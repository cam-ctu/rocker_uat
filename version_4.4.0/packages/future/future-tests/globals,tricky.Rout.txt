
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:32.814] plan(): Setting new future strategy stack:
[09:31:32.814] List of future strategies:
[09:31:32.814] 1. sequential:
[09:31:32.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.814]    - tweaked: FALSE
[09:31:32.814]    - call: future::plan("sequential")
[09:31:32.825] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[09:31:32.917] plan(): Setting new future strategy stack:
[09:31:32.917] List of future strategies:
[09:31:32.917] 1. sequential:
[09:31:32.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.917]    - tweaked: FALSE
[09:31:32.917]    - call: plan(strategy)
[09:31:32.928] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:32.930] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:32.931] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:32.936] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:32.937] Searching for globals ... DONE
[09:31:32.937] Resolving globals: TRUE
[09:31:32.937] Resolving any globals that are futures ...
[09:31:32.937] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:32.937] Resolving any globals that are futures ... DONE
[09:31:32.937] 
[09:31:32.938] 
[09:31:32.938] getGlobalsAndPackages() ... DONE
[09:31:32.938] run() for ‘Future’ ...
[09:31:32.938] - state: ‘created’
[09:31:32.939] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:32.939] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:32.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:32.939]   - Field: ‘label’
[09:31:32.939]   - Field: ‘local’
[09:31:32.939]   - Field: ‘owner’
[09:31:32.939]   - Field: ‘envir’
[09:31:32.939]   - Field: ‘packages’
[09:31:32.940]   - Field: ‘gc’
[09:31:32.940]   - Field: ‘conditions’
[09:31:32.940]   - Field: ‘expr’
[09:31:32.940]   - Field: ‘uuid’
[09:31:32.940]   - Field: ‘seed’
[09:31:32.940]   - Field: ‘version’
[09:31:32.940]   - Field: ‘result’
[09:31:32.940]   - Field: ‘asynchronous’
[09:31:32.940]   - Field: ‘calls’
[09:31:32.940]   - Field: ‘globals’
[09:31:32.940]   - Field: ‘stdout’
[09:31:32.941]   - Field: ‘earlySignal’
[09:31:32.941]   - Field: ‘lazy’
[09:31:32.941]   - Field: ‘state’
[09:31:32.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:32.941] - Launch lazy future ...
[09:31:32.942] Packages needed by the future expression (n = 0): <none>
[09:31:32.942] Packages needed by future strategies (n = 0): <none>
[09:31:32.942] {
[09:31:32.942]     {
[09:31:32.942]         {
[09:31:32.942]             ...future.startTime <- base::Sys.time()
[09:31:32.942]             {
[09:31:32.942]                 {
[09:31:32.942]                   {
[09:31:32.942]                     base::local({
[09:31:32.942]                       has_future <- base::requireNamespace("future", 
[09:31:32.942]                         quietly = TRUE)
[09:31:32.942]                       if (has_future) {
[09:31:32.942]                         ns <- base::getNamespace("future")
[09:31:32.942]                         version <- ns[[".package"]][["version"]]
[09:31:32.942]                         if (is.null(version)) 
[09:31:32.942]                           version <- utils::packageVersion("future")
[09:31:32.942]                       }
[09:31:32.942]                       else {
[09:31:32.942]                         version <- NULL
[09:31:32.942]                       }
[09:31:32.942]                       if (!has_future || version < "1.8.0") {
[09:31:32.942]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:32.942]                           "", base::R.version$version.string), 
[09:31:32.942]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:32.942]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:32.942]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:32.942]                             "release", "version")], collapse = " "), 
[09:31:32.942]                           hostname = base::Sys.info()[["nodename"]])
[09:31:32.942]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:32.942]                           info)
[09:31:32.942]                         info <- base::paste(info, collapse = "; ")
[09:31:32.942]                         if (!has_future) {
[09:31:32.942]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:32.942]                             info)
[09:31:32.942]                         }
[09:31:32.942]                         else {
[09:31:32.942]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:32.942]                             info, version)
[09:31:32.942]                         }
[09:31:32.942]                         base::stop(msg)
[09:31:32.942]                       }
[09:31:32.942]                     })
[09:31:32.942]                   }
[09:31:32.942]                   ...future.strategy.old <- future::plan("list")
[09:31:32.942]                   options(future.plan = NULL)
[09:31:32.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:32.942]                 }
[09:31:32.942]                 ...future.workdir <- getwd()
[09:31:32.942]             }
[09:31:32.942]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:32.942]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:32.942]         }
[09:31:32.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:32.942]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:32.942]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:32.942]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:32.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:32.942]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:32.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:32.942]             base::names(...future.oldOptions))
[09:31:32.942]     }
[09:31:32.942]     if (FALSE) {
[09:31:32.942]     }
[09:31:32.942]     else {
[09:31:32.942]         if (TRUE) {
[09:31:32.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:32.942]                 open = "w")
[09:31:32.942]         }
[09:31:32.942]         else {
[09:31:32.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:32.942]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:32.942]         }
[09:31:32.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:32.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:32.942]             base::sink(type = "output", split = FALSE)
[09:31:32.942]             base::close(...future.stdout)
[09:31:32.942]         }, add = TRUE)
[09:31:32.942]     }
[09:31:32.942]     ...future.frame <- base::sys.nframe()
[09:31:32.942]     ...future.conditions <- base::list()
[09:31:32.942]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:32.942]     if (FALSE) {
[09:31:32.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:32.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:32.942]     }
[09:31:32.942]     ...future.result <- base::tryCatch({
[09:31:32.942]         base::withCallingHandlers({
[09:31:32.942]             ...future.value <- base::withVisible(base::local({
[09:31:32.942]                 b <- a
[09:31:32.942]                 a <- 2
[09:31:32.942]                 a * b
[09:31:32.942]             }))
[09:31:32.942]             future::FutureResult(value = ...future.value$value, 
[09:31:32.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.942]                   ...future.rng), globalenv = if (FALSE) 
[09:31:32.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:32.942]                     ...future.globalenv.names))
[09:31:32.942]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:32.942]         }, condition = base::local({
[09:31:32.942]             c <- base::c
[09:31:32.942]             inherits <- base::inherits
[09:31:32.942]             invokeRestart <- base::invokeRestart
[09:31:32.942]             length <- base::length
[09:31:32.942]             list <- base::list
[09:31:32.942]             seq.int <- base::seq.int
[09:31:32.942]             signalCondition <- base::signalCondition
[09:31:32.942]             sys.calls <- base::sys.calls
[09:31:32.942]             `[[` <- base::`[[`
[09:31:32.942]             `+` <- base::`+`
[09:31:32.942]             `<<-` <- base::`<<-`
[09:31:32.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:32.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:32.942]                   3L)]
[09:31:32.942]             }
[09:31:32.942]             function(cond) {
[09:31:32.942]                 is_error <- inherits(cond, "error")
[09:31:32.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:32.942]                   NULL)
[09:31:32.942]                 if (is_error) {
[09:31:32.942]                   sessionInformation <- function() {
[09:31:32.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:32.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:32.942]                       search = base::search(), system = base::Sys.info())
[09:31:32.942]                   }
[09:31:32.942]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:32.942]                     cond$call), session = sessionInformation(), 
[09:31:32.942]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:32.942]                   signalCondition(cond)
[09:31:32.942]                 }
[09:31:32.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:32.942]                 "immediateCondition"))) {
[09:31:32.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:32.942]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:32.942]                   if (TRUE && !signal) {
[09:31:32.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.942]                     {
[09:31:32.942]                       inherits <- base::inherits
[09:31:32.942]                       invokeRestart <- base::invokeRestart
[09:31:32.942]                       is.null <- base::is.null
[09:31:32.942]                       muffled <- FALSE
[09:31:32.942]                       if (inherits(cond, "message")) {
[09:31:32.942]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.942]                         if (muffled) 
[09:31:32.942]                           invokeRestart("muffleMessage")
[09:31:32.942]                       }
[09:31:32.942]                       else if (inherits(cond, "warning")) {
[09:31:32.942]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.942]                         if (muffled) 
[09:31:32.942]                           invokeRestart("muffleWarning")
[09:31:32.942]                       }
[09:31:32.942]                       else if (inherits(cond, "condition")) {
[09:31:32.942]                         if (!is.null(pattern)) {
[09:31:32.942]                           computeRestarts <- base::computeRestarts
[09:31:32.942]                           grepl <- base::grepl
[09:31:32.942]                           restarts <- computeRestarts(cond)
[09:31:32.942]                           for (restart in restarts) {
[09:31:32.942]                             name <- restart$name
[09:31:32.942]                             if (is.null(name)) 
[09:31:32.942]                               next
[09:31:32.942]                             if (!grepl(pattern, name)) 
[09:31:32.942]                               next
[09:31:32.942]                             invokeRestart(restart)
[09:31:32.942]                             muffled <- TRUE
[09:31:32.942]                             break
[09:31:32.942]                           }
[09:31:32.942]                         }
[09:31:32.942]                       }
[09:31:32.942]                       invisible(muffled)
[09:31:32.942]                     }
[09:31:32.942]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.942]                   }
[09:31:32.942]                 }
[09:31:32.942]                 else {
[09:31:32.942]                   if (TRUE) {
[09:31:32.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.942]                     {
[09:31:32.942]                       inherits <- base::inherits
[09:31:32.942]                       invokeRestart <- base::invokeRestart
[09:31:32.942]                       is.null <- base::is.null
[09:31:32.942]                       muffled <- FALSE
[09:31:32.942]                       if (inherits(cond, "message")) {
[09:31:32.942]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.942]                         if (muffled) 
[09:31:32.942]                           invokeRestart("muffleMessage")
[09:31:32.942]                       }
[09:31:32.942]                       else if (inherits(cond, "warning")) {
[09:31:32.942]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.942]                         if (muffled) 
[09:31:32.942]                           invokeRestart("muffleWarning")
[09:31:32.942]                       }
[09:31:32.942]                       else if (inherits(cond, "condition")) {
[09:31:32.942]                         if (!is.null(pattern)) {
[09:31:32.942]                           computeRestarts <- base::computeRestarts
[09:31:32.942]                           grepl <- base::grepl
[09:31:32.942]                           restarts <- computeRestarts(cond)
[09:31:32.942]                           for (restart in restarts) {
[09:31:32.942]                             name <- restart$name
[09:31:32.942]                             if (is.null(name)) 
[09:31:32.942]                               next
[09:31:32.942]                             if (!grepl(pattern, name)) 
[09:31:32.942]                               next
[09:31:32.942]                             invokeRestart(restart)
[09:31:32.942]                             muffled <- TRUE
[09:31:32.942]                             break
[09:31:32.942]                           }
[09:31:32.942]                         }
[09:31:32.942]                       }
[09:31:32.942]                       invisible(muffled)
[09:31:32.942]                     }
[09:31:32.942]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.942]                   }
[09:31:32.942]                 }
[09:31:32.942]             }
[09:31:32.942]         }))
[09:31:32.942]     }, error = function(ex) {
[09:31:32.942]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:32.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.942]                 ...future.rng), started = ...future.startTime, 
[09:31:32.942]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:32.942]             version = "1.8"), class = "FutureResult")
[09:31:32.942]     }, finally = {
[09:31:32.942]         if (!identical(...future.workdir, getwd())) 
[09:31:32.942]             setwd(...future.workdir)
[09:31:32.942]         {
[09:31:32.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:32.942]                 ...future.oldOptions$nwarnings <- NULL
[09:31:32.942]             }
[09:31:32.942]             base::options(...future.oldOptions)
[09:31:32.942]             if (.Platform$OS.type == "windows") {
[09:31:32.942]                 old_names <- names(...future.oldEnvVars)
[09:31:32.942]                 envs <- base::Sys.getenv()
[09:31:32.942]                 names <- names(envs)
[09:31:32.942]                 common <- intersect(names, old_names)
[09:31:32.942]                 added <- setdiff(names, old_names)
[09:31:32.942]                 removed <- setdiff(old_names, names)
[09:31:32.942]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:32.942]                   envs[common]]
[09:31:32.942]                 NAMES <- toupper(changed)
[09:31:32.942]                 args <- list()
[09:31:32.942]                 for (kk in seq_along(NAMES)) {
[09:31:32.942]                   name <- changed[[kk]]
[09:31:32.942]                   NAME <- NAMES[[kk]]
[09:31:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.942]                     next
[09:31:32.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.942]                 }
[09:31:32.942]                 NAMES <- toupper(added)
[09:31:32.942]                 for (kk in seq_along(NAMES)) {
[09:31:32.942]                   name <- added[[kk]]
[09:31:32.942]                   NAME <- NAMES[[kk]]
[09:31:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.942]                     next
[09:31:32.942]                   args[[name]] <- ""
[09:31:32.942]                 }
[09:31:32.942]                 NAMES <- toupper(removed)
[09:31:32.942]                 for (kk in seq_along(NAMES)) {
[09:31:32.942]                   name <- removed[[kk]]
[09:31:32.942]                   NAME <- NAMES[[kk]]
[09:31:32.942]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.942]                     next
[09:31:32.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.942]                 }
[09:31:32.942]                 if (length(args) > 0) 
[09:31:32.942]                   base::do.call(base::Sys.setenv, args = args)
[09:31:32.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:32.942]             }
[09:31:32.942]             else {
[09:31:32.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:32.942]             }
[09:31:32.942]             {
[09:31:32.942]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:32.942]                   0L) {
[09:31:32.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:32.942]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:32.942]                   base::options(opts)
[09:31:32.942]                 }
[09:31:32.942]                 {
[09:31:32.942]                   {
[09:31:32.942]                     NULL
[09:31:32.942]                     RNGkind("Mersenne-Twister")
[09:31:32.942]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:32.942]                       inherits = FALSE)
[09:31:32.942]                   }
[09:31:32.942]                   options(future.plan = NULL)
[09:31:32.942]                   if (is.na(NA_character_)) 
[09:31:32.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:32.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:32.942]                     .init = FALSE)
[09:31:32.942]                 }
[09:31:32.942]             }
[09:31:32.942]         }
[09:31:32.942]     })
[09:31:32.942]     if (TRUE) {
[09:31:32.942]         base::sink(type = "output", split = FALSE)
[09:31:32.942]         if (TRUE) {
[09:31:32.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:32.942]         }
[09:31:32.942]         else {
[09:31:32.942]             ...future.result["stdout"] <- base::list(NULL)
[09:31:32.942]         }
[09:31:32.942]         base::close(...future.stdout)
[09:31:32.942]         ...future.stdout <- NULL
[09:31:32.942]     }
[09:31:32.942]     ...future.result$conditions <- ...future.conditions
[09:31:32.942]     ...future.result$finished <- base::Sys.time()
[09:31:32.942]     ...future.result
[09:31:32.942] }
[09:31:32.944] plan(): Setting new future strategy stack:
[09:31:32.944] List of future strategies:
[09:31:32.944] 1. sequential:
[09:31:32.944]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.944]    - tweaked: FALSE
[09:31:32.944]    - call: NULL
[09:31:32.945] plan(): nbrOfWorkers() = 1
[09:31:32.946] plan(): Setting new future strategy stack:
[09:31:32.946] List of future strategies:
[09:31:32.946] 1. sequential:
[09:31:32.946]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.946]    - tweaked: FALSE
[09:31:32.946]    - call: plan(strategy)
[09:31:32.946] plan(): nbrOfWorkers() = 1
[09:31:32.946] SequentialFuture started (and completed)
[09:31:32.947] - Launch lazy future ... done
[09:31:32.947] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:32.948] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:32.948] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:32.949] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:32.949] Searching for globals ... DONE
[09:31:32.949] Resolving globals: TRUE
[09:31:32.949] Resolving any globals that are futures ...
[09:31:32.950] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:32.950] Resolving any globals that are futures ... DONE
[09:31:32.950] 
[09:31:32.950] 
[09:31:32.950] getGlobalsAndPackages() ... DONE
[09:31:32.950] run() for ‘Future’ ...
[09:31:32.950] - state: ‘created’
[09:31:32.951] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:32.951] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:32.951] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:32.951]   - Field: ‘label’
[09:31:32.951]   - Field: ‘local’
[09:31:32.951]   - Field: ‘owner’
[09:31:32.951]   - Field: ‘envir’
[09:31:32.951]   - Field: ‘packages’
[09:31:32.951]   - Field: ‘gc’
[09:31:32.952]   - Field: ‘conditions’
[09:31:32.952]   - Field: ‘expr’
[09:31:32.952]   - Field: ‘uuid’
[09:31:32.952]   - Field: ‘seed’
[09:31:32.952]   - Field: ‘version’
[09:31:32.952]   - Field: ‘result’
[09:31:32.952]   - Field: ‘asynchronous’
[09:31:32.952]   - Field: ‘calls’
[09:31:32.952]   - Field: ‘globals’
[09:31:32.952]   - Field: ‘stdout’
[09:31:32.952]   - Field: ‘earlySignal’
[09:31:32.952]   - Field: ‘lazy’
[09:31:32.953]   - Field: ‘state’
[09:31:32.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:32.953] - Launch lazy future ...
[09:31:32.953] Packages needed by the future expression (n = 0): <none>
[09:31:32.953] Packages needed by future strategies (n = 0): <none>
[09:31:32.953] {
[09:31:32.953]     {
[09:31:32.953]         {
[09:31:32.953]             ...future.startTime <- base::Sys.time()
[09:31:32.953]             {
[09:31:32.953]                 {
[09:31:32.953]                   {
[09:31:32.953]                     base::local({
[09:31:32.953]                       has_future <- base::requireNamespace("future", 
[09:31:32.953]                         quietly = TRUE)
[09:31:32.953]                       if (has_future) {
[09:31:32.953]                         ns <- base::getNamespace("future")
[09:31:32.953]                         version <- ns[[".package"]][["version"]]
[09:31:32.953]                         if (is.null(version)) 
[09:31:32.953]                           version <- utils::packageVersion("future")
[09:31:32.953]                       }
[09:31:32.953]                       else {
[09:31:32.953]                         version <- NULL
[09:31:32.953]                       }
[09:31:32.953]                       if (!has_future || version < "1.8.0") {
[09:31:32.953]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:32.953]                           "", base::R.version$version.string), 
[09:31:32.953]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:32.953]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:32.953]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:32.953]                             "release", "version")], collapse = " "), 
[09:31:32.953]                           hostname = base::Sys.info()[["nodename"]])
[09:31:32.953]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:32.953]                           info)
[09:31:32.953]                         info <- base::paste(info, collapse = "; ")
[09:31:32.953]                         if (!has_future) {
[09:31:32.953]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:32.953]                             info)
[09:31:32.953]                         }
[09:31:32.953]                         else {
[09:31:32.953]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:32.953]                             info, version)
[09:31:32.953]                         }
[09:31:32.953]                         base::stop(msg)
[09:31:32.953]                       }
[09:31:32.953]                     })
[09:31:32.953]                   }
[09:31:32.953]                   ...future.strategy.old <- future::plan("list")
[09:31:32.953]                   options(future.plan = NULL)
[09:31:32.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:32.953]                 }
[09:31:32.953]                 ...future.workdir <- getwd()
[09:31:32.953]             }
[09:31:32.953]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:32.953]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:32.953]         }
[09:31:32.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:32.953]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:32.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:32.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:32.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:32.953]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:32.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:32.953]             base::names(...future.oldOptions))
[09:31:32.953]     }
[09:31:32.953]     if (FALSE) {
[09:31:32.953]     }
[09:31:32.953]     else {
[09:31:32.953]         if (TRUE) {
[09:31:32.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:32.953]                 open = "w")
[09:31:32.953]         }
[09:31:32.953]         else {
[09:31:32.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:32.953]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:32.953]         }
[09:31:32.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:32.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:32.953]             base::sink(type = "output", split = FALSE)
[09:31:32.953]             base::close(...future.stdout)
[09:31:32.953]         }, add = TRUE)
[09:31:32.953]     }
[09:31:32.953]     ...future.frame <- base::sys.nframe()
[09:31:32.953]     ...future.conditions <- base::list()
[09:31:32.953]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:32.953]     if (FALSE) {
[09:31:32.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:32.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:32.953]     }
[09:31:32.953]     ...future.result <- base::tryCatch({
[09:31:32.953]         base::withCallingHandlers({
[09:31:32.953]             ...future.value <- base::withVisible(base::local({
[09:31:32.953]                 b <- a
[09:31:32.953]                 a <- 2
[09:31:32.953]                 a * b
[09:31:32.953]             }))
[09:31:32.953]             future::FutureResult(value = ...future.value$value, 
[09:31:32.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.953]                   ...future.rng), globalenv = if (FALSE) 
[09:31:32.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:32.953]                     ...future.globalenv.names))
[09:31:32.953]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:32.953]         }, condition = base::local({
[09:31:32.953]             c <- base::c
[09:31:32.953]             inherits <- base::inherits
[09:31:32.953]             invokeRestart <- base::invokeRestart
[09:31:32.953]             length <- base::length
[09:31:32.953]             list <- base::list
[09:31:32.953]             seq.int <- base::seq.int
[09:31:32.953]             signalCondition <- base::signalCondition
[09:31:32.953]             sys.calls <- base::sys.calls
[09:31:32.953]             `[[` <- base::`[[`
[09:31:32.953]             `+` <- base::`+`
[09:31:32.953]             `<<-` <- base::`<<-`
[09:31:32.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:32.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:32.953]                   3L)]
[09:31:32.953]             }
[09:31:32.953]             function(cond) {
[09:31:32.953]                 is_error <- inherits(cond, "error")
[09:31:32.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:32.953]                   NULL)
[09:31:32.953]                 if (is_error) {
[09:31:32.953]                   sessionInformation <- function() {
[09:31:32.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:32.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:32.953]                       search = base::search(), system = base::Sys.info())
[09:31:32.953]                   }
[09:31:32.953]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:32.953]                     cond$call), session = sessionInformation(), 
[09:31:32.953]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:32.953]                   signalCondition(cond)
[09:31:32.953]                 }
[09:31:32.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:32.953]                 "immediateCondition"))) {
[09:31:32.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:32.953]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:32.953]                   if (TRUE && !signal) {
[09:31:32.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.953]                     {
[09:31:32.953]                       inherits <- base::inherits
[09:31:32.953]                       invokeRestart <- base::invokeRestart
[09:31:32.953]                       is.null <- base::is.null
[09:31:32.953]                       muffled <- FALSE
[09:31:32.953]                       if (inherits(cond, "message")) {
[09:31:32.953]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.953]                         if (muffled) 
[09:31:32.953]                           invokeRestart("muffleMessage")
[09:31:32.953]                       }
[09:31:32.953]                       else if (inherits(cond, "warning")) {
[09:31:32.953]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.953]                         if (muffled) 
[09:31:32.953]                           invokeRestart("muffleWarning")
[09:31:32.953]                       }
[09:31:32.953]                       else if (inherits(cond, "condition")) {
[09:31:32.953]                         if (!is.null(pattern)) {
[09:31:32.953]                           computeRestarts <- base::computeRestarts
[09:31:32.953]                           grepl <- base::grepl
[09:31:32.953]                           restarts <- computeRestarts(cond)
[09:31:32.953]                           for (restart in restarts) {
[09:31:32.953]                             name <- restart$name
[09:31:32.953]                             if (is.null(name)) 
[09:31:32.953]                               next
[09:31:32.953]                             if (!grepl(pattern, name)) 
[09:31:32.953]                               next
[09:31:32.953]                             invokeRestart(restart)
[09:31:32.953]                             muffled <- TRUE
[09:31:32.953]                             break
[09:31:32.953]                           }
[09:31:32.953]                         }
[09:31:32.953]                       }
[09:31:32.953]                       invisible(muffled)
[09:31:32.953]                     }
[09:31:32.953]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.953]                   }
[09:31:32.953]                 }
[09:31:32.953]                 else {
[09:31:32.953]                   if (TRUE) {
[09:31:32.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.953]                     {
[09:31:32.953]                       inherits <- base::inherits
[09:31:32.953]                       invokeRestart <- base::invokeRestart
[09:31:32.953]                       is.null <- base::is.null
[09:31:32.953]                       muffled <- FALSE
[09:31:32.953]                       if (inherits(cond, "message")) {
[09:31:32.953]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.953]                         if (muffled) 
[09:31:32.953]                           invokeRestart("muffleMessage")
[09:31:32.953]                       }
[09:31:32.953]                       else if (inherits(cond, "warning")) {
[09:31:32.953]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.953]                         if (muffled) 
[09:31:32.953]                           invokeRestart("muffleWarning")
[09:31:32.953]                       }
[09:31:32.953]                       else if (inherits(cond, "condition")) {
[09:31:32.953]                         if (!is.null(pattern)) {
[09:31:32.953]                           computeRestarts <- base::computeRestarts
[09:31:32.953]                           grepl <- base::grepl
[09:31:32.953]                           restarts <- computeRestarts(cond)
[09:31:32.953]                           for (restart in restarts) {
[09:31:32.953]                             name <- restart$name
[09:31:32.953]                             if (is.null(name)) 
[09:31:32.953]                               next
[09:31:32.953]                             if (!grepl(pattern, name)) 
[09:31:32.953]                               next
[09:31:32.953]                             invokeRestart(restart)
[09:31:32.953]                             muffled <- TRUE
[09:31:32.953]                             break
[09:31:32.953]                           }
[09:31:32.953]                         }
[09:31:32.953]                       }
[09:31:32.953]                       invisible(muffled)
[09:31:32.953]                     }
[09:31:32.953]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.953]                   }
[09:31:32.953]                 }
[09:31:32.953]             }
[09:31:32.953]         }))
[09:31:32.953]     }, error = function(ex) {
[09:31:32.953]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:32.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.953]                 ...future.rng), started = ...future.startTime, 
[09:31:32.953]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:32.953]             version = "1.8"), class = "FutureResult")
[09:31:32.953]     }, finally = {
[09:31:32.953]         if (!identical(...future.workdir, getwd())) 
[09:31:32.953]             setwd(...future.workdir)
[09:31:32.953]         {
[09:31:32.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:32.953]                 ...future.oldOptions$nwarnings <- NULL
[09:31:32.953]             }
[09:31:32.953]             base::options(...future.oldOptions)
[09:31:32.953]             if (.Platform$OS.type == "windows") {
[09:31:32.953]                 old_names <- names(...future.oldEnvVars)
[09:31:32.953]                 envs <- base::Sys.getenv()
[09:31:32.953]                 names <- names(envs)
[09:31:32.953]                 common <- intersect(names, old_names)
[09:31:32.953]                 added <- setdiff(names, old_names)
[09:31:32.953]                 removed <- setdiff(old_names, names)
[09:31:32.953]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:32.953]                   envs[common]]
[09:31:32.953]                 NAMES <- toupper(changed)
[09:31:32.953]                 args <- list()
[09:31:32.953]                 for (kk in seq_along(NAMES)) {
[09:31:32.953]                   name <- changed[[kk]]
[09:31:32.953]                   NAME <- NAMES[[kk]]
[09:31:32.953]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.953]                     next
[09:31:32.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.953]                 }
[09:31:32.953]                 NAMES <- toupper(added)
[09:31:32.953]                 for (kk in seq_along(NAMES)) {
[09:31:32.953]                   name <- added[[kk]]
[09:31:32.953]                   NAME <- NAMES[[kk]]
[09:31:32.953]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.953]                     next
[09:31:32.953]                   args[[name]] <- ""
[09:31:32.953]                 }
[09:31:32.953]                 NAMES <- toupper(removed)
[09:31:32.953]                 for (kk in seq_along(NAMES)) {
[09:31:32.953]                   name <- removed[[kk]]
[09:31:32.953]                   NAME <- NAMES[[kk]]
[09:31:32.953]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.953]                     next
[09:31:32.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.953]                 }
[09:31:32.953]                 if (length(args) > 0) 
[09:31:32.953]                   base::do.call(base::Sys.setenv, args = args)
[09:31:32.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:32.953]             }
[09:31:32.953]             else {
[09:31:32.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:32.953]             }
[09:31:32.953]             {
[09:31:32.953]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:32.953]                   0L) {
[09:31:32.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:32.953]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:32.953]                   base::options(opts)
[09:31:32.953]                 }
[09:31:32.953]                 {
[09:31:32.953]                   {
[09:31:32.953]                     NULL
[09:31:32.953]                     RNGkind("Mersenne-Twister")
[09:31:32.953]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:32.953]                       inherits = FALSE)
[09:31:32.953]                   }
[09:31:32.953]                   options(future.plan = NULL)
[09:31:32.953]                   if (is.na(NA_character_)) 
[09:31:32.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:32.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:32.953]                     .init = FALSE)
[09:31:32.953]                 }
[09:31:32.953]             }
[09:31:32.953]         }
[09:31:32.953]     })
[09:31:32.953]     if (TRUE) {
[09:31:32.953]         base::sink(type = "output", split = FALSE)
[09:31:32.953]         if (TRUE) {
[09:31:32.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:32.953]         }
[09:31:32.953]         else {
[09:31:32.953]             ...future.result["stdout"] <- base::list(NULL)
[09:31:32.953]         }
[09:31:32.953]         base::close(...future.stdout)
[09:31:32.953]         ...future.stdout <- NULL
[09:31:32.953]     }
[09:31:32.953]     ...future.result$conditions <- ...future.conditions
[09:31:32.953]     ...future.result$finished <- base::Sys.time()
[09:31:32.953]     ...future.result
[09:31:32.953] }
[09:31:32.955] plan(): Setting new future strategy stack:
[09:31:32.955] List of future strategies:
[09:31:32.955] 1. sequential:
[09:31:32.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.955]    - tweaked: FALSE
[09:31:32.955]    - call: NULL
[09:31:32.956] plan(): nbrOfWorkers() = 1
[09:31:32.956] plan(): Setting new future strategy stack:
[09:31:32.957] List of future strategies:
[09:31:32.957] 1. sequential:
[09:31:32.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.957]    - tweaked: FALSE
[09:31:32.957]    - call: plan(strategy)
[09:31:32.957] plan(): nbrOfWorkers() = 1
[09:31:32.957] SequentialFuture started (and completed)
[09:31:32.957] signalConditions() ...
[09:31:32.957]  - include = ‘immediateCondition’
[09:31:32.957]  - exclude = 
[09:31:32.958]  - resignal = FALSE
[09:31:32.958]  - Number of conditions: 1
[09:31:32.958] signalConditions() ... done
[09:31:32.958] - Launch lazy future ... done
[09:31:32.958] run() for ‘SequentialFuture’ ... done
[09:31:32.958] signalConditions() ...
[09:31:32.958]  - include = ‘immediateCondition’
[09:31:32.958]  - exclude = 
[09:31:32.958]  - resignal = FALSE
[09:31:32.958]  - Number of conditions: 1
[09:31:32.958] signalConditions() ... done
[09:31:32.959] Future state: ‘finished’
[09:31:32.959] signalConditions() ...
[09:31:32.959]  - include = ‘condition’
[09:31:32.960]  - exclude = ‘immediateCondition’
[09:31:32.960]  - resignal = TRUE
[09:31:32.961]  - Number of conditions: 1
[09:31:32.961]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:32.961] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:32"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:32.976] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:32.976] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:32.977] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:32.977] Searching for globals ... DONE
[09:31:32.977] Resolving globals: TRUE
[09:31:32.978] Resolving any globals that are futures ...
[09:31:32.978] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:32.978] Resolving any globals that are futures ... DONE
[09:31:32.978] Resolving futures part of globals (recursively) ...
[09:31:32.979] resolve() on list ...
[09:31:32.979]  recursive: 99
[09:31:32.979]  length: 1
[09:31:32.979]  elements: ‘ii’
[09:31:32.979]  length: 0 (resolved future 1)
[09:31:32.979] resolve() on list ... DONE
[09:31:32.979] - globals: [1] ‘ii’
[09:31:32.979] Resolving futures part of globals (recursively) ... DONE
[09:31:32.980] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:32.980] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:32.980] - globals: [1] ‘ii’
[09:31:32.981] 
[09:31:32.981] getGlobalsAndPackages() ... DONE
[09:31:32.981] run() for ‘Future’ ...
[09:31:32.981] - state: ‘created’
[09:31:32.981] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:32.981] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:32.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:32.982]   - Field: ‘label’
[09:31:32.982]   - Field: ‘local’
[09:31:32.982]   - Field: ‘owner’
[09:31:32.982]   - Field: ‘envir’
[09:31:32.982]   - Field: ‘packages’
[09:31:32.982]   - Field: ‘gc’
[09:31:32.982]   - Field: ‘conditions’
[09:31:32.982]   - Field: ‘expr’
[09:31:32.982]   - Field: ‘uuid’
[09:31:32.982]   - Field: ‘seed’
[09:31:32.982]   - Field: ‘version’
[09:31:32.982]   - Field: ‘result’
[09:31:32.983]   - Field: ‘asynchronous’
[09:31:32.983]   - Field: ‘calls’
[09:31:32.983]   - Field: ‘globals’
[09:31:32.983]   - Field: ‘stdout’
[09:31:32.983]   - Field: ‘earlySignal’
[09:31:32.983]   - Field: ‘lazy’
[09:31:32.983]   - Field: ‘state’
[09:31:32.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:32.983] - Launch lazy future ...
[09:31:32.983] Packages needed by the future expression (n = 0): <none>
[09:31:32.984] Packages needed by future strategies (n = 0): <none>
[09:31:32.984] {
[09:31:32.984]     {
[09:31:32.984]         {
[09:31:32.984]             ...future.startTime <- base::Sys.time()
[09:31:32.984]             {
[09:31:32.984]                 {
[09:31:32.984]                   {
[09:31:32.984]                     base::local({
[09:31:32.984]                       has_future <- base::requireNamespace("future", 
[09:31:32.984]                         quietly = TRUE)
[09:31:32.984]                       if (has_future) {
[09:31:32.984]                         ns <- base::getNamespace("future")
[09:31:32.984]                         version <- ns[[".package"]][["version"]]
[09:31:32.984]                         if (is.null(version)) 
[09:31:32.984]                           version <- utils::packageVersion("future")
[09:31:32.984]                       }
[09:31:32.984]                       else {
[09:31:32.984]                         version <- NULL
[09:31:32.984]                       }
[09:31:32.984]                       if (!has_future || version < "1.8.0") {
[09:31:32.984]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:32.984]                           "", base::R.version$version.string), 
[09:31:32.984]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:32.984]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:32.984]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:32.984]                             "release", "version")], collapse = " "), 
[09:31:32.984]                           hostname = base::Sys.info()[["nodename"]])
[09:31:32.984]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:32.984]                           info)
[09:31:32.984]                         info <- base::paste(info, collapse = "; ")
[09:31:32.984]                         if (!has_future) {
[09:31:32.984]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:32.984]                             info)
[09:31:32.984]                         }
[09:31:32.984]                         else {
[09:31:32.984]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:32.984]                             info, version)
[09:31:32.984]                         }
[09:31:32.984]                         base::stop(msg)
[09:31:32.984]                       }
[09:31:32.984]                     })
[09:31:32.984]                   }
[09:31:32.984]                   ...future.strategy.old <- future::plan("list")
[09:31:32.984]                   options(future.plan = NULL)
[09:31:32.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:32.984]                 }
[09:31:32.984]                 ...future.workdir <- getwd()
[09:31:32.984]             }
[09:31:32.984]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:32.984]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:32.984]         }
[09:31:32.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:32.984]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:32.984]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:32.984]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:32.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:32.984]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:32.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:32.984]             base::names(...future.oldOptions))
[09:31:32.984]     }
[09:31:32.984]     if (FALSE) {
[09:31:32.984]     }
[09:31:32.984]     else {
[09:31:32.984]         if (TRUE) {
[09:31:32.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:32.984]                 open = "w")
[09:31:32.984]         }
[09:31:32.984]         else {
[09:31:32.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:32.984]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:32.984]         }
[09:31:32.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:32.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:32.984]             base::sink(type = "output", split = FALSE)
[09:31:32.984]             base::close(...future.stdout)
[09:31:32.984]         }, add = TRUE)
[09:31:32.984]     }
[09:31:32.984]     ...future.frame <- base::sys.nframe()
[09:31:32.984]     ...future.conditions <- base::list()
[09:31:32.984]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:32.984]     if (FALSE) {
[09:31:32.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:32.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:32.984]     }
[09:31:32.984]     ...future.result <- base::tryCatch({
[09:31:32.984]         base::withCallingHandlers({
[09:31:32.984]             ...future.value <- base::withVisible(base::local({
[09:31:32.984]                 b <- a * ii
[09:31:32.984]                 a <- 0
[09:31:32.984]                 b
[09:31:32.984]             }))
[09:31:32.984]             future::FutureResult(value = ...future.value$value, 
[09:31:32.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.984]                   ...future.rng), globalenv = if (FALSE) 
[09:31:32.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:32.984]                     ...future.globalenv.names))
[09:31:32.984]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:32.984]         }, condition = base::local({
[09:31:32.984]             c <- base::c
[09:31:32.984]             inherits <- base::inherits
[09:31:32.984]             invokeRestart <- base::invokeRestart
[09:31:32.984]             length <- base::length
[09:31:32.984]             list <- base::list
[09:31:32.984]             seq.int <- base::seq.int
[09:31:32.984]             signalCondition <- base::signalCondition
[09:31:32.984]             sys.calls <- base::sys.calls
[09:31:32.984]             `[[` <- base::`[[`
[09:31:32.984]             `+` <- base::`+`
[09:31:32.984]             `<<-` <- base::`<<-`
[09:31:32.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:32.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:32.984]                   3L)]
[09:31:32.984]             }
[09:31:32.984]             function(cond) {
[09:31:32.984]                 is_error <- inherits(cond, "error")
[09:31:32.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:32.984]                   NULL)
[09:31:32.984]                 if (is_error) {
[09:31:32.984]                   sessionInformation <- function() {
[09:31:32.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:32.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:32.984]                       search = base::search(), system = base::Sys.info())
[09:31:32.984]                   }
[09:31:32.984]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:32.984]                     cond$call), session = sessionInformation(), 
[09:31:32.984]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:32.984]                   signalCondition(cond)
[09:31:32.984]                 }
[09:31:32.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:32.984]                 "immediateCondition"))) {
[09:31:32.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:32.984]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:32.984]                   if (TRUE && !signal) {
[09:31:32.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.984]                     {
[09:31:32.984]                       inherits <- base::inherits
[09:31:32.984]                       invokeRestart <- base::invokeRestart
[09:31:32.984]                       is.null <- base::is.null
[09:31:32.984]                       muffled <- FALSE
[09:31:32.984]                       if (inherits(cond, "message")) {
[09:31:32.984]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.984]                         if (muffled) 
[09:31:32.984]                           invokeRestart("muffleMessage")
[09:31:32.984]                       }
[09:31:32.984]                       else if (inherits(cond, "warning")) {
[09:31:32.984]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.984]                         if (muffled) 
[09:31:32.984]                           invokeRestart("muffleWarning")
[09:31:32.984]                       }
[09:31:32.984]                       else if (inherits(cond, "condition")) {
[09:31:32.984]                         if (!is.null(pattern)) {
[09:31:32.984]                           computeRestarts <- base::computeRestarts
[09:31:32.984]                           grepl <- base::grepl
[09:31:32.984]                           restarts <- computeRestarts(cond)
[09:31:32.984]                           for (restart in restarts) {
[09:31:32.984]                             name <- restart$name
[09:31:32.984]                             if (is.null(name)) 
[09:31:32.984]                               next
[09:31:32.984]                             if (!grepl(pattern, name)) 
[09:31:32.984]                               next
[09:31:32.984]                             invokeRestart(restart)
[09:31:32.984]                             muffled <- TRUE
[09:31:32.984]                             break
[09:31:32.984]                           }
[09:31:32.984]                         }
[09:31:32.984]                       }
[09:31:32.984]                       invisible(muffled)
[09:31:32.984]                     }
[09:31:32.984]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.984]                   }
[09:31:32.984]                 }
[09:31:32.984]                 else {
[09:31:32.984]                   if (TRUE) {
[09:31:32.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.984]                     {
[09:31:32.984]                       inherits <- base::inherits
[09:31:32.984]                       invokeRestart <- base::invokeRestart
[09:31:32.984]                       is.null <- base::is.null
[09:31:32.984]                       muffled <- FALSE
[09:31:32.984]                       if (inherits(cond, "message")) {
[09:31:32.984]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.984]                         if (muffled) 
[09:31:32.984]                           invokeRestart("muffleMessage")
[09:31:32.984]                       }
[09:31:32.984]                       else if (inherits(cond, "warning")) {
[09:31:32.984]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.984]                         if (muffled) 
[09:31:32.984]                           invokeRestart("muffleWarning")
[09:31:32.984]                       }
[09:31:32.984]                       else if (inherits(cond, "condition")) {
[09:31:32.984]                         if (!is.null(pattern)) {
[09:31:32.984]                           computeRestarts <- base::computeRestarts
[09:31:32.984]                           grepl <- base::grepl
[09:31:32.984]                           restarts <- computeRestarts(cond)
[09:31:32.984]                           for (restart in restarts) {
[09:31:32.984]                             name <- restart$name
[09:31:32.984]                             if (is.null(name)) 
[09:31:32.984]                               next
[09:31:32.984]                             if (!grepl(pattern, name)) 
[09:31:32.984]                               next
[09:31:32.984]                             invokeRestart(restart)
[09:31:32.984]                             muffled <- TRUE
[09:31:32.984]                             break
[09:31:32.984]                           }
[09:31:32.984]                         }
[09:31:32.984]                       }
[09:31:32.984]                       invisible(muffled)
[09:31:32.984]                     }
[09:31:32.984]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.984]                   }
[09:31:32.984]                 }
[09:31:32.984]             }
[09:31:32.984]         }))
[09:31:32.984]     }, error = function(ex) {
[09:31:32.984]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:32.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.984]                 ...future.rng), started = ...future.startTime, 
[09:31:32.984]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:32.984]             version = "1.8"), class = "FutureResult")
[09:31:32.984]     }, finally = {
[09:31:32.984]         if (!identical(...future.workdir, getwd())) 
[09:31:32.984]             setwd(...future.workdir)
[09:31:32.984]         {
[09:31:32.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:32.984]                 ...future.oldOptions$nwarnings <- NULL
[09:31:32.984]             }
[09:31:32.984]             base::options(...future.oldOptions)
[09:31:32.984]             if (.Platform$OS.type == "windows") {
[09:31:32.984]                 old_names <- names(...future.oldEnvVars)
[09:31:32.984]                 envs <- base::Sys.getenv()
[09:31:32.984]                 names <- names(envs)
[09:31:32.984]                 common <- intersect(names, old_names)
[09:31:32.984]                 added <- setdiff(names, old_names)
[09:31:32.984]                 removed <- setdiff(old_names, names)
[09:31:32.984]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:32.984]                   envs[common]]
[09:31:32.984]                 NAMES <- toupper(changed)
[09:31:32.984]                 args <- list()
[09:31:32.984]                 for (kk in seq_along(NAMES)) {
[09:31:32.984]                   name <- changed[[kk]]
[09:31:32.984]                   NAME <- NAMES[[kk]]
[09:31:32.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.984]                     next
[09:31:32.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.984]                 }
[09:31:32.984]                 NAMES <- toupper(added)
[09:31:32.984]                 for (kk in seq_along(NAMES)) {
[09:31:32.984]                   name <- added[[kk]]
[09:31:32.984]                   NAME <- NAMES[[kk]]
[09:31:32.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.984]                     next
[09:31:32.984]                   args[[name]] <- ""
[09:31:32.984]                 }
[09:31:32.984]                 NAMES <- toupper(removed)
[09:31:32.984]                 for (kk in seq_along(NAMES)) {
[09:31:32.984]                   name <- removed[[kk]]
[09:31:32.984]                   NAME <- NAMES[[kk]]
[09:31:32.984]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.984]                     next
[09:31:32.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.984]                 }
[09:31:32.984]                 if (length(args) > 0) 
[09:31:32.984]                   base::do.call(base::Sys.setenv, args = args)
[09:31:32.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:32.984]             }
[09:31:32.984]             else {
[09:31:32.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:32.984]             }
[09:31:32.984]             {
[09:31:32.984]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:32.984]                   0L) {
[09:31:32.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:32.984]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:32.984]                   base::options(opts)
[09:31:32.984]                 }
[09:31:32.984]                 {
[09:31:32.984]                   {
[09:31:32.984]                     NULL
[09:31:32.984]                     RNGkind("Mersenne-Twister")
[09:31:32.984]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:32.984]                       inherits = FALSE)
[09:31:32.984]                   }
[09:31:32.984]                   options(future.plan = NULL)
[09:31:32.984]                   if (is.na(NA_character_)) 
[09:31:32.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:32.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:32.984]                     .init = FALSE)
[09:31:32.984]                 }
[09:31:32.984]             }
[09:31:32.984]         }
[09:31:32.984]     })
[09:31:32.984]     if (TRUE) {
[09:31:32.984]         base::sink(type = "output", split = FALSE)
[09:31:32.984]         if (TRUE) {
[09:31:32.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:32.984]         }
[09:31:32.984]         else {
[09:31:32.984]             ...future.result["stdout"] <- base::list(NULL)
[09:31:32.984]         }
[09:31:32.984]         base::close(...future.stdout)
[09:31:32.984]         ...future.stdout <- NULL
[09:31:32.984]     }
[09:31:32.984]     ...future.result$conditions <- ...future.conditions
[09:31:32.984]     ...future.result$finished <- base::Sys.time()
[09:31:32.984]     ...future.result
[09:31:32.984] }
[09:31:32.985] assign_globals() ...
[09:31:32.986] List of 1
[09:31:32.986]  $ ii: int 1
[09:31:32.986]  - attr(*, "where")=List of 1
[09:31:32.986]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:32.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:32.986]  - attr(*, "resolved")= logi TRUE
[09:31:32.986]  - attr(*, "total_size")= num 56
[09:31:32.986]  - attr(*, "already-done")= logi TRUE
[09:31:32.988] - copied ‘ii’ to environment
[09:31:32.988] assign_globals() ... done
[09:31:32.988] plan(): Setting new future strategy stack:
[09:31:32.988] List of future strategies:
[09:31:32.988] 1. sequential:
[09:31:32.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.988]    - tweaked: FALSE
[09:31:32.988]    - call: NULL
[09:31:32.990] plan(): nbrOfWorkers() = 1
[09:31:32.991] plan(): Setting new future strategy stack:
[09:31:32.991] List of future strategies:
[09:31:32.991] 1. sequential:
[09:31:32.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:32.991]    - tweaked: FALSE
[09:31:32.991]    - call: plan(strategy)
[09:31:32.991] plan(): nbrOfWorkers() = 1
[09:31:32.991] SequentialFuture started (and completed)
[09:31:32.991] - Launch lazy future ... done
[09:31:32.991] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:32.992] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:32.992] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:32.993] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:32.993] Searching for globals ... DONE
[09:31:32.994] Resolving globals: TRUE
[09:31:32.994] Resolving any globals that are futures ...
[09:31:32.994] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:32.994] Resolving any globals that are futures ... DONE
[09:31:32.994] Resolving futures part of globals (recursively) ...
[09:31:32.994] resolve() on list ...
[09:31:32.994]  recursive: 99
[09:31:32.995]  length: 1
[09:31:32.995]  elements: ‘ii’
[09:31:32.995]  length: 0 (resolved future 1)
[09:31:32.995] resolve() on list ... DONE
[09:31:32.995] - globals: [1] ‘ii’
[09:31:32.995] Resolving futures part of globals (recursively) ... DONE
[09:31:32.995] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:32.995] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:32.995] - globals: [1] ‘ii’
[09:31:32.996] 
[09:31:32.996] getGlobalsAndPackages() ... DONE
[09:31:32.996] run() for ‘Future’ ...
[09:31:32.996] - state: ‘created’
[09:31:32.996] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:32.996] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:32.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:32.997]   - Field: ‘label’
[09:31:32.997]   - Field: ‘local’
[09:31:32.997]   - Field: ‘owner’
[09:31:32.997]   - Field: ‘envir’
[09:31:32.997]   - Field: ‘packages’
[09:31:32.997]   - Field: ‘gc’
[09:31:32.997]   - Field: ‘conditions’
[09:31:32.997]   - Field: ‘expr’
[09:31:32.997]   - Field: ‘uuid’
[09:31:32.997]   - Field: ‘seed’
[09:31:32.997]   - Field: ‘version’
[09:31:32.997]   - Field: ‘result’
[09:31:32.998]   - Field: ‘asynchronous’
[09:31:32.998]   - Field: ‘calls’
[09:31:32.998]   - Field: ‘globals’
[09:31:32.998]   - Field: ‘stdout’
[09:31:32.998]   - Field: ‘earlySignal’
[09:31:32.998]   - Field: ‘lazy’
[09:31:32.998]   - Field: ‘state’
[09:31:32.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:32.998] - Launch lazy future ...
[09:31:32.998] Packages needed by the future expression (n = 0): <none>
[09:31:32.999] Packages needed by future strategies (n = 0): <none>
[09:31:32.999] {
[09:31:32.999]     {
[09:31:32.999]         {
[09:31:32.999]             ...future.startTime <- base::Sys.time()
[09:31:32.999]             {
[09:31:32.999]                 {
[09:31:32.999]                   {
[09:31:32.999]                     base::local({
[09:31:32.999]                       has_future <- base::requireNamespace("future", 
[09:31:32.999]                         quietly = TRUE)
[09:31:32.999]                       if (has_future) {
[09:31:32.999]                         ns <- base::getNamespace("future")
[09:31:32.999]                         version <- ns[[".package"]][["version"]]
[09:31:32.999]                         if (is.null(version)) 
[09:31:32.999]                           version <- utils::packageVersion("future")
[09:31:32.999]                       }
[09:31:32.999]                       else {
[09:31:32.999]                         version <- NULL
[09:31:32.999]                       }
[09:31:32.999]                       if (!has_future || version < "1.8.0") {
[09:31:32.999]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:32.999]                           "", base::R.version$version.string), 
[09:31:32.999]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:32.999]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:32.999]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:32.999]                             "release", "version")], collapse = " "), 
[09:31:32.999]                           hostname = base::Sys.info()[["nodename"]])
[09:31:32.999]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:32.999]                           info)
[09:31:32.999]                         info <- base::paste(info, collapse = "; ")
[09:31:32.999]                         if (!has_future) {
[09:31:32.999]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:32.999]                             info)
[09:31:32.999]                         }
[09:31:32.999]                         else {
[09:31:32.999]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:32.999]                             info, version)
[09:31:32.999]                         }
[09:31:32.999]                         base::stop(msg)
[09:31:32.999]                       }
[09:31:32.999]                     })
[09:31:32.999]                   }
[09:31:32.999]                   ...future.strategy.old <- future::plan("list")
[09:31:32.999]                   options(future.plan = NULL)
[09:31:32.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:32.999]                 }
[09:31:32.999]                 ...future.workdir <- getwd()
[09:31:32.999]             }
[09:31:32.999]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:32.999]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:32.999]         }
[09:31:32.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:32.999]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:32.999]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:32.999]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:32.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:32.999]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:32.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:32.999]             base::names(...future.oldOptions))
[09:31:32.999]     }
[09:31:32.999]     if (FALSE) {
[09:31:32.999]     }
[09:31:32.999]     else {
[09:31:32.999]         if (TRUE) {
[09:31:32.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:32.999]                 open = "w")
[09:31:32.999]         }
[09:31:32.999]         else {
[09:31:32.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:32.999]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:32.999]         }
[09:31:32.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:32.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:32.999]             base::sink(type = "output", split = FALSE)
[09:31:32.999]             base::close(...future.stdout)
[09:31:32.999]         }, add = TRUE)
[09:31:32.999]     }
[09:31:32.999]     ...future.frame <- base::sys.nframe()
[09:31:32.999]     ...future.conditions <- base::list()
[09:31:32.999]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:32.999]     if (FALSE) {
[09:31:32.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:32.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:32.999]     }
[09:31:32.999]     ...future.result <- base::tryCatch({
[09:31:32.999]         base::withCallingHandlers({
[09:31:32.999]             ...future.value <- base::withVisible(base::local({
[09:31:32.999]                 b <- a * ii
[09:31:32.999]                 a <- 0
[09:31:32.999]                 b
[09:31:32.999]             }))
[09:31:32.999]             future::FutureResult(value = ...future.value$value, 
[09:31:32.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.999]                   ...future.rng), globalenv = if (FALSE) 
[09:31:32.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:32.999]                     ...future.globalenv.names))
[09:31:32.999]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:32.999]         }, condition = base::local({
[09:31:32.999]             c <- base::c
[09:31:32.999]             inherits <- base::inherits
[09:31:32.999]             invokeRestart <- base::invokeRestart
[09:31:32.999]             length <- base::length
[09:31:32.999]             list <- base::list
[09:31:32.999]             seq.int <- base::seq.int
[09:31:32.999]             signalCondition <- base::signalCondition
[09:31:32.999]             sys.calls <- base::sys.calls
[09:31:32.999]             `[[` <- base::`[[`
[09:31:32.999]             `+` <- base::`+`
[09:31:32.999]             `<<-` <- base::`<<-`
[09:31:32.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:32.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:32.999]                   3L)]
[09:31:32.999]             }
[09:31:32.999]             function(cond) {
[09:31:32.999]                 is_error <- inherits(cond, "error")
[09:31:32.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:32.999]                   NULL)
[09:31:32.999]                 if (is_error) {
[09:31:32.999]                   sessionInformation <- function() {
[09:31:32.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:32.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:32.999]                       search = base::search(), system = base::Sys.info())
[09:31:32.999]                   }
[09:31:32.999]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:32.999]                     cond$call), session = sessionInformation(), 
[09:31:32.999]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:32.999]                   signalCondition(cond)
[09:31:32.999]                 }
[09:31:32.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:32.999]                 "immediateCondition"))) {
[09:31:32.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:32.999]                   ...future.conditions[[length(...future.conditions) + 
[09:31:32.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:32.999]                   if (TRUE && !signal) {
[09:31:32.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.999]                     {
[09:31:32.999]                       inherits <- base::inherits
[09:31:32.999]                       invokeRestart <- base::invokeRestart
[09:31:32.999]                       is.null <- base::is.null
[09:31:32.999]                       muffled <- FALSE
[09:31:32.999]                       if (inherits(cond, "message")) {
[09:31:32.999]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.999]                         if (muffled) 
[09:31:32.999]                           invokeRestart("muffleMessage")
[09:31:32.999]                       }
[09:31:32.999]                       else if (inherits(cond, "warning")) {
[09:31:32.999]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.999]                         if (muffled) 
[09:31:32.999]                           invokeRestart("muffleWarning")
[09:31:32.999]                       }
[09:31:32.999]                       else if (inherits(cond, "condition")) {
[09:31:32.999]                         if (!is.null(pattern)) {
[09:31:32.999]                           computeRestarts <- base::computeRestarts
[09:31:32.999]                           grepl <- base::grepl
[09:31:32.999]                           restarts <- computeRestarts(cond)
[09:31:32.999]                           for (restart in restarts) {
[09:31:32.999]                             name <- restart$name
[09:31:32.999]                             if (is.null(name)) 
[09:31:32.999]                               next
[09:31:32.999]                             if (!grepl(pattern, name)) 
[09:31:32.999]                               next
[09:31:32.999]                             invokeRestart(restart)
[09:31:32.999]                             muffled <- TRUE
[09:31:32.999]                             break
[09:31:32.999]                           }
[09:31:32.999]                         }
[09:31:32.999]                       }
[09:31:32.999]                       invisible(muffled)
[09:31:32.999]                     }
[09:31:32.999]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.999]                   }
[09:31:32.999]                 }
[09:31:32.999]                 else {
[09:31:32.999]                   if (TRUE) {
[09:31:32.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:32.999]                     {
[09:31:32.999]                       inherits <- base::inherits
[09:31:32.999]                       invokeRestart <- base::invokeRestart
[09:31:32.999]                       is.null <- base::is.null
[09:31:32.999]                       muffled <- FALSE
[09:31:32.999]                       if (inherits(cond, "message")) {
[09:31:32.999]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:32.999]                         if (muffled) 
[09:31:32.999]                           invokeRestart("muffleMessage")
[09:31:32.999]                       }
[09:31:32.999]                       else if (inherits(cond, "warning")) {
[09:31:32.999]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:32.999]                         if (muffled) 
[09:31:32.999]                           invokeRestart("muffleWarning")
[09:31:32.999]                       }
[09:31:32.999]                       else if (inherits(cond, "condition")) {
[09:31:32.999]                         if (!is.null(pattern)) {
[09:31:32.999]                           computeRestarts <- base::computeRestarts
[09:31:32.999]                           grepl <- base::grepl
[09:31:32.999]                           restarts <- computeRestarts(cond)
[09:31:32.999]                           for (restart in restarts) {
[09:31:32.999]                             name <- restart$name
[09:31:32.999]                             if (is.null(name)) 
[09:31:32.999]                               next
[09:31:32.999]                             if (!grepl(pattern, name)) 
[09:31:32.999]                               next
[09:31:32.999]                             invokeRestart(restart)
[09:31:32.999]                             muffled <- TRUE
[09:31:32.999]                             break
[09:31:32.999]                           }
[09:31:32.999]                         }
[09:31:32.999]                       }
[09:31:32.999]                       invisible(muffled)
[09:31:32.999]                     }
[09:31:32.999]                     muffleCondition(cond, pattern = "^muffle")
[09:31:32.999]                   }
[09:31:32.999]                 }
[09:31:32.999]             }
[09:31:32.999]         }))
[09:31:32.999]     }, error = function(ex) {
[09:31:32.999]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:32.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:32.999]                 ...future.rng), started = ...future.startTime, 
[09:31:32.999]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:32.999]             version = "1.8"), class = "FutureResult")
[09:31:32.999]     }, finally = {
[09:31:32.999]         if (!identical(...future.workdir, getwd())) 
[09:31:32.999]             setwd(...future.workdir)
[09:31:32.999]         {
[09:31:32.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:32.999]                 ...future.oldOptions$nwarnings <- NULL
[09:31:32.999]             }
[09:31:32.999]             base::options(...future.oldOptions)
[09:31:32.999]             if (.Platform$OS.type == "windows") {
[09:31:32.999]                 old_names <- names(...future.oldEnvVars)
[09:31:32.999]                 envs <- base::Sys.getenv()
[09:31:32.999]                 names <- names(envs)
[09:31:32.999]                 common <- intersect(names, old_names)
[09:31:32.999]                 added <- setdiff(names, old_names)
[09:31:32.999]                 removed <- setdiff(old_names, names)
[09:31:32.999]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:32.999]                   envs[common]]
[09:31:32.999]                 NAMES <- toupper(changed)
[09:31:32.999]                 args <- list()
[09:31:32.999]                 for (kk in seq_along(NAMES)) {
[09:31:32.999]                   name <- changed[[kk]]
[09:31:32.999]                   NAME <- NAMES[[kk]]
[09:31:32.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.999]                     next
[09:31:32.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.999]                 }
[09:31:32.999]                 NAMES <- toupper(added)
[09:31:32.999]                 for (kk in seq_along(NAMES)) {
[09:31:32.999]                   name <- added[[kk]]
[09:31:32.999]                   NAME <- NAMES[[kk]]
[09:31:32.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.999]                     next
[09:31:32.999]                   args[[name]] <- ""
[09:31:32.999]                 }
[09:31:32.999]                 NAMES <- toupper(removed)
[09:31:32.999]                 for (kk in seq_along(NAMES)) {
[09:31:32.999]                   name <- removed[[kk]]
[09:31:32.999]                   NAME <- NAMES[[kk]]
[09:31:32.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:32.999]                     next
[09:31:32.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:32.999]                 }
[09:31:32.999]                 if (length(args) > 0) 
[09:31:32.999]                   base::do.call(base::Sys.setenv, args = args)
[09:31:32.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:32.999]             }
[09:31:32.999]             else {
[09:31:32.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:32.999]             }
[09:31:32.999]             {
[09:31:32.999]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:32.999]                   0L) {
[09:31:32.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:32.999]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:32.999]                   base::options(opts)
[09:31:32.999]                 }
[09:31:32.999]                 {
[09:31:32.999]                   {
[09:31:32.999]                     NULL
[09:31:32.999]                     RNGkind("Mersenne-Twister")
[09:31:32.999]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:32.999]                       inherits = FALSE)
[09:31:32.999]                   }
[09:31:32.999]                   options(future.plan = NULL)
[09:31:32.999]                   if (is.na(NA_character_)) 
[09:31:32.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:32.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:32.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:32.999]                     .init = FALSE)
[09:31:32.999]                 }
[09:31:32.999]             }
[09:31:32.999]         }
[09:31:32.999]     })
[09:31:32.999]     if (TRUE) {
[09:31:32.999]         base::sink(type = "output", split = FALSE)
[09:31:32.999]         if (TRUE) {
[09:31:32.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:32.999]         }
[09:31:32.999]         else {
[09:31:32.999]             ...future.result["stdout"] <- base::list(NULL)
[09:31:32.999]         }
[09:31:32.999]         base::close(...future.stdout)
[09:31:32.999]         ...future.stdout <- NULL
[09:31:32.999]     }
[09:31:32.999]     ...future.result$conditions <- ...future.conditions
[09:31:32.999]     ...future.result$finished <- base::Sys.time()
[09:31:32.999]     ...future.result
[09:31:32.999] }
[09:31:33.000] assign_globals() ...
[09:31:33.000] List of 1
[09:31:33.000]  $ ii: int 2
[09:31:33.000]  - attr(*, "where")=List of 1
[09:31:33.000]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.000]  - attr(*, "resolved")= logi TRUE
[09:31:33.000]  - attr(*, "total_size")= num 56
[09:31:33.000]  - attr(*, "already-done")= logi TRUE
[09:31:33.003] - copied ‘ii’ to environment
[09:31:33.003] assign_globals() ... done
[09:31:33.003] plan(): Setting new future strategy stack:
[09:31:33.003] List of future strategies:
[09:31:33.003] 1. sequential:
[09:31:33.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.003]    - tweaked: FALSE
[09:31:33.003]    - call: NULL
[09:31:33.004] plan(): nbrOfWorkers() = 1
[09:31:33.004] plan(): Setting new future strategy stack:
[09:31:33.004] List of future strategies:
[09:31:33.004] 1. sequential:
[09:31:33.004]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.004]    - tweaked: FALSE
[09:31:33.004]    - call: plan(strategy)
[09:31:33.005] plan(): nbrOfWorkers() = 1
[09:31:33.005] SequentialFuture started (and completed)
[09:31:33.005] - Launch lazy future ... done
[09:31:33.005] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.005] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.006] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.007] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.007] Searching for globals ... DONE
[09:31:33.007] Resolving globals: TRUE
[09:31:33.007] Resolving any globals that are futures ...
[09:31:33.007] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.007] Resolving any globals that are futures ... DONE
[09:31:33.008] Resolving futures part of globals (recursively) ...
[09:31:33.008] resolve() on list ...
[09:31:33.008]  recursive: 99
[09:31:33.008]  length: 1
[09:31:33.008]  elements: ‘ii’
[09:31:33.008]  length: 0 (resolved future 1)
[09:31:33.008] resolve() on list ... DONE
[09:31:33.008] - globals: [1] ‘ii’
[09:31:33.008] Resolving futures part of globals (recursively) ... DONE
[09:31:33.009] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.009] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.009] - globals: [1] ‘ii’
[09:31:33.009] 
[09:31:33.009] getGlobalsAndPackages() ... DONE
[09:31:33.009] run() for ‘Future’ ...
[09:31:33.009] - state: ‘created’
[09:31:33.010] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.010] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.010] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.010]   - Field: ‘label’
[09:31:33.010]   - Field: ‘local’
[09:31:33.010]   - Field: ‘owner’
[09:31:33.010]   - Field: ‘envir’
[09:31:33.010]   - Field: ‘packages’
[09:31:33.010]   - Field: ‘gc’
[09:31:33.010]   - Field: ‘conditions’
[09:31:33.011]   - Field: ‘expr’
[09:31:33.011]   - Field: ‘uuid’
[09:31:33.011]   - Field: ‘seed’
[09:31:33.011]   - Field: ‘version’
[09:31:33.011]   - Field: ‘result’
[09:31:33.011]   - Field: ‘asynchronous’
[09:31:33.011]   - Field: ‘calls’
[09:31:33.011]   - Field: ‘globals’
[09:31:33.011]   - Field: ‘stdout’
[09:31:33.011]   - Field: ‘earlySignal’
[09:31:33.011]   - Field: ‘lazy’
[09:31:33.011]   - Field: ‘state’
[09:31:33.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.012] - Launch lazy future ...
[09:31:33.012] Packages needed by the future expression (n = 0): <none>
[09:31:33.012] Packages needed by future strategies (n = 0): <none>
[09:31:33.012] {
[09:31:33.012]     {
[09:31:33.012]         {
[09:31:33.012]             ...future.startTime <- base::Sys.time()
[09:31:33.012]             {
[09:31:33.012]                 {
[09:31:33.012]                   {
[09:31:33.012]                     base::local({
[09:31:33.012]                       has_future <- base::requireNamespace("future", 
[09:31:33.012]                         quietly = TRUE)
[09:31:33.012]                       if (has_future) {
[09:31:33.012]                         ns <- base::getNamespace("future")
[09:31:33.012]                         version <- ns[[".package"]][["version"]]
[09:31:33.012]                         if (is.null(version)) 
[09:31:33.012]                           version <- utils::packageVersion("future")
[09:31:33.012]                       }
[09:31:33.012]                       else {
[09:31:33.012]                         version <- NULL
[09:31:33.012]                       }
[09:31:33.012]                       if (!has_future || version < "1.8.0") {
[09:31:33.012]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.012]                           "", base::R.version$version.string), 
[09:31:33.012]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.012]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.012]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.012]                             "release", "version")], collapse = " "), 
[09:31:33.012]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.012]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.012]                           info)
[09:31:33.012]                         info <- base::paste(info, collapse = "; ")
[09:31:33.012]                         if (!has_future) {
[09:31:33.012]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.012]                             info)
[09:31:33.012]                         }
[09:31:33.012]                         else {
[09:31:33.012]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.012]                             info, version)
[09:31:33.012]                         }
[09:31:33.012]                         base::stop(msg)
[09:31:33.012]                       }
[09:31:33.012]                     })
[09:31:33.012]                   }
[09:31:33.012]                   ...future.strategy.old <- future::plan("list")
[09:31:33.012]                   options(future.plan = NULL)
[09:31:33.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.012]                 }
[09:31:33.012]                 ...future.workdir <- getwd()
[09:31:33.012]             }
[09:31:33.012]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.012]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.012]         }
[09:31:33.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.012]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.012]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.012]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.012]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.012]             base::names(...future.oldOptions))
[09:31:33.012]     }
[09:31:33.012]     if (FALSE) {
[09:31:33.012]     }
[09:31:33.012]     else {
[09:31:33.012]         if (TRUE) {
[09:31:33.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.012]                 open = "w")
[09:31:33.012]         }
[09:31:33.012]         else {
[09:31:33.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.012]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.012]         }
[09:31:33.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.012]             base::sink(type = "output", split = FALSE)
[09:31:33.012]             base::close(...future.stdout)
[09:31:33.012]         }, add = TRUE)
[09:31:33.012]     }
[09:31:33.012]     ...future.frame <- base::sys.nframe()
[09:31:33.012]     ...future.conditions <- base::list()
[09:31:33.012]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.012]     if (FALSE) {
[09:31:33.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.012]     }
[09:31:33.012]     ...future.result <- base::tryCatch({
[09:31:33.012]         base::withCallingHandlers({
[09:31:33.012]             ...future.value <- base::withVisible(base::local({
[09:31:33.012]                 b <- a * ii
[09:31:33.012]                 a <- 0
[09:31:33.012]                 b
[09:31:33.012]             }))
[09:31:33.012]             future::FutureResult(value = ...future.value$value, 
[09:31:33.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.012]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.012]                     ...future.globalenv.names))
[09:31:33.012]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.012]         }, condition = base::local({
[09:31:33.012]             c <- base::c
[09:31:33.012]             inherits <- base::inherits
[09:31:33.012]             invokeRestart <- base::invokeRestart
[09:31:33.012]             length <- base::length
[09:31:33.012]             list <- base::list
[09:31:33.012]             seq.int <- base::seq.int
[09:31:33.012]             signalCondition <- base::signalCondition
[09:31:33.012]             sys.calls <- base::sys.calls
[09:31:33.012]             `[[` <- base::`[[`
[09:31:33.012]             `+` <- base::`+`
[09:31:33.012]             `<<-` <- base::`<<-`
[09:31:33.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.012]                   3L)]
[09:31:33.012]             }
[09:31:33.012]             function(cond) {
[09:31:33.012]                 is_error <- inherits(cond, "error")
[09:31:33.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.012]                   NULL)
[09:31:33.012]                 if (is_error) {
[09:31:33.012]                   sessionInformation <- function() {
[09:31:33.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.012]                       search = base::search(), system = base::Sys.info())
[09:31:33.012]                   }
[09:31:33.012]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.012]                     cond$call), session = sessionInformation(), 
[09:31:33.012]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.012]                   signalCondition(cond)
[09:31:33.012]                 }
[09:31:33.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.012]                 "immediateCondition"))) {
[09:31:33.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.012]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.012]                   if (TRUE && !signal) {
[09:31:33.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.012]                     {
[09:31:33.012]                       inherits <- base::inherits
[09:31:33.012]                       invokeRestart <- base::invokeRestart
[09:31:33.012]                       is.null <- base::is.null
[09:31:33.012]                       muffled <- FALSE
[09:31:33.012]                       if (inherits(cond, "message")) {
[09:31:33.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.012]                         if (muffled) 
[09:31:33.012]                           invokeRestart("muffleMessage")
[09:31:33.012]                       }
[09:31:33.012]                       else if (inherits(cond, "warning")) {
[09:31:33.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.012]                         if (muffled) 
[09:31:33.012]                           invokeRestart("muffleWarning")
[09:31:33.012]                       }
[09:31:33.012]                       else if (inherits(cond, "condition")) {
[09:31:33.012]                         if (!is.null(pattern)) {
[09:31:33.012]                           computeRestarts <- base::computeRestarts
[09:31:33.012]                           grepl <- base::grepl
[09:31:33.012]                           restarts <- computeRestarts(cond)
[09:31:33.012]                           for (restart in restarts) {
[09:31:33.012]                             name <- restart$name
[09:31:33.012]                             if (is.null(name)) 
[09:31:33.012]                               next
[09:31:33.012]                             if (!grepl(pattern, name)) 
[09:31:33.012]                               next
[09:31:33.012]                             invokeRestart(restart)
[09:31:33.012]                             muffled <- TRUE
[09:31:33.012]                             break
[09:31:33.012]                           }
[09:31:33.012]                         }
[09:31:33.012]                       }
[09:31:33.012]                       invisible(muffled)
[09:31:33.012]                     }
[09:31:33.012]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.012]                   }
[09:31:33.012]                 }
[09:31:33.012]                 else {
[09:31:33.012]                   if (TRUE) {
[09:31:33.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.012]                     {
[09:31:33.012]                       inherits <- base::inherits
[09:31:33.012]                       invokeRestart <- base::invokeRestart
[09:31:33.012]                       is.null <- base::is.null
[09:31:33.012]                       muffled <- FALSE
[09:31:33.012]                       if (inherits(cond, "message")) {
[09:31:33.012]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.012]                         if (muffled) 
[09:31:33.012]                           invokeRestart("muffleMessage")
[09:31:33.012]                       }
[09:31:33.012]                       else if (inherits(cond, "warning")) {
[09:31:33.012]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.012]                         if (muffled) 
[09:31:33.012]                           invokeRestart("muffleWarning")
[09:31:33.012]                       }
[09:31:33.012]                       else if (inherits(cond, "condition")) {
[09:31:33.012]                         if (!is.null(pattern)) {
[09:31:33.012]                           computeRestarts <- base::computeRestarts
[09:31:33.012]                           grepl <- base::grepl
[09:31:33.012]                           restarts <- computeRestarts(cond)
[09:31:33.012]                           for (restart in restarts) {
[09:31:33.012]                             name <- restart$name
[09:31:33.012]                             if (is.null(name)) 
[09:31:33.012]                               next
[09:31:33.012]                             if (!grepl(pattern, name)) 
[09:31:33.012]                               next
[09:31:33.012]                             invokeRestart(restart)
[09:31:33.012]                             muffled <- TRUE
[09:31:33.012]                             break
[09:31:33.012]                           }
[09:31:33.012]                         }
[09:31:33.012]                       }
[09:31:33.012]                       invisible(muffled)
[09:31:33.012]                     }
[09:31:33.012]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.012]                   }
[09:31:33.012]                 }
[09:31:33.012]             }
[09:31:33.012]         }))
[09:31:33.012]     }, error = function(ex) {
[09:31:33.012]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.012]                 ...future.rng), started = ...future.startTime, 
[09:31:33.012]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.012]             version = "1.8"), class = "FutureResult")
[09:31:33.012]     }, finally = {
[09:31:33.012]         if (!identical(...future.workdir, getwd())) 
[09:31:33.012]             setwd(...future.workdir)
[09:31:33.012]         {
[09:31:33.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.012]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.012]             }
[09:31:33.012]             base::options(...future.oldOptions)
[09:31:33.012]             if (.Platform$OS.type == "windows") {
[09:31:33.012]                 old_names <- names(...future.oldEnvVars)
[09:31:33.012]                 envs <- base::Sys.getenv()
[09:31:33.012]                 names <- names(envs)
[09:31:33.012]                 common <- intersect(names, old_names)
[09:31:33.012]                 added <- setdiff(names, old_names)
[09:31:33.012]                 removed <- setdiff(old_names, names)
[09:31:33.012]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.012]                   envs[common]]
[09:31:33.012]                 NAMES <- toupper(changed)
[09:31:33.012]                 args <- list()
[09:31:33.012]                 for (kk in seq_along(NAMES)) {
[09:31:33.012]                   name <- changed[[kk]]
[09:31:33.012]                   NAME <- NAMES[[kk]]
[09:31:33.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.012]                     next
[09:31:33.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.012]                 }
[09:31:33.012]                 NAMES <- toupper(added)
[09:31:33.012]                 for (kk in seq_along(NAMES)) {
[09:31:33.012]                   name <- added[[kk]]
[09:31:33.012]                   NAME <- NAMES[[kk]]
[09:31:33.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.012]                     next
[09:31:33.012]                   args[[name]] <- ""
[09:31:33.012]                 }
[09:31:33.012]                 NAMES <- toupper(removed)
[09:31:33.012]                 for (kk in seq_along(NAMES)) {
[09:31:33.012]                   name <- removed[[kk]]
[09:31:33.012]                   NAME <- NAMES[[kk]]
[09:31:33.012]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.012]                     next
[09:31:33.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.012]                 }
[09:31:33.012]                 if (length(args) > 0) 
[09:31:33.012]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.012]             }
[09:31:33.012]             else {
[09:31:33.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.012]             }
[09:31:33.012]             {
[09:31:33.012]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.012]                   0L) {
[09:31:33.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.012]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.012]                   base::options(opts)
[09:31:33.012]                 }
[09:31:33.012]                 {
[09:31:33.012]                   {
[09:31:33.012]                     NULL
[09:31:33.012]                     RNGkind("Mersenne-Twister")
[09:31:33.012]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.012]                       inherits = FALSE)
[09:31:33.012]                   }
[09:31:33.012]                   options(future.plan = NULL)
[09:31:33.012]                   if (is.na(NA_character_)) 
[09:31:33.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.012]                     .init = FALSE)
[09:31:33.012]                 }
[09:31:33.012]             }
[09:31:33.012]         }
[09:31:33.012]     })
[09:31:33.012]     if (TRUE) {
[09:31:33.012]         base::sink(type = "output", split = FALSE)
[09:31:33.012]         if (TRUE) {
[09:31:33.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.012]         }
[09:31:33.012]         else {
[09:31:33.012]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.012]         }
[09:31:33.012]         base::close(...future.stdout)
[09:31:33.012]         ...future.stdout <- NULL
[09:31:33.012]     }
[09:31:33.012]     ...future.result$conditions <- ...future.conditions
[09:31:33.012]     ...future.result$finished <- base::Sys.time()
[09:31:33.012]     ...future.result
[09:31:33.012] }
[09:31:33.014] assign_globals() ...
[09:31:33.014] List of 1
[09:31:33.014]  $ ii: int 3
[09:31:33.014]  - attr(*, "where")=List of 1
[09:31:33.014]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.014]  - attr(*, "resolved")= logi TRUE
[09:31:33.014]  - attr(*, "total_size")= num 56
[09:31:33.014]  - attr(*, "already-done")= logi TRUE
[09:31:33.017] - copied ‘ii’ to environment
[09:31:33.017] assign_globals() ... done
[09:31:33.017] plan(): Setting new future strategy stack:
[09:31:33.018] List of future strategies:
[09:31:33.018] 1. sequential:
[09:31:33.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.018]    - tweaked: FALSE
[09:31:33.018]    - call: NULL
[09:31:33.018] plan(): nbrOfWorkers() = 1
[09:31:33.019] plan(): Setting new future strategy stack:
[09:31:33.019] List of future strategies:
[09:31:33.019] 1. sequential:
[09:31:33.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.019]    - tweaked: FALSE
[09:31:33.019]    - call: plan(strategy)
[09:31:33.019] plan(): nbrOfWorkers() = 1
[09:31:33.019] SequentialFuture started (and completed)
[09:31:33.019] - Launch lazy future ... done
[09:31:33.019] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.020] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.021] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.022] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.022] Searching for globals ... DONE
[09:31:33.022] Resolving globals: TRUE
[09:31:33.022] Resolving any globals that are futures ...
[09:31:33.022] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.022] Resolving any globals that are futures ... DONE
[09:31:33.022] Resolving futures part of globals (recursively) ...
[09:31:33.023] resolve() on list ...
[09:31:33.023]  recursive: 99
[09:31:33.023]  length: 1
[09:31:33.023]  elements: ‘ii’
[09:31:33.023]  length: 0 (resolved future 1)
[09:31:33.023] resolve() on list ... DONE
[09:31:33.023] - globals: [1] ‘ii’
[09:31:33.023] Resolving futures part of globals (recursively) ... DONE
[09:31:33.023] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.024] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.024] - globals: [1] ‘ii’
[09:31:33.024] 
[09:31:33.024] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.025] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.025] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.026] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.026] Searching for globals ... DONE
[09:31:33.026] Resolving globals: TRUE
[09:31:33.026] Resolving any globals that are futures ...
[09:31:33.026] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.026] Resolving any globals that are futures ... DONE
[09:31:33.027] Resolving futures part of globals (recursively) ...
[09:31:33.027] resolve() on list ...
[09:31:33.027]  recursive: 99
[09:31:33.027]  length: 1
[09:31:33.027]  elements: ‘ii’
[09:31:33.027]  length: 0 (resolved future 1)
[09:31:33.027] resolve() on list ... DONE
[09:31:33.027] - globals: [1] ‘ii’
[09:31:33.027] Resolving futures part of globals (recursively) ... DONE
[09:31:33.028] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.028] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.028] - globals: [1] ‘ii’
[09:31:33.028] 
[09:31:33.028] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.029] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.029] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.030] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.030] Searching for globals ... DONE
[09:31:33.030] Resolving globals: TRUE
[09:31:33.030] Resolving any globals that are futures ...
[09:31:33.030] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.031] Resolving any globals that are futures ... DONE
[09:31:33.031] Resolving futures part of globals (recursively) ...
[09:31:33.031] resolve() on list ...
[09:31:33.031]  recursive: 99
[09:31:33.031]  length: 1
[09:31:33.031]  elements: ‘ii’
[09:31:33.031]  length: 0 (resolved future 1)
[09:31:33.031] resolve() on list ... DONE
[09:31:33.032] - globals: [1] ‘ii’
[09:31:33.032] Resolving futures part of globals (recursively) ... DONE
[09:31:33.032] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.032] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.032] - globals: [1] ‘ii’
[09:31:33.032] 
[09:31:33.032] getGlobalsAndPackages() ... DONE
[09:31:33.033] run() for ‘Future’ ...
[09:31:33.033] - state: ‘created’
[09:31:33.033] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.033] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.033]   - Field: ‘label’
[09:31:33.033]   - Field: ‘local’
[09:31:33.033]   - Field: ‘owner’
[09:31:33.034]   - Field: ‘envir’
[09:31:33.034]   - Field: ‘packages’
[09:31:33.034]   - Field: ‘gc’
[09:31:33.034]   - Field: ‘conditions’
[09:31:33.034]   - Field: ‘expr’
[09:31:33.034]   - Field: ‘uuid’
[09:31:33.034]   - Field: ‘seed’
[09:31:33.034]   - Field: ‘version’
[09:31:33.034]   - Field: ‘result’
[09:31:33.034]   - Field: ‘asynchronous’
[09:31:33.034]   - Field: ‘calls’
[09:31:33.034]   - Field: ‘globals’
[09:31:33.035]   - Field: ‘stdout’
[09:31:33.035]   - Field: ‘earlySignal’
[09:31:33.035]   - Field: ‘lazy’
[09:31:33.035]   - Field: ‘state’
[09:31:33.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.035] - Launch lazy future ...
[09:31:33.035] Packages needed by the future expression (n = 0): <none>
[09:31:33.035] Packages needed by future strategies (n = 0): <none>
[09:31:33.036] {
[09:31:33.036]     {
[09:31:33.036]         {
[09:31:33.036]             ...future.startTime <- base::Sys.time()
[09:31:33.036]             {
[09:31:33.036]                 {
[09:31:33.036]                   {
[09:31:33.036]                     base::local({
[09:31:33.036]                       has_future <- base::requireNamespace("future", 
[09:31:33.036]                         quietly = TRUE)
[09:31:33.036]                       if (has_future) {
[09:31:33.036]                         ns <- base::getNamespace("future")
[09:31:33.036]                         version <- ns[[".package"]][["version"]]
[09:31:33.036]                         if (is.null(version)) 
[09:31:33.036]                           version <- utils::packageVersion("future")
[09:31:33.036]                       }
[09:31:33.036]                       else {
[09:31:33.036]                         version <- NULL
[09:31:33.036]                       }
[09:31:33.036]                       if (!has_future || version < "1.8.0") {
[09:31:33.036]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.036]                           "", base::R.version$version.string), 
[09:31:33.036]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.036]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.036]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.036]                             "release", "version")], collapse = " "), 
[09:31:33.036]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.036]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.036]                           info)
[09:31:33.036]                         info <- base::paste(info, collapse = "; ")
[09:31:33.036]                         if (!has_future) {
[09:31:33.036]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.036]                             info)
[09:31:33.036]                         }
[09:31:33.036]                         else {
[09:31:33.036]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.036]                             info, version)
[09:31:33.036]                         }
[09:31:33.036]                         base::stop(msg)
[09:31:33.036]                       }
[09:31:33.036]                     })
[09:31:33.036]                   }
[09:31:33.036]                   ...future.strategy.old <- future::plan("list")
[09:31:33.036]                   options(future.plan = NULL)
[09:31:33.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.036]                 }
[09:31:33.036]                 ...future.workdir <- getwd()
[09:31:33.036]             }
[09:31:33.036]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.036]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.036]         }
[09:31:33.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.036]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.036]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.036]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.036]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.036]             base::names(...future.oldOptions))
[09:31:33.036]     }
[09:31:33.036]     if (FALSE) {
[09:31:33.036]     }
[09:31:33.036]     else {
[09:31:33.036]         if (TRUE) {
[09:31:33.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.036]                 open = "w")
[09:31:33.036]         }
[09:31:33.036]         else {
[09:31:33.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.036]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.036]         }
[09:31:33.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.036]             base::sink(type = "output", split = FALSE)
[09:31:33.036]             base::close(...future.stdout)
[09:31:33.036]         }, add = TRUE)
[09:31:33.036]     }
[09:31:33.036]     ...future.frame <- base::sys.nframe()
[09:31:33.036]     ...future.conditions <- base::list()
[09:31:33.036]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.036]     if (FALSE) {
[09:31:33.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.036]     }
[09:31:33.036]     ...future.result <- base::tryCatch({
[09:31:33.036]         base::withCallingHandlers({
[09:31:33.036]             ...future.value <- base::withVisible(base::local({
[09:31:33.036]                 b <- a * ii
[09:31:33.036]                 a <- 0
[09:31:33.036]                 b
[09:31:33.036]             }))
[09:31:33.036]             future::FutureResult(value = ...future.value$value, 
[09:31:33.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.036]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.036]                     ...future.globalenv.names))
[09:31:33.036]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.036]         }, condition = base::local({
[09:31:33.036]             c <- base::c
[09:31:33.036]             inherits <- base::inherits
[09:31:33.036]             invokeRestart <- base::invokeRestart
[09:31:33.036]             length <- base::length
[09:31:33.036]             list <- base::list
[09:31:33.036]             seq.int <- base::seq.int
[09:31:33.036]             signalCondition <- base::signalCondition
[09:31:33.036]             sys.calls <- base::sys.calls
[09:31:33.036]             `[[` <- base::`[[`
[09:31:33.036]             `+` <- base::`+`
[09:31:33.036]             `<<-` <- base::`<<-`
[09:31:33.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.036]                   3L)]
[09:31:33.036]             }
[09:31:33.036]             function(cond) {
[09:31:33.036]                 is_error <- inherits(cond, "error")
[09:31:33.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.036]                   NULL)
[09:31:33.036]                 if (is_error) {
[09:31:33.036]                   sessionInformation <- function() {
[09:31:33.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.036]                       search = base::search(), system = base::Sys.info())
[09:31:33.036]                   }
[09:31:33.036]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.036]                     cond$call), session = sessionInformation(), 
[09:31:33.036]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.036]                   signalCondition(cond)
[09:31:33.036]                 }
[09:31:33.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.036]                 "immediateCondition"))) {
[09:31:33.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.036]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.036]                   if (TRUE && !signal) {
[09:31:33.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.036]                     {
[09:31:33.036]                       inherits <- base::inherits
[09:31:33.036]                       invokeRestart <- base::invokeRestart
[09:31:33.036]                       is.null <- base::is.null
[09:31:33.036]                       muffled <- FALSE
[09:31:33.036]                       if (inherits(cond, "message")) {
[09:31:33.036]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.036]                         if (muffled) 
[09:31:33.036]                           invokeRestart("muffleMessage")
[09:31:33.036]                       }
[09:31:33.036]                       else if (inherits(cond, "warning")) {
[09:31:33.036]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.036]                         if (muffled) 
[09:31:33.036]                           invokeRestart("muffleWarning")
[09:31:33.036]                       }
[09:31:33.036]                       else if (inherits(cond, "condition")) {
[09:31:33.036]                         if (!is.null(pattern)) {
[09:31:33.036]                           computeRestarts <- base::computeRestarts
[09:31:33.036]                           grepl <- base::grepl
[09:31:33.036]                           restarts <- computeRestarts(cond)
[09:31:33.036]                           for (restart in restarts) {
[09:31:33.036]                             name <- restart$name
[09:31:33.036]                             if (is.null(name)) 
[09:31:33.036]                               next
[09:31:33.036]                             if (!grepl(pattern, name)) 
[09:31:33.036]                               next
[09:31:33.036]                             invokeRestart(restart)
[09:31:33.036]                             muffled <- TRUE
[09:31:33.036]                             break
[09:31:33.036]                           }
[09:31:33.036]                         }
[09:31:33.036]                       }
[09:31:33.036]                       invisible(muffled)
[09:31:33.036]                     }
[09:31:33.036]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.036]                   }
[09:31:33.036]                 }
[09:31:33.036]                 else {
[09:31:33.036]                   if (TRUE) {
[09:31:33.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.036]                     {
[09:31:33.036]                       inherits <- base::inherits
[09:31:33.036]                       invokeRestart <- base::invokeRestart
[09:31:33.036]                       is.null <- base::is.null
[09:31:33.036]                       muffled <- FALSE
[09:31:33.036]                       if (inherits(cond, "message")) {
[09:31:33.036]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.036]                         if (muffled) 
[09:31:33.036]                           invokeRestart("muffleMessage")
[09:31:33.036]                       }
[09:31:33.036]                       else if (inherits(cond, "warning")) {
[09:31:33.036]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.036]                         if (muffled) 
[09:31:33.036]                           invokeRestart("muffleWarning")
[09:31:33.036]                       }
[09:31:33.036]                       else if (inherits(cond, "condition")) {
[09:31:33.036]                         if (!is.null(pattern)) {
[09:31:33.036]                           computeRestarts <- base::computeRestarts
[09:31:33.036]                           grepl <- base::grepl
[09:31:33.036]                           restarts <- computeRestarts(cond)
[09:31:33.036]                           for (restart in restarts) {
[09:31:33.036]                             name <- restart$name
[09:31:33.036]                             if (is.null(name)) 
[09:31:33.036]                               next
[09:31:33.036]                             if (!grepl(pattern, name)) 
[09:31:33.036]                               next
[09:31:33.036]                             invokeRestart(restart)
[09:31:33.036]                             muffled <- TRUE
[09:31:33.036]                             break
[09:31:33.036]                           }
[09:31:33.036]                         }
[09:31:33.036]                       }
[09:31:33.036]                       invisible(muffled)
[09:31:33.036]                     }
[09:31:33.036]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.036]                   }
[09:31:33.036]                 }
[09:31:33.036]             }
[09:31:33.036]         }))
[09:31:33.036]     }, error = function(ex) {
[09:31:33.036]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.036]                 ...future.rng), started = ...future.startTime, 
[09:31:33.036]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.036]             version = "1.8"), class = "FutureResult")
[09:31:33.036]     }, finally = {
[09:31:33.036]         if (!identical(...future.workdir, getwd())) 
[09:31:33.036]             setwd(...future.workdir)
[09:31:33.036]         {
[09:31:33.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.036]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.036]             }
[09:31:33.036]             base::options(...future.oldOptions)
[09:31:33.036]             if (.Platform$OS.type == "windows") {
[09:31:33.036]                 old_names <- names(...future.oldEnvVars)
[09:31:33.036]                 envs <- base::Sys.getenv()
[09:31:33.036]                 names <- names(envs)
[09:31:33.036]                 common <- intersect(names, old_names)
[09:31:33.036]                 added <- setdiff(names, old_names)
[09:31:33.036]                 removed <- setdiff(old_names, names)
[09:31:33.036]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.036]                   envs[common]]
[09:31:33.036]                 NAMES <- toupper(changed)
[09:31:33.036]                 args <- list()
[09:31:33.036]                 for (kk in seq_along(NAMES)) {
[09:31:33.036]                   name <- changed[[kk]]
[09:31:33.036]                   NAME <- NAMES[[kk]]
[09:31:33.036]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.036]                     next
[09:31:33.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.036]                 }
[09:31:33.036]                 NAMES <- toupper(added)
[09:31:33.036]                 for (kk in seq_along(NAMES)) {
[09:31:33.036]                   name <- added[[kk]]
[09:31:33.036]                   NAME <- NAMES[[kk]]
[09:31:33.036]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.036]                     next
[09:31:33.036]                   args[[name]] <- ""
[09:31:33.036]                 }
[09:31:33.036]                 NAMES <- toupper(removed)
[09:31:33.036]                 for (kk in seq_along(NAMES)) {
[09:31:33.036]                   name <- removed[[kk]]
[09:31:33.036]                   NAME <- NAMES[[kk]]
[09:31:33.036]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.036]                     next
[09:31:33.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.036]                 }
[09:31:33.036]                 if (length(args) > 0) 
[09:31:33.036]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.036]             }
[09:31:33.036]             else {
[09:31:33.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.036]             }
[09:31:33.036]             {
[09:31:33.036]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.036]                   0L) {
[09:31:33.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.036]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.036]                   base::options(opts)
[09:31:33.036]                 }
[09:31:33.036]                 {
[09:31:33.036]                   {
[09:31:33.036]                     NULL
[09:31:33.036]                     RNGkind("Mersenne-Twister")
[09:31:33.036]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.036]                       inherits = FALSE)
[09:31:33.036]                   }
[09:31:33.036]                   options(future.plan = NULL)
[09:31:33.036]                   if (is.na(NA_character_)) 
[09:31:33.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.036]                     .init = FALSE)
[09:31:33.036]                 }
[09:31:33.036]             }
[09:31:33.036]         }
[09:31:33.036]     })
[09:31:33.036]     if (TRUE) {
[09:31:33.036]         base::sink(type = "output", split = FALSE)
[09:31:33.036]         if (TRUE) {
[09:31:33.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.036]         }
[09:31:33.036]         else {
[09:31:33.036]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.036]         }
[09:31:33.036]         base::close(...future.stdout)
[09:31:33.036]         ...future.stdout <- NULL
[09:31:33.036]     }
[09:31:33.036]     ...future.result$conditions <- ...future.conditions
[09:31:33.036]     ...future.result$finished <- base::Sys.time()
[09:31:33.036]     ...future.result
[09:31:33.036] }
[09:31:33.037] assign_globals() ...
[09:31:33.037] List of 1
[09:31:33.037]  $ ii: int 1
[09:31:33.037]  - attr(*, "where")=List of 1
[09:31:33.037]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.037]  - attr(*, "resolved")= logi TRUE
[09:31:33.037]  - attr(*, "total_size")= num 56
[09:31:33.037]  - attr(*, "already-done")= logi TRUE
[09:31:33.040] - copied ‘ii’ to environment
[09:31:33.040] assign_globals() ... done
[09:31:33.040] plan(): Setting new future strategy stack:
[09:31:33.040] List of future strategies:
[09:31:33.040] 1. sequential:
[09:31:33.040]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.040]    - tweaked: FALSE
[09:31:33.040]    - call: NULL
[09:31:33.040] plan(): nbrOfWorkers() = 1
[09:31:33.042] plan(): Setting new future strategy stack:
[09:31:33.042] List of future strategies:
[09:31:33.042] 1. sequential:
[09:31:33.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.042]    - tweaked: FALSE
[09:31:33.042]    - call: plan(strategy)
[09:31:33.043] plan(): nbrOfWorkers() = 1
[09:31:33.043] SequentialFuture started (and completed)
[09:31:33.043] signalConditions() ...
[09:31:33.043]  - include = ‘immediateCondition’
[09:31:33.043]  - exclude = 
[09:31:33.043]  - resignal = FALSE
[09:31:33.043]  - Number of conditions: 1
[09:31:33.043] signalConditions() ... done
[09:31:33.043] - Launch lazy future ... done
[09:31:33.043] run() for ‘SequentialFuture’ ... done
[09:31:33.044] signalConditions() ...
[09:31:33.044]  - include = ‘immediateCondition’
[09:31:33.044]  - exclude = 
[09:31:33.044]  - resignal = FALSE
[09:31:33.044]  - Number of conditions: 1
[09:31:33.044] signalConditions() ... done
[09:31:33.044] Future state: ‘finished’
[09:31:33.044] signalConditions() ...
[09:31:33.044]  - include = ‘condition’
[09:31:33.044]  - exclude = ‘immediateCondition’
[09:31:33.044]  - resignal = TRUE
[09:31:33.045]  - Number of conditions: 1
[09:31:33.045]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:33.045] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:33"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.057] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.057] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.058] 
[09:31:33.058] Searching for globals ... DONE
[09:31:33.058] - globals: [0] <none>
[09:31:33.058] getGlobalsAndPackages() ... DONE
[09:31:33.058] run() for ‘Future’ ...
[09:31:33.058] - state: ‘created’
[09:31:33.058] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.058] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.059]   - Field: ‘label’
[09:31:33.059]   - Field: ‘local’
[09:31:33.059]   - Field: ‘owner’
[09:31:33.059]   - Field: ‘envir’
[09:31:33.059]   - Field: ‘packages’
[09:31:33.059]   - Field: ‘gc’
[09:31:33.059]   - Field: ‘conditions’
[09:31:33.059]   - Field: ‘expr’
[09:31:33.059]   - Field: ‘uuid’
[09:31:33.059]   - Field: ‘seed’
[09:31:33.060]   - Field: ‘version’
[09:31:33.060]   - Field: ‘result’
[09:31:33.060]   - Field: ‘asynchronous’
[09:31:33.060]   - Field: ‘calls’
[09:31:33.060]   - Field: ‘globals’
[09:31:33.060]   - Field: ‘stdout’
[09:31:33.060]   - Field: ‘earlySignal’
[09:31:33.060]   - Field: ‘lazy’
[09:31:33.060]   - Field: ‘state’
[09:31:33.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.060] - Launch lazy future ...
[09:31:33.061] Packages needed by the future expression (n = 0): <none>
[09:31:33.061] Packages needed by future strategies (n = 0): <none>
[09:31:33.061] {
[09:31:33.061]     {
[09:31:33.061]         {
[09:31:33.061]             ...future.startTime <- base::Sys.time()
[09:31:33.061]             {
[09:31:33.061]                 {
[09:31:33.061]                   {
[09:31:33.061]                     base::local({
[09:31:33.061]                       has_future <- base::requireNamespace("future", 
[09:31:33.061]                         quietly = TRUE)
[09:31:33.061]                       if (has_future) {
[09:31:33.061]                         ns <- base::getNamespace("future")
[09:31:33.061]                         version <- ns[[".package"]][["version"]]
[09:31:33.061]                         if (is.null(version)) 
[09:31:33.061]                           version <- utils::packageVersion("future")
[09:31:33.061]                       }
[09:31:33.061]                       else {
[09:31:33.061]                         version <- NULL
[09:31:33.061]                       }
[09:31:33.061]                       if (!has_future || version < "1.8.0") {
[09:31:33.061]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.061]                           "", base::R.version$version.string), 
[09:31:33.061]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.061]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.061]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.061]                             "release", "version")], collapse = " "), 
[09:31:33.061]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.061]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.061]                           info)
[09:31:33.061]                         info <- base::paste(info, collapse = "; ")
[09:31:33.061]                         if (!has_future) {
[09:31:33.061]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.061]                             info)
[09:31:33.061]                         }
[09:31:33.061]                         else {
[09:31:33.061]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.061]                             info, version)
[09:31:33.061]                         }
[09:31:33.061]                         base::stop(msg)
[09:31:33.061]                       }
[09:31:33.061]                     })
[09:31:33.061]                   }
[09:31:33.061]                   ...future.strategy.old <- future::plan("list")
[09:31:33.061]                   options(future.plan = NULL)
[09:31:33.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.061]                 }
[09:31:33.061]                 ...future.workdir <- getwd()
[09:31:33.061]             }
[09:31:33.061]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.061]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.061]         }
[09:31:33.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.061]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.061]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.061]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.061]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.061]             base::names(...future.oldOptions))
[09:31:33.061]     }
[09:31:33.061]     if (FALSE) {
[09:31:33.061]     }
[09:31:33.061]     else {
[09:31:33.061]         if (TRUE) {
[09:31:33.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.061]                 open = "w")
[09:31:33.061]         }
[09:31:33.061]         else {
[09:31:33.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.061]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.061]         }
[09:31:33.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.061]             base::sink(type = "output", split = FALSE)
[09:31:33.061]             base::close(...future.stdout)
[09:31:33.061]         }, add = TRUE)
[09:31:33.061]     }
[09:31:33.061]     ...future.frame <- base::sys.nframe()
[09:31:33.061]     ...future.conditions <- base::list()
[09:31:33.061]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.061]     if (FALSE) {
[09:31:33.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.061]     }
[09:31:33.061]     ...future.result <- base::tryCatch({
[09:31:33.061]         base::withCallingHandlers({
[09:31:33.061]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.061]             future::FutureResult(value = ...future.value$value, 
[09:31:33.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.061]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.061]                     ...future.globalenv.names))
[09:31:33.061]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.061]         }, condition = base::local({
[09:31:33.061]             c <- base::c
[09:31:33.061]             inherits <- base::inherits
[09:31:33.061]             invokeRestart <- base::invokeRestart
[09:31:33.061]             length <- base::length
[09:31:33.061]             list <- base::list
[09:31:33.061]             seq.int <- base::seq.int
[09:31:33.061]             signalCondition <- base::signalCondition
[09:31:33.061]             sys.calls <- base::sys.calls
[09:31:33.061]             `[[` <- base::`[[`
[09:31:33.061]             `+` <- base::`+`
[09:31:33.061]             `<<-` <- base::`<<-`
[09:31:33.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.061]                   3L)]
[09:31:33.061]             }
[09:31:33.061]             function(cond) {
[09:31:33.061]                 is_error <- inherits(cond, "error")
[09:31:33.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.061]                   NULL)
[09:31:33.061]                 if (is_error) {
[09:31:33.061]                   sessionInformation <- function() {
[09:31:33.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.061]                       search = base::search(), system = base::Sys.info())
[09:31:33.061]                   }
[09:31:33.061]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.061]                     cond$call), session = sessionInformation(), 
[09:31:33.061]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.061]                   signalCondition(cond)
[09:31:33.061]                 }
[09:31:33.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.061]                 "immediateCondition"))) {
[09:31:33.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.061]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.061]                   if (TRUE && !signal) {
[09:31:33.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.061]                     {
[09:31:33.061]                       inherits <- base::inherits
[09:31:33.061]                       invokeRestart <- base::invokeRestart
[09:31:33.061]                       is.null <- base::is.null
[09:31:33.061]                       muffled <- FALSE
[09:31:33.061]                       if (inherits(cond, "message")) {
[09:31:33.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.061]                         if (muffled) 
[09:31:33.061]                           invokeRestart("muffleMessage")
[09:31:33.061]                       }
[09:31:33.061]                       else if (inherits(cond, "warning")) {
[09:31:33.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.061]                         if (muffled) 
[09:31:33.061]                           invokeRestart("muffleWarning")
[09:31:33.061]                       }
[09:31:33.061]                       else if (inherits(cond, "condition")) {
[09:31:33.061]                         if (!is.null(pattern)) {
[09:31:33.061]                           computeRestarts <- base::computeRestarts
[09:31:33.061]                           grepl <- base::grepl
[09:31:33.061]                           restarts <- computeRestarts(cond)
[09:31:33.061]                           for (restart in restarts) {
[09:31:33.061]                             name <- restart$name
[09:31:33.061]                             if (is.null(name)) 
[09:31:33.061]                               next
[09:31:33.061]                             if (!grepl(pattern, name)) 
[09:31:33.061]                               next
[09:31:33.061]                             invokeRestart(restart)
[09:31:33.061]                             muffled <- TRUE
[09:31:33.061]                             break
[09:31:33.061]                           }
[09:31:33.061]                         }
[09:31:33.061]                       }
[09:31:33.061]                       invisible(muffled)
[09:31:33.061]                     }
[09:31:33.061]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.061]                   }
[09:31:33.061]                 }
[09:31:33.061]                 else {
[09:31:33.061]                   if (TRUE) {
[09:31:33.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.061]                     {
[09:31:33.061]                       inherits <- base::inherits
[09:31:33.061]                       invokeRestart <- base::invokeRestart
[09:31:33.061]                       is.null <- base::is.null
[09:31:33.061]                       muffled <- FALSE
[09:31:33.061]                       if (inherits(cond, "message")) {
[09:31:33.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.061]                         if (muffled) 
[09:31:33.061]                           invokeRestart("muffleMessage")
[09:31:33.061]                       }
[09:31:33.061]                       else if (inherits(cond, "warning")) {
[09:31:33.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.061]                         if (muffled) 
[09:31:33.061]                           invokeRestart("muffleWarning")
[09:31:33.061]                       }
[09:31:33.061]                       else if (inherits(cond, "condition")) {
[09:31:33.061]                         if (!is.null(pattern)) {
[09:31:33.061]                           computeRestarts <- base::computeRestarts
[09:31:33.061]                           grepl <- base::grepl
[09:31:33.061]                           restarts <- computeRestarts(cond)
[09:31:33.061]                           for (restart in restarts) {
[09:31:33.061]                             name <- restart$name
[09:31:33.061]                             if (is.null(name)) 
[09:31:33.061]                               next
[09:31:33.061]                             if (!grepl(pattern, name)) 
[09:31:33.061]                               next
[09:31:33.061]                             invokeRestart(restart)
[09:31:33.061]                             muffled <- TRUE
[09:31:33.061]                             break
[09:31:33.061]                           }
[09:31:33.061]                         }
[09:31:33.061]                       }
[09:31:33.061]                       invisible(muffled)
[09:31:33.061]                     }
[09:31:33.061]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.061]                   }
[09:31:33.061]                 }
[09:31:33.061]             }
[09:31:33.061]         }))
[09:31:33.061]     }, error = function(ex) {
[09:31:33.061]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.061]                 ...future.rng), started = ...future.startTime, 
[09:31:33.061]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.061]             version = "1.8"), class = "FutureResult")
[09:31:33.061]     }, finally = {
[09:31:33.061]         if (!identical(...future.workdir, getwd())) 
[09:31:33.061]             setwd(...future.workdir)
[09:31:33.061]         {
[09:31:33.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.061]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.061]             }
[09:31:33.061]             base::options(...future.oldOptions)
[09:31:33.061]             if (.Platform$OS.type == "windows") {
[09:31:33.061]                 old_names <- names(...future.oldEnvVars)
[09:31:33.061]                 envs <- base::Sys.getenv()
[09:31:33.061]                 names <- names(envs)
[09:31:33.061]                 common <- intersect(names, old_names)
[09:31:33.061]                 added <- setdiff(names, old_names)
[09:31:33.061]                 removed <- setdiff(old_names, names)
[09:31:33.061]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.061]                   envs[common]]
[09:31:33.061]                 NAMES <- toupper(changed)
[09:31:33.061]                 args <- list()
[09:31:33.061]                 for (kk in seq_along(NAMES)) {
[09:31:33.061]                   name <- changed[[kk]]
[09:31:33.061]                   NAME <- NAMES[[kk]]
[09:31:33.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.061]                     next
[09:31:33.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.061]                 }
[09:31:33.061]                 NAMES <- toupper(added)
[09:31:33.061]                 for (kk in seq_along(NAMES)) {
[09:31:33.061]                   name <- added[[kk]]
[09:31:33.061]                   NAME <- NAMES[[kk]]
[09:31:33.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.061]                     next
[09:31:33.061]                   args[[name]] <- ""
[09:31:33.061]                 }
[09:31:33.061]                 NAMES <- toupper(removed)
[09:31:33.061]                 for (kk in seq_along(NAMES)) {
[09:31:33.061]                   name <- removed[[kk]]
[09:31:33.061]                   NAME <- NAMES[[kk]]
[09:31:33.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.061]                     next
[09:31:33.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.061]                 }
[09:31:33.061]                 if (length(args) > 0) 
[09:31:33.061]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.061]             }
[09:31:33.061]             else {
[09:31:33.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.061]             }
[09:31:33.061]             {
[09:31:33.061]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.061]                   0L) {
[09:31:33.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.061]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.061]                   base::options(opts)
[09:31:33.061]                 }
[09:31:33.061]                 {
[09:31:33.061]                   {
[09:31:33.061]                     NULL
[09:31:33.061]                     RNGkind("Mersenne-Twister")
[09:31:33.061]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.061]                       inherits = FALSE)
[09:31:33.061]                   }
[09:31:33.061]                   options(future.plan = NULL)
[09:31:33.061]                   if (is.na(NA_character_)) 
[09:31:33.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.061]                     .init = FALSE)
[09:31:33.061]                 }
[09:31:33.061]             }
[09:31:33.061]         }
[09:31:33.061]     })
[09:31:33.061]     if (TRUE) {
[09:31:33.061]         base::sink(type = "output", split = FALSE)
[09:31:33.061]         if (TRUE) {
[09:31:33.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.061]         }
[09:31:33.061]         else {
[09:31:33.061]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.061]         }
[09:31:33.061]         base::close(...future.stdout)
[09:31:33.061]         ...future.stdout <- NULL
[09:31:33.061]     }
[09:31:33.061]     ...future.result$conditions <- ...future.conditions
[09:31:33.061]     ...future.result$finished <- base::Sys.time()
[09:31:33.061]     ...future.result
[09:31:33.061] }
[09:31:33.063] plan(): Setting new future strategy stack:
[09:31:33.063] List of future strategies:
[09:31:33.063] 1. sequential:
[09:31:33.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.063]    - tweaked: FALSE
[09:31:33.063]    - call: NULL
[09:31:33.063] plan(): nbrOfWorkers() = 1
[09:31:33.064] plan(): Setting new future strategy stack:
[09:31:33.064] List of future strategies:
[09:31:33.064] 1. sequential:
[09:31:33.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.064]    - tweaked: FALSE
[09:31:33.064]    - call: plan(strategy)
[09:31:33.064] plan(): nbrOfWorkers() = 1
[09:31:33.064] SequentialFuture started (and completed)
[09:31:33.065] - Launch lazy future ... done
[09:31:33.065] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.065] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.065] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.067] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.067] Searching for globals ... DONE
[09:31:33.067] Resolving globals: TRUE
[09:31:33.067] Resolving any globals that are futures ...
[09:31:33.067] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.067] Resolving any globals that are futures ... DONE
[09:31:33.067] Resolving futures part of globals (recursively) ...
[09:31:33.068] resolve() on list ...
[09:31:33.068]  recursive: 99
[09:31:33.068]  length: 1
[09:31:33.068]  elements: ‘a’
[09:31:33.068] resolved() for ‘SequentialFuture’ ...
[09:31:33.068] - state: ‘finished’
[09:31:33.068] - run: TRUE
[09:31:33.068] - result: ‘FutureResult’
[09:31:33.069] resolved() for ‘SequentialFuture’ ... done
[09:31:33.069] Future #1
[09:31:33.069] resolved() for ‘SequentialFuture’ ...
[09:31:33.069] - state: ‘finished’
[09:31:33.069] - run: TRUE
[09:31:33.069] - result: ‘FutureResult’
[09:31:33.069] resolved() for ‘SequentialFuture’ ... done
[09:31:33.069] A SequentialFuture was resolved
[09:31:33.069]  length: 0 (resolved future 1)
[09:31:33.070] resolve() on list ... DONE
[09:31:33.070] - globals: [1] ‘a’
[09:31:33.070] Resolving futures part of globals (recursively) ... DONE
[09:31:33.070] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[09:31:33.071] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[09:31:33.071] - globals: [1] ‘a’
[09:31:33.071] - packages: [1] ‘future’
[09:31:33.071] getGlobalsAndPackages() ... DONE
[09:31:33.071] run() for ‘Future’ ...
[09:31:33.071] - state: ‘created’
[09:31:33.071] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.072]   - Field: ‘label’
[09:31:33.072]   - Field: ‘local’
[09:31:33.072]   - Field: ‘owner’
[09:31:33.072]   - Field: ‘envir’
[09:31:33.072]   - Field: ‘packages’
[09:31:33.072]   - Field: ‘gc’
[09:31:33.072]   - Field: ‘conditions’
[09:31:33.073]   - Field: ‘expr’
[09:31:33.073]   - Field: ‘uuid’
[09:31:33.073]   - Field: ‘seed’
[09:31:33.073]   - Field: ‘version’
[09:31:33.073]   - Field: ‘result’
[09:31:33.073]   - Field: ‘asynchronous’
[09:31:33.073]   - Field: ‘calls’
[09:31:33.073]   - Field: ‘globals’
[09:31:33.073]   - Field: ‘stdout’
[09:31:33.073]   - Field: ‘earlySignal’
[09:31:33.073]   - Field: ‘lazy’
[09:31:33.073]   - Field: ‘state’
[09:31:33.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.074] - Launch lazy future ...
[09:31:33.074] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.074] Packages needed by future strategies (n = 0): <none>
[09:31:33.074] {
[09:31:33.074]     {
[09:31:33.074]         {
[09:31:33.074]             ...future.startTime <- base::Sys.time()
[09:31:33.074]             {
[09:31:33.074]                 {
[09:31:33.074]                   {
[09:31:33.074]                     {
[09:31:33.074]                       base::local({
[09:31:33.074]                         has_future <- base::requireNamespace("future", 
[09:31:33.074]                           quietly = TRUE)
[09:31:33.074]                         if (has_future) {
[09:31:33.074]                           ns <- base::getNamespace("future")
[09:31:33.074]                           version <- ns[[".package"]][["version"]]
[09:31:33.074]                           if (is.null(version)) 
[09:31:33.074]                             version <- utils::packageVersion("future")
[09:31:33.074]                         }
[09:31:33.074]                         else {
[09:31:33.074]                           version <- NULL
[09:31:33.074]                         }
[09:31:33.074]                         if (!has_future || version < "1.8.0") {
[09:31:33.074]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.074]                             "", base::R.version$version.string), 
[09:31:33.074]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.074]                               "release", "version")], collapse = " "), 
[09:31:33.074]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.074]                             info)
[09:31:33.074]                           info <- base::paste(info, collapse = "; ")
[09:31:33.074]                           if (!has_future) {
[09:31:33.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.074]                               info)
[09:31:33.074]                           }
[09:31:33.074]                           else {
[09:31:33.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.074]                               info, version)
[09:31:33.074]                           }
[09:31:33.074]                           base::stop(msg)
[09:31:33.074]                         }
[09:31:33.074]                       })
[09:31:33.074]                     }
[09:31:33.074]                     base::local({
[09:31:33.074]                       for (pkg in "future") {
[09:31:33.074]                         base::loadNamespace(pkg)
[09:31:33.074]                         base::library(pkg, character.only = TRUE)
[09:31:33.074]                       }
[09:31:33.074]                     })
[09:31:33.074]                   }
[09:31:33.074]                   ...future.strategy.old <- future::plan("list")
[09:31:33.074]                   options(future.plan = NULL)
[09:31:33.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.074]                 }
[09:31:33.074]                 ...future.workdir <- getwd()
[09:31:33.074]             }
[09:31:33.074]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.074]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.074]         }
[09:31:33.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.074]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.074]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.074]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.074]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.074]             base::names(...future.oldOptions))
[09:31:33.074]     }
[09:31:33.074]     if (FALSE) {
[09:31:33.074]     }
[09:31:33.074]     else {
[09:31:33.074]         if (TRUE) {
[09:31:33.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.074]                 open = "w")
[09:31:33.074]         }
[09:31:33.074]         else {
[09:31:33.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.074]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.074]         }
[09:31:33.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.074]             base::sink(type = "output", split = FALSE)
[09:31:33.074]             base::close(...future.stdout)
[09:31:33.074]         }, add = TRUE)
[09:31:33.074]     }
[09:31:33.074]     ...future.frame <- base::sys.nframe()
[09:31:33.074]     ...future.conditions <- base::list()
[09:31:33.074]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.074]     if (FALSE) {
[09:31:33.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.074]     }
[09:31:33.074]     ...future.result <- base::tryCatch({
[09:31:33.074]         base::withCallingHandlers({
[09:31:33.074]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.074]                 1))
[09:31:33.074]             future::FutureResult(value = ...future.value$value, 
[09:31:33.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.074]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.074]                     ...future.globalenv.names))
[09:31:33.074]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.074]         }, condition = base::local({
[09:31:33.074]             c <- base::c
[09:31:33.074]             inherits <- base::inherits
[09:31:33.074]             invokeRestart <- base::invokeRestart
[09:31:33.074]             length <- base::length
[09:31:33.074]             list <- base::list
[09:31:33.074]             seq.int <- base::seq.int
[09:31:33.074]             signalCondition <- base::signalCondition
[09:31:33.074]             sys.calls <- base::sys.calls
[09:31:33.074]             `[[` <- base::`[[`
[09:31:33.074]             `+` <- base::`+`
[09:31:33.074]             `<<-` <- base::`<<-`
[09:31:33.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.074]                   3L)]
[09:31:33.074]             }
[09:31:33.074]             function(cond) {
[09:31:33.074]                 is_error <- inherits(cond, "error")
[09:31:33.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.074]                   NULL)
[09:31:33.074]                 if (is_error) {
[09:31:33.074]                   sessionInformation <- function() {
[09:31:33.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.074]                       search = base::search(), system = base::Sys.info())
[09:31:33.074]                   }
[09:31:33.074]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.074]                     cond$call), session = sessionInformation(), 
[09:31:33.074]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.074]                   signalCondition(cond)
[09:31:33.074]                 }
[09:31:33.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.074]                 "immediateCondition"))) {
[09:31:33.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.074]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.074]                   if (TRUE && !signal) {
[09:31:33.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.074]                     {
[09:31:33.074]                       inherits <- base::inherits
[09:31:33.074]                       invokeRestart <- base::invokeRestart
[09:31:33.074]                       is.null <- base::is.null
[09:31:33.074]                       muffled <- FALSE
[09:31:33.074]                       if (inherits(cond, "message")) {
[09:31:33.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.074]                         if (muffled) 
[09:31:33.074]                           invokeRestart("muffleMessage")
[09:31:33.074]                       }
[09:31:33.074]                       else if (inherits(cond, "warning")) {
[09:31:33.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.074]                         if (muffled) 
[09:31:33.074]                           invokeRestart("muffleWarning")
[09:31:33.074]                       }
[09:31:33.074]                       else if (inherits(cond, "condition")) {
[09:31:33.074]                         if (!is.null(pattern)) {
[09:31:33.074]                           computeRestarts <- base::computeRestarts
[09:31:33.074]                           grepl <- base::grepl
[09:31:33.074]                           restarts <- computeRestarts(cond)
[09:31:33.074]                           for (restart in restarts) {
[09:31:33.074]                             name <- restart$name
[09:31:33.074]                             if (is.null(name)) 
[09:31:33.074]                               next
[09:31:33.074]                             if (!grepl(pattern, name)) 
[09:31:33.074]                               next
[09:31:33.074]                             invokeRestart(restart)
[09:31:33.074]                             muffled <- TRUE
[09:31:33.074]                             break
[09:31:33.074]                           }
[09:31:33.074]                         }
[09:31:33.074]                       }
[09:31:33.074]                       invisible(muffled)
[09:31:33.074]                     }
[09:31:33.074]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.074]                   }
[09:31:33.074]                 }
[09:31:33.074]                 else {
[09:31:33.074]                   if (TRUE) {
[09:31:33.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.074]                     {
[09:31:33.074]                       inherits <- base::inherits
[09:31:33.074]                       invokeRestart <- base::invokeRestart
[09:31:33.074]                       is.null <- base::is.null
[09:31:33.074]                       muffled <- FALSE
[09:31:33.074]                       if (inherits(cond, "message")) {
[09:31:33.074]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.074]                         if (muffled) 
[09:31:33.074]                           invokeRestart("muffleMessage")
[09:31:33.074]                       }
[09:31:33.074]                       else if (inherits(cond, "warning")) {
[09:31:33.074]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.074]                         if (muffled) 
[09:31:33.074]                           invokeRestart("muffleWarning")
[09:31:33.074]                       }
[09:31:33.074]                       else if (inherits(cond, "condition")) {
[09:31:33.074]                         if (!is.null(pattern)) {
[09:31:33.074]                           computeRestarts <- base::computeRestarts
[09:31:33.074]                           grepl <- base::grepl
[09:31:33.074]                           restarts <- computeRestarts(cond)
[09:31:33.074]                           for (restart in restarts) {
[09:31:33.074]                             name <- restart$name
[09:31:33.074]                             if (is.null(name)) 
[09:31:33.074]                               next
[09:31:33.074]                             if (!grepl(pattern, name)) 
[09:31:33.074]                               next
[09:31:33.074]                             invokeRestart(restart)
[09:31:33.074]                             muffled <- TRUE
[09:31:33.074]                             break
[09:31:33.074]                           }
[09:31:33.074]                         }
[09:31:33.074]                       }
[09:31:33.074]                       invisible(muffled)
[09:31:33.074]                     }
[09:31:33.074]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.074]                   }
[09:31:33.074]                 }
[09:31:33.074]             }
[09:31:33.074]         }))
[09:31:33.074]     }, error = function(ex) {
[09:31:33.074]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.074]                 ...future.rng), started = ...future.startTime, 
[09:31:33.074]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.074]             version = "1.8"), class = "FutureResult")
[09:31:33.074]     }, finally = {
[09:31:33.074]         if (!identical(...future.workdir, getwd())) 
[09:31:33.074]             setwd(...future.workdir)
[09:31:33.074]         {
[09:31:33.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.074]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.074]             }
[09:31:33.074]             base::options(...future.oldOptions)
[09:31:33.074]             if (.Platform$OS.type == "windows") {
[09:31:33.074]                 old_names <- names(...future.oldEnvVars)
[09:31:33.074]                 envs <- base::Sys.getenv()
[09:31:33.074]                 names <- names(envs)
[09:31:33.074]                 common <- intersect(names, old_names)
[09:31:33.074]                 added <- setdiff(names, old_names)
[09:31:33.074]                 removed <- setdiff(old_names, names)
[09:31:33.074]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.074]                   envs[common]]
[09:31:33.074]                 NAMES <- toupper(changed)
[09:31:33.074]                 args <- list()
[09:31:33.074]                 for (kk in seq_along(NAMES)) {
[09:31:33.074]                   name <- changed[[kk]]
[09:31:33.074]                   NAME <- NAMES[[kk]]
[09:31:33.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.074]                     next
[09:31:33.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.074]                 }
[09:31:33.074]                 NAMES <- toupper(added)
[09:31:33.074]                 for (kk in seq_along(NAMES)) {
[09:31:33.074]                   name <- added[[kk]]
[09:31:33.074]                   NAME <- NAMES[[kk]]
[09:31:33.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.074]                     next
[09:31:33.074]                   args[[name]] <- ""
[09:31:33.074]                 }
[09:31:33.074]                 NAMES <- toupper(removed)
[09:31:33.074]                 for (kk in seq_along(NAMES)) {
[09:31:33.074]                   name <- removed[[kk]]
[09:31:33.074]                   NAME <- NAMES[[kk]]
[09:31:33.074]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.074]                     next
[09:31:33.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.074]                 }
[09:31:33.074]                 if (length(args) > 0) 
[09:31:33.074]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.074]             }
[09:31:33.074]             else {
[09:31:33.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.074]             }
[09:31:33.074]             {
[09:31:33.074]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.074]                   0L) {
[09:31:33.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.074]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.074]                   base::options(opts)
[09:31:33.074]                 }
[09:31:33.074]                 {
[09:31:33.074]                   {
[09:31:33.074]                     NULL
[09:31:33.074]                     RNGkind("Mersenne-Twister")
[09:31:33.074]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.074]                       inherits = FALSE)
[09:31:33.074]                   }
[09:31:33.074]                   options(future.plan = NULL)
[09:31:33.074]                   if (is.na(NA_character_)) 
[09:31:33.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.074]                     .init = FALSE)
[09:31:33.074]                 }
[09:31:33.074]             }
[09:31:33.074]         }
[09:31:33.074]     })
[09:31:33.074]     if (TRUE) {
[09:31:33.074]         base::sink(type = "output", split = FALSE)
[09:31:33.074]         if (TRUE) {
[09:31:33.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.074]         }
[09:31:33.074]         else {
[09:31:33.074]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.074]         }
[09:31:33.074]         base::close(...future.stdout)
[09:31:33.074]         ...future.stdout <- NULL
[09:31:33.074]     }
[09:31:33.074]     ...future.result$conditions <- ...future.conditions
[09:31:33.074]     ...future.result$finished <- base::Sys.time()
[09:31:33.074]     ...future.result
[09:31:33.074] }
[09:31:33.076] assign_globals() ...
[09:31:33.076] List of 1
[09:31:33.076]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a716cd0> 
[09:31:33.076]  - attr(*, "where")=List of 1
[09:31:33.076]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.076]  - attr(*, "resolved")= logi TRUE
[09:31:33.076]  - attr(*, "total_size")= num 10424
[09:31:33.076]  - attr(*, "already-done")= logi TRUE
[09:31:33.078] - copied ‘a’ to environment
[09:31:33.078] assign_globals() ... done
[09:31:33.079] plan(): Setting new future strategy stack:
[09:31:33.079] List of future strategies:
[09:31:33.079] 1. sequential:
[09:31:33.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.079]    - tweaked: FALSE
[09:31:33.079]    - call: NULL
[09:31:33.079] plan(): nbrOfWorkers() = 1
[09:31:33.080] plan(): Setting new future strategy stack:
[09:31:33.080] List of future strategies:
[09:31:33.080] 1. sequential:
[09:31:33.080]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.080]    - tweaked: FALSE
[09:31:33.080]    - call: plan(strategy)
[09:31:33.080] plan(): nbrOfWorkers() = 1
[09:31:33.080] SequentialFuture started (and completed)
[09:31:33.081] - Launch lazy future ... done
[09:31:33.081] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.081] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.081] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.082] 
[09:31:33.082] Searching for globals ... DONE
[09:31:33.082] - globals: [0] <none>
[09:31:33.082] getGlobalsAndPackages() ... DONE
[09:31:33.082] run() for ‘Future’ ...
[09:31:33.082] - state: ‘created’
[09:31:33.082] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.083] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.083]   - Field: ‘label’
[09:31:33.083]   - Field: ‘local’
[09:31:33.083]   - Field: ‘owner’
[09:31:33.083]   - Field: ‘envir’
[09:31:33.083]   - Field: ‘packages’
[09:31:33.083]   - Field: ‘gc’
[09:31:33.083]   - Field: ‘conditions’
[09:31:33.083]   - Field: ‘expr’
[09:31:33.083]   - Field: ‘uuid’
[09:31:33.084]   - Field: ‘seed’
[09:31:33.084]   - Field: ‘version’
[09:31:33.084]   - Field: ‘result’
[09:31:33.084]   - Field: ‘asynchronous’
[09:31:33.084]   - Field: ‘calls’
[09:31:33.084]   - Field: ‘globals’
[09:31:33.084]   - Field: ‘stdout’
[09:31:33.084]   - Field: ‘earlySignal’
[09:31:33.084]   - Field: ‘lazy’
[09:31:33.084]   - Field: ‘state’
[09:31:33.084] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.084] - Launch lazy future ...
[09:31:33.085] Packages needed by the future expression (n = 0): <none>
[09:31:33.085] Packages needed by future strategies (n = 0): <none>
[09:31:33.085] {
[09:31:33.085]     {
[09:31:33.085]         {
[09:31:33.085]             ...future.startTime <- base::Sys.time()
[09:31:33.085]             {
[09:31:33.085]                 {
[09:31:33.085]                   {
[09:31:33.085]                     base::local({
[09:31:33.085]                       has_future <- base::requireNamespace("future", 
[09:31:33.085]                         quietly = TRUE)
[09:31:33.085]                       if (has_future) {
[09:31:33.085]                         ns <- base::getNamespace("future")
[09:31:33.085]                         version <- ns[[".package"]][["version"]]
[09:31:33.085]                         if (is.null(version)) 
[09:31:33.085]                           version <- utils::packageVersion("future")
[09:31:33.085]                       }
[09:31:33.085]                       else {
[09:31:33.085]                         version <- NULL
[09:31:33.085]                       }
[09:31:33.085]                       if (!has_future || version < "1.8.0") {
[09:31:33.085]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.085]                           "", base::R.version$version.string), 
[09:31:33.085]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.085]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.085]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.085]                             "release", "version")], collapse = " "), 
[09:31:33.085]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.085]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.085]                           info)
[09:31:33.085]                         info <- base::paste(info, collapse = "; ")
[09:31:33.085]                         if (!has_future) {
[09:31:33.085]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.085]                             info)
[09:31:33.085]                         }
[09:31:33.085]                         else {
[09:31:33.085]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.085]                             info, version)
[09:31:33.085]                         }
[09:31:33.085]                         base::stop(msg)
[09:31:33.085]                       }
[09:31:33.085]                     })
[09:31:33.085]                   }
[09:31:33.085]                   ...future.strategy.old <- future::plan("list")
[09:31:33.085]                   options(future.plan = NULL)
[09:31:33.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.085]                 }
[09:31:33.085]                 ...future.workdir <- getwd()
[09:31:33.085]             }
[09:31:33.085]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.085]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.085]         }
[09:31:33.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.085]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.085]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.085]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.085]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.085]             base::names(...future.oldOptions))
[09:31:33.085]     }
[09:31:33.085]     if (FALSE) {
[09:31:33.085]     }
[09:31:33.085]     else {
[09:31:33.085]         if (TRUE) {
[09:31:33.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.085]                 open = "w")
[09:31:33.085]         }
[09:31:33.085]         else {
[09:31:33.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.085]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.085]         }
[09:31:33.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.085]             base::sink(type = "output", split = FALSE)
[09:31:33.085]             base::close(...future.stdout)
[09:31:33.085]         }, add = TRUE)
[09:31:33.085]     }
[09:31:33.085]     ...future.frame <- base::sys.nframe()
[09:31:33.085]     ...future.conditions <- base::list()
[09:31:33.085]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.085]     if (FALSE) {
[09:31:33.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.085]     }
[09:31:33.085]     ...future.result <- base::tryCatch({
[09:31:33.085]         base::withCallingHandlers({
[09:31:33.085]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.085]             future::FutureResult(value = ...future.value$value, 
[09:31:33.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.085]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.085]                     ...future.globalenv.names))
[09:31:33.085]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.085]         }, condition = base::local({
[09:31:33.085]             c <- base::c
[09:31:33.085]             inherits <- base::inherits
[09:31:33.085]             invokeRestart <- base::invokeRestart
[09:31:33.085]             length <- base::length
[09:31:33.085]             list <- base::list
[09:31:33.085]             seq.int <- base::seq.int
[09:31:33.085]             signalCondition <- base::signalCondition
[09:31:33.085]             sys.calls <- base::sys.calls
[09:31:33.085]             `[[` <- base::`[[`
[09:31:33.085]             `+` <- base::`+`
[09:31:33.085]             `<<-` <- base::`<<-`
[09:31:33.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.085]                   3L)]
[09:31:33.085]             }
[09:31:33.085]             function(cond) {
[09:31:33.085]                 is_error <- inherits(cond, "error")
[09:31:33.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.085]                   NULL)
[09:31:33.085]                 if (is_error) {
[09:31:33.085]                   sessionInformation <- function() {
[09:31:33.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.085]                       search = base::search(), system = base::Sys.info())
[09:31:33.085]                   }
[09:31:33.085]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.085]                     cond$call), session = sessionInformation(), 
[09:31:33.085]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.085]                   signalCondition(cond)
[09:31:33.085]                 }
[09:31:33.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.085]                 "immediateCondition"))) {
[09:31:33.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.085]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.085]                   if (TRUE && !signal) {
[09:31:33.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.085]                     {
[09:31:33.085]                       inherits <- base::inherits
[09:31:33.085]                       invokeRestart <- base::invokeRestart
[09:31:33.085]                       is.null <- base::is.null
[09:31:33.085]                       muffled <- FALSE
[09:31:33.085]                       if (inherits(cond, "message")) {
[09:31:33.085]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.085]                         if (muffled) 
[09:31:33.085]                           invokeRestart("muffleMessage")
[09:31:33.085]                       }
[09:31:33.085]                       else if (inherits(cond, "warning")) {
[09:31:33.085]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.085]                         if (muffled) 
[09:31:33.085]                           invokeRestart("muffleWarning")
[09:31:33.085]                       }
[09:31:33.085]                       else if (inherits(cond, "condition")) {
[09:31:33.085]                         if (!is.null(pattern)) {
[09:31:33.085]                           computeRestarts <- base::computeRestarts
[09:31:33.085]                           grepl <- base::grepl
[09:31:33.085]                           restarts <- computeRestarts(cond)
[09:31:33.085]                           for (restart in restarts) {
[09:31:33.085]                             name <- restart$name
[09:31:33.085]                             if (is.null(name)) 
[09:31:33.085]                               next
[09:31:33.085]                             if (!grepl(pattern, name)) 
[09:31:33.085]                               next
[09:31:33.085]                             invokeRestart(restart)
[09:31:33.085]                             muffled <- TRUE
[09:31:33.085]                             break
[09:31:33.085]                           }
[09:31:33.085]                         }
[09:31:33.085]                       }
[09:31:33.085]                       invisible(muffled)
[09:31:33.085]                     }
[09:31:33.085]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.085]                   }
[09:31:33.085]                 }
[09:31:33.085]                 else {
[09:31:33.085]                   if (TRUE) {
[09:31:33.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.085]                     {
[09:31:33.085]                       inherits <- base::inherits
[09:31:33.085]                       invokeRestart <- base::invokeRestart
[09:31:33.085]                       is.null <- base::is.null
[09:31:33.085]                       muffled <- FALSE
[09:31:33.085]                       if (inherits(cond, "message")) {
[09:31:33.085]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.085]                         if (muffled) 
[09:31:33.085]                           invokeRestart("muffleMessage")
[09:31:33.085]                       }
[09:31:33.085]                       else if (inherits(cond, "warning")) {
[09:31:33.085]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.085]                         if (muffled) 
[09:31:33.085]                           invokeRestart("muffleWarning")
[09:31:33.085]                       }
[09:31:33.085]                       else if (inherits(cond, "condition")) {
[09:31:33.085]                         if (!is.null(pattern)) {
[09:31:33.085]                           computeRestarts <- base::computeRestarts
[09:31:33.085]                           grepl <- base::grepl
[09:31:33.085]                           restarts <- computeRestarts(cond)
[09:31:33.085]                           for (restart in restarts) {
[09:31:33.085]                             name <- restart$name
[09:31:33.085]                             if (is.null(name)) 
[09:31:33.085]                               next
[09:31:33.085]                             if (!grepl(pattern, name)) 
[09:31:33.085]                               next
[09:31:33.085]                             invokeRestart(restart)
[09:31:33.085]                             muffled <- TRUE
[09:31:33.085]                             break
[09:31:33.085]                           }
[09:31:33.085]                         }
[09:31:33.085]                       }
[09:31:33.085]                       invisible(muffled)
[09:31:33.085]                     }
[09:31:33.085]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.085]                   }
[09:31:33.085]                 }
[09:31:33.085]             }
[09:31:33.085]         }))
[09:31:33.085]     }, error = function(ex) {
[09:31:33.085]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.085]                 ...future.rng), started = ...future.startTime, 
[09:31:33.085]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.085]             version = "1.8"), class = "FutureResult")
[09:31:33.085]     }, finally = {
[09:31:33.085]         if (!identical(...future.workdir, getwd())) 
[09:31:33.085]             setwd(...future.workdir)
[09:31:33.085]         {
[09:31:33.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.085]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.085]             }
[09:31:33.085]             base::options(...future.oldOptions)
[09:31:33.085]             if (.Platform$OS.type == "windows") {
[09:31:33.085]                 old_names <- names(...future.oldEnvVars)
[09:31:33.085]                 envs <- base::Sys.getenv()
[09:31:33.085]                 names <- names(envs)
[09:31:33.085]                 common <- intersect(names, old_names)
[09:31:33.085]                 added <- setdiff(names, old_names)
[09:31:33.085]                 removed <- setdiff(old_names, names)
[09:31:33.085]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.085]                   envs[common]]
[09:31:33.085]                 NAMES <- toupper(changed)
[09:31:33.085]                 args <- list()
[09:31:33.085]                 for (kk in seq_along(NAMES)) {
[09:31:33.085]                   name <- changed[[kk]]
[09:31:33.085]                   NAME <- NAMES[[kk]]
[09:31:33.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.085]                     next
[09:31:33.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.085]                 }
[09:31:33.085]                 NAMES <- toupper(added)
[09:31:33.085]                 for (kk in seq_along(NAMES)) {
[09:31:33.085]                   name <- added[[kk]]
[09:31:33.085]                   NAME <- NAMES[[kk]]
[09:31:33.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.085]                     next
[09:31:33.085]                   args[[name]] <- ""
[09:31:33.085]                 }
[09:31:33.085]                 NAMES <- toupper(removed)
[09:31:33.085]                 for (kk in seq_along(NAMES)) {
[09:31:33.085]                   name <- removed[[kk]]
[09:31:33.085]                   NAME <- NAMES[[kk]]
[09:31:33.085]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.085]                     next
[09:31:33.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.085]                 }
[09:31:33.085]                 if (length(args) > 0) 
[09:31:33.085]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.085]             }
[09:31:33.085]             else {
[09:31:33.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.085]             }
[09:31:33.085]             {
[09:31:33.085]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.085]                   0L) {
[09:31:33.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.085]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.085]                   base::options(opts)
[09:31:33.085]                 }
[09:31:33.085]                 {
[09:31:33.085]                   {
[09:31:33.085]                     NULL
[09:31:33.085]                     RNGkind("Mersenne-Twister")
[09:31:33.085]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.085]                       inherits = FALSE)
[09:31:33.085]                   }
[09:31:33.085]                   options(future.plan = NULL)
[09:31:33.085]                   if (is.na(NA_character_)) 
[09:31:33.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.085]                     .init = FALSE)
[09:31:33.085]                 }
[09:31:33.085]             }
[09:31:33.085]         }
[09:31:33.085]     })
[09:31:33.085]     if (TRUE) {
[09:31:33.085]         base::sink(type = "output", split = FALSE)
[09:31:33.085]         if (TRUE) {
[09:31:33.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.085]         }
[09:31:33.085]         else {
[09:31:33.085]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.085]         }
[09:31:33.085]         base::close(...future.stdout)
[09:31:33.085]         ...future.stdout <- NULL
[09:31:33.085]     }
[09:31:33.085]     ...future.result$conditions <- ...future.conditions
[09:31:33.085]     ...future.result$finished <- base::Sys.time()
[09:31:33.085]     ...future.result
[09:31:33.085] }
[09:31:33.087] plan(): Setting new future strategy stack:
[09:31:33.087] List of future strategies:
[09:31:33.087] 1. sequential:
[09:31:33.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.087]    - tweaked: FALSE
[09:31:33.087]    - call: NULL
[09:31:33.087] plan(): nbrOfWorkers() = 1
[09:31:33.088] plan(): Setting new future strategy stack:
[09:31:33.088] List of future strategies:
[09:31:33.088] 1. sequential:
[09:31:33.088]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.088]    - tweaked: FALSE
[09:31:33.088]    - call: plan(strategy)
[09:31:33.088] plan(): nbrOfWorkers() = 1
[09:31:33.088] SequentialFuture started (and completed)
[09:31:33.089] - Launch lazy future ... done
[09:31:33.089] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.090] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.090] Searching for globals ... DONE
[09:31:33.090] Resolving globals: TRUE
[09:31:33.090] Resolving any globals that are futures ...
[09:31:33.090] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.090] Resolving any globals that are futures ... DONE
[09:31:33.091] Resolving futures part of globals (recursively) ...
[09:31:33.091] resolve() on list ...
[09:31:33.091]  recursive: 99
[09:31:33.091]  length: 1
[09:31:33.091]  elements: ‘a’
[09:31:33.091] resolved() for ‘SequentialFuture’ ...
[09:31:33.091] - state: ‘finished’
[09:31:33.092] - run: TRUE
[09:31:33.092] - result: ‘FutureResult’
[09:31:33.092] resolved() for ‘SequentialFuture’ ... done
[09:31:33.092] Future #1
[09:31:33.092] resolved() for ‘SequentialFuture’ ...
[09:31:33.092] - state: ‘finished’
[09:31:33.092] - run: TRUE
[09:31:33.092] - result: ‘FutureResult’
[09:31:33.092] resolved() for ‘SequentialFuture’ ... done
[09:31:33.092] A SequentialFuture was resolved
[09:31:33.093]  length: 0 (resolved future 1)
[09:31:33.093] resolve() on list ... DONE
[09:31:33.094] - globals: [1] ‘a’
[09:31:33.094] Resolving futures part of globals (recursively) ... DONE
[09:31:33.094] The total size of the 1 globals is 10.18 KiB (10424 bytes)
[09:31:33.095] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.18 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.18 KiB of class ‘environment’)
[09:31:33.095] - globals: [1] ‘a’
[09:31:33.095] - packages: [1] ‘future’
[09:31:33.095] getGlobalsAndPackages() ... DONE
[09:31:33.095] run() for ‘Future’ ...
[09:31:33.095] - state: ‘created’
[09:31:33.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.096] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.096]   - Field: ‘label’
[09:31:33.096]   - Field: ‘local’
[09:31:33.096]   - Field: ‘owner’
[09:31:33.096]   - Field: ‘envir’
[09:31:33.096]   - Field: ‘packages’
[09:31:33.096]   - Field: ‘gc’
[09:31:33.096]   - Field: ‘conditions’
[09:31:33.096]   - Field: ‘expr’
[09:31:33.097]   - Field: ‘uuid’
[09:31:33.097]   - Field: ‘seed’
[09:31:33.097]   - Field: ‘version’
[09:31:33.097]   - Field: ‘result’
[09:31:33.097]   - Field: ‘asynchronous’
[09:31:33.097]   - Field: ‘calls’
[09:31:33.097]   - Field: ‘globals’
[09:31:33.097]   - Field: ‘stdout’
[09:31:33.097]   - Field: ‘earlySignal’
[09:31:33.097]   - Field: ‘lazy’
[09:31:33.097]   - Field: ‘state’
[09:31:33.098] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.098] - Launch lazy future ...
[09:31:33.098] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.098] Packages needed by future strategies (n = 0): <none>
[09:31:33.098] {
[09:31:33.098]     {
[09:31:33.098]         {
[09:31:33.098]             ...future.startTime <- base::Sys.time()
[09:31:33.098]             {
[09:31:33.098]                 {
[09:31:33.098]                   {
[09:31:33.098]                     {
[09:31:33.098]                       base::local({
[09:31:33.098]                         has_future <- base::requireNamespace("future", 
[09:31:33.098]                           quietly = TRUE)
[09:31:33.098]                         if (has_future) {
[09:31:33.098]                           ns <- base::getNamespace("future")
[09:31:33.098]                           version <- ns[[".package"]][["version"]]
[09:31:33.098]                           if (is.null(version)) 
[09:31:33.098]                             version <- utils::packageVersion("future")
[09:31:33.098]                         }
[09:31:33.098]                         else {
[09:31:33.098]                           version <- NULL
[09:31:33.098]                         }
[09:31:33.098]                         if (!has_future || version < "1.8.0") {
[09:31:33.098]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.098]                             "", base::R.version$version.string), 
[09:31:33.098]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.098]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.098]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.098]                               "release", "version")], collapse = " "), 
[09:31:33.098]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.098]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.098]                             info)
[09:31:33.098]                           info <- base::paste(info, collapse = "; ")
[09:31:33.098]                           if (!has_future) {
[09:31:33.098]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.098]                               info)
[09:31:33.098]                           }
[09:31:33.098]                           else {
[09:31:33.098]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.098]                               info, version)
[09:31:33.098]                           }
[09:31:33.098]                           base::stop(msg)
[09:31:33.098]                         }
[09:31:33.098]                       })
[09:31:33.098]                     }
[09:31:33.098]                     base::local({
[09:31:33.098]                       for (pkg in "future") {
[09:31:33.098]                         base::loadNamespace(pkg)
[09:31:33.098]                         base::library(pkg, character.only = TRUE)
[09:31:33.098]                       }
[09:31:33.098]                     })
[09:31:33.098]                   }
[09:31:33.098]                   ...future.strategy.old <- future::plan("list")
[09:31:33.098]                   options(future.plan = NULL)
[09:31:33.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.098]                 }
[09:31:33.098]                 ...future.workdir <- getwd()
[09:31:33.098]             }
[09:31:33.098]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.098]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.098]         }
[09:31:33.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.098]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.098]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.098]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.098]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.098]             base::names(...future.oldOptions))
[09:31:33.098]     }
[09:31:33.098]     if (FALSE) {
[09:31:33.098]     }
[09:31:33.098]     else {
[09:31:33.098]         if (TRUE) {
[09:31:33.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.098]                 open = "w")
[09:31:33.098]         }
[09:31:33.098]         else {
[09:31:33.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.098]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.098]         }
[09:31:33.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.098]             base::sink(type = "output", split = FALSE)
[09:31:33.098]             base::close(...future.stdout)
[09:31:33.098]         }, add = TRUE)
[09:31:33.098]     }
[09:31:33.098]     ...future.frame <- base::sys.nframe()
[09:31:33.098]     ...future.conditions <- base::list()
[09:31:33.098]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.098]     if (FALSE) {
[09:31:33.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.098]     }
[09:31:33.098]     ...future.result <- base::tryCatch({
[09:31:33.098]         base::withCallingHandlers({
[09:31:33.098]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.098]                 1))
[09:31:33.098]             future::FutureResult(value = ...future.value$value, 
[09:31:33.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.098]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.098]                     ...future.globalenv.names))
[09:31:33.098]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.098]         }, condition = base::local({
[09:31:33.098]             c <- base::c
[09:31:33.098]             inherits <- base::inherits
[09:31:33.098]             invokeRestart <- base::invokeRestart
[09:31:33.098]             length <- base::length
[09:31:33.098]             list <- base::list
[09:31:33.098]             seq.int <- base::seq.int
[09:31:33.098]             signalCondition <- base::signalCondition
[09:31:33.098]             sys.calls <- base::sys.calls
[09:31:33.098]             `[[` <- base::`[[`
[09:31:33.098]             `+` <- base::`+`
[09:31:33.098]             `<<-` <- base::`<<-`
[09:31:33.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.098]                   3L)]
[09:31:33.098]             }
[09:31:33.098]             function(cond) {
[09:31:33.098]                 is_error <- inherits(cond, "error")
[09:31:33.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.098]                   NULL)
[09:31:33.098]                 if (is_error) {
[09:31:33.098]                   sessionInformation <- function() {
[09:31:33.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.098]                       search = base::search(), system = base::Sys.info())
[09:31:33.098]                   }
[09:31:33.098]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.098]                     cond$call), session = sessionInformation(), 
[09:31:33.098]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.098]                   signalCondition(cond)
[09:31:33.098]                 }
[09:31:33.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.098]                 "immediateCondition"))) {
[09:31:33.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.098]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.098]                   if (TRUE && !signal) {
[09:31:33.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.098]                     {
[09:31:33.098]                       inherits <- base::inherits
[09:31:33.098]                       invokeRestart <- base::invokeRestart
[09:31:33.098]                       is.null <- base::is.null
[09:31:33.098]                       muffled <- FALSE
[09:31:33.098]                       if (inherits(cond, "message")) {
[09:31:33.098]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.098]                         if (muffled) 
[09:31:33.098]                           invokeRestart("muffleMessage")
[09:31:33.098]                       }
[09:31:33.098]                       else if (inherits(cond, "warning")) {
[09:31:33.098]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.098]                         if (muffled) 
[09:31:33.098]                           invokeRestart("muffleWarning")
[09:31:33.098]                       }
[09:31:33.098]                       else if (inherits(cond, "condition")) {
[09:31:33.098]                         if (!is.null(pattern)) {
[09:31:33.098]                           computeRestarts <- base::computeRestarts
[09:31:33.098]                           grepl <- base::grepl
[09:31:33.098]                           restarts <- computeRestarts(cond)
[09:31:33.098]                           for (restart in restarts) {
[09:31:33.098]                             name <- restart$name
[09:31:33.098]                             if (is.null(name)) 
[09:31:33.098]                               next
[09:31:33.098]                             if (!grepl(pattern, name)) 
[09:31:33.098]                               next
[09:31:33.098]                             invokeRestart(restart)
[09:31:33.098]                             muffled <- TRUE
[09:31:33.098]                             break
[09:31:33.098]                           }
[09:31:33.098]                         }
[09:31:33.098]                       }
[09:31:33.098]                       invisible(muffled)
[09:31:33.098]                     }
[09:31:33.098]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.098]                   }
[09:31:33.098]                 }
[09:31:33.098]                 else {
[09:31:33.098]                   if (TRUE) {
[09:31:33.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.098]                     {
[09:31:33.098]                       inherits <- base::inherits
[09:31:33.098]                       invokeRestart <- base::invokeRestart
[09:31:33.098]                       is.null <- base::is.null
[09:31:33.098]                       muffled <- FALSE
[09:31:33.098]                       if (inherits(cond, "message")) {
[09:31:33.098]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.098]                         if (muffled) 
[09:31:33.098]                           invokeRestart("muffleMessage")
[09:31:33.098]                       }
[09:31:33.098]                       else if (inherits(cond, "warning")) {
[09:31:33.098]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.098]                         if (muffled) 
[09:31:33.098]                           invokeRestart("muffleWarning")
[09:31:33.098]                       }
[09:31:33.098]                       else if (inherits(cond, "condition")) {
[09:31:33.098]                         if (!is.null(pattern)) {
[09:31:33.098]                           computeRestarts <- base::computeRestarts
[09:31:33.098]                           grepl <- base::grepl
[09:31:33.098]                           restarts <- computeRestarts(cond)
[09:31:33.098]                           for (restart in restarts) {
[09:31:33.098]                             name <- restart$name
[09:31:33.098]                             if (is.null(name)) 
[09:31:33.098]                               next
[09:31:33.098]                             if (!grepl(pattern, name)) 
[09:31:33.098]                               next
[09:31:33.098]                             invokeRestart(restart)
[09:31:33.098]                             muffled <- TRUE
[09:31:33.098]                             break
[09:31:33.098]                           }
[09:31:33.098]                         }
[09:31:33.098]                       }
[09:31:33.098]                       invisible(muffled)
[09:31:33.098]                     }
[09:31:33.098]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.098]                   }
[09:31:33.098]                 }
[09:31:33.098]             }
[09:31:33.098]         }))
[09:31:33.098]     }, error = function(ex) {
[09:31:33.098]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.098]                 ...future.rng), started = ...future.startTime, 
[09:31:33.098]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.098]             version = "1.8"), class = "FutureResult")
[09:31:33.098]     }, finally = {
[09:31:33.098]         if (!identical(...future.workdir, getwd())) 
[09:31:33.098]             setwd(...future.workdir)
[09:31:33.098]         {
[09:31:33.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.098]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.098]             }
[09:31:33.098]             base::options(...future.oldOptions)
[09:31:33.098]             if (.Platform$OS.type == "windows") {
[09:31:33.098]                 old_names <- names(...future.oldEnvVars)
[09:31:33.098]                 envs <- base::Sys.getenv()
[09:31:33.098]                 names <- names(envs)
[09:31:33.098]                 common <- intersect(names, old_names)
[09:31:33.098]                 added <- setdiff(names, old_names)
[09:31:33.098]                 removed <- setdiff(old_names, names)
[09:31:33.098]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.098]                   envs[common]]
[09:31:33.098]                 NAMES <- toupper(changed)
[09:31:33.098]                 args <- list()
[09:31:33.098]                 for (kk in seq_along(NAMES)) {
[09:31:33.098]                   name <- changed[[kk]]
[09:31:33.098]                   NAME <- NAMES[[kk]]
[09:31:33.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.098]                     next
[09:31:33.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.098]                 }
[09:31:33.098]                 NAMES <- toupper(added)
[09:31:33.098]                 for (kk in seq_along(NAMES)) {
[09:31:33.098]                   name <- added[[kk]]
[09:31:33.098]                   NAME <- NAMES[[kk]]
[09:31:33.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.098]                     next
[09:31:33.098]                   args[[name]] <- ""
[09:31:33.098]                 }
[09:31:33.098]                 NAMES <- toupper(removed)
[09:31:33.098]                 for (kk in seq_along(NAMES)) {
[09:31:33.098]                   name <- removed[[kk]]
[09:31:33.098]                   NAME <- NAMES[[kk]]
[09:31:33.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.098]                     next
[09:31:33.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.098]                 }
[09:31:33.098]                 if (length(args) > 0) 
[09:31:33.098]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.098]             }
[09:31:33.098]             else {
[09:31:33.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.098]             }
[09:31:33.098]             {
[09:31:33.098]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.098]                   0L) {
[09:31:33.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.098]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.098]                   base::options(opts)
[09:31:33.098]                 }
[09:31:33.098]                 {
[09:31:33.098]                   {
[09:31:33.098]                     NULL
[09:31:33.098]                     RNGkind("Mersenne-Twister")
[09:31:33.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.098]                       inherits = FALSE)
[09:31:33.098]                   }
[09:31:33.098]                   options(future.plan = NULL)
[09:31:33.098]                   if (is.na(NA_character_)) 
[09:31:33.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.098]                     .init = FALSE)
[09:31:33.098]                 }
[09:31:33.098]             }
[09:31:33.098]         }
[09:31:33.098]     })
[09:31:33.098]     if (TRUE) {
[09:31:33.098]         base::sink(type = "output", split = FALSE)
[09:31:33.098]         if (TRUE) {
[09:31:33.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.098]         }
[09:31:33.098]         else {
[09:31:33.098]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.098]         }
[09:31:33.098]         base::close(...future.stdout)
[09:31:33.098]         ...future.stdout <- NULL
[09:31:33.098]     }
[09:31:33.098]     ...future.result$conditions <- ...future.conditions
[09:31:33.098]     ...future.result$finished <- base::Sys.time()
[09:31:33.098]     ...future.result
[09:31:33.098] }
[09:31:33.100] assign_globals() ...
[09:31:33.100] List of 1
[09:31:33.100]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a4a8418> 
[09:31:33.100]  - attr(*, "where")=List of 1
[09:31:33.100]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.100]  - attr(*, "resolved")= logi TRUE
[09:31:33.100]  - attr(*, "total_size")= num 10424
[09:31:33.100]  - attr(*, "already-done")= logi TRUE
[09:31:33.102] - copied ‘a’ to environment
[09:31:33.102] assign_globals() ... done
[09:31:33.103] plan(): Setting new future strategy stack:
[09:31:33.103] List of future strategies:
[09:31:33.103] 1. sequential:
[09:31:33.103]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.103]    - tweaked: FALSE
[09:31:33.103]    - call: NULL
[09:31:33.103] plan(): nbrOfWorkers() = 1
[09:31:33.104] plan(): Setting new future strategy stack:
[09:31:33.104] List of future strategies:
[09:31:33.104] 1. sequential:
[09:31:33.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.104]    - tweaked: FALSE
[09:31:33.104]    - call: plan(strategy)
[09:31:33.104] plan(): nbrOfWorkers() = 1
[09:31:33.104] SequentialFuture started (and completed)
[09:31:33.105] - Launch lazy future ... done
[09:31:33.105] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.105] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.105] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.106] 
[09:31:33.106] Searching for globals ... DONE
[09:31:33.106] - globals: [0] <none>
[09:31:33.106] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.106] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.106] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.107] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.107] Searching for globals ... DONE
[09:31:33.107] Resolving globals: TRUE
[09:31:33.107] Resolving any globals that are futures ...
[09:31:33.108] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.108] Resolving any globals that are futures ... DONE
[09:31:33.108] Resolving futures part of globals (recursively) ...
[09:31:33.108] resolve() on list ...
[09:31:33.108]  recursive: 99
[09:31:33.108]  length: 1
[09:31:33.108]  elements: ‘a’
[09:31:33.109] run() for ‘Future’ ...
[09:31:33.109] - state: ‘created’
[09:31:33.109] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.109] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.109]   - Field: ‘label’
[09:31:33.109]   - Field: ‘local’
[09:31:33.109]   - Field: ‘owner’
[09:31:33.109]   - Field: ‘envir’
[09:31:33.110]   - Field: ‘packages’
[09:31:33.110]   - Field: ‘gc’
[09:31:33.110]   - Field: ‘conditions’
[09:31:33.110]   - Field: ‘expr’
[09:31:33.110]   - Field: ‘uuid’
[09:31:33.110]   - Field: ‘seed’
[09:31:33.110]   - Field: ‘version’
[09:31:33.110]   - Field: ‘result’
[09:31:33.110]   - Field: ‘asynchronous’
[09:31:33.110]   - Field: ‘calls’
[09:31:33.110]   - Field: ‘globals’
[09:31:33.110]   - Field: ‘stdout’
[09:31:33.111]   - Field: ‘earlySignal’
[09:31:33.111]   - Field: ‘lazy’
[09:31:33.111]   - Field: ‘state’
[09:31:33.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.111] - Launch lazy future ...
[09:31:33.111] Packages needed by the future expression (n = 0): <none>
[09:31:33.111] Packages needed by future strategies (n = 0): <none>
[09:31:33.111] {
[09:31:33.111]     {
[09:31:33.111]         {
[09:31:33.111]             ...future.startTime <- base::Sys.time()
[09:31:33.111]             {
[09:31:33.111]                 {
[09:31:33.111]                   {
[09:31:33.111]                     base::local({
[09:31:33.111]                       has_future <- base::requireNamespace("future", 
[09:31:33.111]                         quietly = TRUE)
[09:31:33.111]                       if (has_future) {
[09:31:33.111]                         ns <- base::getNamespace("future")
[09:31:33.111]                         version <- ns[[".package"]][["version"]]
[09:31:33.111]                         if (is.null(version)) 
[09:31:33.111]                           version <- utils::packageVersion("future")
[09:31:33.111]                       }
[09:31:33.111]                       else {
[09:31:33.111]                         version <- NULL
[09:31:33.111]                       }
[09:31:33.111]                       if (!has_future || version < "1.8.0") {
[09:31:33.111]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.111]                           "", base::R.version$version.string), 
[09:31:33.111]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.111]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.111]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.111]                             "release", "version")], collapse = " "), 
[09:31:33.111]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.111]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.111]                           info)
[09:31:33.111]                         info <- base::paste(info, collapse = "; ")
[09:31:33.111]                         if (!has_future) {
[09:31:33.111]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.111]                             info)
[09:31:33.111]                         }
[09:31:33.111]                         else {
[09:31:33.111]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.111]                             info, version)
[09:31:33.111]                         }
[09:31:33.111]                         base::stop(msg)
[09:31:33.111]                       }
[09:31:33.111]                     })
[09:31:33.111]                   }
[09:31:33.111]                   ...future.strategy.old <- future::plan("list")
[09:31:33.111]                   options(future.plan = NULL)
[09:31:33.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.111]                 }
[09:31:33.111]                 ...future.workdir <- getwd()
[09:31:33.111]             }
[09:31:33.111]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.111]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.111]         }
[09:31:33.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.111]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.111]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.111]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.111]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.111]             base::names(...future.oldOptions))
[09:31:33.111]     }
[09:31:33.111]     if (FALSE) {
[09:31:33.111]     }
[09:31:33.111]     else {
[09:31:33.111]         if (TRUE) {
[09:31:33.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.111]                 open = "w")
[09:31:33.111]         }
[09:31:33.111]         else {
[09:31:33.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.111]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.111]         }
[09:31:33.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.111]             base::sink(type = "output", split = FALSE)
[09:31:33.111]             base::close(...future.stdout)
[09:31:33.111]         }, add = TRUE)
[09:31:33.111]     }
[09:31:33.111]     ...future.frame <- base::sys.nframe()
[09:31:33.111]     ...future.conditions <- base::list()
[09:31:33.111]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.111]     if (FALSE) {
[09:31:33.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.111]     }
[09:31:33.111]     ...future.result <- base::tryCatch({
[09:31:33.111]         base::withCallingHandlers({
[09:31:33.111]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.111]             future::FutureResult(value = ...future.value$value, 
[09:31:33.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.111]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.111]                     ...future.globalenv.names))
[09:31:33.111]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.111]         }, condition = base::local({
[09:31:33.111]             c <- base::c
[09:31:33.111]             inherits <- base::inherits
[09:31:33.111]             invokeRestart <- base::invokeRestart
[09:31:33.111]             length <- base::length
[09:31:33.111]             list <- base::list
[09:31:33.111]             seq.int <- base::seq.int
[09:31:33.111]             signalCondition <- base::signalCondition
[09:31:33.111]             sys.calls <- base::sys.calls
[09:31:33.111]             `[[` <- base::`[[`
[09:31:33.111]             `+` <- base::`+`
[09:31:33.111]             `<<-` <- base::`<<-`
[09:31:33.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.111]                   3L)]
[09:31:33.111]             }
[09:31:33.111]             function(cond) {
[09:31:33.111]                 is_error <- inherits(cond, "error")
[09:31:33.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.111]                   NULL)
[09:31:33.111]                 if (is_error) {
[09:31:33.111]                   sessionInformation <- function() {
[09:31:33.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.111]                       search = base::search(), system = base::Sys.info())
[09:31:33.111]                   }
[09:31:33.111]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.111]                     cond$call), session = sessionInformation(), 
[09:31:33.111]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.111]                   signalCondition(cond)
[09:31:33.111]                 }
[09:31:33.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.111]                 "immediateCondition"))) {
[09:31:33.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.111]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.111]                   if (TRUE && !signal) {
[09:31:33.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.111]                     {
[09:31:33.111]                       inherits <- base::inherits
[09:31:33.111]                       invokeRestart <- base::invokeRestart
[09:31:33.111]                       is.null <- base::is.null
[09:31:33.111]                       muffled <- FALSE
[09:31:33.111]                       if (inherits(cond, "message")) {
[09:31:33.111]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.111]                         if (muffled) 
[09:31:33.111]                           invokeRestart("muffleMessage")
[09:31:33.111]                       }
[09:31:33.111]                       else if (inherits(cond, "warning")) {
[09:31:33.111]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.111]                         if (muffled) 
[09:31:33.111]                           invokeRestart("muffleWarning")
[09:31:33.111]                       }
[09:31:33.111]                       else if (inherits(cond, "condition")) {
[09:31:33.111]                         if (!is.null(pattern)) {
[09:31:33.111]                           computeRestarts <- base::computeRestarts
[09:31:33.111]                           grepl <- base::grepl
[09:31:33.111]                           restarts <- computeRestarts(cond)
[09:31:33.111]                           for (restart in restarts) {
[09:31:33.111]                             name <- restart$name
[09:31:33.111]                             if (is.null(name)) 
[09:31:33.111]                               next
[09:31:33.111]                             if (!grepl(pattern, name)) 
[09:31:33.111]                               next
[09:31:33.111]                             invokeRestart(restart)
[09:31:33.111]                             muffled <- TRUE
[09:31:33.111]                             break
[09:31:33.111]                           }
[09:31:33.111]                         }
[09:31:33.111]                       }
[09:31:33.111]                       invisible(muffled)
[09:31:33.111]                     }
[09:31:33.111]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.111]                   }
[09:31:33.111]                 }
[09:31:33.111]                 else {
[09:31:33.111]                   if (TRUE) {
[09:31:33.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.111]                     {
[09:31:33.111]                       inherits <- base::inherits
[09:31:33.111]                       invokeRestart <- base::invokeRestart
[09:31:33.111]                       is.null <- base::is.null
[09:31:33.111]                       muffled <- FALSE
[09:31:33.111]                       if (inherits(cond, "message")) {
[09:31:33.111]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.111]                         if (muffled) 
[09:31:33.111]                           invokeRestart("muffleMessage")
[09:31:33.111]                       }
[09:31:33.111]                       else if (inherits(cond, "warning")) {
[09:31:33.111]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.111]                         if (muffled) 
[09:31:33.111]                           invokeRestart("muffleWarning")
[09:31:33.111]                       }
[09:31:33.111]                       else if (inherits(cond, "condition")) {
[09:31:33.111]                         if (!is.null(pattern)) {
[09:31:33.111]                           computeRestarts <- base::computeRestarts
[09:31:33.111]                           grepl <- base::grepl
[09:31:33.111]                           restarts <- computeRestarts(cond)
[09:31:33.111]                           for (restart in restarts) {
[09:31:33.111]                             name <- restart$name
[09:31:33.111]                             if (is.null(name)) 
[09:31:33.111]                               next
[09:31:33.111]                             if (!grepl(pattern, name)) 
[09:31:33.111]                               next
[09:31:33.111]                             invokeRestart(restart)
[09:31:33.111]                             muffled <- TRUE
[09:31:33.111]                             break
[09:31:33.111]                           }
[09:31:33.111]                         }
[09:31:33.111]                       }
[09:31:33.111]                       invisible(muffled)
[09:31:33.111]                     }
[09:31:33.111]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.111]                   }
[09:31:33.111]                 }
[09:31:33.111]             }
[09:31:33.111]         }))
[09:31:33.111]     }, error = function(ex) {
[09:31:33.111]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.111]                 ...future.rng), started = ...future.startTime, 
[09:31:33.111]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.111]             version = "1.8"), class = "FutureResult")
[09:31:33.111]     }, finally = {
[09:31:33.111]         if (!identical(...future.workdir, getwd())) 
[09:31:33.111]             setwd(...future.workdir)
[09:31:33.111]         {
[09:31:33.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.111]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.111]             }
[09:31:33.111]             base::options(...future.oldOptions)
[09:31:33.111]             if (.Platform$OS.type == "windows") {
[09:31:33.111]                 old_names <- names(...future.oldEnvVars)
[09:31:33.111]                 envs <- base::Sys.getenv()
[09:31:33.111]                 names <- names(envs)
[09:31:33.111]                 common <- intersect(names, old_names)
[09:31:33.111]                 added <- setdiff(names, old_names)
[09:31:33.111]                 removed <- setdiff(old_names, names)
[09:31:33.111]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.111]                   envs[common]]
[09:31:33.111]                 NAMES <- toupper(changed)
[09:31:33.111]                 args <- list()
[09:31:33.111]                 for (kk in seq_along(NAMES)) {
[09:31:33.111]                   name <- changed[[kk]]
[09:31:33.111]                   NAME <- NAMES[[kk]]
[09:31:33.111]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.111]                     next
[09:31:33.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.111]                 }
[09:31:33.111]                 NAMES <- toupper(added)
[09:31:33.111]                 for (kk in seq_along(NAMES)) {
[09:31:33.111]                   name <- added[[kk]]
[09:31:33.111]                   NAME <- NAMES[[kk]]
[09:31:33.111]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.111]                     next
[09:31:33.111]                   args[[name]] <- ""
[09:31:33.111]                 }
[09:31:33.111]                 NAMES <- toupper(removed)
[09:31:33.111]                 for (kk in seq_along(NAMES)) {
[09:31:33.111]                   name <- removed[[kk]]
[09:31:33.111]                   NAME <- NAMES[[kk]]
[09:31:33.111]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.111]                     next
[09:31:33.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.111]                 }
[09:31:33.111]                 if (length(args) > 0) 
[09:31:33.111]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.111]             }
[09:31:33.111]             else {
[09:31:33.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.111]             }
[09:31:33.111]             {
[09:31:33.111]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.111]                   0L) {
[09:31:33.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.111]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.111]                   base::options(opts)
[09:31:33.111]                 }
[09:31:33.111]                 {
[09:31:33.111]                   {
[09:31:33.111]                     NULL
[09:31:33.111]                     RNGkind("Mersenne-Twister")
[09:31:33.111]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.111]                       inherits = FALSE)
[09:31:33.111]                   }
[09:31:33.111]                   options(future.plan = NULL)
[09:31:33.111]                   if (is.na(NA_character_)) 
[09:31:33.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.111]                     .init = FALSE)
[09:31:33.111]                 }
[09:31:33.111]             }
[09:31:33.111]         }
[09:31:33.111]     })
[09:31:33.111]     if (TRUE) {
[09:31:33.111]         base::sink(type = "output", split = FALSE)
[09:31:33.111]         if (TRUE) {
[09:31:33.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.111]         }
[09:31:33.111]         else {
[09:31:33.111]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.111]         }
[09:31:33.111]         base::close(...future.stdout)
[09:31:33.111]         ...future.stdout <- NULL
[09:31:33.111]     }
[09:31:33.111]     ...future.result$conditions <- ...future.conditions
[09:31:33.111]     ...future.result$finished <- base::Sys.time()
[09:31:33.111]     ...future.result
[09:31:33.111] }
[09:31:33.113] plan(): Setting new future strategy stack:
[09:31:33.113] List of future strategies:
[09:31:33.113] 1. sequential:
[09:31:33.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.113]    - tweaked: FALSE
[09:31:33.113]    - call: NULL
[09:31:33.114] plan(): nbrOfWorkers() = 1
[09:31:33.114] plan(): Setting new future strategy stack:
[09:31:33.114] List of future strategies:
[09:31:33.114] 1. sequential:
[09:31:33.114]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.114]    - tweaked: FALSE
[09:31:33.114]    - call: plan(strategy)
[09:31:33.115] plan(): nbrOfWorkers() = 1
[09:31:33.115] SequentialFuture started (and completed)
[09:31:33.115] - Launch lazy future ... done
[09:31:33.115] run() for ‘SequentialFuture’ ... done
[09:31:33.115] resolved() for ‘SequentialFuture’ ...
[09:31:33.115] - state: ‘finished’
[09:31:33.115] - run: TRUE
[09:31:33.115] - result: ‘FutureResult’
[09:31:33.116] resolved() for ‘SequentialFuture’ ... done
[09:31:33.116] Future #1
[09:31:33.116] resolved() for ‘SequentialFuture’ ...
[09:31:33.116] - state: ‘finished’
[09:31:33.116] - run: TRUE
[09:31:33.116] - result: ‘FutureResult’
[09:31:33.116] resolved() for ‘SequentialFuture’ ... done
[09:31:33.116] A SequentialFuture was resolved
[09:31:33.116]  length: 0 (resolved future 1)
[09:31:33.116] resolve() on list ... DONE
[09:31:33.117] - globals: [1] ‘a’
[09:31:33.117] Resolving futures part of globals (recursively) ... DONE
[09:31:33.117] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[09:31:33.118] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[09:31:33.118] - globals: [1] ‘a’
[09:31:33.118] - packages: [1] ‘future’
[09:31:33.118] getGlobalsAndPackages() ... DONE
[09:31:33.118] run() for ‘Future’ ...
[09:31:33.118] - state: ‘created’
[09:31:33.118] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.119] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.119]   - Field: ‘label’
[09:31:33.119]   - Field: ‘local’
[09:31:33.120]   - Field: ‘owner’
[09:31:33.120]   - Field: ‘envir’
[09:31:33.120]   - Field: ‘packages’
[09:31:33.120]   - Field: ‘gc’
[09:31:33.120]   - Field: ‘conditions’
[09:31:33.120]   - Field: ‘expr’
[09:31:33.120]   - Field: ‘uuid’
[09:31:33.121]   - Field: ‘seed’
[09:31:33.121]   - Field: ‘version’
[09:31:33.121]   - Field: ‘result’
[09:31:33.121]   - Field: ‘asynchronous’
[09:31:33.121]   - Field: ‘calls’
[09:31:33.121]   - Field: ‘globals’
[09:31:33.121]   - Field: ‘stdout’
[09:31:33.121]   - Field: ‘earlySignal’
[09:31:33.121]   - Field: ‘lazy’
[09:31:33.121]   - Field: ‘state’
[09:31:33.121] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.121] - Launch lazy future ...
[09:31:33.122] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.122] Packages needed by future strategies (n = 0): <none>
[09:31:33.122] {
[09:31:33.122]     {
[09:31:33.122]         {
[09:31:33.122]             ...future.startTime <- base::Sys.time()
[09:31:33.122]             {
[09:31:33.122]                 {
[09:31:33.122]                   {
[09:31:33.122]                     {
[09:31:33.122]                       base::local({
[09:31:33.122]                         has_future <- base::requireNamespace("future", 
[09:31:33.122]                           quietly = TRUE)
[09:31:33.122]                         if (has_future) {
[09:31:33.122]                           ns <- base::getNamespace("future")
[09:31:33.122]                           version <- ns[[".package"]][["version"]]
[09:31:33.122]                           if (is.null(version)) 
[09:31:33.122]                             version <- utils::packageVersion("future")
[09:31:33.122]                         }
[09:31:33.122]                         else {
[09:31:33.122]                           version <- NULL
[09:31:33.122]                         }
[09:31:33.122]                         if (!has_future || version < "1.8.0") {
[09:31:33.122]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.122]                             "", base::R.version$version.string), 
[09:31:33.122]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.122]                               "release", "version")], collapse = " "), 
[09:31:33.122]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.122]                             info)
[09:31:33.122]                           info <- base::paste(info, collapse = "; ")
[09:31:33.122]                           if (!has_future) {
[09:31:33.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.122]                               info)
[09:31:33.122]                           }
[09:31:33.122]                           else {
[09:31:33.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.122]                               info, version)
[09:31:33.122]                           }
[09:31:33.122]                           base::stop(msg)
[09:31:33.122]                         }
[09:31:33.122]                       })
[09:31:33.122]                     }
[09:31:33.122]                     base::local({
[09:31:33.122]                       for (pkg in "future") {
[09:31:33.122]                         base::loadNamespace(pkg)
[09:31:33.122]                         base::library(pkg, character.only = TRUE)
[09:31:33.122]                       }
[09:31:33.122]                     })
[09:31:33.122]                   }
[09:31:33.122]                   ...future.strategy.old <- future::plan("list")
[09:31:33.122]                   options(future.plan = NULL)
[09:31:33.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.122]                 }
[09:31:33.122]                 ...future.workdir <- getwd()
[09:31:33.122]             }
[09:31:33.122]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.122]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.122]         }
[09:31:33.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.122]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.122]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.122]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.122]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.122]             base::names(...future.oldOptions))
[09:31:33.122]     }
[09:31:33.122]     if (FALSE) {
[09:31:33.122]     }
[09:31:33.122]     else {
[09:31:33.122]         if (TRUE) {
[09:31:33.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.122]                 open = "w")
[09:31:33.122]         }
[09:31:33.122]         else {
[09:31:33.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.122]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.122]         }
[09:31:33.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.122]             base::sink(type = "output", split = FALSE)
[09:31:33.122]             base::close(...future.stdout)
[09:31:33.122]         }, add = TRUE)
[09:31:33.122]     }
[09:31:33.122]     ...future.frame <- base::sys.nframe()
[09:31:33.122]     ...future.conditions <- base::list()
[09:31:33.122]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.122]     if (FALSE) {
[09:31:33.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.122]     }
[09:31:33.122]     ...future.result <- base::tryCatch({
[09:31:33.122]         base::withCallingHandlers({
[09:31:33.122]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.122]                 1))
[09:31:33.122]             future::FutureResult(value = ...future.value$value, 
[09:31:33.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.122]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.122]                     ...future.globalenv.names))
[09:31:33.122]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.122]         }, condition = base::local({
[09:31:33.122]             c <- base::c
[09:31:33.122]             inherits <- base::inherits
[09:31:33.122]             invokeRestart <- base::invokeRestart
[09:31:33.122]             length <- base::length
[09:31:33.122]             list <- base::list
[09:31:33.122]             seq.int <- base::seq.int
[09:31:33.122]             signalCondition <- base::signalCondition
[09:31:33.122]             sys.calls <- base::sys.calls
[09:31:33.122]             `[[` <- base::`[[`
[09:31:33.122]             `+` <- base::`+`
[09:31:33.122]             `<<-` <- base::`<<-`
[09:31:33.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.122]                   3L)]
[09:31:33.122]             }
[09:31:33.122]             function(cond) {
[09:31:33.122]                 is_error <- inherits(cond, "error")
[09:31:33.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.122]                   NULL)
[09:31:33.122]                 if (is_error) {
[09:31:33.122]                   sessionInformation <- function() {
[09:31:33.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.122]                       search = base::search(), system = base::Sys.info())
[09:31:33.122]                   }
[09:31:33.122]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.122]                     cond$call), session = sessionInformation(), 
[09:31:33.122]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.122]                   signalCondition(cond)
[09:31:33.122]                 }
[09:31:33.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.122]                 "immediateCondition"))) {
[09:31:33.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.122]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.122]                   if (TRUE && !signal) {
[09:31:33.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.122]                     {
[09:31:33.122]                       inherits <- base::inherits
[09:31:33.122]                       invokeRestart <- base::invokeRestart
[09:31:33.122]                       is.null <- base::is.null
[09:31:33.122]                       muffled <- FALSE
[09:31:33.122]                       if (inherits(cond, "message")) {
[09:31:33.122]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.122]                         if (muffled) 
[09:31:33.122]                           invokeRestart("muffleMessage")
[09:31:33.122]                       }
[09:31:33.122]                       else if (inherits(cond, "warning")) {
[09:31:33.122]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.122]                         if (muffled) 
[09:31:33.122]                           invokeRestart("muffleWarning")
[09:31:33.122]                       }
[09:31:33.122]                       else if (inherits(cond, "condition")) {
[09:31:33.122]                         if (!is.null(pattern)) {
[09:31:33.122]                           computeRestarts <- base::computeRestarts
[09:31:33.122]                           grepl <- base::grepl
[09:31:33.122]                           restarts <- computeRestarts(cond)
[09:31:33.122]                           for (restart in restarts) {
[09:31:33.122]                             name <- restart$name
[09:31:33.122]                             if (is.null(name)) 
[09:31:33.122]                               next
[09:31:33.122]                             if (!grepl(pattern, name)) 
[09:31:33.122]                               next
[09:31:33.122]                             invokeRestart(restart)
[09:31:33.122]                             muffled <- TRUE
[09:31:33.122]                             break
[09:31:33.122]                           }
[09:31:33.122]                         }
[09:31:33.122]                       }
[09:31:33.122]                       invisible(muffled)
[09:31:33.122]                     }
[09:31:33.122]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.122]                   }
[09:31:33.122]                 }
[09:31:33.122]                 else {
[09:31:33.122]                   if (TRUE) {
[09:31:33.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.122]                     {
[09:31:33.122]                       inherits <- base::inherits
[09:31:33.122]                       invokeRestart <- base::invokeRestart
[09:31:33.122]                       is.null <- base::is.null
[09:31:33.122]                       muffled <- FALSE
[09:31:33.122]                       if (inherits(cond, "message")) {
[09:31:33.122]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.122]                         if (muffled) 
[09:31:33.122]                           invokeRestart("muffleMessage")
[09:31:33.122]                       }
[09:31:33.122]                       else if (inherits(cond, "warning")) {
[09:31:33.122]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.122]                         if (muffled) 
[09:31:33.122]                           invokeRestart("muffleWarning")
[09:31:33.122]                       }
[09:31:33.122]                       else if (inherits(cond, "condition")) {
[09:31:33.122]                         if (!is.null(pattern)) {
[09:31:33.122]                           computeRestarts <- base::computeRestarts
[09:31:33.122]                           grepl <- base::grepl
[09:31:33.122]                           restarts <- computeRestarts(cond)
[09:31:33.122]                           for (restart in restarts) {
[09:31:33.122]                             name <- restart$name
[09:31:33.122]                             if (is.null(name)) 
[09:31:33.122]                               next
[09:31:33.122]                             if (!grepl(pattern, name)) 
[09:31:33.122]                               next
[09:31:33.122]                             invokeRestart(restart)
[09:31:33.122]                             muffled <- TRUE
[09:31:33.122]                             break
[09:31:33.122]                           }
[09:31:33.122]                         }
[09:31:33.122]                       }
[09:31:33.122]                       invisible(muffled)
[09:31:33.122]                     }
[09:31:33.122]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.122]                   }
[09:31:33.122]                 }
[09:31:33.122]             }
[09:31:33.122]         }))
[09:31:33.122]     }, error = function(ex) {
[09:31:33.122]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.122]                 ...future.rng), started = ...future.startTime, 
[09:31:33.122]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.122]             version = "1.8"), class = "FutureResult")
[09:31:33.122]     }, finally = {
[09:31:33.122]         if (!identical(...future.workdir, getwd())) 
[09:31:33.122]             setwd(...future.workdir)
[09:31:33.122]         {
[09:31:33.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.122]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.122]             }
[09:31:33.122]             base::options(...future.oldOptions)
[09:31:33.122]             if (.Platform$OS.type == "windows") {
[09:31:33.122]                 old_names <- names(...future.oldEnvVars)
[09:31:33.122]                 envs <- base::Sys.getenv()
[09:31:33.122]                 names <- names(envs)
[09:31:33.122]                 common <- intersect(names, old_names)
[09:31:33.122]                 added <- setdiff(names, old_names)
[09:31:33.122]                 removed <- setdiff(old_names, names)
[09:31:33.122]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.122]                   envs[common]]
[09:31:33.122]                 NAMES <- toupper(changed)
[09:31:33.122]                 args <- list()
[09:31:33.122]                 for (kk in seq_along(NAMES)) {
[09:31:33.122]                   name <- changed[[kk]]
[09:31:33.122]                   NAME <- NAMES[[kk]]
[09:31:33.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.122]                     next
[09:31:33.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.122]                 }
[09:31:33.122]                 NAMES <- toupper(added)
[09:31:33.122]                 for (kk in seq_along(NAMES)) {
[09:31:33.122]                   name <- added[[kk]]
[09:31:33.122]                   NAME <- NAMES[[kk]]
[09:31:33.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.122]                     next
[09:31:33.122]                   args[[name]] <- ""
[09:31:33.122]                 }
[09:31:33.122]                 NAMES <- toupper(removed)
[09:31:33.122]                 for (kk in seq_along(NAMES)) {
[09:31:33.122]                   name <- removed[[kk]]
[09:31:33.122]                   NAME <- NAMES[[kk]]
[09:31:33.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.122]                     next
[09:31:33.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.122]                 }
[09:31:33.122]                 if (length(args) > 0) 
[09:31:33.122]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.122]             }
[09:31:33.122]             else {
[09:31:33.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.122]             }
[09:31:33.122]             {
[09:31:33.122]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.122]                   0L) {
[09:31:33.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.122]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.122]                   base::options(opts)
[09:31:33.122]                 }
[09:31:33.122]                 {
[09:31:33.122]                   {
[09:31:33.122]                     NULL
[09:31:33.122]                     RNGkind("Mersenne-Twister")
[09:31:33.122]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.122]                       inherits = FALSE)
[09:31:33.122]                   }
[09:31:33.122]                   options(future.plan = NULL)
[09:31:33.122]                   if (is.na(NA_character_)) 
[09:31:33.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.122]                     .init = FALSE)
[09:31:33.122]                 }
[09:31:33.122]             }
[09:31:33.122]         }
[09:31:33.122]     })
[09:31:33.122]     if (TRUE) {
[09:31:33.122]         base::sink(type = "output", split = FALSE)
[09:31:33.122]         if (TRUE) {
[09:31:33.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.122]         }
[09:31:33.122]         else {
[09:31:33.122]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.122]         }
[09:31:33.122]         base::close(...future.stdout)
[09:31:33.122]         ...future.stdout <- NULL
[09:31:33.122]     }
[09:31:33.122]     ...future.result$conditions <- ...future.conditions
[09:31:33.122]     ...future.result$finished <- base::Sys.time()
[09:31:33.122]     ...future.result
[09:31:33.122] }
[09:31:33.124] assign_globals() ...
[09:31:33.124] List of 1
[09:31:33.124]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a270df8> 
[09:31:33.124]  - attr(*, "where")=List of 1
[09:31:33.124]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.124]  - attr(*, "resolved")= logi TRUE
[09:31:33.124]  - attr(*, "total_size")= num 10592
[09:31:33.124]  - attr(*, "already-done")= logi TRUE
[09:31:33.126] - copied ‘a’ to environment
[09:31:33.126] assign_globals() ... done
[09:31:33.126] plan(): Setting new future strategy stack:
[09:31:33.126] List of future strategies:
[09:31:33.126] 1. sequential:
[09:31:33.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.126]    - tweaked: FALSE
[09:31:33.126]    - call: NULL
[09:31:33.127] plan(): nbrOfWorkers() = 1
[09:31:33.128] plan(): Setting new future strategy stack:
[09:31:33.128] List of future strategies:
[09:31:33.128] 1. sequential:
[09:31:33.128]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.128]    - tweaked: FALSE
[09:31:33.128]    - call: plan(strategy)
[09:31:33.128] plan(): nbrOfWorkers() = 1
[09:31:33.128] SequentialFuture started (and completed)
[09:31:33.128] - Launch lazy future ... done
[09:31:33.128] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.129] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.129] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.130] 
[09:31:33.130] Searching for globals ... DONE
[09:31:33.130] - globals: [0] <none>
[09:31:33.130] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.130] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.130] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.131] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.131] Searching for globals ... DONE
[09:31:33.131] Resolving globals: TRUE
[09:31:33.131] Resolving any globals that are futures ...
[09:31:33.131] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.132] Resolving any globals that are futures ... DONE
[09:31:33.132] Resolving futures part of globals (recursively) ...
[09:31:33.132] resolve() on list ...
[09:31:33.132]  recursive: 99
[09:31:33.132]  length: 1
[09:31:33.132]  elements: ‘a’
[09:31:33.132] run() for ‘Future’ ...
[09:31:33.133] - state: ‘created’
[09:31:33.133] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.133]   - Field: ‘label’
[09:31:33.133]   - Field: ‘local’
[09:31:33.133]   - Field: ‘owner’
[09:31:33.133]   - Field: ‘envir’
[09:31:33.133]   - Field: ‘packages’
[09:31:33.133]   - Field: ‘gc’
[09:31:33.134]   - Field: ‘conditions’
[09:31:33.134]   - Field: ‘expr’
[09:31:33.134]   - Field: ‘uuid’
[09:31:33.134]   - Field: ‘seed’
[09:31:33.134]   - Field: ‘version’
[09:31:33.134]   - Field: ‘result’
[09:31:33.134]   - Field: ‘asynchronous’
[09:31:33.134]   - Field: ‘calls’
[09:31:33.134]   - Field: ‘globals’
[09:31:33.134]   - Field: ‘stdout’
[09:31:33.134]   - Field: ‘earlySignal’
[09:31:33.134]   - Field: ‘lazy’
[09:31:33.135]   - Field: ‘state’
[09:31:33.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.135] - Launch lazy future ...
[09:31:33.135] Packages needed by the future expression (n = 0): <none>
[09:31:33.135] Packages needed by future strategies (n = 0): <none>
[09:31:33.135] {
[09:31:33.135]     {
[09:31:33.135]         {
[09:31:33.135]             ...future.startTime <- base::Sys.time()
[09:31:33.135]             {
[09:31:33.135]                 {
[09:31:33.135]                   {
[09:31:33.135]                     base::local({
[09:31:33.135]                       has_future <- base::requireNamespace("future", 
[09:31:33.135]                         quietly = TRUE)
[09:31:33.135]                       if (has_future) {
[09:31:33.135]                         ns <- base::getNamespace("future")
[09:31:33.135]                         version <- ns[[".package"]][["version"]]
[09:31:33.135]                         if (is.null(version)) 
[09:31:33.135]                           version <- utils::packageVersion("future")
[09:31:33.135]                       }
[09:31:33.135]                       else {
[09:31:33.135]                         version <- NULL
[09:31:33.135]                       }
[09:31:33.135]                       if (!has_future || version < "1.8.0") {
[09:31:33.135]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.135]                           "", base::R.version$version.string), 
[09:31:33.135]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.135]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.135]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.135]                             "release", "version")], collapse = " "), 
[09:31:33.135]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.135]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.135]                           info)
[09:31:33.135]                         info <- base::paste(info, collapse = "; ")
[09:31:33.135]                         if (!has_future) {
[09:31:33.135]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.135]                             info)
[09:31:33.135]                         }
[09:31:33.135]                         else {
[09:31:33.135]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.135]                             info, version)
[09:31:33.135]                         }
[09:31:33.135]                         base::stop(msg)
[09:31:33.135]                       }
[09:31:33.135]                     })
[09:31:33.135]                   }
[09:31:33.135]                   ...future.strategy.old <- future::plan("list")
[09:31:33.135]                   options(future.plan = NULL)
[09:31:33.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.135]                 }
[09:31:33.135]                 ...future.workdir <- getwd()
[09:31:33.135]             }
[09:31:33.135]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.135]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.135]         }
[09:31:33.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.135]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.135]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.135]             base::names(...future.oldOptions))
[09:31:33.135]     }
[09:31:33.135]     if (FALSE) {
[09:31:33.135]     }
[09:31:33.135]     else {
[09:31:33.135]         if (TRUE) {
[09:31:33.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.135]                 open = "w")
[09:31:33.135]         }
[09:31:33.135]         else {
[09:31:33.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.135]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.135]         }
[09:31:33.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.135]             base::sink(type = "output", split = FALSE)
[09:31:33.135]             base::close(...future.stdout)
[09:31:33.135]         }, add = TRUE)
[09:31:33.135]     }
[09:31:33.135]     ...future.frame <- base::sys.nframe()
[09:31:33.135]     ...future.conditions <- base::list()
[09:31:33.135]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.135]     if (FALSE) {
[09:31:33.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.135]     }
[09:31:33.135]     ...future.result <- base::tryCatch({
[09:31:33.135]         base::withCallingHandlers({
[09:31:33.135]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.135]             future::FutureResult(value = ...future.value$value, 
[09:31:33.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.135]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.135]                     ...future.globalenv.names))
[09:31:33.135]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.135]         }, condition = base::local({
[09:31:33.135]             c <- base::c
[09:31:33.135]             inherits <- base::inherits
[09:31:33.135]             invokeRestart <- base::invokeRestart
[09:31:33.135]             length <- base::length
[09:31:33.135]             list <- base::list
[09:31:33.135]             seq.int <- base::seq.int
[09:31:33.135]             signalCondition <- base::signalCondition
[09:31:33.135]             sys.calls <- base::sys.calls
[09:31:33.135]             `[[` <- base::`[[`
[09:31:33.135]             `+` <- base::`+`
[09:31:33.135]             `<<-` <- base::`<<-`
[09:31:33.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.135]                   3L)]
[09:31:33.135]             }
[09:31:33.135]             function(cond) {
[09:31:33.135]                 is_error <- inherits(cond, "error")
[09:31:33.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.135]                   NULL)
[09:31:33.135]                 if (is_error) {
[09:31:33.135]                   sessionInformation <- function() {
[09:31:33.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.135]                       search = base::search(), system = base::Sys.info())
[09:31:33.135]                   }
[09:31:33.135]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.135]                     cond$call), session = sessionInformation(), 
[09:31:33.135]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.135]                   signalCondition(cond)
[09:31:33.135]                 }
[09:31:33.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.135]                 "immediateCondition"))) {
[09:31:33.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.135]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.135]                   if (TRUE && !signal) {
[09:31:33.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.135]                     {
[09:31:33.135]                       inherits <- base::inherits
[09:31:33.135]                       invokeRestart <- base::invokeRestart
[09:31:33.135]                       is.null <- base::is.null
[09:31:33.135]                       muffled <- FALSE
[09:31:33.135]                       if (inherits(cond, "message")) {
[09:31:33.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.135]                         if (muffled) 
[09:31:33.135]                           invokeRestart("muffleMessage")
[09:31:33.135]                       }
[09:31:33.135]                       else if (inherits(cond, "warning")) {
[09:31:33.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.135]                         if (muffled) 
[09:31:33.135]                           invokeRestart("muffleWarning")
[09:31:33.135]                       }
[09:31:33.135]                       else if (inherits(cond, "condition")) {
[09:31:33.135]                         if (!is.null(pattern)) {
[09:31:33.135]                           computeRestarts <- base::computeRestarts
[09:31:33.135]                           grepl <- base::grepl
[09:31:33.135]                           restarts <- computeRestarts(cond)
[09:31:33.135]                           for (restart in restarts) {
[09:31:33.135]                             name <- restart$name
[09:31:33.135]                             if (is.null(name)) 
[09:31:33.135]                               next
[09:31:33.135]                             if (!grepl(pattern, name)) 
[09:31:33.135]                               next
[09:31:33.135]                             invokeRestart(restart)
[09:31:33.135]                             muffled <- TRUE
[09:31:33.135]                             break
[09:31:33.135]                           }
[09:31:33.135]                         }
[09:31:33.135]                       }
[09:31:33.135]                       invisible(muffled)
[09:31:33.135]                     }
[09:31:33.135]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.135]                   }
[09:31:33.135]                 }
[09:31:33.135]                 else {
[09:31:33.135]                   if (TRUE) {
[09:31:33.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.135]                     {
[09:31:33.135]                       inherits <- base::inherits
[09:31:33.135]                       invokeRestart <- base::invokeRestart
[09:31:33.135]                       is.null <- base::is.null
[09:31:33.135]                       muffled <- FALSE
[09:31:33.135]                       if (inherits(cond, "message")) {
[09:31:33.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.135]                         if (muffled) 
[09:31:33.135]                           invokeRestart("muffleMessage")
[09:31:33.135]                       }
[09:31:33.135]                       else if (inherits(cond, "warning")) {
[09:31:33.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.135]                         if (muffled) 
[09:31:33.135]                           invokeRestart("muffleWarning")
[09:31:33.135]                       }
[09:31:33.135]                       else if (inherits(cond, "condition")) {
[09:31:33.135]                         if (!is.null(pattern)) {
[09:31:33.135]                           computeRestarts <- base::computeRestarts
[09:31:33.135]                           grepl <- base::grepl
[09:31:33.135]                           restarts <- computeRestarts(cond)
[09:31:33.135]                           for (restart in restarts) {
[09:31:33.135]                             name <- restart$name
[09:31:33.135]                             if (is.null(name)) 
[09:31:33.135]                               next
[09:31:33.135]                             if (!grepl(pattern, name)) 
[09:31:33.135]                               next
[09:31:33.135]                             invokeRestart(restart)
[09:31:33.135]                             muffled <- TRUE
[09:31:33.135]                             break
[09:31:33.135]                           }
[09:31:33.135]                         }
[09:31:33.135]                       }
[09:31:33.135]                       invisible(muffled)
[09:31:33.135]                     }
[09:31:33.135]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.135]                   }
[09:31:33.135]                 }
[09:31:33.135]             }
[09:31:33.135]         }))
[09:31:33.135]     }, error = function(ex) {
[09:31:33.135]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.135]                 ...future.rng), started = ...future.startTime, 
[09:31:33.135]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.135]             version = "1.8"), class = "FutureResult")
[09:31:33.135]     }, finally = {
[09:31:33.135]         if (!identical(...future.workdir, getwd())) 
[09:31:33.135]             setwd(...future.workdir)
[09:31:33.135]         {
[09:31:33.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.135]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.135]             }
[09:31:33.135]             base::options(...future.oldOptions)
[09:31:33.135]             if (.Platform$OS.type == "windows") {
[09:31:33.135]                 old_names <- names(...future.oldEnvVars)
[09:31:33.135]                 envs <- base::Sys.getenv()
[09:31:33.135]                 names <- names(envs)
[09:31:33.135]                 common <- intersect(names, old_names)
[09:31:33.135]                 added <- setdiff(names, old_names)
[09:31:33.135]                 removed <- setdiff(old_names, names)
[09:31:33.135]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.135]                   envs[common]]
[09:31:33.135]                 NAMES <- toupper(changed)
[09:31:33.135]                 args <- list()
[09:31:33.135]                 for (kk in seq_along(NAMES)) {
[09:31:33.135]                   name <- changed[[kk]]
[09:31:33.135]                   NAME <- NAMES[[kk]]
[09:31:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.135]                     next
[09:31:33.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.135]                 }
[09:31:33.135]                 NAMES <- toupper(added)
[09:31:33.135]                 for (kk in seq_along(NAMES)) {
[09:31:33.135]                   name <- added[[kk]]
[09:31:33.135]                   NAME <- NAMES[[kk]]
[09:31:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.135]                     next
[09:31:33.135]                   args[[name]] <- ""
[09:31:33.135]                 }
[09:31:33.135]                 NAMES <- toupper(removed)
[09:31:33.135]                 for (kk in seq_along(NAMES)) {
[09:31:33.135]                   name <- removed[[kk]]
[09:31:33.135]                   NAME <- NAMES[[kk]]
[09:31:33.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.135]                     next
[09:31:33.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.135]                 }
[09:31:33.135]                 if (length(args) > 0) 
[09:31:33.135]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.135]             }
[09:31:33.135]             else {
[09:31:33.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.135]             }
[09:31:33.135]             {
[09:31:33.135]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.135]                   0L) {
[09:31:33.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.135]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.135]                   base::options(opts)
[09:31:33.135]                 }
[09:31:33.135]                 {
[09:31:33.135]                   {
[09:31:33.135]                     NULL
[09:31:33.135]                     RNGkind("Mersenne-Twister")
[09:31:33.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.135]                       inherits = FALSE)
[09:31:33.135]                   }
[09:31:33.135]                   options(future.plan = NULL)
[09:31:33.135]                   if (is.na(NA_character_)) 
[09:31:33.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.135]                     .init = FALSE)
[09:31:33.135]                 }
[09:31:33.135]             }
[09:31:33.135]         }
[09:31:33.135]     })
[09:31:33.135]     if (TRUE) {
[09:31:33.135]         base::sink(type = "output", split = FALSE)
[09:31:33.135]         if (TRUE) {
[09:31:33.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.135]         }
[09:31:33.135]         else {
[09:31:33.135]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.135]         }
[09:31:33.135]         base::close(...future.stdout)
[09:31:33.135]         ...future.stdout <- NULL
[09:31:33.135]     }
[09:31:33.135]     ...future.result$conditions <- ...future.conditions
[09:31:33.135]     ...future.result$finished <- base::Sys.time()
[09:31:33.135]     ...future.result
[09:31:33.135] }
[09:31:33.137] plan(): Setting new future strategy stack:
[09:31:33.137] List of future strategies:
[09:31:33.137] 1. sequential:
[09:31:33.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.137]    - tweaked: FALSE
[09:31:33.137]    - call: NULL
[09:31:33.138] plan(): nbrOfWorkers() = 1
[09:31:33.138] plan(): Setting new future strategy stack:
[09:31:33.138] List of future strategies:
[09:31:33.138] 1. sequential:
[09:31:33.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.138]    - tweaked: FALSE
[09:31:33.138]    - call: plan(strategy)
[09:31:33.139] plan(): nbrOfWorkers() = 1
[09:31:33.139] SequentialFuture started (and completed)
[09:31:33.139] - Launch lazy future ... done
[09:31:33.139] run() for ‘SequentialFuture’ ... done
[09:31:33.139] resolved() for ‘SequentialFuture’ ...
[09:31:33.139] - state: ‘finished’
[09:31:33.139] - run: TRUE
[09:31:33.139] - result: ‘FutureResult’
[09:31:33.139] resolved() for ‘SequentialFuture’ ... done
[09:31:33.140] Future #1
[09:31:33.140] resolved() for ‘SequentialFuture’ ...
[09:31:33.140] - state: ‘finished’
[09:31:33.140] - run: TRUE
[09:31:33.140] - result: ‘FutureResult’
[09:31:33.140] resolved() for ‘SequentialFuture’ ... done
[09:31:33.140] A SequentialFuture was resolved
[09:31:33.140]  length: 0 (resolved future 1)
[09:31:33.140] resolve() on list ... DONE
[09:31:33.140] - globals: [1] ‘a’
[09:31:33.141] Resolving futures part of globals (recursively) ... DONE
[09:31:33.141] The total size of the 1 globals is 10.34 KiB (10592 bytes)
[09:31:33.141] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.34 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.34 KiB of class ‘environment’)
[09:31:33.142] - globals: [1] ‘a’
[09:31:33.142] - packages: [1] ‘future’
[09:31:33.142] getGlobalsAndPackages() ... DONE
[09:31:33.142] run() for ‘Future’ ...
[09:31:33.142] - state: ‘created’
[09:31:33.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.143]   - Field: ‘label’
[09:31:33.143]   - Field: ‘local’
[09:31:33.143]   - Field: ‘owner’
[09:31:33.143]   - Field: ‘envir’
[09:31:33.143]   - Field: ‘packages’
[09:31:33.143]   - Field: ‘gc’
[09:31:33.143]   - Field: ‘conditions’
[09:31:33.143]   - Field: ‘expr’
[09:31:33.143]   - Field: ‘uuid’
[09:31:33.143]   - Field: ‘seed’
[09:31:33.144]   - Field: ‘version’
[09:31:33.144]   - Field: ‘result’
[09:31:33.144]   - Field: ‘asynchronous’
[09:31:33.144]   - Field: ‘calls’
[09:31:33.144]   - Field: ‘globals’
[09:31:33.144]   - Field: ‘stdout’
[09:31:33.144]   - Field: ‘earlySignal’
[09:31:33.144]   - Field: ‘lazy’
[09:31:33.144]   - Field: ‘state’
[09:31:33.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.144] - Launch lazy future ...
[09:31:33.145] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.145] Packages needed by future strategies (n = 0): <none>
[09:31:33.146] {
[09:31:33.146]     {
[09:31:33.146]         {
[09:31:33.146]             ...future.startTime <- base::Sys.time()
[09:31:33.146]             {
[09:31:33.146]                 {
[09:31:33.146]                   {
[09:31:33.146]                     {
[09:31:33.146]                       base::local({
[09:31:33.146]                         has_future <- base::requireNamespace("future", 
[09:31:33.146]                           quietly = TRUE)
[09:31:33.146]                         if (has_future) {
[09:31:33.146]                           ns <- base::getNamespace("future")
[09:31:33.146]                           version <- ns[[".package"]][["version"]]
[09:31:33.146]                           if (is.null(version)) 
[09:31:33.146]                             version <- utils::packageVersion("future")
[09:31:33.146]                         }
[09:31:33.146]                         else {
[09:31:33.146]                           version <- NULL
[09:31:33.146]                         }
[09:31:33.146]                         if (!has_future || version < "1.8.0") {
[09:31:33.146]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.146]                             "", base::R.version$version.string), 
[09:31:33.146]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.146]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.146]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.146]                               "release", "version")], collapse = " "), 
[09:31:33.146]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.146]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.146]                             info)
[09:31:33.146]                           info <- base::paste(info, collapse = "; ")
[09:31:33.146]                           if (!has_future) {
[09:31:33.146]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.146]                               info)
[09:31:33.146]                           }
[09:31:33.146]                           else {
[09:31:33.146]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.146]                               info, version)
[09:31:33.146]                           }
[09:31:33.146]                           base::stop(msg)
[09:31:33.146]                         }
[09:31:33.146]                       })
[09:31:33.146]                     }
[09:31:33.146]                     base::local({
[09:31:33.146]                       for (pkg in "future") {
[09:31:33.146]                         base::loadNamespace(pkg)
[09:31:33.146]                         base::library(pkg, character.only = TRUE)
[09:31:33.146]                       }
[09:31:33.146]                     })
[09:31:33.146]                   }
[09:31:33.146]                   ...future.strategy.old <- future::plan("list")
[09:31:33.146]                   options(future.plan = NULL)
[09:31:33.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.146]                 }
[09:31:33.146]                 ...future.workdir <- getwd()
[09:31:33.146]             }
[09:31:33.146]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.146]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.146]         }
[09:31:33.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.146]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.146]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.146]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.146]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.146]             base::names(...future.oldOptions))
[09:31:33.146]     }
[09:31:33.146]     if (FALSE) {
[09:31:33.146]     }
[09:31:33.146]     else {
[09:31:33.146]         if (TRUE) {
[09:31:33.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.146]                 open = "w")
[09:31:33.146]         }
[09:31:33.146]         else {
[09:31:33.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.146]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.146]         }
[09:31:33.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.146]             base::sink(type = "output", split = FALSE)
[09:31:33.146]             base::close(...future.stdout)
[09:31:33.146]         }, add = TRUE)
[09:31:33.146]     }
[09:31:33.146]     ...future.frame <- base::sys.nframe()
[09:31:33.146]     ...future.conditions <- base::list()
[09:31:33.146]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.146]     if (FALSE) {
[09:31:33.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.146]     }
[09:31:33.146]     ...future.result <- base::tryCatch({
[09:31:33.146]         base::withCallingHandlers({
[09:31:33.146]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.146]                 1))
[09:31:33.146]             future::FutureResult(value = ...future.value$value, 
[09:31:33.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.146]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.146]                     ...future.globalenv.names))
[09:31:33.146]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.146]         }, condition = base::local({
[09:31:33.146]             c <- base::c
[09:31:33.146]             inherits <- base::inherits
[09:31:33.146]             invokeRestart <- base::invokeRestart
[09:31:33.146]             length <- base::length
[09:31:33.146]             list <- base::list
[09:31:33.146]             seq.int <- base::seq.int
[09:31:33.146]             signalCondition <- base::signalCondition
[09:31:33.146]             sys.calls <- base::sys.calls
[09:31:33.146]             `[[` <- base::`[[`
[09:31:33.146]             `+` <- base::`+`
[09:31:33.146]             `<<-` <- base::`<<-`
[09:31:33.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.146]                   3L)]
[09:31:33.146]             }
[09:31:33.146]             function(cond) {
[09:31:33.146]                 is_error <- inherits(cond, "error")
[09:31:33.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.146]                   NULL)
[09:31:33.146]                 if (is_error) {
[09:31:33.146]                   sessionInformation <- function() {
[09:31:33.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.146]                       search = base::search(), system = base::Sys.info())
[09:31:33.146]                   }
[09:31:33.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.146]                     cond$call), session = sessionInformation(), 
[09:31:33.146]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.146]                   signalCondition(cond)
[09:31:33.146]                 }
[09:31:33.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.146]                 "immediateCondition"))) {
[09:31:33.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.146]                   if (TRUE && !signal) {
[09:31:33.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.146]                     {
[09:31:33.146]                       inherits <- base::inherits
[09:31:33.146]                       invokeRestart <- base::invokeRestart
[09:31:33.146]                       is.null <- base::is.null
[09:31:33.146]                       muffled <- FALSE
[09:31:33.146]                       if (inherits(cond, "message")) {
[09:31:33.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.146]                         if (muffled) 
[09:31:33.146]                           invokeRestart("muffleMessage")
[09:31:33.146]                       }
[09:31:33.146]                       else if (inherits(cond, "warning")) {
[09:31:33.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.146]                         if (muffled) 
[09:31:33.146]                           invokeRestart("muffleWarning")
[09:31:33.146]                       }
[09:31:33.146]                       else if (inherits(cond, "condition")) {
[09:31:33.146]                         if (!is.null(pattern)) {
[09:31:33.146]                           computeRestarts <- base::computeRestarts
[09:31:33.146]                           grepl <- base::grepl
[09:31:33.146]                           restarts <- computeRestarts(cond)
[09:31:33.146]                           for (restart in restarts) {
[09:31:33.146]                             name <- restart$name
[09:31:33.146]                             if (is.null(name)) 
[09:31:33.146]                               next
[09:31:33.146]                             if (!grepl(pattern, name)) 
[09:31:33.146]                               next
[09:31:33.146]                             invokeRestart(restart)
[09:31:33.146]                             muffled <- TRUE
[09:31:33.146]                             break
[09:31:33.146]                           }
[09:31:33.146]                         }
[09:31:33.146]                       }
[09:31:33.146]                       invisible(muffled)
[09:31:33.146]                     }
[09:31:33.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.146]                   }
[09:31:33.146]                 }
[09:31:33.146]                 else {
[09:31:33.146]                   if (TRUE) {
[09:31:33.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.146]                     {
[09:31:33.146]                       inherits <- base::inherits
[09:31:33.146]                       invokeRestart <- base::invokeRestart
[09:31:33.146]                       is.null <- base::is.null
[09:31:33.146]                       muffled <- FALSE
[09:31:33.146]                       if (inherits(cond, "message")) {
[09:31:33.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.146]                         if (muffled) 
[09:31:33.146]                           invokeRestart("muffleMessage")
[09:31:33.146]                       }
[09:31:33.146]                       else if (inherits(cond, "warning")) {
[09:31:33.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.146]                         if (muffled) 
[09:31:33.146]                           invokeRestart("muffleWarning")
[09:31:33.146]                       }
[09:31:33.146]                       else if (inherits(cond, "condition")) {
[09:31:33.146]                         if (!is.null(pattern)) {
[09:31:33.146]                           computeRestarts <- base::computeRestarts
[09:31:33.146]                           grepl <- base::grepl
[09:31:33.146]                           restarts <- computeRestarts(cond)
[09:31:33.146]                           for (restart in restarts) {
[09:31:33.146]                             name <- restart$name
[09:31:33.146]                             if (is.null(name)) 
[09:31:33.146]                               next
[09:31:33.146]                             if (!grepl(pattern, name)) 
[09:31:33.146]                               next
[09:31:33.146]                             invokeRestart(restart)
[09:31:33.146]                             muffled <- TRUE
[09:31:33.146]                             break
[09:31:33.146]                           }
[09:31:33.146]                         }
[09:31:33.146]                       }
[09:31:33.146]                       invisible(muffled)
[09:31:33.146]                     }
[09:31:33.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.146]                   }
[09:31:33.146]                 }
[09:31:33.146]             }
[09:31:33.146]         }))
[09:31:33.146]     }, error = function(ex) {
[09:31:33.146]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.146]                 ...future.rng), started = ...future.startTime, 
[09:31:33.146]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.146]             version = "1.8"), class = "FutureResult")
[09:31:33.146]     }, finally = {
[09:31:33.146]         if (!identical(...future.workdir, getwd())) 
[09:31:33.146]             setwd(...future.workdir)
[09:31:33.146]         {
[09:31:33.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.146]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.146]             }
[09:31:33.146]             base::options(...future.oldOptions)
[09:31:33.146]             if (.Platform$OS.type == "windows") {
[09:31:33.146]                 old_names <- names(...future.oldEnvVars)
[09:31:33.146]                 envs <- base::Sys.getenv()
[09:31:33.146]                 names <- names(envs)
[09:31:33.146]                 common <- intersect(names, old_names)
[09:31:33.146]                 added <- setdiff(names, old_names)
[09:31:33.146]                 removed <- setdiff(old_names, names)
[09:31:33.146]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.146]                   envs[common]]
[09:31:33.146]                 NAMES <- toupper(changed)
[09:31:33.146]                 args <- list()
[09:31:33.146]                 for (kk in seq_along(NAMES)) {
[09:31:33.146]                   name <- changed[[kk]]
[09:31:33.146]                   NAME <- NAMES[[kk]]
[09:31:33.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.146]                     next
[09:31:33.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.146]                 }
[09:31:33.146]                 NAMES <- toupper(added)
[09:31:33.146]                 for (kk in seq_along(NAMES)) {
[09:31:33.146]                   name <- added[[kk]]
[09:31:33.146]                   NAME <- NAMES[[kk]]
[09:31:33.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.146]                     next
[09:31:33.146]                   args[[name]] <- ""
[09:31:33.146]                 }
[09:31:33.146]                 NAMES <- toupper(removed)
[09:31:33.146]                 for (kk in seq_along(NAMES)) {
[09:31:33.146]                   name <- removed[[kk]]
[09:31:33.146]                   NAME <- NAMES[[kk]]
[09:31:33.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.146]                     next
[09:31:33.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.146]                 }
[09:31:33.146]                 if (length(args) > 0) 
[09:31:33.146]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.146]             }
[09:31:33.146]             else {
[09:31:33.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.146]             }
[09:31:33.146]             {
[09:31:33.146]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.146]                   0L) {
[09:31:33.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.146]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.146]                   base::options(opts)
[09:31:33.146]                 }
[09:31:33.146]                 {
[09:31:33.146]                   {
[09:31:33.146]                     NULL
[09:31:33.146]                     RNGkind("Mersenne-Twister")
[09:31:33.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.146]                       inherits = FALSE)
[09:31:33.146]                   }
[09:31:33.146]                   options(future.plan = NULL)
[09:31:33.146]                   if (is.na(NA_character_)) 
[09:31:33.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.146]                     .init = FALSE)
[09:31:33.146]                 }
[09:31:33.146]             }
[09:31:33.146]         }
[09:31:33.146]     })
[09:31:33.146]     if (TRUE) {
[09:31:33.146]         base::sink(type = "output", split = FALSE)
[09:31:33.146]         if (TRUE) {
[09:31:33.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.146]         }
[09:31:33.146]         else {
[09:31:33.146]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.146]         }
[09:31:33.146]         base::close(...future.stdout)
[09:31:33.146]         ...future.stdout <- NULL
[09:31:33.146]     }
[09:31:33.146]     ...future.result$conditions <- ...future.conditions
[09:31:33.146]     ...future.result$finished <- base::Sys.time()
[09:31:33.146]     ...future.result
[09:31:33.146] }
[09:31:33.148] assign_globals() ...
[09:31:33.148] List of 1
[09:31:33.148]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e219f91020> 
[09:31:33.148]  - attr(*, "where")=List of 1
[09:31:33.148]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.148]  - attr(*, "resolved")= logi TRUE
[09:31:33.148]  - attr(*, "total_size")= num 10592
[09:31:33.148]  - attr(*, "already-done")= logi TRUE
[09:31:33.150] - copied ‘a’ to environment
[09:31:33.150] assign_globals() ... done
[09:31:33.150] plan(): Setting new future strategy stack:
[09:31:33.150] List of future strategies:
[09:31:33.150] 1. sequential:
[09:31:33.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.150]    - tweaked: FALSE
[09:31:33.150]    - call: NULL
[09:31:33.151] plan(): nbrOfWorkers() = 1
[09:31:33.152] plan(): Setting new future strategy stack:
[09:31:33.152] List of future strategies:
[09:31:33.152] 1. sequential:
[09:31:33.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.152]    - tweaked: FALSE
[09:31:33.152]    - call: plan(strategy)
[09:31:33.152] plan(): nbrOfWorkers() = 1
[09:31:33.152] SequentialFuture started (and completed)
[09:31:33.152] - Launch lazy future ... done
[09:31:33.152] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.153] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.153] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.154] - globals found: [2] ‘{’, ‘pkg’
[09:31:33.154] Searching for globals ... DONE
[09:31:33.154] Resolving globals: TRUE
[09:31:33.154] Resolving any globals that are futures ...
[09:31:33.154] - globals: [2] ‘{’, ‘pkg’
[09:31:33.154] Resolving any globals that are futures ... DONE
[09:31:33.154] Resolving futures part of globals (recursively) ...
[09:31:33.155] resolve() on list ...
[09:31:33.155]  recursive: 99
[09:31:33.155]  length: 1
[09:31:33.155]  elements: ‘pkg’
[09:31:33.155]  length: 0 (resolved future 1)
[09:31:33.155] resolve() on list ... DONE
[09:31:33.155] - globals: [1] ‘pkg’
[09:31:33.155] Resolving futures part of globals (recursively) ... DONE
[09:31:33.155] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:33.156] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:33.156] - globals: [1] ‘pkg’
[09:31:33.156] 
[09:31:33.156] getGlobalsAndPackages() ... DONE
[09:31:33.156] Packages needed by the future expression (n = 0): <none>
[09:31:33.156] Packages needed by future strategies (n = 0): <none>
[09:31:33.157] {
[09:31:33.157]     {
[09:31:33.157]         {
[09:31:33.157]             ...future.startTime <- base::Sys.time()
[09:31:33.157]             {
[09:31:33.157]                 {
[09:31:33.157]                   {
[09:31:33.157]                     base::local({
[09:31:33.157]                       has_future <- base::requireNamespace("future", 
[09:31:33.157]                         quietly = TRUE)
[09:31:33.157]                       if (has_future) {
[09:31:33.157]                         ns <- base::getNamespace("future")
[09:31:33.157]                         version <- ns[[".package"]][["version"]]
[09:31:33.157]                         if (is.null(version)) 
[09:31:33.157]                           version <- utils::packageVersion("future")
[09:31:33.157]                       }
[09:31:33.157]                       else {
[09:31:33.157]                         version <- NULL
[09:31:33.157]                       }
[09:31:33.157]                       if (!has_future || version < "1.8.0") {
[09:31:33.157]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.157]                           "", base::R.version$version.string), 
[09:31:33.157]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.157]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.157]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.157]                             "release", "version")], collapse = " "), 
[09:31:33.157]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.157]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.157]                           info)
[09:31:33.157]                         info <- base::paste(info, collapse = "; ")
[09:31:33.157]                         if (!has_future) {
[09:31:33.157]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.157]                             info)
[09:31:33.157]                         }
[09:31:33.157]                         else {
[09:31:33.157]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.157]                             info, version)
[09:31:33.157]                         }
[09:31:33.157]                         base::stop(msg)
[09:31:33.157]                       }
[09:31:33.157]                     })
[09:31:33.157]                   }
[09:31:33.157]                   ...future.strategy.old <- future::plan("list")
[09:31:33.157]                   options(future.plan = NULL)
[09:31:33.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.157]                 }
[09:31:33.157]                 ...future.workdir <- getwd()
[09:31:33.157]             }
[09:31:33.157]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.157]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.157]         }
[09:31:33.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.157]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.157]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.157]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.157]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.157]             base::names(...future.oldOptions))
[09:31:33.157]     }
[09:31:33.157]     if (FALSE) {
[09:31:33.157]     }
[09:31:33.157]     else {
[09:31:33.157]         if (TRUE) {
[09:31:33.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.157]                 open = "w")
[09:31:33.157]         }
[09:31:33.157]         else {
[09:31:33.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.157]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.157]         }
[09:31:33.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.157]             base::sink(type = "output", split = FALSE)
[09:31:33.157]             base::close(...future.stdout)
[09:31:33.157]         }, add = TRUE)
[09:31:33.157]     }
[09:31:33.157]     ...future.frame <- base::sys.nframe()
[09:31:33.157]     ...future.conditions <- base::list()
[09:31:33.157]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.157]     if (FALSE) {
[09:31:33.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.157]     }
[09:31:33.157]     ...future.result <- base::tryCatch({
[09:31:33.157]         base::withCallingHandlers({
[09:31:33.157]             ...future.value <- base::withVisible(base::local({
[09:31:33.157]                 pkg
[09:31:33.157]             }))
[09:31:33.157]             future::FutureResult(value = ...future.value$value, 
[09:31:33.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.157]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.157]                     ...future.globalenv.names))
[09:31:33.157]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.157]         }, condition = base::local({
[09:31:33.157]             c <- base::c
[09:31:33.157]             inherits <- base::inherits
[09:31:33.157]             invokeRestart <- base::invokeRestart
[09:31:33.157]             length <- base::length
[09:31:33.157]             list <- base::list
[09:31:33.157]             seq.int <- base::seq.int
[09:31:33.157]             signalCondition <- base::signalCondition
[09:31:33.157]             sys.calls <- base::sys.calls
[09:31:33.157]             `[[` <- base::`[[`
[09:31:33.157]             `+` <- base::`+`
[09:31:33.157]             `<<-` <- base::`<<-`
[09:31:33.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.157]                   3L)]
[09:31:33.157]             }
[09:31:33.157]             function(cond) {
[09:31:33.157]                 is_error <- inherits(cond, "error")
[09:31:33.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.157]                   NULL)
[09:31:33.157]                 if (is_error) {
[09:31:33.157]                   sessionInformation <- function() {
[09:31:33.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.157]                       search = base::search(), system = base::Sys.info())
[09:31:33.157]                   }
[09:31:33.157]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.157]                     cond$call), session = sessionInformation(), 
[09:31:33.157]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.157]                   signalCondition(cond)
[09:31:33.157]                 }
[09:31:33.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.157]                 "immediateCondition"))) {
[09:31:33.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.157]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.157]                   if (TRUE && !signal) {
[09:31:33.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.157]                     {
[09:31:33.157]                       inherits <- base::inherits
[09:31:33.157]                       invokeRestart <- base::invokeRestart
[09:31:33.157]                       is.null <- base::is.null
[09:31:33.157]                       muffled <- FALSE
[09:31:33.157]                       if (inherits(cond, "message")) {
[09:31:33.157]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.157]                         if (muffled) 
[09:31:33.157]                           invokeRestart("muffleMessage")
[09:31:33.157]                       }
[09:31:33.157]                       else if (inherits(cond, "warning")) {
[09:31:33.157]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.157]                         if (muffled) 
[09:31:33.157]                           invokeRestart("muffleWarning")
[09:31:33.157]                       }
[09:31:33.157]                       else if (inherits(cond, "condition")) {
[09:31:33.157]                         if (!is.null(pattern)) {
[09:31:33.157]                           computeRestarts <- base::computeRestarts
[09:31:33.157]                           grepl <- base::grepl
[09:31:33.157]                           restarts <- computeRestarts(cond)
[09:31:33.157]                           for (restart in restarts) {
[09:31:33.157]                             name <- restart$name
[09:31:33.157]                             if (is.null(name)) 
[09:31:33.157]                               next
[09:31:33.157]                             if (!grepl(pattern, name)) 
[09:31:33.157]                               next
[09:31:33.157]                             invokeRestart(restart)
[09:31:33.157]                             muffled <- TRUE
[09:31:33.157]                             break
[09:31:33.157]                           }
[09:31:33.157]                         }
[09:31:33.157]                       }
[09:31:33.157]                       invisible(muffled)
[09:31:33.157]                     }
[09:31:33.157]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.157]                   }
[09:31:33.157]                 }
[09:31:33.157]                 else {
[09:31:33.157]                   if (TRUE) {
[09:31:33.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.157]                     {
[09:31:33.157]                       inherits <- base::inherits
[09:31:33.157]                       invokeRestart <- base::invokeRestart
[09:31:33.157]                       is.null <- base::is.null
[09:31:33.157]                       muffled <- FALSE
[09:31:33.157]                       if (inherits(cond, "message")) {
[09:31:33.157]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.157]                         if (muffled) 
[09:31:33.157]                           invokeRestart("muffleMessage")
[09:31:33.157]                       }
[09:31:33.157]                       else if (inherits(cond, "warning")) {
[09:31:33.157]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.157]                         if (muffled) 
[09:31:33.157]                           invokeRestart("muffleWarning")
[09:31:33.157]                       }
[09:31:33.157]                       else if (inherits(cond, "condition")) {
[09:31:33.157]                         if (!is.null(pattern)) {
[09:31:33.157]                           computeRestarts <- base::computeRestarts
[09:31:33.157]                           grepl <- base::grepl
[09:31:33.157]                           restarts <- computeRestarts(cond)
[09:31:33.157]                           for (restart in restarts) {
[09:31:33.157]                             name <- restart$name
[09:31:33.157]                             if (is.null(name)) 
[09:31:33.157]                               next
[09:31:33.157]                             if (!grepl(pattern, name)) 
[09:31:33.157]                               next
[09:31:33.157]                             invokeRestart(restart)
[09:31:33.157]                             muffled <- TRUE
[09:31:33.157]                             break
[09:31:33.157]                           }
[09:31:33.157]                         }
[09:31:33.157]                       }
[09:31:33.157]                       invisible(muffled)
[09:31:33.157]                     }
[09:31:33.157]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.157]                   }
[09:31:33.157]                 }
[09:31:33.157]             }
[09:31:33.157]         }))
[09:31:33.157]     }, error = function(ex) {
[09:31:33.157]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.157]                 ...future.rng), started = ...future.startTime, 
[09:31:33.157]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.157]             version = "1.8"), class = "FutureResult")
[09:31:33.157]     }, finally = {
[09:31:33.157]         if (!identical(...future.workdir, getwd())) 
[09:31:33.157]             setwd(...future.workdir)
[09:31:33.157]         {
[09:31:33.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.157]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.157]             }
[09:31:33.157]             base::options(...future.oldOptions)
[09:31:33.157]             if (.Platform$OS.type == "windows") {
[09:31:33.157]                 old_names <- names(...future.oldEnvVars)
[09:31:33.157]                 envs <- base::Sys.getenv()
[09:31:33.157]                 names <- names(envs)
[09:31:33.157]                 common <- intersect(names, old_names)
[09:31:33.157]                 added <- setdiff(names, old_names)
[09:31:33.157]                 removed <- setdiff(old_names, names)
[09:31:33.157]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.157]                   envs[common]]
[09:31:33.157]                 NAMES <- toupper(changed)
[09:31:33.157]                 args <- list()
[09:31:33.157]                 for (kk in seq_along(NAMES)) {
[09:31:33.157]                   name <- changed[[kk]]
[09:31:33.157]                   NAME <- NAMES[[kk]]
[09:31:33.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.157]                     next
[09:31:33.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.157]                 }
[09:31:33.157]                 NAMES <- toupper(added)
[09:31:33.157]                 for (kk in seq_along(NAMES)) {
[09:31:33.157]                   name <- added[[kk]]
[09:31:33.157]                   NAME <- NAMES[[kk]]
[09:31:33.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.157]                     next
[09:31:33.157]                   args[[name]] <- ""
[09:31:33.157]                 }
[09:31:33.157]                 NAMES <- toupper(removed)
[09:31:33.157]                 for (kk in seq_along(NAMES)) {
[09:31:33.157]                   name <- removed[[kk]]
[09:31:33.157]                   NAME <- NAMES[[kk]]
[09:31:33.157]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.157]                     next
[09:31:33.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.157]                 }
[09:31:33.157]                 if (length(args) > 0) 
[09:31:33.157]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.157]             }
[09:31:33.157]             else {
[09:31:33.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.157]             }
[09:31:33.157]             {
[09:31:33.157]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.157]                   0L) {
[09:31:33.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.157]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.157]                   base::options(opts)
[09:31:33.157]                 }
[09:31:33.157]                 {
[09:31:33.157]                   {
[09:31:33.157]                     NULL
[09:31:33.157]                     RNGkind("Mersenne-Twister")
[09:31:33.157]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.157]                       inherits = FALSE)
[09:31:33.157]                   }
[09:31:33.157]                   options(future.plan = NULL)
[09:31:33.157]                   if (is.na(NA_character_)) 
[09:31:33.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.157]                     .init = FALSE)
[09:31:33.157]                 }
[09:31:33.157]             }
[09:31:33.157]         }
[09:31:33.157]     })
[09:31:33.157]     if (TRUE) {
[09:31:33.157]         base::sink(type = "output", split = FALSE)
[09:31:33.157]         if (TRUE) {
[09:31:33.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.157]         }
[09:31:33.157]         else {
[09:31:33.157]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.157]         }
[09:31:33.157]         base::close(...future.stdout)
[09:31:33.157]         ...future.stdout <- NULL
[09:31:33.157]     }
[09:31:33.157]     ...future.result$conditions <- ...future.conditions
[09:31:33.157]     ...future.result$finished <- base::Sys.time()
[09:31:33.157]     ...future.result
[09:31:33.157] }
[09:31:33.158] assign_globals() ...
[09:31:33.158] List of 1
[09:31:33.158]  $ pkg: chr "foo"
[09:31:33.158]  - attr(*, "where")=List of 1
[09:31:33.158]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:33.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.158]  - attr(*, "resolved")= logi TRUE
[09:31:33.158]  - attr(*, "total_size")= num 112
[09:31:33.160] - copied ‘pkg’ to environment
[09:31:33.160] assign_globals() ... done
[09:31:33.161] plan(): Setting new future strategy stack:
[09:31:33.161] List of future strategies:
[09:31:33.161] 1. sequential:
[09:31:33.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.161]    - tweaked: FALSE
[09:31:33.161]    - call: NULL
[09:31:33.161] plan(): nbrOfWorkers() = 1
[09:31:33.162] plan(): Setting new future strategy stack:
[09:31:33.162] List of future strategies:
[09:31:33.162] 1. sequential:
[09:31:33.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.162]    - tweaked: FALSE
[09:31:33.162]    - call: plan(strategy)
[09:31:33.162] plan(): nbrOfWorkers() = 1
[09:31:33.162] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.163] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.163] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.165] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:33.166] Searching for globals ... DONE
[09:31:33.166] Resolving globals: TRUE
[09:31:33.166] Resolving any globals that are futures ...
[09:31:33.166] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:33.166] Resolving any globals that are futures ... DONE
[09:31:33.166] Resolving futures part of globals (recursively) ...
[09:31:33.167] resolve() on list ...
[09:31:33.167]  recursive: 99
[09:31:33.167]  length: 1
[09:31:33.167]  elements: ‘a’
[09:31:33.167]  length: 0 (resolved future 1)
[09:31:33.167] resolve() on list ... DONE
[09:31:33.167] - globals: [1] ‘a’
[09:31:33.167] Resolving futures part of globals (recursively) ... DONE
[09:31:33.167] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.168] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:33.168] - globals: [1] ‘a’
[09:31:33.168] 
[09:31:33.168] getGlobalsAndPackages() ... DONE
[09:31:33.168] run() for ‘Future’ ...
[09:31:33.168] - state: ‘created’
[09:31:33.168] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.169]   - Field: ‘label’
[09:31:33.169]   - Field: ‘local’
[09:31:33.169]   - Field: ‘owner’
[09:31:33.169]   - Field: ‘envir’
[09:31:33.169]   - Field: ‘packages’
[09:31:33.169]   - Field: ‘gc’
[09:31:33.169]   - Field: ‘conditions’
[09:31:33.169]   - Field: ‘expr’
[09:31:33.169]   - Field: ‘uuid’
[09:31:33.170]   - Field: ‘seed’
[09:31:33.170]   - Field: ‘version’
[09:31:33.170]   - Field: ‘result’
[09:31:33.170]   - Field: ‘asynchronous’
[09:31:33.170]   - Field: ‘calls’
[09:31:33.170]   - Field: ‘globals’
[09:31:33.170]   - Field: ‘stdout’
[09:31:33.170]   - Field: ‘earlySignal’
[09:31:33.170]   - Field: ‘lazy’
[09:31:33.170]   - Field: ‘state’
[09:31:33.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.170] - Launch lazy future ...
[09:31:33.171] Packages needed by the future expression (n = 0): <none>
[09:31:33.171] Packages needed by future strategies (n = 0): <none>
[09:31:33.171] {
[09:31:33.171]     {
[09:31:33.171]         {
[09:31:33.171]             ...future.startTime <- base::Sys.time()
[09:31:33.171]             {
[09:31:33.171]                 {
[09:31:33.171]                   {
[09:31:33.171]                     base::local({
[09:31:33.171]                       has_future <- base::requireNamespace("future", 
[09:31:33.171]                         quietly = TRUE)
[09:31:33.171]                       if (has_future) {
[09:31:33.171]                         ns <- base::getNamespace("future")
[09:31:33.171]                         version <- ns[[".package"]][["version"]]
[09:31:33.171]                         if (is.null(version)) 
[09:31:33.171]                           version <- utils::packageVersion("future")
[09:31:33.171]                       }
[09:31:33.171]                       else {
[09:31:33.171]                         version <- NULL
[09:31:33.171]                       }
[09:31:33.171]                       if (!has_future || version < "1.8.0") {
[09:31:33.171]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.171]                           "", base::R.version$version.string), 
[09:31:33.171]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.171]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.171]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.171]                             "release", "version")], collapse = " "), 
[09:31:33.171]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.171]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.171]                           info)
[09:31:33.171]                         info <- base::paste(info, collapse = "; ")
[09:31:33.171]                         if (!has_future) {
[09:31:33.171]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.171]                             info)
[09:31:33.171]                         }
[09:31:33.171]                         else {
[09:31:33.171]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.171]                             info, version)
[09:31:33.171]                         }
[09:31:33.171]                         base::stop(msg)
[09:31:33.171]                       }
[09:31:33.171]                     })
[09:31:33.171]                   }
[09:31:33.171]                   ...future.strategy.old <- future::plan("list")
[09:31:33.171]                   options(future.plan = NULL)
[09:31:33.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.171]                 }
[09:31:33.171]                 ...future.workdir <- getwd()
[09:31:33.171]             }
[09:31:33.171]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.171]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.171]         }
[09:31:33.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.171]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.171]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.171]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.171]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.171]             base::names(...future.oldOptions))
[09:31:33.171]     }
[09:31:33.171]     if (FALSE) {
[09:31:33.171]     }
[09:31:33.171]     else {
[09:31:33.171]         if (TRUE) {
[09:31:33.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.171]                 open = "w")
[09:31:33.171]         }
[09:31:33.171]         else {
[09:31:33.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.171]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.171]         }
[09:31:33.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.171]             base::sink(type = "output", split = FALSE)
[09:31:33.171]             base::close(...future.stdout)
[09:31:33.171]         }, add = TRUE)
[09:31:33.171]     }
[09:31:33.171]     ...future.frame <- base::sys.nframe()
[09:31:33.171]     ...future.conditions <- base::list()
[09:31:33.171]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.171]     if (FALSE) {
[09:31:33.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.171]     }
[09:31:33.171]     ...future.result <- base::tryCatch({
[09:31:33.171]         base::withCallingHandlers({
[09:31:33.171]             ...future.value <- base::withVisible(base::local({
[09:31:33.171]                 b <- a
[09:31:33.171]                 a <- 2
[09:31:33.171]                 a * b
[09:31:33.171]             }))
[09:31:33.171]             future::FutureResult(value = ...future.value$value, 
[09:31:33.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.171]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.171]                     ...future.globalenv.names))
[09:31:33.171]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.171]         }, condition = base::local({
[09:31:33.171]             c <- base::c
[09:31:33.171]             inherits <- base::inherits
[09:31:33.171]             invokeRestart <- base::invokeRestart
[09:31:33.171]             length <- base::length
[09:31:33.171]             list <- base::list
[09:31:33.171]             seq.int <- base::seq.int
[09:31:33.171]             signalCondition <- base::signalCondition
[09:31:33.171]             sys.calls <- base::sys.calls
[09:31:33.171]             `[[` <- base::`[[`
[09:31:33.171]             `+` <- base::`+`
[09:31:33.171]             `<<-` <- base::`<<-`
[09:31:33.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.171]                   3L)]
[09:31:33.171]             }
[09:31:33.171]             function(cond) {
[09:31:33.171]                 is_error <- inherits(cond, "error")
[09:31:33.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.171]                   NULL)
[09:31:33.171]                 if (is_error) {
[09:31:33.171]                   sessionInformation <- function() {
[09:31:33.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.171]                       search = base::search(), system = base::Sys.info())
[09:31:33.171]                   }
[09:31:33.171]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.171]                     cond$call), session = sessionInformation(), 
[09:31:33.171]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.171]                   signalCondition(cond)
[09:31:33.171]                 }
[09:31:33.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.171]                 "immediateCondition"))) {
[09:31:33.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.171]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.171]                   if (TRUE && !signal) {
[09:31:33.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.171]                     {
[09:31:33.171]                       inherits <- base::inherits
[09:31:33.171]                       invokeRestart <- base::invokeRestart
[09:31:33.171]                       is.null <- base::is.null
[09:31:33.171]                       muffled <- FALSE
[09:31:33.171]                       if (inherits(cond, "message")) {
[09:31:33.171]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.171]                         if (muffled) 
[09:31:33.171]                           invokeRestart("muffleMessage")
[09:31:33.171]                       }
[09:31:33.171]                       else if (inherits(cond, "warning")) {
[09:31:33.171]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.171]                         if (muffled) 
[09:31:33.171]                           invokeRestart("muffleWarning")
[09:31:33.171]                       }
[09:31:33.171]                       else if (inherits(cond, "condition")) {
[09:31:33.171]                         if (!is.null(pattern)) {
[09:31:33.171]                           computeRestarts <- base::computeRestarts
[09:31:33.171]                           grepl <- base::grepl
[09:31:33.171]                           restarts <- computeRestarts(cond)
[09:31:33.171]                           for (restart in restarts) {
[09:31:33.171]                             name <- restart$name
[09:31:33.171]                             if (is.null(name)) 
[09:31:33.171]                               next
[09:31:33.171]                             if (!grepl(pattern, name)) 
[09:31:33.171]                               next
[09:31:33.171]                             invokeRestart(restart)
[09:31:33.171]                             muffled <- TRUE
[09:31:33.171]                             break
[09:31:33.171]                           }
[09:31:33.171]                         }
[09:31:33.171]                       }
[09:31:33.171]                       invisible(muffled)
[09:31:33.171]                     }
[09:31:33.171]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.171]                   }
[09:31:33.171]                 }
[09:31:33.171]                 else {
[09:31:33.171]                   if (TRUE) {
[09:31:33.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.171]                     {
[09:31:33.171]                       inherits <- base::inherits
[09:31:33.171]                       invokeRestart <- base::invokeRestart
[09:31:33.171]                       is.null <- base::is.null
[09:31:33.171]                       muffled <- FALSE
[09:31:33.171]                       if (inherits(cond, "message")) {
[09:31:33.171]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.171]                         if (muffled) 
[09:31:33.171]                           invokeRestart("muffleMessage")
[09:31:33.171]                       }
[09:31:33.171]                       else if (inherits(cond, "warning")) {
[09:31:33.171]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.171]                         if (muffled) 
[09:31:33.171]                           invokeRestart("muffleWarning")
[09:31:33.171]                       }
[09:31:33.171]                       else if (inherits(cond, "condition")) {
[09:31:33.171]                         if (!is.null(pattern)) {
[09:31:33.171]                           computeRestarts <- base::computeRestarts
[09:31:33.171]                           grepl <- base::grepl
[09:31:33.171]                           restarts <- computeRestarts(cond)
[09:31:33.171]                           for (restart in restarts) {
[09:31:33.171]                             name <- restart$name
[09:31:33.171]                             if (is.null(name)) 
[09:31:33.171]                               next
[09:31:33.171]                             if (!grepl(pattern, name)) 
[09:31:33.171]                               next
[09:31:33.171]                             invokeRestart(restart)
[09:31:33.171]                             muffled <- TRUE
[09:31:33.171]                             break
[09:31:33.171]                           }
[09:31:33.171]                         }
[09:31:33.171]                       }
[09:31:33.171]                       invisible(muffled)
[09:31:33.171]                     }
[09:31:33.171]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.171]                   }
[09:31:33.171]                 }
[09:31:33.171]             }
[09:31:33.171]         }))
[09:31:33.171]     }, error = function(ex) {
[09:31:33.171]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.171]                 ...future.rng), started = ...future.startTime, 
[09:31:33.171]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.171]             version = "1.8"), class = "FutureResult")
[09:31:33.171]     }, finally = {
[09:31:33.171]         if (!identical(...future.workdir, getwd())) 
[09:31:33.171]             setwd(...future.workdir)
[09:31:33.171]         {
[09:31:33.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.171]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.171]             }
[09:31:33.171]             base::options(...future.oldOptions)
[09:31:33.171]             if (.Platform$OS.type == "windows") {
[09:31:33.171]                 old_names <- names(...future.oldEnvVars)
[09:31:33.171]                 envs <- base::Sys.getenv()
[09:31:33.171]                 names <- names(envs)
[09:31:33.171]                 common <- intersect(names, old_names)
[09:31:33.171]                 added <- setdiff(names, old_names)
[09:31:33.171]                 removed <- setdiff(old_names, names)
[09:31:33.171]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.171]                   envs[common]]
[09:31:33.171]                 NAMES <- toupper(changed)
[09:31:33.171]                 args <- list()
[09:31:33.171]                 for (kk in seq_along(NAMES)) {
[09:31:33.171]                   name <- changed[[kk]]
[09:31:33.171]                   NAME <- NAMES[[kk]]
[09:31:33.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.171]                     next
[09:31:33.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.171]                 }
[09:31:33.171]                 NAMES <- toupper(added)
[09:31:33.171]                 for (kk in seq_along(NAMES)) {
[09:31:33.171]                   name <- added[[kk]]
[09:31:33.171]                   NAME <- NAMES[[kk]]
[09:31:33.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.171]                     next
[09:31:33.171]                   args[[name]] <- ""
[09:31:33.171]                 }
[09:31:33.171]                 NAMES <- toupper(removed)
[09:31:33.171]                 for (kk in seq_along(NAMES)) {
[09:31:33.171]                   name <- removed[[kk]]
[09:31:33.171]                   NAME <- NAMES[[kk]]
[09:31:33.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.171]                     next
[09:31:33.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.171]                 }
[09:31:33.171]                 if (length(args) > 0) 
[09:31:33.171]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.171]             }
[09:31:33.171]             else {
[09:31:33.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.171]             }
[09:31:33.171]             {
[09:31:33.171]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.171]                   0L) {
[09:31:33.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.171]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.171]                   base::options(opts)
[09:31:33.171]                 }
[09:31:33.171]                 {
[09:31:33.171]                   {
[09:31:33.171]                     NULL
[09:31:33.171]                     RNGkind("Mersenne-Twister")
[09:31:33.171]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.171]                       inherits = FALSE)
[09:31:33.171]                   }
[09:31:33.171]                   options(future.plan = NULL)
[09:31:33.171]                   if (is.na(NA_character_)) 
[09:31:33.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.171]                     .init = FALSE)
[09:31:33.171]                 }
[09:31:33.171]             }
[09:31:33.171]         }
[09:31:33.171]     })
[09:31:33.171]     if (TRUE) {
[09:31:33.171]         base::sink(type = "output", split = FALSE)
[09:31:33.171]         if (TRUE) {
[09:31:33.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.171]         }
[09:31:33.171]         else {
[09:31:33.171]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.171]         }
[09:31:33.171]         base::close(...future.stdout)
[09:31:33.171]         ...future.stdout <- NULL
[09:31:33.171]     }
[09:31:33.171]     ...future.result$conditions <- ...future.conditions
[09:31:33.171]     ...future.result$finished <- base::Sys.time()
[09:31:33.171]     ...future.result
[09:31:33.171] }
[09:31:33.173] assign_globals() ...
[09:31:33.173] List of 1
[09:31:33.173]  $ a: num 3
[09:31:33.173]  - attr(*, "where")=List of 1
[09:31:33.173]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.173]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.173]  - attr(*, "resolved")= logi TRUE
[09:31:33.173]  - attr(*, "total_size")= num 56
[09:31:33.173]  - attr(*, "already-done")= logi TRUE
[09:31:33.176] - copied ‘a’ to environment
[09:31:33.176] assign_globals() ... done
[09:31:33.177] plan(): Setting new future strategy stack:
[09:31:33.177] List of future strategies:
[09:31:33.177] 1. sequential:
[09:31:33.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.177]    - tweaked: FALSE
[09:31:33.177]    - call: NULL
[09:31:33.177] plan(): nbrOfWorkers() = 1
[09:31:33.178] plan(): Setting new future strategy stack:
[09:31:33.178] List of future strategies:
[09:31:33.178] 1. sequential:
[09:31:33.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.178]    - tweaked: FALSE
[09:31:33.178]    - call: plan(strategy)
[09:31:33.178] plan(): nbrOfWorkers() = 1
[09:31:33.179] SequentialFuture started (and completed)
[09:31:33.179] - Launch lazy future ... done
[09:31:33.179] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.179] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.179] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.181] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:33.181] Searching for globals ... DONE
[09:31:33.181] Resolving globals: TRUE
[09:31:33.181] Resolving any globals that are futures ...
[09:31:33.181] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:33.182] Resolving any globals that are futures ... DONE
[09:31:33.182] Resolving futures part of globals (recursively) ...
[09:31:33.182] resolve() on list ...
[09:31:33.182]  recursive: 99
[09:31:33.182]  length: 1
[09:31:33.182]  elements: ‘a’
[09:31:33.182]  length: 0 (resolved future 1)
[09:31:33.182] resolve() on list ... DONE
[09:31:33.183] - globals: [1] ‘a’
[09:31:33.183] Resolving futures part of globals (recursively) ... DONE
[09:31:33.183] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.183] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:33.183] - globals: [1] ‘a’
[09:31:33.183] 
[09:31:33.183] getGlobalsAndPackages() ... DONE
[09:31:33.184] run() for ‘Future’ ...
[09:31:33.184] - state: ‘created’
[09:31:33.184] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.184] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.184] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.184]   - Field: ‘label’
[09:31:33.184]   - Field: ‘local’
[09:31:33.185]   - Field: ‘owner’
[09:31:33.185]   - Field: ‘envir’
[09:31:33.185]   - Field: ‘packages’
[09:31:33.185]   - Field: ‘gc’
[09:31:33.185]   - Field: ‘conditions’
[09:31:33.185]   - Field: ‘expr’
[09:31:33.185]   - Field: ‘uuid’
[09:31:33.185]   - Field: ‘seed’
[09:31:33.185]   - Field: ‘version’
[09:31:33.185]   - Field: ‘result’
[09:31:33.185]   - Field: ‘asynchronous’
[09:31:33.185]   - Field: ‘calls’
[09:31:33.186]   - Field: ‘globals’
[09:31:33.186]   - Field: ‘stdout’
[09:31:33.186]   - Field: ‘earlySignal’
[09:31:33.186]   - Field: ‘lazy’
[09:31:33.186]   - Field: ‘state’
[09:31:33.186] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.186] - Launch lazy future ...
[09:31:33.186] Packages needed by the future expression (n = 0): <none>
[09:31:33.186] Packages needed by future strategies (n = 0): <none>
[09:31:33.187] {
[09:31:33.187]     {
[09:31:33.187]         {
[09:31:33.187]             ...future.startTime <- base::Sys.time()
[09:31:33.187]             {
[09:31:33.187]                 {
[09:31:33.187]                   {
[09:31:33.187]                     base::local({
[09:31:33.187]                       has_future <- base::requireNamespace("future", 
[09:31:33.187]                         quietly = TRUE)
[09:31:33.187]                       if (has_future) {
[09:31:33.187]                         ns <- base::getNamespace("future")
[09:31:33.187]                         version <- ns[[".package"]][["version"]]
[09:31:33.187]                         if (is.null(version)) 
[09:31:33.187]                           version <- utils::packageVersion("future")
[09:31:33.187]                       }
[09:31:33.187]                       else {
[09:31:33.187]                         version <- NULL
[09:31:33.187]                       }
[09:31:33.187]                       if (!has_future || version < "1.8.0") {
[09:31:33.187]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.187]                           "", base::R.version$version.string), 
[09:31:33.187]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.187]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.187]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.187]                             "release", "version")], collapse = " "), 
[09:31:33.187]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.187]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.187]                           info)
[09:31:33.187]                         info <- base::paste(info, collapse = "; ")
[09:31:33.187]                         if (!has_future) {
[09:31:33.187]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.187]                             info)
[09:31:33.187]                         }
[09:31:33.187]                         else {
[09:31:33.187]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.187]                             info, version)
[09:31:33.187]                         }
[09:31:33.187]                         base::stop(msg)
[09:31:33.187]                       }
[09:31:33.187]                     })
[09:31:33.187]                   }
[09:31:33.187]                   ...future.strategy.old <- future::plan("list")
[09:31:33.187]                   options(future.plan = NULL)
[09:31:33.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.187]                 }
[09:31:33.187]                 ...future.workdir <- getwd()
[09:31:33.187]             }
[09:31:33.187]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.187]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.187]         }
[09:31:33.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.187]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.187]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.187]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.187]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.187]             base::names(...future.oldOptions))
[09:31:33.187]     }
[09:31:33.187]     if (FALSE) {
[09:31:33.187]     }
[09:31:33.187]     else {
[09:31:33.187]         if (TRUE) {
[09:31:33.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.187]                 open = "w")
[09:31:33.187]         }
[09:31:33.187]         else {
[09:31:33.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.187]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.187]         }
[09:31:33.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.187]             base::sink(type = "output", split = FALSE)
[09:31:33.187]             base::close(...future.stdout)
[09:31:33.187]         }, add = TRUE)
[09:31:33.187]     }
[09:31:33.187]     ...future.frame <- base::sys.nframe()
[09:31:33.187]     ...future.conditions <- base::list()
[09:31:33.187]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.187]     if (FALSE) {
[09:31:33.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.187]     }
[09:31:33.187]     ...future.result <- base::tryCatch({
[09:31:33.187]         base::withCallingHandlers({
[09:31:33.187]             ...future.value <- base::withVisible(base::local({
[09:31:33.187]                 b <- a
[09:31:33.187]                 a <- 2
[09:31:33.187]                 a * b
[09:31:33.187]             }))
[09:31:33.187]             future::FutureResult(value = ...future.value$value, 
[09:31:33.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.187]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.187]                     ...future.globalenv.names))
[09:31:33.187]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.187]         }, condition = base::local({
[09:31:33.187]             c <- base::c
[09:31:33.187]             inherits <- base::inherits
[09:31:33.187]             invokeRestart <- base::invokeRestart
[09:31:33.187]             length <- base::length
[09:31:33.187]             list <- base::list
[09:31:33.187]             seq.int <- base::seq.int
[09:31:33.187]             signalCondition <- base::signalCondition
[09:31:33.187]             sys.calls <- base::sys.calls
[09:31:33.187]             `[[` <- base::`[[`
[09:31:33.187]             `+` <- base::`+`
[09:31:33.187]             `<<-` <- base::`<<-`
[09:31:33.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.187]                   3L)]
[09:31:33.187]             }
[09:31:33.187]             function(cond) {
[09:31:33.187]                 is_error <- inherits(cond, "error")
[09:31:33.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.187]                   NULL)
[09:31:33.187]                 if (is_error) {
[09:31:33.187]                   sessionInformation <- function() {
[09:31:33.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.187]                       search = base::search(), system = base::Sys.info())
[09:31:33.187]                   }
[09:31:33.187]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.187]                     cond$call), session = sessionInformation(), 
[09:31:33.187]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.187]                   signalCondition(cond)
[09:31:33.187]                 }
[09:31:33.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.187]                 "immediateCondition"))) {
[09:31:33.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.187]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.187]                   if (TRUE && !signal) {
[09:31:33.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.187]                     {
[09:31:33.187]                       inherits <- base::inherits
[09:31:33.187]                       invokeRestart <- base::invokeRestart
[09:31:33.187]                       is.null <- base::is.null
[09:31:33.187]                       muffled <- FALSE
[09:31:33.187]                       if (inherits(cond, "message")) {
[09:31:33.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.187]                         if (muffled) 
[09:31:33.187]                           invokeRestart("muffleMessage")
[09:31:33.187]                       }
[09:31:33.187]                       else if (inherits(cond, "warning")) {
[09:31:33.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.187]                         if (muffled) 
[09:31:33.187]                           invokeRestart("muffleWarning")
[09:31:33.187]                       }
[09:31:33.187]                       else if (inherits(cond, "condition")) {
[09:31:33.187]                         if (!is.null(pattern)) {
[09:31:33.187]                           computeRestarts <- base::computeRestarts
[09:31:33.187]                           grepl <- base::grepl
[09:31:33.187]                           restarts <- computeRestarts(cond)
[09:31:33.187]                           for (restart in restarts) {
[09:31:33.187]                             name <- restart$name
[09:31:33.187]                             if (is.null(name)) 
[09:31:33.187]                               next
[09:31:33.187]                             if (!grepl(pattern, name)) 
[09:31:33.187]                               next
[09:31:33.187]                             invokeRestart(restart)
[09:31:33.187]                             muffled <- TRUE
[09:31:33.187]                             break
[09:31:33.187]                           }
[09:31:33.187]                         }
[09:31:33.187]                       }
[09:31:33.187]                       invisible(muffled)
[09:31:33.187]                     }
[09:31:33.187]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.187]                   }
[09:31:33.187]                 }
[09:31:33.187]                 else {
[09:31:33.187]                   if (TRUE) {
[09:31:33.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.187]                     {
[09:31:33.187]                       inherits <- base::inherits
[09:31:33.187]                       invokeRestart <- base::invokeRestart
[09:31:33.187]                       is.null <- base::is.null
[09:31:33.187]                       muffled <- FALSE
[09:31:33.187]                       if (inherits(cond, "message")) {
[09:31:33.187]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.187]                         if (muffled) 
[09:31:33.187]                           invokeRestart("muffleMessage")
[09:31:33.187]                       }
[09:31:33.187]                       else if (inherits(cond, "warning")) {
[09:31:33.187]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.187]                         if (muffled) 
[09:31:33.187]                           invokeRestart("muffleWarning")
[09:31:33.187]                       }
[09:31:33.187]                       else if (inherits(cond, "condition")) {
[09:31:33.187]                         if (!is.null(pattern)) {
[09:31:33.187]                           computeRestarts <- base::computeRestarts
[09:31:33.187]                           grepl <- base::grepl
[09:31:33.187]                           restarts <- computeRestarts(cond)
[09:31:33.187]                           for (restart in restarts) {
[09:31:33.187]                             name <- restart$name
[09:31:33.187]                             if (is.null(name)) 
[09:31:33.187]                               next
[09:31:33.187]                             if (!grepl(pattern, name)) 
[09:31:33.187]                               next
[09:31:33.187]                             invokeRestart(restart)
[09:31:33.187]                             muffled <- TRUE
[09:31:33.187]                             break
[09:31:33.187]                           }
[09:31:33.187]                         }
[09:31:33.187]                       }
[09:31:33.187]                       invisible(muffled)
[09:31:33.187]                     }
[09:31:33.187]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.187]                   }
[09:31:33.187]                 }
[09:31:33.187]             }
[09:31:33.187]         }))
[09:31:33.187]     }, error = function(ex) {
[09:31:33.187]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.187]                 ...future.rng), started = ...future.startTime, 
[09:31:33.187]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.187]             version = "1.8"), class = "FutureResult")
[09:31:33.187]     }, finally = {
[09:31:33.187]         if (!identical(...future.workdir, getwd())) 
[09:31:33.187]             setwd(...future.workdir)
[09:31:33.187]         {
[09:31:33.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.187]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.187]             }
[09:31:33.187]             base::options(...future.oldOptions)
[09:31:33.187]             if (.Platform$OS.type == "windows") {
[09:31:33.187]                 old_names <- names(...future.oldEnvVars)
[09:31:33.187]                 envs <- base::Sys.getenv()
[09:31:33.187]                 names <- names(envs)
[09:31:33.187]                 common <- intersect(names, old_names)
[09:31:33.187]                 added <- setdiff(names, old_names)
[09:31:33.187]                 removed <- setdiff(old_names, names)
[09:31:33.187]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.187]                   envs[common]]
[09:31:33.187]                 NAMES <- toupper(changed)
[09:31:33.187]                 args <- list()
[09:31:33.187]                 for (kk in seq_along(NAMES)) {
[09:31:33.187]                   name <- changed[[kk]]
[09:31:33.187]                   NAME <- NAMES[[kk]]
[09:31:33.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.187]                     next
[09:31:33.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.187]                 }
[09:31:33.187]                 NAMES <- toupper(added)
[09:31:33.187]                 for (kk in seq_along(NAMES)) {
[09:31:33.187]                   name <- added[[kk]]
[09:31:33.187]                   NAME <- NAMES[[kk]]
[09:31:33.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.187]                     next
[09:31:33.187]                   args[[name]] <- ""
[09:31:33.187]                 }
[09:31:33.187]                 NAMES <- toupper(removed)
[09:31:33.187]                 for (kk in seq_along(NAMES)) {
[09:31:33.187]                   name <- removed[[kk]]
[09:31:33.187]                   NAME <- NAMES[[kk]]
[09:31:33.187]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.187]                     next
[09:31:33.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.187]                 }
[09:31:33.187]                 if (length(args) > 0) 
[09:31:33.187]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.187]             }
[09:31:33.187]             else {
[09:31:33.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.187]             }
[09:31:33.187]             {
[09:31:33.187]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.187]                   0L) {
[09:31:33.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.187]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.187]                   base::options(opts)
[09:31:33.187]                 }
[09:31:33.187]                 {
[09:31:33.187]                   {
[09:31:33.187]                     NULL
[09:31:33.187]                     RNGkind("Mersenne-Twister")
[09:31:33.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.187]                       inherits = FALSE)
[09:31:33.187]                   }
[09:31:33.187]                   options(future.plan = NULL)
[09:31:33.187]                   if (is.na(NA_character_)) 
[09:31:33.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.187]                     .init = FALSE)
[09:31:33.187]                 }
[09:31:33.187]             }
[09:31:33.187]         }
[09:31:33.187]     })
[09:31:33.187]     if (TRUE) {
[09:31:33.187]         base::sink(type = "output", split = FALSE)
[09:31:33.187]         if (TRUE) {
[09:31:33.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.187]         }
[09:31:33.187]         else {
[09:31:33.187]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.187]         }
[09:31:33.187]         base::close(...future.stdout)
[09:31:33.187]         ...future.stdout <- NULL
[09:31:33.187]     }
[09:31:33.187]     ...future.result$conditions <- ...future.conditions
[09:31:33.187]     ...future.result$finished <- base::Sys.time()
[09:31:33.187]     ...future.result
[09:31:33.187] }
[09:31:33.188] assign_globals() ...
[09:31:33.188] List of 1
[09:31:33.188]  $ a: num 3
[09:31:33.188]  - attr(*, "where")=List of 1
[09:31:33.188]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.188]  - attr(*, "resolved")= logi TRUE
[09:31:33.188]  - attr(*, "total_size")= num 56
[09:31:33.188]  - attr(*, "already-done")= logi TRUE
[09:31:33.190] - copied ‘a’ to environment
[09:31:33.191] assign_globals() ... done
[09:31:33.191] plan(): Setting new future strategy stack:
[09:31:33.191] List of future strategies:
[09:31:33.191] 1. sequential:
[09:31:33.191]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.191]    - tweaked: FALSE
[09:31:33.191]    - call: NULL
[09:31:33.191] plan(): nbrOfWorkers() = 1
[09:31:33.192] plan(): Setting new future strategy stack:
[09:31:33.192] List of future strategies:
[09:31:33.192] 1. sequential:
[09:31:33.192]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.192]    - tweaked: FALSE
[09:31:33.192]    - call: plan(strategy)
[09:31:33.192] plan(): nbrOfWorkers() = 1
[09:31:33.193] SequentialFuture started (and completed)
[09:31:33.193] - Launch lazy future ... done
[09:31:33.193] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.193] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.194] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.195] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.195] Searching for globals ... DONE
[09:31:33.195] Resolving globals: TRUE
[09:31:33.196] Resolving any globals that are futures ...
[09:31:33.196] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.196] Resolving any globals that are futures ... DONE
[09:31:33.196] Resolving futures part of globals (recursively) ...
[09:31:33.196] resolve() on list ...
[09:31:33.196]  recursive: 99
[09:31:33.196]  length: 2
[09:31:33.197]  elements: ‘a’, ‘ii’
[09:31:33.197]  length: 1 (resolved future 1)
[09:31:33.197]  length: 0 (resolved future 2)
[09:31:33.197] resolve() on list ... DONE
[09:31:33.197] - globals: [2] ‘a’, ‘ii’
[09:31:33.197] Resolving futures part of globals (recursively) ... DONE
[09:31:33.198] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.198] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.199] - globals: [2] ‘a’, ‘ii’
[09:31:33.199] 
[09:31:33.199] getGlobalsAndPackages() ... DONE
[09:31:33.199] run() for ‘Future’ ...
[09:31:33.199] - state: ‘created’
[09:31:33.199] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.199] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.200] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.200]   - Field: ‘label’
[09:31:33.200]   - Field: ‘local’
[09:31:33.200]   - Field: ‘owner’
[09:31:33.200]   - Field: ‘envir’
[09:31:33.200]   - Field: ‘packages’
[09:31:33.200]   - Field: ‘gc’
[09:31:33.200]   - Field: ‘conditions’
[09:31:33.200]   - Field: ‘expr’
[09:31:33.200]   - Field: ‘uuid’
[09:31:33.200]   - Field: ‘seed’
[09:31:33.200]   - Field: ‘version’
[09:31:33.201]   - Field: ‘result’
[09:31:33.201]   - Field: ‘asynchronous’
[09:31:33.201]   - Field: ‘calls’
[09:31:33.201]   - Field: ‘globals’
[09:31:33.201]   - Field: ‘stdout’
[09:31:33.201]   - Field: ‘earlySignal’
[09:31:33.201]   - Field: ‘lazy’
[09:31:33.201]   - Field: ‘state’
[09:31:33.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.201] - Launch lazy future ...
[09:31:33.201] Packages needed by the future expression (n = 0): <none>
[09:31:33.202] Packages needed by future strategies (n = 0): <none>
[09:31:33.202] {
[09:31:33.202]     {
[09:31:33.202]         {
[09:31:33.202]             ...future.startTime <- base::Sys.time()
[09:31:33.202]             {
[09:31:33.202]                 {
[09:31:33.202]                   {
[09:31:33.202]                     base::local({
[09:31:33.202]                       has_future <- base::requireNamespace("future", 
[09:31:33.202]                         quietly = TRUE)
[09:31:33.202]                       if (has_future) {
[09:31:33.202]                         ns <- base::getNamespace("future")
[09:31:33.202]                         version <- ns[[".package"]][["version"]]
[09:31:33.202]                         if (is.null(version)) 
[09:31:33.202]                           version <- utils::packageVersion("future")
[09:31:33.202]                       }
[09:31:33.202]                       else {
[09:31:33.202]                         version <- NULL
[09:31:33.202]                       }
[09:31:33.202]                       if (!has_future || version < "1.8.0") {
[09:31:33.202]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.202]                           "", base::R.version$version.string), 
[09:31:33.202]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.202]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.202]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.202]                             "release", "version")], collapse = " "), 
[09:31:33.202]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.202]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.202]                           info)
[09:31:33.202]                         info <- base::paste(info, collapse = "; ")
[09:31:33.202]                         if (!has_future) {
[09:31:33.202]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.202]                             info)
[09:31:33.202]                         }
[09:31:33.202]                         else {
[09:31:33.202]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.202]                             info, version)
[09:31:33.202]                         }
[09:31:33.202]                         base::stop(msg)
[09:31:33.202]                       }
[09:31:33.202]                     })
[09:31:33.202]                   }
[09:31:33.202]                   ...future.strategy.old <- future::plan("list")
[09:31:33.202]                   options(future.plan = NULL)
[09:31:33.202]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.202]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.202]                 }
[09:31:33.202]                 ...future.workdir <- getwd()
[09:31:33.202]             }
[09:31:33.202]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.202]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.202]         }
[09:31:33.202]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.202]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.202]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.202]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.202]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.202]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.202]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.202]             base::names(...future.oldOptions))
[09:31:33.202]     }
[09:31:33.202]     if (FALSE) {
[09:31:33.202]     }
[09:31:33.202]     else {
[09:31:33.202]         if (TRUE) {
[09:31:33.202]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.202]                 open = "w")
[09:31:33.202]         }
[09:31:33.202]         else {
[09:31:33.202]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.202]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.202]         }
[09:31:33.202]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.202]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.202]             base::sink(type = "output", split = FALSE)
[09:31:33.202]             base::close(...future.stdout)
[09:31:33.202]         }, add = TRUE)
[09:31:33.202]     }
[09:31:33.202]     ...future.frame <- base::sys.nframe()
[09:31:33.202]     ...future.conditions <- base::list()
[09:31:33.202]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.202]     if (FALSE) {
[09:31:33.202]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.202]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.202]     }
[09:31:33.202]     ...future.result <- base::tryCatch({
[09:31:33.202]         base::withCallingHandlers({
[09:31:33.202]             ...future.value <- base::withVisible(base::local({
[09:31:33.202]                 b <- a * ii
[09:31:33.202]                 a <- 0
[09:31:33.202]                 b
[09:31:33.202]             }))
[09:31:33.202]             future::FutureResult(value = ...future.value$value, 
[09:31:33.202]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.202]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.202]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.202]                     ...future.globalenv.names))
[09:31:33.202]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.202]         }, condition = base::local({
[09:31:33.202]             c <- base::c
[09:31:33.202]             inherits <- base::inherits
[09:31:33.202]             invokeRestart <- base::invokeRestart
[09:31:33.202]             length <- base::length
[09:31:33.202]             list <- base::list
[09:31:33.202]             seq.int <- base::seq.int
[09:31:33.202]             signalCondition <- base::signalCondition
[09:31:33.202]             sys.calls <- base::sys.calls
[09:31:33.202]             `[[` <- base::`[[`
[09:31:33.202]             `+` <- base::`+`
[09:31:33.202]             `<<-` <- base::`<<-`
[09:31:33.202]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.202]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.202]                   3L)]
[09:31:33.202]             }
[09:31:33.202]             function(cond) {
[09:31:33.202]                 is_error <- inherits(cond, "error")
[09:31:33.202]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.202]                   NULL)
[09:31:33.202]                 if (is_error) {
[09:31:33.202]                   sessionInformation <- function() {
[09:31:33.202]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.202]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.202]                       search = base::search(), system = base::Sys.info())
[09:31:33.202]                   }
[09:31:33.202]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.202]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.202]                     cond$call), session = sessionInformation(), 
[09:31:33.202]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.202]                   signalCondition(cond)
[09:31:33.202]                 }
[09:31:33.202]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.202]                 "immediateCondition"))) {
[09:31:33.202]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.202]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.202]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.202]                   if (TRUE && !signal) {
[09:31:33.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.202]                     {
[09:31:33.202]                       inherits <- base::inherits
[09:31:33.202]                       invokeRestart <- base::invokeRestart
[09:31:33.202]                       is.null <- base::is.null
[09:31:33.202]                       muffled <- FALSE
[09:31:33.202]                       if (inherits(cond, "message")) {
[09:31:33.202]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.202]                         if (muffled) 
[09:31:33.202]                           invokeRestart("muffleMessage")
[09:31:33.202]                       }
[09:31:33.202]                       else if (inherits(cond, "warning")) {
[09:31:33.202]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.202]                         if (muffled) 
[09:31:33.202]                           invokeRestart("muffleWarning")
[09:31:33.202]                       }
[09:31:33.202]                       else if (inherits(cond, "condition")) {
[09:31:33.202]                         if (!is.null(pattern)) {
[09:31:33.202]                           computeRestarts <- base::computeRestarts
[09:31:33.202]                           grepl <- base::grepl
[09:31:33.202]                           restarts <- computeRestarts(cond)
[09:31:33.202]                           for (restart in restarts) {
[09:31:33.202]                             name <- restart$name
[09:31:33.202]                             if (is.null(name)) 
[09:31:33.202]                               next
[09:31:33.202]                             if (!grepl(pattern, name)) 
[09:31:33.202]                               next
[09:31:33.202]                             invokeRestart(restart)
[09:31:33.202]                             muffled <- TRUE
[09:31:33.202]                             break
[09:31:33.202]                           }
[09:31:33.202]                         }
[09:31:33.202]                       }
[09:31:33.202]                       invisible(muffled)
[09:31:33.202]                     }
[09:31:33.202]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.202]                   }
[09:31:33.202]                 }
[09:31:33.202]                 else {
[09:31:33.202]                   if (TRUE) {
[09:31:33.202]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.202]                     {
[09:31:33.202]                       inherits <- base::inherits
[09:31:33.202]                       invokeRestart <- base::invokeRestart
[09:31:33.202]                       is.null <- base::is.null
[09:31:33.202]                       muffled <- FALSE
[09:31:33.202]                       if (inherits(cond, "message")) {
[09:31:33.202]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.202]                         if (muffled) 
[09:31:33.202]                           invokeRestart("muffleMessage")
[09:31:33.202]                       }
[09:31:33.202]                       else if (inherits(cond, "warning")) {
[09:31:33.202]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.202]                         if (muffled) 
[09:31:33.202]                           invokeRestart("muffleWarning")
[09:31:33.202]                       }
[09:31:33.202]                       else if (inherits(cond, "condition")) {
[09:31:33.202]                         if (!is.null(pattern)) {
[09:31:33.202]                           computeRestarts <- base::computeRestarts
[09:31:33.202]                           grepl <- base::grepl
[09:31:33.202]                           restarts <- computeRestarts(cond)
[09:31:33.202]                           for (restart in restarts) {
[09:31:33.202]                             name <- restart$name
[09:31:33.202]                             if (is.null(name)) 
[09:31:33.202]                               next
[09:31:33.202]                             if (!grepl(pattern, name)) 
[09:31:33.202]                               next
[09:31:33.202]                             invokeRestart(restart)
[09:31:33.202]                             muffled <- TRUE
[09:31:33.202]                             break
[09:31:33.202]                           }
[09:31:33.202]                         }
[09:31:33.202]                       }
[09:31:33.202]                       invisible(muffled)
[09:31:33.202]                     }
[09:31:33.202]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.202]                   }
[09:31:33.202]                 }
[09:31:33.202]             }
[09:31:33.202]         }))
[09:31:33.202]     }, error = function(ex) {
[09:31:33.202]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.202]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.202]                 ...future.rng), started = ...future.startTime, 
[09:31:33.202]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.202]             version = "1.8"), class = "FutureResult")
[09:31:33.202]     }, finally = {
[09:31:33.202]         if (!identical(...future.workdir, getwd())) 
[09:31:33.202]             setwd(...future.workdir)
[09:31:33.202]         {
[09:31:33.202]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.202]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.202]             }
[09:31:33.202]             base::options(...future.oldOptions)
[09:31:33.202]             if (.Platform$OS.type == "windows") {
[09:31:33.202]                 old_names <- names(...future.oldEnvVars)
[09:31:33.202]                 envs <- base::Sys.getenv()
[09:31:33.202]                 names <- names(envs)
[09:31:33.202]                 common <- intersect(names, old_names)
[09:31:33.202]                 added <- setdiff(names, old_names)
[09:31:33.202]                 removed <- setdiff(old_names, names)
[09:31:33.202]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.202]                   envs[common]]
[09:31:33.202]                 NAMES <- toupper(changed)
[09:31:33.202]                 args <- list()
[09:31:33.202]                 for (kk in seq_along(NAMES)) {
[09:31:33.202]                   name <- changed[[kk]]
[09:31:33.202]                   NAME <- NAMES[[kk]]
[09:31:33.202]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.202]                     next
[09:31:33.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.202]                 }
[09:31:33.202]                 NAMES <- toupper(added)
[09:31:33.202]                 for (kk in seq_along(NAMES)) {
[09:31:33.202]                   name <- added[[kk]]
[09:31:33.202]                   NAME <- NAMES[[kk]]
[09:31:33.202]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.202]                     next
[09:31:33.202]                   args[[name]] <- ""
[09:31:33.202]                 }
[09:31:33.202]                 NAMES <- toupper(removed)
[09:31:33.202]                 for (kk in seq_along(NAMES)) {
[09:31:33.202]                   name <- removed[[kk]]
[09:31:33.202]                   NAME <- NAMES[[kk]]
[09:31:33.202]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.202]                     next
[09:31:33.202]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.202]                 }
[09:31:33.202]                 if (length(args) > 0) 
[09:31:33.202]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.202]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.202]             }
[09:31:33.202]             else {
[09:31:33.202]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.202]             }
[09:31:33.202]             {
[09:31:33.202]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.202]                   0L) {
[09:31:33.202]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.202]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.202]                   base::options(opts)
[09:31:33.202]                 }
[09:31:33.202]                 {
[09:31:33.202]                   {
[09:31:33.202]                     NULL
[09:31:33.202]                     RNGkind("Mersenne-Twister")
[09:31:33.202]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.202]                       inherits = FALSE)
[09:31:33.202]                   }
[09:31:33.202]                   options(future.plan = NULL)
[09:31:33.202]                   if (is.na(NA_character_)) 
[09:31:33.202]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.202]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.202]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.202]                     .init = FALSE)
[09:31:33.202]                 }
[09:31:33.202]             }
[09:31:33.202]         }
[09:31:33.202]     })
[09:31:33.202]     if (TRUE) {
[09:31:33.202]         base::sink(type = "output", split = FALSE)
[09:31:33.202]         if (TRUE) {
[09:31:33.202]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.202]         }
[09:31:33.202]         else {
[09:31:33.202]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.202]         }
[09:31:33.202]         base::close(...future.stdout)
[09:31:33.202]         ...future.stdout <- NULL
[09:31:33.202]     }
[09:31:33.202]     ...future.result$conditions <- ...future.conditions
[09:31:33.202]     ...future.result$finished <- base::Sys.time()
[09:31:33.202]     ...future.result
[09:31:33.202] }
[09:31:33.203] assign_globals() ...
[09:31:33.204] List of 2
[09:31:33.204]  $ a : num 1
[09:31:33.204]  $ ii: int 1
[09:31:33.204]  - attr(*, "where")=List of 2
[09:31:33.204]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.204]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.204]  - attr(*, "resolved")= logi TRUE
[09:31:33.204]  - attr(*, "total_size")= num 112
[09:31:33.204]  - attr(*, "already-done")= logi TRUE
[09:31:33.206] - copied ‘a’ to environment
[09:31:33.206] - copied ‘ii’ to environment
[09:31:33.207] assign_globals() ... done
[09:31:33.207] plan(): Setting new future strategy stack:
[09:31:33.207] List of future strategies:
[09:31:33.207] 1. sequential:
[09:31:33.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.207]    - tweaked: FALSE
[09:31:33.207]    - call: NULL
[09:31:33.207] plan(): nbrOfWorkers() = 1
[09:31:33.208] plan(): Setting new future strategy stack:
[09:31:33.208] List of future strategies:
[09:31:33.208] 1. sequential:
[09:31:33.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.208]    - tweaked: FALSE
[09:31:33.208]    - call: plan(strategy)
[09:31:33.208] plan(): nbrOfWorkers() = 1
[09:31:33.209] SequentialFuture started (and completed)
[09:31:33.209] - Launch lazy future ... done
[09:31:33.209] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.209] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.209] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.211] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.211] Searching for globals ... DONE
[09:31:33.211] Resolving globals: TRUE
[09:31:33.211] Resolving any globals that are futures ...
[09:31:33.211] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.211] Resolving any globals that are futures ... DONE
[09:31:33.212] Resolving futures part of globals (recursively) ...
[09:31:33.212] resolve() on list ...
[09:31:33.212]  recursive: 99
[09:31:33.212]  length: 2
[09:31:33.212]  elements: ‘a’, ‘ii’
[09:31:33.212]  length: 1 (resolved future 1)
[09:31:33.212]  length: 0 (resolved future 2)
[09:31:33.213] resolve() on list ... DONE
[09:31:33.213] - globals: [2] ‘a’, ‘ii’
[09:31:33.213] Resolving futures part of globals (recursively) ... DONE
[09:31:33.213] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.213] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.213] - globals: [2] ‘a’, ‘ii’
[09:31:33.213] 
[09:31:33.213] getGlobalsAndPackages() ... DONE
[09:31:33.214] run() for ‘Future’ ...
[09:31:33.214] - state: ‘created’
[09:31:33.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.214]   - Field: ‘label’
[09:31:33.214]   - Field: ‘local’
[09:31:33.214]   - Field: ‘owner’
[09:31:33.215]   - Field: ‘envir’
[09:31:33.215]   - Field: ‘packages’
[09:31:33.215]   - Field: ‘gc’
[09:31:33.215]   - Field: ‘conditions’
[09:31:33.215]   - Field: ‘expr’
[09:31:33.215]   - Field: ‘uuid’
[09:31:33.215]   - Field: ‘seed’
[09:31:33.215]   - Field: ‘version’
[09:31:33.215]   - Field: ‘result’
[09:31:33.215]   - Field: ‘asynchronous’
[09:31:33.215]   - Field: ‘calls’
[09:31:33.215]   - Field: ‘globals’
[09:31:33.216]   - Field: ‘stdout’
[09:31:33.216]   - Field: ‘earlySignal’
[09:31:33.216]   - Field: ‘lazy’
[09:31:33.216]   - Field: ‘state’
[09:31:33.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.216] - Launch lazy future ...
[09:31:33.216] Packages needed by the future expression (n = 0): <none>
[09:31:33.216] Packages needed by future strategies (n = 0): <none>
[09:31:33.217] {
[09:31:33.217]     {
[09:31:33.217]         {
[09:31:33.217]             ...future.startTime <- base::Sys.time()
[09:31:33.217]             {
[09:31:33.217]                 {
[09:31:33.217]                   {
[09:31:33.217]                     base::local({
[09:31:33.217]                       has_future <- base::requireNamespace("future", 
[09:31:33.217]                         quietly = TRUE)
[09:31:33.217]                       if (has_future) {
[09:31:33.217]                         ns <- base::getNamespace("future")
[09:31:33.217]                         version <- ns[[".package"]][["version"]]
[09:31:33.217]                         if (is.null(version)) 
[09:31:33.217]                           version <- utils::packageVersion("future")
[09:31:33.217]                       }
[09:31:33.217]                       else {
[09:31:33.217]                         version <- NULL
[09:31:33.217]                       }
[09:31:33.217]                       if (!has_future || version < "1.8.0") {
[09:31:33.217]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.217]                           "", base::R.version$version.string), 
[09:31:33.217]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.217]                             "release", "version")], collapse = " "), 
[09:31:33.217]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.217]                           info)
[09:31:33.217]                         info <- base::paste(info, collapse = "; ")
[09:31:33.217]                         if (!has_future) {
[09:31:33.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.217]                             info)
[09:31:33.217]                         }
[09:31:33.217]                         else {
[09:31:33.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.217]                             info, version)
[09:31:33.217]                         }
[09:31:33.217]                         base::stop(msg)
[09:31:33.217]                       }
[09:31:33.217]                     })
[09:31:33.217]                   }
[09:31:33.217]                   ...future.strategy.old <- future::plan("list")
[09:31:33.217]                   options(future.plan = NULL)
[09:31:33.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.217]                 }
[09:31:33.217]                 ...future.workdir <- getwd()
[09:31:33.217]             }
[09:31:33.217]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.217]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.217]         }
[09:31:33.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.217]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.217]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.217]             base::names(...future.oldOptions))
[09:31:33.217]     }
[09:31:33.217]     if (FALSE) {
[09:31:33.217]     }
[09:31:33.217]     else {
[09:31:33.217]         if (TRUE) {
[09:31:33.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.217]                 open = "w")
[09:31:33.217]         }
[09:31:33.217]         else {
[09:31:33.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.217]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.217]         }
[09:31:33.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.217]             base::sink(type = "output", split = FALSE)
[09:31:33.217]             base::close(...future.stdout)
[09:31:33.217]         }, add = TRUE)
[09:31:33.217]     }
[09:31:33.217]     ...future.frame <- base::sys.nframe()
[09:31:33.217]     ...future.conditions <- base::list()
[09:31:33.217]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.217]     if (FALSE) {
[09:31:33.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.217]     }
[09:31:33.217]     ...future.result <- base::tryCatch({
[09:31:33.217]         base::withCallingHandlers({
[09:31:33.217]             ...future.value <- base::withVisible(base::local({
[09:31:33.217]                 b <- a * ii
[09:31:33.217]                 a <- 0
[09:31:33.217]                 b
[09:31:33.217]             }))
[09:31:33.217]             future::FutureResult(value = ...future.value$value, 
[09:31:33.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.217]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.217]                     ...future.globalenv.names))
[09:31:33.217]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.217]         }, condition = base::local({
[09:31:33.217]             c <- base::c
[09:31:33.217]             inherits <- base::inherits
[09:31:33.217]             invokeRestart <- base::invokeRestart
[09:31:33.217]             length <- base::length
[09:31:33.217]             list <- base::list
[09:31:33.217]             seq.int <- base::seq.int
[09:31:33.217]             signalCondition <- base::signalCondition
[09:31:33.217]             sys.calls <- base::sys.calls
[09:31:33.217]             `[[` <- base::`[[`
[09:31:33.217]             `+` <- base::`+`
[09:31:33.217]             `<<-` <- base::`<<-`
[09:31:33.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.217]                   3L)]
[09:31:33.217]             }
[09:31:33.217]             function(cond) {
[09:31:33.217]                 is_error <- inherits(cond, "error")
[09:31:33.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.217]                   NULL)
[09:31:33.217]                 if (is_error) {
[09:31:33.217]                   sessionInformation <- function() {
[09:31:33.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.217]                       search = base::search(), system = base::Sys.info())
[09:31:33.217]                   }
[09:31:33.217]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.217]                     cond$call), session = sessionInformation(), 
[09:31:33.217]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.217]                   signalCondition(cond)
[09:31:33.217]                 }
[09:31:33.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.217]                 "immediateCondition"))) {
[09:31:33.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.217]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.217]                   if (TRUE && !signal) {
[09:31:33.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.217]                     {
[09:31:33.217]                       inherits <- base::inherits
[09:31:33.217]                       invokeRestart <- base::invokeRestart
[09:31:33.217]                       is.null <- base::is.null
[09:31:33.217]                       muffled <- FALSE
[09:31:33.217]                       if (inherits(cond, "message")) {
[09:31:33.217]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.217]                         if (muffled) 
[09:31:33.217]                           invokeRestart("muffleMessage")
[09:31:33.217]                       }
[09:31:33.217]                       else if (inherits(cond, "warning")) {
[09:31:33.217]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.217]                         if (muffled) 
[09:31:33.217]                           invokeRestart("muffleWarning")
[09:31:33.217]                       }
[09:31:33.217]                       else if (inherits(cond, "condition")) {
[09:31:33.217]                         if (!is.null(pattern)) {
[09:31:33.217]                           computeRestarts <- base::computeRestarts
[09:31:33.217]                           grepl <- base::grepl
[09:31:33.217]                           restarts <- computeRestarts(cond)
[09:31:33.217]                           for (restart in restarts) {
[09:31:33.217]                             name <- restart$name
[09:31:33.217]                             if (is.null(name)) 
[09:31:33.217]                               next
[09:31:33.217]                             if (!grepl(pattern, name)) 
[09:31:33.217]                               next
[09:31:33.217]                             invokeRestart(restart)
[09:31:33.217]                             muffled <- TRUE
[09:31:33.217]                             break
[09:31:33.217]                           }
[09:31:33.217]                         }
[09:31:33.217]                       }
[09:31:33.217]                       invisible(muffled)
[09:31:33.217]                     }
[09:31:33.217]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.217]                   }
[09:31:33.217]                 }
[09:31:33.217]                 else {
[09:31:33.217]                   if (TRUE) {
[09:31:33.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.217]                     {
[09:31:33.217]                       inherits <- base::inherits
[09:31:33.217]                       invokeRestart <- base::invokeRestart
[09:31:33.217]                       is.null <- base::is.null
[09:31:33.217]                       muffled <- FALSE
[09:31:33.217]                       if (inherits(cond, "message")) {
[09:31:33.217]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.217]                         if (muffled) 
[09:31:33.217]                           invokeRestart("muffleMessage")
[09:31:33.217]                       }
[09:31:33.217]                       else if (inherits(cond, "warning")) {
[09:31:33.217]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.217]                         if (muffled) 
[09:31:33.217]                           invokeRestart("muffleWarning")
[09:31:33.217]                       }
[09:31:33.217]                       else if (inherits(cond, "condition")) {
[09:31:33.217]                         if (!is.null(pattern)) {
[09:31:33.217]                           computeRestarts <- base::computeRestarts
[09:31:33.217]                           grepl <- base::grepl
[09:31:33.217]                           restarts <- computeRestarts(cond)
[09:31:33.217]                           for (restart in restarts) {
[09:31:33.217]                             name <- restart$name
[09:31:33.217]                             if (is.null(name)) 
[09:31:33.217]                               next
[09:31:33.217]                             if (!grepl(pattern, name)) 
[09:31:33.217]                               next
[09:31:33.217]                             invokeRestart(restart)
[09:31:33.217]                             muffled <- TRUE
[09:31:33.217]                             break
[09:31:33.217]                           }
[09:31:33.217]                         }
[09:31:33.217]                       }
[09:31:33.217]                       invisible(muffled)
[09:31:33.217]                     }
[09:31:33.217]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.217]                   }
[09:31:33.217]                 }
[09:31:33.217]             }
[09:31:33.217]         }))
[09:31:33.217]     }, error = function(ex) {
[09:31:33.217]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.217]                 ...future.rng), started = ...future.startTime, 
[09:31:33.217]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.217]             version = "1.8"), class = "FutureResult")
[09:31:33.217]     }, finally = {
[09:31:33.217]         if (!identical(...future.workdir, getwd())) 
[09:31:33.217]             setwd(...future.workdir)
[09:31:33.217]         {
[09:31:33.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.217]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.217]             }
[09:31:33.217]             base::options(...future.oldOptions)
[09:31:33.217]             if (.Platform$OS.type == "windows") {
[09:31:33.217]                 old_names <- names(...future.oldEnvVars)
[09:31:33.217]                 envs <- base::Sys.getenv()
[09:31:33.217]                 names <- names(envs)
[09:31:33.217]                 common <- intersect(names, old_names)
[09:31:33.217]                 added <- setdiff(names, old_names)
[09:31:33.217]                 removed <- setdiff(old_names, names)
[09:31:33.217]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.217]                   envs[common]]
[09:31:33.217]                 NAMES <- toupper(changed)
[09:31:33.217]                 args <- list()
[09:31:33.217]                 for (kk in seq_along(NAMES)) {
[09:31:33.217]                   name <- changed[[kk]]
[09:31:33.217]                   NAME <- NAMES[[kk]]
[09:31:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.217]                     next
[09:31:33.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.217]                 }
[09:31:33.217]                 NAMES <- toupper(added)
[09:31:33.217]                 for (kk in seq_along(NAMES)) {
[09:31:33.217]                   name <- added[[kk]]
[09:31:33.217]                   NAME <- NAMES[[kk]]
[09:31:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.217]                     next
[09:31:33.217]                   args[[name]] <- ""
[09:31:33.217]                 }
[09:31:33.217]                 NAMES <- toupper(removed)
[09:31:33.217]                 for (kk in seq_along(NAMES)) {
[09:31:33.217]                   name <- removed[[kk]]
[09:31:33.217]                   NAME <- NAMES[[kk]]
[09:31:33.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.217]                     next
[09:31:33.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.217]                 }
[09:31:33.217]                 if (length(args) > 0) 
[09:31:33.217]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.217]             }
[09:31:33.217]             else {
[09:31:33.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.217]             }
[09:31:33.217]             {
[09:31:33.217]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.217]                   0L) {
[09:31:33.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.217]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.217]                   base::options(opts)
[09:31:33.217]                 }
[09:31:33.217]                 {
[09:31:33.217]                   {
[09:31:33.217]                     NULL
[09:31:33.217]                     RNGkind("Mersenne-Twister")
[09:31:33.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.217]                       inherits = FALSE)
[09:31:33.217]                   }
[09:31:33.217]                   options(future.plan = NULL)
[09:31:33.217]                   if (is.na(NA_character_)) 
[09:31:33.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.217]                     .init = FALSE)
[09:31:33.217]                 }
[09:31:33.217]             }
[09:31:33.217]         }
[09:31:33.217]     })
[09:31:33.217]     if (TRUE) {
[09:31:33.217]         base::sink(type = "output", split = FALSE)
[09:31:33.217]         if (TRUE) {
[09:31:33.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.217]         }
[09:31:33.217]         else {
[09:31:33.217]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.217]         }
[09:31:33.217]         base::close(...future.stdout)
[09:31:33.217]         ...future.stdout <- NULL
[09:31:33.217]     }
[09:31:33.217]     ...future.result$conditions <- ...future.conditions
[09:31:33.217]     ...future.result$finished <- base::Sys.time()
[09:31:33.217]     ...future.result
[09:31:33.217] }
[09:31:33.218] assign_globals() ...
[09:31:33.218] List of 2
[09:31:33.218]  $ a : num 1
[09:31:33.218]  $ ii: int 2
[09:31:33.218]  - attr(*, "where")=List of 2
[09:31:33.218]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.218]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.218]  - attr(*, "resolved")= logi TRUE
[09:31:33.218]  - attr(*, "total_size")= num 112
[09:31:33.218]  - attr(*, "already-done")= logi TRUE
[09:31:33.221] - copied ‘a’ to environment
[09:31:33.221] - copied ‘ii’ to environment
[09:31:33.221] assign_globals() ... done
[09:31:33.221] plan(): Setting new future strategy stack:
[09:31:33.222] List of future strategies:
[09:31:33.222] 1. sequential:
[09:31:33.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.222]    - tweaked: FALSE
[09:31:33.222]    - call: NULL
[09:31:33.223] plan(): nbrOfWorkers() = 1
[09:31:33.224] plan(): Setting new future strategy stack:
[09:31:33.224] List of future strategies:
[09:31:33.224] 1. sequential:
[09:31:33.224]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.224]    - tweaked: FALSE
[09:31:33.224]    - call: plan(strategy)
[09:31:33.224] plan(): nbrOfWorkers() = 1
[09:31:33.224] SequentialFuture started (and completed)
[09:31:33.224] - Launch lazy future ... done
[09:31:33.224] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.225] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.225] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.227] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.227] Searching for globals ... DONE
[09:31:33.227] Resolving globals: TRUE
[09:31:33.227] Resolving any globals that are futures ...
[09:31:33.227] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.227] Resolving any globals that are futures ... DONE
[09:31:33.227] Resolving futures part of globals (recursively) ...
[09:31:33.228] resolve() on list ...
[09:31:33.228]  recursive: 99
[09:31:33.228]  length: 2
[09:31:33.228]  elements: ‘a’, ‘ii’
[09:31:33.228]  length: 1 (resolved future 1)
[09:31:33.228]  length: 0 (resolved future 2)
[09:31:33.228] resolve() on list ... DONE
[09:31:33.228] - globals: [2] ‘a’, ‘ii’
[09:31:33.228] Resolving futures part of globals (recursively) ... DONE
[09:31:33.229] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.229] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.229] - globals: [2] ‘a’, ‘ii’
[09:31:33.229] 
[09:31:33.229] getGlobalsAndPackages() ... DONE
[09:31:33.229] run() for ‘Future’ ...
[09:31:33.229] - state: ‘created’
[09:31:33.230] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.230] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.230] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.230]   - Field: ‘label’
[09:31:33.230]   - Field: ‘local’
[09:31:33.230]   - Field: ‘owner’
[09:31:33.230]   - Field: ‘envir’
[09:31:33.230]   - Field: ‘packages’
[09:31:33.230]   - Field: ‘gc’
[09:31:33.231]   - Field: ‘conditions’
[09:31:33.231]   - Field: ‘expr’
[09:31:33.231]   - Field: ‘uuid’
[09:31:33.231]   - Field: ‘seed’
[09:31:33.231]   - Field: ‘version’
[09:31:33.231]   - Field: ‘result’
[09:31:33.231]   - Field: ‘asynchronous’
[09:31:33.231]   - Field: ‘calls’
[09:31:33.231]   - Field: ‘globals’
[09:31:33.231]   - Field: ‘stdout’
[09:31:33.231]   - Field: ‘earlySignal’
[09:31:33.231]   - Field: ‘lazy’
[09:31:33.232]   - Field: ‘state’
[09:31:33.232] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.232] - Launch lazy future ...
[09:31:33.232] Packages needed by the future expression (n = 0): <none>
[09:31:33.232] Packages needed by future strategies (n = 0): <none>
[09:31:33.232] {
[09:31:33.232]     {
[09:31:33.232]         {
[09:31:33.232]             ...future.startTime <- base::Sys.time()
[09:31:33.232]             {
[09:31:33.232]                 {
[09:31:33.232]                   {
[09:31:33.232]                     base::local({
[09:31:33.232]                       has_future <- base::requireNamespace("future", 
[09:31:33.232]                         quietly = TRUE)
[09:31:33.232]                       if (has_future) {
[09:31:33.232]                         ns <- base::getNamespace("future")
[09:31:33.232]                         version <- ns[[".package"]][["version"]]
[09:31:33.232]                         if (is.null(version)) 
[09:31:33.232]                           version <- utils::packageVersion("future")
[09:31:33.232]                       }
[09:31:33.232]                       else {
[09:31:33.232]                         version <- NULL
[09:31:33.232]                       }
[09:31:33.232]                       if (!has_future || version < "1.8.0") {
[09:31:33.232]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.232]                           "", base::R.version$version.string), 
[09:31:33.232]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.232]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.232]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.232]                             "release", "version")], collapse = " "), 
[09:31:33.232]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.232]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.232]                           info)
[09:31:33.232]                         info <- base::paste(info, collapse = "; ")
[09:31:33.232]                         if (!has_future) {
[09:31:33.232]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.232]                             info)
[09:31:33.232]                         }
[09:31:33.232]                         else {
[09:31:33.232]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.232]                             info, version)
[09:31:33.232]                         }
[09:31:33.232]                         base::stop(msg)
[09:31:33.232]                       }
[09:31:33.232]                     })
[09:31:33.232]                   }
[09:31:33.232]                   ...future.strategy.old <- future::plan("list")
[09:31:33.232]                   options(future.plan = NULL)
[09:31:33.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.232]                 }
[09:31:33.232]                 ...future.workdir <- getwd()
[09:31:33.232]             }
[09:31:33.232]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.232]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.232]         }
[09:31:33.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.232]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.232]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.232]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.232]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.232]             base::names(...future.oldOptions))
[09:31:33.232]     }
[09:31:33.232]     if (FALSE) {
[09:31:33.232]     }
[09:31:33.232]     else {
[09:31:33.232]         if (TRUE) {
[09:31:33.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.232]                 open = "w")
[09:31:33.232]         }
[09:31:33.232]         else {
[09:31:33.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.232]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.232]         }
[09:31:33.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.232]             base::sink(type = "output", split = FALSE)
[09:31:33.232]             base::close(...future.stdout)
[09:31:33.232]         }, add = TRUE)
[09:31:33.232]     }
[09:31:33.232]     ...future.frame <- base::sys.nframe()
[09:31:33.232]     ...future.conditions <- base::list()
[09:31:33.232]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.232]     if (FALSE) {
[09:31:33.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.232]     }
[09:31:33.232]     ...future.result <- base::tryCatch({
[09:31:33.232]         base::withCallingHandlers({
[09:31:33.232]             ...future.value <- base::withVisible(base::local({
[09:31:33.232]                 b <- a * ii
[09:31:33.232]                 a <- 0
[09:31:33.232]                 b
[09:31:33.232]             }))
[09:31:33.232]             future::FutureResult(value = ...future.value$value, 
[09:31:33.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.232]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.232]                     ...future.globalenv.names))
[09:31:33.232]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.232]         }, condition = base::local({
[09:31:33.232]             c <- base::c
[09:31:33.232]             inherits <- base::inherits
[09:31:33.232]             invokeRestart <- base::invokeRestart
[09:31:33.232]             length <- base::length
[09:31:33.232]             list <- base::list
[09:31:33.232]             seq.int <- base::seq.int
[09:31:33.232]             signalCondition <- base::signalCondition
[09:31:33.232]             sys.calls <- base::sys.calls
[09:31:33.232]             `[[` <- base::`[[`
[09:31:33.232]             `+` <- base::`+`
[09:31:33.232]             `<<-` <- base::`<<-`
[09:31:33.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.232]                   3L)]
[09:31:33.232]             }
[09:31:33.232]             function(cond) {
[09:31:33.232]                 is_error <- inherits(cond, "error")
[09:31:33.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.232]                   NULL)
[09:31:33.232]                 if (is_error) {
[09:31:33.232]                   sessionInformation <- function() {
[09:31:33.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.232]                       search = base::search(), system = base::Sys.info())
[09:31:33.232]                   }
[09:31:33.232]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.232]                     cond$call), session = sessionInformation(), 
[09:31:33.232]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.232]                   signalCondition(cond)
[09:31:33.232]                 }
[09:31:33.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.232]                 "immediateCondition"))) {
[09:31:33.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.232]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.232]                   if (TRUE && !signal) {
[09:31:33.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.232]                     {
[09:31:33.232]                       inherits <- base::inherits
[09:31:33.232]                       invokeRestart <- base::invokeRestart
[09:31:33.232]                       is.null <- base::is.null
[09:31:33.232]                       muffled <- FALSE
[09:31:33.232]                       if (inherits(cond, "message")) {
[09:31:33.232]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.232]                         if (muffled) 
[09:31:33.232]                           invokeRestart("muffleMessage")
[09:31:33.232]                       }
[09:31:33.232]                       else if (inherits(cond, "warning")) {
[09:31:33.232]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.232]                         if (muffled) 
[09:31:33.232]                           invokeRestart("muffleWarning")
[09:31:33.232]                       }
[09:31:33.232]                       else if (inherits(cond, "condition")) {
[09:31:33.232]                         if (!is.null(pattern)) {
[09:31:33.232]                           computeRestarts <- base::computeRestarts
[09:31:33.232]                           grepl <- base::grepl
[09:31:33.232]                           restarts <- computeRestarts(cond)
[09:31:33.232]                           for (restart in restarts) {
[09:31:33.232]                             name <- restart$name
[09:31:33.232]                             if (is.null(name)) 
[09:31:33.232]                               next
[09:31:33.232]                             if (!grepl(pattern, name)) 
[09:31:33.232]                               next
[09:31:33.232]                             invokeRestart(restart)
[09:31:33.232]                             muffled <- TRUE
[09:31:33.232]                             break
[09:31:33.232]                           }
[09:31:33.232]                         }
[09:31:33.232]                       }
[09:31:33.232]                       invisible(muffled)
[09:31:33.232]                     }
[09:31:33.232]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.232]                   }
[09:31:33.232]                 }
[09:31:33.232]                 else {
[09:31:33.232]                   if (TRUE) {
[09:31:33.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.232]                     {
[09:31:33.232]                       inherits <- base::inherits
[09:31:33.232]                       invokeRestart <- base::invokeRestart
[09:31:33.232]                       is.null <- base::is.null
[09:31:33.232]                       muffled <- FALSE
[09:31:33.232]                       if (inherits(cond, "message")) {
[09:31:33.232]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.232]                         if (muffled) 
[09:31:33.232]                           invokeRestart("muffleMessage")
[09:31:33.232]                       }
[09:31:33.232]                       else if (inherits(cond, "warning")) {
[09:31:33.232]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.232]                         if (muffled) 
[09:31:33.232]                           invokeRestart("muffleWarning")
[09:31:33.232]                       }
[09:31:33.232]                       else if (inherits(cond, "condition")) {
[09:31:33.232]                         if (!is.null(pattern)) {
[09:31:33.232]                           computeRestarts <- base::computeRestarts
[09:31:33.232]                           grepl <- base::grepl
[09:31:33.232]                           restarts <- computeRestarts(cond)
[09:31:33.232]                           for (restart in restarts) {
[09:31:33.232]                             name <- restart$name
[09:31:33.232]                             if (is.null(name)) 
[09:31:33.232]                               next
[09:31:33.232]                             if (!grepl(pattern, name)) 
[09:31:33.232]                               next
[09:31:33.232]                             invokeRestart(restart)
[09:31:33.232]                             muffled <- TRUE
[09:31:33.232]                             break
[09:31:33.232]                           }
[09:31:33.232]                         }
[09:31:33.232]                       }
[09:31:33.232]                       invisible(muffled)
[09:31:33.232]                     }
[09:31:33.232]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.232]                   }
[09:31:33.232]                 }
[09:31:33.232]             }
[09:31:33.232]         }))
[09:31:33.232]     }, error = function(ex) {
[09:31:33.232]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.232]                 ...future.rng), started = ...future.startTime, 
[09:31:33.232]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.232]             version = "1.8"), class = "FutureResult")
[09:31:33.232]     }, finally = {
[09:31:33.232]         if (!identical(...future.workdir, getwd())) 
[09:31:33.232]             setwd(...future.workdir)
[09:31:33.232]         {
[09:31:33.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.232]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.232]             }
[09:31:33.232]             base::options(...future.oldOptions)
[09:31:33.232]             if (.Platform$OS.type == "windows") {
[09:31:33.232]                 old_names <- names(...future.oldEnvVars)
[09:31:33.232]                 envs <- base::Sys.getenv()
[09:31:33.232]                 names <- names(envs)
[09:31:33.232]                 common <- intersect(names, old_names)
[09:31:33.232]                 added <- setdiff(names, old_names)
[09:31:33.232]                 removed <- setdiff(old_names, names)
[09:31:33.232]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.232]                   envs[common]]
[09:31:33.232]                 NAMES <- toupper(changed)
[09:31:33.232]                 args <- list()
[09:31:33.232]                 for (kk in seq_along(NAMES)) {
[09:31:33.232]                   name <- changed[[kk]]
[09:31:33.232]                   NAME <- NAMES[[kk]]
[09:31:33.232]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.232]                     next
[09:31:33.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.232]                 }
[09:31:33.232]                 NAMES <- toupper(added)
[09:31:33.232]                 for (kk in seq_along(NAMES)) {
[09:31:33.232]                   name <- added[[kk]]
[09:31:33.232]                   NAME <- NAMES[[kk]]
[09:31:33.232]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.232]                     next
[09:31:33.232]                   args[[name]] <- ""
[09:31:33.232]                 }
[09:31:33.232]                 NAMES <- toupper(removed)
[09:31:33.232]                 for (kk in seq_along(NAMES)) {
[09:31:33.232]                   name <- removed[[kk]]
[09:31:33.232]                   NAME <- NAMES[[kk]]
[09:31:33.232]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.232]                     next
[09:31:33.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.232]                 }
[09:31:33.232]                 if (length(args) > 0) 
[09:31:33.232]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.232]             }
[09:31:33.232]             else {
[09:31:33.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.232]             }
[09:31:33.232]             {
[09:31:33.232]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.232]                   0L) {
[09:31:33.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.232]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.232]                   base::options(opts)
[09:31:33.232]                 }
[09:31:33.232]                 {
[09:31:33.232]                   {
[09:31:33.232]                     NULL
[09:31:33.232]                     RNGkind("Mersenne-Twister")
[09:31:33.232]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.232]                       inherits = FALSE)
[09:31:33.232]                   }
[09:31:33.232]                   options(future.plan = NULL)
[09:31:33.232]                   if (is.na(NA_character_)) 
[09:31:33.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.232]                     .init = FALSE)
[09:31:33.232]                 }
[09:31:33.232]             }
[09:31:33.232]         }
[09:31:33.232]     })
[09:31:33.232]     if (TRUE) {
[09:31:33.232]         base::sink(type = "output", split = FALSE)
[09:31:33.232]         if (TRUE) {
[09:31:33.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.232]         }
[09:31:33.232]         else {
[09:31:33.232]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.232]         }
[09:31:33.232]         base::close(...future.stdout)
[09:31:33.232]         ...future.stdout <- NULL
[09:31:33.232]     }
[09:31:33.232]     ...future.result$conditions <- ...future.conditions
[09:31:33.232]     ...future.result$finished <- base::Sys.time()
[09:31:33.232]     ...future.result
[09:31:33.232] }
[09:31:33.234] assign_globals() ...
[09:31:33.234] List of 2
[09:31:33.234]  $ a : num 1
[09:31:33.234]  $ ii: int 3
[09:31:33.234]  - attr(*, "where")=List of 2
[09:31:33.234]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.234]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.234]  - attr(*, "resolved")= logi TRUE
[09:31:33.234]  - attr(*, "total_size")= num 112
[09:31:33.234]  - attr(*, "already-done")= logi TRUE
[09:31:33.237] - copied ‘a’ to environment
[09:31:33.237] - copied ‘ii’ to environment
[09:31:33.237] assign_globals() ... done
[09:31:33.237] plan(): Setting new future strategy stack:
[09:31:33.237] List of future strategies:
[09:31:33.237] 1. sequential:
[09:31:33.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.237]    - tweaked: FALSE
[09:31:33.237]    - call: NULL
[09:31:33.238] plan(): nbrOfWorkers() = 1
[09:31:33.238] plan(): Setting new future strategy stack:
[09:31:33.238] List of future strategies:
[09:31:33.238] 1. sequential:
[09:31:33.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.238]    - tweaked: FALSE
[09:31:33.238]    - call: plan(strategy)
[09:31:33.239] plan(): nbrOfWorkers() = 1
[09:31:33.239] SequentialFuture started (and completed)
[09:31:33.239] - Launch lazy future ... done
[09:31:33.239] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.240] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.240] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.242] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.242] Searching for globals ... DONE
[09:31:33.242] Resolving globals: TRUE
[09:31:33.242] Resolving any globals that are futures ...
[09:31:33.242] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.242] Resolving any globals that are futures ... DONE
[09:31:33.242] Resolving futures part of globals (recursively) ...
[09:31:33.243] resolve() on list ...
[09:31:33.243]  recursive: 99
[09:31:33.243]  length: 2
[09:31:33.243]  elements: ‘a’, ‘ii’
[09:31:33.243]  length: 1 (resolved future 1)
[09:31:33.243]  length: 0 (resolved future 2)
[09:31:33.243] resolve() on list ... DONE
[09:31:33.243] - globals: [2] ‘a’, ‘ii’
[09:31:33.243] Resolving futures part of globals (recursively) ... DONE
[09:31:33.244] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.244] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.244] - globals: [2] ‘a’, ‘ii’
[09:31:33.244] 
[09:31:33.244] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.245] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.245] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.247] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.248] Searching for globals ... DONE
[09:31:33.248] Resolving globals: TRUE
[09:31:33.248] Resolving any globals that are futures ...
[09:31:33.248] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.248] Resolving any globals that are futures ... DONE
[09:31:33.248] Resolving futures part of globals (recursively) ...
[09:31:33.248] resolve() on list ...
[09:31:33.249]  recursive: 99
[09:31:33.249]  length: 2
[09:31:33.249]  elements: ‘a’, ‘ii’
[09:31:33.249]  length: 1 (resolved future 1)
[09:31:33.249]  length: 0 (resolved future 2)
[09:31:33.249] resolve() on list ... DONE
[09:31:33.249] - globals: [2] ‘a’, ‘ii’
[09:31:33.249] Resolving futures part of globals (recursively) ... DONE
[09:31:33.249] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.250] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.250] - globals: [2] ‘a’, ‘ii’
[09:31:33.250] 
[09:31:33.250] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.250] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.251] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.252] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.252] Searching for globals ... DONE
[09:31:33.252] Resolving globals: TRUE
[09:31:33.253] Resolving any globals that are futures ...
[09:31:33.253] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:33.253] Resolving any globals that are futures ... DONE
[09:31:33.253] Resolving futures part of globals (recursively) ...
[09:31:33.253] resolve() on list ...
[09:31:33.253]  recursive: 99
[09:31:33.253]  length: 2
[09:31:33.253]  elements: ‘a’, ‘ii’
[09:31:33.254]  length: 1 (resolved future 1)
[09:31:33.254]  length: 0 (resolved future 2)
[09:31:33.254] resolve() on list ... DONE
[09:31:33.254] - globals: [2] ‘a’, ‘ii’
[09:31:33.254] Resolving futures part of globals (recursively) ... DONE
[09:31:33.254] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:33.254] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.254] - globals: [2] ‘a’, ‘ii’
[09:31:33.255] 
[09:31:33.255] getGlobalsAndPackages() ... DONE
[09:31:33.255] run() for ‘Future’ ...
[09:31:33.255] - state: ‘created’
[09:31:33.255] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.255] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.255] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.256]   - Field: ‘label’
[09:31:33.256]   - Field: ‘local’
[09:31:33.256]   - Field: ‘owner’
[09:31:33.256]   - Field: ‘envir’
[09:31:33.256]   - Field: ‘packages’
[09:31:33.256]   - Field: ‘gc’
[09:31:33.256]   - Field: ‘conditions’
[09:31:33.256]   - Field: ‘expr’
[09:31:33.256]   - Field: ‘uuid’
[09:31:33.256]   - Field: ‘seed’
[09:31:33.257]   - Field: ‘version’
[09:31:33.257]   - Field: ‘result’
[09:31:33.257]   - Field: ‘asynchronous’
[09:31:33.257]   - Field: ‘calls’
[09:31:33.257]   - Field: ‘globals’
[09:31:33.257]   - Field: ‘stdout’
[09:31:33.257]   - Field: ‘earlySignal’
[09:31:33.257]   - Field: ‘lazy’
[09:31:33.257]   - Field: ‘state’
[09:31:33.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.258] - Launch lazy future ...
[09:31:33.258] Packages needed by the future expression (n = 0): <none>
[09:31:33.258] Packages needed by future strategies (n = 0): <none>
[09:31:33.258] {
[09:31:33.258]     {
[09:31:33.258]         {
[09:31:33.258]             ...future.startTime <- base::Sys.time()
[09:31:33.258]             {
[09:31:33.258]                 {
[09:31:33.258]                   {
[09:31:33.258]                     base::local({
[09:31:33.258]                       has_future <- base::requireNamespace("future", 
[09:31:33.258]                         quietly = TRUE)
[09:31:33.258]                       if (has_future) {
[09:31:33.258]                         ns <- base::getNamespace("future")
[09:31:33.258]                         version <- ns[[".package"]][["version"]]
[09:31:33.258]                         if (is.null(version)) 
[09:31:33.258]                           version <- utils::packageVersion("future")
[09:31:33.258]                       }
[09:31:33.258]                       else {
[09:31:33.258]                         version <- NULL
[09:31:33.258]                       }
[09:31:33.258]                       if (!has_future || version < "1.8.0") {
[09:31:33.258]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.258]                           "", base::R.version$version.string), 
[09:31:33.258]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.258]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.258]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.258]                             "release", "version")], collapse = " "), 
[09:31:33.258]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.258]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.258]                           info)
[09:31:33.258]                         info <- base::paste(info, collapse = "; ")
[09:31:33.258]                         if (!has_future) {
[09:31:33.258]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.258]                             info)
[09:31:33.258]                         }
[09:31:33.258]                         else {
[09:31:33.258]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.258]                             info, version)
[09:31:33.258]                         }
[09:31:33.258]                         base::stop(msg)
[09:31:33.258]                       }
[09:31:33.258]                     })
[09:31:33.258]                   }
[09:31:33.258]                   ...future.strategy.old <- future::plan("list")
[09:31:33.258]                   options(future.plan = NULL)
[09:31:33.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.258]                 }
[09:31:33.258]                 ...future.workdir <- getwd()
[09:31:33.258]             }
[09:31:33.258]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.258]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.258]         }
[09:31:33.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.258]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.258]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.258]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.258]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.258]             base::names(...future.oldOptions))
[09:31:33.258]     }
[09:31:33.258]     if (FALSE) {
[09:31:33.258]     }
[09:31:33.258]     else {
[09:31:33.258]         if (TRUE) {
[09:31:33.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.258]                 open = "w")
[09:31:33.258]         }
[09:31:33.258]         else {
[09:31:33.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.258]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.258]         }
[09:31:33.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.258]             base::sink(type = "output", split = FALSE)
[09:31:33.258]             base::close(...future.stdout)
[09:31:33.258]         }, add = TRUE)
[09:31:33.258]     }
[09:31:33.258]     ...future.frame <- base::sys.nframe()
[09:31:33.258]     ...future.conditions <- base::list()
[09:31:33.258]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.258]     if (FALSE) {
[09:31:33.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.258]     }
[09:31:33.258]     ...future.result <- base::tryCatch({
[09:31:33.258]         base::withCallingHandlers({
[09:31:33.258]             ...future.value <- base::withVisible(base::local({
[09:31:33.258]                 b <- a * ii
[09:31:33.258]                 a <- 0
[09:31:33.258]                 b
[09:31:33.258]             }))
[09:31:33.258]             future::FutureResult(value = ...future.value$value, 
[09:31:33.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.258]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.258]                     ...future.globalenv.names))
[09:31:33.258]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.258]         }, condition = base::local({
[09:31:33.258]             c <- base::c
[09:31:33.258]             inherits <- base::inherits
[09:31:33.258]             invokeRestart <- base::invokeRestart
[09:31:33.258]             length <- base::length
[09:31:33.258]             list <- base::list
[09:31:33.258]             seq.int <- base::seq.int
[09:31:33.258]             signalCondition <- base::signalCondition
[09:31:33.258]             sys.calls <- base::sys.calls
[09:31:33.258]             `[[` <- base::`[[`
[09:31:33.258]             `+` <- base::`+`
[09:31:33.258]             `<<-` <- base::`<<-`
[09:31:33.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.258]                   3L)]
[09:31:33.258]             }
[09:31:33.258]             function(cond) {
[09:31:33.258]                 is_error <- inherits(cond, "error")
[09:31:33.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.258]                   NULL)
[09:31:33.258]                 if (is_error) {
[09:31:33.258]                   sessionInformation <- function() {
[09:31:33.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.258]                       search = base::search(), system = base::Sys.info())
[09:31:33.258]                   }
[09:31:33.258]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.258]                     cond$call), session = sessionInformation(), 
[09:31:33.258]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.258]                   signalCondition(cond)
[09:31:33.258]                 }
[09:31:33.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.258]                 "immediateCondition"))) {
[09:31:33.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.258]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.258]                   if (TRUE && !signal) {
[09:31:33.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.258]                     {
[09:31:33.258]                       inherits <- base::inherits
[09:31:33.258]                       invokeRestart <- base::invokeRestart
[09:31:33.258]                       is.null <- base::is.null
[09:31:33.258]                       muffled <- FALSE
[09:31:33.258]                       if (inherits(cond, "message")) {
[09:31:33.258]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.258]                         if (muffled) 
[09:31:33.258]                           invokeRestart("muffleMessage")
[09:31:33.258]                       }
[09:31:33.258]                       else if (inherits(cond, "warning")) {
[09:31:33.258]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.258]                         if (muffled) 
[09:31:33.258]                           invokeRestart("muffleWarning")
[09:31:33.258]                       }
[09:31:33.258]                       else if (inherits(cond, "condition")) {
[09:31:33.258]                         if (!is.null(pattern)) {
[09:31:33.258]                           computeRestarts <- base::computeRestarts
[09:31:33.258]                           grepl <- base::grepl
[09:31:33.258]                           restarts <- computeRestarts(cond)
[09:31:33.258]                           for (restart in restarts) {
[09:31:33.258]                             name <- restart$name
[09:31:33.258]                             if (is.null(name)) 
[09:31:33.258]                               next
[09:31:33.258]                             if (!grepl(pattern, name)) 
[09:31:33.258]                               next
[09:31:33.258]                             invokeRestart(restart)
[09:31:33.258]                             muffled <- TRUE
[09:31:33.258]                             break
[09:31:33.258]                           }
[09:31:33.258]                         }
[09:31:33.258]                       }
[09:31:33.258]                       invisible(muffled)
[09:31:33.258]                     }
[09:31:33.258]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.258]                   }
[09:31:33.258]                 }
[09:31:33.258]                 else {
[09:31:33.258]                   if (TRUE) {
[09:31:33.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.258]                     {
[09:31:33.258]                       inherits <- base::inherits
[09:31:33.258]                       invokeRestart <- base::invokeRestart
[09:31:33.258]                       is.null <- base::is.null
[09:31:33.258]                       muffled <- FALSE
[09:31:33.258]                       if (inherits(cond, "message")) {
[09:31:33.258]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.258]                         if (muffled) 
[09:31:33.258]                           invokeRestart("muffleMessage")
[09:31:33.258]                       }
[09:31:33.258]                       else if (inherits(cond, "warning")) {
[09:31:33.258]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.258]                         if (muffled) 
[09:31:33.258]                           invokeRestart("muffleWarning")
[09:31:33.258]                       }
[09:31:33.258]                       else if (inherits(cond, "condition")) {
[09:31:33.258]                         if (!is.null(pattern)) {
[09:31:33.258]                           computeRestarts <- base::computeRestarts
[09:31:33.258]                           grepl <- base::grepl
[09:31:33.258]                           restarts <- computeRestarts(cond)
[09:31:33.258]                           for (restart in restarts) {
[09:31:33.258]                             name <- restart$name
[09:31:33.258]                             if (is.null(name)) 
[09:31:33.258]                               next
[09:31:33.258]                             if (!grepl(pattern, name)) 
[09:31:33.258]                               next
[09:31:33.258]                             invokeRestart(restart)
[09:31:33.258]                             muffled <- TRUE
[09:31:33.258]                             break
[09:31:33.258]                           }
[09:31:33.258]                         }
[09:31:33.258]                       }
[09:31:33.258]                       invisible(muffled)
[09:31:33.258]                     }
[09:31:33.258]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.258]                   }
[09:31:33.258]                 }
[09:31:33.258]             }
[09:31:33.258]         }))
[09:31:33.258]     }, error = function(ex) {
[09:31:33.258]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.258]                 ...future.rng), started = ...future.startTime, 
[09:31:33.258]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.258]             version = "1.8"), class = "FutureResult")
[09:31:33.258]     }, finally = {
[09:31:33.258]         if (!identical(...future.workdir, getwd())) 
[09:31:33.258]             setwd(...future.workdir)
[09:31:33.258]         {
[09:31:33.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.258]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.258]             }
[09:31:33.258]             base::options(...future.oldOptions)
[09:31:33.258]             if (.Platform$OS.type == "windows") {
[09:31:33.258]                 old_names <- names(...future.oldEnvVars)
[09:31:33.258]                 envs <- base::Sys.getenv()
[09:31:33.258]                 names <- names(envs)
[09:31:33.258]                 common <- intersect(names, old_names)
[09:31:33.258]                 added <- setdiff(names, old_names)
[09:31:33.258]                 removed <- setdiff(old_names, names)
[09:31:33.258]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.258]                   envs[common]]
[09:31:33.258]                 NAMES <- toupper(changed)
[09:31:33.258]                 args <- list()
[09:31:33.258]                 for (kk in seq_along(NAMES)) {
[09:31:33.258]                   name <- changed[[kk]]
[09:31:33.258]                   NAME <- NAMES[[kk]]
[09:31:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.258]                     next
[09:31:33.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.258]                 }
[09:31:33.258]                 NAMES <- toupper(added)
[09:31:33.258]                 for (kk in seq_along(NAMES)) {
[09:31:33.258]                   name <- added[[kk]]
[09:31:33.258]                   NAME <- NAMES[[kk]]
[09:31:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.258]                     next
[09:31:33.258]                   args[[name]] <- ""
[09:31:33.258]                 }
[09:31:33.258]                 NAMES <- toupper(removed)
[09:31:33.258]                 for (kk in seq_along(NAMES)) {
[09:31:33.258]                   name <- removed[[kk]]
[09:31:33.258]                   NAME <- NAMES[[kk]]
[09:31:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.258]                     next
[09:31:33.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.258]                 }
[09:31:33.258]                 if (length(args) > 0) 
[09:31:33.258]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.258]             }
[09:31:33.258]             else {
[09:31:33.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.258]             }
[09:31:33.258]             {
[09:31:33.258]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.258]                   0L) {
[09:31:33.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.258]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.258]                   base::options(opts)
[09:31:33.258]                 }
[09:31:33.258]                 {
[09:31:33.258]                   {
[09:31:33.258]                     NULL
[09:31:33.258]                     RNGkind("Mersenne-Twister")
[09:31:33.258]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.258]                       inherits = FALSE)
[09:31:33.258]                   }
[09:31:33.258]                   options(future.plan = NULL)
[09:31:33.258]                   if (is.na(NA_character_)) 
[09:31:33.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.258]                     .init = FALSE)
[09:31:33.258]                 }
[09:31:33.258]             }
[09:31:33.258]         }
[09:31:33.258]     })
[09:31:33.258]     if (TRUE) {
[09:31:33.258]         base::sink(type = "output", split = FALSE)
[09:31:33.258]         if (TRUE) {
[09:31:33.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.258]         }
[09:31:33.258]         else {
[09:31:33.258]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.258]         }
[09:31:33.258]         base::close(...future.stdout)
[09:31:33.258]         ...future.stdout <- NULL
[09:31:33.258]     }
[09:31:33.258]     ...future.result$conditions <- ...future.conditions
[09:31:33.258]     ...future.result$finished <- base::Sys.time()
[09:31:33.258]     ...future.result
[09:31:33.258] }
[09:31:33.260] assign_globals() ...
[09:31:33.260] List of 2
[09:31:33.260]  $ a : num 1
[09:31:33.260]  $ ii: int 1
[09:31:33.260]  - attr(*, "where")=List of 2
[09:31:33.260]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.260]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.260]  - attr(*, "resolved")= logi TRUE
[09:31:33.260]  - attr(*, "total_size")= num 112
[09:31:33.260]  - attr(*, "already-done")= logi TRUE
[09:31:33.263] - copied ‘a’ to environment
[09:31:33.263] - copied ‘ii’ to environment
[09:31:33.263] assign_globals() ... done
[09:31:33.263] plan(): Setting new future strategy stack:
[09:31:33.263] List of future strategies:
[09:31:33.263] 1. sequential:
[09:31:33.263]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.263]    - tweaked: FALSE
[09:31:33.263]    - call: NULL
[09:31:33.263] plan(): nbrOfWorkers() = 1
[09:31:33.264] plan(): Setting new future strategy stack:
[09:31:33.264] List of future strategies:
[09:31:33.264] 1. sequential:
[09:31:33.264]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.264]    - tweaked: FALSE
[09:31:33.264]    - call: plan(strategy)
[09:31:33.265] plan(): nbrOfWorkers() = 1
[09:31:33.265] SequentialFuture started (and completed)
[09:31:33.265] - Launch lazy future ... done
[09:31:33.265] run() for ‘SequentialFuture’ ... done
[09:31:33.265] run() for ‘Future’ ...
[09:31:33.265] - state: ‘created’
[09:31:33.265] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.266] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.266]   - Field: ‘label’
[09:31:33.266]   - Field: ‘local’
[09:31:33.266]   - Field: ‘owner’
[09:31:33.266]   - Field: ‘envir’
[09:31:33.266]   - Field: ‘packages’
[09:31:33.266]   - Field: ‘gc’
[09:31:33.266]   - Field: ‘conditions’
[09:31:33.266]   - Field: ‘expr’
[09:31:33.267]   - Field: ‘uuid’
[09:31:33.267]   - Field: ‘seed’
[09:31:33.267]   - Field: ‘version’
[09:31:33.267]   - Field: ‘result’
[09:31:33.267]   - Field: ‘asynchronous’
[09:31:33.267]   - Field: ‘calls’
[09:31:33.267]   - Field: ‘globals’
[09:31:33.267]   - Field: ‘stdout’
[09:31:33.267]   - Field: ‘earlySignal’
[09:31:33.267]   - Field: ‘lazy’
[09:31:33.267]   - Field: ‘state’
[09:31:33.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.268] - Launch lazy future ...
[09:31:33.268] Packages needed by the future expression (n = 0): <none>
[09:31:33.268] Packages needed by future strategies (n = 0): <none>
[09:31:33.269] {
[09:31:33.269]     {
[09:31:33.269]         {
[09:31:33.269]             ...future.startTime <- base::Sys.time()
[09:31:33.269]             {
[09:31:33.269]                 {
[09:31:33.269]                   {
[09:31:33.269]                     base::local({
[09:31:33.269]                       has_future <- base::requireNamespace("future", 
[09:31:33.269]                         quietly = TRUE)
[09:31:33.269]                       if (has_future) {
[09:31:33.269]                         ns <- base::getNamespace("future")
[09:31:33.269]                         version <- ns[[".package"]][["version"]]
[09:31:33.269]                         if (is.null(version)) 
[09:31:33.269]                           version <- utils::packageVersion("future")
[09:31:33.269]                       }
[09:31:33.269]                       else {
[09:31:33.269]                         version <- NULL
[09:31:33.269]                       }
[09:31:33.269]                       if (!has_future || version < "1.8.0") {
[09:31:33.269]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.269]                           "", base::R.version$version.string), 
[09:31:33.269]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.269]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.269]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.269]                             "release", "version")], collapse = " "), 
[09:31:33.269]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.269]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.269]                           info)
[09:31:33.269]                         info <- base::paste(info, collapse = "; ")
[09:31:33.269]                         if (!has_future) {
[09:31:33.269]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.269]                             info)
[09:31:33.269]                         }
[09:31:33.269]                         else {
[09:31:33.269]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.269]                             info, version)
[09:31:33.269]                         }
[09:31:33.269]                         base::stop(msg)
[09:31:33.269]                       }
[09:31:33.269]                     })
[09:31:33.269]                   }
[09:31:33.269]                   ...future.strategy.old <- future::plan("list")
[09:31:33.269]                   options(future.plan = NULL)
[09:31:33.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.269]                 }
[09:31:33.269]                 ...future.workdir <- getwd()
[09:31:33.269]             }
[09:31:33.269]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.269]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.269]         }
[09:31:33.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.269]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.269]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.269]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.269]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.269]             base::names(...future.oldOptions))
[09:31:33.269]     }
[09:31:33.269]     if (FALSE) {
[09:31:33.269]     }
[09:31:33.269]     else {
[09:31:33.269]         if (TRUE) {
[09:31:33.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.269]                 open = "w")
[09:31:33.269]         }
[09:31:33.269]         else {
[09:31:33.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.269]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.269]         }
[09:31:33.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.269]             base::sink(type = "output", split = FALSE)
[09:31:33.269]             base::close(...future.stdout)
[09:31:33.269]         }, add = TRUE)
[09:31:33.269]     }
[09:31:33.269]     ...future.frame <- base::sys.nframe()
[09:31:33.269]     ...future.conditions <- base::list()
[09:31:33.269]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.269]     if (FALSE) {
[09:31:33.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.269]     }
[09:31:33.269]     ...future.result <- base::tryCatch({
[09:31:33.269]         base::withCallingHandlers({
[09:31:33.269]             ...future.value <- base::withVisible(base::local({
[09:31:33.269]                 b <- a * ii
[09:31:33.269]                 a <- 0
[09:31:33.269]                 b
[09:31:33.269]             }))
[09:31:33.269]             future::FutureResult(value = ...future.value$value, 
[09:31:33.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.269]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.269]                     ...future.globalenv.names))
[09:31:33.269]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.269]         }, condition = base::local({
[09:31:33.269]             c <- base::c
[09:31:33.269]             inherits <- base::inherits
[09:31:33.269]             invokeRestart <- base::invokeRestart
[09:31:33.269]             length <- base::length
[09:31:33.269]             list <- base::list
[09:31:33.269]             seq.int <- base::seq.int
[09:31:33.269]             signalCondition <- base::signalCondition
[09:31:33.269]             sys.calls <- base::sys.calls
[09:31:33.269]             `[[` <- base::`[[`
[09:31:33.269]             `+` <- base::`+`
[09:31:33.269]             `<<-` <- base::`<<-`
[09:31:33.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.269]                   3L)]
[09:31:33.269]             }
[09:31:33.269]             function(cond) {
[09:31:33.269]                 is_error <- inherits(cond, "error")
[09:31:33.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.269]                   NULL)
[09:31:33.269]                 if (is_error) {
[09:31:33.269]                   sessionInformation <- function() {
[09:31:33.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.269]                       search = base::search(), system = base::Sys.info())
[09:31:33.269]                   }
[09:31:33.269]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.269]                     cond$call), session = sessionInformation(), 
[09:31:33.269]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.269]                   signalCondition(cond)
[09:31:33.269]                 }
[09:31:33.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.269]                 "immediateCondition"))) {
[09:31:33.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.269]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.269]                   if (TRUE && !signal) {
[09:31:33.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.269]                     {
[09:31:33.269]                       inherits <- base::inherits
[09:31:33.269]                       invokeRestart <- base::invokeRestart
[09:31:33.269]                       is.null <- base::is.null
[09:31:33.269]                       muffled <- FALSE
[09:31:33.269]                       if (inherits(cond, "message")) {
[09:31:33.269]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.269]                         if (muffled) 
[09:31:33.269]                           invokeRestart("muffleMessage")
[09:31:33.269]                       }
[09:31:33.269]                       else if (inherits(cond, "warning")) {
[09:31:33.269]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.269]                         if (muffled) 
[09:31:33.269]                           invokeRestart("muffleWarning")
[09:31:33.269]                       }
[09:31:33.269]                       else if (inherits(cond, "condition")) {
[09:31:33.269]                         if (!is.null(pattern)) {
[09:31:33.269]                           computeRestarts <- base::computeRestarts
[09:31:33.269]                           grepl <- base::grepl
[09:31:33.269]                           restarts <- computeRestarts(cond)
[09:31:33.269]                           for (restart in restarts) {
[09:31:33.269]                             name <- restart$name
[09:31:33.269]                             if (is.null(name)) 
[09:31:33.269]                               next
[09:31:33.269]                             if (!grepl(pattern, name)) 
[09:31:33.269]                               next
[09:31:33.269]                             invokeRestart(restart)
[09:31:33.269]                             muffled <- TRUE
[09:31:33.269]                             break
[09:31:33.269]                           }
[09:31:33.269]                         }
[09:31:33.269]                       }
[09:31:33.269]                       invisible(muffled)
[09:31:33.269]                     }
[09:31:33.269]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.269]                   }
[09:31:33.269]                 }
[09:31:33.269]                 else {
[09:31:33.269]                   if (TRUE) {
[09:31:33.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.269]                     {
[09:31:33.269]                       inherits <- base::inherits
[09:31:33.269]                       invokeRestart <- base::invokeRestart
[09:31:33.269]                       is.null <- base::is.null
[09:31:33.269]                       muffled <- FALSE
[09:31:33.269]                       if (inherits(cond, "message")) {
[09:31:33.269]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.269]                         if (muffled) 
[09:31:33.269]                           invokeRestart("muffleMessage")
[09:31:33.269]                       }
[09:31:33.269]                       else if (inherits(cond, "warning")) {
[09:31:33.269]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.269]                         if (muffled) 
[09:31:33.269]                           invokeRestart("muffleWarning")
[09:31:33.269]                       }
[09:31:33.269]                       else if (inherits(cond, "condition")) {
[09:31:33.269]                         if (!is.null(pattern)) {
[09:31:33.269]                           computeRestarts <- base::computeRestarts
[09:31:33.269]                           grepl <- base::grepl
[09:31:33.269]                           restarts <- computeRestarts(cond)
[09:31:33.269]                           for (restart in restarts) {
[09:31:33.269]                             name <- restart$name
[09:31:33.269]                             if (is.null(name)) 
[09:31:33.269]                               next
[09:31:33.269]                             if (!grepl(pattern, name)) 
[09:31:33.269]                               next
[09:31:33.269]                             invokeRestart(restart)
[09:31:33.269]                             muffled <- TRUE
[09:31:33.269]                             break
[09:31:33.269]                           }
[09:31:33.269]                         }
[09:31:33.269]                       }
[09:31:33.269]                       invisible(muffled)
[09:31:33.269]                     }
[09:31:33.269]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.269]                   }
[09:31:33.269]                 }
[09:31:33.269]             }
[09:31:33.269]         }))
[09:31:33.269]     }, error = function(ex) {
[09:31:33.269]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.269]                 ...future.rng), started = ...future.startTime, 
[09:31:33.269]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.269]             version = "1.8"), class = "FutureResult")
[09:31:33.269]     }, finally = {
[09:31:33.269]         if (!identical(...future.workdir, getwd())) 
[09:31:33.269]             setwd(...future.workdir)
[09:31:33.269]         {
[09:31:33.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.269]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.269]             }
[09:31:33.269]             base::options(...future.oldOptions)
[09:31:33.269]             if (.Platform$OS.type == "windows") {
[09:31:33.269]                 old_names <- names(...future.oldEnvVars)
[09:31:33.269]                 envs <- base::Sys.getenv()
[09:31:33.269]                 names <- names(envs)
[09:31:33.269]                 common <- intersect(names, old_names)
[09:31:33.269]                 added <- setdiff(names, old_names)
[09:31:33.269]                 removed <- setdiff(old_names, names)
[09:31:33.269]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.269]                   envs[common]]
[09:31:33.269]                 NAMES <- toupper(changed)
[09:31:33.269]                 args <- list()
[09:31:33.269]                 for (kk in seq_along(NAMES)) {
[09:31:33.269]                   name <- changed[[kk]]
[09:31:33.269]                   NAME <- NAMES[[kk]]
[09:31:33.269]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.269]                     next
[09:31:33.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.269]                 }
[09:31:33.269]                 NAMES <- toupper(added)
[09:31:33.269]                 for (kk in seq_along(NAMES)) {
[09:31:33.269]                   name <- added[[kk]]
[09:31:33.269]                   NAME <- NAMES[[kk]]
[09:31:33.269]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.269]                     next
[09:31:33.269]                   args[[name]] <- ""
[09:31:33.269]                 }
[09:31:33.269]                 NAMES <- toupper(removed)
[09:31:33.269]                 for (kk in seq_along(NAMES)) {
[09:31:33.269]                   name <- removed[[kk]]
[09:31:33.269]                   NAME <- NAMES[[kk]]
[09:31:33.269]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.269]                     next
[09:31:33.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.269]                 }
[09:31:33.269]                 if (length(args) > 0) 
[09:31:33.269]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.269]             }
[09:31:33.269]             else {
[09:31:33.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.269]             }
[09:31:33.269]             {
[09:31:33.269]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.269]                   0L) {
[09:31:33.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.269]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.269]                   base::options(opts)
[09:31:33.269]                 }
[09:31:33.269]                 {
[09:31:33.269]                   {
[09:31:33.269]                     NULL
[09:31:33.269]                     RNGkind("Mersenne-Twister")
[09:31:33.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.269]                       inherits = FALSE)
[09:31:33.269]                   }
[09:31:33.269]                   options(future.plan = NULL)
[09:31:33.269]                   if (is.na(NA_character_)) 
[09:31:33.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.269]                     .init = FALSE)
[09:31:33.269]                 }
[09:31:33.269]             }
[09:31:33.269]         }
[09:31:33.269]     })
[09:31:33.269]     if (TRUE) {
[09:31:33.269]         base::sink(type = "output", split = FALSE)
[09:31:33.269]         if (TRUE) {
[09:31:33.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.269]         }
[09:31:33.269]         else {
[09:31:33.269]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.269]         }
[09:31:33.269]         base::close(...future.stdout)
[09:31:33.269]         ...future.stdout <- NULL
[09:31:33.269]     }
[09:31:33.269]     ...future.result$conditions <- ...future.conditions
[09:31:33.269]     ...future.result$finished <- base::Sys.time()
[09:31:33.269]     ...future.result
[09:31:33.269] }
[09:31:33.271] assign_globals() ...
[09:31:33.271] List of 2
[09:31:33.271]  $ a : num 1
[09:31:33.271]  $ ii: int 2
[09:31:33.271]  - attr(*, "where")=List of 2
[09:31:33.271]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.271]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.271]  - attr(*, "resolved")= logi TRUE
[09:31:33.271]  - attr(*, "total_size")= num 112
[09:31:33.271]  - attr(*, "already-done")= logi TRUE
[09:31:33.274] - copied ‘a’ to environment
[09:31:33.274] - copied ‘ii’ to environment
[09:31:33.274] assign_globals() ... done
[09:31:33.274] plan(): Setting new future strategy stack:
[09:31:33.274] List of future strategies:
[09:31:33.274] 1. sequential:
[09:31:33.274]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.274]    - tweaked: FALSE
[09:31:33.274]    - call: NULL
[09:31:33.274] plan(): nbrOfWorkers() = 1
[09:31:33.275] plan(): Setting new future strategy stack:
[09:31:33.275] List of future strategies:
[09:31:33.275] 1. sequential:
[09:31:33.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.275]    - tweaked: FALSE
[09:31:33.275]    - call: plan(strategy)
[09:31:33.276] plan(): nbrOfWorkers() = 1
[09:31:33.276] SequentialFuture started (and completed)
[09:31:33.276] - Launch lazy future ... done
[09:31:33.276] run() for ‘SequentialFuture’ ... done
[09:31:33.276] run() for ‘Future’ ...
[09:31:33.276] - state: ‘created’
[09:31:33.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.277]   - Field: ‘label’
[09:31:33.277]   - Field: ‘local’
[09:31:33.277]   - Field: ‘owner’
[09:31:33.277]   - Field: ‘envir’
[09:31:33.277]   - Field: ‘packages’
[09:31:33.277]   - Field: ‘gc’
[09:31:33.277]   - Field: ‘conditions’
[09:31:33.277]   - Field: ‘expr’
[09:31:33.277]   - Field: ‘uuid’
[09:31:33.278]   - Field: ‘seed’
[09:31:33.278]   - Field: ‘version’
[09:31:33.278]   - Field: ‘result’
[09:31:33.278]   - Field: ‘asynchronous’
[09:31:33.278]   - Field: ‘calls’
[09:31:33.278]   - Field: ‘globals’
[09:31:33.278]   - Field: ‘stdout’
[09:31:33.278]   - Field: ‘earlySignal’
[09:31:33.278]   - Field: ‘lazy’
[09:31:33.278]   - Field: ‘state’
[09:31:33.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.278] - Launch lazy future ...
[09:31:33.279] Packages needed by the future expression (n = 0): <none>
[09:31:33.279] Packages needed by future strategies (n = 0): <none>
[09:31:33.279] {
[09:31:33.279]     {
[09:31:33.279]         {
[09:31:33.279]             ...future.startTime <- base::Sys.time()
[09:31:33.279]             {
[09:31:33.279]                 {
[09:31:33.279]                   {
[09:31:33.279]                     base::local({
[09:31:33.279]                       has_future <- base::requireNamespace("future", 
[09:31:33.279]                         quietly = TRUE)
[09:31:33.279]                       if (has_future) {
[09:31:33.279]                         ns <- base::getNamespace("future")
[09:31:33.279]                         version <- ns[[".package"]][["version"]]
[09:31:33.279]                         if (is.null(version)) 
[09:31:33.279]                           version <- utils::packageVersion("future")
[09:31:33.279]                       }
[09:31:33.279]                       else {
[09:31:33.279]                         version <- NULL
[09:31:33.279]                       }
[09:31:33.279]                       if (!has_future || version < "1.8.0") {
[09:31:33.279]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.279]                           "", base::R.version$version.string), 
[09:31:33.279]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.279]                             "release", "version")], collapse = " "), 
[09:31:33.279]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.279]                           info)
[09:31:33.279]                         info <- base::paste(info, collapse = "; ")
[09:31:33.279]                         if (!has_future) {
[09:31:33.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.279]                             info)
[09:31:33.279]                         }
[09:31:33.279]                         else {
[09:31:33.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.279]                             info, version)
[09:31:33.279]                         }
[09:31:33.279]                         base::stop(msg)
[09:31:33.279]                       }
[09:31:33.279]                     })
[09:31:33.279]                   }
[09:31:33.279]                   ...future.strategy.old <- future::plan("list")
[09:31:33.279]                   options(future.plan = NULL)
[09:31:33.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.279]                 }
[09:31:33.279]                 ...future.workdir <- getwd()
[09:31:33.279]             }
[09:31:33.279]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.279]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.279]         }
[09:31:33.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.279]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.279]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.279]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.279]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.279]             base::names(...future.oldOptions))
[09:31:33.279]     }
[09:31:33.279]     if (FALSE) {
[09:31:33.279]     }
[09:31:33.279]     else {
[09:31:33.279]         if (TRUE) {
[09:31:33.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.279]                 open = "w")
[09:31:33.279]         }
[09:31:33.279]         else {
[09:31:33.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.279]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.279]         }
[09:31:33.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.279]             base::sink(type = "output", split = FALSE)
[09:31:33.279]             base::close(...future.stdout)
[09:31:33.279]         }, add = TRUE)
[09:31:33.279]     }
[09:31:33.279]     ...future.frame <- base::sys.nframe()
[09:31:33.279]     ...future.conditions <- base::list()
[09:31:33.279]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.279]     if (FALSE) {
[09:31:33.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.279]     }
[09:31:33.279]     ...future.result <- base::tryCatch({
[09:31:33.279]         base::withCallingHandlers({
[09:31:33.279]             ...future.value <- base::withVisible(base::local({
[09:31:33.279]                 b <- a * ii
[09:31:33.279]                 a <- 0
[09:31:33.279]                 b
[09:31:33.279]             }))
[09:31:33.279]             future::FutureResult(value = ...future.value$value, 
[09:31:33.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.279]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.279]                     ...future.globalenv.names))
[09:31:33.279]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.279]         }, condition = base::local({
[09:31:33.279]             c <- base::c
[09:31:33.279]             inherits <- base::inherits
[09:31:33.279]             invokeRestart <- base::invokeRestart
[09:31:33.279]             length <- base::length
[09:31:33.279]             list <- base::list
[09:31:33.279]             seq.int <- base::seq.int
[09:31:33.279]             signalCondition <- base::signalCondition
[09:31:33.279]             sys.calls <- base::sys.calls
[09:31:33.279]             `[[` <- base::`[[`
[09:31:33.279]             `+` <- base::`+`
[09:31:33.279]             `<<-` <- base::`<<-`
[09:31:33.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.279]                   3L)]
[09:31:33.279]             }
[09:31:33.279]             function(cond) {
[09:31:33.279]                 is_error <- inherits(cond, "error")
[09:31:33.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.279]                   NULL)
[09:31:33.279]                 if (is_error) {
[09:31:33.279]                   sessionInformation <- function() {
[09:31:33.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.279]                       search = base::search(), system = base::Sys.info())
[09:31:33.279]                   }
[09:31:33.279]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.279]                     cond$call), session = sessionInformation(), 
[09:31:33.279]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.279]                   signalCondition(cond)
[09:31:33.279]                 }
[09:31:33.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.279]                 "immediateCondition"))) {
[09:31:33.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.279]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.279]                   if (TRUE && !signal) {
[09:31:33.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.279]                     {
[09:31:33.279]                       inherits <- base::inherits
[09:31:33.279]                       invokeRestart <- base::invokeRestart
[09:31:33.279]                       is.null <- base::is.null
[09:31:33.279]                       muffled <- FALSE
[09:31:33.279]                       if (inherits(cond, "message")) {
[09:31:33.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.279]                         if (muffled) 
[09:31:33.279]                           invokeRestart("muffleMessage")
[09:31:33.279]                       }
[09:31:33.279]                       else if (inherits(cond, "warning")) {
[09:31:33.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.279]                         if (muffled) 
[09:31:33.279]                           invokeRestart("muffleWarning")
[09:31:33.279]                       }
[09:31:33.279]                       else if (inherits(cond, "condition")) {
[09:31:33.279]                         if (!is.null(pattern)) {
[09:31:33.279]                           computeRestarts <- base::computeRestarts
[09:31:33.279]                           grepl <- base::grepl
[09:31:33.279]                           restarts <- computeRestarts(cond)
[09:31:33.279]                           for (restart in restarts) {
[09:31:33.279]                             name <- restart$name
[09:31:33.279]                             if (is.null(name)) 
[09:31:33.279]                               next
[09:31:33.279]                             if (!grepl(pattern, name)) 
[09:31:33.279]                               next
[09:31:33.279]                             invokeRestart(restart)
[09:31:33.279]                             muffled <- TRUE
[09:31:33.279]                             break
[09:31:33.279]                           }
[09:31:33.279]                         }
[09:31:33.279]                       }
[09:31:33.279]                       invisible(muffled)
[09:31:33.279]                     }
[09:31:33.279]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.279]                   }
[09:31:33.279]                 }
[09:31:33.279]                 else {
[09:31:33.279]                   if (TRUE) {
[09:31:33.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.279]                     {
[09:31:33.279]                       inherits <- base::inherits
[09:31:33.279]                       invokeRestart <- base::invokeRestart
[09:31:33.279]                       is.null <- base::is.null
[09:31:33.279]                       muffled <- FALSE
[09:31:33.279]                       if (inherits(cond, "message")) {
[09:31:33.279]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.279]                         if (muffled) 
[09:31:33.279]                           invokeRestart("muffleMessage")
[09:31:33.279]                       }
[09:31:33.279]                       else if (inherits(cond, "warning")) {
[09:31:33.279]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.279]                         if (muffled) 
[09:31:33.279]                           invokeRestart("muffleWarning")
[09:31:33.279]                       }
[09:31:33.279]                       else if (inherits(cond, "condition")) {
[09:31:33.279]                         if (!is.null(pattern)) {
[09:31:33.279]                           computeRestarts <- base::computeRestarts
[09:31:33.279]                           grepl <- base::grepl
[09:31:33.279]                           restarts <- computeRestarts(cond)
[09:31:33.279]                           for (restart in restarts) {
[09:31:33.279]                             name <- restart$name
[09:31:33.279]                             if (is.null(name)) 
[09:31:33.279]                               next
[09:31:33.279]                             if (!grepl(pattern, name)) 
[09:31:33.279]                               next
[09:31:33.279]                             invokeRestart(restart)
[09:31:33.279]                             muffled <- TRUE
[09:31:33.279]                             break
[09:31:33.279]                           }
[09:31:33.279]                         }
[09:31:33.279]                       }
[09:31:33.279]                       invisible(muffled)
[09:31:33.279]                     }
[09:31:33.279]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.279]                   }
[09:31:33.279]                 }
[09:31:33.279]             }
[09:31:33.279]         }))
[09:31:33.279]     }, error = function(ex) {
[09:31:33.279]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.279]                 ...future.rng), started = ...future.startTime, 
[09:31:33.279]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.279]             version = "1.8"), class = "FutureResult")
[09:31:33.279]     }, finally = {
[09:31:33.279]         if (!identical(...future.workdir, getwd())) 
[09:31:33.279]             setwd(...future.workdir)
[09:31:33.279]         {
[09:31:33.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.279]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.279]             }
[09:31:33.279]             base::options(...future.oldOptions)
[09:31:33.279]             if (.Platform$OS.type == "windows") {
[09:31:33.279]                 old_names <- names(...future.oldEnvVars)
[09:31:33.279]                 envs <- base::Sys.getenv()
[09:31:33.279]                 names <- names(envs)
[09:31:33.279]                 common <- intersect(names, old_names)
[09:31:33.279]                 added <- setdiff(names, old_names)
[09:31:33.279]                 removed <- setdiff(old_names, names)
[09:31:33.279]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.279]                   envs[common]]
[09:31:33.279]                 NAMES <- toupper(changed)
[09:31:33.279]                 args <- list()
[09:31:33.279]                 for (kk in seq_along(NAMES)) {
[09:31:33.279]                   name <- changed[[kk]]
[09:31:33.279]                   NAME <- NAMES[[kk]]
[09:31:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.279]                     next
[09:31:33.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.279]                 }
[09:31:33.279]                 NAMES <- toupper(added)
[09:31:33.279]                 for (kk in seq_along(NAMES)) {
[09:31:33.279]                   name <- added[[kk]]
[09:31:33.279]                   NAME <- NAMES[[kk]]
[09:31:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.279]                     next
[09:31:33.279]                   args[[name]] <- ""
[09:31:33.279]                 }
[09:31:33.279]                 NAMES <- toupper(removed)
[09:31:33.279]                 for (kk in seq_along(NAMES)) {
[09:31:33.279]                   name <- removed[[kk]]
[09:31:33.279]                   NAME <- NAMES[[kk]]
[09:31:33.279]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.279]                     next
[09:31:33.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.279]                 }
[09:31:33.279]                 if (length(args) > 0) 
[09:31:33.279]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.279]             }
[09:31:33.279]             else {
[09:31:33.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.279]             }
[09:31:33.279]             {
[09:31:33.279]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.279]                   0L) {
[09:31:33.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.279]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.279]                   base::options(opts)
[09:31:33.279]                 }
[09:31:33.279]                 {
[09:31:33.279]                   {
[09:31:33.279]                     NULL
[09:31:33.279]                     RNGkind("Mersenne-Twister")
[09:31:33.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.279]                       inherits = FALSE)
[09:31:33.279]                   }
[09:31:33.279]                   options(future.plan = NULL)
[09:31:33.279]                   if (is.na(NA_character_)) 
[09:31:33.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.279]                     .init = FALSE)
[09:31:33.279]                 }
[09:31:33.279]             }
[09:31:33.279]         }
[09:31:33.279]     })
[09:31:33.279]     if (TRUE) {
[09:31:33.279]         base::sink(type = "output", split = FALSE)
[09:31:33.279]         if (TRUE) {
[09:31:33.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.279]         }
[09:31:33.279]         else {
[09:31:33.279]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.279]         }
[09:31:33.279]         base::close(...future.stdout)
[09:31:33.279]         ...future.stdout <- NULL
[09:31:33.279]     }
[09:31:33.279]     ...future.result$conditions <- ...future.conditions
[09:31:33.279]     ...future.result$finished <- base::Sys.time()
[09:31:33.279]     ...future.result
[09:31:33.279] }
[09:31:33.281] assign_globals() ...
[09:31:33.281] List of 2
[09:31:33.281]  $ a : num 1
[09:31:33.281]  $ ii: int 3
[09:31:33.281]  - attr(*, "where")=List of 2
[09:31:33.281]   ..$ a :<environment: R_EmptyEnv> 
[09:31:33.281]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.281]  - attr(*, "resolved")= logi TRUE
[09:31:33.281]  - attr(*, "total_size")= num 112
[09:31:33.281]  - attr(*, "already-done")= logi TRUE
[09:31:33.283] - copied ‘a’ to environment
[09:31:33.284] - copied ‘ii’ to environment
[09:31:33.284] assign_globals() ... done
[09:31:33.284] plan(): Setting new future strategy stack:
[09:31:33.284] List of future strategies:
[09:31:33.284] 1. sequential:
[09:31:33.284]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.284]    - tweaked: FALSE
[09:31:33.284]    - call: NULL
[09:31:33.284] plan(): nbrOfWorkers() = 1
[09:31:33.285] plan(): Setting new future strategy stack:
[09:31:33.285] List of future strategies:
[09:31:33.285] 1. sequential:
[09:31:33.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.285]    - tweaked: FALSE
[09:31:33.285]    - call: plan(strategy)
[09:31:33.285] plan(): nbrOfWorkers() = 1
[09:31:33.286] SequentialFuture started (and completed)
[09:31:33.286] - Launch lazy future ... done
[09:31:33.286] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.286] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.286] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.287] 
[09:31:33.287] Searching for globals ... DONE
[09:31:33.287] - globals: [0] <none>
[09:31:33.287] getGlobalsAndPackages() ... DONE
[09:31:33.287] run() for ‘Future’ ...
[09:31:33.287] - state: ‘created’
[09:31:33.287] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.288] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.288] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.288]   - Field: ‘label’
[09:31:33.288]   - Field: ‘local’
[09:31:33.288]   - Field: ‘owner’
[09:31:33.288]   - Field: ‘envir’
[09:31:33.288]   - Field: ‘packages’
[09:31:33.288]   - Field: ‘gc’
[09:31:33.288]   - Field: ‘conditions’
[09:31:33.288]   - Field: ‘expr’
[09:31:33.289]   - Field: ‘uuid’
[09:31:33.289]   - Field: ‘seed’
[09:31:33.289]   - Field: ‘version’
[09:31:33.289]   - Field: ‘result’
[09:31:33.289]   - Field: ‘asynchronous’
[09:31:33.289]   - Field: ‘calls’
[09:31:33.289]   - Field: ‘globals’
[09:31:33.289]   - Field: ‘stdout’
[09:31:33.289]   - Field: ‘earlySignal’
[09:31:33.289]   - Field: ‘lazy’
[09:31:33.289]   - Field: ‘state’
[09:31:33.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.290] - Launch lazy future ...
[09:31:33.290] Packages needed by the future expression (n = 0): <none>
[09:31:33.290] Packages needed by future strategies (n = 0): <none>
[09:31:33.290] {
[09:31:33.290]     {
[09:31:33.290]         {
[09:31:33.290]             ...future.startTime <- base::Sys.time()
[09:31:33.290]             {
[09:31:33.290]                 {
[09:31:33.290]                   {
[09:31:33.290]                     base::local({
[09:31:33.290]                       has_future <- base::requireNamespace("future", 
[09:31:33.290]                         quietly = TRUE)
[09:31:33.290]                       if (has_future) {
[09:31:33.290]                         ns <- base::getNamespace("future")
[09:31:33.290]                         version <- ns[[".package"]][["version"]]
[09:31:33.290]                         if (is.null(version)) 
[09:31:33.290]                           version <- utils::packageVersion("future")
[09:31:33.290]                       }
[09:31:33.290]                       else {
[09:31:33.290]                         version <- NULL
[09:31:33.290]                       }
[09:31:33.290]                       if (!has_future || version < "1.8.0") {
[09:31:33.290]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.290]                           "", base::R.version$version.string), 
[09:31:33.290]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.290]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.290]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.290]                             "release", "version")], collapse = " "), 
[09:31:33.290]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.290]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.290]                           info)
[09:31:33.290]                         info <- base::paste(info, collapse = "; ")
[09:31:33.290]                         if (!has_future) {
[09:31:33.290]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.290]                             info)
[09:31:33.290]                         }
[09:31:33.290]                         else {
[09:31:33.290]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.290]                             info, version)
[09:31:33.290]                         }
[09:31:33.290]                         base::stop(msg)
[09:31:33.290]                       }
[09:31:33.290]                     })
[09:31:33.290]                   }
[09:31:33.290]                   ...future.strategy.old <- future::plan("list")
[09:31:33.290]                   options(future.plan = NULL)
[09:31:33.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.290]                 }
[09:31:33.290]                 ...future.workdir <- getwd()
[09:31:33.290]             }
[09:31:33.290]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.290]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.290]         }
[09:31:33.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.290]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.290]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.290]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.290]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.290]             base::names(...future.oldOptions))
[09:31:33.290]     }
[09:31:33.290]     if (FALSE) {
[09:31:33.290]     }
[09:31:33.290]     else {
[09:31:33.290]         if (TRUE) {
[09:31:33.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.290]                 open = "w")
[09:31:33.290]         }
[09:31:33.290]         else {
[09:31:33.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.290]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.290]         }
[09:31:33.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.290]             base::sink(type = "output", split = FALSE)
[09:31:33.290]             base::close(...future.stdout)
[09:31:33.290]         }, add = TRUE)
[09:31:33.290]     }
[09:31:33.290]     ...future.frame <- base::sys.nframe()
[09:31:33.290]     ...future.conditions <- base::list()
[09:31:33.290]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.290]     if (FALSE) {
[09:31:33.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.290]     }
[09:31:33.290]     ...future.result <- base::tryCatch({
[09:31:33.290]         base::withCallingHandlers({
[09:31:33.290]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.290]             future::FutureResult(value = ...future.value$value, 
[09:31:33.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.290]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.290]                     ...future.globalenv.names))
[09:31:33.290]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.290]         }, condition = base::local({
[09:31:33.290]             c <- base::c
[09:31:33.290]             inherits <- base::inherits
[09:31:33.290]             invokeRestart <- base::invokeRestart
[09:31:33.290]             length <- base::length
[09:31:33.290]             list <- base::list
[09:31:33.290]             seq.int <- base::seq.int
[09:31:33.290]             signalCondition <- base::signalCondition
[09:31:33.290]             sys.calls <- base::sys.calls
[09:31:33.290]             `[[` <- base::`[[`
[09:31:33.290]             `+` <- base::`+`
[09:31:33.290]             `<<-` <- base::`<<-`
[09:31:33.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.290]                   3L)]
[09:31:33.290]             }
[09:31:33.290]             function(cond) {
[09:31:33.290]                 is_error <- inherits(cond, "error")
[09:31:33.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.290]                   NULL)
[09:31:33.290]                 if (is_error) {
[09:31:33.290]                   sessionInformation <- function() {
[09:31:33.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.290]                       search = base::search(), system = base::Sys.info())
[09:31:33.290]                   }
[09:31:33.290]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.290]                     cond$call), session = sessionInformation(), 
[09:31:33.290]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.290]                   signalCondition(cond)
[09:31:33.290]                 }
[09:31:33.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.290]                 "immediateCondition"))) {
[09:31:33.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.290]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.290]                   if (TRUE && !signal) {
[09:31:33.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.290]                     {
[09:31:33.290]                       inherits <- base::inherits
[09:31:33.290]                       invokeRestart <- base::invokeRestart
[09:31:33.290]                       is.null <- base::is.null
[09:31:33.290]                       muffled <- FALSE
[09:31:33.290]                       if (inherits(cond, "message")) {
[09:31:33.290]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.290]                         if (muffled) 
[09:31:33.290]                           invokeRestart("muffleMessage")
[09:31:33.290]                       }
[09:31:33.290]                       else if (inherits(cond, "warning")) {
[09:31:33.290]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.290]                         if (muffled) 
[09:31:33.290]                           invokeRestart("muffleWarning")
[09:31:33.290]                       }
[09:31:33.290]                       else if (inherits(cond, "condition")) {
[09:31:33.290]                         if (!is.null(pattern)) {
[09:31:33.290]                           computeRestarts <- base::computeRestarts
[09:31:33.290]                           grepl <- base::grepl
[09:31:33.290]                           restarts <- computeRestarts(cond)
[09:31:33.290]                           for (restart in restarts) {
[09:31:33.290]                             name <- restart$name
[09:31:33.290]                             if (is.null(name)) 
[09:31:33.290]                               next
[09:31:33.290]                             if (!grepl(pattern, name)) 
[09:31:33.290]                               next
[09:31:33.290]                             invokeRestart(restart)
[09:31:33.290]                             muffled <- TRUE
[09:31:33.290]                             break
[09:31:33.290]                           }
[09:31:33.290]                         }
[09:31:33.290]                       }
[09:31:33.290]                       invisible(muffled)
[09:31:33.290]                     }
[09:31:33.290]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.290]                   }
[09:31:33.290]                 }
[09:31:33.290]                 else {
[09:31:33.290]                   if (TRUE) {
[09:31:33.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.290]                     {
[09:31:33.290]                       inherits <- base::inherits
[09:31:33.290]                       invokeRestart <- base::invokeRestart
[09:31:33.290]                       is.null <- base::is.null
[09:31:33.290]                       muffled <- FALSE
[09:31:33.290]                       if (inherits(cond, "message")) {
[09:31:33.290]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.290]                         if (muffled) 
[09:31:33.290]                           invokeRestart("muffleMessage")
[09:31:33.290]                       }
[09:31:33.290]                       else if (inherits(cond, "warning")) {
[09:31:33.290]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.290]                         if (muffled) 
[09:31:33.290]                           invokeRestart("muffleWarning")
[09:31:33.290]                       }
[09:31:33.290]                       else if (inherits(cond, "condition")) {
[09:31:33.290]                         if (!is.null(pattern)) {
[09:31:33.290]                           computeRestarts <- base::computeRestarts
[09:31:33.290]                           grepl <- base::grepl
[09:31:33.290]                           restarts <- computeRestarts(cond)
[09:31:33.290]                           for (restart in restarts) {
[09:31:33.290]                             name <- restart$name
[09:31:33.290]                             if (is.null(name)) 
[09:31:33.290]                               next
[09:31:33.290]                             if (!grepl(pattern, name)) 
[09:31:33.290]                               next
[09:31:33.290]                             invokeRestart(restart)
[09:31:33.290]                             muffled <- TRUE
[09:31:33.290]                             break
[09:31:33.290]                           }
[09:31:33.290]                         }
[09:31:33.290]                       }
[09:31:33.290]                       invisible(muffled)
[09:31:33.290]                     }
[09:31:33.290]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.290]                   }
[09:31:33.290]                 }
[09:31:33.290]             }
[09:31:33.290]         }))
[09:31:33.290]     }, error = function(ex) {
[09:31:33.290]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.290]                 ...future.rng), started = ...future.startTime, 
[09:31:33.290]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.290]             version = "1.8"), class = "FutureResult")
[09:31:33.290]     }, finally = {
[09:31:33.290]         if (!identical(...future.workdir, getwd())) 
[09:31:33.290]             setwd(...future.workdir)
[09:31:33.290]         {
[09:31:33.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.290]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.290]             }
[09:31:33.290]             base::options(...future.oldOptions)
[09:31:33.290]             if (.Platform$OS.type == "windows") {
[09:31:33.290]                 old_names <- names(...future.oldEnvVars)
[09:31:33.290]                 envs <- base::Sys.getenv()
[09:31:33.290]                 names <- names(envs)
[09:31:33.290]                 common <- intersect(names, old_names)
[09:31:33.290]                 added <- setdiff(names, old_names)
[09:31:33.290]                 removed <- setdiff(old_names, names)
[09:31:33.290]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.290]                   envs[common]]
[09:31:33.290]                 NAMES <- toupper(changed)
[09:31:33.290]                 args <- list()
[09:31:33.290]                 for (kk in seq_along(NAMES)) {
[09:31:33.290]                   name <- changed[[kk]]
[09:31:33.290]                   NAME <- NAMES[[kk]]
[09:31:33.290]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.290]                     next
[09:31:33.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.290]                 }
[09:31:33.290]                 NAMES <- toupper(added)
[09:31:33.290]                 for (kk in seq_along(NAMES)) {
[09:31:33.290]                   name <- added[[kk]]
[09:31:33.290]                   NAME <- NAMES[[kk]]
[09:31:33.290]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.290]                     next
[09:31:33.290]                   args[[name]] <- ""
[09:31:33.290]                 }
[09:31:33.290]                 NAMES <- toupper(removed)
[09:31:33.290]                 for (kk in seq_along(NAMES)) {
[09:31:33.290]                   name <- removed[[kk]]
[09:31:33.290]                   NAME <- NAMES[[kk]]
[09:31:33.290]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.290]                     next
[09:31:33.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.290]                 }
[09:31:33.290]                 if (length(args) > 0) 
[09:31:33.290]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.290]             }
[09:31:33.290]             else {
[09:31:33.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.290]             }
[09:31:33.290]             {
[09:31:33.290]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.290]                   0L) {
[09:31:33.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.290]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.290]                   base::options(opts)
[09:31:33.290]                 }
[09:31:33.290]                 {
[09:31:33.290]                   {
[09:31:33.290]                     NULL
[09:31:33.290]                     RNGkind("Mersenne-Twister")
[09:31:33.290]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.290]                       inherits = FALSE)
[09:31:33.290]                   }
[09:31:33.290]                   options(future.plan = NULL)
[09:31:33.290]                   if (is.na(NA_character_)) 
[09:31:33.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.290]                     .init = FALSE)
[09:31:33.290]                 }
[09:31:33.290]             }
[09:31:33.290]         }
[09:31:33.290]     })
[09:31:33.290]     if (TRUE) {
[09:31:33.290]         base::sink(type = "output", split = FALSE)
[09:31:33.290]         if (TRUE) {
[09:31:33.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.290]         }
[09:31:33.290]         else {
[09:31:33.290]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.290]         }
[09:31:33.290]         base::close(...future.stdout)
[09:31:33.290]         ...future.stdout <- NULL
[09:31:33.290]     }
[09:31:33.290]     ...future.result$conditions <- ...future.conditions
[09:31:33.290]     ...future.result$finished <- base::Sys.time()
[09:31:33.290]     ...future.result
[09:31:33.290] }
[09:31:33.292] plan(): Setting new future strategy stack:
[09:31:33.292] List of future strategies:
[09:31:33.292] 1. sequential:
[09:31:33.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.292]    - tweaked: FALSE
[09:31:33.292]    - call: NULL
[09:31:33.292] plan(): nbrOfWorkers() = 1
[09:31:33.293] plan(): Setting new future strategy stack:
[09:31:33.293] List of future strategies:
[09:31:33.293] 1. sequential:
[09:31:33.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.293]    - tweaked: FALSE
[09:31:33.293]    - call: plan(strategy)
[09:31:33.294] plan(): nbrOfWorkers() = 1
[09:31:33.294] SequentialFuture started (and completed)
[09:31:33.294] - Launch lazy future ... done
[09:31:33.294] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.294] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.294] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.296] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.296] Searching for globals ... DONE
[09:31:33.296] Resolving globals: TRUE
[09:31:33.296] Resolving any globals that are futures ...
[09:31:33.297] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.297] Resolving any globals that are futures ... DONE
[09:31:33.297] Resolving futures part of globals (recursively) ...
[09:31:33.297] resolve() on list ...
[09:31:33.297]  recursive: 99
[09:31:33.297]  length: 1
[09:31:33.297]  elements: ‘a’
[09:31:33.297] resolved() for ‘SequentialFuture’ ...
[09:31:33.298] - state: ‘finished’
[09:31:33.298] - run: TRUE
[09:31:33.298] - result: ‘FutureResult’
[09:31:33.298] resolved() for ‘SequentialFuture’ ... done
[09:31:33.298] Future #1
[09:31:33.298] resolved() for ‘SequentialFuture’ ...
[09:31:33.298] - state: ‘finished’
[09:31:33.298] - run: TRUE
[09:31:33.298] - result: ‘FutureResult’
[09:31:33.298] resolved() for ‘SequentialFuture’ ... done
[09:31:33.298] A SequentialFuture was resolved
[09:31:33.299]  length: 0 (resolved future 1)
[09:31:33.299] resolve() on list ... DONE
[09:31:33.299] - globals: [1] ‘a’
[09:31:33.299] Resolving futures part of globals (recursively) ... DONE
[09:31:33.300] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[09:31:33.301] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[09:31:33.301] - globals: [1] ‘a’
[09:31:33.301] - packages: [1] ‘future’
[09:31:33.301] getGlobalsAndPackages() ... DONE
[09:31:33.301] run() for ‘Future’ ...
[09:31:33.301] - state: ‘created’
[09:31:33.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.302]   - Field: ‘label’
[09:31:33.302]   - Field: ‘local’
[09:31:33.302]   - Field: ‘owner’
[09:31:33.302]   - Field: ‘envir’
[09:31:33.302]   - Field: ‘packages’
[09:31:33.302]   - Field: ‘gc’
[09:31:33.302]   - Field: ‘conditions’
[09:31:33.303]   - Field: ‘expr’
[09:31:33.303]   - Field: ‘uuid’
[09:31:33.303]   - Field: ‘seed’
[09:31:33.303]   - Field: ‘version’
[09:31:33.303]   - Field: ‘result’
[09:31:33.303]   - Field: ‘asynchronous’
[09:31:33.303]   - Field: ‘calls’
[09:31:33.303]   - Field: ‘globals’
[09:31:33.303]   - Field: ‘stdout’
[09:31:33.303]   - Field: ‘earlySignal’
[09:31:33.303]   - Field: ‘lazy’
[09:31:33.303]   - Field: ‘state’
[09:31:33.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.304] - Launch lazy future ...
[09:31:33.304] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.304] Packages needed by future strategies (n = 0): <none>
[09:31:33.304] {
[09:31:33.304]     {
[09:31:33.304]         {
[09:31:33.304]             ...future.startTime <- base::Sys.time()
[09:31:33.304]             {
[09:31:33.304]                 {
[09:31:33.304]                   {
[09:31:33.304]                     {
[09:31:33.304]                       base::local({
[09:31:33.304]                         has_future <- base::requireNamespace("future", 
[09:31:33.304]                           quietly = TRUE)
[09:31:33.304]                         if (has_future) {
[09:31:33.304]                           ns <- base::getNamespace("future")
[09:31:33.304]                           version <- ns[[".package"]][["version"]]
[09:31:33.304]                           if (is.null(version)) 
[09:31:33.304]                             version <- utils::packageVersion("future")
[09:31:33.304]                         }
[09:31:33.304]                         else {
[09:31:33.304]                           version <- NULL
[09:31:33.304]                         }
[09:31:33.304]                         if (!has_future || version < "1.8.0") {
[09:31:33.304]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.304]                             "", base::R.version$version.string), 
[09:31:33.304]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.304]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.304]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.304]                               "release", "version")], collapse = " "), 
[09:31:33.304]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.304]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.304]                             info)
[09:31:33.304]                           info <- base::paste(info, collapse = "; ")
[09:31:33.304]                           if (!has_future) {
[09:31:33.304]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.304]                               info)
[09:31:33.304]                           }
[09:31:33.304]                           else {
[09:31:33.304]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.304]                               info, version)
[09:31:33.304]                           }
[09:31:33.304]                           base::stop(msg)
[09:31:33.304]                         }
[09:31:33.304]                       })
[09:31:33.304]                     }
[09:31:33.304]                     base::local({
[09:31:33.304]                       for (pkg in "future") {
[09:31:33.304]                         base::loadNamespace(pkg)
[09:31:33.304]                         base::library(pkg, character.only = TRUE)
[09:31:33.304]                       }
[09:31:33.304]                     })
[09:31:33.304]                   }
[09:31:33.304]                   ...future.strategy.old <- future::plan("list")
[09:31:33.304]                   options(future.plan = NULL)
[09:31:33.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.304]                 }
[09:31:33.304]                 ...future.workdir <- getwd()
[09:31:33.304]             }
[09:31:33.304]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.304]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.304]         }
[09:31:33.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.304]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.304]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.304]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.304]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.304]             base::names(...future.oldOptions))
[09:31:33.304]     }
[09:31:33.304]     if (FALSE) {
[09:31:33.304]     }
[09:31:33.304]     else {
[09:31:33.304]         if (TRUE) {
[09:31:33.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.304]                 open = "w")
[09:31:33.304]         }
[09:31:33.304]         else {
[09:31:33.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.304]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.304]         }
[09:31:33.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.304]             base::sink(type = "output", split = FALSE)
[09:31:33.304]             base::close(...future.stdout)
[09:31:33.304]         }, add = TRUE)
[09:31:33.304]     }
[09:31:33.304]     ...future.frame <- base::sys.nframe()
[09:31:33.304]     ...future.conditions <- base::list()
[09:31:33.304]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.304]     if (FALSE) {
[09:31:33.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.304]     }
[09:31:33.304]     ...future.result <- base::tryCatch({
[09:31:33.304]         base::withCallingHandlers({
[09:31:33.304]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.304]                 1))
[09:31:33.304]             future::FutureResult(value = ...future.value$value, 
[09:31:33.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.304]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.304]                     ...future.globalenv.names))
[09:31:33.304]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.304]         }, condition = base::local({
[09:31:33.304]             c <- base::c
[09:31:33.304]             inherits <- base::inherits
[09:31:33.304]             invokeRestart <- base::invokeRestart
[09:31:33.304]             length <- base::length
[09:31:33.304]             list <- base::list
[09:31:33.304]             seq.int <- base::seq.int
[09:31:33.304]             signalCondition <- base::signalCondition
[09:31:33.304]             sys.calls <- base::sys.calls
[09:31:33.304]             `[[` <- base::`[[`
[09:31:33.304]             `+` <- base::`+`
[09:31:33.304]             `<<-` <- base::`<<-`
[09:31:33.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.304]                   3L)]
[09:31:33.304]             }
[09:31:33.304]             function(cond) {
[09:31:33.304]                 is_error <- inherits(cond, "error")
[09:31:33.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.304]                   NULL)
[09:31:33.304]                 if (is_error) {
[09:31:33.304]                   sessionInformation <- function() {
[09:31:33.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.304]                       search = base::search(), system = base::Sys.info())
[09:31:33.304]                   }
[09:31:33.304]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.304]                     cond$call), session = sessionInformation(), 
[09:31:33.304]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.304]                   signalCondition(cond)
[09:31:33.304]                 }
[09:31:33.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.304]                 "immediateCondition"))) {
[09:31:33.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.304]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.304]                   if (TRUE && !signal) {
[09:31:33.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.304]                     {
[09:31:33.304]                       inherits <- base::inherits
[09:31:33.304]                       invokeRestart <- base::invokeRestart
[09:31:33.304]                       is.null <- base::is.null
[09:31:33.304]                       muffled <- FALSE
[09:31:33.304]                       if (inherits(cond, "message")) {
[09:31:33.304]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.304]                         if (muffled) 
[09:31:33.304]                           invokeRestart("muffleMessage")
[09:31:33.304]                       }
[09:31:33.304]                       else if (inherits(cond, "warning")) {
[09:31:33.304]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.304]                         if (muffled) 
[09:31:33.304]                           invokeRestart("muffleWarning")
[09:31:33.304]                       }
[09:31:33.304]                       else if (inherits(cond, "condition")) {
[09:31:33.304]                         if (!is.null(pattern)) {
[09:31:33.304]                           computeRestarts <- base::computeRestarts
[09:31:33.304]                           grepl <- base::grepl
[09:31:33.304]                           restarts <- computeRestarts(cond)
[09:31:33.304]                           for (restart in restarts) {
[09:31:33.304]                             name <- restart$name
[09:31:33.304]                             if (is.null(name)) 
[09:31:33.304]                               next
[09:31:33.304]                             if (!grepl(pattern, name)) 
[09:31:33.304]                               next
[09:31:33.304]                             invokeRestart(restart)
[09:31:33.304]                             muffled <- TRUE
[09:31:33.304]                             break
[09:31:33.304]                           }
[09:31:33.304]                         }
[09:31:33.304]                       }
[09:31:33.304]                       invisible(muffled)
[09:31:33.304]                     }
[09:31:33.304]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.304]                   }
[09:31:33.304]                 }
[09:31:33.304]                 else {
[09:31:33.304]                   if (TRUE) {
[09:31:33.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.304]                     {
[09:31:33.304]                       inherits <- base::inherits
[09:31:33.304]                       invokeRestart <- base::invokeRestart
[09:31:33.304]                       is.null <- base::is.null
[09:31:33.304]                       muffled <- FALSE
[09:31:33.304]                       if (inherits(cond, "message")) {
[09:31:33.304]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.304]                         if (muffled) 
[09:31:33.304]                           invokeRestart("muffleMessage")
[09:31:33.304]                       }
[09:31:33.304]                       else if (inherits(cond, "warning")) {
[09:31:33.304]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.304]                         if (muffled) 
[09:31:33.304]                           invokeRestart("muffleWarning")
[09:31:33.304]                       }
[09:31:33.304]                       else if (inherits(cond, "condition")) {
[09:31:33.304]                         if (!is.null(pattern)) {
[09:31:33.304]                           computeRestarts <- base::computeRestarts
[09:31:33.304]                           grepl <- base::grepl
[09:31:33.304]                           restarts <- computeRestarts(cond)
[09:31:33.304]                           for (restart in restarts) {
[09:31:33.304]                             name <- restart$name
[09:31:33.304]                             if (is.null(name)) 
[09:31:33.304]                               next
[09:31:33.304]                             if (!grepl(pattern, name)) 
[09:31:33.304]                               next
[09:31:33.304]                             invokeRestart(restart)
[09:31:33.304]                             muffled <- TRUE
[09:31:33.304]                             break
[09:31:33.304]                           }
[09:31:33.304]                         }
[09:31:33.304]                       }
[09:31:33.304]                       invisible(muffled)
[09:31:33.304]                     }
[09:31:33.304]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.304]                   }
[09:31:33.304]                 }
[09:31:33.304]             }
[09:31:33.304]         }))
[09:31:33.304]     }, error = function(ex) {
[09:31:33.304]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.304]                 ...future.rng), started = ...future.startTime, 
[09:31:33.304]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.304]             version = "1.8"), class = "FutureResult")
[09:31:33.304]     }, finally = {
[09:31:33.304]         if (!identical(...future.workdir, getwd())) 
[09:31:33.304]             setwd(...future.workdir)
[09:31:33.304]         {
[09:31:33.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.304]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.304]             }
[09:31:33.304]             base::options(...future.oldOptions)
[09:31:33.304]             if (.Platform$OS.type == "windows") {
[09:31:33.304]                 old_names <- names(...future.oldEnvVars)
[09:31:33.304]                 envs <- base::Sys.getenv()
[09:31:33.304]                 names <- names(envs)
[09:31:33.304]                 common <- intersect(names, old_names)
[09:31:33.304]                 added <- setdiff(names, old_names)
[09:31:33.304]                 removed <- setdiff(old_names, names)
[09:31:33.304]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.304]                   envs[common]]
[09:31:33.304]                 NAMES <- toupper(changed)
[09:31:33.304]                 args <- list()
[09:31:33.304]                 for (kk in seq_along(NAMES)) {
[09:31:33.304]                   name <- changed[[kk]]
[09:31:33.304]                   NAME <- NAMES[[kk]]
[09:31:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.304]                     next
[09:31:33.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.304]                 }
[09:31:33.304]                 NAMES <- toupper(added)
[09:31:33.304]                 for (kk in seq_along(NAMES)) {
[09:31:33.304]                   name <- added[[kk]]
[09:31:33.304]                   NAME <- NAMES[[kk]]
[09:31:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.304]                     next
[09:31:33.304]                   args[[name]] <- ""
[09:31:33.304]                 }
[09:31:33.304]                 NAMES <- toupper(removed)
[09:31:33.304]                 for (kk in seq_along(NAMES)) {
[09:31:33.304]                   name <- removed[[kk]]
[09:31:33.304]                   NAME <- NAMES[[kk]]
[09:31:33.304]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.304]                     next
[09:31:33.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.304]                 }
[09:31:33.304]                 if (length(args) > 0) 
[09:31:33.304]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.304]             }
[09:31:33.304]             else {
[09:31:33.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.304]             }
[09:31:33.304]             {
[09:31:33.304]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.304]                   0L) {
[09:31:33.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.304]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.304]                   base::options(opts)
[09:31:33.304]                 }
[09:31:33.304]                 {
[09:31:33.304]                   {
[09:31:33.304]                     NULL
[09:31:33.304]                     RNGkind("Mersenne-Twister")
[09:31:33.304]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.304]                       inherits = FALSE)
[09:31:33.304]                   }
[09:31:33.304]                   options(future.plan = NULL)
[09:31:33.304]                   if (is.na(NA_character_)) 
[09:31:33.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.304]                     .init = FALSE)
[09:31:33.304]                 }
[09:31:33.304]             }
[09:31:33.304]         }
[09:31:33.304]     })
[09:31:33.304]     if (TRUE) {
[09:31:33.304]         base::sink(type = "output", split = FALSE)
[09:31:33.304]         if (TRUE) {
[09:31:33.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.304]         }
[09:31:33.304]         else {
[09:31:33.304]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.304]         }
[09:31:33.304]         base::close(...future.stdout)
[09:31:33.304]         ...future.stdout <- NULL
[09:31:33.304]     }
[09:31:33.304]     ...future.result$conditions <- ...future.conditions
[09:31:33.304]     ...future.result$finished <- base::Sys.time()
[09:31:33.304]     ...future.result
[09:31:33.304] }
[09:31:33.306] assign_globals() ...
[09:31:33.306] List of 1
[09:31:33.306]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a624ef0> 
[09:31:33.306]  - attr(*, "where")=List of 1
[09:31:33.306]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.306]  - attr(*, "resolved")= logi TRUE
[09:31:33.306]  - attr(*, "total_size")= num 1622272
[09:31:33.306]  - attr(*, "already-done")= logi TRUE
[09:31:33.308] - copied ‘a’ to environment
[09:31:33.308] assign_globals() ... done
[09:31:33.309] plan(): Setting new future strategy stack:
[09:31:33.309] List of future strategies:
[09:31:33.309] 1. sequential:
[09:31:33.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.309]    - tweaked: FALSE
[09:31:33.309]    - call: NULL
[09:31:33.309] plan(): nbrOfWorkers() = 1
[09:31:33.310] plan(): Setting new future strategy stack:
[09:31:33.310] List of future strategies:
[09:31:33.310] 1. sequential:
[09:31:33.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.310]    - tweaked: FALSE
[09:31:33.310]    - call: plan(strategy)
[09:31:33.310] plan(): nbrOfWorkers() = 1
[09:31:33.310] SequentialFuture started (and completed)
[09:31:33.311] - Launch lazy future ... done
[09:31:33.311] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.311] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.311] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.312] 
[09:31:33.312] Searching for globals ... DONE
[09:31:33.312] - globals: [0] <none>
[09:31:33.312] getGlobalsAndPackages() ... DONE
[09:31:33.312] run() for ‘Future’ ...
[09:31:33.312] - state: ‘created’
[09:31:33.312] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.313] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.313]   - Field: ‘label’
[09:31:33.313]   - Field: ‘local’
[09:31:33.313]   - Field: ‘owner’
[09:31:33.313]   - Field: ‘envir’
[09:31:33.313]   - Field: ‘packages’
[09:31:33.313]   - Field: ‘gc’
[09:31:33.313]   - Field: ‘conditions’
[09:31:33.313]   - Field: ‘expr’
[09:31:33.313]   - Field: ‘uuid’
[09:31:33.313]   - Field: ‘seed’
[09:31:33.314]   - Field: ‘version’
[09:31:33.314]   - Field: ‘result’
[09:31:33.314]   - Field: ‘asynchronous’
[09:31:33.314]   - Field: ‘calls’
[09:31:33.314]   - Field: ‘globals’
[09:31:33.314]   - Field: ‘stdout’
[09:31:33.314]   - Field: ‘earlySignal’
[09:31:33.314]   - Field: ‘lazy’
[09:31:33.314]   - Field: ‘state’
[09:31:33.314] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.314] - Launch lazy future ...
[09:31:33.315] Packages needed by the future expression (n = 0): <none>
[09:31:33.315] Packages needed by future strategies (n = 0): <none>
[09:31:33.315] {
[09:31:33.315]     {
[09:31:33.315]         {
[09:31:33.315]             ...future.startTime <- base::Sys.time()
[09:31:33.315]             {
[09:31:33.315]                 {
[09:31:33.315]                   {
[09:31:33.315]                     base::local({
[09:31:33.315]                       has_future <- base::requireNamespace("future", 
[09:31:33.315]                         quietly = TRUE)
[09:31:33.315]                       if (has_future) {
[09:31:33.315]                         ns <- base::getNamespace("future")
[09:31:33.315]                         version <- ns[[".package"]][["version"]]
[09:31:33.315]                         if (is.null(version)) 
[09:31:33.315]                           version <- utils::packageVersion("future")
[09:31:33.315]                       }
[09:31:33.315]                       else {
[09:31:33.315]                         version <- NULL
[09:31:33.315]                       }
[09:31:33.315]                       if (!has_future || version < "1.8.0") {
[09:31:33.315]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.315]                           "", base::R.version$version.string), 
[09:31:33.315]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.315]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.315]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.315]                             "release", "version")], collapse = " "), 
[09:31:33.315]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.315]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.315]                           info)
[09:31:33.315]                         info <- base::paste(info, collapse = "; ")
[09:31:33.315]                         if (!has_future) {
[09:31:33.315]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.315]                             info)
[09:31:33.315]                         }
[09:31:33.315]                         else {
[09:31:33.315]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.315]                             info, version)
[09:31:33.315]                         }
[09:31:33.315]                         base::stop(msg)
[09:31:33.315]                       }
[09:31:33.315]                     })
[09:31:33.315]                   }
[09:31:33.315]                   ...future.strategy.old <- future::plan("list")
[09:31:33.315]                   options(future.plan = NULL)
[09:31:33.315]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.315]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.315]                 }
[09:31:33.315]                 ...future.workdir <- getwd()
[09:31:33.315]             }
[09:31:33.315]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.315]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.315]         }
[09:31:33.315]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.315]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.315]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.315]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.315]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.315]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.315]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.315]             base::names(...future.oldOptions))
[09:31:33.315]     }
[09:31:33.315]     if (FALSE) {
[09:31:33.315]     }
[09:31:33.315]     else {
[09:31:33.315]         if (TRUE) {
[09:31:33.315]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.315]                 open = "w")
[09:31:33.315]         }
[09:31:33.315]         else {
[09:31:33.315]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.315]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.315]         }
[09:31:33.315]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.315]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.315]             base::sink(type = "output", split = FALSE)
[09:31:33.315]             base::close(...future.stdout)
[09:31:33.315]         }, add = TRUE)
[09:31:33.315]     }
[09:31:33.315]     ...future.frame <- base::sys.nframe()
[09:31:33.315]     ...future.conditions <- base::list()
[09:31:33.315]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.315]     if (FALSE) {
[09:31:33.315]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.315]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.315]     }
[09:31:33.315]     ...future.result <- base::tryCatch({
[09:31:33.315]         base::withCallingHandlers({
[09:31:33.315]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.315]             future::FutureResult(value = ...future.value$value, 
[09:31:33.315]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.315]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.315]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.315]                     ...future.globalenv.names))
[09:31:33.315]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.315]         }, condition = base::local({
[09:31:33.315]             c <- base::c
[09:31:33.315]             inherits <- base::inherits
[09:31:33.315]             invokeRestart <- base::invokeRestart
[09:31:33.315]             length <- base::length
[09:31:33.315]             list <- base::list
[09:31:33.315]             seq.int <- base::seq.int
[09:31:33.315]             signalCondition <- base::signalCondition
[09:31:33.315]             sys.calls <- base::sys.calls
[09:31:33.315]             `[[` <- base::`[[`
[09:31:33.315]             `+` <- base::`+`
[09:31:33.315]             `<<-` <- base::`<<-`
[09:31:33.315]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.315]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.315]                   3L)]
[09:31:33.315]             }
[09:31:33.315]             function(cond) {
[09:31:33.315]                 is_error <- inherits(cond, "error")
[09:31:33.315]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.315]                   NULL)
[09:31:33.315]                 if (is_error) {
[09:31:33.315]                   sessionInformation <- function() {
[09:31:33.315]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.315]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.315]                       search = base::search(), system = base::Sys.info())
[09:31:33.315]                   }
[09:31:33.315]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.315]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.315]                     cond$call), session = sessionInformation(), 
[09:31:33.315]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.315]                   signalCondition(cond)
[09:31:33.315]                 }
[09:31:33.315]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.315]                 "immediateCondition"))) {
[09:31:33.315]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.315]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.315]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.315]                   if (TRUE && !signal) {
[09:31:33.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.315]                     {
[09:31:33.315]                       inherits <- base::inherits
[09:31:33.315]                       invokeRestart <- base::invokeRestart
[09:31:33.315]                       is.null <- base::is.null
[09:31:33.315]                       muffled <- FALSE
[09:31:33.315]                       if (inherits(cond, "message")) {
[09:31:33.315]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.315]                         if (muffled) 
[09:31:33.315]                           invokeRestart("muffleMessage")
[09:31:33.315]                       }
[09:31:33.315]                       else if (inherits(cond, "warning")) {
[09:31:33.315]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.315]                         if (muffled) 
[09:31:33.315]                           invokeRestart("muffleWarning")
[09:31:33.315]                       }
[09:31:33.315]                       else if (inherits(cond, "condition")) {
[09:31:33.315]                         if (!is.null(pattern)) {
[09:31:33.315]                           computeRestarts <- base::computeRestarts
[09:31:33.315]                           grepl <- base::grepl
[09:31:33.315]                           restarts <- computeRestarts(cond)
[09:31:33.315]                           for (restart in restarts) {
[09:31:33.315]                             name <- restart$name
[09:31:33.315]                             if (is.null(name)) 
[09:31:33.315]                               next
[09:31:33.315]                             if (!grepl(pattern, name)) 
[09:31:33.315]                               next
[09:31:33.315]                             invokeRestart(restart)
[09:31:33.315]                             muffled <- TRUE
[09:31:33.315]                             break
[09:31:33.315]                           }
[09:31:33.315]                         }
[09:31:33.315]                       }
[09:31:33.315]                       invisible(muffled)
[09:31:33.315]                     }
[09:31:33.315]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.315]                   }
[09:31:33.315]                 }
[09:31:33.315]                 else {
[09:31:33.315]                   if (TRUE) {
[09:31:33.315]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.315]                     {
[09:31:33.315]                       inherits <- base::inherits
[09:31:33.315]                       invokeRestart <- base::invokeRestart
[09:31:33.315]                       is.null <- base::is.null
[09:31:33.315]                       muffled <- FALSE
[09:31:33.315]                       if (inherits(cond, "message")) {
[09:31:33.315]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.315]                         if (muffled) 
[09:31:33.315]                           invokeRestart("muffleMessage")
[09:31:33.315]                       }
[09:31:33.315]                       else if (inherits(cond, "warning")) {
[09:31:33.315]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.315]                         if (muffled) 
[09:31:33.315]                           invokeRestart("muffleWarning")
[09:31:33.315]                       }
[09:31:33.315]                       else if (inherits(cond, "condition")) {
[09:31:33.315]                         if (!is.null(pattern)) {
[09:31:33.315]                           computeRestarts <- base::computeRestarts
[09:31:33.315]                           grepl <- base::grepl
[09:31:33.315]                           restarts <- computeRestarts(cond)
[09:31:33.315]                           for (restart in restarts) {
[09:31:33.315]                             name <- restart$name
[09:31:33.315]                             if (is.null(name)) 
[09:31:33.315]                               next
[09:31:33.315]                             if (!grepl(pattern, name)) 
[09:31:33.315]                               next
[09:31:33.315]                             invokeRestart(restart)
[09:31:33.315]                             muffled <- TRUE
[09:31:33.315]                             break
[09:31:33.315]                           }
[09:31:33.315]                         }
[09:31:33.315]                       }
[09:31:33.315]                       invisible(muffled)
[09:31:33.315]                     }
[09:31:33.315]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.315]                   }
[09:31:33.315]                 }
[09:31:33.315]             }
[09:31:33.315]         }))
[09:31:33.315]     }, error = function(ex) {
[09:31:33.315]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.315]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.315]                 ...future.rng), started = ...future.startTime, 
[09:31:33.315]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.315]             version = "1.8"), class = "FutureResult")
[09:31:33.315]     }, finally = {
[09:31:33.315]         if (!identical(...future.workdir, getwd())) 
[09:31:33.315]             setwd(...future.workdir)
[09:31:33.315]         {
[09:31:33.315]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.315]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.315]             }
[09:31:33.315]             base::options(...future.oldOptions)
[09:31:33.315]             if (.Platform$OS.type == "windows") {
[09:31:33.315]                 old_names <- names(...future.oldEnvVars)
[09:31:33.315]                 envs <- base::Sys.getenv()
[09:31:33.315]                 names <- names(envs)
[09:31:33.315]                 common <- intersect(names, old_names)
[09:31:33.315]                 added <- setdiff(names, old_names)
[09:31:33.315]                 removed <- setdiff(old_names, names)
[09:31:33.315]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.315]                   envs[common]]
[09:31:33.315]                 NAMES <- toupper(changed)
[09:31:33.315]                 args <- list()
[09:31:33.315]                 for (kk in seq_along(NAMES)) {
[09:31:33.315]                   name <- changed[[kk]]
[09:31:33.315]                   NAME <- NAMES[[kk]]
[09:31:33.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.315]                     next
[09:31:33.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.315]                 }
[09:31:33.315]                 NAMES <- toupper(added)
[09:31:33.315]                 for (kk in seq_along(NAMES)) {
[09:31:33.315]                   name <- added[[kk]]
[09:31:33.315]                   NAME <- NAMES[[kk]]
[09:31:33.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.315]                     next
[09:31:33.315]                   args[[name]] <- ""
[09:31:33.315]                 }
[09:31:33.315]                 NAMES <- toupper(removed)
[09:31:33.315]                 for (kk in seq_along(NAMES)) {
[09:31:33.315]                   name <- removed[[kk]]
[09:31:33.315]                   NAME <- NAMES[[kk]]
[09:31:33.315]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.315]                     next
[09:31:33.315]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.315]                 }
[09:31:33.315]                 if (length(args) > 0) 
[09:31:33.315]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.315]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.315]             }
[09:31:33.315]             else {
[09:31:33.315]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.315]             }
[09:31:33.315]             {
[09:31:33.315]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.315]                   0L) {
[09:31:33.315]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.315]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.315]                   base::options(opts)
[09:31:33.315]                 }
[09:31:33.315]                 {
[09:31:33.315]                   {
[09:31:33.315]                     NULL
[09:31:33.315]                     RNGkind("Mersenne-Twister")
[09:31:33.315]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.315]                       inherits = FALSE)
[09:31:33.315]                   }
[09:31:33.315]                   options(future.plan = NULL)
[09:31:33.315]                   if (is.na(NA_character_)) 
[09:31:33.315]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.315]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.315]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.315]                     .init = FALSE)
[09:31:33.315]                 }
[09:31:33.315]             }
[09:31:33.315]         }
[09:31:33.315]     })
[09:31:33.315]     if (TRUE) {
[09:31:33.315]         base::sink(type = "output", split = FALSE)
[09:31:33.315]         if (TRUE) {
[09:31:33.315]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.315]         }
[09:31:33.315]         else {
[09:31:33.315]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.315]         }
[09:31:33.315]         base::close(...future.stdout)
[09:31:33.315]         ...future.stdout <- NULL
[09:31:33.315]     }
[09:31:33.315]     ...future.result$conditions <- ...future.conditions
[09:31:33.315]     ...future.result$finished <- base::Sys.time()
[09:31:33.315]     ...future.result
[09:31:33.315] }
[09:31:33.317] plan(): Setting new future strategy stack:
[09:31:33.317] List of future strategies:
[09:31:33.317] 1. sequential:
[09:31:33.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.317]    - tweaked: FALSE
[09:31:33.317]    - call: NULL
[09:31:33.317] plan(): nbrOfWorkers() = 1
[09:31:33.318] plan(): Setting new future strategy stack:
[09:31:33.318] List of future strategies:
[09:31:33.318] 1. sequential:
[09:31:33.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.318]    - tweaked: FALSE
[09:31:33.318]    - call: plan(strategy)
[09:31:33.318] plan(): nbrOfWorkers() = 1
[09:31:33.318] SequentialFuture started (and completed)
[09:31:33.319] - Launch lazy future ... done
[09:31:33.319] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.319] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.319] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.321] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.321] Searching for globals ... DONE
[09:31:33.321] Resolving globals: TRUE
[09:31:33.321] Resolving any globals that are futures ...
[09:31:33.321] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.321] Resolving any globals that are futures ... DONE
[09:31:33.321] Resolving futures part of globals (recursively) ...
[09:31:33.322] resolve() on list ...
[09:31:33.322]  recursive: 99
[09:31:33.322]  length: 1
[09:31:33.322]  elements: ‘a’
[09:31:33.322] resolved() for ‘SequentialFuture’ ...
[09:31:33.322] - state: ‘finished’
[09:31:33.322] - run: TRUE
[09:31:33.322] - result: ‘FutureResult’
[09:31:33.322] resolved() for ‘SequentialFuture’ ... done
[09:31:33.322] Future #1
[09:31:33.323] resolved() for ‘SequentialFuture’ ...
[09:31:33.323] - state: ‘finished’
[09:31:33.323] - run: TRUE
[09:31:33.323] - result: ‘FutureResult’
[09:31:33.323] resolved() for ‘SequentialFuture’ ... done
[09:31:33.323] A SequentialFuture was resolved
[09:31:33.323]  length: 0 (resolved future 1)
[09:31:33.323] resolve() on list ... DONE
[09:31:33.323] - globals: [1] ‘a’
[09:31:33.323] Resolving futures part of globals (recursively) ... DONE
[09:31:33.325] The total size of the 1 globals is 1.55 MiB (1622272 bytes)
[09:31:33.325] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[09:31:33.326] - globals: [1] ‘a’
[09:31:33.326] - packages: [1] ‘future’
[09:31:33.326] getGlobalsAndPackages() ... DONE
[09:31:33.326] run() for ‘Future’ ...
[09:31:33.326] - state: ‘created’
[09:31:33.326] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.327]   - Field: ‘label’
[09:31:33.327]   - Field: ‘local’
[09:31:33.327]   - Field: ‘owner’
[09:31:33.327]   - Field: ‘envir’
[09:31:33.327]   - Field: ‘packages’
[09:31:33.327]   - Field: ‘gc’
[09:31:33.327]   - Field: ‘conditions’
[09:31:33.327]   - Field: ‘expr’
[09:31:33.327]   - Field: ‘uuid’
[09:31:33.327]   - Field: ‘seed’
[09:31:33.327]   - Field: ‘version’
[09:31:33.328]   - Field: ‘result’
[09:31:33.328]   - Field: ‘asynchronous’
[09:31:33.328]   - Field: ‘calls’
[09:31:33.328]   - Field: ‘globals’
[09:31:33.328]   - Field: ‘stdout’
[09:31:33.328]   - Field: ‘earlySignal’
[09:31:33.328]   - Field: ‘lazy’
[09:31:33.328]   - Field: ‘state’
[09:31:33.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.328] - Launch lazy future ...
[09:31:33.328] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.329] Packages needed by future strategies (n = 0): <none>
[09:31:33.329] {
[09:31:33.329]     {
[09:31:33.329]         {
[09:31:33.329]             ...future.startTime <- base::Sys.time()
[09:31:33.329]             {
[09:31:33.329]                 {
[09:31:33.329]                   {
[09:31:33.329]                     {
[09:31:33.329]                       base::local({
[09:31:33.329]                         has_future <- base::requireNamespace("future", 
[09:31:33.329]                           quietly = TRUE)
[09:31:33.329]                         if (has_future) {
[09:31:33.329]                           ns <- base::getNamespace("future")
[09:31:33.329]                           version <- ns[[".package"]][["version"]]
[09:31:33.329]                           if (is.null(version)) 
[09:31:33.329]                             version <- utils::packageVersion("future")
[09:31:33.329]                         }
[09:31:33.329]                         else {
[09:31:33.329]                           version <- NULL
[09:31:33.329]                         }
[09:31:33.329]                         if (!has_future || version < "1.8.0") {
[09:31:33.329]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.329]                             "", base::R.version$version.string), 
[09:31:33.329]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.329]                               "release", "version")], collapse = " "), 
[09:31:33.329]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.329]                             info)
[09:31:33.329]                           info <- base::paste(info, collapse = "; ")
[09:31:33.329]                           if (!has_future) {
[09:31:33.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.329]                               info)
[09:31:33.329]                           }
[09:31:33.329]                           else {
[09:31:33.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.329]                               info, version)
[09:31:33.329]                           }
[09:31:33.329]                           base::stop(msg)
[09:31:33.329]                         }
[09:31:33.329]                       })
[09:31:33.329]                     }
[09:31:33.329]                     base::local({
[09:31:33.329]                       for (pkg in "future") {
[09:31:33.329]                         base::loadNamespace(pkg)
[09:31:33.329]                         base::library(pkg, character.only = TRUE)
[09:31:33.329]                       }
[09:31:33.329]                     })
[09:31:33.329]                   }
[09:31:33.329]                   ...future.strategy.old <- future::plan("list")
[09:31:33.329]                   options(future.plan = NULL)
[09:31:33.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.329]                 }
[09:31:33.329]                 ...future.workdir <- getwd()
[09:31:33.329]             }
[09:31:33.329]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.329]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.329]         }
[09:31:33.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.329]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.329]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.329]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.329]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.329]             base::names(...future.oldOptions))
[09:31:33.329]     }
[09:31:33.329]     if (FALSE) {
[09:31:33.329]     }
[09:31:33.329]     else {
[09:31:33.329]         if (TRUE) {
[09:31:33.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.329]                 open = "w")
[09:31:33.329]         }
[09:31:33.329]         else {
[09:31:33.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.329]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.329]         }
[09:31:33.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.329]             base::sink(type = "output", split = FALSE)
[09:31:33.329]             base::close(...future.stdout)
[09:31:33.329]         }, add = TRUE)
[09:31:33.329]     }
[09:31:33.329]     ...future.frame <- base::sys.nframe()
[09:31:33.329]     ...future.conditions <- base::list()
[09:31:33.329]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.329]     if (FALSE) {
[09:31:33.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.329]     }
[09:31:33.329]     ...future.result <- base::tryCatch({
[09:31:33.329]         base::withCallingHandlers({
[09:31:33.329]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.329]                 1))
[09:31:33.329]             future::FutureResult(value = ...future.value$value, 
[09:31:33.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.329]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.329]                     ...future.globalenv.names))
[09:31:33.329]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.329]         }, condition = base::local({
[09:31:33.329]             c <- base::c
[09:31:33.329]             inherits <- base::inherits
[09:31:33.329]             invokeRestart <- base::invokeRestart
[09:31:33.329]             length <- base::length
[09:31:33.329]             list <- base::list
[09:31:33.329]             seq.int <- base::seq.int
[09:31:33.329]             signalCondition <- base::signalCondition
[09:31:33.329]             sys.calls <- base::sys.calls
[09:31:33.329]             `[[` <- base::`[[`
[09:31:33.329]             `+` <- base::`+`
[09:31:33.329]             `<<-` <- base::`<<-`
[09:31:33.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.329]                   3L)]
[09:31:33.329]             }
[09:31:33.329]             function(cond) {
[09:31:33.329]                 is_error <- inherits(cond, "error")
[09:31:33.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.329]                   NULL)
[09:31:33.329]                 if (is_error) {
[09:31:33.329]                   sessionInformation <- function() {
[09:31:33.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.329]                       search = base::search(), system = base::Sys.info())
[09:31:33.329]                   }
[09:31:33.329]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.329]                     cond$call), session = sessionInformation(), 
[09:31:33.329]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.329]                   signalCondition(cond)
[09:31:33.329]                 }
[09:31:33.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.329]                 "immediateCondition"))) {
[09:31:33.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.329]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.329]                   if (TRUE && !signal) {
[09:31:33.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.329]                     {
[09:31:33.329]                       inherits <- base::inherits
[09:31:33.329]                       invokeRestart <- base::invokeRestart
[09:31:33.329]                       is.null <- base::is.null
[09:31:33.329]                       muffled <- FALSE
[09:31:33.329]                       if (inherits(cond, "message")) {
[09:31:33.329]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.329]                         if (muffled) 
[09:31:33.329]                           invokeRestart("muffleMessage")
[09:31:33.329]                       }
[09:31:33.329]                       else if (inherits(cond, "warning")) {
[09:31:33.329]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.329]                         if (muffled) 
[09:31:33.329]                           invokeRestart("muffleWarning")
[09:31:33.329]                       }
[09:31:33.329]                       else if (inherits(cond, "condition")) {
[09:31:33.329]                         if (!is.null(pattern)) {
[09:31:33.329]                           computeRestarts <- base::computeRestarts
[09:31:33.329]                           grepl <- base::grepl
[09:31:33.329]                           restarts <- computeRestarts(cond)
[09:31:33.329]                           for (restart in restarts) {
[09:31:33.329]                             name <- restart$name
[09:31:33.329]                             if (is.null(name)) 
[09:31:33.329]                               next
[09:31:33.329]                             if (!grepl(pattern, name)) 
[09:31:33.329]                               next
[09:31:33.329]                             invokeRestart(restart)
[09:31:33.329]                             muffled <- TRUE
[09:31:33.329]                             break
[09:31:33.329]                           }
[09:31:33.329]                         }
[09:31:33.329]                       }
[09:31:33.329]                       invisible(muffled)
[09:31:33.329]                     }
[09:31:33.329]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.329]                   }
[09:31:33.329]                 }
[09:31:33.329]                 else {
[09:31:33.329]                   if (TRUE) {
[09:31:33.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.329]                     {
[09:31:33.329]                       inherits <- base::inherits
[09:31:33.329]                       invokeRestart <- base::invokeRestart
[09:31:33.329]                       is.null <- base::is.null
[09:31:33.329]                       muffled <- FALSE
[09:31:33.329]                       if (inherits(cond, "message")) {
[09:31:33.329]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.329]                         if (muffled) 
[09:31:33.329]                           invokeRestart("muffleMessage")
[09:31:33.329]                       }
[09:31:33.329]                       else if (inherits(cond, "warning")) {
[09:31:33.329]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.329]                         if (muffled) 
[09:31:33.329]                           invokeRestart("muffleWarning")
[09:31:33.329]                       }
[09:31:33.329]                       else if (inherits(cond, "condition")) {
[09:31:33.329]                         if (!is.null(pattern)) {
[09:31:33.329]                           computeRestarts <- base::computeRestarts
[09:31:33.329]                           grepl <- base::grepl
[09:31:33.329]                           restarts <- computeRestarts(cond)
[09:31:33.329]                           for (restart in restarts) {
[09:31:33.329]                             name <- restart$name
[09:31:33.329]                             if (is.null(name)) 
[09:31:33.329]                               next
[09:31:33.329]                             if (!grepl(pattern, name)) 
[09:31:33.329]                               next
[09:31:33.329]                             invokeRestart(restart)
[09:31:33.329]                             muffled <- TRUE
[09:31:33.329]                             break
[09:31:33.329]                           }
[09:31:33.329]                         }
[09:31:33.329]                       }
[09:31:33.329]                       invisible(muffled)
[09:31:33.329]                     }
[09:31:33.329]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.329]                   }
[09:31:33.329]                 }
[09:31:33.329]             }
[09:31:33.329]         }))
[09:31:33.329]     }, error = function(ex) {
[09:31:33.329]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.329]                 ...future.rng), started = ...future.startTime, 
[09:31:33.329]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.329]             version = "1.8"), class = "FutureResult")
[09:31:33.329]     }, finally = {
[09:31:33.329]         if (!identical(...future.workdir, getwd())) 
[09:31:33.329]             setwd(...future.workdir)
[09:31:33.329]         {
[09:31:33.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.329]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.329]             }
[09:31:33.329]             base::options(...future.oldOptions)
[09:31:33.329]             if (.Platform$OS.type == "windows") {
[09:31:33.329]                 old_names <- names(...future.oldEnvVars)
[09:31:33.329]                 envs <- base::Sys.getenv()
[09:31:33.329]                 names <- names(envs)
[09:31:33.329]                 common <- intersect(names, old_names)
[09:31:33.329]                 added <- setdiff(names, old_names)
[09:31:33.329]                 removed <- setdiff(old_names, names)
[09:31:33.329]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.329]                   envs[common]]
[09:31:33.329]                 NAMES <- toupper(changed)
[09:31:33.329]                 args <- list()
[09:31:33.329]                 for (kk in seq_along(NAMES)) {
[09:31:33.329]                   name <- changed[[kk]]
[09:31:33.329]                   NAME <- NAMES[[kk]]
[09:31:33.329]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.329]                     next
[09:31:33.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.329]                 }
[09:31:33.329]                 NAMES <- toupper(added)
[09:31:33.329]                 for (kk in seq_along(NAMES)) {
[09:31:33.329]                   name <- added[[kk]]
[09:31:33.329]                   NAME <- NAMES[[kk]]
[09:31:33.329]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.329]                     next
[09:31:33.329]                   args[[name]] <- ""
[09:31:33.329]                 }
[09:31:33.329]                 NAMES <- toupper(removed)
[09:31:33.329]                 for (kk in seq_along(NAMES)) {
[09:31:33.329]                   name <- removed[[kk]]
[09:31:33.329]                   NAME <- NAMES[[kk]]
[09:31:33.329]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.329]                     next
[09:31:33.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.329]                 }
[09:31:33.329]                 if (length(args) > 0) 
[09:31:33.329]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.329]             }
[09:31:33.329]             else {
[09:31:33.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.329]             }
[09:31:33.329]             {
[09:31:33.329]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.329]                   0L) {
[09:31:33.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.329]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.329]                   base::options(opts)
[09:31:33.329]                 }
[09:31:33.329]                 {
[09:31:33.329]                   {
[09:31:33.329]                     NULL
[09:31:33.329]                     RNGkind("Mersenne-Twister")
[09:31:33.329]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.329]                       inherits = FALSE)
[09:31:33.329]                   }
[09:31:33.329]                   options(future.plan = NULL)
[09:31:33.329]                   if (is.na(NA_character_)) 
[09:31:33.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.329]                     .init = FALSE)
[09:31:33.329]                 }
[09:31:33.329]             }
[09:31:33.329]         }
[09:31:33.329]     })
[09:31:33.329]     if (TRUE) {
[09:31:33.329]         base::sink(type = "output", split = FALSE)
[09:31:33.329]         if (TRUE) {
[09:31:33.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.329]         }
[09:31:33.329]         else {
[09:31:33.329]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.329]         }
[09:31:33.329]         base::close(...future.stdout)
[09:31:33.329]         ...future.stdout <- NULL
[09:31:33.329]     }
[09:31:33.329]     ...future.result$conditions <- ...future.conditions
[09:31:33.329]     ...future.result$finished <- base::Sys.time()
[09:31:33.329]     ...future.result
[09:31:33.329] }
[09:31:33.331] assign_globals() ...
[09:31:33.331] List of 1
[09:31:33.331]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a5fbf20> 
[09:31:33.331]  - attr(*, "where")=List of 1
[09:31:33.331]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.331]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.331]  - attr(*, "resolved")= logi TRUE
[09:31:33.331]  - attr(*, "total_size")= num 1622272
[09:31:33.331]  - attr(*, "already-done")= logi TRUE
[09:31:33.333] - copied ‘a’ to environment
[09:31:33.333] assign_globals() ... done
[09:31:33.333] plan(): Setting new future strategy stack:
[09:31:33.333] List of future strategies:
[09:31:33.333] 1. sequential:
[09:31:33.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.333]    - tweaked: FALSE
[09:31:33.333]    - call: NULL
[09:31:33.334] plan(): nbrOfWorkers() = 1
[09:31:33.334] plan(): Setting new future strategy stack:
[09:31:33.335] List of future strategies:
[09:31:33.335] 1. sequential:
[09:31:33.335]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.335]    - tweaked: FALSE
[09:31:33.335]    - call: plan(strategy)
[09:31:33.335] plan(): nbrOfWorkers() = 1
[09:31:33.335] SequentialFuture started (and completed)
[09:31:33.335] - Launch lazy future ... done
[09:31:33.335] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.336] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.336] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.336] 
[09:31:33.336] Searching for globals ... DONE
[09:31:33.336] - globals: [0] <none>
[09:31:33.336] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.337] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.337] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.338] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.338] Searching for globals ... DONE
[09:31:33.338] Resolving globals: TRUE
[09:31:33.338] Resolving any globals that are futures ...
[09:31:33.338] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.338] Resolving any globals that are futures ... DONE
[09:31:33.338] Resolving futures part of globals (recursively) ...
[09:31:33.339] resolve() on list ...
[09:31:33.339]  recursive: 99
[09:31:33.339]  length: 1
[09:31:33.339]  elements: ‘a’
[09:31:33.339] run() for ‘Future’ ...
[09:31:33.339] - state: ‘created’
[09:31:33.339] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.339] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.339] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.340]   - Field: ‘label’
[09:31:33.340]   - Field: ‘local’
[09:31:33.340]   - Field: ‘owner’
[09:31:33.340]   - Field: ‘envir’
[09:31:33.340]   - Field: ‘packages’
[09:31:33.340]   - Field: ‘gc’
[09:31:33.340]   - Field: ‘conditions’
[09:31:33.340]   - Field: ‘expr’
[09:31:33.340]   - Field: ‘uuid’
[09:31:33.340]   - Field: ‘seed’
[09:31:33.340]   - Field: ‘version’
[09:31:33.341]   - Field: ‘result’
[09:31:33.341]   - Field: ‘asynchronous’
[09:31:33.341]   - Field: ‘calls’
[09:31:33.341]   - Field: ‘globals’
[09:31:33.341]   - Field: ‘stdout’
[09:31:33.341]   - Field: ‘earlySignal’
[09:31:33.341]   - Field: ‘lazy’
[09:31:33.341]   - Field: ‘state’
[09:31:33.341] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.341] - Launch lazy future ...
[09:31:33.342] Packages needed by the future expression (n = 0): <none>
[09:31:33.342] Packages needed by future strategies (n = 0): <none>
[09:31:33.342] {
[09:31:33.342]     {
[09:31:33.342]         {
[09:31:33.342]             ...future.startTime <- base::Sys.time()
[09:31:33.342]             {
[09:31:33.342]                 {
[09:31:33.342]                   {
[09:31:33.342]                     base::local({
[09:31:33.342]                       has_future <- base::requireNamespace("future", 
[09:31:33.342]                         quietly = TRUE)
[09:31:33.342]                       if (has_future) {
[09:31:33.342]                         ns <- base::getNamespace("future")
[09:31:33.342]                         version <- ns[[".package"]][["version"]]
[09:31:33.342]                         if (is.null(version)) 
[09:31:33.342]                           version <- utils::packageVersion("future")
[09:31:33.342]                       }
[09:31:33.342]                       else {
[09:31:33.342]                         version <- NULL
[09:31:33.342]                       }
[09:31:33.342]                       if (!has_future || version < "1.8.0") {
[09:31:33.342]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.342]                           "", base::R.version$version.string), 
[09:31:33.342]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.342]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.342]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.342]                             "release", "version")], collapse = " "), 
[09:31:33.342]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.342]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.342]                           info)
[09:31:33.342]                         info <- base::paste(info, collapse = "; ")
[09:31:33.342]                         if (!has_future) {
[09:31:33.342]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.342]                             info)
[09:31:33.342]                         }
[09:31:33.342]                         else {
[09:31:33.342]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.342]                             info, version)
[09:31:33.342]                         }
[09:31:33.342]                         base::stop(msg)
[09:31:33.342]                       }
[09:31:33.342]                     })
[09:31:33.342]                   }
[09:31:33.342]                   ...future.strategy.old <- future::plan("list")
[09:31:33.342]                   options(future.plan = NULL)
[09:31:33.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.342]                 }
[09:31:33.342]                 ...future.workdir <- getwd()
[09:31:33.342]             }
[09:31:33.342]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.342]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.342]         }
[09:31:33.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.342]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.342]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.342]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.342]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.342]             base::names(...future.oldOptions))
[09:31:33.342]     }
[09:31:33.342]     if (FALSE) {
[09:31:33.342]     }
[09:31:33.342]     else {
[09:31:33.342]         if (TRUE) {
[09:31:33.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.342]                 open = "w")
[09:31:33.342]         }
[09:31:33.342]         else {
[09:31:33.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.342]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.342]         }
[09:31:33.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.342]             base::sink(type = "output", split = FALSE)
[09:31:33.342]             base::close(...future.stdout)
[09:31:33.342]         }, add = TRUE)
[09:31:33.342]     }
[09:31:33.342]     ...future.frame <- base::sys.nframe()
[09:31:33.342]     ...future.conditions <- base::list()
[09:31:33.342]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.342]     if (FALSE) {
[09:31:33.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.342]     }
[09:31:33.342]     ...future.result <- base::tryCatch({
[09:31:33.342]         base::withCallingHandlers({
[09:31:33.342]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.342]             future::FutureResult(value = ...future.value$value, 
[09:31:33.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.342]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.342]                     ...future.globalenv.names))
[09:31:33.342]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.342]         }, condition = base::local({
[09:31:33.342]             c <- base::c
[09:31:33.342]             inherits <- base::inherits
[09:31:33.342]             invokeRestart <- base::invokeRestart
[09:31:33.342]             length <- base::length
[09:31:33.342]             list <- base::list
[09:31:33.342]             seq.int <- base::seq.int
[09:31:33.342]             signalCondition <- base::signalCondition
[09:31:33.342]             sys.calls <- base::sys.calls
[09:31:33.342]             `[[` <- base::`[[`
[09:31:33.342]             `+` <- base::`+`
[09:31:33.342]             `<<-` <- base::`<<-`
[09:31:33.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.342]                   3L)]
[09:31:33.342]             }
[09:31:33.342]             function(cond) {
[09:31:33.342]                 is_error <- inherits(cond, "error")
[09:31:33.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.342]                   NULL)
[09:31:33.342]                 if (is_error) {
[09:31:33.342]                   sessionInformation <- function() {
[09:31:33.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.342]                       search = base::search(), system = base::Sys.info())
[09:31:33.342]                   }
[09:31:33.342]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.342]                     cond$call), session = sessionInformation(), 
[09:31:33.342]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.342]                   signalCondition(cond)
[09:31:33.342]                 }
[09:31:33.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.342]                 "immediateCondition"))) {
[09:31:33.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.342]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.342]                   if (TRUE && !signal) {
[09:31:33.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.342]                     {
[09:31:33.342]                       inherits <- base::inherits
[09:31:33.342]                       invokeRestart <- base::invokeRestart
[09:31:33.342]                       is.null <- base::is.null
[09:31:33.342]                       muffled <- FALSE
[09:31:33.342]                       if (inherits(cond, "message")) {
[09:31:33.342]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.342]                         if (muffled) 
[09:31:33.342]                           invokeRestart("muffleMessage")
[09:31:33.342]                       }
[09:31:33.342]                       else if (inherits(cond, "warning")) {
[09:31:33.342]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.342]                         if (muffled) 
[09:31:33.342]                           invokeRestart("muffleWarning")
[09:31:33.342]                       }
[09:31:33.342]                       else if (inherits(cond, "condition")) {
[09:31:33.342]                         if (!is.null(pattern)) {
[09:31:33.342]                           computeRestarts <- base::computeRestarts
[09:31:33.342]                           grepl <- base::grepl
[09:31:33.342]                           restarts <- computeRestarts(cond)
[09:31:33.342]                           for (restart in restarts) {
[09:31:33.342]                             name <- restart$name
[09:31:33.342]                             if (is.null(name)) 
[09:31:33.342]                               next
[09:31:33.342]                             if (!grepl(pattern, name)) 
[09:31:33.342]                               next
[09:31:33.342]                             invokeRestart(restart)
[09:31:33.342]                             muffled <- TRUE
[09:31:33.342]                             break
[09:31:33.342]                           }
[09:31:33.342]                         }
[09:31:33.342]                       }
[09:31:33.342]                       invisible(muffled)
[09:31:33.342]                     }
[09:31:33.342]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.342]                   }
[09:31:33.342]                 }
[09:31:33.342]                 else {
[09:31:33.342]                   if (TRUE) {
[09:31:33.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.342]                     {
[09:31:33.342]                       inherits <- base::inherits
[09:31:33.342]                       invokeRestart <- base::invokeRestart
[09:31:33.342]                       is.null <- base::is.null
[09:31:33.342]                       muffled <- FALSE
[09:31:33.342]                       if (inherits(cond, "message")) {
[09:31:33.342]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.342]                         if (muffled) 
[09:31:33.342]                           invokeRestart("muffleMessage")
[09:31:33.342]                       }
[09:31:33.342]                       else if (inherits(cond, "warning")) {
[09:31:33.342]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.342]                         if (muffled) 
[09:31:33.342]                           invokeRestart("muffleWarning")
[09:31:33.342]                       }
[09:31:33.342]                       else if (inherits(cond, "condition")) {
[09:31:33.342]                         if (!is.null(pattern)) {
[09:31:33.342]                           computeRestarts <- base::computeRestarts
[09:31:33.342]                           grepl <- base::grepl
[09:31:33.342]                           restarts <- computeRestarts(cond)
[09:31:33.342]                           for (restart in restarts) {
[09:31:33.342]                             name <- restart$name
[09:31:33.342]                             if (is.null(name)) 
[09:31:33.342]                               next
[09:31:33.342]                             if (!grepl(pattern, name)) 
[09:31:33.342]                               next
[09:31:33.342]                             invokeRestart(restart)
[09:31:33.342]                             muffled <- TRUE
[09:31:33.342]                             break
[09:31:33.342]                           }
[09:31:33.342]                         }
[09:31:33.342]                       }
[09:31:33.342]                       invisible(muffled)
[09:31:33.342]                     }
[09:31:33.342]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.342]                   }
[09:31:33.342]                 }
[09:31:33.342]             }
[09:31:33.342]         }))
[09:31:33.342]     }, error = function(ex) {
[09:31:33.342]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.342]                 ...future.rng), started = ...future.startTime, 
[09:31:33.342]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.342]             version = "1.8"), class = "FutureResult")
[09:31:33.342]     }, finally = {
[09:31:33.342]         if (!identical(...future.workdir, getwd())) 
[09:31:33.342]             setwd(...future.workdir)
[09:31:33.342]         {
[09:31:33.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.342]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.342]             }
[09:31:33.342]             base::options(...future.oldOptions)
[09:31:33.342]             if (.Platform$OS.type == "windows") {
[09:31:33.342]                 old_names <- names(...future.oldEnvVars)
[09:31:33.342]                 envs <- base::Sys.getenv()
[09:31:33.342]                 names <- names(envs)
[09:31:33.342]                 common <- intersect(names, old_names)
[09:31:33.342]                 added <- setdiff(names, old_names)
[09:31:33.342]                 removed <- setdiff(old_names, names)
[09:31:33.342]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.342]                   envs[common]]
[09:31:33.342]                 NAMES <- toupper(changed)
[09:31:33.342]                 args <- list()
[09:31:33.342]                 for (kk in seq_along(NAMES)) {
[09:31:33.342]                   name <- changed[[kk]]
[09:31:33.342]                   NAME <- NAMES[[kk]]
[09:31:33.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.342]                     next
[09:31:33.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.342]                 }
[09:31:33.342]                 NAMES <- toupper(added)
[09:31:33.342]                 for (kk in seq_along(NAMES)) {
[09:31:33.342]                   name <- added[[kk]]
[09:31:33.342]                   NAME <- NAMES[[kk]]
[09:31:33.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.342]                     next
[09:31:33.342]                   args[[name]] <- ""
[09:31:33.342]                 }
[09:31:33.342]                 NAMES <- toupper(removed)
[09:31:33.342]                 for (kk in seq_along(NAMES)) {
[09:31:33.342]                   name <- removed[[kk]]
[09:31:33.342]                   NAME <- NAMES[[kk]]
[09:31:33.342]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.342]                     next
[09:31:33.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.342]                 }
[09:31:33.342]                 if (length(args) > 0) 
[09:31:33.342]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.342]             }
[09:31:33.342]             else {
[09:31:33.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.342]             }
[09:31:33.342]             {
[09:31:33.342]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.342]                   0L) {
[09:31:33.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.342]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.342]                   base::options(opts)
[09:31:33.342]                 }
[09:31:33.342]                 {
[09:31:33.342]                   {
[09:31:33.342]                     NULL
[09:31:33.342]                     RNGkind("Mersenne-Twister")
[09:31:33.342]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.342]                       inherits = FALSE)
[09:31:33.342]                   }
[09:31:33.342]                   options(future.plan = NULL)
[09:31:33.342]                   if (is.na(NA_character_)) 
[09:31:33.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.342]                     .init = FALSE)
[09:31:33.342]                 }
[09:31:33.342]             }
[09:31:33.342]         }
[09:31:33.342]     })
[09:31:33.342]     if (TRUE) {
[09:31:33.342]         base::sink(type = "output", split = FALSE)
[09:31:33.342]         if (TRUE) {
[09:31:33.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.342]         }
[09:31:33.342]         else {
[09:31:33.342]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.342]         }
[09:31:33.342]         base::close(...future.stdout)
[09:31:33.342]         ...future.stdout <- NULL
[09:31:33.342]     }
[09:31:33.342]     ...future.result$conditions <- ...future.conditions
[09:31:33.342]     ...future.result$finished <- base::Sys.time()
[09:31:33.342]     ...future.result
[09:31:33.342] }
[09:31:33.367] plan(): Setting new future strategy stack:
[09:31:33.368] List of future strategies:
[09:31:33.368] 1. sequential:
[09:31:33.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.368]    - tweaked: FALSE
[09:31:33.368]    - call: NULL
[09:31:33.368] plan(): nbrOfWorkers() = 1
[09:31:33.369] plan(): Setting new future strategy stack:
[09:31:33.369] List of future strategies:
[09:31:33.369] 1. sequential:
[09:31:33.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.369]    - tweaked: FALSE
[09:31:33.369]    - call: plan(strategy)
[09:31:33.369] plan(): nbrOfWorkers() = 1
[09:31:33.370] SequentialFuture started (and completed)
[09:31:33.370] - Launch lazy future ... done
[09:31:33.370] run() for ‘SequentialFuture’ ... done
[09:31:33.370] resolved() for ‘SequentialFuture’ ...
[09:31:33.370] - state: ‘finished’
[09:31:33.370] - run: TRUE
[09:31:33.370] - result: ‘FutureResult’
[09:31:33.370] resolved() for ‘SequentialFuture’ ... done
[09:31:33.370] Future #1
[09:31:33.371] resolved() for ‘SequentialFuture’ ...
[09:31:33.371] - state: ‘finished’
[09:31:33.371] - run: TRUE
[09:31:33.371] - result: ‘FutureResult’
[09:31:33.371] resolved() for ‘SequentialFuture’ ... done
[09:31:33.371] A SequentialFuture was resolved
[09:31:33.371]  length: 0 (resolved future 1)
[09:31:33.371] resolve() on list ... DONE
[09:31:33.371] - globals: [1] ‘a’
[09:31:33.371] Resolving futures part of globals (recursively) ... DONE
[09:31:33.373] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[09:31:33.373] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[09:31:33.374] - globals: [1] ‘a’
[09:31:33.374] - packages: [1] ‘future’
[09:31:33.374] getGlobalsAndPackages() ... DONE
[09:31:33.374] run() for ‘Future’ ...
[09:31:33.374] - state: ‘created’
[09:31:33.374] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.375] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.375]   - Field: ‘label’
[09:31:33.375]   - Field: ‘local’
[09:31:33.375]   - Field: ‘owner’
[09:31:33.375]   - Field: ‘envir’
[09:31:33.375]   - Field: ‘packages’
[09:31:33.375]   - Field: ‘gc’
[09:31:33.375]   - Field: ‘conditions’
[09:31:33.375]   - Field: ‘expr’
[09:31:33.375]   - Field: ‘uuid’
[09:31:33.376]   - Field: ‘seed’
[09:31:33.376]   - Field: ‘version’
[09:31:33.376]   - Field: ‘result’
[09:31:33.376]   - Field: ‘asynchronous’
[09:31:33.376]   - Field: ‘calls’
[09:31:33.376]   - Field: ‘globals’
[09:31:33.376]   - Field: ‘stdout’
[09:31:33.376]   - Field: ‘earlySignal’
[09:31:33.376]   - Field: ‘lazy’
[09:31:33.376]   - Field: ‘state’
[09:31:33.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.377] - Launch lazy future ...
[09:31:33.377] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.377] Packages needed by future strategies (n = 0): <none>
[09:31:33.377] {
[09:31:33.377]     {
[09:31:33.377]         {
[09:31:33.377]             ...future.startTime <- base::Sys.time()
[09:31:33.377]             {
[09:31:33.377]                 {
[09:31:33.377]                   {
[09:31:33.377]                     {
[09:31:33.377]                       base::local({
[09:31:33.377]                         has_future <- base::requireNamespace("future", 
[09:31:33.377]                           quietly = TRUE)
[09:31:33.377]                         if (has_future) {
[09:31:33.377]                           ns <- base::getNamespace("future")
[09:31:33.377]                           version <- ns[[".package"]][["version"]]
[09:31:33.377]                           if (is.null(version)) 
[09:31:33.377]                             version <- utils::packageVersion("future")
[09:31:33.377]                         }
[09:31:33.377]                         else {
[09:31:33.377]                           version <- NULL
[09:31:33.377]                         }
[09:31:33.377]                         if (!has_future || version < "1.8.0") {
[09:31:33.377]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.377]                             "", base::R.version$version.string), 
[09:31:33.377]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.377]                               "release", "version")], collapse = " "), 
[09:31:33.377]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.377]                             info)
[09:31:33.377]                           info <- base::paste(info, collapse = "; ")
[09:31:33.377]                           if (!has_future) {
[09:31:33.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.377]                               info)
[09:31:33.377]                           }
[09:31:33.377]                           else {
[09:31:33.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.377]                               info, version)
[09:31:33.377]                           }
[09:31:33.377]                           base::stop(msg)
[09:31:33.377]                         }
[09:31:33.377]                       })
[09:31:33.377]                     }
[09:31:33.377]                     base::local({
[09:31:33.377]                       for (pkg in "future") {
[09:31:33.377]                         base::loadNamespace(pkg)
[09:31:33.377]                         base::library(pkg, character.only = TRUE)
[09:31:33.377]                       }
[09:31:33.377]                     })
[09:31:33.377]                   }
[09:31:33.377]                   ...future.strategy.old <- future::plan("list")
[09:31:33.377]                   options(future.plan = NULL)
[09:31:33.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.377]                 }
[09:31:33.377]                 ...future.workdir <- getwd()
[09:31:33.377]             }
[09:31:33.377]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.377]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.377]         }
[09:31:33.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.377]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.377]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.377]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.377]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.377]             base::names(...future.oldOptions))
[09:31:33.377]     }
[09:31:33.377]     if (FALSE) {
[09:31:33.377]     }
[09:31:33.377]     else {
[09:31:33.377]         if (TRUE) {
[09:31:33.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.377]                 open = "w")
[09:31:33.377]         }
[09:31:33.377]         else {
[09:31:33.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.377]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.377]         }
[09:31:33.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.377]             base::sink(type = "output", split = FALSE)
[09:31:33.377]             base::close(...future.stdout)
[09:31:33.377]         }, add = TRUE)
[09:31:33.377]     }
[09:31:33.377]     ...future.frame <- base::sys.nframe()
[09:31:33.377]     ...future.conditions <- base::list()
[09:31:33.377]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.377]     if (FALSE) {
[09:31:33.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.377]     }
[09:31:33.377]     ...future.result <- base::tryCatch({
[09:31:33.377]         base::withCallingHandlers({
[09:31:33.377]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.377]                 1))
[09:31:33.377]             future::FutureResult(value = ...future.value$value, 
[09:31:33.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.377]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.377]                     ...future.globalenv.names))
[09:31:33.377]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.377]         }, condition = base::local({
[09:31:33.377]             c <- base::c
[09:31:33.377]             inherits <- base::inherits
[09:31:33.377]             invokeRestart <- base::invokeRestart
[09:31:33.377]             length <- base::length
[09:31:33.377]             list <- base::list
[09:31:33.377]             seq.int <- base::seq.int
[09:31:33.377]             signalCondition <- base::signalCondition
[09:31:33.377]             sys.calls <- base::sys.calls
[09:31:33.377]             `[[` <- base::`[[`
[09:31:33.377]             `+` <- base::`+`
[09:31:33.377]             `<<-` <- base::`<<-`
[09:31:33.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.377]                   3L)]
[09:31:33.377]             }
[09:31:33.377]             function(cond) {
[09:31:33.377]                 is_error <- inherits(cond, "error")
[09:31:33.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.377]                   NULL)
[09:31:33.377]                 if (is_error) {
[09:31:33.377]                   sessionInformation <- function() {
[09:31:33.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.377]                       search = base::search(), system = base::Sys.info())
[09:31:33.377]                   }
[09:31:33.377]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.377]                     cond$call), session = sessionInformation(), 
[09:31:33.377]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.377]                   signalCondition(cond)
[09:31:33.377]                 }
[09:31:33.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.377]                 "immediateCondition"))) {
[09:31:33.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.377]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.377]                   if (TRUE && !signal) {
[09:31:33.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.377]                     {
[09:31:33.377]                       inherits <- base::inherits
[09:31:33.377]                       invokeRestart <- base::invokeRestart
[09:31:33.377]                       is.null <- base::is.null
[09:31:33.377]                       muffled <- FALSE
[09:31:33.377]                       if (inherits(cond, "message")) {
[09:31:33.377]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.377]                         if (muffled) 
[09:31:33.377]                           invokeRestart("muffleMessage")
[09:31:33.377]                       }
[09:31:33.377]                       else if (inherits(cond, "warning")) {
[09:31:33.377]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.377]                         if (muffled) 
[09:31:33.377]                           invokeRestart("muffleWarning")
[09:31:33.377]                       }
[09:31:33.377]                       else if (inherits(cond, "condition")) {
[09:31:33.377]                         if (!is.null(pattern)) {
[09:31:33.377]                           computeRestarts <- base::computeRestarts
[09:31:33.377]                           grepl <- base::grepl
[09:31:33.377]                           restarts <- computeRestarts(cond)
[09:31:33.377]                           for (restart in restarts) {
[09:31:33.377]                             name <- restart$name
[09:31:33.377]                             if (is.null(name)) 
[09:31:33.377]                               next
[09:31:33.377]                             if (!grepl(pattern, name)) 
[09:31:33.377]                               next
[09:31:33.377]                             invokeRestart(restart)
[09:31:33.377]                             muffled <- TRUE
[09:31:33.377]                             break
[09:31:33.377]                           }
[09:31:33.377]                         }
[09:31:33.377]                       }
[09:31:33.377]                       invisible(muffled)
[09:31:33.377]                     }
[09:31:33.377]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.377]                   }
[09:31:33.377]                 }
[09:31:33.377]                 else {
[09:31:33.377]                   if (TRUE) {
[09:31:33.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.377]                     {
[09:31:33.377]                       inherits <- base::inherits
[09:31:33.377]                       invokeRestart <- base::invokeRestart
[09:31:33.377]                       is.null <- base::is.null
[09:31:33.377]                       muffled <- FALSE
[09:31:33.377]                       if (inherits(cond, "message")) {
[09:31:33.377]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.377]                         if (muffled) 
[09:31:33.377]                           invokeRestart("muffleMessage")
[09:31:33.377]                       }
[09:31:33.377]                       else if (inherits(cond, "warning")) {
[09:31:33.377]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.377]                         if (muffled) 
[09:31:33.377]                           invokeRestart("muffleWarning")
[09:31:33.377]                       }
[09:31:33.377]                       else if (inherits(cond, "condition")) {
[09:31:33.377]                         if (!is.null(pattern)) {
[09:31:33.377]                           computeRestarts <- base::computeRestarts
[09:31:33.377]                           grepl <- base::grepl
[09:31:33.377]                           restarts <- computeRestarts(cond)
[09:31:33.377]                           for (restart in restarts) {
[09:31:33.377]                             name <- restart$name
[09:31:33.377]                             if (is.null(name)) 
[09:31:33.377]                               next
[09:31:33.377]                             if (!grepl(pattern, name)) 
[09:31:33.377]                               next
[09:31:33.377]                             invokeRestart(restart)
[09:31:33.377]                             muffled <- TRUE
[09:31:33.377]                             break
[09:31:33.377]                           }
[09:31:33.377]                         }
[09:31:33.377]                       }
[09:31:33.377]                       invisible(muffled)
[09:31:33.377]                     }
[09:31:33.377]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.377]                   }
[09:31:33.377]                 }
[09:31:33.377]             }
[09:31:33.377]         }))
[09:31:33.377]     }, error = function(ex) {
[09:31:33.377]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.377]                 ...future.rng), started = ...future.startTime, 
[09:31:33.377]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.377]             version = "1.8"), class = "FutureResult")
[09:31:33.377]     }, finally = {
[09:31:33.377]         if (!identical(...future.workdir, getwd())) 
[09:31:33.377]             setwd(...future.workdir)
[09:31:33.377]         {
[09:31:33.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.377]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.377]             }
[09:31:33.377]             base::options(...future.oldOptions)
[09:31:33.377]             if (.Platform$OS.type == "windows") {
[09:31:33.377]                 old_names <- names(...future.oldEnvVars)
[09:31:33.377]                 envs <- base::Sys.getenv()
[09:31:33.377]                 names <- names(envs)
[09:31:33.377]                 common <- intersect(names, old_names)
[09:31:33.377]                 added <- setdiff(names, old_names)
[09:31:33.377]                 removed <- setdiff(old_names, names)
[09:31:33.377]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.377]                   envs[common]]
[09:31:33.377]                 NAMES <- toupper(changed)
[09:31:33.377]                 args <- list()
[09:31:33.377]                 for (kk in seq_along(NAMES)) {
[09:31:33.377]                   name <- changed[[kk]]
[09:31:33.377]                   NAME <- NAMES[[kk]]
[09:31:33.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.377]                     next
[09:31:33.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.377]                 }
[09:31:33.377]                 NAMES <- toupper(added)
[09:31:33.377]                 for (kk in seq_along(NAMES)) {
[09:31:33.377]                   name <- added[[kk]]
[09:31:33.377]                   NAME <- NAMES[[kk]]
[09:31:33.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.377]                     next
[09:31:33.377]                   args[[name]] <- ""
[09:31:33.377]                 }
[09:31:33.377]                 NAMES <- toupper(removed)
[09:31:33.377]                 for (kk in seq_along(NAMES)) {
[09:31:33.377]                   name <- removed[[kk]]
[09:31:33.377]                   NAME <- NAMES[[kk]]
[09:31:33.377]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.377]                     next
[09:31:33.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.377]                 }
[09:31:33.377]                 if (length(args) > 0) 
[09:31:33.377]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.377]             }
[09:31:33.377]             else {
[09:31:33.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.377]             }
[09:31:33.377]             {
[09:31:33.377]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.377]                   0L) {
[09:31:33.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.377]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.377]                   base::options(opts)
[09:31:33.377]                 }
[09:31:33.377]                 {
[09:31:33.377]                   {
[09:31:33.377]                     NULL
[09:31:33.377]                     RNGkind("Mersenne-Twister")
[09:31:33.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.377]                       inherits = FALSE)
[09:31:33.377]                   }
[09:31:33.377]                   options(future.plan = NULL)
[09:31:33.377]                   if (is.na(NA_character_)) 
[09:31:33.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.377]                     .init = FALSE)
[09:31:33.377]                 }
[09:31:33.377]             }
[09:31:33.377]         }
[09:31:33.377]     })
[09:31:33.377]     if (TRUE) {
[09:31:33.377]         base::sink(type = "output", split = FALSE)
[09:31:33.377]         if (TRUE) {
[09:31:33.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.377]         }
[09:31:33.377]         else {
[09:31:33.377]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.377]         }
[09:31:33.377]         base::close(...future.stdout)
[09:31:33.377]         ...future.stdout <- NULL
[09:31:33.377]     }
[09:31:33.377]     ...future.result$conditions <- ...future.conditions
[09:31:33.377]     ...future.result$finished <- base::Sys.time()
[09:31:33.377]     ...future.result
[09:31:33.377] }
[09:31:33.379] assign_globals() ...
[09:31:33.379] List of 1
[09:31:33.379]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a60bc10> 
[09:31:33.379]  - attr(*, "where")=List of 1
[09:31:33.379]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.379]  - attr(*, "resolved")= logi TRUE
[09:31:33.379]  - attr(*, "total_size")= num 1622440
[09:31:33.379]  - attr(*, "already-done")= logi TRUE
[09:31:33.381] - copied ‘a’ to environment
[09:31:33.381] assign_globals() ... done
[09:31:33.382] plan(): Setting new future strategy stack:
[09:31:33.382] List of future strategies:
[09:31:33.382] 1. sequential:
[09:31:33.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.382]    - tweaked: FALSE
[09:31:33.382]    - call: NULL
[09:31:33.382] plan(): nbrOfWorkers() = 1
[09:31:33.383] plan(): Setting new future strategy stack:
[09:31:33.383] List of future strategies:
[09:31:33.383] 1. sequential:
[09:31:33.383]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.383]    - tweaked: FALSE
[09:31:33.383]    - call: plan(strategy)
[09:31:33.383] plan(): nbrOfWorkers() = 1
[09:31:33.384] SequentialFuture started (and completed)
[09:31:33.384] - Launch lazy future ... done
[09:31:33.384] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.384] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.384] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.385] 
[09:31:33.385] Searching for globals ... DONE
[09:31:33.385] - globals: [0] <none>
[09:31:33.385] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.385] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.386] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.386] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.386] Searching for globals ... DONE
[09:31:33.387] Resolving globals: TRUE
[09:31:33.387] Resolving any globals that are futures ...
[09:31:33.387] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.387] Resolving any globals that are futures ... DONE
[09:31:33.387] Resolving futures part of globals (recursively) ...
[09:31:33.387] resolve() on list ...
[09:31:33.387]  recursive: 99
[09:31:33.387]  length: 1
[09:31:33.388]  elements: ‘a’
[09:31:33.388] run() for ‘Future’ ...
[09:31:33.388] - state: ‘created’
[09:31:33.388] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.388] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.388]   - Field: ‘label’
[09:31:33.388]   - Field: ‘local’
[09:31:33.389]   - Field: ‘owner’
[09:31:33.389]   - Field: ‘envir’
[09:31:33.389]   - Field: ‘packages’
[09:31:33.389]   - Field: ‘gc’
[09:31:33.389]   - Field: ‘conditions’
[09:31:33.389]   - Field: ‘expr’
[09:31:33.389]   - Field: ‘uuid’
[09:31:33.389]   - Field: ‘seed’
[09:31:33.389]   - Field: ‘version’
[09:31:33.389]   - Field: ‘result’
[09:31:33.389]   - Field: ‘asynchronous’
[09:31:33.390]   - Field: ‘calls’
[09:31:33.390]   - Field: ‘globals’
[09:31:33.390]   - Field: ‘stdout’
[09:31:33.390]   - Field: ‘earlySignal’
[09:31:33.390]   - Field: ‘lazy’
[09:31:33.390]   - Field: ‘state’
[09:31:33.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.390] - Launch lazy future ...
[09:31:33.390] Packages needed by the future expression (n = 0): <none>
[09:31:33.390] Packages needed by future strategies (n = 0): <none>
[09:31:33.391] {
[09:31:33.391]     {
[09:31:33.391]         {
[09:31:33.391]             ...future.startTime <- base::Sys.time()
[09:31:33.391]             {
[09:31:33.391]                 {
[09:31:33.391]                   {
[09:31:33.391]                     base::local({
[09:31:33.391]                       has_future <- base::requireNamespace("future", 
[09:31:33.391]                         quietly = TRUE)
[09:31:33.391]                       if (has_future) {
[09:31:33.391]                         ns <- base::getNamespace("future")
[09:31:33.391]                         version <- ns[[".package"]][["version"]]
[09:31:33.391]                         if (is.null(version)) 
[09:31:33.391]                           version <- utils::packageVersion("future")
[09:31:33.391]                       }
[09:31:33.391]                       else {
[09:31:33.391]                         version <- NULL
[09:31:33.391]                       }
[09:31:33.391]                       if (!has_future || version < "1.8.0") {
[09:31:33.391]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.391]                           "", base::R.version$version.string), 
[09:31:33.391]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.391]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.391]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.391]                             "release", "version")], collapse = " "), 
[09:31:33.391]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.391]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.391]                           info)
[09:31:33.391]                         info <- base::paste(info, collapse = "; ")
[09:31:33.391]                         if (!has_future) {
[09:31:33.391]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.391]                             info)
[09:31:33.391]                         }
[09:31:33.391]                         else {
[09:31:33.391]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.391]                             info, version)
[09:31:33.391]                         }
[09:31:33.391]                         base::stop(msg)
[09:31:33.391]                       }
[09:31:33.391]                     })
[09:31:33.391]                   }
[09:31:33.391]                   ...future.strategy.old <- future::plan("list")
[09:31:33.391]                   options(future.plan = NULL)
[09:31:33.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.391]                 }
[09:31:33.391]                 ...future.workdir <- getwd()
[09:31:33.391]             }
[09:31:33.391]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.391]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.391]         }
[09:31:33.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.391]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.391]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.391]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.391]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.391]             base::names(...future.oldOptions))
[09:31:33.391]     }
[09:31:33.391]     if (FALSE) {
[09:31:33.391]     }
[09:31:33.391]     else {
[09:31:33.391]         if (TRUE) {
[09:31:33.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.391]                 open = "w")
[09:31:33.391]         }
[09:31:33.391]         else {
[09:31:33.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.391]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.391]         }
[09:31:33.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.391]             base::sink(type = "output", split = FALSE)
[09:31:33.391]             base::close(...future.stdout)
[09:31:33.391]         }, add = TRUE)
[09:31:33.391]     }
[09:31:33.391]     ...future.frame <- base::sys.nframe()
[09:31:33.391]     ...future.conditions <- base::list()
[09:31:33.391]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.391]     if (FALSE) {
[09:31:33.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.391]     }
[09:31:33.391]     ...future.result <- base::tryCatch({
[09:31:33.391]         base::withCallingHandlers({
[09:31:33.391]             ...future.value <- base::withVisible(base::local(1))
[09:31:33.391]             future::FutureResult(value = ...future.value$value, 
[09:31:33.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.391]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.391]                     ...future.globalenv.names))
[09:31:33.391]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.391]         }, condition = base::local({
[09:31:33.391]             c <- base::c
[09:31:33.391]             inherits <- base::inherits
[09:31:33.391]             invokeRestart <- base::invokeRestart
[09:31:33.391]             length <- base::length
[09:31:33.391]             list <- base::list
[09:31:33.391]             seq.int <- base::seq.int
[09:31:33.391]             signalCondition <- base::signalCondition
[09:31:33.391]             sys.calls <- base::sys.calls
[09:31:33.391]             `[[` <- base::`[[`
[09:31:33.391]             `+` <- base::`+`
[09:31:33.391]             `<<-` <- base::`<<-`
[09:31:33.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.391]                   3L)]
[09:31:33.391]             }
[09:31:33.391]             function(cond) {
[09:31:33.391]                 is_error <- inherits(cond, "error")
[09:31:33.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.391]                   NULL)
[09:31:33.391]                 if (is_error) {
[09:31:33.391]                   sessionInformation <- function() {
[09:31:33.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.391]                       search = base::search(), system = base::Sys.info())
[09:31:33.391]                   }
[09:31:33.391]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.391]                     cond$call), session = sessionInformation(), 
[09:31:33.391]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.391]                   signalCondition(cond)
[09:31:33.391]                 }
[09:31:33.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.391]                 "immediateCondition"))) {
[09:31:33.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.391]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.391]                   if (TRUE && !signal) {
[09:31:33.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.391]                     {
[09:31:33.391]                       inherits <- base::inherits
[09:31:33.391]                       invokeRestart <- base::invokeRestart
[09:31:33.391]                       is.null <- base::is.null
[09:31:33.391]                       muffled <- FALSE
[09:31:33.391]                       if (inherits(cond, "message")) {
[09:31:33.391]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.391]                         if (muffled) 
[09:31:33.391]                           invokeRestart("muffleMessage")
[09:31:33.391]                       }
[09:31:33.391]                       else if (inherits(cond, "warning")) {
[09:31:33.391]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.391]                         if (muffled) 
[09:31:33.391]                           invokeRestart("muffleWarning")
[09:31:33.391]                       }
[09:31:33.391]                       else if (inherits(cond, "condition")) {
[09:31:33.391]                         if (!is.null(pattern)) {
[09:31:33.391]                           computeRestarts <- base::computeRestarts
[09:31:33.391]                           grepl <- base::grepl
[09:31:33.391]                           restarts <- computeRestarts(cond)
[09:31:33.391]                           for (restart in restarts) {
[09:31:33.391]                             name <- restart$name
[09:31:33.391]                             if (is.null(name)) 
[09:31:33.391]                               next
[09:31:33.391]                             if (!grepl(pattern, name)) 
[09:31:33.391]                               next
[09:31:33.391]                             invokeRestart(restart)
[09:31:33.391]                             muffled <- TRUE
[09:31:33.391]                             break
[09:31:33.391]                           }
[09:31:33.391]                         }
[09:31:33.391]                       }
[09:31:33.391]                       invisible(muffled)
[09:31:33.391]                     }
[09:31:33.391]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.391]                   }
[09:31:33.391]                 }
[09:31:33.391]                 else {
[09:31:33.391]                   if (TRUE) {
[09:31:33.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.391]                     {
[09:31:33.391]                       inherits <- base::inherits
[09:31:33.391]                       invokeRestart <- base::invokeRestart
[09:31:33.391]                       is.null <- base::is.null
[09:31:33.391]                       muffled <- FALSE
[09:31:33.391]                       if (inherits(cond, "message")) {
[09:31:33.391]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.391]                         if (muffled) 
[09:31:33.391]                           invokeRestart("muffleMessage")
[09:31:33.391]                       }
[09:31:33.391]                       else if (inherits(cond, "warning")) {
[09:31:33.391]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.391]                         if (muffled) 
[09:31:33.391]                           invokeRestart("muffleWarning")
[09:31:33.391]                       }
[09:31:33.391]                       else if (inherits(cond, "condition")) {
[09:31:33.391]                         if (!is.null(pattern)) {
[09:31:33.391]                           computeRestarts <- base::computeRestarts
[09:31:33.391]                           grepl <- base::grepl
[09:31:33.391]                           restarts <- computeRestarts(cond)
[09:31:33.391]                           for (restart in restarts) {
[09:31:33.391]                             name <- restart$name
[09:31:33.391]                             if (is.null(name)) 
[09:31:33.391]                               next
[09:31:33.391]                             if (!grepl(pattern, name)) 
[09:31:33.391]                               next
[09:31:33.391]                             invokeRestart(restart)
[09:31:33.391]                             muffled <- TRUE
[09:31:33.391]                             break
[09:31:33.391]                           }
[09:31:33.391]                         }
[09:31:33.391]                       }
[09:31:33.391]                       invisible(muffled)
[09:31:33.391]                     }
[09:31:33.391]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.391]                   }
[09:31:33.391]                 }
[09:31:33.391]             }
[09:31:33.391]         }))
[09:31:33.391]     }, error = function(ex) {
[09:31:33.391]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.391]                 ...future.rng), started = ...future.startTime, 
[09:31:33.391]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.391]             version = "1.8"), class = "FutureResult")
[09:31:33.391]     }, finally = {
[09:31:33.391]         if (!identical(...future.workdir, getwd())) 
[09:31:33.391]             setwd(...future.workdir)
[09:31:33.391]         {
[09:31:33.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.391]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.391]             }
[09:31:33.391]             base::options(...future.oldOptions)
[09:31:33.391]             if (.Platform$OS.type == "windows") {
[09:31:33.391]                 old_names <- names(...future.oldEnvVars)
[09:31:33.391]                 envs <- base::Sys.getenv()
[09:31:33.391]                 names <- names(envs)
[09:31:33.391]                 common <- intersect(names, old_names)
[09:31:33.391]                 added <- setdiff(names, old_names)
[09:31:33.391]                 removed <- setdiff(old_names, names)
[09:31:33.391]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.391]                   envs[common]]
[09:31:33.391]                 NAMES <- toupper(changed)
[09:31:33.391]                 args <- list()
[09:31:33.391]                 for (kk in seq_along(NAMES)) {
[09:31:33.391]                   name <- changed[[kk]]
[09:31:33.391]                   NAME <- NAMES[[kk]]
[09:31:33.391]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.391]                     next
[09:31:33.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.391]                 }
[09:31:33.391]                 NAMES <- toupper(added)
[09:31:33.391]                 for (kk in seq_along(NAMES)) {
[09:31:33.391]                   name <- added[[kk]]
[09:31:33.391]                   NAME <- NAMES[[kk]]
[09:31:33.391]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.391]                     next
[09:31:33.391]                   args[[name]] <- ""
[09:31:33.391]                 }
[09:31:33.391]                 NAMES <- toupper(removed)
[09:31:33.391]                 for (kk in seq_along(NAMES)) {
[09:31:33.391]                   name <- removed[[kk]]
[09:31:33.391]                   NAME <- NAMES[[kk]]
[09:31:33.391]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.391]                     next
[09:31:33.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.391]                 }
[09:31:33.391]                 if (length(args) > 0) 
[09:31:33.391]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.391]             }
[09:31:33.391]             else {
[09:31:33.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.391]             }
[09:31:33.391]             {
[09:31:33.391]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.391]                   0L) {
[09:31:33.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.391]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.391]                   base::options(opts)
[09:31:33.391]                 }
[09:31:33.391]                 {
[09:31:33.391]                   {
[09:31:33.391]                     NULL
[09:31:33.391]                     RNGkind("Mersenne-Twister")
[09:31:33.391]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.391]                       inherits = FALSE)
[09:31:33.391]                   }
[09:31:33.391]                   options(future.plan = NULL)
[09:31:33.391]                   if (is.na(NA_character_)) 
[09:31:33.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.391]                     .init = FALSE)
[09:31:33.391]                 }
[09:31:33.391]             }
[09:31:33.391]         }
[09:31:33.391]     })
[09:31:33.391]     if (TRUE) {
[09:31:33.391]         base::sink(type = "output", split = FALSE)
[09:31:33.391]         if (TRUE) {
[09:31:33.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.391]         }
[09:31:33.391]         else {
[09:31:33.391]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.391]         }
[09:31:33.391]         base::close(...future.stdout)
[09:31:33.391]         ...future.stdout <- NULL
[09:31:33.391]     }
[09:31:33.391]     ...future.result$conditions <- ...future.conditions
[09:31:33.391]     ...future.result$finished <- base::Sys.time()
[09:31:33.391]     ...future.result
[09:31:33.391] }
[09:31:33.393] plan(): Setting new future strategy stack:
[09:31:33.393] List of future strategies:
[09:31:33.393] 1. sequential:
[09:31:33.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.393]    - tweaked: FALSE
[09:31:33.393]    - call: NULL
[09:31:33.393] plan(): nbrOfWorkers() = 1
[09:31:33.394] plan(): Setting new future strategy stack:
[09:31:33.394] List of future strategies:
[09:31:33.394] 1. sequential:
[09:31:33.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.394]    - tweaked: FALSE
[09:31:33.394]    - call: plan(strategy)
[09:31:33.394] plan(): nbrOfWorkers() = 1
[09:31:33.394] SequentialFuture started (and completed)
[09:31:33.394] - Launch lazy future ... done
[09:31:33.395] run() for ‘SequentialFuture’ ... done
[09:31:33.395] resolved() for ‘SequentialFuture’ ...
[09:31:33.395] - state: ‘finished’
[09:31:33.395] - run: TRUE
[09:31:33.395] - result: ‘FutureResult’
[09:31:33.395] resolved() for ‘SequentialFuture’ ... done
[09:31:33.395] Future #1
[09:31:33.395] resolved() for ‘SequentialFuture’ ...
[09:31:33.395] - state: ‘finished’
[09:31:33.396] - run: TRUE
[09:31:33.396] - result: ‘FutureResult’
[09:31:33.397] resolved() for ‘SequentialFuture’ ... done
[09:31:33.397] A SequentialFuture was resolved
[09:31:33.397]  length: 0 (resolved future 1)
[09:31:33.397] resolve() on list ... DONE
[09:31:33.397] - globals: [1] ‘a’
[09:31:33.397] Resolving futures part of globals (recursively) ... DONE
[09:31:33.399] The total size of the 1 globals is 1.55 MiB (1622440 bytes)
[09:31:33.399] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.55 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.55 MiB of class ‘environment’)
[09:31:33.399] - globals: [1] ‘a’
[09:31:33.399] - packages: [1] ‘future’
[09:31:33.399] getGlobalsAndPackages() ... DONE
[09:31:33.400] run() for ‘Future’ ...
[09:31:33.400] - state: ‘created’
[09:31:33.400] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.400]   - Field: ‘label’
[09:31:33.400]   - Field: ‘local’
[09:31:33.401]   - Field: ‘owner’
[09:31:33.401]   - Field: ‘envir’
[09:31:33.401]   - Field: ‘packages’
[09:31:33.401]   - Field: ‘gc’
[09:31:33.401]   - Field: ‘conditions’
[09:31:33.401]   - Field: ‘expr’
[09:31:33.401]   - Field: ‘uuid’
[09:31:33.401]   - Field: ‘seed’
[09:31:33.401]   - Field: ‘version’
[09:31:33.401]   - Field: ‘result’
[09:31:33.401]   - Field: ‘asynchronous’
[09:31:33.401]   - Field: ‘calls’
[09:31:33.402]   - Field: ‘globals’
[09:31:33.402]   - Field: ‘stdout’
[09:31:33.402]   - Field: ‘earlySignal’
[09:31:33.402]   - Field: ‘lazy’
[09:31:33.402]   - Field: ‘state’
[09:31:33.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.402] - Launch lazy future ...
[09:31:33.402] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.402] Packages needed by future strategies (n = 0): <none>
[09:31:33.403] {
[09:31:33.403]     {
[09:31:33.403]         {
[09:31:33.403]             ...future.startTime <- base::Sys.time()
[09:31:33.403]             {
[09:31:33.403]                 {
[09:31:33.403]                   {
[09:31:33.403]                     {
[09:31:33.403]                       base::local({
[09:31:33.403]                         has_future <- base::requireNamespace("future", 
[09:31:33.403]                           quietly = TRUE)
[09:31:33.403]                         if (has_future) {
[09:31:33.403]                           ns <- base::getNamespace("future")
[09:31:33.403]                           version <- ns[[".package"]][["version"]]
[09:31:33.403]                           if (is.null(version)) 
[09:31:33.403]                             version <- utils::packageVersion("future")
[09:31:33.403]                         }
[09:31:33.403]                         else {
[09:31:33.403]                           version <- NULL
[09:31:33.403]                         }
[09:31:33.403]                         if (!has_future || version < "1.8.0") {
[09:31:33.403]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.403]                             "", base::R.version$version.string), 
[09:31:33.403]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.403]                               "release", "version")], collapse = " "), 
[09:31:33.403]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.403]                             info)
[09:31:33.403]                           info <- base::paste(info, collapse = "; ")
[09:31:33.403]                           if (!has_future) {
[09:31:33.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.403]                               info)
[09:31:33.403]                           }
[09:31:33.403]                           else {
[09:31:33.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.403]                               info, version)
[09:31:33.403]                           }
[09:31:33.403]                           base::stop(msg)
[09:31:33.403]                         }
[09:31:33.403]                       })
[09:31:33.403]                     }
[09:31:33.403]                     base::local({
[09:31:33.403]                       for (pkg in "future") {
[09:31:33.403]                         base::loadNamespace(pkg)
[09:31:33.403]                         base::library(pkg, character.only = TRUE)
[09:31:33.403]                       }
[09:31:33.403]                     })
[09:31:33.403]                   }
[09:31:33.403]                   ...future.strategy.old <- future::plan("list")
[09:31:33.403]                   options(future.plan = NULL)
[09:31:33.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.403]                 }
[09:31:33.403]                 ...future.workdir <- getwd()
[09:31:33.403]             }
[09:31:33.403]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.403]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.403]         }
[09:31:33.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.403]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.403]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.403]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.403]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.403]             base::names(...future.oldOptions))
[09:31:33.403]     }
[09:31:33.403]     if (FALSE) {
[09:31:33.403]     }
[09:31:33.403]     else {
[09:31:33.403]         if (TRUE) {
[09:31:33.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.403]                 open = "w")
[09:31:33.403]         }
[09:31:33.403]         else {
[09:31:33.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.403]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.403]         }
[09:31:33.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.403]             base::sink(type = "output", split = FALSE)
[09:31:33.403]             base::close(...future.stdout)
[09:31:33.403]         }, add = TRUE)
[09:31:33.403]     }
[09:31:33.403]     ...future.frame <- base::sys.nframe()
[09:31:33.403]     ...future.conditions <- base::list()
[09:31:33.403]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.403]     if (FALSE) {
[09:31:33.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.403]     }
[09:31:33.403]     ...future.result <- base::tryCatch({
[09:31:33.403]         base::withCallingHandlers({
[09:31:33.403]             ...future.value <- base::withVisible(base::local(value(a) + 
[09:31:33.403]                 1))
[09:31:33.403]             future::FutureResult(value = ...future.value$value, 
[09:31:33.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.403]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.403]                     ...future.globalenv.names))
[09:31:33.403]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.403]         }, condition = base::local({
[09:31:33.403]             c <- base::c
[09:31:33.403]             inherits <- base::inherits
[09:31:33.403]             invokeRestart <- base::invokeRestart
[09:31:33.403]             length <- base::length
[09:31:33.403]             list <- base::list
[09:31:33.403]             seq.int <- base::seq.int
[09:31:33.403]             signalCondition <- base::signalCondition
[09:31:33.403]             sys.calls <- base::sys.calls
[09:31:33.403]             `[[` <- base::`[[`
[09:31:33.403]             `+` <- base::`+`
[09:31:33.403]             `<<-` <- base::`<<-`
[09:31:33.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.403]                   3L)]
[09:31:33.403]             }
[09:31:33.403]             function(cond) {
[09:31:33.403]                 is_error <- inherits(cond, "error")
[09:31:33.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.403]                   NULL)
[09:31:33.403]                 if (is_error) {
[09:31:33.403]                   sessionInformation <- function() {
[09:31:33.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.403]                       search = base::search(), system = base::Sys.info())
[09:31:33.403]                   }
[09:31:33.403]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.403]                     cond$call), session = sessionInformation(), 
[09:31:33.403]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.403]                   signalCondition(cond)
[09:31:33.403]                 }
[09:31:33.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.403]                 "immediateCondition"))) {
[09:31:33.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.403]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.403]                   if (TRUE && !signal) {
[09:31:33.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.403]                     {
[09:31:33.403]                       inherits <- base::inherits
[09:31:33.403]                       invokeRestart <- base::invokeRestart
[09:31:33.403]                       is.null <- base::is.null
[09:31:33.403]                       muffled <- FALSE
[09:31:33.403]                       if (inherits(cond, "message")) {
[09:31:33.403]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.403]                         if (muffled) 
[09:31:33.403]                           invokeRestart("muffleMessage")
[09:31:33.403]                       }
[09:31:33.403]                       else if (inherits(cond, "warning")) {
[09:31:33.403]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.403]                         if (muffled) 
[09:31:33.403]                           invokeRestart("muffleWarning")
[09:31:33.403]                       }
[09:31:33.403]                       else if (inherits(cond, "condition")) {
[09:31:33.403]                         if (!is.null(pattern)) {
[09:31:33.403]                           computeRestarts <- base::computeRestarts
[09:31:33.403]                           grepl <- base::grepl
[09:31:33.403]                           restarts <- computeRestarts(cond)
[09:31:33.403]                           for (restart in restarts) {
[09:31:33.403]                             name <- restart$name
[09:31:33.403]                             if (is.null(name)) 
[09:31:33.403]                               next
[09:31:33.403]                             if (!grepl(pattern, name)) 
[09:31:33.403]                               next
[09:31:33.403]                             invokeRestart(restart)
[09:31:33.403]                             muffled <- TRUE
[09:31:33.403]                             break
[09:31:33.403]                           }
[09:31:33.403]                         }
[09:31:33.403]                       }
[09:31:33.403]                       invisible(muffled)
[09:31:33.403]                     }
[09:31:33.403]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.403]                   }
[09:31:33.403]                 }
[09:31:33.403]                 else {
[09:31:33.403]                   if (TRUE) {
[09:31:33.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.403]                     {
[09:31:33.403]                       inherits <- base::inherits
[09:31:33.403]                       invokeRestart <- base::invokeRestart
[09:31:33.403]                       is.null <- base::is.null
[09:31:33.403]                       muffled <- FALSE
[09:31:33.403]                       if (inherits(cond, "message")) {
[09:31:33.403]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.403]                         if (muffled) 
[09:31:33.403]                           invokeRestart("muffleMessage")
[09:31:33.403]                       }
[09:31:33.403]                       else if (inherits(cond, "warning")) {
[09:31:33.403]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.403]                         if (muffled) 
[09:31:33.403]                           invokeRestart("muffleWarning")
[09:31:33.403]                       }
[09:31:33.403]                       else if (inherits(cond, "condition")) {
[09:31:33.403]                         if (!is.null(pattern)) {
[09:31:33.403]                           computeRestarts <- base::computeRestarts
[09:31:33.403]                           grepl <- base::grepl
[09:31:33.403]                           restarts <- computeRestarts(cond)
[09:31:33.403]                           for (restart in restarts) {
[09:31:33.403]                             name <- restart$name
[09:31:33.403]                             if (is.null(name)) 
[09:31:33.403]                               next
[09:31:33.403]                             if (!grepl(pattern, name)) 
[09:31:33.403]                               next
[09:31:33.403]                             invokeRestart(restart)
[09:31:33.403]                             muffled <- TRUE
[09:31:33.403]                             break
[09:31:33.403]                           }
[09:31:33.403]                         }
[09:31:33.403]                       }
[09:31:33.403]                       invisible(muffled)
[09:31:33.403]                     }
[09:31:33.403]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.403]                   }
[09:31:33.403]                 }
[09:31:33.403]             }
[09:31:33.403]         }))
[09:31:33.403]     }, error = function(ex) {
[09:31:33.403]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.403]                 ...future.rng), started = ...future.startTime, 
[09:31:33.403]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.403]             version = "1.8"), class = "FutureResult")
[09:31:33.403]     }, finally = {
[09:31:33.403]         if (!identical(...future.workdir, getwd())) 
[09:31:33.403]             setwd(...future.workdir)
[09:31:33.403]         {
[09:31:33.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.403]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.403]             }
[09:31:33.403]             base::options(...future.oldOptions)
[09:31:33.403]             if (.Platform$OS.type == "windows") {
[09:31:33.403]                 old_names <- names(...future.oldEnvVars)
[09:31:33.403]                 envs <- base::Sys.getenv()
[09:31:33.403]                 names <- names(envs)
[09:31:33.403]                 common <- intersect(names, old_names)
[09:31:33.403]                 added <- setdiff(names, old_names)
[09:31:33.403]                 removed <- setdiff(old_names, names)
[09:31:33.403]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.403]                   envs[common]]
[09:31:33.403]                 NAMES <- toupper(changed)
[09:31:33.403]                 args <- list()
[09:31:33.403]                 for (kk in seq_along(NAMES)) {
[09:31:33.403]                   name <- changed[[kk]]
[09:31:33.403]                   NAME <- NAMES[[kk]]
[09:31:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.403]                     next
[09:31:33.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.403]                 }
[09:31:33.403]                 NAMES <- toupper(added)
[09:31:33.403]                 for (kk in seq_along(NAMES)) {
[09:31:33.403]                   name <- added[[kk]]
[09:31:33.403]                   NAME <- NAMES[[kk]]
[09:31:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.403]                     next
[09:31:33.403]                   args[[name]] <- ""
[09:31:33.403]                 }
[09:31:33.403]                 NAMES <- toupper(removed)
[09:31:33.403]                 for (kk in seq_along(NAMES)) {
[09:31:33.403]                   name <- removed[[kk]]
[09:31:33.403]                   NAME <- NAMES[[kk]]
[09:31:33.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.403]                     next
[09:31:33.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.403]                 }
[09:31:33.403]                 if (length(args) > 0) 
[09:31:33.403]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.403]             }
[09:31:33.403]             else {
[09:31:33.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.403]             }
[09:31:33.403]             {
[09:31:33.403]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.403]                   0L) {
[09:31:33.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.403]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.403]                   base::options(opts)
[09:31:33.403]                 }
[09:31:33.403]                 {
[09:31:33.403]                   {
[09:31:33.403]                     NULL
[09:31:33.403]                     RNGkind("Mersenne-Twister")
[09:31:33.403]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.403]                       inherits = FALSE)
[09:31:33.403]                   }
[09:31:33.403]                   options(future.plan = NULL)
[09:31:33.403]                   if (is.na(NA_character_)) 
[09:31:33.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.403]                     .init = FALSE)
[09:31:33.403]                 }
[09:31:33.403]             }
[09:31:33.403]         }
[09:31:33.403]     })
[09:31:33.403]     if (TRUE) {
[09:31:33.403]         base::sink(type = "output", split = FALSE)
[09:31:33.403]         if (TRUE) {
[09:31:33.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.403]         }
[09:31:33.403]         else {
[09:31:33.403]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.403]         }
[09:31:33.403]         base::close(...future.stdout)
[09:31:33.403]         ...future.stdout <- NULL
[09:31:33.403]     }
[09:31:33.403]     ...future.result$conditions <- ...future.conditions
[09:31:33.403]     ...future.result$finished <- base::Sys.time()
[09:31:33.403]     ...future.result
[09:31:33.403] }
[09:31:33.404] assign_globals() ...
[09:31:33.404] List of 1
[09:31:33.404]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e21a49a5d8> 
[09:31:33.404]  - attr(*, "where")=List of 1
[09:31:33.404]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.404]  - attr(*, "resolved")= logi TRUE
[09:31:33.404]  - attr(*, "total_size")= num 1622440
[09:31:33.404]  - attr(*, "already-done")= logi TRUE
[09:31:33.407] - copied ‘a’ to environment
[09:31:33.407] assign_globals() ... done
[09:31:33.407] plan(): Setting new future strategy stack:
[09:31:33.407] List of future strategies:
[09:31:33.407] 1. sequential:
[09:31:33.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.407]    - tweaked: FALSE
[09:31:33.407]    - call: NULL
[09:31:33.408] plan(): nbrOfWorkers() = 1
[09:31:33.408] plan(): Setting new future strategy stack:
[09:31:33.408] List of future strategies:
[09:31:33.408] 1. sequential:
[09:31:33.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.408]    - tweaked: FALSE
[09:31:33.408]    - call: plan(strategy)
[09:31:33.409] plan(): nbrOfWorkers() = 1
[09:31:33.409] SequentialFuture started (and completed)
[09:31:33.409] - Launch lazy future ... done
[09:31:33.409] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.410] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.410] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.410] - globals found: [2] ‘{’, ‘pkg’
[09:31:33.411] Searching for globals ... DONE
[09:31:33.411] Resolving globals: TRUE
[09:31:33.411] Resolving any globals that are futures ...
[09:31:33.411] - globals: [2] ‘{’, ‘pkg’
[09:31:33.411] Resolving any globals that are futures ... DONE
[09:31:33.411] Resolving futures part of globals (recursively) ...
[09:31:33.411] resolve() on list ...
[09:31:33.411]  recursive: 99
[09:31:33.412]  length: 1
[09:31:33.412]  elements: ‘pkg’
[09:31:33.412]  length: 0 (resolved future 1)
[09:31:33.412] resolve() on list ... DONE
[09:31:33.412] - globals: [1] ‘pkg’
[09:31:33.412] Resolving futures part of globals (recursively) ... DONE
[09:31:33.412] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:33.412] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:33.413] - globals: [1] ‘pkg’
[09:31:33.413] 
[09:31:33.413] getGlobalsAndPackages() ... DONE
[09:31:33.413] Packages needed by the future expression (n = 0): <none>
[09:31:33.413] Packages needed by future strategies (n = 0): <none>
[09:31:33.413] {
[09:31:33.413]     {
[09:31:33.413]         {
[09:31:33.413]             ...future.startTime <- base::Sys.time()
[09:31:33.413]             {
[09:31:33.413]                 {
[09:31:33.413]                   {
[09:31:33.413]                     base::local({
[09:31:33.413]                       has_future <- base::requireNamespace("future", 
[09:31:33.413]                         quietly = TRUE)
[09:31:33.413]                       if (has_future) {
[09:31:33.413]                         ns <- base::getNamespace("future")
[09:31:33.413]                         version <- ns[[".package"]][["version"]]
[09:31:33.413]                         if (is.null(version)) 
[09:31:33.413]                           version <- utils::packageVersion("future")
[09:31:33.413]                       }
[09:31:33.413]                       else {
[09:31:33.413]                         version <- NULL
[09:31:33.413]                       }
[09:31:33.413]                       if (!has_future || version < "1.8.0") {
[09:31:33.413]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.413]                           "", base::R.version$version.string), 
[09:31:33.413]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.413]                             "release", "version")], collapse = " "), 
[09:31:33.413]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.413]                           info)
[09:31:33.413]                         info <- base::paste(info, collapse = "; ")
[09:31:33.413]                         if (!has_future) {
[09:31:33.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.413]                             info)
[09:31:33.413]                         }
[09:31:33.413]                         else {
[09:31:33.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.413]                             info, version)
[09:31:33.413]                         }
[09:31:33.413]                         base::stop(msg)
[09:31:33.413]                       }
[09:31:33.413]                     })
[09:31:33.413]                   }
[09:31:33.413]                   ...future.strategy.old <- future::plan("list")
[09:31:33.413]                   options(future.plan = NULL)
[09:31:33.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.413]                 }
[09:31:33.413]                 ...future.workdir <- getwd()
[09:31:33.413]             }
[09:31:33.413]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.413]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.413]         }
[09:31:33.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.413]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.413]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.413]             base::names(...future.oldOptions))
[09:31:33.413]     }
[09:31:33.413]     if (FALSE) {
[09:31:33.413]     }
[09:31:33.413]     else {
[09:31:33.413]         if (TRUE) {
[09:31:33.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.413]                 open = "w")
[09:31:33.413]         }
[09:31:33.413]         else {
[09:31:33.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.413]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.413]         }
[09:31:33.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.413]             base::sink(type = "output", split = FALSE)
[09:31:33.413]             base::close(...future.stdout)
[09:31:33.413]         }, add = TRUE)
[09:31:33.413]     }
[09:31:33.413]     ...future.frame <- base::sys.nframe()
[09:31:33.413]     ...future.conditions <- base::list()
[09:31:33.413]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.413]     if (FALSE) {
[09:31:33.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.413]     }
[09:31:33.413]     ...future.result <- base::tryCatch({
[09:31:33.413]         base::withCallingHandlers({
[09:31:33.413]             ...future.value <- base::withVisible(base::local({
[09:31:33.413]                 pkg
[09:31:33.413]             }))
[09:31:33.413]             future::FutureResult(value = ...future.value$value, 
[09:31:33.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.413]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.413]                     ...future.globalenv.names))
[09:31:33.413]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.413]         }, condition = base::local({
[09:31:33.413]             c <- base::c
[09:31:33.413]             inherits <- base::inherits
[09:31:33.413]             invokeRestart <- base::invokeRestart
[09:31:33.413]             length <- base::length
[09:31:33.413]             list <- base::list
[09:31:33.413]             seq.int <- base::seq.int
[09:31:33.413]             signalCondition <- base::signalCondition
[09:31:33.413]             sys.calls <- base::sys.calls
[09:31:33.413]             `[[` <- base::`[[`
[09:31:33.413]             `+` <- base::`+`
[09:31:33.413]             `<<-` <- base::`<<-`
[09:31:33.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.413]                   3L)]
[09:31:33.413]             }
[09:31:33.413]             function(cond) {
[09:31:33.413]                 is_error <- inherits(cond, "error")
[09:31:33.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.413]                   NULL)
[09:31:33.413]                 if (is_error) {
[09:31:33.413]                   sessionInformation <- function() {
[09:31:33.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.413]                       search = base::search(), system = base::Sys.info())
[09:31:33.413]                   }
[09:31:33.413]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.413]                     cond$call), session = sessionInformation(), 
[09:31:33.413]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.413]                   signalCondition(cond)
[09:31:33.413]                 }
[09:31:33.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.413]                 "immediateCondition"))) {
[09:31:33.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.413]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.413]                   if (TRUE && !signal) {
[09:31:33.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.413]                     {
[09:31:33.413]                       inherits <- base::inherits
[09:31:33.413]                       invokeRestart <- base::invokeRestart
[09:31:33.413]                       is.null <- base::is.null
[09:31:33.413]                       muffled <- FALSE
[09:31:33.413]                       if (inherits(cond, "message")) {
[09:31:33.413]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.413]                         if (muffled) 
[09:31:33.413]                           invokeRestart("muffleMessage")
[09:31:33.413]                       }
[09:31:33.413]                       else if (inherits(cond, "warning")) {
[09:31:33.413]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.413]                         if (muffled) 
[09:31:33.413]                           invokeRestart("muffleWarning")
[09:31:33.413]                       }
[09:31:33.413]                       else if (inherits(cond, "condition")) {
[09:31:33.413]                         if (!is.null(pattern)) {
[09:31:33.413]                           computeRestarts <- base::computeRestarts
[09:31:33.413]                           grepl <- base::grepl
[09:31:33.413]                           restarts <- computeRestarts(cond)
[09:31:33.413]                           for (restart in restarts) {
[09:31:33.413]                             name <- restart$name
[09:31:33.413]                             if (is.null(name)) 
[09:31:33.413]                               next
[09:31:33.413]                             if (!grepl(pattern, name)) 
[09:31:33.413]                               next
[09:31:33.413]                             invokeRestart(restart)
[09:31:33.413]                             muffled <- TRUE
[09:31:33.413]                             break
[09:31:33.413]                           }
[09:31:33.413]                         }
[09:31:33.413]                       }
[09:31:33.413]                       invisible(muffled)
[09:31:33.413]                     }
[09:31:33.413]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.413]                   }
[09:31:33.413]                 }
[09:31:33.413]                 else {
[09:31:33.413]                   if (TRUE) {
[09:31:33.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.413]                     {
[09:31:33.413]                       inherits <- base::inherits
[09:31:33.413]                       invokeRestart <- base::invokeRestart
[09:31:33.413]                       is.null <- base::is.null
[09:31:33.413]                       muffled <- FALSE
[09:31:33.413]                       if (inherits(cond, "message")) {
[09:31:33.413]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.413]                         if (muffled) 
[09:31:33.413]                           invokeRestart("muffleMessage")
[09:31:33.413]                       }
[09:31:33.413]                       else if (inherits(cond, "warning")) {
[09:31:33.413]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.413]                         if (muffled) 
[09:31:33.413]                           invokeRestart("muffleWarning")
[09:31:33.413]                       }
[09:31:33.413]                       else if (inherits(cond, "condition")) {
[09:31:33.413]                         if (!is.null(pattern)) {
[09:31:33.413]                           computeRestarts <- base::computeRestarts
[09:31:33.413]                           grepl <- base::grepl
[09:31:33.413]                           restarts <- computeRestarts(cond)
[09:31:33.413]                           for (restart in restarts) {
[09:31:33.413]                             name <- restart$name
[09:31:33.413]                             if (is.null(name)) 
[09:31:33.413]                               next
[09:31:33.413]                             if (!grepl(pattern, name)) 
[09:31:33.413]                               next
[09:31:33.413]                             invokeRestart(restart)
[09:31:33.413]                             muffled <- TRUE
[09:31:33.413]                             break
[09:31:33.413]                           }
[09:31:33.413]                         }
[09:31:33.413]                       }
[09:31:33.413]                       invisible(muffled)
[09:31:33.413]                     }
[09:31:33.413]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.413]                   }
[09:31:33.413]                 }
[09:31:33.413]             }
[09:31:33.413]         }))
[09:31:33.413]     }, error = function(ex) {
[09:31:33.413]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.413]                 ...future.rng), started = ...future.startTime, 
[09:31:33.413]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.413]             version = "1.8"), class = "FutureResult")
[09:31:33.413]     }, finally = {
[09:31:33.413]         if (!identical(...future.workdir, getwd())) 
[09:31:33.413]             setwd(...future.workdir)
[09:31:33.413]         {
[09:31:33.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.413]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.413]             }
[09:31:33.413]             base::options(...future.oldOptions)
[09:31:33.413]             if (.Platform$OS.type == "windows") {
[09:31:33.413]                 old_names <- names(...future.oldEnvVars)
[09:31:33.413]                 envs <- base::Sys.getenv()
[09:31:33.413]                 names <- names(envs)
[09:31:33.413]                 common <- intersect(names, old_names)
[09:31:33.413]                 added <- setdiff(names, old_names)
[09:31:33.413]                 removed <- setdiff(old_names, names)
[09:31:33.413]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.413]                   envs[common]]
[09:31:33.413]                 NAMES <- toupper(changed)
[09:31:33.413]                 args <- list()
[09:31:33.413]                 for (kk in seq_along(NAMES)) {
[09:31:33.413]                   name <- changed[[kk]]
[09:31:33.413]                   NAME <- NAMES[[kk]]
[09:31:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.413]                     next
[09:31:33.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.413]                 }
[09:31:33.413]                 NAMES <- toupper(added)
[09:31:33.413]                 for (kk in seq_along(NAMES)) {
[09:31:33.413]                   name <- added[[kk]]
[09:31:33.413]                   NAME <- NAMES[[kk]]
[09:31:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.413]                     next
[09:31:33.413]                   args[[name]] <- ""
[09:31:33.413]                 }
[09:31:33.413]                 NAMES <- toupper(removed)
[09:31:33.413]                 for (kk in seq_along(NAMES)) {
[09:31:33.413]                   name <- removed[[kk]]
[09:31:33.413]                   NAME <- NAMES[[kk]]
[09:31:33.413]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.413]                     next
[09:31:33.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.413]                 }
[09:31:33.413]                 if (length(args) > 0) 
[09:31:33.413]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.413]             }
[09:31:33.413]             else {
[09:31:33.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.413]             }
[09:31:33.413]             {
[09:31:33.413]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.413]                   0L) {
[09:31:33.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.413]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.413]                   base::options(opts)
[09:31:33.413]                 }
[09:31:33.413]                 {
[09:31:33.413]                   {
[09:31:33.413]                     NULL
[09:31:33.413]                     RNGkind("Mersenne-Twister")
[09:31:33.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.413]                       inherits = FALSE)
[09:31:33.413]                   }
[09:31:33.413]                   options(future.plan = NULL)
[09:31:33.413]                   if (is.na(NA_character_)) 
[09:31:33.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.413]                     .init = FALSE)
[09:31:33.413]                 }
[09:31:33.413]             }
[09:31:33.413]         }
[09:31:33.413]     })
[09:31:33.413]     if (TRUE) {
[09:31:33.413]         base::sink(type = "output", split = FALSE)
[09:31:33.413]         if (TRUE) {
[09:31:33.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.413]         }
[09:31:33.413]         else {
[09:31:33.413]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.413]         }
[09:31:33.413]         base::close(...future.stdout)
[09:31:33.413]         ...future.stdout <- NULL
[09:31:33.413]     }
[09:31:33.413]     ...future.result$conditions <- ...future.conditions
[09:31:33.413]     ...future.result$finished <- base::Sys.time()
[09:31:33.413]     ...future.result
[09:31:33.413] }
[09:31:33.415] assign_globals() ...
[09:31:33.415] List of 1
[09:31:33.415]  $ pkg: chr "foo"
[09:31:33.415]  - attr(*, "where")=List of 1
[09:31:33.415]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:33.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.415]  - attr(*, "resolved")= logi TRUE
[09:31:33.415]  - attr(*, "total_size")= num 112
[09:31:33.417] - copied ‘pkg’ to environment
[09:31:33.417] assign_globals() ... done
[09:31:33.417] plan(): Setting new future strategy stack:
[09:31:33.417] List of future strategies:
[09:31:33.417] 1. sequential:
[09:31:33.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.417]    - tweaked: FALSE
[09:31:33.417]    - call: NULL
[09:31:33.418] plan(): nbrOfWorkers() = 1
[09:31:33.418] plan(): Setting new future strategy stack:
[09:31:33.419] List of future strategies:
[09:31:33.419] 1. sequential:
[09:31:33.419]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.419]    - tweaked: FALSE
[09:31:33.419]    - call: plan(strategy)
[09:31:33.419] plan(): nbrOfWorkers() = 1
[09:31:33.419] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.420] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.420] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.421] - globals found: [3] ‘{’, ‘<-’, ‘+’
[09:31:33.421] Searching for globals ... DONE
[09:31:33.422] Resolving globals: TRUE
[09:31:33.422] Resolving any globals that are futures ...
[09:31:33.422] - globals: [3] ‘{’, ‘<-’, ‘+’
[09:31:33.422] Resolving any globals that are futures ... DONE
[09:31:33.422] 
[09:31:33.422] 
[09:31:33.422] getGlobalsAndPackages() ... DONE
[09:31:33.422] run() for ‘Future’ ...
[09:31:33.423] - state: ‘created’
[09:31:33.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.424] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.424]   - Field: ‘label’
[09:31:33.424]   - Field: ‘local’
[09:31:33.424]   - Field: ‘owner’
[09:31:33.424]   - Field: ‘envir’
[09:31:33.424]   - Field: ‘packages’
[09:31:33.424]   - Field: ‘gc’
[09:31:33.424]   - Field: ‘conditions’
[09:31:33.425]   - Field: ‘expr’
[09:31:33.425]   - Field: ‘uuid’
[09:31:33.425]   - Field: ‘seed’
[09:31:33.425]   - Field: ‘version’
[09:31:33.425]   - Field: ‘result’
[09:31:33.425]   - Field: ‘asynchronous’
[09:31:33.425]   - Field: ‘calls’
[09:31:33.425]   - Field: ‘globals’
[09:31:33.425]   - Field: ‘stdout’
[09:31:33.425]   - Field: ‘earlySignal’
[09:31:33.425]   - Field: ‘lazy’
[09:31:33.426]   - Field: ‘state’
[09:31:33.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.426] - Launch lazy future ...
[09:31:33.426] Packages needed by the future expression (n = 0): <none>
[09:31:33.426] Packages needed by future strategies (n = 0): <none>
[09:31:33.426] {
[09:31:33.426]     {
[09:31:33.426]         {
[09:31:33.426]             ...future.startTime <- base::Sys.time()
[09:31:33.426]             {
[09:31:33.426]                 {
[09:31:33.426]                   {
[09:31:33.426]                     base::local({
[09:31:33.426]                       has_future <- base::requireNamespace("future", 
[09:31:33.426]                         quietly = TRUE)
[09:31:33.426]                       if (has_future) {
[09:31:33.426]                         ns <- base::getNamespace("future")
[09:31:33.426]                         version <- ns[[".package"]][["version"]]
[09:31:33.426]                         if (is.null(version)) 
[09:31:33.426]                           version <- utils::packageVersion("future")
[09:31:33.426]                       }
[09:31:33.426]                       else {
[09:31:33.426]                         version <- NULL
[09:31:33.426]                       }
[09:31:33.426]                       if (!has_future || version < "1.8.0") {
[09:31:33.426]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.426]                           "", base::R.version$version.string), 
[09:31:33.426]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.426]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.426]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.426]                             "release", "version")], collapse = " "), 
[09:31:33.426]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.426]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.426]                           info)
[09:31:33.426]                         info <- base::paste(info, collapse = "; ")
[09:31:33.426]                         if (!has_future) {
[09:31:33.426]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.426]                             info)
[09:31:33.426]                         }
[09:31:33.426]                         else {
[09:31:33.426]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.426]                             info, version)
[09:31:33.426]                         }
[09:31:33.426]                         base::stop(msg)
[09:31:33.426]                       }
[09:31:33.426]                     })
[09:31:33.426]                   }
[09:31:33.426]                   ...future.strategy.old <- future::plan("list")
[09:31:33.426]                   options(future.plan = NULL)
[09:31:33.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.426]                 }
[09:31:33.426]                 ...future.workdir <- getwd()
[09:31:33.426]             }
[09:31:33.426]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.426]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.426]         }
[09:31:33.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.426]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.426]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.426]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.426]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.426]             base::names(...future.oldOptions))
[09:31:33.426]     }
[09:31:33.426]     if (FALSE) {
[09:31:33.426]     }
[09:31:33.426]     else {
[09:31:33.426]         if (TRUE) {
[09:31:33.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.426]                 open = "w")
[09:31:33.426]         }
[09:31:33.426]         else {
[09:31:33.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.426]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.426]         }
[09:31:33.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.426]             base::sink(type = "output", split = FALSE)
[09:31:33.426]             base::close(...future.stdout)
[09:31:33.426]         }, add = TRUE)
[09:31:33.426]     }
[09:31:33.426]     ...future.frame <- base::sys.nframe()
[09:31:33.426]     ...future.conditions <- base::list()
[09:31:33.426]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.426]     if (FALSE) {
[09:31:33.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.426]     }
[09:31:33.426]     ...future.result <- base::tryCatch({
[09:31:33.426]         base::withCallingHandlers({
[09:31:33.426]             ...future.value <- base::withVisible(base::local({
[09:31:33.426]                 x <- 0
[09:31:33.426]                 x <- x + 1
[09:31:33.426]                 x
[09:31:33.426]             }))
[09:31:33.426]             future::FutureResult(value = ...future.value$value, 
[09:31:33.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.426]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.426]                     ...future.globalenv.names))
[09:31:33.426]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.426]         }, condition = base::local({
[09:31:33.426]             c <- base::c
[09:31:33.426]             inherits <- base::inherits
[09:31:33.426]             invokeRestart <- base::invokeRestart
[09:31:33.426]             length <- base::length
[09:31:33.426]             list <- base::list
[09:31:33.426]             seq.int <- base::seq.int
[09:31:33.426]             signalCondition <- base::signalCondition
[09:31:33.426]             sys.calls <- base::sys.calls
[09:31:33.426]             `[[` <- base::`[[`
[09:31:33.426]             `+` <- base::`+`
[09:31:33.426]             `<<-` <- base::`<<-`
[09:31:33.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.426]                   3L)]
[09:31:33.426]             }
[09:31:33.426]             function(cond) {
[09:31:33.426]                 is_error <- inherits(cond, "error")
[09:31:33.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.426]                   NULL)
[09:31:33.426]                 if (is_error) {
[09:31:33.426]                   sessionInformation <- function() {
[09:31:33.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.426]                       search = base::search(), system = base::Sys.info())
[09:31:33.426]                   }
[09:31:33.426]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.426]                     cond$call), session = sessionInformation(), 
[09:31:33.426]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.426]                   signalCondition(cond)
[09:31:33.426]                 }
[09:31:33.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.426]                 "immediateCondition"))) {
[09:31:33.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.426]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.426]                   if (TRUE && !signal) {
[09:31:33.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.426]                     {
[09:31:33.426]                       inherits <- base::inherits
[09:31:33.426]                       invokeRestart <- base::invokeRestart
[09:31:33.426]                       is.null <- base::is.null
[09:31:33.426]                       muffled <- FALSE
[09:31:33.426]                       if (inherits(cond, "message")) {
[09:31:33.426]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.426]                         if (muffled) 
[09:31:33.426]                           invokeRestart("muffleMessage")
[09:31:33.426]                       }
[09:31:33.426]                       else if (inherits(cond, "warning")) {
[09:31:33.426]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.426]                         if (muffled) 
[09:31:33.426]                           invokeRestart("muffleWarning")
[09:31:33.426]                       }
[09:31:33.426]                       else if (inherits(cond, "condition")) {
[09:31:33.426]                         if (!is.null(pattern)) {
[09:31:33.426]                           computeRestarts <- base::computeRestarts
[09:31:33.426]                           grepl <- base::grepl
[09:31:33.426]                           restarts <- computeRestarts(cond)
[09:31:33.426]                           for (restart in restarts) {
[09:31:33.426]                             name <- restart$name
[09:31:33.426]                             if (is.null(name)) 
[09:31:33.426]                               next
[09:31:33.426]                             if (!grepl(pattern, name)) 
[09:31:33.426]                               next
[09:31:33.426]                             invokeRestart(restart)
[09:31:33.426]                             muffled <- TRUE
[09:31:33.426]                             break
[09:31:33.426]                           }
[09:31:33.426]                         }
[09:31:33.426]                       }
[09:31:33.426]                       invisible(muffled)
[09:31:33.426]                     }
[09:31:33.426]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.426]                   }
[09:31:33.426]                 }
[09:31:33.426]                 else {
[09:31:33.426]                   if (TRUE) {
[09:31:33.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.426]                     {
[09:31:33.426]                       inherits <- base::inherits
[09:31:33.426]                       invokeRestart <- base::invokeRestart
[09:31:33.426]                       is.null <- base::is.null
[09:31:33.426]                       muffled <- FALSE
[09:31:33.426]                       if (inherits(cond, "message")) {
[09:31:33.426]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.426]                         if (muffled) 
[09:31:33.426]                           invokeRestart("muffleMessage")
[09:31:33.426]                       }
[09:31:33.426]                       else if (inherits(cond, "warning")) {
[09:31:33.426]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.426]                         if (muffled) 
[09:31:33.426]                           invokeRestart("muffleWarning")
[09:31:33.426]                       }
[09:31:33.426]                       else if (inherits(cond, "condition")) {
[09:31:33.426]                         if (!is.null(pattern)) {
[09:31:33.426]                           computeRestarts <- base::computeRestarts
[09:31:33.426]                           grepl <- base::grepl
[09:31:33.426]                           restarts <- computeRestarts(cond)
[09:31:33.426]                           for (restart in restarts) {
[09:31:33.426]                             name <- restart$name
[09:31:33.426]                             if (is.null(name)) 
[09:31:33.426]                               next
[09:31:33.426]                             if (!grepl(pattern, name)) 
[09:31:33.426]                               next
[09:31:33.426]                             invokeRestart(restart)
[09:31:33.426]                             muffled <- TRUE
[09:31:33.426]                             break
[09:31:33.426]                           }
[09:31:33.426]                         }
[09:31:33.426]                       }
[09:31:33.426]                       invisible(muffled)
[09:31:33.426]                     }
[09:31:33.426]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.426]                   }
[09:31:33.426]                 }
[09:31:33.426]             }
[09:31:33.426]         }))
[09:31:33.426]     }, error = function(ex) {
[09:31:33.426]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.426]                 ...future.rng), started = ...future.startTime, 
[09:31:33.426]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.426]             version = "1.8"), class = "FutureResult")
[09:31:33.426]     }, finally = {
[09:31:33.426]         if (!identical(...future.workdir, getwd())) 
[09:31:33.426]             setwd(...future.workdir)
[09:31:33.426]         {
[09:31:33.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.426]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.426]             }
[09:31:33.426]             base::options(...future.oldOptions)
[09:31:33.426]             if (.Platform$OS.type == "windows") {
[09:31:33.426]                 old_names <- names(...future.oldEnvVars)
[09:31:33.426]                 envs <- base::Sys.getenv()
[09:31:33.426]                 names <- names(envs)
[09:31:33.426]                 common <- intersect(names, old_names)
[09:31:33.426]                 added <- setdiff(names, old_names)
[09:31:33.426]                 removed <- setdiff(old_names, names)
[09:31:33.426]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.426]                   envs[common]]
[09:31:33.426]                 NAMES <- toupper(changed)
[09:31:33.426]                 args <- list()
[09:31:33.426]                 for (kk in seq_along(NAMES)) {
[09:31:33.426]                   name <- changed[[kk]]
[09:31:33.426]                   NAME <- NAMES[[kk]]
[09:31:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.426]                     next
[09:31:33.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.426]                 }
[09:31:33.426]                 NAMES <- toupper(added)
[09:31:33.426]                 for (kk in seq_along(NAMES)) {
[09:31:33.426]                   name <- added[[kk]]
[09:31:33.426]                   NAME <- NAMES[[kk]]
[09:31:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.426]                     next
[09:31:33.426]                   args[[name]] <- ""
[09:31:33.426]                 }
[09:31:33.426]                 NAMES <- toupper(removed)
[09:31:33.426]                 for (kk in seq_along(NAMES)) {
[09:31:33.426]                   name <- removed[[kk]]
[09:31:33.426]                   NAME <- NAMES[[kk]]
[09:31:33.426]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.426]                     next
[09:31:33.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.426]                 }
[09:31:33.426]                 if (length(args) > 0) 
[09:31:33.426]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.426]             }
[09:31:33.426]             else {
[09:31:33.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.426]             }
[09:31:33.426]             {
[09:31:33.426]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.426]                   0L) {
[09:31:33.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.426]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.426]                   base::options(opts)
[09:31:33.426]                 }
[09:31:33.426]                 {
[09:31:33.426]                   {
[09:31:33.426]                     NULL
[09:31:33.426]                     RNGkind("Mersenne-Twister")
[09:31:33.426]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.426]                       inherits = FALSE)
[09:31:33.426]                   }
[09:31:33.426]                   options(future.plan = NULL)
[09:31:33.426]                   if (is.na(NA_character_)) 
[09:31:33.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.426]                     .init = FALSE)
[09:31:33.426]                 }
[09:31:33.426]             }
[09:31:33.426]         }
[09:31:33.426]     })
[09:31:33.426]     if (TRUE) {
[09:31:33.426]         base::sink(type = "output", split = FALSE)
[09:31:33.426]         if (TRUE) {
[09:31:33.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.426]         }
[09:31:33.426]         else {
[09:31:33.426]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.426]         }
[09:31:33.426]         base::close(...future.stdout)
[09:31:33.426]         ...future.stdout <- NULL
[09:31:33.426]     }
[09:31:33.426]     ...future.result$conditions <- ...future.conditions
[09:31:33.426]     ...future.result$finished <- base::Sys.time()
[09:31:33.426]     ...future.result
[09:31:33.426] }
[09:31:33.428] plan(): Setting new future strategy stack:
[09:31:33.428] List of future strategies:
[09:31:33.428] 1. sequential:
[09:31:33.428]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.428]    - tweaked: FALSE
[09:31:33.428]    - call: NULL
[09:31:33.428] plan(): nbrOfWorkers() = 1
[09:31:33.429] plan(): Setting new future strategy stack:
[09:31:33.429] List of future strategies:
[09:31:33.429] 1. sequential:
[09:31:33.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.429]    - tweaked: FALSE
[09:31:33.429]    - call: plan(strategy)
[09:31:33.430] plan(): nbrOfWorkers() = 1
[09:31:33.430] SequentialFuture started (and completed)
[09:31:33.430] - Launch lazy future ... done
[09:31:33.430] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.430] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.431] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.432] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:33.432] Searching for globals ... DONE
[09:31:33.432] Resolving globals: TRUE
[09:31:33.432] Resolving any globals that are futures ...
[09:31:33.432] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:33.432] Resolving any globals that are futures ... DONE
[09:31:33.433] Resolving futures part of globals (recursively) ...
[09:31:33.433] resolve() on list ...
[09:31:33.433]  recursive: 99
[09:31:33.433]  length: 1
[09:31:33.433]  elements: ‘x’
[09:31:33.433]  length: 0 (resolved future 1)
[09:31:33.433] resolve() on list ... DONE
[09:31:33.433] - globals: [1] ‘x’
[09:31:33.433] Resolving futures part of globals (recursively) ... DONE
[09:31:33.433] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.434] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[09:31:33.434] - globals: [1] ‘x’
[09:31:33.434] 
[09:31:33.434] getGlobalsAndPackages() ... DONE
[09:31:33.434] run() for ‘Future’ ...
[09:31:33.434] - state: ‘created’
[09:31:33.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.435] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.435]   - Field: ‘label’
[09:31:33.435]   - Field: ‘local’
[09:31:33.435]   - Field: ‘owner’
[09:31:33.435]   - Field: ‘envir’
[09:31:33.435]   - Field: ‘packages’
[09:31:33.435]   - Field: ‘gc’
[09:31:33.435]   - Field: ‘conditions’
[09:31:33.436]   - Field: ‘expr’
[09:31:33.436]   - Field: ‘uuid’
[09:31:33.436]   - Field: ‘seed’
[09:31:33.436]   - Field: ‘version’
[09:31:33.436]   - Field: ‘result’
[09:31:33.436]   - Field: ‘asynchronous’
[09:31:33.436]   - Field: ‘calls’
[09:31:33.436]   - Field: ‘globals’
[09:31:33.436]   - Field: ‘stdout’
[09:31:33.436]   - Field: ‘earlySignal’
[09:31:33.436]   - Field: ‘lazy’
[09:31:33.436]   - Field: ‘state’
[09:31:33.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.437] - Launch lazy future ...
[09:31:33.437] Packages needed by the future expression (n = 0): <none>
[09:31:33.437] Packages needed by future strategies (n = 0): <none>
[09:31:33.437] {
[09:31:33.437]     {
[09:31:33.437]         {
[09:31:33.437]             ...future.startTime <- base::Sys.time()
[09:31:33.437]             {
[09:31:33.437]                 {
[09:31:33.437]                   {
[09:31:33.437]                     base::local({
[09:31:33.437]                       has_future <- base::requireNamespace("future", 
[09:31:33.437]                         quietly = TRUE)
[09:31:33.437]                       if (has_future) {
[09:31:33.437]                         ns <- base::getNamespace("future")
[09:31:33.437]                         version <- ns[[".package"]][["version"]]
[09:31:33.437]                         if (is.null(version)) 
[09:31:33.437]                           version <- utils::packageVersion("future")
[09:31:33.437]                       }
[09:31:33.437]                       else {
[09:31:33.437]                         version <- NULL
[09:31:33.437]                       }
[09:31:33.437]                       if (!has_future || version < "1.8.0") {
[09:31:33.437]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.437]                           "", base::R.version$version.string), 
[09:31:33.437]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.437]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.437]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.437]                             "release", "version")], collapse = " "), 
[09:31:33.437]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.437]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.437]                           info)
[09:31:33.437]                         info <- base::paste(info, collapse = "; ")
[09:31:33.437]                         if (!has_future) {
[09:31:33.437]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.437]                             info)
[09:31:33.437]                         }
[09:31:33.437]                         else {
[09:31:33.437]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.437]                             info, version)
[09:31:33.437]                         }
[09:31:33.437]                         base::stop(msg)
[09:31:33.437]                       }
[09:31:33.437]                     })
[09:31:33.437]                   }
[09:31:33.437]                   ...future.strategy.old <- future::plan("list")
[09:31:33.437]                   options(future.plan = NULL)
[09:31:33.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.437]                 }
[09:31:33.437]                 ...future.workdir <- getwd()
[09:31:33.437]             }
[09:31:33.437]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.437]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.437]         }
[09:31:33.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.437]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.437]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.437]             base::names(...future.oldOptions))
[09:31:33.437]     }
[09:31:33.437]     if (FALSE) {
[09:31:33.437]     }
[09:31:33.437]     else {
[09:31:33.437]         if (TRUE) {
[09:31:33.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.437]                 open = "w")
[09:31:33.437]         }
[09:31:33.437]         else {
[09:31:33.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.437]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.437]         }
[09:31:33.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.437]             base::sink(type = "output", split = FALSE)
[09:31:33.437]             base::close(...future.stdout)
[09:31:33.437]         }, add = TRUE)
[09:31:33.437]     }
[09:31:33.437]     ...future.frame <- base::sys.nframe()
[09:31:33.437]     ...future.conditions <- base::list()
[09:31:33.437]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.437]     if (FALSE) {
[09:31:33.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.437]     }
[09:31:33.437]     ...future.result <- base::tryCatch({
[09:31:33.437]         base::withCallingHandlers({
[09:31:33.437]             ...future.value <- base::withVisible(base::local({
[09:31:33.437]                 x <- x + 1
[09:31:33.437]                 x
[09:31:33.437]             }))
[09:31:33.437]             future::FutureResult(value = ...future.value$value, 
[09:31:33.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.437]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.437]                     ...future.globalenv.names))
[09:31:33.437]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.437]         }, condition = base::local({
[09:31:33.437]             c <- base::c
[09:31:33.437]             inherits <- base::inherits
[09:31:33.437]             invokeRestart <- base::invokeRestart
[09:31:33.437]             length <- base::length
[09:31:33.437]             list <- base::list
[09:31:33.437]             seq.int <- base::seq.int
[09:31:33.437]             signalCondition <- base::signalCondition
[09:31:33.437]             sys.calls <- base::sys.calls
[09:31:33.437]             `[[` <- base::`[[`
[09:31:33.437]             `+` <- base::`+`
[09:31:33.437]             `<<-` <- base::`<<-`
[09:31:33.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.437]                   3L)]
[09:31:33.437]             }
[09:31:33.437]             function(cond) {
[09:31:33.437]                 is_error <- inherits(cond, "error")
[09:31:33.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.437]                   NULL)
[09:31:33.437]                 if (is_error) {
[09:31:33.437]                   sessionInformation <- function() {
[09:31:33.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.437]                       search = base::search(), system = base::Sys.info())
[09:31:33.437]                   }
[09:31:33.437]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.437]                     cond$call), session = sessionInformation(), 
[09:31:33.437]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.437]                   signalCondition(cond)
[09:31:33.437]                 }
[09:31:33.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.437]                 "immediateCondition"))) {
[09:31:33.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.437]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.437]                   if (TRUE && !signal) {
[09:31:33.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.437]                     {
[09:31:33.437]                       inherits <- base::inherits
[09:31:33.437]                       invokeRestart <- base::invokeRestart
[09:31:33.437]                       is.null <- base::is.null
[09:31:33.437]                       muffled <- FALSE
[09:31:33.437]                       if (inherits(cond, "message")) {
[09:31:33.437]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.437]                         if (muffled) 
[09:31:33.437]                           invokeRestart("muffleMessage")
[09:31:33.437]                       }
[09:31:33.437]                       else if (inherits(cond, "warning")) {
[09:31:33.437]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.437]                         if (muffled) 
[09:31:33.437]                           invokeRestart("muffleWarning")
[09:31:33.437]                       }
[09:31:33.437]                       else if (inherits(cond, "condition")) {
[09:31:33.437]                         if (!is.null(pattern)) {
[09:31:33.437]                           computeRestarts <- base::computeRestarts
[09:31:33.437]                           grepl <- base::grepl
[09:31:33.437]                           restarts <- computeRestarts(cond)
[09:31:33.437]                           for (restart in restarts) {
[09:31:33.437]                             name <- restart$name
[09:31:33.437]                             if (is.null(name)) 
[09:31:33.437]                               next
[09:31:33.437]                             if (!grepl(pattern, name)) 
[09:31:33.437]                               next
[09:31:33.437]                             invokeRestart(restart)
[09:31:33.437]                             muffled <- TRUE
[09:31:33.437]                             break
[09:31:33.437]                           }
[09:31:33.437]                         }
[09:31:33.437]                       }
[09:31:33.437]                       invisible(muffled)
[09:31:33.437]                     }
[09:31:33.437]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.437]                   }
[09:31:33.437]                 }
[09:31:33.437]                 else {
[09:31:33.437]                   if (TRUE) {
[09:31:33.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.437]                     {
[09:31:33.437]                       inherits <- base::inherits
[09:31:33.437]                       invokeRestart <- base::invokeRestart
[09:31:33.437]                       is.null <- base::is.null
[09:31:33.437]                       muffled <- FALSE
[09:31:33.437]                       if (inherits(cond, "message")) {
[09:31:33.437]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.437]                         if (muffled) 
[09:31:33.437]                           invokeRestart("muffleMessage")
[09:31:33.437]                       }
[09:31:33.437]                       else if (inherits(cond, "warning")) {
[09:31:33.437]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.437]                         if (muffled) 
[09:31:33.437]                           invokeRestart("muffleWarning")
[09:31:33.437]                       }
[09:31:33.437]                       else if (inherits(cond, "condition")) {
[09:31:33.437]                         if (!is.null(pattern)) {
[09:31:33.437]                           computeRestarts <- base::computeRestarts
[09:31:33.437]                           grepl <- base::grepl
[09:31:33.437]                           restarts <- computeRestarts(cond)
[09:31:33.437]                           for (restart in restarts) {
[09:31:33.437]                             name <- restart$name
[09:31:33.437]                             if (is.null(name)) 
[09:31:33.437]                               next
[09:31:33.437]                             if (!grepl(pattern, name)) 
[09:31:33.437]                               next
[09:31:33.437]                             invokeRestart(restart)
[09:31:33.437]                             muffled <- TRUE
[09:31:33.437]                             break
[09:31:33.437]                           }
[09:31:33.437]                         }
[09:31:33.437]                       }
[09:31:33.437]                       invisible(muffled)
[09:31:33.437]                     }
[09:31:33.437]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.437]                   }
[09:31:33.437]                 }
[09:31:33.437]             }
[09:31:33.437]         }))
[09:31:33.437]     }, error = function(ex) {
[09:31:33.437]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.437]                 ...future.rng), started = ...future.startTime, 
[09:31:33.437]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.437]             version = "1.8"), class = "FutureResult")
[09:31:33.437]     }, finally = {
[09:31:33.437]         if (!identical(...future.workdir, getwd())) 
[09:31:33.437]             setwd(...future.workdir)
[09:31:33.437]         {
[09:31:33.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.437]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.437]             }
[09:31:33.437]             base::options(...future.oldOptions)
[09:31:33.437]             if (.Platform$OS.type == "windows") {
[09:31:33.437]                 old_names <- names(...future.oldEnvVars)
[09:31:33.437]                 envs <- base::Sys.getenv()
[09:31:33.437]                 names <- names(envs)
[09:31:33.437]                 common <- intersect(names, old_names)
[09:31:33.437]                 added <- setdiff(names, old_names)
[09:31:33.437]                 removed <- setdiff(old_names, names)
[09:31:33.437]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.437]                   envs[common]]
[09:31:33.437]                 NAMES <- toupper(changed)
[09:31:33.437]                 args <- list()
[09:31:33.437]                 for (kk in seq_along(NAMES)) {
[09:31:33.437]                   name <- changed[[kk]]
[09:31:33.437]                   NAME <- NAMES[[kk]]
[09:31:33.437]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.437]                     next
[09:31:33.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.437]                 }
[09:31:33.437]                 NAMES <- toupper(added)
[09:31:33.437]                 for (kk in seq_along(NAMES)) {
[09:31:33.437]                   name <- added[[kk]]
[09:31:33.437]                   NAME <- NAMES[[kk]]
[09:31:33.437]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.437]                     next
[09:31:33.437]                   args[[name]] <- ""
[09:31:33.437]                 }
[09:31:33.437]                 NAMES <- toupper(removed)
[09:31:33.437]                 for (kk in seq_along(NAMES)) {
[09:31:33.437]                   name <- removed[[kk]]
[09:31:33.437]                   NAME <- NAMES[[kk]]
[09:31:33.437]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.437]                     next
[09:31:33.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.437]                 }
[09:31:33.437]                 if (length(args) > 0) 
[09:31:33.437]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.437]             }
[09:31:33.437]             else {
[09:31:33.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.437]             }
[09:31:33.437]             {
[09:31:33.437]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.437]                   0L) {
[09:31:33.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.437]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.437]                   base::options(opts)
[09:31:33.437]                 }
[09:31:33.437]                 {
[09:31:33.437]                   {
[09:31:33.437]                     NULL
[09:31:33.437]                     RNGkind("Mersenne-Twister")
[09:31:33.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.437]                       inherits = FALSE)
[09:31:33.437]                   }
[09:31:33.437]                   options(future.plan = NULL)
[09:31:33.437]                   if (is.na(NA_character_)) 
[09:31:33.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.437]                     .init = FALSE)
[09:31:33.437]                 }
[09:31:33.437]             }
[09:31:33.437]         }
[09:31:33.437]     })
[09:31:33.437]     if (TRUE) {
[09:31:33.437]         base::sink(type = "output", split = FALSE)
[09:31:33.437]         if (TRUE) {
[09:31:33.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.437]         }
[09:31:33.437]         else {
[09:31:33.437]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.437]         }
[09:31:33.437]         base::close(...future.stdout)
[09:31:33.437]         ...future.stdout <- NULL
[09:31:33.437]     }
[09:31:33.437]     ...future.result$conditions <- ...future.conditions
[09:31:33.437]     ...future.result$finished <- base::Sys.time()
[09:31:33.437]     ...future.result
[09:31:33.437] }
[09:31:33.439] assign_globals() ...
[09:31:33.439] List of 1
[09:31:33.439]  $ x: num 1
[09:31:33.439]  - attr(*, "where")=List of 1
[09:31:33.439]   ..$ x:<environment: R_EmptyEnv> 
[09:31:33.439]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.439]  - attr(*, "resolved")= logi TRUE
[09:31:33.439]  - attr(*, "total_size")= num 56
[09:31:33.439]  - attr(*, "already-done")= logi TRUE
[09:31:33.441] - copied ‘x’ to environment
[09:31:33.441] assign_globals() ... done
[09:31:33.441] plan(): Setting new future strategy stack:
[09:31:33.441] List of future strategies:
[09:31:33.441] 1. sequential:
[09:31:33.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.441]    - tweaked: FALSE
[09:31:33.441]    - call: NULL
[09:31:33.442] plan(): nbrOfWorkers() = 1
[09:31:33.443] plan(): Setting new future strategy stack:
[09:31:33.443] List of future strategies:
[09:31:33.443] 1. sequential:
[09:31:33.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.443]    - tweaked: FALSE
[09:31:33.443]    - call: plan(strategy)
[09:31:33.443] plan(): nbrOfWorkers() = 1
[09:31:33.443] SequentialFuture started (and completed)
[09:31:33.443] - Launch lazy future ... done
[09:31:33.443] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.444] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:33.446] - globals found: [3] ‘{’, ‘<-’, ‘x’
[09:31:33.446] Searching for globals ... DONE
[09:31:33.446] Resolving globals: TRUE
[09:31:33.446] Resolving any globals that are futures ...
[09:31:33.446] - globals: [3] ‘{’, ‘<-’, ‘x’
[09:31:33.446] Resolving any globals that are futures ... DONE
[09:31:33.446] Resolving futures part of globals (recursively) ...
[09:31:33.446] resolve() on list ...
[09:31:33.447]  recursive: 99
[09:31:33.447]  length: 1
[09:31:33.447]  elements: ‘x’
[09:31:33.447]  length: 0 (resolved future 1)
[09:31:33.447] resolve() on list ... DONE
[09:31:33.447] - globals: [1] ‘x’
[09:31:33.447] Resolving futures part of globals (recursively) ... DONE
[09:31:33.447] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[09:31:33.448] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[09:31:33.448] - globals: [1] ‘x’
[09:31:33.448] 
[09:31:33.448] getGlobalsAndPackages() ... DONE
[09:31:33.448] run() for ‘Future’ ...
[09:31:33.448] - state: ‘created’
[09:31:33.448] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:33.449] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:33.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:33.449]   - Field: ‘label’
[09:31:33.449]   - Field: ‘local’
[09:31:33.449]   - Field: ‘owner’
[09:31:33.449]   - Field: ‘envir’
[09:31:33.449]   - Field: ‘packages’
[09:31:33.449]   - Field: ‘gc’
[09:31:33.449]   - Field: ‘conditions’
[09:31:33.449]   - Field: ‘expr’
[09:31:33.449]   - Field: ‘uuid’
[09:31:33.450]   - Field: ‘seed’
[09:31:33.450]   - Field: ‘version’
[09:31:33.450]   - Field: ‘result’
[09:31:33.450]   - Field: ‘asynchronous’
[09:31:33.451]   - Field: ‘calls’
[09:31:33.451]   - Field: ‘globals’
[09:31:33.451]   - Field: ‘stdout’
[09:31:33.451]   - Field: ‘earlySignal’
[09:31:33.451]   - Field: ‘lazy’
[09:31:33.451]   - Field: ‘state’
[09:31:33.451] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:33.451] - Launch lazy future ...
[09:31:33.452] Packages needed by the future expression (n = 0): <none>
[09:31:33.452] Packages needed by future strategies (n = 0): <none>
[09:31:33.452] {
[09:31:33.452]     {
[09:31:33.452]         {
[09:31:33.452]             ...future.startTime <- base::Sys.time()
[09:31:33.452]             {
[09:31:33.452]                 {
[09:31:33.452]                   {
[09:31:33.452]                     base::local({
[09:31:33.452]                       has_future <- base::requireNamespace("future", 
[09:31:33.452]                         quietly = TRUE)
[09:31:33.452]                       if (has_future) {
[09:31:33.452]                         ns <- base::getNamespace("future")
[09:31:33.452]                         version <- ns[[".package"]][["version"]]
[09:31:33.452]                         if (is.null(version)) 
[09:31:33.452]                           version <- utils::packageVersion("future")
[09:31:33.452]                       }
[09:31:33.452]                       else {
[09:31:33.452]                         version <- NULL
[09:31:33.452]                       }
[09:31:33.452]                       if (!has_future || version < "1.8.0") {
[09:31:33.452]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.452]                           "", base::R.version$version.string), 
[09:31:33.452]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:33.452]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.452]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.452]                             "release", "version")], collapse = " "), 
[09:31:33.452]                           hostname = base::Sys.info()[["nodename"]])
[09:31:33.452]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.452]                           info)
[09:31:33.452]                         info <- base::paste(info, collapse = "; ")
[09:31:33.452]                         if (!has_future) {
[09:31:33.452]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.452]                             info)
[09:31:33.452]                         }
[09:31:33.452]                         else {
[09:31:33.452]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.452]                             info, version)
[09:31:33.452]                         }
[09:31:33.452]                         base::stop(msg)
[09:31:33.452]                       }
[09:31:33.452]                     })
[09:31:33.452]                   }
[09:31:33.452]                   ...future.strategy.old <- future::plan("list")
[09:31:33.452]                   options(future.plan = NULL)
[09:31:33.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.452]                 }
[09:31:33.452]                 ...future.workdir <- getwd()
[09:31:33.452]             }
[09:31:33.452]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.452]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.452]         }
[09:31:33.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.452]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:33.452]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.452]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.452]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.452]             base::names(...future.oldOptions))
[09:31:33.452]     }
[09:31:33.452]     if (FALSE) {
[09:31:33.452]     }
[09:31:33.452]     else {
[09:31:33.452]         if (TRUE) {
[09:31:33.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.452]                 open = "w")
[09:31:33.452]         }
[09:31:33.452]         else {
[09:31:33.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.452]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.452]         }
[09:31:33.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.452]             base::sink(type = "output", split = FALSE)
[09:31:33.452]             base::close(...future.stdout)
[09:31:33.452]         }, add = TRUE)
[09:31:33.452]     }
[09:31:33.452]     ...future.frame <- base::sys.nframe()
[09:31:33.452]     ...future.conditions <- base::list()
[09:31:33.452]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.452]     if (FALSE) {
[09:31:33.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.452]     }
[09:31:33.452]     ...future.result <- base::tryCatch({
[09:31:33.452]         base::withCallingHandlers({
[09:31:33.452]             ...future.value <- base::withVisible(base::local({
[09:31:33.452]                 x <- x()
[09:31:33.452]                 x
[09:31:33.452]             }))
[09:31:33.452]             future::FutureResult(value = ...future.value$value, 
[09:31:33.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.452]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.452]                     ...future.globalenv.names))
[09:31:33.452]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.452]         }, condition = base::local({
[09:31:33.452]             c <- base::c
[09:31:33.452]             inherits <- base::inherits
[09:31:33.452]             invokeRestart <- base::invokeRestart
[09:31:33.452]             length <- base::length
[09:31:33.452]             list <- base::list
[09:31:33.452]             seq.int <- base::seq.int
[09:31:33.452]             signalCondition <- base::signalCondition
[09:31:33.452]             sys.calls <- base::sys.calls
[09:31:33.452]             `[[` <- base::`[[`
[09:31:33.452]             `+` <- base::`+`
[09:31:33.452]             `<<-` <- base::`<<-`
[09:31:33.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.452]                   3L)]
[09:31:33.452]             }
[09:31:33.452]             function(cond) {
[09:31:33.452]                 is_error <- inherits(cond, "error")
[09:31:33.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.452]                   NULL)
[09:31:33.452]                 if (is_error) {
[09:31:33.452]                   sessionInformation <- function() {
[09:31:33.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.452]                       search = base::search(), system = base::Sys.info())
[09:31:33.452]                   }
[09:31:33.452]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.452]                     cond$call), session = sessionInformation(), 
[09:31:33.452]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.452]                   signalCondition(cond)
[09:31:33.452]                 }
[09:31:33.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.452]                 "immediateCondition"))) {
[09:31:33.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.452]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.452]                   if (TRUE && !signal) {
[09:31:33.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.452]                     {
[09:31:33.452]                       inherits <- base::inherits
[09:31:33.452]                       invokeRestart <- base::invokeRestart
[09:31:33.452]                       is.null <- base::is.null
[09:31:33.452]                       muffled <- FALSE
[09:31:33.452]                       if (inherits(cond, "message")) {
[09:31:33.452]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.452]                         if (muffled) 
[09:31:33.452]                           invokeRestart("muffleMessage")
[09:31:33.452]                       }
[09:31:33.452]                       else if (inherits(cond, "warning")) {
[09:31:33.452]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.452]                         if (muffled) 
[09:31:33.452]                           invokeRestart("muffleWarning")
[09:31:33.452]                       }
[09:31:33.452]                       else if (inherits(cond, "condition")) {
[09:31:33.452]                         if (!is.null(pattern)) {
[09:31:33.452]                           computeRestarts <- base::computeRestarts
[09:31:33.452]                           grepl <- base::grepl
[09:31:33.452]                           restarts <- computeRestarts(cond)
[09:31:33.452]                           for (restart in restarts) {
[09:31:33.452]                             name <- restart$name
[09:31:33.452]                             if (is.null(name)) 
[09:31:33.452]                               next
[09:31:33.452]                             if (!grepl(pattern, name)) 
[09:31:33.452]                               next
[09:31:33.452]                             invokeRestart(restart)
[09:31:33.452]                             muffled <- TRUE
[09:31:33.452]                             break
[09:31:33.452]                           }
[09:31:33.452]                         }
[09:31:33.452]                       }
[09:31:33.452]                       invisible(muffled)
[09:31:33.452]                     }
[09:31:33.452]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.452]                   }
[09:31:33.452]                 }
[09:31:33.452]                 else {
[09:31:33.452]                   if (TRUE) {
[09:31:33.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.452]                     {
[09:31:33.452]                       inherits <- base::inherits
[09:31:33.452]                       invokeRestart <- base::invokeRestart
[09:31:33.452]                       is.null <- base::is.null
[09:31:33.452]                       muffled <- FALSE
[09:31:33.452]                       if (inherits(cond, "message")) {
[09:31:33.452]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.452]                         if (muffled) 
[09:31:33.452]                           invokeRestart("muffleMessage")
[09:31:33.452]                       }
[09:31:33.452]                       else if (inherits(cond, "warning")) {
[09:31:33.452]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.452]                         if (muffled) 
[09:31:33.452]                           invokeRestart("muffleWarning")
[09:31:33.452]                       }
[09:31:33.452]                       else if (inherits(cond, "condition")) {
[09:31:33.452]                         if (!is.null(pattern)) {
[09:31:33.452]                           computeRestarts <- base::computeRestarts
[09:31:33.452]                           grepl <- base::grepl
[09:31:33.452]                           restarts <- computeRestarts(cond)
[09:31:33.452]                           for (restart in restarts) {
[09:31:33.452]                             name <- restart$name
[09:31:33.452]                             if (is.null(name)) 
[09:31:33.452]                               next
[09:31:33.452]                             if (!grepl(pattern, name)) 
[09:31:33.452]                               next
[09:31:33.452]                             invokeRestart(restart)
[09:31:33.452]                             muffled <- TRUE
[09:31:33.452]                             break
[09:31:33.452]                           }
[09:31:33.452]                         }
[09:31:33.452]                       }
[09:31:33.452]                       invisible(muffled)
[09:31:33.452]                     }
[09:31:33.452]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.452]                   }
[09:31:33.452]                 }
[09:31:33.452]             }
[09:31:33.452]         }))
[09:31:33.452]     }, error = function(ex) {
[09:31:33.452]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.452]                 ...future.rng), started = ...future.startTime, 
[09:31:33.452]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.452]             version = "1.8"), class = "FutureResult")
[09:31:33.452]     }, finally = {
[09:31:33.452]         if (!identical(...future.workdir, getwd())) 
[09:31:33.452]             setwd(...future.workdir)
[09:31:33.452]         {
[09:31:33.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.452]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.452]             }
[09:31:33.452]             base::options(...future.oldOptions)
[09:31:33.452]             if (.Platform$OS.type == "windows") {
[09:31:33.452]                 old_names <- names(...future.oldEnvVars)
[09:31:33.452]                 envs <- base::Sys.getenv()
[09:31:33.452]                 names <- names(envs)
[09:31:33.452]                 common <- intersect(names, old_names)
[09:31:33.452]                 added <- setdiff(names, old_names)
[09:31:33.452]                 removed <- setdiff(old_names, names)
[09:31:33.452]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.452]                   envs[common]]
[09:31:33.452]                 NAMES <- toupper(changed)
[09:31:33.452]                 args <- list()
[09:31:33.452]                 for (kk in seq_along(NAMES)) {
[09:31:33.452]                   name <- changed[[kk]]
[09:31:33.452]                   NAME <- NAMES[[kk]]
[09:31:33.452]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.452]                     next
[09:31:33.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.452]                 }
[09:31:33.452]                 NAMES <- toupper(added)
[09:31:33.452]                 for (kk in seq_along(NAMES)) {
[09:31:33.452]                   name <- added[[kk]]
[09:31:33.452]                   NAME <- NAMES[[kk]]
[09:31:33.452]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.452]                     next
[09:31:33.452]                   args[[name]] <- ""
[09:31:33.452]                 }
[09:31:33.452]                 NAMES <- toupper(removed)
[09:31:33.452]                 for (kk in seq_along(NAMES)) {
[09:31:33.452]                   name <- removed[[kk]]
[09:31:33.452]                   NAME <- NAMES[[kk]]
[09:31:33.452]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.452]                     next
[09:31:33.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.452]                 }
[09:31:33.452]                 if (length(args) > 0) 
[09:31:33.452]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.452]             }
[09:31:33.452]             else {
[09:31:33.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.452]             }
[09:31:33.452]             {
[09:31:33.452]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.452]                   0L) {
[09:31:33.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.452]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.452]                   base::options(opts)
[09:31:33.452]                 }
[09:31:33.452]                 {
[09:31:33.452]                   {
[09:31:33.452]                     NULL
[09:31:33.452]                     RNGkind("Mersenne-Twister")
[09:31:33.452]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:33.452]                       inherits = FALSE)
[09:31:33.452]                   }
[09:31:33.452]                   options(future.plan = NULL)
[09:31:33.452]                   if (is.na(NA_character_)) 
[09:31:33.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.452]                     .init = FALSE)
[09:31:33.452]                 }
[09:31:33.452]             }
[09:31:33.452]         }
[09:31:33.452]     })
[09:31:33.452]     if (TRUE) {
[09:31:33.452]         base::sink(type = "output", split = FALSE)
[09:31:33.452]         if (TRUE) {
[09:31:33.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.452]         }
[09:31:33.452]         else {
[09:31:33.452]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.452]         }
[09:31:33.452]         base::close(...future.stdout)
[09:31:33.452]         ...future.stdout <- NULL
[09:31:33.452]     }
[09:31:33.452]     ...future.result$conditions <- ...future.conditions
[09:31:33.452]     ...future.result$finished <- base::Sys.time()
[09:31:33.452]     ...future.result
[09:31:33.452] }
[09:31:33.454] assign_globals() ...
[09:31:33.454] List of 1
[09:31:33.454]  $ x:function ()  
[09:31:33.454]  - attr(*, "where")=List of 1
[09:31:33.454]   ..$ x:<environment: R_EmptyEnv> 
[09:31:33.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.454]  - attr(*, "resolved")= logi TRUE
[09:31:33.454]  - attr(*, "total_size")= num 1032
[09:31:33.454]  - attr(*, "already-done")= logi TRUE
[09:31:33.456] - reassign environment for ‘x’
[09:31:33.456] - copied ‘x’ to environment
[09:31:33.456] assign_globals() ... done
[09:31:33.456] plan(): Setting new future strategy stack:
[09:31:33.456] List of future strategies:
[09:31:33.456] 1. sequential:
[09:31:33.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.456]    - tweaked: FALSE
[09:31:33.456]    - call: NULL
[09:31:33.457] plan(): nbrOfWorkers() = 1
[09:31:33.457] plan(): Setting new future strategy stack:
[09:31:33.457] List of future strategies:
[09:31:33.457] 1. sequential:
[09:31:33.457]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.457]    - tweaked: FALSE
[09:31:33.457]    - call: plan(strategy)
[09:31:33.458] plan(): nbrOfWorkers() = 1
[09:31:33.458] SequentialFuture started (and completed)
[09:31:33.458] - Launch lazy future ... done
[09:31:33.458] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[09:31:33.467] plan(): Setting new future strategy stack:
[09:31:33.467] List of future strategies:
[09:31:33.467] 1. multicore:
[09:31:33.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.467]    - tweaked: FALSE
[09:31:33.467]    - call: plan(strategy)
[09:31:33.470] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.471] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.471] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.472] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:33.472] Searching for globals ... DONE
[09:31:33.472] Resolving globals: TRUE
[09:31:33.472] Resolving any globals that are futures ...
[09:31:33.472] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:33.473] Resolving any globals that are futures ... DONE
[09:31:33.473] 
[09:31:33.473] 
[09:31:33.473] getGlobalsAndPackages() ... DONE
[09:31:33.473] run() for ‘Future’ ...
[09:31:33.473] - state: ‘created’
[09:31:33.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.477] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.477] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.477]   - Field: ‘label’
[09:31:33.477]   - Field: ‘local’
[09:31:33.477]   - Field: ‘owner’
[09:31:33.477]   - Field: ‘envir’
[09:31:33.477]   - Field: ‘workers’
[09:31:33.478]   - Field: ‘packages’
[09:31:33.478]   - Field: ‘gc’
[09:31:33.478]   - Field: ‘job’
[09:31:33.478]   - Field: ‘conditions’
[09:31:33.478]   - Field: ‘expr’
[09:31:33.478]   - Field: ‘uuid’
[09:31:33.478]   - Field: ‘seed’
[09:31:33.478]   - Field: ‘version’
[09:31:33.478]   - Field: ‘result’
[09:31:33.478]   - Field: ‘asynchronous’
[09:31:33.478]   - Field: ‘calls’
[09:31:33.479]   - Field: ‘globals’
[09:31:33.479]   - Field: ‘stdout’
[09:31:33.479]   - Field: ‘earlySignal’
[09:31:33.479]   - Field: ‘lazy’
[09:31:33.479]   - Field: ‘state’
[09:31:33.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.479] - Launch lazy future ...
[09:31:33.480] Packages needed by the future expression (n = 0): <none>
[09:31:33.480] Packages needed by future strategies (n = 0): <none>
[09:31:33.480] {
[09:31:33.480]     {
[09:31:33.480]         {
[09:31:33.480]             ...future.startTime <- base::Sys.time()
[09:31:33.480]             {
[09:31:33.480]                 {
[09:31:33.480]                   {
[09:31:33.480]                     {
[09:31:33.480]                       base::local({
[09:31:33.480]                         has_future <- base::requireNamespace("future", 
[09:31:33.480]                           quietly = TRUE)
[09:31:33.480]                         if (has_future) {
[09:31:33.480]                           ns <- base::getNamespace("future")
[09:31:33.480]                           version <- ns[[".package"]][["version"]]
[09:31:33.480]                           if (is.null(version)) 
[09:31:33.480]                             version <- utils::packageVersion("future")
[09:31:33.480]                         }
[09:31:33.480]                         else {
[09:31:33.480]                           version <- NULL
[09:31:33.480]                         }
[09:31:33.480]                         if (!has_future || version < "1.8.0") {
[09:31:33.480]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.480]                             "", base::R.version$version.string), 
[09:31:33.480]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.480]                               "release", "version")], collapse = " "), 
[09:31:33.480]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.480]                             info)
[09:31:33.480]                           info <- base::paste(info, collapse = "; ")
[09:31:33.480]                           if (!has_future) {
[09:31:33.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.480]                               info)
[09:31:33.480]                           }
[09:31:33.480]                           else {
[09:31:33.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.480]                               info, version)
[09:31:33.480]                           }
[09:31:33.480]                           base::stop(msg)
[09:31:33.480]                         }
[09:31:33.480]                       })
[09:31:33.480]                     }
[09:31:33.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.480]                     base::options(mc.cores = 1L)
[09:31:33.480]                   }
[09:31:33.480]                   ...future.strategy.old <- future::plan("list")
[09:31:33.480]                   options(future.plan = NULL)
[09:31:33.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.480]                 }
[09:31:33.480]                 ...future.workdir <- getwd()
[09:31:33.480]             }
[09:31:33.480]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.480]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.480]         }
[09:31:33.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.480]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.480]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.480]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.480]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.480]             base::names(...future.oldOptions))
[09:31:33.480]     }
[09:31:33.480]     if (FALSE) {
[09:31:33.480]     }
[09:31:33.480]     else {
[09:31:33.480]         if (TRUE) {
[09:31:33.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.480]                 open = "w")
[09:31:33.480]         }
[09:31:33.480]         else {
[09:31:33.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.480]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.480]         }
[09:31:33.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.480]             base::sink(type = "output", split = FALSE)
[09:31:33.480]             base::close(...future.stdout)
[09:31:33.480]         }, add = TRUE)
[09:31:33.480]     }
[09:31:33.480]     ...future.frame <- base::sys.nframe()
[09:31:33.480]     ...future.conditions <- base::list()
[09:31:33.480]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.480]     if (FALSE) {
[09:31:33.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.480]     }
[09:31:33.480]     ...future.result <- base::tryCatch({
[09:31:33.480]         base::withCallingHandlers({
[09:31:33.480]             ...future.value <- base::withVisible(base::local({
[09:31:33.480]                 withCallingHandlers({
[09:31:33.480]                   {
[09:31:33.480]                     b <- a
[09:31:33.480]                     a <- 2
[09:31:33.480]                     a * b
[09:31:33.480]                   }
[09:31:33.480]                 }, immediateCondition = function(cond) {
[09:31:33.480]                   save_rds <- function (object, pathname, ...) 
[09:31:33.480]                   {
[09:31:33.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.480]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.480]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.480]                         fi_tmp[["mtime"]])
[09:31:33.480]                     }
[09:31:33.480]                     tryCatch({
[09:31:33.480]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.480]                     }, error = function(ex) {
[09:31:33.480]                       msg <- conditionMessage(ex)
[09:31:33.480]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.480]                         fi_tmp[["mtime"]], msg)
[09:31:33.480]                       ex$message <- msg
[09:31:33.480]                       stop(ex)
[09:31:33.480]                     })
[09:31:33.480]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.480]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.480]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.480]                       fi <- file.info(pathname)
[09:31:33.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.480]                         fi[["size"]], fi[["mtime"]])
[09:31:33.480]                       stop(msg)
[09:31:33.480]                     }
[09:31:33.480]                     invisible(pathname)
[09:31:33.480]                   }
[09:31:33.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.480]                     rootPath = tempdir()) 
[09:31:33.480]                   {
[09:31:33.480]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.480]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.480]                       tmpdir = path, fileext = ".rds")
[09:31:33.480]                     save_rds(obj, file)
[09:31:33.480]                   }
[09:31:33.480]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.480]                   {
[09:31:33.480]                     inherits <- base::inherits
[09:31:33.480]                     invokeRestart <- base::invokeRestart
[09:31:33.480]                     is.null <- base::is.null
[09:31:33.480]                     muffled <- FALSE
[09:31:33.480]                     if (inherits(cond, "message")) {
[09:31:33.480]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.480]                       if (muffled) 
[09:31:33.480]                         invokeRestart("muffleMessage")
[09:31:33.480]                     }
[09:31:33.480]                     else if (inherits(cond, "warning")) {
[09:31:33.480]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.480]                       if (muffled) 
[09:31:33.480]                         invokeRestart("muffleWarning")
[09:31:33.480]                     }
[09:31:33.480]                     else if (inherits(cond, "condition")) {
[09:31:33.480]                       if (!is.null(pattern)) {
[09:31:33.480]                         computeRestarts <- base::computeRestarts
[09:31:33.480]                         grepl <- base::grepl
[09:31:33.480]                         restarts <- computeRestarts(cond)
[09:31:33.480]                         for (restart in restarts) {
[09:31:33.480]                           name <- restart$name
[09:31:33.480]                           if (is.null(name)) 
[09:31:33.480]                             next
[09:31:33.480]                           if (!grepl(pattern, name)) 
[09:31:33.480]                             next
[09:31:33.480]                           invokeRestart(restart)
[09:31:33.480]                           muffled <- TRUE
[09:31:33.480]                           break
[09:31:33.480]                         }
[09:31:33.480]                       }
[09:31:33.480]                     }
[09:31:33.480]                     invisible(muffled)
[09:31:33.480]                   }
[09:31:33.480]                   muffleCondition(cond)
[09:31:33.480]                 })
[09:31:33.480]             }))
[09:31:33.480]             future::FutureResult(value = ...future.value$value, 
[09:31:33.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.480]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.480]                     ...future.globalenv.names))
[09:31:33.480]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.480]         }, condition = base::local({
[09:31:33.480]             c <- base::c
[09:31:33.480]             inherits <- base::inherits
[09:31:33.480]             invokeRestart <- base::invokeRestart
[09:31:33.480]             length <- base::length
[09:31:33.480]             list <- base::list
[09:31:33.480]             seq.int <- base::seq.int
[09:31:33.480]             signalCondition <- base::signalCondition
[09:31:33.480]             sys.calls <- base::sys.calls
[09:31:33.480]             `[[` <- base::`[[`
[09:31:33.480]             `+` <- base::`+`
[09:31:33.480]             `<<-` <- base::`<<-`
[09:31:33.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.480]                   3L)]
[09:31:33.480]             }
[09:31:33.480]             function(cond) {
[09:31:33.480]                 is_error <- inherits(cond, "error")
[09:31:33.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.480]                   NULL)
[09:31:33.480]                 if (is_error) {
[09:31:33.480]                   sessionInformation <- function() {
[09:31:33.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.480]                       search = base::search(), system = base::Sys.info())
[09:31:33.480]                   }
[09:31:33.480]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.480]                     cond$call), session = sessionInformation(), 
[09:31:33.480]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.480]                   signalCondition(cond)
[09:31:33.480]                 }
[09:31:33.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.480]                 "immediateCondition"))) {
[09:31:33.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.480]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.480]                   if (TRUE && !signal) {
[09:31:33.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.480]                     {
[09:31:33.480]                       inherits <- base::inherits
[09:31:33.480]                       invokeRestart <- base::invokeRestart
[09:31:33.480]                       is.null <- base::is.null
[09:31:33.480]                       muffled <- FALSE
[09:31:33.480]                       if (inherits(cond, "message")) {
[09:31:33.480]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.480]                         if (muffled) 
[09:31:33.480]                           invokeRestart("muffleMessage")
[09:31:33.480]                       }
[09:31:33.480]                       else if (inherits(cond, "warning")) {
[09:31:33.480]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.480]                         if (muffled) 
[09:31:33.480]                           invokeRestart("muffleWarning")
[09:31:33.480]                       }
[09:31:33.480]                       else if (inherits(cond, "condition")) {
[09:31:33.480]                         if (!is.null(pattern)) {
[09:31:33.480]                           computeRestarts <- base::computeRestarts
[09:31:33.480]                           grepl <- base::grepl
[09:31:33.480]                           restarts <- computeRestarts(cond)
[09:31:33.480]                           for (restart in restarts) {
[09:31:33.480]                             name <- restart$name
[09:31:33.480]                             if (is.null(name)) 
[09:31:33.480]                               next
[09:31:33.480]                             if (!grepl(pattern, name)) 
[09:31:33.480]                               next
[09:31:33.480]                             invokeRestart(restart)
[09:31:33.480]                             muffled <- TRUE
[09:31:33.480]                             break
[09:31:33.480]                           }
[09:31:33.480]                         }
[09:31:33.480]                       }
[09:31:33.480]                       invisible(muffled)
[09:31:33.480]                     }
[09:31:33.480]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.480]                   }
[09:31:33.480]                 }
[09:31:33.480]                 else {
[09:31:33.480]                   if (TRUE) {
[09:31:33.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.480]                     {
[09:31:33.480]                       inherits <- base::inherits
[09:31:33.480]                       invokeRestart <- base::invokeRestart
[09:31:33.480]                       is.null <- base::is.null
[09:31:33.480]                       muffled <- FALSE
[09:31:33.480]                       if (inherits(cond, "message")) {
[09:31:33.480]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.480]                         if (muffled) 
[09:31:33.480]                           invokeRestart("muffleMessage")
[09:31:33.480]                       }
[09:31:33.480]                       else if (inherits(cond, "warning")) {
[09:31:33.480]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.480]                         if (muffled) 
[09:31:33.480]                           invokeRestart("muffleWarning")
[09:31:33.480]                       }
[09:31:33.480]                       else if (inherits(cond, "condition")) {
[09:31:33.480]                         if (!is.null(pattern)) {
[09:31:33.480]                           computeRestarts <- base::computeRestarts
[09:31:33.480]                           grepl <- base::grepl
[09:31:33.480]                           restarts <- computeRestarts(cond)
[09:31:33.480]                           for (restart in restarts) {
[09:31:33.480]                             name <- restart$name
[09:31:33.480]                             if (is.null(name)) 
[09:31:33.480]                               next
[09:31:33.480]                             if (!grepl(pattern, name)) 
[09:31:33.480]                               next
[09:31:33.480]                             invokeRestart(restart)
[09:31:33.480]                             muffled <- TRUE
[09:31:33.480]                             break
[09:31:33.480]                           }
[09:31:33.480]                         }
[09:31:33.480]                       }
[09:31:33.480]                       invisible(muffled)
[09:31:33.480]                     }
[09:31:33.480]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.480]                   }
[09:31:33.480]                 }
[09:31:33.480]             }
[09:31:33.480]         }))
[09:31:33.480]     }, error = function(ex) {
[09:31:33.480]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.480]                 ...future.rng), started = ...future.startTime, 
[09:31:33.480]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.480]             version = "1.8"), class = "FutureResult")
[09:31:33.480]     }, finally = {
[09:31:33.480]         if (!identical(...future.workdir, getwd())) 
[09:31:33.480]             setwd(...future.workdir)
[09:31:33.480]         {
[09:31:33.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.480]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.480]             }
[09:31:33.480]             base::options(...future.oldOptions)
[09:31:33.480]             if (.Platform$OS.type == "windows") {
[09:31:33.480]                 old_names <- names(...future.oldEnvVars)
[09:31:33.480]                 envs <- base::Sys.getenv()
[09:31:33.480]                 names <- names(envs)
[09:31:33.480]                 common <- intersect(names, old_names)
[09:31:33.480]                 added <- setdiff(names, old_names)
[09:31:33.480]                 removed <- setdiff(old_names, names)
[09:31:33.480]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.480]                   envs[common]]
[09:31:33.480]                 NAMES <- toupper(changed)
[09:31:33.480]                 args <- list()
[09:31:33.480]                 for (kk in seq_along(NAMES)) {
[09:31:33.480]                   name <- changed[[kk]]
[09:31:33.480]                   NAME <- NAMES[[kk]]
[09:31:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.480]                     next
[09:31:33.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.480]                 }
[09:31:33.480]                 NAMES <- toupper(added)
[09:31:33.480]                 for (kk in seq_along(NAMES)) {
[09:31:33.480]                   name <- added[[kk]]
[09:31:33.480]                   NAME <- NAMES[[kk]]
[09:31:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.480]                     next
[09:31:33.480]                   args[[name]] <- ""
[09:31:33.480]                 }
[09:31:33.480]                 NAMES <- toupper(removed)
[09:31:33.480]                 for (kk in seq_along(NAMES)) {
[09:31:33.480]                   name <- removed[[kk]]
[09:31:33.480]                   NAME <- NAMES[[kk]]
[09:31:33.480]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.480]                     next
[09:31:33.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.480]                 }
[09:31:33.480]                 if (length(args) > 0) 
[09:31:33.480]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.480]             }
[09:31:33.480]             else {
[09:31:33.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.480]             }
[09:31:33.480]             {
[09:31:33.480]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.480]                   0L) {
[09:31:33.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.480]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.480]                   base::options(opts)
[09:31:33.480]                 }
[09:31:33.480]                 {
[09:31:33.480]                   {
[09:31:33.480]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.480]                     NULL
[09:31:33.480]                   }
[09:31:33.480]                   options(future.plan = NULL)
[09:31:33.480]                   if (is.na(NA_character_)) 
[09:31:33.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.480]                     .init = FALSE)
[09:31:33.480]                 }
[09:31:33.480]             }
[09:31:33.480]         }
[09:31:33.480]     })
[09:31:33.480]     if (TRUE) {
[09:31:33.480]         base::sink(type = "output", split = FALSE)
[09:31:33.480]         if (TRUE) {
[09:31:33.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.480]         }
[09:31:33.480]         else {
[09:31:33.480]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.480]         }
[09:31:33.480]         base::close(...future.stdout)
[09:31:33.480]         ...future.stdout <- NULL
[09:31:33.480]     }
[09:31:33.480]     ...future.result$conditions <- ...future.conditions
[09:31:33.480]     ...future.result$finished <- base::Sys.time()
[09:31:33.480]     ...future.result
[09:31:33.480] }
[09:31:33.483] requestCore(): workers = 2
[09:31:33.486] MulticoreFuture started
[09:31:33.486] - Launch lazy future ... done
[09:31:33.486] plan(): Setting new future strategy stack:
[09:31:33.486] run() for ‘MulticoreFuture’ ... done
[09:31:33.488] result() for MulticoreFuture ...
[09:31:33.486] List of future strategies:
[09:31:33.486] 1. sequential:
[09:31:33.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.486]    - tweaked: FALSE
[09:31:33.486]    - call: NULL
[09:31:33.492] plan(): nbrOfWorkers() = 1
[09:31:33.495] plan(): Setting new future strategy stack:
[09:31:33.495] List of future strategies:
[09:31:33.495] 1. multicore:
[09:31:33.495]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.495]    - tweaked: FALSE
[09:31:33.495]    - call: plan(strategy)
[09:31:33.502] plan(): nbrOfWorkers() = 2
[09:31:33.507] result() for MulticoreFuture ...
[09:31:33.507] result() for MulticoreFuture ... done
[09:31:33.507] result() for MulticoreFuture ... done
[09:31:33.507] result() for MulticoreFuture ...
[09:31:33.508] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.508] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.508] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.510] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:33.510] Searching for globals ... DONE
[09:31:33.510] Resolving globals: TRUE
[09:31:33.510] Resolving any globals that are futures ...
[09:31:33.510] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:33.511] Resolving any globals that are futures ... DONE
[09:31:33.511] 
[09:31:33.511] 
[09:31:33.511] getGlobalsAndPackages() ... DONE
[09:31:33.512] run() for ‘Future’ ...
[09:31:33.512] - state: ‘created’
[09:31:33.512] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.516] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.516]   - Field: ‘label’
[09:31:33.516]   - Field: ‘local’
[09:31:33.516]   - Field: ‘owner’
[09:31:33.516]   - Field: ‘envir’
[09:31:33.516]   - Field: ‘workers’
[09:31:33.516]   - Field: ‘packages’
[09:31:33.516]   - Field: ‘gc’
[09:31:33.517]   - Field: ‘job’
[09:31:33.517]   - Field: ‘conditions’
[09:31:33.517]   - Field: ‘expr’
[09:31:33.517]   - Field: ‘uuid’
[09:31:33.517]   - Field: ‘seed’
[09:31:33.517]   - Field: ‘version’
[09:31:33.517]   - Field: ‘result’
[09:31:33.517]   - Field: ‘asynchronous’
[09:31:33.517]   - Field: ‘calls’
[09:31:33.518]   - Field: ‘globals’
[09:31:33.518]   - Field: ‘stdout’
[09:31:33.518]   - Field: ‘earlySignal’
[09:31:33.518]   - Field: ‘lazy’
[09:31:33.518]   - Field: ‘state’
[09:31:33.518] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.518] - Launch lazy future ...
[09:31:33.518] Packages needed by the future expression (n = 0): <none>
[09:31:33.519] Packages needed by future strategies (n = 0): <none>
[09:31:33.519] {
[09:31:33.519]     {
[09:31:33.519]         {
[09:31:33.519]             ...future.startTime <- base::Sys.time()
[09:31:33.519]             {
[09:31:33.519]                 {
[09:31:33.519]                   {
[09:31:33.519]                     {
[09:31:33.519]                       base::local({
[09:31:33.519]                         has_future <- base::requireNamespace("future", 
[09:31:33.519]                           quietly = TRUE)
[09:31:33.519]                         if (has_future) {
[09:31:33.519]                           ns <- base::getNamespace("future")
[09:31:33.519]                           version <- ns[[".package"]][["version"]]
[09:31:33.519]                           if (is.null(version)) 
[09:31:33.519]                             version <- utils::packageVersion("future")
[09:31:33.519]                         }
[09:31:33.519]                         else {
[09:31:33.519]                           version <- NULL
[09:31:33.519]                         }
[09:31:33.519]                         if (!has_future || version < "1.8.0") {
[09:31:33.519]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.519]                             "", base::R.version$version.string), 
[09:31:33.519]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.519]                               "release", "version")], collapse = " "), 
[09:31:33.519]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.519]                             info)
[09:31:33.519]                           info <- base::paste(info, collapse = "; ")
[09:31:33.519]                           if (!has_future) {
[09:31:33.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.519]                               info)
[09:31:33.519]                           }
[09:31:33.519]                           else {
[09:31:33.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.519]                               info, version)
[09:31:33.519]                           }
[09:31:33.519]                           base::stop(msg)
[09:31:33.519]                         }
[09:31:33.519]                       })
[09:31:33.519]                     }
[09:31:33.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.519]                     base::options(mc.cores = 1L)
[09:31:33.519]                   }
[09:31:33.519]                   ...future.strategy.old <- future::plan("list")
[09:31:33.519]                   options(future.plan = NULL)
[09:31:33.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.519]                 }
[09:31:33.519]                 ...future.workdir <- getwd()
[09:31:33.519]             }
[09:31:33.519]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.519]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.519]         }
[09:31:33.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.519]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.519]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.519]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.519]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.519]             base::names(...future.oldOptions))
[09:31:33.519]     }
[09:31:33.519]     if (FALSE) {
[09:31:33.519]     }
[09:31:33.519]     else {
[09:31:33.519]         if (TRUE) {
[09:31:33.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.519]                 open = "w")
[09:31:33.519]         }
[09:31:33.519]         else {
[09:31:33.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.519]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.519]         }
[09:31:33.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.519]             base::sink(type = "output", split = FALSE)
[09:31:33.519]             base::close(...future.stdout)
[09:31:33.519]         }, add = TRUE)
[09:31:33.519]     }
[09:31:33.519]     ...future.frame <- base::sys.nframe()
[09:31:33.519]     ...future.conditions <- base::list()
[09:31:33.519]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.519]     if (FALSE) {
[09:31:33.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.519]     }
[09:31:33.519]     ...future.result <- base::tryCatch({
[09:31:33.519]         base::withCallingHandlers({
[09:31:33.519]             ...future.value <- base::withVisible(base::local({
[09:31:33.519]                 withCallingHandlers({
[09:31:33.519]                   {
[09:31:33.519]                     b <- a
[09:31:33.519]                     a <- 2
[09:31:33.519]                     a * b
[09:31:33.519]                   }
[09:31:33.519]                 }, immediateCondition = function(cond) {
[09:31:33.519]                   save_rds <- function (object, pathname, ...) 
[09:31:33.519]                   {
[09:31:33.519]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.519]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.519]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.519]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.519]                         fi_tmp[["mtime"]])
[09:31:33.519]                     }
[09:31:33.519]                     tryCatch({
[09:31:33.519]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.519]                     }, error = function(ex) {
[09:31:33.519]                       msg <- conditionMessage(ex)
[09:31:33.519]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.519]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.519]                         fi_tmp[["mtime"]], msg)
[09:31:33.519]                       ex$message <- msg
[09:31:33.519]                       stop(ex)
[09:31:33.519]                     })
[09:31:33.519]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.519]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.519]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.519]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.519]                       fi <- file.info(pathname)
[09:31:33.519]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.519]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.519]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.519]                         fi[["size"]], fi[["mtime"]])
[09:31:33.519]                       stop(msg)
[09:31:33.519]                     }
[09:31:33.519]                     invisible(pathname)
[09:31:33.519]                   }
[09:31:33.519]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.519]                     rootPath = tempdir()) 
[09:31:33.519]                   {
[09:31:33.519]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.519]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.519]                       tmpdir = path, fileext = ".rds")
[09:31:33.519]                     save_rds(obj, file)
[09:31:33.519]                   }
[09:31:33.519]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.519]                   {
[09:31:33.519]                     inherits <- base::inherits
[09:31:33.519]                     invokeRestart <- base::invokeRestart
[09:31:33.519]                     is.null <- base::is.null
[09:31:33.519]                     muffled <- FALSE
[09:31:33.519]                     if (inherits(cond, "message")) {
[09:31:33.519]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.519]                       if (muffled) 
[09:31:33.519]                         invokeRestart("muffleMessage")
[09:31:33.519]                     }
[09:31:33.519]                     else if (inherits(cond, "warning")) {
[09:31:33.519]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.519]                       if (muffled) 
[09:31:33.519]                         invokeRestart("muffleWarning")
[09:31:33.519]                     }
[09:31:33.519]                     else if (inherits(cond, "condition")) {
[09:31:33.519]                       if (!is.null(pattern)) {
[09:31:33.519]                         computeRestarts <- base::computeRestarts
[09:31:33.519]                         grepl <- base::grepl
[09:31:33.519]                         restarts <- computeRestarts(cond)
[09:31:33.519]                         for (restart in restarts) {
[09:31:33.519]                           name <- restart$name
[09:31:33.519]                           if (is.null(name)) 
[09:31:33.519]                             next
[09:31:33.519]                           if (!grepl(pattern, name)) 
[09:31:33.519]                             next
[09:31:33.519]                           invokeRestart(restart)
[09:31:33.519]                           muffled <- TRUE
[09:31:33.519]                           break
[09:31:33.519]                         }
[09:31:33.519]                       }
[09:31:33.519]                     }
[09:31:33.519]                     invisible(muffled)
[09:31:33.519]                   }
[09:31:33.519]                   muffleCondition(cond)
[09:31:33.519]                 })
[09:31:33.519]             }))
[09:31:33.519]             future::FutureResult(value = ...future.value$value, 
[09:31:33.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.519]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.519]                     ...future.globalenv.names))
[09:31:33.519]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.519]         }, condition = base::local({
[09:31:33.519]             c <- base::c
[09:31:33.519]             inherits <- base::inherits
[09:31:33.519]             invokeRestart <- base::invokeRestart
[09:31:33.519]             length <- base::length
[09:31:33.519]             list <- base::list
[09:31:33.519]             seq.int <- base::seq.int
[09:31:33.519]             signalCondition <- base::signalCondition
[09:31:33.519]             sys.calls <- base::sys.calls
[09:31:33.519]             `[[` <- base::`[[`
[09:31:33.519]             `+` <- base::`+`
[09:31:33.519]             `<<-` <- base::`<<-`
[09:31:33.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.519]                   3L)]
[09:31:33.519]             }
[09:31:33.519]             function(cond) {
[09:31:33.519]                 is_error <- inherits(cond, "error")
[09:31:33.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.519]                   NULL)
[09:31:33.519]                 if (is_error) {
[09:31:33.519]                   sessionInformation <- function() {
[09:31:33.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.519]                       search = base::search(), system = base::Sys.info())
[09:31:33.519]                   }
[09:31:33.519]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.519]                     cond$call), session = sessionInformation(), 
[09:31:33.519]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.519]                   signalCondition(cond)
[09:31:33.519]                 }
[09:31:33.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.519]                 "immediateCondition"))) {
[09:31:33.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.519]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.519]                   if (TRUE && !signal) {
[09:31:33.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.519]                     {
[09:31:33.519]                       inherits <- base::inherits
[09:31:33.519]                       invokeRestart <- base::invokeRestart
[09:31:33.519]                       is.null <- base::is.null
[09:31:33.519]                       muffled <- FALSE
[09:31:33.519]                       if (inherits(cond, "message")) {
[09:31:33.519]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.519]                         if (muffled) 
[09:31:33.519]                           invokeRestart("muffleMessage")
[09:31:33.519]                       }
[09:31:33.519]                       else if (inherits(cond, "warning")) {
[09:31:33.519]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.519]                         if (muffled) 
[09:31:33.519]                           invokeRestart("muffleWarning")
[09:31:33.519]                       }
[09:31:33.519]                       else if (inherits(cond, "condition")) {
[09:31:33.519]                         if (!is.null(pattern)) {
[09:31:33.519]                           computeRestarts <- base::computeRestarts
[09:31:33.519]                           grepl <- base::grepl
[09:31:33.519]                           restarts <- computeRestarts(cond)
[09:31:33.519]                           for (restart in restarts) {
[09:31:33.519]                             name <- restart$name
[09:31:33.519]                             if (is.null(name)) 
[09:31:33.519]                               next
[09:31:33.519]                             if (!grepl(pattern, name)) 
[09:31:33.519]                               next
[09:31:33.519]                             invokeRestart(restart)
[09:31:33.519]                             muffled <- TRUE
[09:31:33.519]                             break
[09:31:33.519]                           }
[09:31:33.519]                         }
[09:31:33.519]                       }
[09:31:33.519]                       invisible(muffled)
[09:31:33.519]                     }
[09:31:33.519]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.519]                   }
[09:31:33.519]                 }
[09:31:33.519]                 else {
[09:31:33.519]                   if (TRUE) {
[09:31:33.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.519]                     {
[09:31:33.519]                       inherits <- base::inherits
[09:31:33.519]                       invokeRestart <- base::invokeRestart
[09:31:33.519]                       is.null <- base::is.null
[09:31:33.519]                       muffled <- FALSE
[09:31:33.519]                       if (inherits(cond, "message")) {
[09:31:33.519]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.519]                         if (muffled) 
[09:31:33.519]                           invokeRestart("muffleMessage")
[09:31:33.519]                       }
[09:31:33.519]                       else if (inherits(cond, "warning")) {
[09:31:33.519]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.519]                         if (muffled) 
[09:31:33.519]                           invokeRestart("muffleWarning")
[09:31:33.519]                       }
[09:31:33.519]                       else if (inherits(cond, "condition")) {
[09:31:33.519]                         if (!is.null(pattern)) {
[09:31:33.519]                           computeRestarts <- base::computeRestarts
[09:31:33.519]                           grepl <- base::grepl
[09:31:33.519]                           restarts <- computeRestarts(cond)
[09:31:33.519]                           for (restart in restarts) {
[09:31:33.519]                             name <- restart$name
[09:31:33.519]                             if (is.null(name)) 
[09:31:33.519]                               next
[09:31:33.519]                             if (!grepl(pattern, name)) 
[09:31:33.519]                               next
[09:31:33.519]                             invokeRestart(restart)
[09:31:33.519]                             muffled <- TRUE
[09:31:33.519]                             break
[09:31:33.519]                           }
[09:31:33.519]                         }
[09:31:33.519]                       }
[09:31:33.519]                       invisible(muffled)
[09:31:33.519]                     }
[09:31:33.519]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.519]                   }
[09:31:33.519]                 }
[09:31:33.519]             }
[09:31:33.519]         }))
[09:31:33.519]     }, error = function(ex) {
[09:31:33.519]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.519]                 ...future.rng), started = ...future.startTime, 
[09:31:33.519]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.519]             version = "1.8"), class = "FutureResult")
[09:31:33.519]     }, finally = {
[09:31:33.519]         if (!identical(...future.workdir, getwd())) 
[09:31:33.519]             setwd(...future.workdir)
[09:31:33.519]         {
[09:31:33.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.519]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.519]             }
[09:31:33.519]             base::options(...future.oldOptions)
[09:31:33.519]             if (.Platform$OS.type == "windows") {
[09:31:33.519]                 old_names <- names(...future.oldEnvVars)
[09:31:33.519]                 envs <- base::Sys.getenv()
[09:31:33.519]                 names <- names(envs)
[09:31:33.519]                 common <- intersect(names, old_names)
[09:31:33.519]                 added <- setdiff(names, old_names)
[09:31:33.519]                 removed <- setdiff(old_names, names)
[09:31:33.519]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.519]                   envs[common]]
[09:31:33.519]                 NAMES <- toupper(changed)
[09:31:33.519]                 args <- list()
[09:31:33.519]                 for (kk in seq_along(NAMES)) {
[09:31:33.519]                   name <- changed[[kk]]
[09:31:33.519]                   NAME <- NAMES[[kk]]
[09:31:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.519]                     next
[09:31:33.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.519]                 }
[09:31:33.519]                 NAMES <- toupper(added)
[09:31:33.519]                 for (kk in seq_along(NAMES)) {
[09:31:33.519]                   name <- added[[kk]]
[09:31:33.519]                   NAME <- NAMES[[kk]]
[09:31:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.519]                     next
[09:31:33.519]                   args[[name]] <- ""
[09:31:33.519]                 }
[09:31:33.519]                 NAMES <- toupper(removed)
[09:31:33.519]                 for (kk in seq_along(NAMES)) {
[09:31:33.519]                   name <- removed[[kk]]
[09:31:33.519]                   NAME <- NAMES[[kk]]
[09:31:33.519]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.519]                     next
[09:31:33.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.519]                 }
[09:31:33.519]                 if (length(args) > 0) 
[09:31:33.519]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.519]             }
[09:31:33.519]             else {
[09:31:33.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.519]             }
[09:31:33.519]             {
[09:31:33.519]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.519]                   0L) {
[09:31:33.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.519]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.519]                   base::options(opts)
[09:31:33.519]                 }
[09:31:33.519]                 {
[09:31:33.519]                   {
[09:31:33.519]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.519]                     NULL
[09:31:33.519]                   }
[09:31:33.519]                   options(future.plan = NULL)
[09:31:33.519]                   if (is.na(NA_character_)) 
[09:31:33.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.519]                     .init = FALSE)
[09:31:33.519]                 }
[09:31:33.519]             }
[09:31:33.519]         }
[09:31:33.519]     })
[09:31:33.519]     if (TRUE) {
[09:31:33.519]         base::sink(type = "output", split = FALSE)
[09:31:33.519]         if (TRUE) {
[09:31:33.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.519]         }
[09:31:33.519]         else {
[09:31:33.519]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.519]         }
[09:31:33.519]         base::close(...future.stdout)
[09:31:33.519]         ...future.stdout <- NULL
[09:31:33.519]     }
[09:31:33.519]     ...future.result$conditions <- ...future.conditions
[09:31:33.519]     ...future.result$finished <- base::Sys.time()
[09:31:33.519]     ...future.result
[09:31:33.519] }
[09:31:33.521] requestCore(): workers = 2
[09:31:33.523] MulticoreFuture started
[09:31:33.523] - Launch lazy future ... done
[09:31:33.524] run() for ‘MulticoreFuture’ ... done
[09:31:33.524] result() for MulticoreFuture ...
[09:31:33.524] plan(): Setting new future strategy stack:
[09:31:33.524] List of future strategies:
[09:31:33.524] 1. sequential:
[09:31:33.524]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.524]    - tweaked: FALSE
[09:31:33.524]    - call: NULL
[09:31:33.525] plan(): nbrOfWorkers() = 1
[09:31:33.527] plan(): Setting new future strategy stack:
[09:31:33.528] List of future strategies:
[09:31:33.528] 1. multicore:
[09:31:33.528]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.528]    - tweaked: FALSE
[09:31:33.528]    - call: plan(strategy)
[09:31:33.532] plan(): nbrOfWorkers() = 2
[09:31:33.538] result() for MulticoreFuture ...
[09:31:33.539] result() for MulticoreFuture ... done
[09:31:33.539] signalConditions() ...
[09:31:33.539]  - include = ‘immediateCondition’
[09:31:33.539]  - exclude = 
[09:31:33.539]  - resignal = FALSE
[09:31:33.539]  - Number of conditions: 1
[09:31:33.539] signalConditions() ... done
[09:31:33.539] result() for MulticoreFuture ... done
[09:31:33.540] result() for MulticoreFuture ...
[09:31:33.540] result() for MulticoreFuture ... done
[09:31:33.540] signalConditions() ...
[09:31:33.540]  - include = ‘immediateCondition’
[09:31:33.540]  - exclude = 
[09:31:33.540]  - resignal = FALSE
[09:31:33.540]  - Number of conditions: 1
[09:31:33.540] signalConditions() ... done
[09:31:33.541] Future state: ‘finished’
[09:31:33.541] result() for MulticoreFuture ...
[09:31:33.541] result() for MulticoreFuture ... done
[09:31:33.541] signalConditions() ...
[09:31:33.541]  - include = ‘condition’
[09:31:33.541]  - exclude = ‘immediateCondition’
[09:31:33.541]  - resignal = TRUE
[09:31:33.541]  - Number of conditions: 1
[09:31:33.541]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:33.542] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:33"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.569] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.569] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.571] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.571] Searching for globals ... DONE
[09:31:33.571] Resolving globals: TRUE
[09:31:33.571] Resolving any globals that are futures ...
[09:31:33.571] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.571] Resolving any globals that are futures ... DONE
[09:31:33.572] Resolving futures part of globals (recursively) ...
[09:31:33.572] resolve() on list ...
[09:31:33.572]  recursive: 99
[09:31:33.572]  length: 1
[09:31:33.572]  elements: ‘ii’
[09:31:33.572]  length: 0 (resolved future 1)
[09:31:33.572] resolve() on list ... DONE
[09:31:33.573] - globals: [1] ‘ii’
[09:31:33.573] Resolving futures part of globals (recursively) ... DONE
[09:31:33.573] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.573] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.573] - globals: [1] ‘ii’
[09:31:33.573] 
[09:31:33.573] getGlobalsAndPackages() ... DONE
[09:31:33.574] run() for ‘Future’ ...
[09:31:33.574] - state: ‘created’
[09:31:33.574] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.578] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.578] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.578]   - Field: ‘label’
[09:31:33.578]   - Field: ‘local’
[09:31:33.578]   - Field: ‘owner’
[09:31:33.578]   - Field: ‘envir’
[09:31:33.578]   - Field: ‘workers’
[09:31:33.580]   - Field: ‘packages’
[09:31:33.580]   - Field: ‘gc’
[09:31:33.580]   - Field: ‘job’
[09:31:33.580]   - Field: ‘conditions’
[09:31:33.580]   - Field: ‘expr’
[09:31:33.580]   - Field: ‘uuid’
[09:31:33.580]   - Field: ‘seed’
[09:31:33.580]   - Field: ‘version’
[09:31:33.580]   - Field: ‘result’
[09:31:33.580]   - Field: ‘asynchronous’
[09:31:33.581]   - Field: ‘calls’
[09:31:33.581]   - Field: ‘globals’
[09:31:33.581]   - Field: ‘stdout’
[09:31:33.581]   - Field: ‘earlySignal’
[09:31:33.581]   - Field: ‘lazy’
[09:31:33.581]   - Field: ‘state’
[09:31:33.581] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.581] - Launch lazy future ...
[09:31:33.581] Packages needed by the future expression (n = 0): <none>
[09:31:33.582] Packages needed by future strategies (n = 0): <none>
[09:31:33.582] {
[09:31:33.582]     {
[09:31:33.582]         {
[09:31:33.582]             ...future.startTime <- base::Sys.time()
[09:31:33.582]             {
[09:31:33.582]                 {
[09:31:33.582]                   {
[09:31:33.582]                     {
[09:31:33.582]                       base::local({
[09:31:33.582]                         has_future <- base::requireNamespace("future", 
[09:31:33.582]                           quietly = TRUE)
[09:31:33.582]                         if (has_future) {
[09:31:33.582]                           ns <- base::getNamespace("future")
[09:31:33.582]                           version <- ns[[".package"]][["version"]]
[09:31:33.582]                           if (is.null(version)) 
[09:31:33.582]                             version <- utils::packageVersion("future")
[09:31:33.582]                         }
[09:31:33.582]                         else {
[09:31:33.582]                           version <- NULL
[09:31:33.582]                         }
[09:31:33.582]                         if (!has_future || version < "1.8.0") {
[09:31:33.582]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.582]                             "", base::R.version$version.string), 
[09:31:33.582]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.582]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.582]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.582]                               "release", "version")], collapse = " "), 
[09:31:33.582]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.582]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.582]                             info)
[09:31:33.582]                           info <- base::paste(info, collapse = "; ")
[09:31:33.582]                           if (!has_future) {
[09:31:33.582]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.582]                               info)
[09:31:33.582]                           }
[09:31:33.582]                           else {
[09:31:33.582]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.582]                               info, version)
[09:31:33.582]                           }
[09:31:33.582]                           base::stop(msg)
[09:31:33.582]                         }
[09:31:33.582]                       })
[09:31:33.582]                     }
[09:31:33.582]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.582]                     base::options(mc.cores = 1L)
[09:31:33.582]                   }
[09:31:33.582]                   ...future.strategy.old <- future::plan("list")
[09:31:33.582]                   options(future.plan = NULL)
[09:31:33.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.582]                 }
[09:31:33.582]                 ...future.workdir <- getwd()
[09:31:33.582]             }
[09:31:33.582]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.582]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.582]         }
[09:31:33.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.582]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.582]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.582]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.582]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.582]             base::names(...future.oldOptions))
[09:31:33.582]     }
[09:31:33.582]     if (FALSE) {
[09:31:33.582]     }
[09:31:33.582]     else {
[09:31:33.582]         if (TRUE) {
[09:31:33.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.582]                 open = "w")
[09:31:33.582]         }
[09:31:33.582]         else {
[09:31:33.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.582]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.582]         }
[09:31:33.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.582]             base::sink(type = "output", split = FALSE)
[09:31:33.582]             base::close(...future.stdout)
[09:31:33.582]         }, add = TRUE)
[09:31:33.582]     }
[09:31:33.582]     ...future.frame <- base::sys.nframe()
[09:31:33.582]     ...future.conditions <- base::list()
[09:31:33.582]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.582]     if (FALSE) {
[09:31:33.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.582]     }
[09:31:33.582]     ...future.result <- base::tryCatch({
[09:31:33.582]         base::withCallingHandlers({
[09:31:33.582]             ...future.value <- base::withVisible(base::local({
[09:31:33.582]                 withCallingHandlers({
[09:31:33.582]                   {
[09:31:33.582]                     b <- a * ii
[09:31:33.582]                     a <- 0
[09:31:33.582]                     b
[09:31:33.582]                   }
[09:31:33.582]                 }, immediateCondition = function(cond) {
[09:31:33.582]                   save_rds <- function (object, pathname, ...) 
[09:31:33.582]                   {
[09:31:33.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.582]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.582]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.582]                         fi_tmp[["mtime"]])
[09:31:33.582]                     }
[09:31:33.582]                     tryCatch({
[09:31:33.582]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.582]                     }, error = function(ex) {
[09:31:33.582]                       msg <- conditionMessage(ex)
[09:31:33.582]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.582]                         fi_tmp[["mtime"]], msg)
[09:31:33.582]                       ex$message <- msg
[09:31:33.582]                       stop(ex)
[09:31:33.582]                     })
[09:31:33.582]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.582]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.582]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.582]                       fi <- file.info(pathname)
[09:31:33.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.582]                         fi[["size"]], fi[["mtime"]])
[09:31:33.582]                       stop(msg)
[09:31:33.582]                     }
[09:31:33.582]                     invisible(pathname)
[09:31:33.582]                   }
[09:31:33.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.582]                     rootPath = tempdir()) 
[09:31:33.582]                   {
[09:31:33.582]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.582]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.582]                       tmpdir = path, fileext = ".rds")
[09:31:33.582]                     save_rds(obj, file)
[09:31:33.582]                   }
[09:31:33.582]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.582]                   {
[09:31:33.582]                     inherits <- base::inherits
[09:31:33.582]                     invokeRestart <- base::invokeRestart
[09:31:33.582]                     is.null <- base::is.null
[09:31:33.582]                     muffled <- FALSE
[09:31:33.582]                     if (inherits(cond, "message")) {
[09:31:33.582]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.582]                       if (muffled) 
[09:31:33.582]                         invokeRestart("muffleMessage")
[09:31:33.582]                     }
[09:31:33.582]                     else if (inherits(cond, "warning")) {
[09:31:33.582]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.582]                       if (muffled) 
[09:31:33.582]                         invokeRestart("muffleWarning")
[09:31:33.582]                     }
[09:31:33.582]                     else if (inherits(cond, "condition")) {
[09:31:33.582]                       if (!is.null(pattern)) {
[09:31:33.582]                         computeRestarts <- base::computeRestarts
[09:31:33.582]                         grepl <- base::grepl
[09:31:33.582]                         restarts <- computeRestarts(cond)
[09:31:33.582]                         for (restart in restarts) {
[09:31:33.582]                           name <- restart$name
[09:31:33.582]                           if (is.null(name)) 
[09:31:33.582]                             next
[09:31:33.582]                           if (!grepl(pattern, name)) 
[09:31:33.582]                             next
[09:31:33.582]                           invokeRestart(restart)
[09:31:33.582]                           muffled <- TRUE
[09:31:33.582]                           break
[09:31:33.582]                         }
[09:31:33.582]                       }
[09:31:33.582]                     }
[09:31:33.582]                     invisible(muffled)
[09:31:33.582]                   }
[09:31:33.582]                   muffleCondition(cond)
[09:31:33.582]                 })
[09:31:33.582]             }))
[09:31:33.582]             future::FutureResult(value = ...future.value$value, 
[09:31:33.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.582]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.582]                     ...future.globalenv.names))
[09:31:33.582]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.582]         }, condition = base::local({
[09:31:33.582]             c <- base::c
[09:31:33.582]             inherits <- base::inherits
[09:31:33.582]             invokeRestart <- base::invokeRestart
[09:31:33.582]             length <- base::length
[09:31:33.582]             list <- base::list
[09:31:33.582]             seq.int <- base::seq.int
[09:31:33.582]             signalCondition <- base::signalCondition
[09:31:33.582]             sys.calls <- base::sys.calls
[09:31:33.582]             `[[` <- base::`[[`
[09:31:33.582]             `+` <- base::`+`
[09:31:33.582]             `<<-` <- base::`<<-`
[09:31:33.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.582]                   3L)]
[09:31:33.582]             }
[09:31:33.582]             function(cond) {
[09:31:33.582]                 is_error <- inherits(cond, "error")
[09:31:33.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.582]                   NULL)
[09:31:33.582]                 if (is_error) {
[09:31:33.582]                   sessionInformation <- function() {
[09:31:33.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.582]                       search = base::search(), system = base::Sys.info())
[09:31:33.582]                   }
[09:31:33.582]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.582]                     cond$call), session = sessionInformation(), 
[09:31:33.582]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.582]                   signalCondition(cond)
[09:31:33.582]                 }
[09:31:33.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.582]                 "immediateCondition"))) {
[09:31:33.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.582]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.582]                   if (TRUE && !signal) {
[09:31:33.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.582]                     {
[09:31:33.582]                       inherits <- base::inherits
[09:31:33.582]                       invokeRestart <- base::invokeRestart
[09:31:33.582]                       is.null <- base::is.null
[09:31:33.582]                       muffled <- FALSE
[09:31:33.582]                       if (inherits(cond, "message")) {
[09:31:33.582]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.582]                         if (muffled) 
[09:31:33.582]                           invokeRestart("muffleMessage")
[09:31:33.582]                       }
[09:31:33.582]                       else if (inherits(cond, "warning")) {
[09:31:33.582]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.582]                         if (muffled) 
[09:31:33.582]                           invokeRestart("muffleWarning")
[09:31:33.582]                       }
[09:31:33.582]                       else if (inherits(cond, "condition")) {
[09:31:33.582]                         if (!is.null(pattern)) {
[09:31:33.582]                           computeRestarts <- base::computeRestarts
[09:31:33.582]                           grepl <- base::grepl
[09:31:33.582]                           restarts <- computeRestarts(cond)
[09:31:33.582]                           for (restart in restarts) {
[09:31:33.582]                             name <- restart$name
[09:31:33.582]                             if (is.null(name)) 
[09:31:33.582]                               next
[09:31:33.582]                             if (!grepl(pattern, name)) 
[09:31:33.582]                               next
[09:31:33.582]                             invokeRestart(restart)
[09:31:33.582]                             muffled <- TRUE
[09:31:33.582]                             break
[09:31:33.582]                           }
[09:31:33.582]                         }
[09:31:33.582]                       }
[09:31:33.582]                       invisible(muffled)
[09:31:33.582]                     }
[09:31:33.582]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.582]                   }
[09:31:33.582]                 }
[09:31:33.582]                 else {
[09:31:33.582]                   if (TRUE) {
[09:31:33.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.582]                     {
[09:31:33.582]                       inherits <- base::inherits
[09:31:33.582]                       invokeRestart <- base::invokeRestart
[09:31:33.582]                       is.null <- base::is.null
[09:31:33.582]                       muffled <- FALSE
[09:31:33.582]                       if (inherits(cond, "message")) {
[09:31:33.582]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.582]                         if (muffled) 
[09:31:33.582]                           invokeRestart("muffleMessage")
[09:31:33.582]                       }
[09:31:33.582]                       else if (inherits(cond, "warning")) {
[09:31:33.582]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.582]                         if (muffled) 
[09:31:33.582]                           invokeRestart("muffleWarning")
[09:31:33.582]                       }
[09:31:33.582]                       else if (inherits(cond, "condition")) {
[09:31:33.582]                         if (!is.null(pattern)) {
[09:31:33.582]                           computeRestarts <- base::computeRestarts
[09:31:33.582]                           grepl <- base::grepl
[09:31:33.582]                           restarts <- computeRestarts(cond)
[09:31:33.582]                           for (restart in restarts) {
[09:31:33.582]                             name <- restart$name
[09:31:33.582]                             if (is.null(name)) 
[09:31:33.582]                               next
[09:31:33.582]                             if (!grepl(pattern, name)) 
[09:31:33.582]                               next
[09:31:33.582]                             invokeRestart(restart)
[09:31:33.582]                             muffled <- TRUE
[09:31:33.582]                             break
[09:31:33.582]                           }
[09:31:33.582]                         }
[09:31:33.582]                       }
[09:31:33.582]                       invisible(muffled)
[09:31:33.582]                     }
[09:31:33.582]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.582]                   }
[09:31:33.582]                 }
[09:31:33.582]             }
[09:31:33.582]         }))
[09:31:33.582]     }, error = function(ex) {
[09:31:33.582]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.582]                 ...future.rng), started = ...future.startTime, 
[09:31:33.582]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.582]             version = "1.8"), class = "FutureResult")
[09:31:33.582]     }, finally = {
[09:31:33.582]         if (!identical(...future.workdir, getwd())) 
[09:31:33.582]             setwd(...future.workdir)
[09:31:33.582]         {
[09:31:33.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.582]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.582]             }
[09:31:33.582]             base::options(...future.oldOptions)
[09:31:33.582]             if (.Platform$OS.type == "windows") {
[09:31:33.582]                 old_names <- names(...future.oldEnvVars)
[09:31:33.582]                 envs <- base::Sys.getenv()
[09:31:33.582]                 names <- names(envs)
[09:31:33.582]                 common <- intersect(names, old_names)
[09:31:33.582]                 added <- setdiff(names, old_names)
[09:31:33.582]                 removed <- setdiff(old_names, names)
[09:31:33.582]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.582]                   envs[common]]
[09:31:33.582]                 NAMES <- toupper(changed)
[09:31:33.582]                 args <- list()
[09:31:33.582]                 for (kk in seq_along(NAMES)) {
[09:31:33.582]                   name <- changed[[kk]]
[09:31:33.582]                   NAME <- NAMES[[kk]]
[09:31:33.582]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.582]                     next
[09:31:33.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.582]                 }
[09:31:33.582]                 NAMES <- toupper(added)
[09:31:33.582]                 for (kk in seq_along(NAMES)) {
[09:31:33.582]                   name <- added[[kk]]
[09:31:33.582]                   NAME <- NAMES[[kk]]
[09:31:33.582]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.582]                     next
[09:31:33.582]                   args[[name]] <- ""
[09:31:33.582]                 }
[09:31:33.582]                 NAMES <- toupper(removed)
[09:31:33.582]                 for (kk in seq_along(NAMES)) {
[09:31:33.582]                   name <- removed[[kk]]
[09:31:33.582]                   NAME <- NAMES[[kk]]
[09:31:33.582]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.582]                     next
[09:31:33.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.582]                 }
[09:31:33.582]                 if (length(args) > 0) 
[09:31:33.582]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.582]             }
[09:31:33.582]             else {
[09:31:33.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.582]             }
[09:31:33.582]             {
[09:31:33.582]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.582]                   0L) {
[09:31:33.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.582]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.582]                   base::options(opts)
[09:31:33.582]                 }
[09:31:33.582]                 {
[09:31:33.582]                   {
[09:31:33.582]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.582]                     NULL
[09:31:33.582]                   }
[09:31:33.582]                   options(future.plan = NULL)
[09:31:33.582]                   if (is.na(NA_character_)) 
[09:31:33.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.582]                     .init = FALSE)
[09:31:33.582]                 }
[09:31:33.582]             }
[09:31:33.582]         }
[09:31:33.582]     })
[09:31:33.582]     if (TRUE) {
[09:31:33.582]         base::sink(type = "output", split = FALSE)
[09:31:33.582]         if (TRUE) {
[09:31:33.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.582]         }
[09:31:33.582]         else {
[09:31:33.582]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.582]         }
[09:31:33.582]         base::close(...future.stdout)
[09:31:33.582]         ...future.stdout <- NULL
[09:31:33.582]     }
[09:31:33.582]     ...future.result$conditions <- ...future.conditions
[09:31:33.582]     ...future.result$finished <- base::Sys.time()
[09:31:33.582]     ...future.result
[09:31:33.582] }
[09:31:33.584] assign_globals() ...
[09:31:33.584] List of 1
[09:31:33.584]  $ ii: int 1
[09:31:33.584]  - attr(*, "where")=List of 1
[09:31:33.584]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.584]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.584]  - attr(*, "resolved")= logi TRUE
[09:31:33.584]  - attr(*, "total_size")= num 56
[09:31:33.584]  - attr(*, "already-done")= logi TRUE
[09:31:33.587] - copied ‘ii’ to environment
[09:31:33.587] assign_globals() ... done
[09:31:33.587] requestCore(): workers = 2
[09:31:33.589] MulticoreFuture started
[09:31:33.589] - Launch lazy future ... done
[09:31:33.590] run() for ‘MulticoreFuture’ ... done
[09:31:33.590] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.591] getGlobalsAndPackages() ...
[09:31:33.590] List of future strategies:
[09:31:33.590] 1. sequential:
[09:31:33.590]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.590]    - tweaked: FALSE
[09:31:33.590]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.591] plan(): nbrOfWorkers() = 1
[09:31:33.591] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.593] plan(): Setting new future strategy stack:
[09:31:33.593] List of future strategies:
[09:31:33.593] 1. multicore:
[09:31:33.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.593]    - tweaked: FALSE
[09:31:33.593]    - call: plan(strategy)
[09:31:33.594] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.594] Searching for globals ... DONE
[09:31:33.594] Resolving globals: TRUE
[09:31:33.595] Resolving any globals that are futures ...
[09:31:33.595] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.595] Resolving any globals that are futures ... DONE
[09:31:33.596] Resolving futures part of globals (recursively) ...
[09:31:33.596] resolve() on list ...
[09:31:33.596]  recursive: 99
[09:31:33.596]  length: 1
[09:31:33.597]  elements: ‘ii’
[09:31:33.597]  length: 0 (resolved future 1)
[09:31:33.597] resolve() on list ... DONE
[09:31:33.597] - globals: [1] ‘ii’
[09:31:33.597] Resolving futures part of globals (recursively) ... DONE
[09:31:33.598] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.598] plan(): nbrOfWorkers() = 2
[09:31:33.598] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.598] - globals: [1] ‘ii’
[09:31:33.598] 
[09:31:33.599] getGlobalsAndPackages() ... DONE
[09:31:33.599] run() for ‘Future’ ...
[09:31:33.599] - state: ‘created’
[09:31:33.599] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.604]   - Field: ‘label’
[09:31:33.604]   - Field: ‘local’
[09:31:33.604]   - Field: ‘owner’
[09:31:33.605]   - Field: ‘envir’
[09:31:33.605]   - Field: ‘workers’
[09:31:33.605]   - Field: ‘packages’
[09:31:33.605]   - Field: ‘gc’
[09:31:33.605]   - Field: ‘job’
[09:31:33.605]   - Field: ‘conditions’
[09:31:33.605]   - Field: ‘expr’
[09:31:33.605]   - Field: ‘uuid’
[09:31:33.606]   - Field: ‘seed’
[09:31:33.606]   - Field: ‘version’
[09:31:33.606]   - Field: ‘result’
[09:31:33.606]   - Field: ‘asynchronous’
[09:31:33.606]   - Field: ‘calls’
[09:31:33.606]   - Field: ‘globals’
[09:31:33.606]   - Field: ‘stdout’
[09:31:33.607]   - Field: ‘earlySignal’
[09:31:33.607]   - Field: ‘lazy’
[09:31:33.607]   - Field: ‘state’
[09:31:33.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.607] - Launch lazy future ...
[09:31:33.608] Packages needed by the future expression (n = 0): <none>
[09:31:33.608] Packages needed by future strategies (n = 0): <none>
[09:31:33.608] {
[09:31:33.608]     {
[09:31:33.608]         {
[09:31:33.608]             ...future.startTime <- base::Sys.time()
[09:31:33.608]             {
[09:31:33.608]                 {
[09:31:33.608]                   {
[09:31:33.608]                     {
[09:31:33.608]                       base::local({
[09:31:33.608]                         has_future <- base::requireNamespace("future", 
[09:31:33.608]                           quietly = TRUE)
[09:31:33.608]                         if (has_future) {
[09:31:33.608]                           ns <- base::getNamespace("future")
[09:31:33.608]                           version <- ns[[".package"]][["version"]]
[09:31:33.608]                           if (is.null(version)) 
[09:31:33.608]                             version <- utils::packageVersion("future")
[09:31:33.608]                         }
[09:31:33.608]                         else {
[09:31:33.608]                           version <- NULL
[09:31:33.608]                         }
[09:31:33.608]                         if (!has_future || version < "1.8.0") {
[09:31:33.608]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.608]                             "", base::R.version$version.string), 
[09:31:33.608]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.608]                               "release", "version")], collapse = " "), 
[09:31:33.608]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.608]                             info)
[09:31:33.608]                           info <- base::paste(info, collapse = "; ")
[09:31:33.608]                           if (!has_future) {
[09:31:33.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.608]                               info)
[09:31:33.608]                           }
[09:31:33.608]                           else {
[09:31:33.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.608]                               info, version)
[09:31:33.608]                           }
[09:31:33.608]                           base::stop(msg)
[09:31:33.608]                         }
[09:31:33.608]                       })
[09:31:33.608]                     }
[09:31:33.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.608]                     base::options(mc.cores = 1L)
[09:31:33.608]                   }
[09:31:33.608]                   ...future.strategy.old <- future::plan("list")
[09:31:33.608]                   options(future.plan = NULL)
[09:31:33.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.608]                 }
[09:31:33.608]                 ...future.workdir <- getwd()
[09:31:33.608]             }
[09:31:33.608]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.608]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.608]         }
[09:31:33.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.608]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.608]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.608]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.608]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.608]             base::names(...future.oldOptions))
[09:31:33.608]     }
[09:31:33.608]     if (FALSE) {
[09:31:33.608]     }
[09:31:33.608]     else {
[09:31:33.608]         if (TRUE) {
[09:31:33.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.608]                 open = "w")
[09:31:33.608]         }
[09:31:33.608]         else {
[09:31:33.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.608]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.608]         }
[09:31:33.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.608]             base::sink(type = "output", split = FALSE)
[09:31:33.608]             base::close(...future.stdout)
[09:31:33.608]         }, add = TRUE)
[09:31:33.608]     }
[09:31:33.608]     ...future.frame <- base::sys.nframe()
[09:31:33.608]     ...future.conditions <- base::list()
[09:31:33.608]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.608]     if (FALSE) {
[09:31:33.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.608]     }
[09:31:33.608]     ...future.result <- base::tryCatch({
[09:31:33.608]         base::withCallingHandlers({
[09:31:33.608]             ...future.value <- base::withVisible(base::local({
[09:31:33.608]                 withCallingHandlers({
[09:31:33.608]                   {
[09:31:33.608]                     b <- a * ii
[09:31:33.608]                     a <- 0
[09:31:33.608]                     b
[09:31:33.608]                   }
[09:31:33.608]                 }, immediateCondition = function(cond) {
[09:31:33.608]                   save_rds <- function (object, pathname, ...) 
[09:31:33.608]                   {
[09:31:33.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.608]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.608]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.608]                         fi_tmp[["mtime"]])
[09:31:33.608]                     }
[09:31:33.608]                     tryCatch({
[09:31:33.608]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.608]                     }, error = function(ex) {
[09:31:33.608]                       msg <- conditionMessage(ex)
[09:31:33.608]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.608]                         fi_tmp[["mtime"]], msg)
[09:31:33.608]                       ex$message <- msg
[09:31:33.608]                       stop(ex)
[09:31:33.608]                     })
[09:31:33.608]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.608]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.608]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.608]                       fi <- file.info(pathname)
[09:31:33.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.608]                         fi[["size"]], fi[["mtime"]])
[09:31:33.608]                       stop(msg)
[09:31:33.608]                     }
[09:31:33.608]                     invisible(pathname)
[09:31:33.608]                   }
[09:31:33.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.608]                     rootPath = tempdir()) 
[09:31:33.608]                   {
[09:31:33.608]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.608]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.608]                       tmpdir = path, fileext = ".rds")
[09:31:33.608]                     save_rds(obj, file)
[09:31:33.608]                   }
[09:31:33.608]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.608]                   {
[09:31:33.608]                     inherits <- base::inherits
[09:31:33.608]                     invokeRestart <- base::invokeRestart
[09:31:33.608]                     is.null <- base::is.null
[09:31:33.608]                     muffled <- FALSE
[09:31:33.608]                     if (inherits(cond, "message")) {
[09:31:33.608]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.608]                       if (muffled) 
[09:31:33.608]                         invokeRestart("muffleMessage")
[09:31:33.608]                     }
[09:31:33.608]                     else if (inherits(cond, "warning")) {
[09:31:33.608]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.608]                       if (muffled) 
[09:31:33.608]                         invokeRestart("muffleWarning")
[09:31:33.608]                     }
[09:31:33.608]                     else if (inherits(cond, "condition")) {
[09:31:33.608]                       if (!is.null(pattern)) {
[09:31:33.608]                         computeRestarts <- base::computeRestarts
[09:31:33.608]                         grepl <- base::grepl
[09:31:33.608]                         restarts <- computeRestarts(cond)
[09:31:33.608]                         for (restart in restarts) {
[09:31:33.608]                           name <- restart$name
[09:31:33.608]                           if (is.null(name)) 
[09:31:33.608]                             next
[09:31:33.608]                           if (!grepl(pattern, name)) 
[09:31:33.608]                             next
[09:31:33.608]                           invokeRestart(restart)
[09:31:33.608]                           muffled <- TRUE
[09:31:33.608]                           break
[09:31:33.608]                         }
[09:31:33.608]                       }
[09:31:33.608]                     }
[09:31:33.608]                     invisible(muffled)
[09:31:33.608]                   }
[09:31:33.608]                   muffleCondition(cond)
[09:31:33.608]                 })
[09:31:33.608]             }))
[09:31:33.608]             future::FutureResult(value = ...future.value$value, 
[09:31:33.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.608]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.608]                     ...future.globalenv.names))
[09:31:33.608]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.608]         }, condition = base::local({
[09:31:33.608]             c <- base::c
[09:31:33.608]             inherits <- base::inherits
[09:31:33.608]             invokeRestart <- base::invokeRestart
[09:31:33.608]             length <- base::length
[09:31:33.608]             list <- base::list
[09:31:33.608]             seq.int <- base::seq.int
[09:31:33.608]             signalCondition <- base::signalCondition
[09:31:33.608]             sys.calls <- base::sys.calls
[09:31:33.608]             `[[` <- base::`[[`
[09:31:33.608]             `+` <- base::`+`
[09:31:33.608]             `<<-` <- base::`<<-`
[09:31:33.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.608]                   3L)]
[09:31:33.608]             }
[09:31:33.608]             function(cond) {
[09:31:33.608]                 is_error <- inherits(cond, "error")
[09:31:33.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.608]                   NULL)
[09:31:33.608]                 if (is_error) {
[09:31:33.608]                   sessionInformation <- function() {
[09:31:33.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.608]                       search = base::search(), system = base::Sys.info())
[09:31:33.608]                   }
[09:31:33.608]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.608]                     cond$call), session = sessionInformation(), 
[09:31:33.608]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.608]                   signalCondition(cond)
[09:31:33.608]                 }
[09:31:33.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.608]                 "immediateCondition"))) {
[09:31:33.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.608]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.608]                   if (TRUE && !signal) {
[09:31:33.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.608]                     {
[09:31:33.608]                       inherits <- base::inherits
[09:31:33.608]                       invokeRestart <- base::invokeRestart
[09:31:33.608]                       is.null <- base::is.null
[09:31:33.608]                       muffled <- FALSE
[09:31:33.608]                       if (inherits(cond, "message")) {
[09:31:33.608]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.608]                         if (muffled) 
[09:31:33.608]                           invokeRestart("muffleMessage")
[09:31:33.608]                       }
[09:31:33.608]                       else if (inherits(cond, "warning")) {
[09:31:33.608]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.608]                         if (muffled) 
[09:31:33.608]                           invokeRestart("muffleWarning")
[09:31:33.608]                       }
[09:31:33.608]                       else if (inherits(cond, "condition")) {
[09:31:33.608]                         if (!is.null(pattern)) {
[09:31:33.608]                           computeRestarts <- base::computeRestarts
[09:31:33.608]                           grepl <- base::grepl
[09:31:33.608]                           restarts <- computeRestarts(cond)
[09:31:33.608]                           for (restart in restarts) {
[09:31:33.608]                             name <- restart$name
[09:31:33.608]                             if (is.null(name)) 
[09:31:33.608]                               next
[09:31:33.608]                             if (!grepl(pattern, name)) 
[09:31:33.608]                               next
[09:31:33.608]                             invokeRestart(restart)
[09:31:33.608]                             muffled <- TRUE
[09:31:33.608]                             break
[09:31:33.608]                           }
[09:31:33.608]                         }
[09:31:33.608]                       }
[09:31:33.608]                       invisible(muffled)
[09:31:33.608]                     }
[09:31:33.608]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.608]                   }
[09:31:33.608]                 }
[09:31:33.608]                 else {
[09:31:33.608]                   if (TRUE) {
[09:31:33.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.608]                     {
[09:31:33.608]                       inherits <- base::inherits
[09:31:33.608]                       invokeRestart <- base::invokeRestart
[09:31:33.608]                       is.null <- base::is.null
[09:31:33.608]                       muffled <- FALSE
[09:31:33.608]                       if (inherits(cond, "message")) {
[09:31:33.608]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.608]                         if (muffled) 
[09:31:33.608]                           invokeRestart("muffleMessage")
[09:31:33.608]                       }
[09:31:33.608]                       else if (inherits(cond, "warning")) {
[09:31:33.608]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.608]                         if (muffled) 
[09:31:33.608]                           invokeRestart("muffleWarning")
[09:31:33.608]                       }
[09:31:33.608]                       else if (inherits(cond, "condition")) {
[09:31:33.608]                         if (!is.null(pattern)) {
[09:31:33.608]                           computeRestarts <- base::computeRestarts
[09:31:33.608]                           grepl <- base::grepl
[09:31:33.608]                           restarts <- computeRestarts(cond)
[09:31:33.608]                           for (restart in restarts) {
[09:31:33.608]                             name <- restart$name
[09:31:33.608]                             if (is.null(name)) 
[09:31:33.608]                               next
[09:31:33.608]                             if (!grepl(pattern, name)) 
[09:31:33.608]                               next
[09:31:33.608]                             invokeRestart(restart)
[09:31:33.608]                             muffled <- TRUE
[09:31:33.608]                             break
[09:31:33.608]                           }
[09:31:33.608]                         }
[09:31:33.608]                       }
[09:31:33.608]                       invisible(muffled)
[09:31:33.608]                     }
[09:31:33.608]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.608]                   }
[09:31:33.608]                 }
[09:31:33.608]             }
[09:31:33.608]         }))
[09:31:33.608]     }, error = function(ex) {
[09:31:33.608]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.608]                 ...future.rng), started = ...future.startTime, 
[09:31:33.608]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.608]             version = "1.8"), class = "FutureResult")
[09:31:33.608]     }, finally = {
[09:31:33.608]         if (!identical(...future.workdir, getwd())) 
[09:31:33.608]             setwd(...future.workdir)
[09:31:33.608]         {
[09:31:33.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.608]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.608]             }
[09:31:33.608]             base::options(...future.oldOptions)
[09:31:33.608]             if (.Platform$OS.type == "windows") {
[09:31:33.608]                 old_names <- names(...future.oldEnvVars)
[09:31:33.608]                 envs <- base::Sys.getenv()
[09:31:33.608]                 names <- names(envs)
[09:31:33.608]                 common <- intersect(names, old_names)
[09:31:33.608]                 added <- setdiff(names, old_names)
[09:31:33.608]                 removed <- setdiff(old_names, names)
[09:31:33.608]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.608]                   envs[common]]
[09:31:33.608]                 NAMES <- toupper(changed)
[09:31:33.608]                 args <- list()
[09:31:33.608]                 for (kk in seq_along(NAMES)) {
[09:31:33.608]                   name <- changed[[kk]]
[09:31:33.608]                   NAME <- NAMES[[kk]]
[09:31:33.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.608]                     next
[09:31:33.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.608]                 }
[09:31:33.608]                 NAMES <- toupper(added)
[09:31:33.608]                 for (kk in seq_along(NAMES)) {
[09:31:33.608]                   name <- added[[kk]]
[09:31:33.608]                   NAME <- NAMES[[kk]]
[09:31:33.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.608]                     next
[09:31:33.608]                   args[[name]] <- ""
[09:31:33.608]                 }
[09:31:33.608]                 NAMES <- toupper(removed)
[09:31:33.608]                 for (kk in seq_along(NAMES)) {
[09:31:33.608]                   name <- removed[[kk]]
[09:31:33.608]                   NAME <- NAMES[[kk]]
[09:31:33.608]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.608]                     next
[09:31:33.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.608]                 }
[09:31:33.608]                 if (length(args) > 0) 
[09:31:33.608]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.608]             }
[09:31:33.608]             else {
[09:31:33.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.608]             }
[09:31:33.608]             {
[09:31:33.608]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.608]                   0L) {
[09:31:33.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.608]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.608]                   base::options(opts)
[09:31:33.608]                 }
[09:31:33.608]                 {
[09:31:33.608]                   {
[09:31:33.608]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.608]                     NULL
[09:31:33.608]                   }
[09:31:33.608]                   options(future.plan = NULL)
[09:31:33.608]                   if (is.na(NA_character_)) 
[09:31:33.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.608]                     .init = FALSE)
[09:31:33.608]                 }
[09:31:33.608]             }
[09:31:33.608]         }
[09:31:33.608]     })
[09:31:33.608]     if (TRUE) {
[09:31:33.608]         base::sink(type = "output", split = FALSE)
[09:31:33.608]         if (TRUE) {
[09:31:33.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.608]         }
[09:31:33.608]         else {
[09:31:33.608]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.608]         }
[09:31:33.608]         base::close(...future.stdout)
[09:31:33.608]         ...future.stdout <- NULL
[09:31:33.608]     }
[09:31:33.608]     ...future.result$conditions <- ...future.conditions
[09:31:33.608]     ...future.result$finished <- base::Sys.time()
[09:31:33.608]     ...future.result
[09:31:33.608] }
[09:31:33.612] assign_globals() ...
[09:31:33.612] List of 1
[09:31:33.612]  $ ii: int 2
[09:31:33.612]  - attr(*, "where")=List of 1
[09:31:33.612]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.612]  - attr(*, "resolved")= logi TRUE
[09:31:33.612]  - attr(*, "total_size")= num 56
[09:31:33.612]  - attr(*, "already-done")= logi TRUE
[09:31:33.616] - copied ‘ii’ to environment
[09:31:33.616] assign_globals() ... done
[09:31:33.617] requestCore(): workers = 2
[09:31:33.619] MulticoreFuture started
[09:31:33.619] - Launch lazy future ... done
[09:31:33.619] run() for ‘MulticoreFuture’ ... done
[09:31:33.620] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.620] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.621] Searching for globals...
[09:31:33.620] List of future strategies:
[09:31:33.620] 1. sequential:
[09:31:33.620]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.620]    - tweaked: FALSE
[09:31:33.620]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.621] plan(): nbrOfWorkers() = 1
[09:31:33.623] plan(): Setting new future strategy stack:
[09:31:33.623] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.624] Searching for globals ... DONE
[09:31:33.623] List of future strategies:
[09:31:33.623] 1. multicore:
[09:31:33.623]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.623]    - tweaked: FALSE
[09:31:33.623]    - call: plan(strategy)
[09:31:33.624] Resolving globals: TRUE
[09:31:33.624] Resolving any globals that are futures ...
[09:31:33.624] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.628] plan(): nbrOfWorkers() = 2
[09:31:33.628] Resolving any globals that are futures ... DONE
[09:31:33.629] Resolving futures part of globals (recursively) ...
[09:31:33.630] resolve() on list ...
[09:31:33.630]  recursive: 99
[09:31:33.631]  length: 1
[09:31:33.631]  elements: ‘ii’
[09:31:33.631]  length: 0 (resolved future 1)
[09:31:33.632] resolve() on list ... DONE
[09:31:33.632] - globals: [1] ‘ii’
[09:31:33.632] Resolving futures part of globals (recursively) ... DONE
[09:31:33.633] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.634] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.634] - globals: [1] ‘ii’
[09:31:33.634] 
[09:31:33.634] getGlobalsAndPackages() ... DONE
[09:31:33.635] run() for ‘Future’ ...
[09:31:33.635] - state: ‘created’
[09:31:33.635] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.640]   - Field: ‘label’
[09:31:33.640]   - Field: ‘local’
[09:31:33.640]   - Field: ‘owner’
[09:31:33.640]   - Field: ‘envir’
[09:31:33.640]   - Field: ‘workers’
[09:31:33.641]   - Field: ‘packages’
[09:31:33.641]   - Field: ‘gc’
[09:31:33.641]   - Field: ‘job’
[09:31:33.641]   - Field: ‘conditions’
[09:31:33.641]   - Field: ‘expr’
[09:31:33.641]   - Field: ‘uuid’
[09:31:33.641]   - Field: ‘seed’
[09:31:33.642]   - Field: ‘version’
[09:31:33.642]   - Field: ‘result’
[09:31:33.642]   - Field: ‘asynchronous’
[09:31:33.642]   - Field: ‘calls’
[09:31:33.642]   - Field: ‘globals’
[09:31:33.642]   - Field: ‘stdout’
[09:31:33.642]   - Field: ‘earlySignal’
[09:31:33.643]   - Field: ‘lazy’
[09:31:33.643]   - Field: ‘state’
[09:31:33.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.643] - Launch lazy future ...
[09:31:33.643] Packages needed by the future expression (n = 0): <none>
[09:31:33.643] Packages needed by future strategies (n = 0): <none>
[09:31:33.644] {
[09:31:33.644]     {
[09:31:33.644]         {
[09:31:33.644]             ...future.startTime <- base::Sys.time()
[09:31:33.644]             {
[09:31:33.644]                 {
[09:31:33.644]                   {
[09:31:33.644]                     {
[09:31:33.644]                       base::local({
[09:31:33.644]                         has_future <- base::requireNamespace("future", 
[09:31:33.644]                           quietly = TRUE)
[09:31:33.644]                         if (has_future) {
[09:31:33.644]                           ns <- base::getNamespace("future")
[09:31:33.644]                           version <- ns[[".package"]][["version"]]
[09:31:33.644]                           if (is.null(version)) 
[09:31:33.644]                             version <- utils::packageVersion("future")
[09:31:33.644]                         }
[09:31:33.644]                         else {
[09:31:33.644]                           version <- NULL
[09:31:33.644]                         }
[09:31:33.644]                         if (!has_future || version < "1.8.0") {
[09:31:33.644]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.644]                             "", base::R.version$version.string), 
[09:31:33.644]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.644]                               "release", "version")], collapse = " "), 
[09:31:33.644]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.644]                             info)
[09:31:33.644]                           info <- base::paste(info, collapse = "; ")
[09:31:33.644]                           if (!has_future) {
[09:31:33.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.644]                               info)
[09:31:33.644]                           }
[09:31:33.644]                           else {
[09:31:33.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.644]                               info, version)
[09:31:33.644]                           }
[09:31:33.644]                           base::stop(msg)
[09:31:33.644]                         }
[09:31:33.644]                       })
[09:31:33.644]                     }
[09:31:33.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.644]                     base::options(mc.cores = 1L)
[09:31:33.644]                   }
[09:31:33.644]                   ...future.strategy.old <- future::plan("list")
[09:31:33.644]                   options(future.plan = NULL)
[09:31:33.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.644]                 }
[09:31:33.644]                 ...future.workdir <- getwd()
[09:31:33.644]             }
[09:31:33.644]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.644]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.644]         }
[09:31:33.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.644]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.644]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.644]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.644]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.644]             base::names(...future.oldOptions))
[09:31:33.644]     }
[09:31:33.644]     if (FALSE) {
[09:31:33.644]     }
[09:31:33.644]     else {
[09:31:33.644]         if (TRUE) {
[09:31:33.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.644]                 open = "w")
[09:31:33.644]         }
[09:31:33.644]         else {
[09:31:33.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.644]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.644]         }
[09:31:33.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.644]             base::sink(type = "output", split = FALSE)
[09:31:33.644]             base::close(...future.stdout)
[09:31:33.644]         }, add = TRUE)
[09:31:33.644]     }
[09:31:33.644]     ...future.frame <- base::sys.nframe()
[09:31:33.644]     ...future.conditions <- base::list()
[09:31:33.644]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.644]     if (FALSE) {
[09:31:33.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.644]     }
[09:31:33.644]     ...future.result <- base::tryCatch({
[09:31:33.644]         base::withCallingHandlers({
[09:31:33.644]             ...future.value <- base::withVisible(base::local({
[09:31:33.644]                 withCallingHandlers({
[09:31:33.644]                   {
[09:31:33.644]                     b <- a * ii
[09:31:33.644]                     a <- 0
[09:31:33.644]                     b
[09:31:33.644]                   }
[09:31:33.644]                 }, immediateCondition = function(cond) {
[09:31:33.644]                   save_rds <- function (object, pathname, ...) 
[09:31:33.644]                   {
[09:31:33.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.644]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.644]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.644]                         fi_tmp[["mtime"]])
[09:31:33.644]                     }
[09:31:33.644]                     tryCatch({
[09:31:33.644]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.644]                     }, error = function(ex) {
[09:31:33.644]                       msg <- conditionMessage(ex)
[09:31:33.644]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.644]                         fi_tmp[["mtime"]], msg)
[09:31:33.644]                       ex$message <- msg
[09:31:33.644]                       stop(ex)
[09:31:33.644]                     })
[09:31:33.644]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.644]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.644]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.644]                       fi <- file.info(pathname)
[09:31:33.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.644]                         fi[["size"]], fi[["mtime"]])
[09:31:33.644]                       stop(msg)
[09:31:33.644]                     }
[09:31:33.644]                     invisible(pathname)
[09:31:33.644]                   }
[09:31:33.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.644]                     rootPath = tempdir()) 
[09:31:33.644]                   {
[09:31:33.644]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.644]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.644]                       tmpdir = path, fileext = ".rds")
[09:31:33.644]                     save_rds(obj, file)
[09:31:33.644]                   }
[09:31:33.644]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.644]                   {
[09:31:33.644]                     inherits <- base::inherits
[09:31:33.644]                     invokeRestart <- base::invokeRestart
[09:31:33.644]                     is.null <- base::is.null
[09:31:33.644]                     muffled <- FALSE
[09:31:33.644]                     if (inherits(cond, "message")) {
[09:31:33.644]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.644]                       if (muffled) 
[09:31:33.644]                         invokeRestart("muffleMessage")
[09:31:33.644]                     }
[09:31:33.644]                     else if (inherits(cond, "warning")) {
[09:31:33.644]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.644]                       if (muffled) 
[09:31:33.644]                         invokeRestart("muffleWarning")
[09:31:33.644]                     }
[09:31:33.644]                     else if (inherits(cond, "condition")) {
[09:31:33.644]                       if (!is.null(pattern)) {
[09:31:33.644]                         computeRestarts <- base::computeRestarts
[09:31:33.644]                         grepl <- base::grepl
[09:31:33.644]                         restarts <- computeRestarts(cond)
[09:31:33.644]                         for (restart in restarts) {
[09:31:33.644]                           name <- restart$name
[09:31:33.644]                           if (is.null(name)) 
[09:31:33.644]                             next
[09:31:33.644]                           if (!grepl(pattern, name)) 
[09:31:33.644]                             next
[09:31:33.644]                           invokeRestart(restart)
[09:31:33.644]                           muffled <- TRUE
[09:31:33.644]                           break
[09:31:33.644]                         }
[09:31:33.644]                       }
[09:31:33.644]                     }
[09:31:33.644]                     invisible(muffled)
[09:31:33.644]                   }
[09:31:33.644]                   muffleCondition(cond)
[09:31:33.644]                 })
[09:31:33.644]             }))
[09:31:33.644]             future::FutureResult(value = ...future.value$value, 
[09:31:33.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.644]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.644]                     ...future.globalenv.names))
[09:31:33.644]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.644]         }, condition = base::local({
[09:31:33.644]             c <- base::c
[09:31:33.644]             inherits <- base::inherits
[09:31:33.644]             invokeRestart <- base::invokeRestart
[09:31:33.644]             length <- base::length
[09:31:33.644]             list <- base::list
[09:31:33.644]             seq.int <- base::seq.int
[09:31:33.644]             signalCondition <- base::signalCondition
[09:31:33.644]             sys.calls <- base::sys.calls
[09:31:33.644]             `[[` <- base::`[[`
[09:31:33.644]             `+` <- base::`+`
[09:31:33.644]             `<<-` <- base::`<<-`
[09:31:33.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.644]                   3L)]
[09:31:33.644]             }
[09:31:33.644]             function(cond) {
[09:31:33.644]                 is_error <- inherits(cond, "error")
[09:31:33.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.644]                   NULL)
[09:31:33.644]                 if (is_error) {
[09:31:33.644]                   sessionInformation <- function() {
[09:31:33.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.644]                       search = base::search(), system = base::Sys.info())
[09:31:33.644]                   }
[09:31:33.644]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.644]                     cond$call), session = sessionInformation(), 
[09:31:33.644]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.644]                   signalCondition(cond)
[09:31:33.644]                 }
[09:31:33.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.644]                 "immediateCondition"))) {
[09:31:33.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.644]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.644]                   if (TRUE && !signal) {
[09:31:33.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.644]                     {
[09:31:33.644]                       inherits <- base::inherits
[09:31:33.644]                       invokeRestart <- base::invokeRestart
[09:31:33.644]                       is.null <- base::is.null
[09:31:33.644]                       muffled <- FALSE
[09:31:33.644]                       if (inherits(cond, "message")) {
[09:31:33.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.644]                         if (muffled) 
[09:31:33.644]                           invokeRestart("muffleMessage")
[09:31:33.644]                       }
[09:31:33.644]                       else if (inherits(cond, "warning")) {
[09:31:33.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.644]                         if (muffled) 
[09:31:33.644]                           invokeRestart("muffleWarning")
[09:31:33.644]                       }
[09:31:33.644]                       else if (inherits(cond, "condition")) {
[09:31:33.644]                         if (!is.null(pattern)) {
[09:31:33.644]                           computeRestarts <- base::computeRestarts
[09:31:33.644]                           grepl <- base::grepl
[09:31:33.644]                           restarts <- computeRestarts(cond)
[09:31:33.644]                           for (restart in restarts) {
[09:31:33.644]                             name <- restart$name
[09:31:33.644]                             if (is.null(name)) 
[09:31:33.644]                               next
[09:31:33.644]                             if (!grepl(pattern, name)) 
[09:31:33.644]                               next
[09:31:33.644]                             invokeRestart(restart)
[09:31:33.644]                             muffled <- TRUE
[09:31:33.644]                             break
[09:31:33.644]                           }
[09:31:33.644]                         }
[09:31:33.644]                       }
[09:31:33.644]                       invisible(muffled)
[09:31:33.644]                     }
[09:31:33.644]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.644]                   }
[09:31:33.644]                 }
[09:31:33.644]                 else {
[09:31:33.644]                   if (TRUE) {
[09:31:33.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.644]                     {
[09:31:33.644]                       inherits <- base::inherits
[09:31:33.644]                       invokeRestart <- base::invokeRestart
[09:31:33.644]                       is.null <- base::is.null
[09:31:33.644]                       muffled <- FALSE
[09:31:33.644]                       if (inherits(cond, "message")) {
[09:31:33.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.644]                         if (muffled) 
[09:31:33.644]                           invokeRestart("muffleMessage")
[09:31:33.644]                       }
[09:31:33.644]                       else if (inherits(cond, "warning")) {
[09:31:33.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.644]                         if (muffled) 
[09:31:33.644]                           invokeRestart("muffleWarning")
[09:31:33.644]                       }
[09:31:33.644]                       else if (inherits(cond, "condition")) {
[09:31:33.644]                         if (!is.null(pattern)) {
[09:31:33.644]                           computeRestarts <- base::computeRestarts
[09:31:33.644]                           grepl <- base::grepl
[09:31:33.644]                           restarts <- computeRestarts(cond)
[09:31:33.644]                           for (restart in restarts) {
[09:31:33.644]                             name <- restart$name
[09:31:33.644]                             if (is.null(name)) 
[09:31:33.644]                               next
[09:31:33.644]                             if (!grepl(pattern, name)) 
[09:31:33.644]                               next
[09:31:33.644]                             invokeRestart(restart)
[09:31:33.644]                             muffled <- TRUE
[09:31:33.644]                             break
[09:31:33.644]                           }
[09:31:33.644]                         }
[09:31:33.644]                       }
[09:31:33.644]                       invisible(muffled)
[09:31:33.644]                     }
[09:31:33.644]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.644]                   }
[09:31:33.644]                 }
[09:31:33.644]             }
[09:31:33.644]         }))
[09:31:33.644]     }, error = function(ex) {
[09:31:33.644]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.644]                 ...future.rng), started = ...future.startTime, 
[09:31:33.644]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.644]             version = "1.8"), class = "FutureResult")
[09:31:33.644]     }, finally = {
[09:31:33.644]         if (!identical(...future.workdir, getwd())) 
[09:31:33.644]             setwd(...future.workdir)
[09:31:33.644]         {
[09:31:33.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.644]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.644]             }
[09:31:33.644]             base::options(...future.oldOptions)
[09:31:33.644]             if (.Platform$OS.type == "windows") {
[09:31:33.644]                 old_names <- names(...future.oldEnvVars)
[09:31:33.644]                 envs <- base::Sys.getenv()
[09:31:33.644]                 names <- names(envs)
[09:31:33.644]                 common <- intersect(names, old_names)
[09:31:33.644]                 added <- setdiff(names, old_names)
[09:31:33.644]                 removed <- setdiff(old_names, names)
[09:31:33.644]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.644]                   envs[common]]
[09:31:33.644]                 NAMES <- toupper(changed)
[09:31:33.644]                 args <- list()
[09:31:33.644]                 for (kk in seq_along(NAMES)) {
[09:31:33.644]                   name <- changed[[kk]]
[09:31:33.644]                   NAME <- NAMES[[kk]]
[09:31:33.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.644]                     next
[09:31:33.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.644]                 }
[09:31:33.644]                 NAMES <- toupper(added)
[09:31:33.644]                 for (kk in seq_along(NAMES)) {
[09:31:33.644]                   name <- added[[kk]]
[09:31:33.644]                   NAME <- NAMES[[kk]]
[09:31:33.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.644]                     next
[09:31:33.644]                   args[[name]] <- ""
[09:31:33.644]                 }
[09:31:33.644]                 NAMES <- toupper(removed)
[09:31:33.644]                 for (kk in seq_along(NAMES)) {
[09:31:33.644]                   name <- removed[[kk]]
[09:31:33.644]                   NAME <- NAMES[[kk]]
[09:31:33.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.644]                     next
[09:31:33.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.644]                 }
[09:31:33.644]                 if (length(args) > 0) 
[09:31:33.644]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.644]             }
[09:31:33.644]             else {
[09:31:33.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.644]             }
[09:31:33.644]             {
[09:31:33.644]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.644]                   0L) {
[09:31:33.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.644]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.644]                   base::options(opts)
[09:31:33.644]                 }
[09:31:33.644]                 {
[09:31:33.644]                   {
[09:31:33.644]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.644]                     NULL
[09:31:33.644]                   }
[09:31:33.644]                   options(future.plan = NULL)
[09:31:33.644]                   if (is.na(NA_character_)) 
[09:31:33.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.644]                     .init = FALSE)
[09:31:33.644]                 }
[09:31:33.644]             }
[09:31:33.644]         }
[09:31:33.644]     })
[09:31:33.644]     if (TRUE) {
[09:31:33.644]         base::sink(type = "output", split = FALSE)
[09:31:33.644]         if (TRUE) {
[09:31:33.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.644]         }
[09:31:33.644]         else {
[09:31:33.644]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.644]         }
[09:31:33.644]         base::close(...future.stdout)
[09:31:33.644]         ...future.stdout <- NULL
[09:31:33.644]     }
[09:31:33.644]     ...future.result$conditions <- ...future.conditions
[09:31:33.644]     ...future.result$finished <- base::Sys.time()
[09:31:33.644]     ...future.result
[09:31:33.644] }
[09:31:33.647] assign_globals() ...
[09:31:33.647] List of 1
[09:31:33.647]  $ ii: int 3
[09:31:33.647]  - attr(*, "where")=List of 1
[09:31:33.647]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.647]  - attr(*, "resolved")= logi TRUE
[09:31:33.647]  - attr(*, "total_size")= num 56
[09:31:33.647]  - attr(*, "already-done")= logi TRUE
[09:31:33.650] - copied ‘ii’ to environment
[09:31:33.650] assign_globals() ... done
[09:31:33.651] requestCore(): workers = 2
[09:31:33.651] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:33.662] result() for MulticoreFuture ...
[09:31:33.663] result() for MulticoreFuture ...
[09:31:33.663] result() for MulticoreFuture ... done
[09:31:33.663] result() for MulticoreFuture ... done
[09:31:33.663] result() for MulticoreFuture ...
[09:31:33.663] result() for MulticoreFuture ... done
[09:31:33.666] MulticoreFuture started
[09:31:33.666] - Launch lazy future ... done
[09:31:33.666] run() for ‘MulticoreFuture’ ... done
[09:31:33.667] plan(): Setting new future strategy stack:
[09:31:33.667] result() for MulticoreFuture ...
[09:31:33.668] result() for MulticoreFuture ... done
[09:31:33.668] result() for MulticoreFuture ...
[09:31:33.668] result() for MulticoreFuture ... done
[09:31:33.667] List of future strategies:
[09:31:33.667] 1. sequential:
[09:31:33.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.667]    - tweaked: FALSE
[09:31:33.667]    - call: NULL
[09:31:33.669] result() for MulticoreFuture ...
[09:31:33.669] plan(): nbrOfWorkers() = 1
[09:31:33.670] result() for MulticoreFuture ...
[09:31:33.670] result() for MulticoreFuture ... done
[09:31:33.671] result() for MulticoreFuture ... done
[09:31:33.671] result() for MulticoreFuture ...
[09:31:33.671] result() for MulticoreFuture ... done
[09:31:33.672] plan(): Setting new future strategy stack:
[09:31:33.672] result() for MulticoreFuture ...
[09:31:33.672] List of future strategies:
[09:31:33.672] 1. multicore:
[09:31:33.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.672]    - tweaked: FALSE
[09:31:33.672]    - call: plan(strategy)
[09:31:33.677] plan(): nbrOfWorkers() = 2
[09:31:33.678] result() for MulticoreFuture ...
[09:31:33.678] result() for MulticoreFuture ... done
[09:31:33.678] result() for MulticoreFuture ... done
[09:31:33.678] result() for MulticoreFuture ...
[09:31:33.678] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.679] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.679] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.681] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.682] Searching for globals ... DONE
[09:31:33.682] Resolving globals: TRUE
[09:31:33.682] Resolving any globals that are futures ...
[09:31:33.682] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.682] Resolving any globals that are futures ... DONE
[09:31:33.682] Resolving futures part of globals (recursively) ...
[09:31:33.683] resolve() on list ...
[09:31:33.683]  recursive: 99
[09:31:33.683]  length: 1
[09:31:33.683]  elements: ‘ii’
[09:31:33.683]  length: 0 (resolved future 1)
[09:31:33.683] resolve() on list ... DONE
[09:31:33.683] - globals: [1] ‘ii’
[09:31:33.684] Resolving futures part of globals (recursively) ... DONE
[09:31:33.684] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.684] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.684] - globals: [1] ‘ii’
[09:31:33.685] 
[09:31:33.685] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.685] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.686] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.687] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.687] Searching for globals ... DONE
[09:31:33.687] Resolving globals: TRUE
[09:31:33.687] Resolving any globals that are futures ...
[09:31:33.688] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.688] Resolving any globals that are futures ... DONE
[09:31:33.690] Resolving futures part of globals (recursively) ...
[09:31:33.691] resolve() on list ...
[09:31:33.691]  recursive: 99
[09:31:33.691]  length: 1
[09:31:33.691]  elements: ‘ii’
[09:31:33.691]  length: 0 (resolved future 1)
[09:31:33.692] resolve() on list ... DONE
[09:31:33.692] - globals: [1] ‘ii’
[09:31:33.692] Resolving futures part of globals (recursively) ... DONE
[09:31:33.692] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.693] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.693] - globals: [1] ‘ii’
[09:31:33.693] 
[09:31:33.693] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.694] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.694] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.696] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.696] Searching for globals ... DONE
[09:31:33.696] Resolving globals: TRUE
[09:31:33.696] Resolving any globals that are futures ...
[09:31:33.696] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:33.696] Resolving any globals that are futures ... DONE
[09:31:33.697] Resolving futures part of globals (recursively) ...
[09:31:33.697] resolve() on list ...
[09:31:33.697]  recursive: 99
[09:31:33.697]  length: 1
[09:31:33.697]  elements: ‘ii’
[09:31:33.697]  length: 0 (resolved future 1)
[09:31:33.697] resolve() on list ... DONE
[09:31:33.698] - globals: [1] ‘ii’
[09:31:33.698] Resolving futures part of globals (recursively) ... DONE
[09:31:33.698] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:33.698] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:33.698] - globals: [1] ‘ii’
[09:31:33.698] 
[09:31:33.699] getGlobalsAndPackages() ... DONE
[09:31:33.699] run() for ‘Future’ ...
[09:31:33.699] - state: ‘created’
[09:31:33.699] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.703]   - Field: ‘label’
[09:31:33.703]   - Field: ‘local’
[09:31:33.703]   - Field: ‘owner’
[09:31:33.704]   - Field: ‘envir’
[09:31:33.704]   - Field: ‘workers’
[09:31:33.704]   - Field: ‘packages’
[09:31:33.704]   - Field: ‘gc’
[09:31:33.704]   - Field: ‘job’
[09:31:33.704]   - Field: ‘conditions’
[09:31:33.704]   - Field: ‘expr’
[09:31:33.704]   - Field: ‘uuid’
[09:31:33.704]   - Field: ‘seed’
[09:31:33.705]   - Field: ‘version’
[09:31:33.705]   - Field: ‘result’
[09:31:33.705]   - Field: ‘asynchronous’
[09:31:33.705]   - Field: ‘calls’
[09:31:33.705]   - Field: ‘globals’
[09:31:33.705]   - Field: ‘stdout’
[09:31:33.705]   - Field: ‘earlySignal’
[09:31:33.705]   - Field: ‘lazy’
[09:31:33.705]   - Field: ‘state’
[09:31:33.705] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.706] - Launch lazy future ...
[09:31:33.706] Packages needed by the future expression (n = 0): <none>
[09:31:33.706] Packages needed by future strategies (n = 0): <none>
[09:31:33.706] {
[09:31:33.706]     {
[09:31:33.706]         {
[09:31:33.706]             ...future.startTime <- base::Sys.time()
[09:31:33.706]             {
[09:31:33.706]                 {
[09:31:33.706]                   {
[09:31:33.706]                     {
[09:31:33.706]                       base::local({
[09:31:33.706]                         has_future <- base::requireNamespace("future", 
[09:31:33.706]                           quietly = TRUE)
[09:31:33.706]                         if (has_future) {
[09:31:33.706]                           ns <- base::getNamespace("future")
[09:31:33.706]                           version <- ns[[".package"]][["version"]]
[09:31:33.706]                           if (is.null(version)) 
[09:31:33.706]                             version <- utils::packageVersion("future")
[09:31:33.706]                         }
[09:31:33.706]                         else {
[09:31:33.706]                           version <- NULL
[09:31:33.706]                         }
[09:31:33.706]                         if (!has_future || version < "1.8.0") {
[09:31:33.706]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.706]                             "", base::R.version$version.string), 
[09:31:33.706]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.706]                               "release", "version")], collapse = " "), 
[09:31:33.706]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.706]                             info)
[09:31:33.706]                           info <- base::paste(info, collapse = "; ")
[09:31:33.706]                           if (!has_future) {
[09:31:33.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.706]                               info)
[09:31:33.706]                           }
[09:31:33.706]                           else {
[09:31:33.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.706]                               info, version)
[09:31:33.706]                           }
[09:31:33.706]                           base::stop(msg)
[09:31:33.706]                         }
[09:31:33.706]                       })
[09:31:33.706]                     }
[09:31:33.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.706]                     base::options(mc.cores = 1L)
[09:31:33.706]                   }
[09:31:33.706]                   ...future.strategy.old <- future::plan("list")
[09:31:33.706]                   options(future.plan = NULL)
[09:31:33.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.706]                 }
[09:31:33.706]                 ...future.workdir <- getwd()
[09:31:33.706]             }
[09:31:33.706]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.706]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.706]         }
[09:31:33.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.706]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.706]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.706]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.706]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.706]             base::names(...future.oldOptions))
[09:31:33.706]     }
[09:31:33.706]     if (FALSE) {
[09:31:33.706]     }
[09:31:33.706]     else {
[09:31:33.706]         if (TRUE) {
[09:31:33.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.706]                 open = "w")
[09:31:33.706]         }
[09:31:33.706]         else {
[09:31:33.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.706]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.706]         }
[09:31:33.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.706]             base::sink(type = "output", split = FALSE)
[09:31:33.706]             base::close(...future.stdout)
[09:31:33.706]         }, add = TRUE)
[09:31:33.706]     }
[09:31:33.706]     ...future.frame <- base::sys.nframe()
[09:31:33.706]     ...future.conditions <- base::list()
[09:31:33.706]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.706]     if (FALSE) {
[09:31:33.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.706]     }
[09:31:33.706]     ...future.result <- base::tryCatch({
[09:31:33.706]         base::withCallingHandlers({
[09:31:33.706]             ...future.value <- base::withVisible(base::local({
[09:31:33.706]                 withCallingHandlers({
[09:31:33.706]                   {
[09:31:33.706]                     b <- a * ii
[09:31:33.706]                     a <- 0
[09:31:33.706]                     b
[09:31:33.706]                   }
[09:31:33.706]                 }, immediateCondition = function(cond) {
[09:31:33.706]                   save_rds <- function (object, pathname, ...) 
[09:31:33.706]                   {
[09:31:33.706]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.706]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.706]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.706]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.706]                         fi_tmp[["mtime"]])
[09:31:33.706]                     }
[09:31:33.706]                     tryCatch({
[09:31:33.706]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.706]                     }, error = function(ex) {
[09:31:33.706]                       msg <- conditionMessage(ex)
[09:31:33.706]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.706]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.706]                         fi_tmp[["mtime"]], msg)
[09:31:33.706]                       ex$message <- msg
[09:31:33.706]                       stop(ex)
[09:31:33.706]                     })
[09:31:33.706]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.706]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.706]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.706]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.706]                       fi <- file.info(pathname)
[09:31:33.706]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.706]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.706]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.706]                         fi[["size"]], fi[["mtime"]])
[09:31:33.706]                       stop(msg)
[09:31:33.706]                     }
[09:31:33.706]                     invisible(pathname)
[09:31:33.706]                   }
[09:31:33.706]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.706]                     rootPath = tempdir()) 
[09:31:33.706]                   {
[09:31:33.706]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.706]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.706]                       tmpdir = path, fileext = ".rds")
[09:31:33.706]                     save_rds(obj, file)
[09:31:33.706]                   }
[09:31:33.706]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.706]                   {
[09:31:33.706]                     inherits <- base::inherits
[09:31:33.706]                     invokeRestart <- base::invokeRestart
[09:31:33.706]                     is.null <- base::is.null
[09:31:33.706]                     muffled <- FALSE
[09:31:33.706]                     if (inherits(cond, "message")) {
[09:31:33.706]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.706]                       if (muffled) 
[09:31:33.706]                         invokeRestart("muffleMessage")
[09:31:33.706]                     }
[09:31:33.706]                     else if (inherits(cond, "warning")) {
[09:31:33.706]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.706]                       if (muffled) 
[09:31:33.706]                         invokeRestart("muffleWarning")
[09:31:33.706]                     }
[09:31:33.706]                     else if (inherits(cond, "condition")) {
[09:31:33.706]                       if (!is.null(pattern)) {
[09:31:33.706]                         computeRestarts <- base::computeRestarts
[09:31:33.706]                         grepl <- base::grepl
[09:31:33.706]                         restarts <- computeRestarts(cond)
[09:31:33.706]                         for (restart in restarts) {
[09:31:33.706]                           name <- restart$name
[09:31:33.706]                           if (is.null(name)) 
[09:31:33.706]                             next
[09:31:33.706]                           if (!grepl(pattern, name)) 
[09:31:33.706]                             next
[09:31:33.706]                           invokeRestart(restart)
[09:31:33.706]                           muffled <- TRUE
[09:31:33.706]                           break
[09:31:33.706]                         }
[09:31:33.706]                       }
[09:31:33.706]                     }
[09:31:33.706]                     invisible(muffled)
[09:31:33.706]                   }
[09:31:33.706]                   muffleCondition(cond)
[09:31:33.706]                 })
[09:31:33.706]             }))
[09:31:33.706]             future::FutureResult(value = ...future.value$value, 
[09:31:33.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.706]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.706]                     ...future.globalenv.names))
[09:31:33.706]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.706]         }, condition = base::local({
[09:31:33.706]             c <- base::c
[09:31:33.706]             inherits <- base::inherits
[09:31:33.706]             invokeRestart <- base::invokeRestart
[09:31:33.706]             length <- base::length
[09:31:33.706]             list <- base::list
[09:31:33.706]             seq.int <- base::seq.int
[09:31:33.706]             signalCondition <- base::signalCondition
[09:31:33.706]             sys.calls <- base::sys.calls
[09:31:33.706]             `[[` <- base::`[[`
[09:31:33.706]             `+` <- base::`+`
[09:31:33.706]             `<<-` <- base::`<<-`
[09:31:33.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.706]                   3L)]
[09:31:33.706]             }
[09:31:33.706]             function(cond) {
[09:31:33.706]                 is_error <- inherits(cond, "error")
[09:31:33.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.706]                   NULL)
[09:31:33.706]                 if (is_error) {
[09:31:33.706]                   sessionInformation <- function() {
[09:31:33.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.706]                       search = base::search(), system = base::Sys.info())
[09:31:33.706]                   }
[09:31:33.706]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.706]                     cond$call), session = sessionInformation(), 
[09:31:33.706]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.706]                   signalCondition(cond)
[09:31:33.706]                 }
[09:31:33.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.706]                 "immediateCondition"))) {
[09:31:33.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.706]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.706]                   if (TRUE && !signal) {
[09:31:33.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.706]                     {
[09:31:33.706]                       inherits <- base::inherits
[09:31:33.706]                       invokeRestart <- base::invokeRestart
[09:31:33.706]                       is.null <- base::is.null
[09:31:33.706]                       muffled <- FALSE
[09:31:33.706]                       if (inherits(cond, "message")) {
[09:31:33.706]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.706]                         if (muffled) 
[09:31:33.706]                           invokeRestart("muffleMessage")
[09:31:33.706]                       }
[09:31:33.706]                       else if (inherits(cond, "warning")) {
[09:31:33.706]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.706]                         if (muffled) 
[09:31:33.706]                           invokeRestart("muffleWarning")
[09:31:33.706]                       }
[09:31:33.706]                       else if (inherits(cond, "condition")) {
[09:31:33.706]                         if (!is.null(pattern)) {
[09:31:33.706]                           computeRestarts <- base::computeRestarts
[09:31:33.706]                           grepl <- base::grepl
[09:31:33.706]                           restarts <- computeRestarts(cond)
[09:31:33.706]                           for (restart in restarts) {
[09:31:33.706]                             name <- restart$name
[09:31:33.706]                             if (is.null(name)) 
[09:31:33.706]                               next
[09:31:33.706]                             if (!grepl(pattern, name)) 
[09:31:33.706]                               next
[09:31:33.706]                             invokeRestart(restart)
[09:31:33.706]                             muffled <- TRUE
[09:31:33.706]                             break
[09:31:33.706]                           }
[09:31:33.706]                         }
[09:31:33.706]                       }
[09:31:33.706]                       invisible(muffled)
[09:31:33.706]                     }
[09:31:33.706]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.706]                   }
[09:31:33.706]                 }
[09:31:33.706]                 else {
[09:31:33.706]                   if (TRUE) {
[09:31:33.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.706]                     {
[09:31:33.706]                       inherits <- base::inherits
[09:31:33.706]                       invokeRestart <- base::invokeRestart
[09:31:33.706]                       is.null <- base::is.null
[09:31:33.706]                       muffled <- FALSE
[09:31:33.706]                       if (inherits(cond, "message")) {
[09:31:33.706]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.706]                         if (muffled) 
[09:31:33.706]                           invokeRestart("muffleMessage")
[09:31:33.706]                       }
[09:31:33.706]                       else if (inherits(cond, "warning")) {
[09:31:33.706]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.706]                         if (muffled) 
[09:31:33.706]                           invokeRestart("muffleWarning")
[09:31:33.706]                       }
[09:31:33.706]                       else if (inherits(cond, "condition")) {
[09:31:33.706]                         if (!is.null(pattern)) {
[09:31:33.706]                           computeRestarts <- base::computeRestarts
[09:31:33.706]                           grepl <- base::grepl
[09:31:33.706]                           restarts <- computeRestarts(cond)
[09:31:33.706]                           for (restart in restarts) {
[09:31:33.706]                             name <- restart$name
[09:31:33.706]                             if (is.null(name)) 
[09:31:33.706]                               next
[09:31:33.706]                             if (!grepl(pattern, name)) 
[09:31:33.706]                               next
[09:31:33.706]                             invokeRestart(restart)
[09:31:33.706]                             muffled <- TRUE
[09:31:33.706]                             break
[09:31:33.706]                           }
[09:31:33.706]                         }
[09:31:33.706]                       }
[09:31:33.706]                       invisible(muffled)
[09:31:33.706]                     }
[09:31:33.706]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.706]                   }
[09:31:33.706]                 }
[09:31:33.706]             }
[09:31:33.706]         }))
[09:31:33.706]     }, error = function(ex) {
[09:31:33.706]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.706]                 ...future.rng), started = ...future.startTime, 
[09:31:33.706]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.706]             version = "1.8"), class = "FutureResult")
[09:31:33.706]     }, finally = {
[09:31:33.706]         if (!identical(...future.workdir, getwd())) 
[09:31:33.706]             setwd(...future.workdir)
[09:31:33.706]         {
[09:31:33.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.706]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.706]             }
[09:31:33.706]             base::options(...future.oldOptions)
[09:31:33.706]             if (.Platform$OS.type == "windows") {
[09:31:33.706]                 old_names <- names(...future.oldEnvVars)
[09:31:33.706]                 envs <- base::Sys.getenv()
[09:31:33.706]                 names <- names(envs)
[09:31:33.706]                 common <- intersect(names, old_names)
[09:31:33.706]                 added <- setdiff(names, old_names)
[09:31:33.706]                 removed <- setdiff(old_names, names)
[09:31:33.706]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.706]                   envs[common]]
[09:31:33.706]                 NAMES <- toupper(changed)
[09:31:33.706]                 args <- list()
[09:31:33.706]                 for (kk in seq_along(NAMES)) {
[09:31:33.706]                   name <- changed[[kk]]
[09:31:33.706]                   NAME <- NAMES[[kk]]
[09:31:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.706]                     next
[09:31:33.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.706]                 }
[09:31:33.706]                 NAMES <- toupper(added)
[09:31:33.706]                 for (kk in seq_along(NAMES)) {
[09:31:33.706]                   name <- added[[kk]]
[09:31:33.706]                   NAME <- NAMES[[kk]]
[09:31:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.706]                     next
[09:31:33.706]                   args[[name]] <- ""
[09:31:33.706]                 }
[09:31:33.706]                 NAMES <- toupper(removed)
[09:31:33.706]                 for (kk in seq_along(NAMES)) {
[09:31:33.706]                   name <- removed[[kk]]
[09:31:33.706]                   NAME <- NAMES[[kk]]
[09:31:33.706]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.706]                     next
[09:31:33.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.706]                 }
[09:31:33.706]                 if (length(args) > 0) 
[09:31:33.706]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.706]             }
[09:31:33.706]             else {
[09:31:33.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.706]             }
[09:31:33.706]             {
[09:31:33.706]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.706]                   0L) {
[09:31:33.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.706]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.706]                   base::options(opts)
[09:31:33.706]                 }
[09:31:33.706]                 {
[09:31:33.706]                   {
[09:31:33.706]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.706]                     NULL
[09:31:33.706]                   }
[09:31:33.706]                   options(future.plan = NULL)
[09:31:33.706]                   if (is.na(NA_character_)) 
[09:31:33.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.706]                     .init = FALSE)
[09:31:33.706]                 }
[09:31:33.706]             }
[09:31:33.706]         }
[09:31:33.706]     })
[09:31:33.706]     if (TRUE) {
[09:31:33.706]         base::sink(type = "output", split = FALSE)
[09:31:33.706]         if (TRUE) {
[09:31:33.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.706]         }
[09:31:33.706]         else {
[09:31:33.706]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.706]         }
[09:31:33.706]         base::close(...future.stdout)
[09:31:33.706]         ...future.stdout <- NULL
[09:31:33.706]     }
[09:31:33.706]     ...future.result$conditions <- ...future.conditions
[09:31:33.706]     ...future.result$finished <- base::Sys.time()
[09:31:33.706]     ...future.result
[09:31:33.706] }
[09:31:33.709] assign_globals() ...
[09:31:33.709] List of 1
[09:31:33.709]  $ ii: int 1
[09:31:33.709]  - attr(*, "where")=List of 1
[09:31:33.709]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:33.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.709]  - attr(*, "resolved")= logi TRUE
[09:31:33.709]  - attr(*, "total_size")= num 56
[09:31:33.709]  - attr(*, "already-done")= logi TRUE
[09:31:33.711] - copied ‘ii’ to environment
[09:31:33.711] assign_globals() ... done
[09:31:33.711] requestCore(): workers = 2
[09:31:33.713] MulticoreFuture started
[09:31:33.713] - Launch lazy future ... done
[09:31:33.714] run() for ‘MulticoreFuture’ ... done
[09:31:33.714] result() for MulticoreFuture ...
[09:31:33.714] plan(): Setting new future strategy stack:
[09:31:33.714] List of future strategies:
[09:31:33.714] 1. sequential:
[09:31:33.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.714]    - tweaked: FALSE
[09:31:33.714]    - call: NULL
[09:31:33.715] plan(): nbrOfWorkers() = 1
[09:31:33.717] plan(): Setting new future strategy stack:
[09:31:33.718] List of future strategies:
[09:31:33.718] 1. multicore:
[09:31:33.718]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.718]    - tweaked: FALSE
[09:31:33.718]    - call: plan(strategy)
[09:31:33.723] plan(): nbrOfWorkers() = 2
[09:31:33.728] result() for MulticoreFuture ...
[09:31:33.729] result() for MulticoreFuture ... done
[09:31:33.729] signalConditions() ...
[09:31:33.729]  - include = ‘immediateCondition’
[09:31:33.729]  - exclude = 
[09:31:33.729]  - resignal = FALSE
[09:31:33.729]  - Number of conditions: 1
[09:31:33.729] signalConditions() ... done
[09:31:33.729] result() for MulticoreFuture ... done
[09:31:33.729] result() for MulticoreFuture ...
[09:31:33.730] result() for MulticoreFuture ... done
[09:31:33.730] signalConditions() ...
[09:31:33.730]  - include = ‘immediateCondition’
[09:31:33.730]  - exclude = 
[09:31:33.730]  - resignal = FALSE
[09:31:33.730]  - Number of conditions: 1
[09:31:33.730] signalConditions() ... done
[09:31:33.730] Future state: ‘finished’
[09:31:33.731] result() for MulticoreFuture ...
[09:31:33.731] result() for MulticoreFuture ... done
[09:31:33.731] signalConditions() ...
[09:31:33.731]  - include = ‘condition’
[09:31:33.731]  - exclude = ‘immediateCondition’
[09:31:33.731]  - resignal = TRUE
[09:31:33.731]  - Number of conditions: 1
[09:31:33.731]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:33.732] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:33"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.762] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.763] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.763] 
[09:31:33.763] Searching for globals ... DONE
[09:31:33.763] - globals: [0] <none>
[09:31:33.763] getGlobalsAndPackages() ... DONE
[09:31:33.764] run() for ‘Future’ ...
[09:31:33.764] - state: ‘created’
[09:31:33.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.768] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.768]   - Field: ‘label’
[09:31:33.768]   - Field: ‘local’
[09:31:33.768]   - Field: ‘owner’
[09:31:33.768]   - Field: ‘envir’
[09:31:33.768]   - Field: ‘workers’
[09:31:33.768]   - Field: ‘packages’
[09:31:33.768]   - Field: ‘gc’
[09:31:33.768]   - Field: ‘job’
[09:31:33.769]   - Field: ‘conditions’
[09:31:33.769]   - Field: ‘expr’
[09:31:33.769]   - Field: ‘uuid’
[09:31:33.769]   - Field: ‘seed’
[09:31:33.769]   - Field: ‘version’
[09:31:33.769]   - Field: ‘result’
[09:31:33.769]   - Field: ‘asynchronous’
[09:31:33.769]   - Field: ‘calls’
[09:31:33.769]   - Field: ‘globals’
[09:31:33.769]   - Field: ‘stdout’
[09:31:33.769]   - Field: ‘earlySignal’
[09:31:33.770]   - Field: ‘lazy’
[09:31:33.770]   - Field: ‘state’
[09:31:33.770] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.770] - Launch lazy future ...
[09:31:33.770] Packages needed by the future expression (n = 0): <none>
[09:31:33.770] Packages needed by future strategies (n = 0): <none>
[09:31:33.771] {
[09:31:33.771]     {
[09:31:33.771]         {
[09:31:33.771]             ...future.startTime <- base::Sys.time()
[09:31:33.771]             {
[09:31:33.771]                 {
[09:31:33.771]                   {
[09:31:33.771]                     {
[09:31:33.771]                       base::local({
[09:31:33.771]                         has_future <- base::requireNamespace("future", 
[09:31:33.771]                           quietly = TRUE)
[09:31:33.771]                         if (has_future) {
[09:31:33.771]                           ns <- base::getNamespace("future")
[09:31:33.771]                           version <- ns[[".package"]][["version"]]
[09:31:33.771]                           if (is.null(version)) 
[09:31:33.771]                             version <- utils::packageVersion("future")
[09:31:33.771]                         }
[09:31:33.771]                         else {
[09:31:33.771]                           version <- NULL
[09:31:33.771]                         }
[09:31:33.771]                         if (!has_future || version < "1.8.0") {
[09:31:33.771]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.771]                             "", base::R.version$version.string), 
[09:31:33.771]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.771]                               "release", "version")], collapse = " "), 
[09:31:33.771]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.771]                             info)
[09:31:33.771]                           info <- base::paste(info, collapse = "; ")
[09:31:33.771]                           if (!has_future) {
[09:31:33.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.771]                               info)
[09:31:33.771]                           }
[09:31:33.771]                           else {
[09:31:33.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.771]                               info, version)
[09:31:33.771]                           }
[09:31:33.771]                           base::stop(msg)
[09:31:33.771]                         }
[09:31:33.771]                       })
[09:31:33.771]                     }
[09:31:33.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.771]                     base::options(mc.cores = 1L)
[09:31:33.771]                   }
[09:31:33.771]                   ...future.strategy.old <- future::plan("list")
[09:31:33.771]                   options(future.plan = NULL)
[09:31:33.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.771]                 }
[09:31:33.771]                 ...future.workdir <- getwd()
[09:31:33.771]             }
[09:31:33.771]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.771]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.771]         }
[09:31:33.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.771]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.771]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.771]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.771]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.771]             base::names(...future.oldOptions))
[09:31:33.771]     }
[09:31:33.771]     if (FALSE) {
[09:31:33.771]     }
[09:31:33.771]     else {
[09:31:33.771]         if (TRUE) {
[09:31:33.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.771]                 open = "w")
[09:31:33.771]         }
[09:31:33.771]         else {
[09:31:33.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.771]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.771]         }
[09:31:33.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.771]             base::sink(type = "output", split = FALSE)
[09:31:33.771]             base::close(...future.stdout)
[09:31:33.771]         }, add = TRUE)
[09:31:33.771]     }
[09:31:33.771]     ...future.frame <- base::sys.nframe()
[09:31:33.771]     ...future.conditions <- base::list()
[09:31:33.771]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.771]     if (FALSE) {
[09:31:33.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.771]     }
[09:31:33.771]     ...future.result <- base::tryCatch({
[09:31:33.771]         base::withCallingHandlers({
[09:31:33.771]             ...future.value <- base::withVisible(base::local({
[09:31:33.771]                 withCallingHandlers({
[09:31:33.771]                   1
[09:31:33.771]                 }, immediateCondition = function(cond) {
[09:31:33.771]                   save_rds <- function (object, pathname, ...) 
[09:31:33.771]                   {
[09:31:33.771]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.771]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.771]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.771]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.771]                         fi_tmp[["mtime"]])
[09:31:33.771]                     }
[09:31:33.771]                     tryCatch({
[09:31:33.771]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.771]                     }, error = function(ex) {
[09:31:33.771]                       msg <- conditionMessage(ex)
[09:31:33.771]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.771]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.771]                         fi_tmp[["mtime"]], msg)
[09:31:33.771]                       ex$message <- msg
[09:31:33.771]                       stop(ex)
[09:31:33.771]                     })
[09:31:33.771]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.771]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.771]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.771]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.771]                       fi <- file.info(pathname)
[09:31:33.771]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.771]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.771]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.771]                         fi[["size"]], fi[["mtime"]])
[09:31:33.771]                       stop(msg)
[09:31:33.771]                     }
[09:31:33.771]                     invisible(pathname)
[09:31:33.771]                   }
[09:31:33.771]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.771]                     rootPath = tempdir()) 
[09:31:33.771]                   {
[09:31:33.771]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.771]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.771]                       tmpdir = path, fileext = ".rds")
[09:31:33.771]                     save_rds(obj, file)
[09:31:33.771]                   }
[09:31:33.771]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.771]                   {
[09:31:33.771]                     inherits <- base::inherits
[09:31:33.771]                     invokeRestart <- base::invokeRestart
[09:31:33.771]                     is.null <- base::is.null
[09:31:33.771]                     muffled <- FALSE
[09:31:33.771]                     if (inherits(cond, "message")) {
[09:31:33.771]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.771]                       if (muffled) 
[09:31:33.771]                         invokeRestart("muffleMessage")
[09:31:33.771]                     }
[09:31:33.771]                     else if (inherits(cond, "warning")) {
[09:31:33.771]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.771]                       if (muffled) 
[09:31:33.771]                         invokeRestart("muffleWarning")
[09:31:33.771]                     }
[09:31:33.771]                     else if (inherits(cond, "condition")) {
[09:31:33.771]                       if (!is.null(pattern)) {
[09:31:33.771]                         computeRestarts <- base::computeRestarts
[09:31:33.771]                         grepl <- base::grepl
[09:31:33.771]                         restarts <- computeRestarts(cond)
[09:31:33.771]                         for (restart in restarts) {
[09:31:33.771]                           name <- restart$name
[09:31:33.771]                           if (is.null(name)) 
[09:31:33.771]                             next
[09:31:33.771]                           if (!grepl(pattern, name)) 
[09:31:33.771]                             next
[09:31:33.771]                           invokeRestart(restart)
[09:31:33.771]                           muffled <- TRUE
[09:31:33.771]                           break
[09:31:33.771]                         }
[09:31:33.771]                       }
[09:31:33.771]                     }
[09:31:33.771]                     invisible(muffled)
[09:31:33.771]                   }
[09:31:33.771]                   muffleCondition(cond)
[09:31:33.771]                 })
[09:31:33.771]             }))
[09:31:33.771]             future::FutureResult(value = ...future.value$value, 
[09:31:33.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.771]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.771]                     ...future.globalenv.names))
[09:31:33.771]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.771]         }, condition = base::local({
[09:31:33.771]             c <- base::c
[09:31:33.771]             inherits <- base::inherits
[09:31:33.771]             invokeRestart <- base::invokeRestart
[09:31:33.771]             length <- base::length
[09:31:33.771]             list <- base::list
[09:31:33.771]             seq.int <- base::seq.int
[09:31:33.771]             signalCondition <- base::signalCondition
[09:31:33.771]             sys.calls <- base::sys.calls
[09:31:33.771]             `[[` <- base::`[[`
[09:31:33.771]             `+` <- base::`+`
[09:31:33.771]             `<<-` <- base::`<<-`
[09:31:33.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.771]                   3L)]
[09:31:33.771]             }
[09:31:33.771]             function(cond) {
[09:31:33.771]                 is_error <- inherits(cond, "error")
[09:31:33.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.771]                   NULL)
[09:31:33.771]                 if (is_error) {
[09:31:33.771]                   sessionInformation <- function() {
[09:31:33.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.771]                       search = base::search(), system = base::Sys.info())
[09:31:33.771]                   }
[09:31:33.771]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.771]                     cond$call), session = sessionInformation(), 
[09:31:33.771]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.771]                   signalCondition(cond)
[09:31:33.771]                 }
[09:31:33.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.771]                 "immediateCondition"))) {
[09:31:33.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.771]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.771]                   if (TRUE && !signal) {
[09:31:33.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.771]                     {
[09:31:33.771]                       inherits <- base::inherits
[09:31:33.771]                       invokeRestart <- base::invokeRestart
[09:31:33.771]                       is.null <- base::is.null
[09:31:33.771]                       muffled <- FALSE
[09:31:33.771]                       if (inherits(cond, "message")) {
[09:31:33.771]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.771]                         if (muffled) 
[09:31:33.771]                           invokeRestart("muffleMessage")
[09:31:33.771]                       }
[09:31:33.771]                       else if (inherits(cond, "warning")) {
[09:31:33.771]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.771]                         if (muffled) 
[09:31:33.771]                           invokeRestart("muffleWarning")
[09:31:33.771]                       }
[09:31:33.771]                       else if (inherits(cond, "condition")) {
[09:31:33.771]                         if (!is.null(pattern)) {
[09:31:33.771]                           computeRestarts <- base::computeRestarts
[09:31:33.771]                           grepl <- base::grepl
[09:31:33.771]                           restarts <- computeRestarts(cond)
[09:31:33.771]                           for (restart in restarts) {
[09:31:33.771]                             name <- restart$name
[09:31:33.771]                             if (is.null(name)) 
[09:31:33.771]                               next
[09:31:33.771]                             if (!grepl(pattern, name)) 
[09:31:33.771]                               next
[09:31:33.771]                             invokeRestart(restart)
[09:31:33.771]                             muffled <- TRUE
[09:31:33.771]                             break
[09:31:33.771]                           }
[09:31:33.771]                         }
[09:31:33.771]                       }
[09:31:33.771]                       invisible(muffled)
[09:31:33.771]                     }
[09:31:33.771]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.771]                   }
[09:31:33.771]                 }
[09:31:33.771]                 else {
[09:31:33.771]                   if (TRUE) {
[09:31:33.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.771]                     {
[09:31:33.771]                       inherits <- base::inherits
[09:31:33.771]                       invokeRestart <- base::invokeRestart
[09:31:33.771]                       is.null <- base::is.null
[09:31:33.771]                       muffled <- FALSE
[09:31:33.771]                       if (inherits(cond, "message")) {
[09:31:33.771]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.771]                         if (muffled) 
[09:31:33.771]                           invokeRestart("muffleMessage")
[09:31:33.771]                       }
[09:31:33.771]                       else if (inherits(cond, "warning")) {
[09:31:33.771]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.771]                         if (muffled) 
[09:31:33.771]                           invokeRestart("muffleWarning")
[09:31:33.771]                       }
[09:31:33.771]                       else if (inherits(cond, "condition")) {
[09:31:33.771]                         if (!is.null(pattern)) {
[09:31:33.771]                           computeRestarts <- base::computeRestarts
[09:31:33.771]                           grepl <- base::grepl
[09:31:33.771]                           restarts <- computeRestarts(cond)
[09:31:33.771]                           for (restart in restarts) {
[09:31:33.771]                             name <- restart$name
[09:31:33.771]                             if (is.null(name)) 
[09:31:33.771]                               next
[09:31:33.771]                             if (!grepl(pattern, name)) 
[09:31:33.771]                               next
[09:31:33.771]                             invokeRestart(restart)
[09:31:33.771]                             muffled <- TRUE
[09:31:33.771]                             break
[09:31:33.771]                           }
[09:31:33.771]                         }
[09:31:33.771]                       }
[09:31:33.771]                       invisible(muffled)
[09:31:33.771]                     }
[09:31:33.771]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.771]                   }
[09:31:33.771]                 }
[09:31:33.771]             }
[09:31:33.771]         }))
[09:31:33.771]     }, error = function(ex) {
[09:31:33.771]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.771]                 ...future.rng), started = ...future.startTime, 
[09:31:33.771]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.771]             version = "1.8"), class = "FutureResult")
[09:31:33.771]     }, finally = {
[09:31:33.771]         if (!identical(...future.workdir, getwd())) 
[09:31:33.771]             setwd(...future.workdir)
[09:31:33.771]         {
[09:31:33.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.771]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.771]             }
[09:31:33.771]             base::options(...future.oldOptions)
[09:31:33.771]             if (.Platform$OS.type == "windows") {
[09:31:33.771]                 old_names <- names(...future.oldEnvVars)
[09:31:33.771]                 envs <- base::Sys.getenv()
[09:31:33.771]                 names <- names(envs)
[09:31:33.771]                 common <- intersect(names, old_names)
[09:31:33.771]                 added <- setdiff(names, old_names)
[09:31:33.771]                 removed <- setdiff(old_names, names)
[09:31:33.771]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.771]                   envs[common]]
[09:31:33.771]                 NAMES <- toupper(changed)
[09:31:33.771]                 args <- list()
[09:31:33.771]                 for (kk in seq_along(NAMES)) {
[09:31:33.771]                   name <- changed[[kk]]
[09:31:33.771]                   NAME <- NAMES[[kk]]
[09:31:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.771]                     next
[09:31:33.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.771]                 }
[09:31:33.771]                 NAMES <- toupper(added)
[09:31:33.771]                 for (kk in seq_along(NAMES)) {
[09:31:33.771]                   name <- added[[kk]]
[09:31:33.771]                   NAME <- NAMES[[kk]]
[09:31:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.771]                     next
[09:31:33.771]                   args[[name]] <- ""
[09:31:33.771]                 }
[09:31:33.771]                 NAMES <- toupper(removed)
[09:31:33.771]                 for (kk in seq_along(NAMES)) {
[09:31:33.771]                   name <- removed[[kk]]
[09:31:33.771]                   NAME <- NAMES[[kk]]
[09:31:33.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.771]                     next
[09:31:33.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.771]                 }
[09:31:33.771]                 if (length(args) > 0) 
[09:31:33.771]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.771]             }
[09:31:33.771]             else {
[09:31:33.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.771]             }
[09:31:33.771]             {
[09:31:33.771]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.771]                   0L) {
[09:31:33.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.771]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.771]                   base::options(opts)
[09:31:33.771]                 }
[09:31:33.771]                 {
[09:31:33.771]                   {
[09:31:33.771]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.771]                     NULL
[09:31:33.771]                   }
[09:31:33.771]                   options(future.plan = NULL)
[09:31:33.771]                   if (is.na(NA_character_)) 
[09:31:33.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.771]                     .init = FALSE)
[09:31:33.771]                 }
[09:31:33.771]             }
[09:31:33.771]         }
[09:31:33.771]     })
[09:31:33.771]     if (TRUE) {
[09:31:33.771]         base::sink(type = "output", split = FALSE)
[09:31:33.771]         if (TRUE) {
[09:31:33.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.771]         }
[09:31:33.771]         else {
[09:31:33.771]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.771]         }
[09:31:33.771]         base::close(...future.stdout)
[09:31:33.771]         ...future.stdout <- NULL
[09:31:33.771]     }
[09:31:33.771]     ...future.result$conditions <- ...future.conditions
[09:31:33.771]     ...future.result$finished <- base::Sys.time()
[09:31:33.771]     ...future.result
[09:31:33.771] }
[09:31:33.773] requestCore(): workers = 2
[09:31:33.775] MulticoreFuture started
[09:31:33.775] - Launch lazy future ... done
[09:31:33.775] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.776] plan(): Setting new future strategy stack:
[09:31:33.776] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.776] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.776] List of future strategies:
[09:31:33.776] 1. sequential:
[09:31:33.776]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.776]    - tweaked: FALSE
[09:31:33.776]    - call: NULL
[09:31:33.777] plan(): nbrOfWorkers() = 1
[09:31:33.778] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.778] Searching for globals ... DONE
[09:31:33.778] Resolving globals: TRUE
[09:31:33.779] Resolving any globals that are futures ...
[09:31:33.779] plan(): Setting new future strategy stack:
[09:31:33.779] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.779] Resolving any globals that are futures ... DONE
[09:31:33.779] List of future strategies:
[09:31:33.779] 1. multicore:
[09:31:33.779]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.779]    - tweaked: FALSE
[09:31:33.779]    - call: plan(strategy)
[09:31:33.780] Resolving futures part of globals (recursively) ...
[09:31:33.780] resolve() on list ...
[09:31:33.780]  recursive: 99
[09:31:33.780]  length: 1
[09:31:33.781]  elements: ‘a’
[09:31:33.783] plan(): nbrOfWorkers() = 2
[09:31:33.784] Future #1
[09:31:33.784] result() for MulticoreFuture ...
[09:31:33.785] result() for MulticoreFuture ...
[09:31:33.785] result() for MulticoreFuture ... done
[09:31:33.786] result() for MulticoreFuture ... done
[09:31:33.786] result() for MulticoreFuture ...
[09:31:33.786] result() for MulticoreFuture ... done
[09:31:33.786] A MulticoreFuture was resolved
[09:31:33.786]  length: 0 (resolved future 1)
[09:31:33.786] resolve() on list ... DONE
[09:31:33.786] - globals: [1] ‘a’
[09:31:33.787] Resolving futures part of globals (recursively) ... DONE
[09:31:33.788] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[09:31:33.788] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[09:31:33.788] - globals: [1] ‘a’
[09:31:33.789] - packages: [1] ‘future’
[09:31:33.789] getGlobalsAndPackages() ... DONE
[09:31:33.789] run() for ‘Future’ ...
[09:31:33.789] - state: ‘created’
[09:31:33.789] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.794]   - Field: ‘label’
[09:31:33.794]   - Field: ‘local’
[09:31:33.794]   - Field: ‘owner’
[09:31:33.794]   - Field: ‘envir’
[09:31:33.794]   - Field: ‘workers’
[09:31:33.794]   - Field: ‘packages’
[09:31:33.794]   - Field: ‘gc’
[09:31:33.794]   - Field: ‘job’
[09:31:33.794]   - Field: ‘conditions’
[09:31:33.795]   - Field: ‘expr’
[09:31:33.795]   - Field: ‘uuid’
[09:31:33.795]   - Field: ‘seed’
[09:31:33.795]   - Field: ‘version’
[09:31:33.795]   - Field: ‘result’
[09:31:33.795]   - Field: ‘asynchronous’
[09:31:33.797]   - Field: ‘calls’
[09:31:33.797]   - Field: ‘globals’
[09:31:33.797]   - Field: ‘stdout’
[09:31:33.798]   - Field: ‘earlySignal’
[09:31:33.798]   - Field: ‘lazy’
[09:31:33.798]   - Field: ‘state’
[09:31:33.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.798] - Launch lazy future ...
[09:31:33.799] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.799] Packages needed by future strategies (n = 0): <none>
[09:31:33.800] {
[09:31:33.800]     {
[09:31:33.800]         {
[09:31:33.800]             ...future.startTime <- base::Sys.time()
[09:31:33.800]             {
[09:31:33.800]                 {
[09:31:33.800]                   {
[09:31:33.800]                     {
[09:31:33.800]                       {
[09:31:33.800]                         base::local({
[09:31:33.800]                           has_future <- base::requireNamespace("future", 
[09:31:33.800]                             quietly = TRUE)
[09:31:33.800]                           if (has_future) {
[09:31:33.800]                             ns <- base::getNamespace("future")
[09:31:33.800]                             version <- ns[[".package"]][["version"]]
[09:31:33.800]                             if (is.null(version)) 
[09:31:33.800]                               version <- utils::packageVersion("future")
[09:31:33.800]                           }
[09:31:33.800]                           else {
[09:31:33.800]                             version <- NULL
[09:31:33.800]                           }
[09:31:33.800]                           if (!has_future || version < "1.8.0") {
[09:31:33.800]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.800]                               "", base::R.version$version.string), 
[09:31:33.800]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:33.800]                                 base::R.version$platform, 8 * 
[09:31:33.800]                                   base::.Machine$sizeof.pointer), 
[09:31:33.800]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.800]                                 "release", "version")], collapse = " "), 
[09:31:33.800]                               hostname = base::Sys.info()[["nodename"]])
[09:31:33.800]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.800]                               info)
[09:31:33.800]                             info <- base::paste(info, collapse = "; ")
[09:31:33.800]                             if (!has_future) {
[09:31:33.800]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.800]                                 info)
[09:31:33.800]                             }
[09:31:33.800]                             else {
[09:31:33.800]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.800]                                 info, version)
[09:31:33.800]                             }
[09:31:33.800]                             base::stop(msg)
[09:31:33.800]                           }
[09:31:33.800]                         })
[09:31:33.800]                       }
[09:31:33.800]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.800]                       base::options(mc.cores = 1L)
[09:31:33.800]                     }
[09:31:33.800]                     base::local({
[09:31:33.800]                       for (pkg in "future") {
[09:31:33.800]                         base::loadNamespace(pkg)
[09:31:33.800]                         base::library(pkg, character.only = TRUE)
[09:31:33.800]                       }
[09:31:33.800]                     })
[09:31:33.800]                   }
[09:31:33.800]                   ...future.strategy.old <- future::plan("list")
[09:31:33.800]                   options(future.plan = NULL)
[09:31:33.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.800]                 }
[09:31:33.800]                 ...future.workdir <- getwd()
[09:31:33.800]             }
[09:31:33.800]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.800]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.800]         }
[09:31:33.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.800]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.800]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.800]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.800]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.800]             base::names(...future.oldOptions))
[09:31:33.800]     }
[09:31:33.800]     if (FALSE) {
[09:31:33.800]     }
[09:31:33.800]     else {
[09:31:33.800]         if (TRUE) {
[09:31:33.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.800]                 open = "w")
[09:31:33.800]         }
[09:31:33.800]         else {
[09:31:33.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.800]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.800]         }
[09:31:33.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.800]             base::sink(type = "output", split = FALSE)
[09:31:33.800]             base::close(...future.stdout)
[09:31:33.800]         }, add = TRUE)
[09:31:33.800]     }
[09:31:33.800]     ...future.frame <- base::sys.nframe()
[09:31:33.800]     ...future.conditions <- base::list()
[09:31:33.800]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.800]     if (FALSE) {
[09:31:33.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.800]     }
[09:31:33.800]     ...future.result <- base::tryCatch({
[09:31:33.800]         base::withCallingHandlers({
[09:31:33.800]             ...future.value <- base::withVisible(base::local({
[09:31:33.800]                 withCallingHandlers({
[09:31:33.800]                   value(a) + 1
[09:31:33.800]                 }, immediateCondition = function(cond) {
[09:31:33.800]                   save_rds <- function (object, pathname, ...) 
[09:31:33.800]                   {
[09:31:33.800]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.800]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.800]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.800]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.800]                         fi_tmp[["mtime"]])
[09:31:33.800]                     }
[09:31:33.800]                     tryCatch({
[09:31:33.800]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.800]                     }, error = function(ex) {
[09:31:33.800]                       msg <- conditionMessage(ex)
[09:31:33.800]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.800]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.800]                         fi_tmp[["mtime"]], msg)
[09:31:33.800]                       ex$message <- msg
[09:31:33.800]                       stop(ex)
[09:31:33.800]                     })
[09:31:33.800]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.800]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.800]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.800]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.800]                       fi <- file.info(pathname)
[09:31:33.800]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.800]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.800]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.800]                         fi[["size"]], fi[["mtime"]])
[09:31:33.800]                       stop(msg)
[09:31:33.800]                     }
[09:31:33.800]                     invisible(pathname)
[09:31:33.800]                   }
[09:31:33.800]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.800]                     rootPath = tempdir()) 
[09:31:33.800]                   {
[09:31:33.800]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.800]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.800]                       tmpdir = path, fileext = ".rds")
[09:31:33.800]                     save_rds(obj, file)
[09:31:33.800]                   }
[09:31:33.800]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.800]                   {
[09:31:33.800]                     inherits <- base::inherits
[09:31:33.800]                     invokeRestart <- base::invokeRestart
[09:31:33.800]                     is.null <- base::is.null
[09:31:33.800]                     muffled <- FALSE
[09:31:33.800]                     if (inherits(cond, "message")) {
[09:31:33.800]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.800]                       if (muffled) 
[09:31:33.800]                         invokeRestart("muffleMessage")
[09:31:33.800]                     }
[09:31:33.800]                     else if (inherits(cond, "warning")) {
[09:31:33.800]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.800]                       if (muffled) 
[09:31:33.800]                         invokeRestart("muffleWarning")
[09:31:33.800]                     }
[09:31:33.800]                     else if (inherits(cond, "condition")) {
[09:31:33.800]                       if (!is.null(pattern)) {
[09:31:33.800]                         computeRestarts <- base::computeRestarts
[09:31:33.800]                         grepl <- base::grepl
[09:31:33.800]                         restarts <- computeRestarts(cond)
[09:31:33.800]                         for (restart in restarts) {
[09:31:33.800]                           name <- restart$name
[09:31:33.800]                           if (is.null(name)) 
[09:31:33.800]                             next
[09:31:33.800]                           if (!grepl(pattern, name)) 
[09:31:33.800]                             next
[09:31:33.800]                           invokeRestart(restart)
[09:31:33.800]                           muffled <- TRUE
[09:31:33.800]                           break
[09:31:33.800]                         }
[09:31:33.800]                       }
[09:31:33.800]                     }
[09:31:33.800]                     invisible(muffled)
[09:31:33.800]                   }
[09:31:33.800]                   muffleCondition(cond)
[09:31:33.800]                 })
[09:31:33.800]             }))
[09:31:33.800]             future::FutureResult(value = ...future.value$value, 
[09:31:33.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.800]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.800]                     ...future.globalenv.names))
[09:31:33.800]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.800]         }, condition = base::local({
[09:31:33.800]             c <- base::c
[09:31:33.800]             inherits <- base::inherits
[09:31:33.800]             invokeRestart <- base::invokeRestart
[09:31:33.800]             length <- base::length
[09:31:33.800]             list <- base::list
[09:31:33.800]             seq.int <- base::seq.int
[09:31:33.800]             signalCondition <- base::signalCondition
[09:31:33.800]             sys.calls <- base::sys.calls
[09:31:33.800]             `[[` <- base::`[[`
[09:31:33.800]             `+` <- base::`+`
[09:31:33.800]             `<<-` <- base::`<<-`
[09:31:33.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.800]                   3L)]
[09:31:33.800]             }
[09:31:33.800]             function(cond) {
[09:31:33.800]                 is_error <- inherits(cond, "error")
[09:31:33.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.800]                   NULL)
[09:31:33.800]                 if (is_error) {
[09:31:33.800]                   sessionInformation <- function() {
[09:31:33.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.800]                       search = base::search(), system = base::Sys.info())
[09:31:33.800]                   }
[09:31:33.800]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.800]                     cond$call), session = sessionInformation(), 
[09:31:33.800]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.800]                   signalCondition(cond)
[09:31:33.800]                 }
[09:31:33.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.800]                 "immediateCondition"))) {
[09:31:33.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.800]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.800]                   if (TRUE && !signal) {
[09:31:33.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.800]                     {
[09:31:33.800]                       inherits <- base::inherits
[09:31:33.800]                       invokeRestart <- base::invokeRestart
[09:31:33.800]                       is.null <- base::is.null
[09:31:33.800]                       muffled <- FALSE
[09:31:33.800]                       if (inherits(cond, "message")) {
[09:31:33.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.800]                         if (muffled) 
[09:31:33.800]                           invokeRestart("muffleMessage")
[09:31:33.800]                       }
[09:31:33.800]                       else if (inherits(cond, "warning")) {
[09:31:33.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.800]                         if (muffled) 
[09:31:33.800]                           invokeRestart("muffleWarning")
[09:31:33.800]                       }
[09:31:33.800]                       else if (inherits(cond, "condition")) {
[09:31:33.800]                         if (!is.null(pattern)) {
[09:31:33.800]                           computeRestarts <- base::computeRestarts
[09:31:33.800]                           grepl <- base::grepl
[09:31:33.800]                           restarts <- computeRestarts(cond)
[09:31:33.800]                           for (restart in restarts) {
[09:31:33.800]                             name <- restart$name
[09:31:33.800]                             if (is.null(name)) 
[09:31:33.800]                               next
[09:31:33.800]                             if (!grepl(pattern, name)) 
[09:31:33.800]                               next
[09:31:33.800]                             invokeRestart(restart)
[09:31:33.800]                             muffled <- TRUE
[09:31:33.800]                             break
[09:31:33.800]                           }
[09:31:33.800]                         }
[09:31:33.800]                       }
[09:31:33.800]                       invisible(muffled)
[09:31:33.800]                     }
[09:31:33.800]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.800]                   }
[09:31:33.800]                 }
[09:31:33.800]                 else {
[09:31:33.800]                   if (TRUE) {
[09:31:33.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.800]                     {
[09:31:33.800]                       inherits <- base::inherits
[09:31:33.800]                       invokeRestart <- base::invokeRestart
[09:31:33.800]                       is.null <- base::is.null
[09:31:33.800]                       muffled <- FALSE
[09:31:33.800]                       if (inherits(cond, "message")) {
[09:31:33.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.800]                         if (muffled) 
[09:31:33.800]                           invokeRestart("muffleMessage")
[09:31:33.800]                       }
[09:31:33.800]                       else if (inherits(cond, "warning")) {
[09:31:33.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.800]                         if (muffled) 
[09:31:33.800]                           invokeRestart("muffleWarning")
[09:31:33.800]                       }
[09:31:33.800]                       else if (inherits(cond, "condition")) {
[09:31:33.800]                         if (!is.null(pattern)) {
[09:31:33.800]                           computeRestarts <- base::computeRestarts
[09:31:33.800]                           grepl <- base::grepl
[09:31:33.800]                           restarts <- computeRestarts(cond)
[09:31:33.800]                           for (restart in restarts) {
[09:31:33.800]                             name <- restart$name
[09:31:33.800]                             if (is.null(name)) 
[09:31:33.800]                               next
[09:31:33.800]                             if (!grepl(pattern, name)) 
[09:31:33.800]                               next
[09:31:33.800]                             invokeRestart(restart)
[09:31:33.800]                             muffled <- TRUE
[09:31:33.800]                             break
[09:31:33.800]                           }
[09:31:33.800]                         }
[09:31:33.800]                       }
[09:31:33.800]                       invisible(muffled)
[09:31:33.800]                     }
[09:31:33.800]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.800]                   }
[09:31:33.800]                 }
[09:31:33.800]             }
[09:31:33.800]         }))
[09:31:33.800]     }, error = function(ex) {
[09:31:33.800]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.800]                 ...future.rng), started = ...future.startTime, 
[09:31:33.800]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.800]             version = "1.8"), class = "FutureResult")
[09:31:33.800]     }, finally = {
[09:31:33.800]         if (!identical(...future.workdir, getwd())) 
[09:31:33.800]             setwd(...future.workdir)
[09:31:33.800]         {
[09:31:33.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.800]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.800]             }
[09:31:33.800]             base::options(...future.oldOptions)
[09:31:33.800]             if (.Platform$OS.type == "windows") {
[09:31:33.800]                 old_names <- names(...future.oldEnvVars)
[09:31:33.800]                 envs <- base::Sys.getenv()
[09:31:33.800]                 names <- names(envs)
[09:31:33.800]                 common <- intersect(names, old_names)
[09:31:33.800]                 added <- setdiff(names, old_names)
[09:31:33.800]                 removed <- setdiff(old_names, names)
[09:31:33.800]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.800]                   envs[common]]
[09:31:33.800]                 NAMES <- toupper(changed)
[09:31:33.800]                 args <- list()
[09:31:33.800]                 for (kk in seq_along(NAMES)) {
[09:31:33.800]                   name <- changed[[kk]]
[09:31:33.800]                   NAME <- NAMES[[kk]]
[09:31:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.800]                     next
[09:31:33.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.800]                 }
[09:31:33.800]                 NAMES <- toupper(added)
[09:31:33.800]                 for (kk in seq_along(NAMES)) {
[09:31:33.800]                   name <- added[[kk]]
[09:31:33.800]                   NAME <- NAMES[[kk]]
[09:31:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.800]                     next
[09:31:33.800]                   args[[name]] <- ""
[09:31:33.800]                 }
[09:31:33.800]                 NAMES <- toupper(removed)
[09:31:33.800]                 for (kk in seq_along(NAMES)) {
[09:31:33.800]                   name <- removed[[kk]]
[09:31:33.800]                   NAME <- NAMES[[kk]]
[09:31:33.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.800]                     next
[09:31:33.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.800]                 }
[09:31:33.800]                 if (length(args) > 0) 
[09:31:33.800]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.800]             }
[09:31:33.800]             else {
[09:31:33.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.800]             }
[09:31:33.800]             {
[09:31:33.800]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.800]                   0L) {
[09:31:33.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.800]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.800]                   base::options(opts)
[09:31:33.800]                 }
[09:31:33.800]                 {
[09:31:33.800]                   {
[09:31:33.800]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.800]                     NULL
[09:31:33.800]                   }
[09:31:33.800]                   options(future.plan = NULL)
[09:31:33.800]                   if (is.na(NA_character_)) 
[09:31:33.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.800]                     .init = FALSE)
[09:31:33.800]                 }
[09:31:33.800]             }
[09:31:33.800]         }
[09:31:33.800]     })
[09:31:33.800]     if (TRUE) {
[09:31:33.800]         base::sink(type = "output", split = FALSE)
[09:31:33.800]         if (TRUE) {
[09:31:33.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.800]         }
[09:31:33.800]         else {
[09:31:33.800]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.800]         }
[09:31:33.800]         base::close(...future.stdout)
[09:31:33.800]         ...future.stdout <- NULL
[09:31:33.800]     }
[09:31:33.800]     ...future.result$conditions <- ...future.conditions
[09:31:33.800]     ...future.result$finished <- base::Sys.time()
[09:31:33.800]     ...future.result
[09:31:33.800] }
[09:31:33.802] assign_globals() ...
[09:31:33.802] List of 1
[09:31:33.802]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e2186b6df8> 
[09:31:33.802]  - attr(*, "where")=List of 1
[09:31:33.802]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.802]  - attr(*, "resolved")= logi TRUE
[09:31:33.802]  - attr(*, "total_size")= num 10816
[09:31:33.802]  - attr(*, "already-done")= logi TRUE
[09:31:33.805] - copied ‘a’ to environment
[09:31:33.805] assign_globals() ... done
[09:31:33.805] requestCore(): workers = 2
[09:31:33.807] MulticoreFuture started
[09:31:33.808] - Launch lazy future ... done
[09:31:33.808] run() for ‘MulticoreFuture’ ... done
[09:31:33.808] result() for MulticoreFuture ...
[09:31:33.809] plan(): Setting new future strategy stack:
[09:31:33.809] List of future strategies:
[09:31:33.809] 1. sequential:
[09:31:33.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.809]    - tweaked: FALSE
[09:31:33.809]    - call: NULL
[09:31:33.810] plan(): nbrOfWorkers() = 1
[09:31:33.814] plan(): Setting new future strategy stack:
[09:31:33.814] List of future strategies:
[09:31:33.814] 1. multicore:
[09:31:33.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.814]    - tweaked: FALSE
[09:31:33.814]    - call: plan(strategy)
[09:31:33.819] plan(): nbrOfWorkers() = 2
[09:31:33.820] result() for MulticoreFuture ...
[09:31:33.821] result() for MulticoreFuture ... done
[09:31:33.821] signalConditions() ...
[09:31:33.821]  - include = ‘immediateCondition’
[09:31:33.821]  - exclude = 
[09:31:33.821]  - resignal = FALSE
[09:31:33.821]  - Number of conditions: 4
[09:31:33.822] signalConditions() ... done
[09:31:33.822] result() for MulticoreFuture ... done
[09:31:33.822] result() for MulticoreFuture ...
[09:31:33.822] result() for MulticoreFuture ... done
[09:31:33.822] signalConditions() ...
[09:31:33.822]  - include = ‘immediateCondition’
[09:31:33.822]  - exclude = 
[09:31:33.823]  - resignal = FALSE
[09:31:33.823]  - Number of conditions: 4
[09:31:33.823] signalConditions() ... done
[09:31:33.823] Future state: ‘finished’
[09:31:33.823] result() for MulticoreFuture ...
[09:31:33.823] result() for MulticoreFuture ... done
[09:31:33.823] signalConditions() ...
[09:31:33.823]  - include = ‘condition’
[09:31:33.824]  - exclude = ‘immediateCondition’
[09:31:33.824]  - resignal = TRUE
[09:31:33.824]  - Number of conditions: 4
[09:31:33.824]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ...
[09:31:33.824]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ... done
[09:31:33.824]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ...
[09:31:33.824]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.813] result() for MulticoreFuture ... done
[09:31:33.825] signalConditions() ... done
value(b) = 2
[09:31:33.825] result() for MulticoreFuture ...
[09:31:33.825] result() for MulticoreFuture ... done
[09:31:33.825] result() for MulticoreFuture ...
[09:31:33.825] result() for MulticoreFuture ... done
[09:31:33.825] signalConditions() ...
[09:31:33.825]  - include = ‘immediateCondition’
[09:31:33.826]  - exclude = 
[09:31:33.826]  - resignal = FALSE
[09:31:33.826]  - Number of conditions: 4
[09:31:33.826] signalConditions() ... done
[09:31:33.826] Future state: ‘finished’
[09:31:33.826] result() for MulticoreFuture ...
[09:31:33.826] result() for MulticoreFuture ... done
[09:31:33.826] signalConditions() ...
[09:31:33.826]  - include = ‘condition’
[09:31:33.827]  - exclude = ‘immediateCondition’
[09:31:33.827]  - resignal = TRUE
[09:31:33.827]  - Number of conditions: 4
[09:31:33.827]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ...
[09:31:33.827]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ... done
[09:31:33.827]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.812] result() for MulticoreFuture ...
[09:31:33.827]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.813] result() for MulticoreFuture ... done
[09:31:33.828] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.828] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.828] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.829] 
[09:31:33.829] Searching for globals ... DONE
[09:31:33.829] - globals: [0] <none>
[09:31:33.829] getGlobalsAndPackages() ... DONE
[09:31:33.830] run() for ‘Future’ ...
[09:31:33.830] - state: ‘created’
[09:31:33.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.834] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.835] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.835]   - Field: ‘label’
[09:31:33.835]   - Field: ‘local’
[09:31:33.835]   - Field: ‘owner’
[09:31:33.835]   - Field: ‘envir’
[09:31:33.835]   - Field: ‘workers’
[09:31:33.835]   - Field: ‘packages’
[09:31:33.835]   - Field: ‘gc’
[09:31:33.835]   - Field: ‘job’
[09:31:33.836]   - Field: ‘conditions’
[09:31:33.836]   - Field: ‘expr’
[09:31:33.836]   - Field: ‘uuid’
[09:31:33.836]   - Field: ‘seed’
[09:31:33.836]   - Field: ‘version’
[09:31:33.836]   - Field: ‘result’
[09:31:33.836]   - Field: ‘asynchronous’
[09:31:33.836]   - Field: ‘calls’
[09:31:33.837]   - Field: ‘globals’
[09:31:33.837]   - Field: ‘stdout’
[09:31:33.837]   - Field: ‘earlySignal’
[09:31:33.837]   - Field: ‘lazy’
[09:31:33.837]   - Field: ‘state’
[09:31:33.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.837] - Launch lazy future ...
[09:31:33.838] Packages needed by the future expression (n = 0): <none>
[09:31:33.838] Packages needed by future strategies (n = 0): <none>
[09:31:33.838] {
[09:31:33.838]     {
[09:31:33.838]         {
[09:31:33.838]             ...future.startTime <- base::Sys.time()
[09:31:33.838]             {
[09:31:33.838]                 {
[09:31:33.838]                   {
[09:31:33.838]                     {
[09:31:33.838]                       base::local({
[09:31:33.838]                         has_future <- base::requireNamespace("future", 
[09:31:33.838]                           quietly = TRUE)
[09:31:33.838]                         if (has_future) {
[09:31:33.838]                           ns <- base::getNamespace("future")
[09:31:33.838]                           version <- ns[[".package"]][["version"]]
[09:31:33.838]                           if (is.null(version)) 
[09:31:33.838]                             version <- utils::packageVersion("future")
[09:31:33.838]                         }
[09:31:33.838]                         else {
[09:31:33.838]                           version <- NULL
[09:31:33.838]                         }
[09:31:33.838]                         if (!has_future || version < "1.8.0") {
[09:31:33.838]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.838]                             "", base::R.version$version.string), 
[09:31:33.838]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.838]                               "release", "version")], collapse = " "), 
[09:31:33.838]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.838]                             info)
[09:31:33.838]                           info <- base::paste(info, collapse = "; ")
[09:31:33.838]                           if (!has_future) {
[09:31:33.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.838]                               info)
[09:31:33.838]                           }
[09:31:33.838]                           else {
[09:31:33.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.838]                               info, version)
[09:31:33.838]                           }
[09:31:33.838]                           base::stop(msg)
[09:31:33.838]                         }
[09:31:33.838]                       })
[09:31:33.838]                     }
[09:31:33.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.838]                     base::options(mc.cores = 1L)
[09:31:33.838]                   }
[09:31:33.838]                   ...future.strategy.old <- future::plan("list")
[09:31:33.838]                   options(future.plan = NULL)
[09:31:33.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.838]                 }
[09:31:33.838]                 ...future.workdir <- getwd()
[09:31:33.838]             }
[09:31:33.838]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.838]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.838]         }
[09:31:33.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.838]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.838]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.838]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.838]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.838]             base::names(...future.oldOptions))
[09:31:33.838]     }
[09:31:33.838]     if (FALSE) {
[09:31:33.838]     }
[09:31:33.838]     else {
[09:31:33.838]         if (TRUE) {
[09:31:33.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.838]                 open = "w")
[09:31:33.838]         }
[09:31:33.838]         else {
[09:31:33.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.838]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.838]         }
[09:31:33.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.838]             base::sink(type = "output", split = FALSE)
[09:31:33.838]             base::close(...future.stdout)
[09:31:33.838]         }, add = TRUE)
[09:31:33.838]     }
[09:31:33.838]     ...future.frame <- base::sys.nframe()
[09:31:33.838]     ...future.conditions <- base::list()
[09:31:33.838]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.838]     if (FALSE) {
[09:31:33.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.838]     }
[09:31:33.838]     ...future.result <- base::tryCatch({
[09:31:33.838]         base::withCallingHandlers({
[09:31:33.838]             ...future.value <- base::withVisible(base::local({
[09:31:33.838]                 withCallingHandlers({
[09:31:33.838]                   1
[09:31:33.838]                 }, immediateCondition = function(cond) {
[09:31:33.838]                   save_rds <- function (object, pathname, ...) 
[09:31:33.838]                   {
[09:31:33.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.838]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.838]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.838]                         fi_tmp[["mtime"]])
[09:31:33.838]                     }
[09:31:33.838]                     tryCatch({
[09:31:33.838]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.838]                     }, error = function(ex) {
[09:31:33.838]                       msg <- conditionMessage(ex)
[09:31:33.838]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.838]                         fi_tmp[["mtime"]], msg)
[09:31:33.838]                       ex$message <- msg
[09:31:33.838]                       stop(ex)
[09:31:33.838]                     })
[09:31:33.838]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.838]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.838]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.838]                       fi <- file.info(pathname)
[09:31:33.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.838]                         fi[["size"]], fi[["mtime"]])
[09:31:33.838]                       stop(msg)
[09:31:33.838]                     }
[09:31:33.838]                     invisible(pathname)
[09:31:33.838]                   }
[09:31:33.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.838]                     rootPath = tempdir()) 
[09:31:33.838]                   {
[09:31:33.838]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.838]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.838]                       tmpdir = path, fileext = ".rds")
[09:31:33.838]                     save_rds(obj, file)
[09:31:33.838]                   }
[09:31:33.838]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.838]                   {
[09:31:33.838]                     inherits <- base::inherits
[09:31:33.838]                     invokeRestart <- base::invokeRestart
[09:31:33.838]                     is.null <- base::is.null
[09:31:33.838]                     muffled <- FALSE
[09:31:33.838]                     if (inherits(cond, "message")) {
[09:31:33.838]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.838]                       if (muffled) 
[09:31:33.838]                         invokeRestart("muffleMessage")
[09:31:33.838]                     }
[09:31:33.838]                     else if (inherits(cond, "warning")) {
[09:31:33.838]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.838]                       if (muffled) 
[09:31:33.838]                         invokeRestart("muffleWarning")
[09:31:33.838]                     }
[09:31:33.838]                     else if (inherits(cond, "condition")) {
[09:31:33.838]                       if (!is.null(pattern)) {
[09:31:33.838]                         computeRestarts <- base::computeRestarts
[09:31:33.838]                         grepl <- base::grepl
[09:31:33.838]                         restarts <- computeRestarts(cond)
[09:31:33.838]                         for (restart in restarts) {
[09:31:33.838]                           name <- restart$name
[09:31:33.838]                           if (is.null(name)) 
[09:31:33.838]                             next
[09:31:33.838]                           if (!grepl(pattern, name)) 
[09:31:33.838]                             next
[09:31:33.838]                           invokeRestart(restart)
[09:31:33.838]                           muffled <- TRUE
[09:31:33.838]                           break
[09:31:33.838]                         }
[09:31:33.838]                       }
[09:31:33.838]                     }
[09:31:33.838]                     invisible(muffled)
[09:31:33.838]                   }
[09:31:33.838]                   muffleCondition(cond)
[09:31:33.838]                 })
[09:31:33.838]             }))
[09:31:33.838]             future::FutureResult(value = ...future.value$value, 
[09:31:33.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.838]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.838]                     ...future.globalenv.names))
[09:31:33.838]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.838]         }, condition = base::local({
[09:31:33.838]             c <- base::c
[09:31:33.838]             inherits <- base::inherits
[09:31:33.838]             invokeRestart <- base::invokeRestart
[09:31:33.838]             length <- base::length
[09:31:33.838]             list <- base::list
[09:31:33.838]             seq.int <- base::seq.int
[09:31:33.838]             signalCondition <- base::signalCondition
[09:31:33.838]             sys.calls <- base::sys.calls
[09:31:33.838]             `[[` <- base::`[[`
[09:31:33.838]             `+` <- base::`+`
[09:31:33.838]             `<<-` <- base::`<<-`
[09:31:33.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.838]                   3L)]
[09:31:33.838]             }
[09:31:33.838]             function(cond) {
[09:31:33.838]                 is_error <- inherits(cond, "error")
[09:31:33.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.838]                   NULL)
[09:31:33.838]                 if (is_error) {
[09:31:33.838]                   sessionInformation <- function() {
[09:31:33.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.838]                       search = base::search(), system = base::Sys.info())
[09:31:33.838]                   }
[09:31:33.838]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.838]                     cond$call), session = sessionInformation(), 
[09:31:33.838]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.838]                   signalCondition(cond)
[09:31:33.838]                 }
[09:31:33.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.838]                 "immediateCondition"))) {
[09:31:33.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.838]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.838]                   if (TRUE && !signal) {
[09:31:33.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.838]                     {
[09:31:33.838]                       inherits <- base::inherits
[09:31:33.838]                       invokeRestart <- base::invokeRestart
[09:31:33.838]                       is.null <- base::is.null
[09:31:33.838]                       muffled <- FALSE
[09:31:33.838]                       if (inherits(cond, "message")) {
[09:31:33.838]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.838]                         if (muffled) 
[09:31:33.838]                           invokeRestart("muffleMessage")
[09:31:33.838]                       }
[09:31:33.838]                       else if (inherits(cond, "warning")) {
[09:31:33.838]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.838]                         if (muffled) 
[09:31:33.838]                           invokeRestart("muffleWarning")
[09:31:33.838]                       }
[09:31:33.838]                       else if (inherits(cond, "condition")) {
[09:31:33.838]                         if (!is.null(pattern)) {
[09:31:33.838]                           computeRestarts <- base::computeRestarts
[09:31:33.838]                           grepl <- base::grepl
[09:31:33.838]                           restarts <- computeRestarts(cond)
[09:31:33.838]                           for (restart in restarts) {
[09:31:33.838]                             name <- restart$name
[09:31:33.838]                             if (is.null(name)) 
[09:31:33.838]                               next
[09:31:33.838]                             if (!grepl(pattern, name)) 
[09:31:33.838]                               next
[09:31:33.838]                             invokeRestart(restart)
[09:31:33.838]                             muffled <- TRUE
[09:31:33.838]                             break
[09:31:33.838]                           }
[09:31:33.838]                         }
[09:31:33.838]                       }
[09:31:33.838]                       invisible(muffled)
[09:31:33.838]                     }
[09:31:33.838]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.838]                   }
[09:31:33.838]                 }
[09:31:33.838]                 else {
[09:31:33.838]                   if (TRUE) {
[09:31:33.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.838]                     {
[09:31:33.838]                       inherits <- base::inherits
[09:31:33.838]                       invokeRestart <- base::invokeRestart
[09:31:33.838]                       is.null <- base::is.null
[09:31:33.838]                       muffled <- FALSE
[09:31:33.838]                       if (inherits(cond, "message")) {
[09:31:33.838]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.838]                         if (muffled) 
[09:31:33.838]                           invokeRestart("muffleMessage")
[09:31:33.838]                       }
[09:31:33.838]                       else if (inherits(cond, "warning")) {
[09:31:33.838]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.838]                         if (muffled) 
[09:31:33.838]                           invokeRestart("muffleWarning")
[09:31:33.838]                       }
[09:31:33.838]                       else if (inherits(cond, "condition")) {
[09:31:33.838]                         if (!is.null(pattern)) {
[09:31:33.838]                           computeRestarts <- base::computeRestarts
[09:31:33.838]                           grepl <- base::grepl
[09:31:33.838]                           restarts <- computeRestarts(cond)
[09:31:33.838]                           for (restart in restarts) {
[09:31:33.838]                             name <- restart$name
[09:31:33.838]                             if (is.null(name)) 
[09:31:33.838]                               next
[09:31:33.838]                             if (!grepl(pattern, name)) 
[09:31:33.838]                               next
[09:31:33.838]                             invokeRestart(restart)
[09:31:33.838]                             muffled <- TRUE
[09:31:33.838]                             break
[09:31:33.838]                           }
[09:31:33.838]                         }
[09:31:33.838]                       }
[09:31:33.838]                       invisible(muffled)
[09:31:33.838]                     }
[09:31:33.838]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.838]                   }
[09:31:33.838]                 }
[09:31:33.838]             }
[09:31:33.838]         }))
[09:31:33.838]     }, error = function(ex) {
[09:31:33.838]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.838]                 ...future.rng), started = ...future.startTime, 
[09:31:33.838]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.838]             version = "1.8"), class = "FutureResult")
[09:31:33.838]     }, finally = {
[09:31:33.838]         if (!identical(...future.workdir, getwd())) 
[09:31:33.838]             setwd(...future.workdir)
[09:31:33.838]         {
[09:31:33.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.838]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.838]             }
[09:31:33.838]             base::options(...future.oldOptions)
[09:31:33.838]             if (.Platform$OS.type == "windows") {
[09:31:33.838]                 old_names <- names(...future.oldEnvVars)
[09:31:33.838]                 envs <- base::Sys.getenv()
[09:31:33.838]                 names <- names(envs)
[09:31:33.838]                 common <- intersect(names, old_names)
[09:31:33.838]                 added <- setdiff(names, old_names)
[09:31:33.838]                 removed <- setdiff(old_names, names)
[09:31:33.838]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.838]                   envs[common]]
[09:31:33.838]                 NAMES <- toupper(changed)
[09:31:33.838]                 args <- list()
[09:31:33.838]                 for (kk in seq_along(NAMES)) {
[09:31:33.838]                   name <- changed[[kk]]
[09:31:33.838]                   NAME <- NAMES[[kk]]
[09:31:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.838]                     next
[09:31:33.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.838]                 }
[09:31:33.838]                 NAMES <- toupper(added)
[09:31:33.838]                 for (kk in seq_along(NAMES)) {
[09:31:33.838]                   name <- added[[kk]]
[09:31:33.838]                   NAME <- NAMES[[kk]]
[09:31:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.838]                     next
[09:31:33.838]                   args[[name]] <- ""
[09:31:33.838]                 }
[09:31:33.838]                 NAMES <- toupper(removed)
[09:31:33.838]                 for (kk in seq_along(NAMES)) {
[09:31:33.838]                   name <- removed[[kk]]
[09:31:33.838]                   NAME <- NAMES[[kk]]
[09:31:33.838]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.838]                     next
[09:31:33.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.838]                 }
[09:31:33.838]                 if (length(args) > 0) 
[09:31:33.838]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.838]             }
[09:31:33.838]             else {
[09:31:33.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.838]             }
[09:31:33.838]             {
[09:31:33.838]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.838]                   0L) {
[09:31:33.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.838]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.838]                   base::options(opts)
[09:31:33.838]                 }
[09:31:33.838]                 {
[09:31:33.838]                   {
[09:31:33.838]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.838]                     NULL
[09:31:33.838]                   }
[09:31:33.838]                   options(future.plan = NULL)
[09:31:33.838]                   if (is.na(NA_character_)) 
[09:31:33.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.838]                     .init = FALSE)
[09:31:33.838]                 }
[09:31:33.838]             }
[09:31:33.838]         }
[09:31:33.838]     })
[09:31:33.838]     if (TRUE) {
[09:31:33.838]         base::sink(type = "output", split = FALSE)
[09:31:33.838]         if (TRUE) {
[09:31:33.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.838]         }
[09:31:33.838]         else {
[09:31:33.838]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.838]         }
[09:31:33.838]         base::close(...future.stdout)
[09:31:33.838]         ...future.stdout <- NULL
[09:31:33.838]     }
[09:31:33.838]     ...future.result$conditions <- ...future.conditions
[09:31:33.838]     ...future.result$finished <- base::Sys.time()
[09:31:33.838]     ...future.result
[09:31:33.838] }
[09:31:33.841] requestCore(): workers = 2
[09:31:33.843] MulticoreFuture started
[09:31:33.843] - Launch lazy future ... done
[09:31:33.844] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.844] plan(): Setting new future strategy stack:
[09:31:33.844] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.845] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.844] List of future strategies:
[09:31:33.844] 1. sequential:
[09:31:33.844]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.844]    - tweaked: FALSE
[09:31:33.844]    - call: NULL
[09:31:33.845] plan(): nbrOfWorkers() = 1
[09:31:33.847] plan(): Setting new future strategy stack:
[09:31:33.848] List of future strategies:
[09:31:33.848] 1. multicore:
[09:31:33.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.848]    - tweaked: FALSE
[09:31:33.848]    - call: plan(strategy)
[09:31:33.851] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.852] Searching for globals ... DONE
[09:31:33.852] Resolving globals: TRUE
[09:31:33.852] Resolving any globals that are futures ...
[09:31:33.853] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.853] Resolving any globals that are futures ... DONE
[09:31:33.854] Resolving futures part of globals (recursively) ...
[09:31:33.855] resolve() on list ...
[09:31:33.856]  recursive: 99
[09:31:33.856] plan(): nbrOfWorkers() = 2
[09:31:33.856]  length: 1
[09:31:33.857]  elements: ‘a’
[09:31:33.857] Future #1
[09:31:33.858] result() for MulticoreFuture ...
[09:31:33.859] result() for MulticoreFuture ...
[09:31:33.859] result() for MulticoreFuture ... done
[09:31:33.859] result() for MulticoreFuture ... done
[09:31:33.859] result() for MulticoreFuture ...
[09:31:33.859] result() for MulticoreFuture ... done
[09:31:33.860] A MulticoreFuture was resolved
[09:31:33.860]  length: 0 (resolved future 1)
[09:31:33.860] resolve() on list ... DONE
[09:31:33.860] - globals: [1] ‘a’
[09:31:33.860] Resolving futures part of globals (recursively) ... DONE
[09:31:33.861] The total size of the 1 globals is 10.56 KiB (10816 bytes)
[09:31:33.862] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.56 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.56 KiB of class ‘environment’)
[09:31:33.862] - globals: [1] ‘a’
[09:31:33.862] - packages: [1] ‘future’
[09:31:33.862] getGlobalsAndPackages() ... DONE
[09:31:33.863] run() for ‘Future’ ...
[09:31:33.863] - state: ‘created’
[09:31:33.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.867] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.867] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.867]   - Field: ‘label’
[09:31:33.867]   - Field: ‘local’
[09:31:33.867]   - Field: ‘owner’
[09:31:33.868]   - Field: ‘envir’
[09:31:33.868]   - Field: ‘workers’
[09:31:33.868]   - Field: ‘packages’
[09:31:33.868]   - Field: ‘gc’
[09:31:33.868]   - Field: ‘job’
[09:31:33.868]   - Field: ‘conditions’
[09:31:33.868]   - Field: ‘expr’
[09:31:33.868]   - Field: ‘uuid’
[09:31:33.869]   - Field: ‘seed’
[09:31:33.869]   - Field: ‘version’
[09:31:33.869]   - Field: ‘result’
[09:31:33.869]   - Field: ‘asynchronous’
[09:31:33.869]   - Field: ‘calls’
[09:31:33.869]   - Field: ‘globals’
[09:31:33.869]   - Field: ‘stdout’
[09:31:33.869]   - Field: ‘earlySignal’
[09:31:33.869]   - Field: ‘lazy’
[09:31:33.869]   - Field: ‘state’
[09:31:33.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.870] - Launch lazy future ...
[09:31:33.870] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.870] Packages needed by future strategies (n = 0): <none>
[09:31:33.871] {
[09:31:33.871]     {
[09:31:33.871]         {
[09:31:33.871]             ...future.startTime <- base::Sys.time()
[09:31:33.871]             {
[09:31:33.871]                 {
[09:31:33.871]                   {
[09:31:33.871]                     {
[09:31:33.871]                       {
[09:31:33.871]                         base::local({
[09:31:33.871]                           has_future <- base::requireNamespace("future", 
[09:31:33.871]                             quietly = TRUE)
[09:31:33.871]                           if (has_future) {
[09:31:33.871]                             ns <- base::getNamespace("future")
[09:31:33.871]                             version <- ns[[".package"]][["version"]]
[09:31:33.871]                             if (is.null(version)) 
[09:31:33.871]                               version <- utils::packageVersion("future")
[09:31:33.871]                           }
[09:31:33.871]                           else {
[09:31:33.871]                             version <- NULL
[09:31:33.871]                           }
[09:31:33.871]                           if (!has_future || version < "1.8.0") {
[09:31:33.871]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.871]                               "", base::R.version$version.string), 
[09:31:33.871]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:33.871]                                 base::R.version$platform, 8 * 
[09:31:33.871]                                   base::.Machine$sizeof.pointer), 
[09:31:33.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.871]                                 "release", "version")], collapse = " "), 
[09:31:33.871]                               hostname = base::Sys.info()[["nodename"]])
[09:31:33.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.871]                               info)
[09:31:33.871]                             info <- base::paste(info, collapse = "; ")
[09:31:33.871]                             if (!has_future) {
[09:31:33.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.871]                                 info)
[09:31:33.871]                             }
[09:31:33.871]                             else {
[09:31:33.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.871]                                 info, version)
[09:31:33.871]                             }
[09:31:33.871]                             base::stop(msg)
[09:31:33.871]                           }
[09:31:33.871]                         })
[09:31:33.871]                       }
[09:31:33.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.871]                       base::options(mc.cores = 1L)
[09:31:33.871]                     }
[09:31:33.871]                     base::local({
[09:31:33.871]                       for (pkg in "future") {
[09:31:33.871]                         base::loadNamespace(pkg)
[09:31:33.871]                         base::library(pkg, character.only = TRUE)
[09:31:33.871]                       }
[09:31:33.871]                     })
[09:31:33.871]                   }
[09:31:33.871]                   ...future.strategy.old <- future::plan("list")
[09:31:33.871]                   options(future.plan = NULL)
[09:31:33.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.871]                 }
[09:31:33.871]                 ...future.workdir <- getwd()
[09:31:33.871]             }
[09:31:33.871]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.871]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.871]         }
[09:31:33.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.871]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.871]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.871]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.871]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.871]             base::names(...future.oldOptions))
[09:31:33.871]     }
[09:31:33.871]     if (FALSE) {
[09:31:33.871]     }
[09:31:33.871]     else {
[09:31:33.871]         if (TRUE) {
[09:31:33.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.871]                 open = "w")
[09:31:33.871]         }
[09:31:33.871]         else {
[09:31:33.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.871]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.871]         }
[09:31:33.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.871]             base::sink(type = "output", split = FALSE)
[09:31:33.871]             base::close(...future.stdout)
[09:31:33.871]         }, add = TRUE)
[09:31:33.871]     }
[09:31:33.871]     ...future.frame <- base::sys.nframe()
[09:31:33.871]     ...future.conditions <- base::list()
[09:31:33.871]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.871]     if (FALSE) {
[09:31:33.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.871]     }
[09:31:33.871]     ...future.result <- base::tryCatch({
[09:31:33.871]         base::withCallingHandlers({
[09:31:33.871]             ...future.value <- base::withVisible(base::local({
[09:31:33.871]                 withCallingHandlers({
[09:31:33.871]                   value(a) + 1
[09:31:33.871]                 }, immediateCondition = function(cond) {
[09:31:33.871]                   save_rds <- function (object, pathname, ...) 
[09:31:33.871]                   {
[09:31:33.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.871]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.871]                         fi_tmp[["mtime"]])
[09:31:33.871]                     }
[09:31:33.871]                     tryCatch({
[09:31:33.871]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.871]                     }, error = function(ex) {
[09:31:33.871]                       msg <- conditionMessage(ex)
[09:31:33.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.871]                         fi_tmp[["mtime"]], msg)
[09:31:33.871]                       ex$message <- msg
[09:31:33.871]                       stop(ex)
[09:31:33.871]                     })
[09:31:33.871]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.871]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.871]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.871]                       fi <- file.info(pathname)
[09:31:33.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.871]                         fi[["size"]], fi[["mtime"]])
[09:31:33.871]                       stop(msg)
[09:31:33.871]                     }
[09:31:33.871]                     invisible(pathname)
[09:31:33.871]                   }
[09:31:33.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.871]                     rootPath = tempdir()) 
[09:31:33.871]                   {
[09:31:33.871]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.871]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.871]                       tmpdir = path, fileext = ".rds")
[09:31:33.871]                     save_rds(obj, file)
[09:31:33.871]                   }
[09:31:33.871]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.871]                   {
[09:31:33.871]                     inherits <- base::inherits
[09:31:33.871]                     invokeRestart <- base::invokeRestart
[09:31:33.871]                     is.null <- base::is.null
[09:31:33.871]                     muffled <- FALSE
[09:31:33.871]                     if (inherits(cond, "message")) {
[09:31:33.871]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.871]                       if (muffled) 
[09:31:33.871]                         invokeRestart("muffleMessage")
[09:31:33.871]                     }
[09:31:33.871]                     else if (inherits(cond, "warning")) {
[09:31:33.871]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.871]                       if (muffled) 
[09:31:33.871]                         invokeRestart("muffleWarning")
[09:31:33.871]                     }
[09:31:33.871]                     else if (inherits(cond, "condition")) {
[09:31:33.871]                       if (!is.null(pattern)) {
[09:31:33.871]                         computeRestarts <- base::computeRestarts
[09:31:33.871]                         grepl <- base::grepl
[09:31:33.871]                         restarts <- computeRestarts(cond)
[09:31:33.871]                         for (restart in restarts) {
[09:31:33.871]                           name <- restart$name
[09:31:33.871]                           if (is.null(name)) 
[09:31:33.871]                             next
[09:31:33.871]                           if (!grepl(pattern, name)) 
[09:31:33.871]                             next
[09:31:33.871]                           invokeRestart(restart)
[09:31:33.871]                           muffled <- TRUE
[09:31:33.871]                           break
[09:31:33.871]                         }
[09:31:33.871]                       }
[09:31:33.871]                     }
[09:31:33.871]                     invisible(muffled)
[09:31:33.871]                   }
[09:31:33.871]                   muffleCondition(cond)
[09:31:33.871]                 })
[09:31:33.871]             }))
[09:31:33.871]             future::FutureResult(value = ...future.value$value, 
[09:31:33.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.871]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.871]                     ...future.globalenv.names))
[09:31:33.871]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.871]         }, condition = base::local({
[09:31:33.871]             c <- base::c
[09:31:33.871]             inherits <- base::inherits
[09:31:33.871]             invokeRestart <- base::invokeRestart
[09:31:33.871]             length <- base::length
[09:31:33.871]             list <- base::list
[09:31:33.871]             seq.int <- base::seq.int
[09:31:33.871]             signalCondition <- base::signalCondition
[09:31:33.871]             sys.calls <- base::sys.calls
[09:31:33.871]             `[[` <- base::`[[`
[09:31:33.871]             `+` <- base::`+`
[09:31:33.871]             `<<-` <- base::`<<-`
[09:31:33.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.871]                   3L)]
[09:31:33.871]             }
[09:31:33.871]             function(cond) {
[09:31:33.871]                 is_error <- inherits(cond, "error")
[09:31:33.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.871]                   NULL)
[09:31:33.871]                 if (is_error) {
[09:31:33.871]                   sessionInformation <- function() {
[09:31:33.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.871]                       search = base::search(), system = base::Sys.info())
[09:31:33.871]                   }
[09:31:33.871]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.871]                     cond$call), session = sessionInformation(), 
[09:31:33.871]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.871]                   signalCondition(cond)
[09:31:33.871]                 }
[09:31:33.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.871]                 "immediateCondition"))) {
[09:31:33.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.871]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.871]                   if (TRUE && !signal) {
[09:31:33.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.871]                     {
[09:31:33.871]                       inherits <- base::inherits
[09:31:33.871]                       invokeRestart <- base::invokeRestart
[09:31:33.871]                       is.null <- base::is.null
[09:31:33.871]                       muffled <- FALSE
[09:31:33.871]                       if (inherits(cond, "message")) {
[09:31:33.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.871]                         if (muffled) 
[09:31:33.871]                           invokeRestart("muffleMessage")
[09:31:33.871]                       }
[09:31:33.871]                       else if (inherits(cond, "warning")) {
[09:31:33.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.871]                         if (muffled) 
[09:31:33.871]                           invokeRestart("muffleWarning")
[09:31:33.871]                       }
[09:31:33.871]                       else if (inherits(cond, "condition")) {
[09:31:33.871]                         if (!is.null(pattern)) {
[09:31:33.871]                           computeRestarts <- base::computeRestarts
[09:31:33.871]                           grepl <- base::grepl
[09:31:33.871]                           restarts <- computeRestarts(cond)
[09:31:33.871]                           for (restart in restarts) {
[09:31:33.871]                             name <- restart$name
[09:31:33.871]                             if (is.null(name)) 
[09:31:33.871]                               next
[09:31:33.871]                             if (!grepl(pattern, name)) 
[09:31:33.871]                               next
[09:31:33.871]                             invokeRestart(restart)
[09:31:33.871]                             muffled <- TRUE
[09:31:33.871]                             break
[09:31:33.871]                           }
[09:31:33.871]                         }
[09:31:33.871]                       }
[09:31:33.871]                       invisible(muffled)
[09:31:33.871]                     }
[09:31:33.871]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.871]                   }
[09:31:33.871]                 }
[09:31:33.871]                 else {
[09:31:33.871]                   if (TRUE) {
[09:31:33.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.871]                     {
[09:31:33.871]                       inherits <- base::inherits
[09:31:33.871]                       invokeRestart <- base::invokeRestart
[09:31:33.871]                       is.null <- base::is.null
[09:31:33.871]                       muffled <- FALSE
[09:31:33.871]                       if (inherits(cond, "message")) {
[09:31:33.871]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.871]                         if (muffled) 
[09:31:33.871]                           invokeRestart("muffleMessage")
[09:31:33.871]                       }
[09:31:33.871]                       else if (inherits(cond, "warning")) {
[09:31:33.871]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.871]                         if (muffled) 
[09:31:33.871]                           invokeRestart("muffleWarning")
[09:31:33.871]                       }
[09:31:33.871]                       else if (inherits(cond, "condition")) {
[09:31:33.871]                         if (!is.null(pattern)) {
[09:31:33.871]                           computeRestarts <- base::computeRestarts
[09:31:33.871]                           grepl <- base::grepl
[09:31:33.871]                           restarts <- computeRestarts(cond)
[09:31:33.871]                           for (restart in restarts) {
[09:31:33.871]                             name <- restart$name
[09:31:33.871]                             if (is.null(name)) 
[09:31:33.871]                               next
[09:31:33.871]                             if (!grepl(pattern, name)) 
[09:31:33.871]                               next
[09:31:33.871]                             invokeRestart(restart)
[09:31:33.871]                             muffled <- TRUE
[09:31:33.871]                             break
[09:31:33.871]                           }
[09:31:33.871]                         }
[09:31:33.871]                       }
[09:31:33.871]                       invisible(muffled)
[09:31:33.871]                     }
[09:31:33.871]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.871]                   }
[09:31:33.871]                 }
[09:31:33.871]             }
[09:31:33.871]         }))
[09:31:33.871]     }, error = function(ex) {
[09:31:33.871]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.871]                 ...future.rng), started = ...future.startTime, 
[09:31:33.871]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.871]             version = "1.8"), class = "FutureResult")
[09:31:33.871]     }, finally = {
[09:31:33.871]         if (!identical(...future.workdir, getwd())) 
[09:31:33.871]             setwd(...future.workdir)
[09:31:33.871]         {
[09:31:33.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.871]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.871]             }
[09:31:33.871]             base::options(...future.oldOptions)
[09:31:33.871]             if (.Platform$OS.type == "windows") {
[09:31:33.871]                 old_names <- names(...future.oldEnvVars)
[09:31:33.871]                 envs <- base::Sys.getenv()
[09:31:33.871]                 names <- names(envs)
[09:31:33.871]                 common <- intersect(names, old_names)
[09:31:33.871]                 added <- setdiff(names, old_names)
[09:31:33.871]                 removed <- setdiff(old_names, names)
[09:31:33.871]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.871]                   envs[common]]
[09:31:33.871]                 NAMES <- toupper(changed)
[09:31:33.871]                 args <- list()
[09:31:33.871]                 for (kk in seq_along(NAMES)) {
[09:31:33.871]                   name <- changed[[kk]]
[09:31:33.871]                   NAME <- NAMES[[kk]]
[09:31:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.871]                     next
[09:31:33.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.871]                 }
[09:31:33.871]                 NAMES <- toupper(added)
[09:31:33.871]                 for (kk in seq_along(NAMES)) {
[09:31:33.871]                   name <- added[[kk]]
[09:31:33.871]                   NAME <- NAMES[[kk]]
[09:31:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.871]                     next
[09:31:33.871]                   args[[name]] <- ""
[09:31:33.871]                 }
[09:31:33.871]                 NAMES <- toupper(removed)
[09:31:33.871]                 for (kk in seq_along(NAMES)) {
[09:31:33.871]                   name <- removed[[kk]]
[09:31:33.871]                   NAME <- NAMES[[kk]]
[09:31:33.871]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.871]                     next
[09:31:33.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.871]                 }
[09:31:33.871]                 if (length(args) > 0) 
[09:31:33.871]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.871]             }
[09:31:33.871]             else {
[09:31:33.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.871]             }
[09:31:33.871]             {
[09:31:33.871]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.871]                   0L) {
[09:31:33.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.871]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.871]                   base::options(opts)
[09:31:33.871]                 }
[09:31:33.871]                 {
[09:31:33.871]                   {
[09:31:33.871]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.871]                     NULL
[09:31:33.871]                   }
[09:31:33.871]                   options(future.plan = NULL)
[09:31:33.871]                   if (is.na(NA_character_)) 
[09:31:33.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.871]                     .init = FALSE)
[09:31:33.871]                 }
[09:31:33.871]             }
[09:31:33.871]         }
[09:31:33.871]     })
[09:31:33.871]     if (TRUE) {
[09:31:33.871]         base::sink(type = "output", split = FALSE)
[09:31:33.871]         if (TRUE) {
[09:31:33.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.871]         }
[09:31:33.871]         else {
[09:31:33.871]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.871]         }
[09:31:33.871]         base::close(...future.stdout)
[09:31:33.871]         ...future.stdout <- NULL
[09:31:33.871]     }
[09:31:33.871]     ...future.result$conditions <- ...future.conditions
[09:31:33.871]     ...future.result$finished <- base::Sys.time()
[09:31:33.871]     ...future.result
[09:31:33.871] }
[09:31:33.873] assign_globals() ...
[09:31:33.873] List of 1
[09:31:33.873]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e21a1c9660> 
[09:31:33.873]  - attr(*, "where")=List of 1
[09:31:33.873]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.873]  - attr(*, "resolved")= logi TRUE
[09:31:33.873]  - attr(*, "total_size")= num 10816
[09:31:33.873]  - attr(*, "already-done")= logi TRUE
[09:31:33.876] - copied ‘a’ to environment
[09:31:33.876] assign_globals() ... done
[09:31:33.876] requestCore(): workers = 2
[09:31:33.878] MulticoreFuture started
[09:31:33.879] - Launch lazy future ... done
[09:31:33.879] run() for ‘MulticoreFuture’ ... done
[09:31:33.879] result() for MulticoreFuture ...
[09:31:33.880] plan(): Setting new future strategy stack:
[09:31:33.880] List of future strategies:
[09:31:33.880] 1. sequential:
[09:31:33.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.880]    - tweaked: FALSE
[09:31:33.880]    - call: NULL
[09:31:33.881] plan(): nbrOfWorkers() = 1
[09:31:33.884] plan(): Setting new future strategy stack:
[09:31:33.884] List of future strategies:
[09:31:33.884] 1. multicore:
[09:31:33.884]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.884]    - tweaked: FALSE
[09:31:33.884]    - call: plan(strategy)
[09:31:33.890] plan(): nbrOfWorkers() = 2
[09:31:33.890] result() for MulticoreFuture ...
[09:31:33.891] result() for MulticoreFuture ... done
[09:31:33.891] signalConditions() ...
[09:31:33.891]  - include = ‘immediateCondition’
[09:31:33.891]  - exclude = 
[09:31:33.891]  - resignal = FALSE
[09:31:33.891]  - Number of conditions: 4
[09:31:33.891] signalConditions() ... done
[09:31:33.891] result() for MulticoreFuture ... done
[09:31:33.892] result() for MulticoreFuture ...
[09:31:33.892] result() for MulticoreFuture ... done
[09:31:33.892] signalConditions() ...
[09:31:33.892]  - include = ‘immediateCondition’
[09:31:33.892]  - exclude = 
[09:31:33.892]  - resignal = FALSE
[09:31:33.892]  - Number of conditions: 4
[09:31:33.892] signalConditions() ... done
[09:31:33.893] Future state: ‘finished’
[09:31:33.893] result() for MulticoreFuture ...
[09:31:33.893] result() for MulticoreFuture ... done
[09:31:33.893] signalConditions() ...
[09:31:33.893]  - include = ‘condition’
[09:31:33.893]  - exclude = ‘immediateCondition’
[09:31:33.893]  - resignal = TRUE
[09:31:33.893]  - Number of conditions: 4
[09:31:33.893]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.882] result() for MulticoreFuture ...
[09:31:33.894]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ... done
[09:31:33.894]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ...
[09:31:33.894]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ... done
[09:31:33.894] signalConditions() ... done
value(b) = 2
[09:31:33.894] result() for MulticoreFuture ...
[09:31:33.894] result() for MulticoreFuture ... done
[09:31:33.895] result() for MulticoreFuture ...
[09:31:33.895] result() for MulticoreFuture ... done
[09:31:33.895] signalConditions() ...
[09:31:33.895]  - include = ‘immediateCondition’
[09:31:33.895]  - exclude = 
[09:31:33.895]  - resignal = FALSE
[09:31:33.895]  - Number of conditions: 4
[09:31:33.895] signalConditions() ... done
[09:31:33.895] Future state: ‘finished’
[09:31:33.896] result() for MulticoreFuture ...
[09:31:33.896] result() for MulticoreFuture ... done
[09:31:33.896] signalConditions() ...
[09:31:33.896]  - include = ‘condition’
[09:31:33.896]  - exclude = ‘immediateCondition’
[09:31:33.896]  - resignal = TRUE
[09:31:33.896]  - Number of conditions: 4
[09:31:33.896]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.882] result() for MulticoreFuture ...
[09:31:33.897]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ... done
[09:31:33.897]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ...
[09:31:33.897]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.883] result() for MulticoreFuture ... done
[09:31:33.897] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.897] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.900] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.901] 
[09:31:33.901] Searching for globals ... DONE
[09:31:33.902] - globals: [0] <none>
[09:31:33.902] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.902] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.903] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.904] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.904] Searching for globals ... DONE
[09:31:33.904] Resolving globals: TRUE
[09:31:33.904] Resolving any globals that are futures ...
[09:31:33.905] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.905] Resolving any globals that are futures ... DONE
[09:31:33.905] Resolving futures part of globals (recursively) ...
[09:31:33.905] resolve() on list ...
[09:31:33.905]  recursive: 99
[09:31:33.906]  length: 1
[09:31:33.906]  elements: ‘a’
[09:31:33.906] run() for ‘Future’ ...
[09:31:33.906] - state: ‘created’
[09:31:33.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.910]   - Field: ‘label’
[09:31:33.910]   - Field: ‘local’
[09:31:33.910]   - Field: ‘owner’
[09:31:33.911]   - Field: ‘envir’
[09:31:33.911]   - Field: ‘workers’
[09:31:33.911]   - Field: ‘packages’
[09:31:33.911]   - Field: ‘gc’
[09:31:33.911]   - Field: ‘job’
[09:31:33.911]   - Field: ‘conditions’
[09:31:33.911]   - Field: ‘expr’
[09:31:33.911]   - Field: ‘uuid’
[09:31:33.911]   - Field: ‘seed’
[09:31:33.912]   - Field: ‘version’
[09:31:33.912]   - Field: ‘result’
[09:31:33.912]   - Field: ‘asynchronous’
[09:31:33.912]   - Field: ‘calls’
[09:31:33.912]   - Field: ‘globals’
[09:31:33.912]   - Field: ‘stdout’
[09:31:33.912]   - Field: ‘earlySignal’
[09:31:33.912]   - Field: ‘lazy’
[09:31:33.912]   - Field: ‘state’
[09:31:33.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.913] - Launch lazy future ...
[09:31:33.913] Packages needed by the future expression (n = 0): <none>
[09:31:33.913] Packages needed by future strategies (n = 0): <none>
[09:31:33.913] {
[09:31:33.913]     {
[09:31:33.913]         {
[09:31:33.913]             ...future.startTime <- base::Sys.time()
[09:31:33.913]             {
[09:31:33.913]                 {
[09:31:33.913]                   {
[09:31:33.913]                     {
[09:31:33.913]                       base::local({
[09:31:33.913]                         has_future <- base::requireNamespace("future", 
[09:31:33.913]                           quietly = TRUE)
[09:31:33.913]                         if (has_future) {
[09:31:33.913]                           ns <- base::getNamespace("future")
[09:31:33.913]                           version <- ns[[".package"]][["version"]]
[09:31:33.913]                           if (is.null(version)) 
[09:31:33.913]                             version <- utils::packageVersion("future")
[09:31:33.913]                         }
[09:31:33.913]                         else {
[09:31:33.913]                           version <- NULL
[09:31:33.913]                         }
[09:31:33.913]                         if (!has_future || version < "1.8.0") {
[09:31:33.913]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.913]                             "", base::R.version$version.string), 
[09:31:33.913]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.913]                               "release", "version")], collapse = " "), 
[09:31:33.913]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.913]                             info)
[09:31:33.913]                           info <- base::paste(info, collapse = "; ")
[09:31:33.913]                           if (!has_future) {
[09:31:33.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.913]                               info)
[09:31:33.913]                           }
[09:31:33.913]                           else {
[09:31:33.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.913]                               info, version)
[09:31:33.913]                           }
[09:31:33.913]                           base::stop(msg)
[09:31:33.913]                         }
[09:31:33.913]                       })
[09:31:33.913]                     }
[09:31:33.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.913]                     base::options(mc.cores = 1L)
[09:31:33.913]                   }
[09:31:33.913]                   ...future.strategy.old <- future::plan("list")
[09:31:33.913]                   options(future.plan = NULL)
[09:31:33.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.913]                 }
[09:31:33.913]                 ...future.workdir <- getwd()
[09:31:33.913]             }
[09:31:33.913]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.913]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.913]         }
[09:31:33.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.913]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.913]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.913]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.913]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.913]             base::names(...future.oldOptions))
[09:31:33.913]     }
[09:31:33.913]     if (FALSE) {
[09:31:33.913]     }
[09:31:33.913]     else {
[09:31:33.913]         if (TRUE) {
[09:31:33.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.913]                 open = "w")
[09:31:33.913]         }
[09:31:33.913]         else {
[09:31:33.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.913]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.913]         }
[09:31:33.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.913]             base::sink(type = "output", split = FALSE)
[09:31:33.913]             base::close(...future.stdout)
[09:31:33.913]         }, add = TRUE)
[09:31:33.913]     }
[09:31:33.913]     ...future.frame <- base::sys.nframe()
[09:31:33.913]     ...future.conditions <- base::list()
[09:31:33.913]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.913]     if (FALSE) {
[09:31:33.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.913]     }
[09:31:33.913]     ...future.result <- base::tryCatch({
[09:31:33.913]         base::withCallingHandlers({
[09:31:33.913]             ...future.value <- base::withVisible(base::local({
[09:31:33.913]                 withCallingHandlers({
[09:31:33.913]                   1
[09:31:33.913]                 }, immediateCondition = function(cond) {
[09:31:33.913]                   save_rds <- function (object, pathname, ...) 
[09:31:33.913]                   {
[09:31:33.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.913]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.913]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.913]                         fi_tmp[["mtime"]])
[09:31:33.913]                     }
[09:31:33.913]                     tryCatch({
[09:31:33.913]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.913]                     }, error = function(ex) {
[09:31:33.913]                       msg <- conditionMessage(ex)
[09:31:33.913]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.913]                         fi_tmp[["mtime"]], msg)
[09:31:33.913]                       ex$message <- msg
[09:31:33.913]                       stop(ex)
[09:31:33.913]                     })
[09:31:33.913]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.913]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.913]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.913]                       fi <- file.info(pathname)
[09:31:33.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.913]                         fi[["size"]], fi[["mtime"]])
[09:31:33.913]                       stop(msg)
[09:31:33.913]                     }
[09:31:33.913]                     invisible(pathname)
[09:31:33.913]                   }
[09:31:33.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.913]                     rootPath = tempdir()) 
[09:31:33.913]                   {
[09:31:33.913]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.913]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.913]                       tmpdir = path, fileext = ".rds")
[09:31:33.913]                     save_rds(obj, file)
[09:31:33.913]                   }
[09:31:33.913]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.913]                   {
[09:31:33.913]                     inherits <- base::inherits
[09:31:33.913]                     invokeRestart <- base::invokeRestart
[09:31:33.913]                     is.null <- base::is.null
[09:31:33.913]                     muffled <- FALSE
[09:31:33.913]                     if (inherits(cond, "message")) {
[09:31:33.913]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.913]                       if (muffled) 
[09:31:33.913]                         invokeRestart("muffleMessage")
[09:31:33.913]                     }
[09:31:33.913]                     else if (inherits(cond, "warning")) {
[09:31:33.913]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.913]                       if (muffled) 
[09:31:33.913]                         invokeRestart("muffleWarning")
[09:31:33.913]                     }
[09:31:33.913]                     else if (inherits(cond, "condition")) {
[09:31:33.913]                       if (!is.null(pattern)) {
[09:31:33.913]                         computeRestarts <- base::computeRestarts
[09:31:33.913]                         grepl <- base::grepl
[09:31:33.913]                         restarts <- computeRestarts(cond)
[09:31:33.913]                         for (restart in restarts) {
[09:31:33.913]                           name <- restart$name
[09:31:33.913]                           if (is.null(name)) 
[09:31:33.913]                             next
[09:31:33.913]                           if (!grepl(pattern, name)) 
[09:31:33.913]                             next
[09:31:33.913]                           invokeRestart(restart)
[09:31:33.913]                           muffled <- TRUE
[09:31:33.913]                           break
[09:31:33.913]                         }
[09:31:33.913]                       }
[09:31:33.913]                     }
[09:31:33.913]                     invisible(muffled)
[09:31:33.913]                   }
[09:31:33.913]                   muffleCondition(cond)
[09:31:33.913]                 })
[09:31:33.913]             }))
[09:31:33.913]             future::FutureResult(value = ...future.value$value, 
[09:31:33.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.913]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.913]                     ...future.globalenv.names))
[09:31:33.913]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.913]         }, condition = base::local({
[09:31:33.913]             c <- base::c
[09:31:33.913]             inherits <- base::inherits
[09:31:33.913]             invokeRestart <- base::invokeRestart
[09:31:33.913]             length <- base::length
[09:31:33.913]             list <- base::list
[09:31:33.913]             seq.int <- base::seq.int
[09:31:33.913]             signalCondition <- base::signalCondition
[09:31:33.913]             sys.calls <- base::sys.calls
[09:31:33.913]             `[[` <- base::`[[`
[09:31:33.913]             `+` <- base::`+`
[09:31:33.913]             `<<-` <- base::`<<-`
[09:31:33.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.913]                   3L)]
[09:31:33.913]             }
[09:31:33.913]             function(cond) {
[09:31:33.913]                 is_error <- inherits(cond, "error")
[09:31:33.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.913]                   NULL)
[09:31:33.913]                 if (is_error) {
[09:31:33.913]                   sessionInformation <- function() {
[09:31:33.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.913]                       search = base::search(), system = base::Sys.info())
[09:31:33.913]                   }
[09:31:33.913]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.913]                     cond$call), session = sessionInformation(), 
[09:31:33.913]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.913]                   signalCondition(cond)
[09:31:33.913]                 }
[09:31:33.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.913]                 "immediateCondition"))) {
[09:31:33.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.913]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.913]                   if (TRUE && !signal) {
[09:31:33.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.913]                     {
[09:31:33.913]                       inherits <- base::inherits
[09:31:33.913]                       invokeRestart <- base::invokeRestart
[09:31:33.913]                       is.null <- base::is.null
[09:31:33.913]                       muffled <- FALSE
[09:31:33.913]                       if (inherits(cond, "message")) {
[09:31:33.913]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.913]                         if (muffled) 
[09:31:33.913]                           invokeRestart("muffleMessage")
[09:31:33.913]                       }
[09:31:33.913]                       else if (inherits(cond, "warning")) {
[09:31:33.913]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.913]                         if (muffled) 
[09:31:33.913]                           invokeRestart("muffleWarning")
[09:31:33.913]                       }
[09:31:33.913]                       else if (inherits(cond, "condition")) {
[09:31:33.913]                         if (!is.null(pattern)) {
[09:31:33.913]                           computeRestarts <- base::computeRestarts
[09:31:33.913]                           grepl <- base::grepl
[09:31:33.913]                           restarts <- computeRestarts(cond)
[09:31:33.913]                           for (restart in restarts) {
[09:31:33.913]                             name <- restart$name
[09:31:33.913]                             if (is.null(name)) 
[09:31:33.913]                               next
[09:31:33.913]                             if (!grepl(pattern, name)) 
[09:31:33.913]                               next
[09:31:33.913]                             invokeRestart(restart)
[09:31:33.913]                             muffled <- TRUE
[09:31:33.913]                             break
[09:31:33.913]                           }
[09:31:33.913]                         }
[09:31:33.913]                       }
[09:31:33.913]                       invisible(muffled)
[09:31:33.913]                     }
[09:31:33.913]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.913]                   }
[09:31:33.913]                 }
[09:31:33.913]                 else {
[09:31:33.913]                   if (TRUE) {
[09:31:33.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.913]                     {
[09:31:33.913]                       inherits <- base::inherits
[09:31:33.913]                       invokeRestart <- base::invokeRestart
[09:31:33.913]                       is.null <- base::is.null
[09:31:33.913]                       muffled <- FALSE
[09:31:33.913]                       if (inherits(cond, "message")) {
[09:31:33.913]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.913]                         if (muffled) 
[09:31:33.913]                           invokeRestart("muffleMessage")
[09:31:33.913]                       }
[09:31:33.913]                       else if (inherits(cond, "warning")) {
[09:31:33.913]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.913]                         if (muffled) 
[09:31:33.913]                           invokeRestart("muffleWarning")
[09:31:33.913]                       }
[09:31:33.913]                       else if (inherits(cond, "condition")) {
[09:31:33.913]                         if (!is.null(pattern)) {
[09:31:33.913]                           computeRestarts <- base::computeRestarts
[09:31:33.913]                           grepl <- base::grepl
[09:31:33.913]                           restarts <- computeRestarts(cond)
[09:31:33.913]                           for (restart in restarts) {
[09:31:33.913]                             name <- restart$name
[09:31:33.913]                             if (is.null(name)) 
[09:31:33.913]                               next
[09:31:33.913]                             if (!grepl(pattern, name)) 
[09:31:33.913]                               next
[09:31:33.913]                             invokeRestart(restart)
[09:31:33.913]                             muffled <- TRUE
[09:31:33.913]                             break
[09:31:33.913]                           }
[09:31:33.913]                         }
[09:31:33.913]                       }
[09:31:33.913]                       invisible(muffled)
[09:31:33.913]                     }
[09:31:33.913]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.913]                   }
[09:31:33.913]                 }
[09:31:33.913]             }
[09:31:33.913]         }))
[09:31:33.913]     }, error = function(ex) {
[09:31:33.913]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.913]                 ...future.rng), started = ...future.startTime, 
[09:31:33.913]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.913]             version = "1.8"), class = "FutureResult")
[09:31:33.913]     }, finally = {
[09:31:33.913]         if (!identical(...future.workdir, getwd())) 
[09:31:33.913]             setwd(...future.workdir)
[09:31:33.913]         {
[09:31:33.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.913]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.913]             }
[09:31:33.913]             base::options(...future.oldOptions)
[09:31:33.913]             if (.Platform$OS.type == "windows") {
[09:31:33.913]                 old_names <- names(...future.oldEnvVars)
[09:31:33.913]                 envs <- base::Sys.getenv()
[09:31:33.913]                 names <- names(envs)
[09:31:33.913]                 common <- intersect(names, old_names)
[09:31:33.913]                 added <- setdiff(names, old_names)
[09:31:33.913]                 removed <- setdiff(old_names, names)
[09:31:33.913]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.913]                   envs[common]]
[09:31:33.913]                 NAMES <- toupper(changed)
[09:31:33.913]                 args <- list()
[09:31:33.913]                 for (kk in seq_along(NAMES)) {
[09:31:33.913]                   name <- changed[[kk]]
[09:31:33.913]                   NAME <- NAMES[[kk]]
[09:31:33.913]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.913]                     next
[09:31:33.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.913]                 }
[09:31:33.913]                 NAMES <- toupper(added)
[09:31:33.913]                 for (kk in seq_along(NAMES)) {
[09:31:33.913]                   name <- added[[kk]]
[09:31:33.913]                   NAME <- NAMES[[kk]]
[09:31:33.913]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.913]                     next
[09:31:33.913]                   args[[name]] <- ""
[09:31:33.913]                 }
[09:31:33.913]                 NAMES <- toupper(removed)
[09:31:33.913]                 for (kk in seq_along(NAMES)) {
[09:31:33.913]                   name <- removed[[kk]]
[09:31:33.913]                   NAME <- NAMES[[kk]]
[09:31:33.913]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.913]                     next
[09:31:33.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.913]                 }
[09:31:33.913]                 if (length(args) > 0) 
[09:31:33.913]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.913]             }
[09:31:33.913]             else {
[09:31:33.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.913]             }
[09:31:33.913]             {
[09:31:33.913]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.913]                   0L) {
[09:31:33.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.913]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.913]                   base::options(opts)
[09:31:33.913]                 }
[09:31:33.913]                 {
[09:31:33.913]                   {
[09:31:33.913]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.913]                     NULL
[09:31:33.913]                   }
[09:31:33.913]                   options(future.plan = NULL)
[09:31:33.913]                   if (is.na(NA_character_)) 
[09:31:33.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.913]                     .init = FALSE)
[09:31:33.913]                 }
[09:31:33.913]             }
[09:31:33.913]         }
[09:31:33.913]     })
[09:31:33.913]     if (TRUE) {
[09:31:33.913]         base::sink(type = "output", split = FALSE)
[09:31:33.913]         if (TRUE) {
[09:31:33.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.913]         }
[09:31:33.913]         else {
[09:31:33.913]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.913]         }
[09:31:33.913]         base::close(...future.stdout)
[09:31:33.913]         ...future.stdout <- NULL
[09:31:33.913]     }
[09:31:33.913]     ...future.result$conditions <- ...future.conditions
[09:31:33.913]     ...future.result$finished <- base::Sys.time()
[09:31:33.913]     ...future.result
[09:31:33.913] }
[09:31:33.916] requestCore(): workers = 2
[09:31:33.918] MulticoreFuture started
[09:31:33.918] - Launch lazy future ... done
[09:31:33.918] run() for ‘MulticoreFuture’ ... done
[09:31:33.919] plan(): Setting new future strategy stack:
[09:31:33.919] List of future strategies:
[09:31:33.919] 1. sequential:
[09:31:33.919]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.919]    - tweaked: FALSE
[09:31:33.919]    - call: NULL
[09:31:33.920] plan(): nbrOfWorkers() = 1
[09:31:33.922] plan(): Setting new future strategy stack:
[09:31:33.922] List of future strategies:
[09:31:33.922] 1. multicore:
[09:31:33.922]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.922]    - tweaked: FALSE
[09:31:33.922]    - call: plan(strategy)
[09:31:33.927] plan(): nbrOfWorkers() = 2
[09:31:33.928] Future #1
[09:31:33.928] result() for MulticoreFuture ...
[09:31:33.929] result() for MulticoreFuture ...
[09:31:33.929] result() for MulticoreFuture ... done
[09:31:33.929] result() for MulticoreFuture ... done
[09:31:33.930] result() for MulticoreFuture ...
[09:31:33.930] result() for MulticoreFuture ... done
[09:31:33.930] A MulticoreFuture was resolved
[09:31:33.930]  length: 0 (resolved future 1)
[09:31:33.930] resolve() on list ... DONE
[09:31:33.930] - globals: [1] ‘a’
[09:31:33.930] Resolving futures part of globals (recursively) ... DONE
[09:31:33.932] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[09:31:33.932] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[09:31:33.932] - globals: [1] ‘a’
[09:31:33.933] - packages: [1] ‘future’
[09:31:33.933] getGlobalsAndPackages() ... DONE
[09:31:33.933] run() for ‘Future’ ...
[09:31:33.933] - state: ‘created’
[09:31:33.933] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.938]   - Field: ‘label’
[09:31:33.938]   - Field: ‘local’
[09:31:33.938]   - Field: ‘owner’
[09:31:33.938]   - Field: ‘envir’
[09:31:33.938]   - Field: ‘workers’
[09:31:33.938]   - Field: ‘packages’
[09:31:33.938]   - Field: ‘gc’
[09:31:33.938]   - Field: ‘job’
[09:31:33.939]   - Field: ‘conditions’
[09:31:33.939]   - Field: ‘expr’
[09:31:33.939]   - Field: ‘uuid’
[09:31:33.939]   - Field: ‘seed’
[09:31:33.939]   - Field: ‘version’
[09:31:33.939]   - Field: ‘result’
[09:31:33.939]   - Field: ‘asynchronous’
[09:31:33.939]   - Field: ‘calls’
[09:31:33.939]   - Field: ‘globals’
[09:31:33.940]   - Field: ‘stdout’
[09:31:33.940]   - Field: ‘earlySignal’
[09:31:33.940]   - Field: ‘lazy’
[09:31:33.940]   - Field: ‘state’
[09:31:33.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.940] - Launch lazy future ...
[09:31:33.941] Packages needed by the future expression (n = 1): ‘future’
[09:31:33.941] Packages needed by future strategies (n = 0): <none>
[09:31:33.941] {
[09:31:33.941]     {
[09:31:33.941]         {
[09:31:33.941]             ...future.startTime <- base::Sys.time()
[09:31:33.941]             {
[09:31:33.941]                 {
[09:31:33.941]                   {
[09:31:33.941]                     {
[09:31:33.941]                       {
[09:31:33.941]                         base::local({
[09:31:33.941]                           has_future <- base::requireNamespace("future", 
[09:31:33.941]                             quietly = TRUE)
[09:31:33.941]                           if (has_future) {
[09:31:33.941]                             ns <- base::getNamespace("future")
[09:31:33.941]                             version <- ns[[".package"]][["version"]]
[09:31:33.941]                             if (is.null(version)) 
[09:31:33.941]                               version <- utils::packageVersion("future")
[09:31:33.941]                           }
[09:31:33.941]                           else {
[09:31:33.941]                             version <- NULL
[09:31:33.941]                           }
[09:31:33.941]                           if (!has_future || version < "1.8.0") {
[09:31:33.941]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.941]                               "", base::R.version$version.string), 
[09:31:33.941]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:33.941]                                 base::R.version$platform, 8 * 
[09:31:33.941]                                   base::.Machine$sizeof.pointer), 
[09:31:33.941]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.941]                                 "release", "version")], collapse = " "), 
[09:31:33.941]                               hostname = base::Sys.info()[["nodename"]])
[09:31:33.941]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.941]                               info)
[09:31:33.941]                             info <- base::paste(info, collapse = "; ")
[09:31:33.941]                             if (!has_future) {
[09:31:33.941]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.941]                                 info)
[09:31:33.941]                             }
[09:31:33.941]                             else {
[09:31:33.941]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.941]                                 info, version)
[09:31:33.941]                             }
[09:31:33.941]                             base::stop(msg)
[09:31:33.941]                           }
[09:31:33.941]                         })
[09:31:33.941]                       }
[09:31:33.941]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.941]                       base::options(mc.cores = 1L)
[09:31:33.941]                     }
[09:31:33.941]                     base::local({
[09:31:33.941]                       for (pkg in "future") {
[09:31:33.941]                         base::loadNamespace(pkg)
[09:31:33.941]                         base::library(pkg, character.only = TRUE)
[09:31:33.941]                       }
[09:31:33.941]                     })
[09:31:33.941]                   }
[09:31:33.941]                   ...future.strategy.old <- future::plan("list")
[09:31:33.941]                   options(future.plan = NULL)
[09:31:33.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.941]                 }
[09:31:33.941]                 ...future.workdir <- getwd()
[09:31:33.941]             }
[09:31:33.941]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.941]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.941]         }
[09:31:33.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.941]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.941]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.941]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.941]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.941]             base::names(...future.oldOptions))
[09:31:33.941]     }
[09:31:33.941]     if (FALSE) {
[09:31:33.941]     }
[09:31:33.941]     else {
[09:31:33.941]         if (TRUE) {
[09:31:33.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.941]                 open = "w")
[09:31:33.941]         }
[09:31:33.941]         else {
[09:31:33.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.941]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.941]         }
[09:31:33.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.941]             base::sink(type = "output", split = FALSE)
[09:31:33.941]             base::close(...future.stdout)
[09:31:33.941]         }, add = TRUE)
[09:31:33.941]     }
[09:31:33.941]     ...future.frame <- base::sys.nframe()
[09:31:33.941]     ...future.conditions <- base::list()
[09:31:33.941]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.941]     if (FALSE) {
[09:31:33.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.941]     }
[09:31:33.941]     ...future.result <- base::tryCatch({
[09:31:33.941]         base::withCallingHandlers({
[09:31:33.941]             ...future.value <- base::withVisible(base::local({
[09:31:33.941]                 withCallingHandlers({
[09:31:33.941]                   value(a) + 1
[09:31:33.941]                 }, immediateCondition = function(cond) {
[09:31:33.941]                   save_rds <- function (object, pathname, ...) 
[09:31:33.941]                   {
[09:31:33.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.941]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.941]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.941]                         fi_tmp[["mtime"]])
[09:31:33.941]                     }
[09:31:33.941]                     tryCatch({
[09:31:33.941]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.941]                     }, error = function(ex) {
[09:31:33.941]                       msg <- conditionMessage(ex)
[09:31:33.941]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.941]                         fi_tmp[["mtime"]], msg)
[09:31:33.941]                       ex$message <- msg
[09:31:33.941]                       stop(ex)
[09:31:33.941]                     })
[09:31:33.941]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.941]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.941]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.941]                       fi <- file.info(pathname)
[09:31:33.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.941]                         fi[["size"]], fi[["mtime"]])
[09:31:33.941]                       stop(msg)
[09:31:33.941]                     }
[09:31:33.941]                     invisible(pathname)
[09:31:33.941]                   }
[09:31:33.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.941]                     rootPath = tempdir()) 
[09:31:33.941]                   {
[09:31:33.941]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.941]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.941]                       tmpdir = path, fileext = ".rds")
[09:31:33.941]                     save_rds(obj, file)
[09:31:33.941]                   }
[09:31:33.941]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.941]                   {
[09:31:33.941]                     inherits <- base::inherits
[09:31:33.941]                     invokeRestart <- base::invokeRestart
[09:31:33.941]                     is.null <- base::is.null
[09:31:33.941]                     muffled <- FALSE
[09:31:33.941]                     if (inherits(cond, "message")) {
[09:31:33.941]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.941]                       if (muffled) 
[09:31:33.941]                         invokeRestart("muffleMessage")
[09:31:33.941]                     }
[09:31:33.941]                     else if (inherits(cond, "warning")) {
[09:31:33.941]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.941]                       if (muffled) 
[09:31:33.941]                         invokeRestart("muffleWarning")
[09:31:33.941]                     }
[09:31:33.941]                     else if (inherits(cond, "condition")) {
[09:31:33.941]                       if (!is.null(pattern)) {
[09:31:33.941]                         computeRestarts <- base::computeRestarts
[09:31:33.941]                         grepl <- base::grepl
[09:31:33.941]                         restarts <- computeRestarts(cond)
[09:31:33.941]                         for (restart in restarts) {
[09:31:33.941]                           name <- restart$name
[09:31:33.941]                           if (is.null(name)) 
[09:31:33.941]                             next
[09:31:33.941]                           if (!grepl(pattern, name)) 
[09:31:33.941]                             next
[09:31:33.941]                           invokeRestart(restart)
[09:31:33.941]                           muffled <- TRUE
[09:31:33.941]                           break
[09:31:33.941]                         }
[09:31:33.941]                       }
[09:31:33.941]                     }
[09:31:33.941]                     invisible(muffled)
[09:31:33.941]                   }
[09:31:33.941]                   muffleCondition(cond)
[09:31:33.941]                 })
[09:31:33.941]             }))
[09:31:33.941]             future::FutureResult(value = ...future.value$value, 
[09:31:33.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.941]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.941]                     ...future.globalenv.names))
[09:31:33.941]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.941]         }, condition = base::local({
[09:31:33.941]             c <- base::c
[09:31:33.941]             inherits <- base::inherits
[09:31:33.941]             invokeRestart <- base::invokeRestart
[09:31:33.941]             length <- base::length
[09:31:33.941]             list <- base::list
[09:31:33.941]             seq.int <- base::seq.int
[09:31:33.941]             signalCondition <- base::signalCondition
[09:31:33.941]             sys.calls <- base::sys.calls
[09:31:33.941]             `[[` <- base::`[[`
[09:31:33.941]             `+` <- base::`+`
[09:31:33.941]             `<<-` <- base::`<<-`
[09:31:33.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.941]                   3L)]
[09:31:33.941]             }
[09:31:33.941]             function(cond) {
[09:31:33.941]                 is_error <- inherits(cond, "error")
[09:31:33.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.941]                   NULL)
[09:31:33.941]                 if (is_error) {
[09:31:33.941]                   sessionInformation <- function() {
[09:31:33.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.941]                       search = base::search(), system = base::Sys.info())
[09:31:33.941]                   }
[09:31:33.941]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.941]                     cond$call), session = sessionInformation(), 
[09:31:33.941]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.941]                   signalCondition(cond)
[09:31:33.941]                 }
[09:31:33.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.941]                 "immediateCondition"))) {
[09:31:33.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.941]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.941]                   if (TRUE && !signal) {
[09:31:33.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.941]                     {
[09:31:33.941]                       inherits <- base::inherits
[09:31:33.941]                       invokeRestart <- base::invokeRestart
[09:31:33.941]                       is.null <- base::is.null
[09:31:33.941]                       muffled <- FALSE
[09:31:33.941]                       if (inherits(cond, "message")) {
[09:31:33.941]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.941]                         if (muffled) 
[09:31:33.941]                           invokeRestart("muffleMessage")
[09:31:33.941]                       }
[09:31:33.941]                       else if (inherits(cond, "warning")) {
[09:31:33.941]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.941]                         if (muffled) 
[09:31:33.941]                           invokeRestart("muffleWarning")
[09:31:33.941]                       }
[09:31:33.941]                       else if (inherits(cond, "condition")) {
[09:31:33.941]                         if (!is.null(pattern)) {
[09:31:33.941]                           computeRestarts <- base::computeRestarts
[09:31:33.941]                           grepl <- base::grepl
[09:31:33.941]                           restarts <- computeRestarts(cond)
[09:31:33.941]                           for (restart in restarts) {
[09:31:33.941]                             name <- restart$name
[09:31:33.941]                             if (is.null(name)) 
[09:31:33.941]                               next
[09:31:33.941]                             if (!grepl(pattern, name)) 
[09:31:33.941]                               next
[09:31:33.941]                             invokeRestart(restart)
[09:31:33.941]                             muffled <- TRUE
[09:31:33.941]                             break
[09:31:33.941]                           }
[09:31:33.941]                         }
[09:31:33.941]                       }
[09:31:33.941]                       invisible(muffled)
[09:31:33.941]                     }
[09:31:33.941]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.941]                   }
[09:31:33.941]                 }
[09:31:33.941]                 else {
[09:31:33.941]                   if (TRUE) {
[09:31:33.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.941]                     {
[09:31:33.941]                       inherits <- base::inherits
[09:31:33.941]                       invokeRestart <- base::invokeRestart
[09:31:33.941]                       is.null <- base::is.null
[09:31:33.941]                       muffled <- FALSE
[09:31:33.941]                       if (inherits(cond, "message")) {
[09:31:33.941]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.941]                         if (muffled) 
[09:31:33.941]                           invokeRestart("muffleMessage")
[09:31:33.941]                       }
[09:31:33.941]                       else if (inherits(cond, "warning")) {
[09:31:33.941]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.941]                         if (muffled) 
[09:31:33.941]                           invokeRestart("muffleWarning")
[09:31:33.941]                       }
[09:31:33.941]                       else if (inherits(cond, "condition")) {
[09:31:33.941]                         if (!is.null(pattern)) {
[09:31:33.941]                           computeRestarts <- base::computeRestarts
[09:31:33.941]                           grepl <- base::grepl
[09:31:33.941]                           restarts <- computeRestarts(cond)
[09:31:33.941]                           for (restart in restarts) {
[09:31:33.941]                             name <- restart$name
[09:31:33.941]                             if (is.null(name)) 
[09:31:33.941]                               next
[09:31:33.941]                             if (!grepl(pattern, name)) 
[09:31:33.941]                               next
[09:31:33.941]                             invokeRestart(restart)
[09:31:33.941]                             muffled <- TRUE
[09:31:33.941]                             break
[09:31:33.941]                           }
[09:31:33.941]                         }
[09:31:33.941]                       }
[09:31:33.941]                       invisible(muffled)
[09:31:33.941]                     }
[09:31:33.941]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.941]                   }
[09:31:33.941]                 }
[09:31:33.941]             }
[09:31:33.941]         }))
[09:31:33.941]     }, error = function(ex) {
[09:31:33.941]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.941]                 ...future.rng), started = ...future.startTime, 
[09:31:33.941]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.941]             version = "1.8"), class = "FutureResult")
[09:31:33.941]     }, finally = {
[09:31:33.941]         if (!identical(...future.workdir, getwd())) 
[09:31:33.941]             setwd(...future.workdir)
[09:31:33.941]         {
[09:31:33.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.941]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.941]             }
[09:31:33.941]             base::options(...future.oldOptions)
[09:31:33.941]             if (.Platform$OS.type == "windows") {
[09:31:33.941]                 old_names <- names(...future.oldEnvVars)
[09:31:33.941]                 envs <- base::Sys.getenv()
[09:31:33.941]                 names <- names(envs)
[09:31:33.941]                 common <- intersect(names, old_names)
[09:31:33.941]                 added <- setdiff(names, old_names)
[09:31:33.941]                 removed <- setdiff(old_names, names)
[09:31:33.941]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.941]                   envs[common]]
[09:31:33.941]                 NAMES <- toupper(changed)
[09:31:33.941]                 args <- list()
[09:31:33.941]                 for (kk in seq_along(NAMES)) {
[09:31:33.941]                   name <- changed[[kk]]
[09:31:33.941]                   NAME <- NAMES[[kk]]
[09:31:33.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.941]                     next
[09:31:33.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.941]                 }
[09:31:33.941]                 NAMES <- toupper(added)
[09:31:33.941]                 for (kk in seq_along(NAMES)) {
[09:31:33.941]                   name <- added[[kk]]
[09:31:33.941]                   NAME <- NAMES[[kk]]
[09:31:33.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.941]                     next
[09:31:33.941]                   args[[name]] <- ""
[09:31:33.941]                 }
[09:31:33.941]                 NAMES <- toupper(removed)
[09:31:33.941]                 for (kk in seq_along(NAMES)) {
[09:31:33.941]                   name <- removed[[kk]]
[09:31:33.941]                   NAME <- NAMES[[kk]]
[09:31:33.941]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.941]                     next
[09:31:33.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.941]                 }
[09:31:33.941]                 if (length(args) > 0) 
[09:31:33.941]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.941]             }
[09:31:33.941]             else {
[09:31:33.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.941]             }
[09:31:33.941]             {
[09:31:33.941]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.941]                   0L) {
[09:31:33.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.941]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.941]                   base::options(opts)
[09:31:33.941]                 }
[09:31:33.941]                 {
[09:31:33.941]                   {
[09:31:33.941]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.941]                     NULL
[09:31:33.941]                   }
[09:31:33.941]                   options(future.plan = NULL)
[09:31:33.941]                   if (is.na(NA_character_)) 
[09:31:33.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.941]                     .init = FALSE)
[09:31:33.941]                 }
[09:31:33.941]             }
[09:31:33.941]         }
[09:31:33.941]     })
[09:31:33.941]     if (TRUE) {
[09:31:33.941]         base::sink(type = "output", split = FALSE)
[09:31:33.941]         if (TRUE) {
[09:31:33.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.941]         }
[09:31:33.941]         else {
[09:31:33.941]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.941]         }
[09:31:33.941]         base::close(...future.stdout)
[09:31:33.941]         ...future.stdout <- NULL
[09:31:33.941]     }
[09:31:33.941]     ...future.result$conditions <- ...future.conditions
[09:31:33.941]     ...future.result$finished <- base::Sys.time()
[09:31:33.941]     ...future.result
[09:31:33.941] }
[09:31:33.944] assign_globals() ...
[09:31:33.944] List of 1
[09:31:33.944]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e21ac8e538> 
[09:31:33.944]  - attr(*, "where")=List of 1
[09:31:33.944]   ..$ a:<environment: R_EmptyEnv> 
[09:31:33.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:33.944]  - attr(*, "resolved")= logi TRUE
[09:31:33.944]  - attr(*, "total_size")= num 10984
[09:31:33.944]  - attr(*, "already-done")= logi TRUE
[09:31:33.950] - copied ‘a’ to environment
[09:31:33.950] assign_globals() ... done
[09:31:33.950] requestCore(): workers = 2
[09:31:33.952] MulticoreFuture started
[09:31:33.952] - Launch lazy future ... done
[09:31:33.953] run() for ‘MulticoreFuture’ ... done
[09:31:33.953] result() for MulticoreFuture ...
[09:31:33.953] plan(): Setting new future strategy stack:
[09:31:33.954] List of future strategies:
[09:31:33.954] 1. sequential:
[09:31:33.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.954]    - tweaked: FALSE
[09:31:33.954]    - call: NULL
[09:31:33.955] plan(): nbrOfWorkers() = 1
[09:31:33.959] plan(): Setting new future strategy stack:
[09:31:33.959] List of future strategies:
[09:31:33.959] 1. multicore:
[09:31:33.959]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.959]    - tweaked: FALSE
[09:31:33.959]    - call: plan(strategy)
[09:31:33.964] plan(): nbrOfWorkers() = 2
[09:31:33.965] result() for MulticoreFuture ...
[09:31:33.965] result() for MulticoreFuture ... done
[09:31:33.965] signalConditions() ...
[09:31:33.965]  - include = ‘immediateCondition’
[09:31:33.966]  - exclude = 
[09:31:33.966]  - resignal = FALSE
[09:31:33.966]  - Number of conditions: 4
[09:31:33.966] signalConditions() ... done
[09:31:33.966] result() for MulticoreFuture ... done
[09:31:33.966] result() for MulticoreFuture ...
[09:31:33.966] result() for MulticoreFuture ... done
[09:31:33.967] signalConditions() ...
[09:31:33.967]  - include = ‘immediateCondition’
[09:31:33.967]  - exclude = 
[09:31:33.967]  - resignal = FALSE
[09:31:33.967]  - Number of conditions: 4
[09:31:33.967] signalConditions() ... done
[09:31:33.967] Future state: ‘finished’
[09:31:33.967] result() for MulticoreFuture ...
[09:31:33.968] result() for MulticoreFuture ... done
[09:31:33.968] signalConditions() ...
[09:31:33.968]  - include = ‘condition’
[09:31:33.968]  - exclude = ‘immediateCondition’
[09:31:33.968]  - resignal = TRUE
[09:31:33.968]  - Number of conditions: 4
[09:31:33.968]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.956] result() for MulticoreFuture ...
[09:31:33.969]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.957] result() for MulticoreFuture ... done
[09:31:33.969]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.957] result() for MulticoreFuture ...
[09:31:33.969]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.958] result() for MulticoreFuture ... done
[09:31:33.969] signalConditions() ... done
value(b) = 2
[09:31:33.969] result() for MulticoreFuture ...
[09:31:33.969] result() for MulticoreFuture ... done
[09:31:33.970] result() for MulticoreFuture ...
[09:31:33.970] result() for MulticoreFuture ... done
[09:31:33.970] signalConditions() ...
[09:31:33.970]  - include = ‘immediateCondition’
[09:31:33.970]  - exclude = 
[09:31:33.970]  - resignal = FALSE
[09:31:33.970]  - Number of conditions: 4
[09:31:33.970] signalConditions() ... done
[09:31:33.970] Future state: ‘finished’
[09:31:33.971] result() for MulticoreFuture ...
[09:31:33.971] result() for MulticoreFuture ... done
[09:31:33.971] signalConditions() ...
[09:31:33.971]  - include = ‘condition’
[09:31:33.971]  - exclude = ‘immediateCondition’
[09:31:33.971]  - resignal = TRUE
[09:31:33.971]  - Number of conditions: 4
[09:31:33.971]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.956] result() for MulticoreFuture ...
[09:31:33.971]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.957] result() for MulticoreFuture ... done
[09:31:33.972]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.957] result() for MulticoreFuture ...
[09:31:33.972]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:33.958] result() for MulticoreFuture ... done
[09:31:33.972] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.972] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.973] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.973] 
[09:31:33.973] Searching for globals ... DONE
[09:31:33.973] - globals: [0] <none>
[09:31:33.974] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:33.974] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:33.974] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:33.975] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:33.975] Searching for globals ... DONE
[09:31:33.976] Resolving globals: TRUE
[09:31:33.976] Resolving any globals that are futures ...
[09:31:33.976] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:33.976] Resolving any globals that are futures ... DONE
[09:31:33.976] Resolving futures part of globals (recursively) ...
[09:31:33.977] resolve() on list ...
[09:31:33.977]  recursive: 99
[09:31:33.977]  length: 1
[09:31:33.977]  elements: ‘a’
[09:31:33.977] run() for ‘Future’ ...
[09:31:33.977] - state: ‘created’
[09:31:33.977] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:33.981] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:33.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:33.982]   - Field: ‘label’
[09:31:33.982]   - Field: ‘local’
[09:31:33.982]   - Field: ‘owner’
[09:31:33.982]   - Field: ‘envir’
[09:31:33.982]   - Field: ‘workers’
[09:31:33.982]   - Field: ‘packages’
[09:31:33.982]   - Field: ‘gc’
[09:31:33.982]   - Field: ‘job’
[09:31:33.983]   - Field: ‘conditions’
[09:31:33.983]   - Field: ‘expr’
[09:31:33.983]   - Field: ‘uuid’
[09:31:33.983]   - Field: ‘seed’
[09:31:33.983]   - Field: ‘version’
[09:31:33.983]   - Field: ‘result’
[09:31:33.983]   - Field: ‘asynchronous’
[09:31:33.983]   - Field: ‘calls’
[09:31:33.983]   - Field: ‘globals’
[09:31:33.983]   - Field: ‘stdout’
[09:31:33.984]   - Field: ‘earlySignal’
[09:31:33.984]   - Field: ‘lazy’
[09:31:33.984]   - Field: ‘state’
[09:31:33.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:33.984] - Launch lazy future ...
[09:31:33.984] Packages needed by the future expression (n = 0): <none>
[09:31:33.985] Packages needed by future strategies (n = 0): <none>
[09:31:33.985] {
[09:31:33.985]     {
[09:31:33.985]         {
[09:31:33.985]             ...future.startTime <- base::Sys.time()
[09:31:33.985]             {
[09:31:33.985]                 {
[09:31:33.985]                   {
[09:31:33.985]                     {
[09:31:33.985]                       base::local({
[09:31:33.985]                         has_future <- base::requireNamespace("future", 
[09:31:33.985]                           quietly = TRUE)
[09:31:33.985]                         if (has_future) {
[09:31:33.985]                           ns <- base::getNamespace("future")
[09:31:33.985]                           version <- ns[[".package"]][["version"]]
[09:31:33.985]                           if (is.null(version)) 
[09:31:33.985]                             version <- utils::packageVersion("future")
[09:31:33.985]                         }
[09:31:33.985]                         else {
[09:31:33.985]                           version <- NULL
[09:31:33.985]                         }
[09:31:33.985]                         if (!has_future || version < "1.8.0") {
[09:31:33.985]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:33.985]                             "", base::R.version$version.string), 
[09:31:33.985]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:33.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:33.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:33.985]                               "release", "version")], collapse = " "), 
[09:31:33.985]                             hostname = base::Sys.info()[["nodename"]])
[09:31:33.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:33.985]                             info)
[09:31:33.985]                           info <- base::paste(info, collapse = "; ")
[09:31:33.985]                           if (!has_future) {
[09:31:33.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:33.985]                               info)
[09:31:33.985]                           }
[09:31:33.985]                           else {
[09:31:33.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:33.985]                               info, version)
[09:31:33.985]                           }
[09:31:33.985]                           base::stop(msg)
[09:31:33.985]                         }
[09:31:33.985]                       })
[09:31:33.985]                     }
[09:31:33.985]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:33.985]                     base::options(mc.cores = 1L)
[09:31:33.985]                   }
[09:31:33.985]                   ...future.strategy.old <- future::plan("list")
[09:31:33.985]                   options(future.plan = NULL)
[09:31:33.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:33.985]                 }
[09:31:33.985]                 ...future.workdir <- getwd()
[09:31:33.985]             }
[09:31:33.985]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:33.985]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:33.985]         }
[09:31:33.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:33.985]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:33.985]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:33.985]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:33.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:33.985]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:33.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:33.985]             base::names(...future.oldOptions))
[09:31:33.985]     }
[09:31:33.985]     if (FALSE) {
[09:31:33.985]     }
[09:31:33.985]     else {
[09:31:33.985]         if (TRUE) {
[09:31:33.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:33.985]                 open = "w")
[09:31:33.985]         }
[09:31:33.985]         else {
[09:31:33.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:33.985]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:33.985]         }
[09:31:33.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:33.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:33.985]             base::sink(type = "output", split = FALSE)
[09:31:33.985]             base::close(...future.stdout)
[09:31:33.985]         }, add = TRUE)
[09:31:33.985]     }
[09:31:33.985]     ...future.frame <- base::sys.nframe()
[09:31:33.985]     ...future.conditions <- base::list()
[09:31:33.985]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:33.985]     if (FALSE) {
[09:31:33.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:33.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:33.985]     }
[09:31:33.985]     ...future.result <- base::tryCatch({
[09:31:33.985]         base::withCallingHandlers({
[09:31:33.985]             ...future.value <- base::withVisible(base::local({
[09:31:33.985]                 withCallingHandlers({
[09:31:33.985]                   1
[09:31:33.985]                 }, immediateCondition = function(cond) {
[09:31:33.985]                   save_rds <- function (object, pathname, ...) 
[09:31:33.985]                   {
[09:31:33.985]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:33.985]                     if (file_test("-f", pathname_tmp)) {
[09:31:33.985]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.985]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:33.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.985]                         fi_tmp[["mtime"]])
[09:31:33.985]                     }
[09:31:33.985]                     tryCatch({
[09:31:33.985]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:33.985]                     }, error = function(ex) {
[09:31:33.985]                       msg <- conditionMessage(ex)
[09:31:33.985]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.985]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:33.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.985]                         fi_tmp[["mtime"]], msg)
[09:31:33.985]                       ex$message <- msg
[09:31:33.985]                       stop(ex)
[09:31:33.985]                     })
[09:31:33.985]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:33.985]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:33.985]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:33.985]                       fi_tmp <- file.info(pathname_tmp)
[09:31:33.985]                       fi <- file.info(pathname)
[09:31:33.985]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:33.985]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:33.985]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:33.985]                         fi[["size"]], fi[["mtime"]])
[09:31:33.985]                       stop(msg)
[09:31:33.985]                     }
[09:31:33.985]                     invisible(pathname)
[09:31:33.985]                   }
[09:31:33.985]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:33.985]                     rootPath = tempdir()) 
[09:31:33.985]                   {
[09:31:33.985]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:33.985]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:33.985]                       tmpdir = path, fileext = ".rds")
[09:31:33.985]                     save_rds(obj, file)
[09:31:33.985]                   }
[09:31:33.985]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:33.985]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.985]                   {
[09:31:33.985]                     inherits <- base::inherits
[09:31:33.985]                     invokeRestart <- base::invokeRestart
[09:31:33.985]                     is.null <- base::is.null
[09:31:33.985]                     muffled <- FALSE
[09:31:33.985]                     if (inherits(cond, "message")) {
[09:31:33.985]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:33.985]                       if (muffled) 
[09:31:33.985]                         invokeRestart("muffleMessage")
[09:31:33.985]                     }
[09:31:33.985]                     else if (inherits(cond, "warning")) {
[09:31:33.985]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:33.985]                       if (muffled) 
[09:31:33.985]                         invokeRestart("muffleWarning")
[09:31:33.985]                     }
[09:31:33.985]                     else if (inherits(cond, "condition")) {
[09:31:33.985]                       if (!is.null(pattern)) {
[09:31:33.985]                         computeRestarts <- base::computeRestarts
[09:31:33.985]                         grepl <- base::grepl
[09:31:33.985]                         restarts <- computeRestarts(cond)
[09:31:33.985]                         for (restart in restarts) {
[09:31:33.985]                           name <- restart$name
[09:31:33.985]                           if (is.null(name)) 
[09:31:33.985]                             next
[09:31:33.985]                           if (!grepl(pattern, name)) 
[09:31:33.985]                             next
[09:31:33.985]                           invokeRestart(restart)
[09:31:33.985]                           muffled <- TRUE
[09:31:33.985]                           break
[09:31:33.985]                         }
[09:31:33.985]                       }
[09:31:33.985]                     }
[09:31:33.985]                     invisible(muffled)
[09:31:33.985]                   }
[09:31:33.985]                   muffleCondition(cond)
[09:31:33.985]                 })
[09:31:33.985]             }))
[09:31:33.985]             future::FutureResult(value = ...future.value$value, 
[09:31:33.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.985]                   ...future.rng), globalenv = if (FALSE) 
[09:31:33.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:33.985]                     ...future.globalenv.names))
[09:31:33.985]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:33.985]         }, condition = base::local({
[09:31:33.985]             c <- base::c
[09:31:33.985]             inherits <- base::inherits
[09:31:33.985]             invokeRestart <- base::invokeRestart
[09:31:33.985]             length <- base::length
[09:31:33.985]             list <- base::list
[09:31:33.985]             seq.int <- base::seq.int
[09:31:33.985]             signalCondition <- base::signalCondition
[09:31:33.985]             sys.calls <- base::sys.calls
[09:31:33.985]             `[[` <- base::`[[`
[09:31:33.985]             `+` <- base::`+`
[09:31:33.985]             `<<-` <- base::`<<-`
[09:31:33.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:33.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:33.985]                   3L)]
[09:31:33.985]             }
[09:31:33.985]             function(cond) {
[09:31:33.985]                 is_error <- inherits(cond, "error")
[09:31:33.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:33.985]                   NULL)
[09:31:33.985]                 if (is_error) {
[09:31:33.985]                   sessionInformation <- function() {
[09:31:33.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:33.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:33.985]                       search = base::search(), system = base::Sys.info())
[09:31:33.985]                   }
[09:31:33.985]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:33.985]                     cond$call), session = sessionInformation(), 
[09:31:33.985]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:33.985]                   signalCondition(cond)
[09:31:33.985]                 }
[09:31:33.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:33.985]                 "immediateCondition"))) {
[09:31:33.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:33.985]                   ...future.conditions[[length(...future.conditions) + 
[09:31:33.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:33.985]                   if (TRUE && !signal) {
[09:31:33.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.985]                     {
[09:31:33.985]                       inherits <- base::inherits
[09:31:33.985]                       invokeRestart <- base::invokeRestart
[09:31:33.985]                       is.null <- base::is.null
[09:31:33.985]                       muffled <- FALSE
[09:31:33.985]                       if (inherits(cond, "message")) {
[09:31:33.985]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.985]                         if (muffled) 
[09:31:33.985]                           invokeRestart("muffleMessage")
[09:31:33.985]                       }
[09:31:33.985]                       else if (inherits(cond, "warning")) {
[09:31:33.985]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.985]                         if (muffled) 
[09:31:33.985]                           invokeRestart("muffleWarning")
[09:31:33.985]                       }
[09:31:33.985]                       else if (inherits(cond, "condition")) {
[09:31:33.985]                         if (!is.null(pattern)) {
[09:31:33.985]                           computeRestarts <- base::computeRestarts
[09:31:33.985]                           grepl <- base::grepl
[09:31:33.985]                           restarts <- computeRestarts(cond)
[09:31:33.985]                           for (restart in restarts) {
[09:31:33.985]                             name <- restart$name
[09:31:33.985]                             if (is.null(name)) 
[09:31:33.985]                               next
[09:31:33.985]                             if (!grepl(pattern, name)) 
[09:31:33.985]                               next
[09:31:33.985]                             invokeRestart(restart)
[09:31:33.985]                             muffled <- TRUE
[09:31:33.985]                             break
[09:31:33.985]                           }
[09:31:33.985]                         }
[09:31:33.985]                       }
[09:31:33.985]                       invisible(muffled)
[09:31:33.985]                     }
[09:31:33.985]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.985]                   }
[09:31:33.985]                 }
[09:31:33.985]                 else {
[09:31:33.985]                   if (TRUE) {
[09:31:33.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:33.985]                     {
[09:31:33.985]                       inherits <- base::inherits
[09:31:33.985]                       invokeRestart <- base::invokeRestart
[09:31:33.985]                       is.null <- base::is.null
[09:31:33.985]                       muffled <- FALSE
[09:31:33.985]                       if (inherits(cond, "message")) {
[09:31:33.985]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:33.985]                         if (muffled) 
[09:31:33.985]                           invokeRestart("muffleMessage")
[09:31:33.985]                       }
[09:31:33.985]                       else if (inherits(cond, "warning")) {
[09:31:33.985]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:33.985]                         if (muffled) 
[09:31:33.985]                           invokeRestart("muffleWarning")
[09:31:33.985]                       }
[09:31:33.985]                       else if (inherits(cond, "condition")) {
[09:31:33.985]                         if (!is.null(pattern)) {
[09:31:33.985]                           computeRestarts <- base::computeRestarts
[09:31:33.985]                           grepl <- base::grepl
[09:31:33.985]                           restarts <- computeRestarts(cond)
[09:31:33.985]                           for (restart in restarts) {
[09:31:33.985]                             name <- restart$name
[09:31:33.985]                             if (is.null(name)) 
[09:31:33.985]                               next
[09:31:33.985]                             if (!grepl(pattern, name)) 
[09:31:33.985]                               next
[09:31:33.985]                             invokeRestart(restart)
[09:31:33.985]                             muffled <- TRUE
[09:31:33.985]                             break
[09:31:33.985]                           }
[09:31:33.985]                         }
[09:31:33.985]                       }
[09:31:33.985]                       invisible(muffled)
[09:31:33.985]                     }
[09:31:33.985]                     muffleCondition(cond, pattern = "^muffle")
[09:31:33.985]                   }
[09:31:33.985]                 }
[09:31:33.985]             }
[09:31:33.985]         }))
[09:31:33.985]     }, error = function(ex) {
[09:31:33.985]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:33.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:33.985]                 ...future.rng), started = ...future.startTime, 
[09:31:33.985]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:33.985]             version = "1.8"), class = "FutureResult")
[09:31:33.985]     }, finally = {
[09:31:33.985]         if (!identical(...future.workdir, getwd())) 
[09:31:33.985]             setwd(...future.workdir)
[09:31:33.985]         {
[09:31:33.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:33.985]                 ...future.oldOptions$nwarnings <- NULL
[09:31:33.985]             }
[09:31:33.985]             base::options(...future.oldOptions)
[09:31:33.985]             if (.Platform$OS.type == "windows") {
[09:31:33.985]                 old_names <- names(...future.oldEnvVars)
[09:31:33.985]                 envs <- base::Sys.getenv()
[09:31:33.985]                 names <- names(envs)
[09:31:33.985]                 common <- intersect(names, old_names)
[09:31:33.985]                 added <- setdiff(names, old_names)
[09:31:33.985]                 removed <- setdiff(old_names, names)
[09:31:33.985]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:33.985]                   envs[common]]
[09:31:33.985]                 NAMES <- toupper(changed)
[09:31:33.985]                 args <- list()
[09:31:33.985]                 for (kk in seq_along(NAMES)) {
[09:31:33.985]                   name <- changed[[kk]]
[09:31:33.985]                   NAME <- NAMES[[kk]]
[09:31:33.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.985]                     next
[09:31:33.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.985]                 }
[09:31:33.985]                 NAMES <- toupper(added)
[09:31:33.985]                 for (kk in seq_along(NAMES)) {
[09:31:33.985]                   name <- added[[kk]]
[09:31:33.985]                   NAME <- NAMES[[kk]]
[09:31:33.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.985]                     next
[09:31:33.985]                   args[[name]] <- ""
[09:31:33.985]                 }
[09:31:33.985]                 NAMES <- toupper(removed)
[09:31:33.985]                 for (kk in seq_along(NAMES)) {
[09:31:33.985]                   name <- removed[[kk]]
[09:31:33.985]                   NAME <- NAMES[[kk]]
[09:31:33.985]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:33.985]                     next
[09:31:33.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:33.985]                 }
[09:31:33.985]                 if (length(args) > 0) 
[09:31:33.985]                   base::do.call(base::Sys.setenv, args = args)
[09:31:33.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:33.985]             }
[09:31:33.985]             else {
[09:31:33.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:33.985]             }
[09:31:33.985]             {
[09:31:33.985]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:33.985]                   0L) {
[09:31:33.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:33.985]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:33.985]                   base::options(opts)
[09:31:33.985]                 }
[09:31:33.985]                 {
[09:31:33.985]                   {
[09:31:33.985]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:33.985]                     NULL
[09:31:33.985]                   }
[09:31:33.985]                   options(future.plan = NULL)
[09:31:33.985]                   if (is.na(NA_character_)) 
[09:31:33.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:33.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:33.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:33.985]                     .init = FALSE)
[09:31:33.985]                 }
[09:31:33.985]             }
[09:31:33.985]         }
[09:31:33.985]     })
[09:31:33.985]     if (TRUE) {
[09:31:33.985]         base::sink(type = "output", split = FALSE)
[09:31:33.985]         if (TRUE) {
[09:31:33.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:33.985]         }
[09:31:33.985]         else {
[09:31:33.985]             ...future.result["stdout"] <- base::list(NULL)
[09:31:33.985]         }
[09:31:33.985]         base::close(...future.stdout)
[09:31:33.985]         ...future.stdout <- NULL
[09:31:33.985]     }
[09:31:33.985]     ...future.result$conditions <- ...future.conditions
[09:31:33.985]     ...future.result$finished <- base::Sys.time()
[09:31:33.985]     ...future.result
[09:31:33.985] }
[09:31:33.988] requestCore(): workers = 2
[09:31:33.989] MulticoreFuture started
[09:31:33.990] - Launch lazy future ... done
[09:31:33.990] run() for ‘MulticoreFuture’ ... done
[09:31:33.990] plan(): Setting new future strategy stack:
[09:31:33.990] List of future strategies:
[09:31:33.990] 1. sequential:
[09:31:33.990]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:33.990]    - tweaked: FALSE
[09:31:33.990]    - call: NULL
[09:31:33.992] plan(): nbrOfWorkers() = 1
[09:31:33.994] plan(): Setting new future strategy stack:
[09:31:33.994] List of future strategies:
[09:31:33.994] 1. multicore:
[09:31:33.994]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:33.994]    - tweaked: FALSE
[09:31:33.994]    - call: plan(strategy)
[09:31:34.005] plan(): nbrOfWorkers() = 2
[09:31:34.011] Future #1
[09:31:34.011] result() for MulticoreFuture ...
[09:31:34.012] result() for MulticoreFuture ...
[09:31:34.012] result() for MulticoreFuture ... done
[09:31:34.012] result() for MulticoreFuture ... done
[09:31:34.012] result() for MulticoreFuture ...
[09:31:34.013] result() for MulticoreFuture ... done
[09:31:34.013] A MulticoreFuture was resolved
[09:31:34.013]  length: 0 (resolved future 1)
[09:31:34.015] resolve() on list ... DONE
[09:31:34.016] - globals: [1] ‘a’
[09:31:34.016] Resolving futures part of globals (recursively) ... DONE
[09:31:34.018] The total size of the 1 globals is 10.73 KiB (10984 bytes)
[09:31:34.019] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.73 KiB of class ‘environment’)
[09:31:34.019] - globals: [1] ‘a’
[09:31:34.019] - packages: [1] ‘future’
[09:31:34.019] getGlobalsAndPackages() ... DONE
[09:31:34.020] run() for ‘Future’ ...
[09:31:34.020] - state: ‘created’
[09:31:34.020] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.024] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.024]   - Field: ‘label’
[09:31:34.024]   - Field: ‘local’
[09:31:34.024]   - Field: ‘owner’
[09:31:34.024]   - Field: ‘envir’
[09:31:34.025]   - Field: ‘workers’
[09:31:34.025]   - Field: ‘packages’
[09:31:34.025]   - Field: ‘gc’
[09:31:34.025]   - Field: ‘job’
[09:31:34.025]   - Field: ‘conditions’
[09:31:34.025]   - Field: ‘expr’
[09:31:34.025]   - Field: ‘uuid’
[09:31:34.025]   - Field: ‘seed’
[09:31:34.025]   - Field: ‘version’
[09:31:34.026]   - Field: ‘result’
[09:31:34.026]   - Field: ‘asynchronous’
[09:31:34.026]   - Field: ‘calls’
[09:31:34.026]   - Field: ‘globals’
[09:31:34.026]   - Field: ‘stdout’
[09:31:34.026]   - Field: ‘earlySignal’
[09:31:34.026]   - Field: ‘lazy’
[09:31:34.026]   - Field: ‘state’
[09:31:34.026] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.027] - Launch lazy future ...
[09:31:34.027] Packages needed by the future expression (n = 1): ‘future’
[09:31:34.027] Packages needed by future strategies (n = 0): <none>
[09:31:34.028] {
[09:31:34.028]     {
[09:31:34.028]         {
[09:31:34.028]             ...future.startTime <- base::Sys.time()
[09:31:34.028]             {
[09:31:34.028]                 {
[09:31:34.028]                   {
[09:31:34.028]                     {
[09:31:34.028]                       {
[09:31:34.028]                         base::local({
[09:31:34.028]                           has_future <- base::requireNamespace("future", 
[09:31:34.028]                             quietly = TRUE)
[09:31:34.028]                           if (has_future) {
[09:31:34.028]                             ns <- base::getNamespace("future")
[09:31:34.028]                             version <- ns[[".package"]][["version"]]
[09:31:34.028]                             if (is.null(version)) 
[09:31:34.028]                               version <- utils::packageVersion("future")
[09:31:34.028]                           }
[09:31:34.028]                           else {
[09:31:34.028]                             version <- NULL
[09:31:34.028]                           }
[09:31:34.028]                           if (!has_future || version < "1.8.0") {
[09:31:34.028]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.028]                               "", base::R.version$version.string), 
[09:31:34.028]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:34.028]                                 base::R.version$platform, 8 * 
[09:31:34.028]                                   base::.Machine$sizeof.pointer), 
[09:31:34.028]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.028]                                 "release", "version")], collapse = " "), 
[09:31:34.028]                               hostname = base::Sys.info()[["nodename"]])
[09:31:34.028]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.028]                               info)
[09:31:34.028]                             info <- base::paste(info, collapse = "; ")
[09:31:34.028]                             if (!has_future) {
[09:31:34.028]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.028]                                 info)
[09:31:34.028]                             }
[09:31:34.028]                             else {
[09:31:34.028]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.028]                                 info, version)
[09:31:34.028]                             }
[09:31:34.028]                             base::stop(msg)
[09:31:34.028]                           }
[09:31:34.028]                         })
[09:31:34.028]                       }
[09:31:34.028]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.028]                       base::options(mc.cores = 1L)
[09:31:34.028]                     }
[09:31:34.028]                     base::local({
[09:31:34.028]                       for (pkg in "future") {
[09:31:34.028]                         base::loadNamespace(pkg)
[09:31:34.028]                         base::library(pkg, character.only = TRUE)
[09:31:34.028]                       }
[09:31:34.028]                     })
[09:31:34.028]                   }
[09:31:34.028]                   ...future.strategy.old <- future::plan("list")
[09:31:34.028]                   options(future.plan = NULL)
[09:31:34.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.028]                 }
[09:31:34.028]                 ...future.workdir <- getwd()
[09:31:34.028]             }
[09:31:34.028]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.028]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.028]         }
[09:31:34.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.028]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:34.028]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.028]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.028]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.028]             base::names(...future.oldOptions))
[09:31:34.028]     }
[09:31:34.028]     if (FALSE) {
[09:31:34.028]     }
[09:31:34.028]     else {
[09:31:34.028]         if (TRUE) {
[09:31:34.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.028]                 open = "w")
[09:31:34.028]         }
[09:31:34.028]         else {
[09:31:34.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.028]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.028]         }
[09:31:34.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.028]             base::sink(type = "output", split = FALSE)
[09:31:34.028]             base::close(...future.stdout)
[09:31:34.028]         }, add = TRUE)
[09:31:34.028]     }
[09:31:34.028]     ...future.frame <- base::sys.nframe()
[09:31:34.028]     ...future.conditions <- base::list()
[09:31:34.028]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.028]     if (FALSE) {
[09:31:34.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.028]     }
[09:31:34.028]     ...future.result <- base::tryCatch({
[09:31:34.028]         base::withCallingHandlers({
[09:31:34.028]             ...future.value <- base::withVisible(base::local({
[09:31:34.028]                 withCallingHandlers({
[09:31:34.028]                   value(a) + 1
[09:31:34.028]                 }, immediateCondition = function(cond) {
[09:31:34.028]                   save_rds <- function (object, pathname, ...) 
[09:31:34.028]                   {
[09:31:34.028]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.028]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.028]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.028]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.028]                         fi_tmp[["mtime"]])
[09:31:34.028]                     }
[09:31:34.028]                     tryCatch({
[09:31:34.028]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.028]                     }, error = function(ex) {
[09:31:34.028]                       msg <- conditionMessage(ex)
[09:31:34.028]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.028]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.028]                         fi_tmp[["mtime"]], msg)
[09:31:34.028]                       ex$message <- msg
[09:31:34.028]                       stop(ex)
[09:31:34.028]                     })
[09:31:34.028]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.028]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.028]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.028]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.028]                       fi <- file.info(pathname)
[09:31:34.028]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.028]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.028]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.028]                         fi[["size"]], fi[["mtime"]])
[09:31:34.028]                       stop(msg)
[09:31:34.028]                     }
[09:31:34.028]                     invisible(pathname)
[09:31:34.028]                   }
[09:31:34.028]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.028]                     rootPath = tempdir()) 
[09:31:34.028]                   {
[09:31:34.028]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.028]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.028]                       tmpdir = path, fileext = ".rds")
[09:31:34.028]                     save_rds(obj, file)
[09:31:34.028]                   }
[09:31:34.028]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.028]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.028]                   {
[09:31:34.028]                     inherits <- base::inherits
[09:31:34.028]                     invokeRestart <- base::invokeRestart
[09:31:34.028]                     is.null <- base::is.null
[09:31:34.028]                     muffled <- FALSE
[09:31:34.028]                     if (inherits(cond, "message")) {
[09:31:34.028]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.028]                       if (muffled) 
[09:31:34.028]                         invokeRestart("muffleMessage")
[09:31:34.028]                     }
[09:31:34.028]                     else if (inherits(cond, "warning")) {
[09:31:34.028]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.028]                       if (muffled) 
[09:31:34.028]                         invokeRestart("muffleWarning")
[09:31:34.028]                     }
[09:31:34.028]                     else if (inherits(cond, "condition")) {
[09:31:34.028]                       if (!is.null(pattern)) {
[09:31:34.028]                         computeRestarts <- base::computeRestarts
[09:31:34.028]                         grepl <- base::grepl
[09:31:34.028]                         restarts <- computeRestarts(cond)
[09:31:34.028]                         for (restart in restarts) {
[09:31:34.028]                           name <- restart$name
[09:31:34.028]                           if (is.null(name)) 
[09:31:34.028]                             next
[09:31:34.028]                           if (!grepl(pattern, name)) 
[09:31:34.028]                             next
[09:31:34.028]                           invokeRestart(restart)
[09:31:34.028]                           muffled <- TRUE
[09:31:34.028]                           break
[09:31:34.028]                         }
[09:31:34.028]                       }
[09:31:34.028]                     }
[09:31:34.028]                     invisible(muffled)
[09:31:34.028]                   }
[09:31:34.028]                   muffleCondition(cond)
[09:31:34.028]                 })
[09:31:34.028]             }))
[09:31:34.028]             future::FutureResult(value = ...future.value$value, 
[09:31:34.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.028]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.028]                     ...future.globalenv.names))
[09:31:34.028]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.028]         }, condition = base::local({
[09:31:34.028]             c <- base::c
[09:31:34.028]             inherits <- base::inherits
[09:31:34.028]             invokeRestart <- base::invokeRestart
[09:31:34.028]             length <- base::length
[09:31:34.028]             list <- base::list
[09:31:34.028]             seq.int <- base::seq.int
[09:31:34.028]             signalCondition <- base::signalCondition
[09:31:34.028]             sys.calls <- base::sys.calls
[09:31:34.028]             `[[` <- base::`[[`
[09:31:34.028]             `+` <- base::`+`
[09:31:34.028]             `<<-` <- base::`<<-`
[09:31:34.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.028]                   3L)]
[09:31:34.028]             }
[09:31:34.028]             function(cond) {
[09:31:34.028]                 is_error <- inherits(cond, "error")
[09:31:34.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.028]                   NULL)
[09:31:34.028]                 if (is_error) {
[09:31:34.028]                   sessionInformation <- function() {
[09:31:34.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.028]                       search = base::search(), system = base::Sys.info())
[09:31:34.028]                   }
[09:31:34.028]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.028]                     cond$call), session = sessionInformation(), 
[09:31:34.028]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.028]                   signalCondition(cond)
[09:31:34.028]                 }
[09:31:34.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.028]                 "immediateCondition"))) {
[09:31:34.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.028]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.028]                   if (TRUE && !signal) {
[09:31:34.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.028]                     {
[09:31:34.028]                       inherits <- base::inherits
[09:31:34.028]                       invokeRestart <- base::invokeRestart
[09:31:34.028]                       is.null <- base::is.null
[09:31:34.028]                       muffled <- FALSE
[09:31:34.028]                       if (inherits(cond, "message")) {
[09:31:34.028]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.028]                         if (muffled) 
[09:31:34.028]                           invokeRestart("muffleMessage")
[09:31:34.028]                       }
[09:31:34.028]                       else if (inherits(cond, "warning")) {
[09:31:34.028]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.028]                         if (muffled) 
[09:31:34.028]                           invokeRestart("muffleWarning")
[09:31:34.028]                       }
[09:31:34.028]                       else if (inherits(cond, "condition")) {
[09:31:34.028]                         if (!is.null(pattern)) {
[09:31:34.028]                           computeRestarts <- base::computeRestarts
[09:31:34.028]                           grepl <- base::grepl
[09:31:34.028]                           restarts <- computeRestarts(cond)
[09:31:34.028]                           for (restart in restarts) {
[09:31:34.028]                             name <- restart$name
[09:31:34.028]                             if (is.null(name)) 
[09:31:34.028]                               next
[09:31:34.028]                             if (!grepl(pattern, name)) 
[09:31:34.028]                               next
[09:31:34.028]                             invokeRestart(restart)
[09:31:34.028]                             muffled <- TRUE
[09:31:34.028]                             break
[09:31:34.028]                           }
[09:31:34.028]                         }
[09:31:34.028]                       }
[09:31:34.028]                       invisible(muffled)
[09:31:34.028]                     }
[09:31:34.028]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.028]                   }
[09:31:34.028]                 }
[09:31:34.028]                 else {
[09:31:34.028]                   if (TRUE) {
[09:31:34.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.028]                     {
[09:31:34.028]                       inherits <- base::inherits
[09:31:34.028]                       invokeRestart <- base::invokeRestart
[09:31:34.028]                       is.null <- base::is.null
[09:31:34.028]                       muffled <- FALSE
[09:31:34.028]                       if (inherits(cond, "message")) {
[09:31:34.028]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.028]                         if (muffled) 
[09:31:34.028]                           invokeRestart("muffleMessage")
[09:31:34.028]                       }
[09:31:34.028]                       else if (inherits(cond, "warning")) {
[09:31:34.028]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.028]                         if (muffled) 
[09:31:34.028]                           invokeRestart("muffleWarning")
[09:31:34.028]                       }
[09:31:34.028]                       else if (inherits(cond, "condition")) {
[09:31:34.028]                         if (!is.null(pattern)) {
[09:31:34.028]                           computeRestarts <- base::computeRestarts
[09:31:34.028]                           grepl <- base::grepl
[09:31:34.028]                           restarts <- computeRestarts(cond)
[09:31:34.028]                           for (restart in restarts) {
[09:31:34.028]                             name <- restart$name
[09:31:34.028]                             if (is.null(name)) 
[09:31:34.028]                               next
[09:31:34.028]                             if (!grepl(pattern, name)) 
[09:31:34.028]                               next
[09:31:34.028]                             invokeRestart(restart)
[09:31:34.028]                             muffled <- TRUE
[09:31:34.028]                             break
[09:31:34.028]                           }
[09:31:34.028]                         }
[09:31:34.028]                       }
[09:31:34.028]                       invisible(muffled)
[09:31:34.028]                     }
[09:31:34.028]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.028]                   }
[09:31:34.028]                 }
[09:31:34.028]             }
[09:31:34.028]         }))
[09:31:34.028]     }, error = function(ex) {
[09:31:34.028]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.028]                 ...future.rng), started = ...future.startTime, 
[09:31:34.028]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.028]             version = "1.8"), class = "FutureResult")
[09:31:34.028]     }, finally = {
[09:31:34.028]         if (!identical(...future.workdir, getwd())) 
[09:31:34.028]             setwd(...future.workdir)
[09:31:34.028]         {
[09:31:34.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.028]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.028]             }
[09:31:34.028]             base::options(...future.oldOptions)
[09:31:34.028]             if (.Platform$OS.type == "windows") {
[09:31:34.028]                 old_names <- names(...future.oldEnvVars)
[09:31:34.028]                 envs <- base::Sys.getenv()
[09:31:34.028]                 names <- names(envs)
[09:31:34.028]                 common <- intersect(names, old_names)
[09:31:34.028]                 added <- setdiff(names, old_names)
[09:31:34.028]                 removed <- setdiff(old_names, names)
[09:31:34.028]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.028]                   envs[common]]
[09:31:34.028]                 NAMES <- toupper(changed)
[09:31:34.028]                 args <- list()
[09:31:34.028]                 for (kk in seq_along(NAMES)) {
[09:31:34.028]                   name <- changed[[kk]]
[09:31:34.028]                   NAME <- NAMES[[kk]]
[09:31:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.028]                     next
[09:31:34.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.028]                 }
[09:31:34.028]                 NAMES <- toupper(added)
[09:31:34.028]                 for (kk in seq_along(NAMES)) {
[09:31:34.028]                   name <- added[[kk]]
[09:31:34.028]                   NAME <- NAMES[[kk]]
[09:31:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.028]                     next
[09:31:34.028]                   args[[name]] <- ""
[09:31:34.028]                 }
[09:31:34.028]                 NAMES <- toupper(removed)
[09:31:34.028]                 for (kk in seq_along(NAMES)) {
[09:31:34.028]                   name <- removed[[kk]]
[09:31:34.028]                   NAME <- NAMES[[kk]]
[09:31:34.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.028]                     next
[09:31:34.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.028]                 }
[09:31:34.028]                 if (length(args) > 0) 
[09:31:34.028]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.028]             }
[09:31:34.028]             else {
[09:31:34.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.028]             }
[09:31:34.028]             {
[09:31:34.028]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.028]                   0L) {
[09:31:34.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.028]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.028]                   base::options(opts)
[09:31:34.028]                 }
[09:31:34.028]                 {
[09:31:34.028]                   {
[09:31:34.028]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.028]                     NULL
[09:31:34.028]                   }
[09:31:34.028]                   options(future.plan = NULL)
[09:31:34.028]                   if (is.na(NA_character_)) 
[09:31:34.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.028]                     .init = FALSE)
[09:31:34.028]                 }
[09:31:34.028]             }
[09:31:34.028]         }
[09:31:34.028]     })
[09:31:34.028]     if (TRUE) {
[09:31:34.028]         base::sink(type = "output", split = FALSE)
[09:31:34.028]         if (TRUE) {
[09:31:34.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.028]         }
[09:31:34.028]         else {
[09:31:34.028]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.028]         }
[09:31:34.028]         base::close(...future.stdout)
[09:31:34.028]         ...future.stdout <- NULL
[09:31:34.028]     }
[09:31:34.028]     ...future.result$conditions <- ...future.conditions
[09:31:34.028]     ...future.result$finished <- base::Sys.time()
[09:31:34.028]     ...future.result
[09:31:34.028] }
[09:31:34.030] assign_globals() ...
[09:31:34.030] List of 1
[09:31:34.030]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e219bfda48> 
[09:31:34.030]  - attr(*, "where")=List of 1
[09:31:34.030]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.030]  - attr(*, "resolved")= logi TRUE
[09:31:34.030]  - attr(*, "total_size")= num 10984
[09:31:34.030]  - attr(*, "already-done")= logi TRUE
[09:31:34.033] - copied ‘a’ to environment
[09:31:34.033] assign_globals() ... done
[09:31:34.033] requestCore(): workers = 2
[09:31:34.035] MulticoreFuture started
[09:31:34.035] - Launch lazy future ... done
[09:31:34.036] run() for ‘MulticoreFuture’ ... done
[09:31:34.036] result() for MulticoreFuture ...
[09:31:34.036] plan(): Setting new future strategy stack:
[09:31:34.037] List of future strategies:
[09:31:34.037] 1. sequential:
[09:31:34.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.037]    - tweaked: FALSE
[09:31:34.037]    - call: NULL
[09:31:34.038] plan(): nbrOfWorkers() = 1
[09:31:34.041] plan(): Setting new future strategy stack:
[09:31:34.041] List of future strategies:
[09:31:34.041] 1. multicore:
[09:31:34.041]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.041]    - tweaked: FALSE
[09:31:34.041]    - call: plan(strategy)
[09:31:34.046] plan(): nbrOfWorkers() = 2
[09:31:34.047] result() for MulticoreFuture ...
[09:31:34.047] result() for MulticoreFuture ... done
[09:31:34.047] signalConditions() ...
[09:31:34.047]  - include = ‘immediateCondition’
[09:31:34.048]  - exclude = 
[09:31:34.048]  - resignal = FALSE
[09:31:34.048]  - Number of conditions: 4
[09:31:34.048] signalConditions() ... done
[09:31:34.048] result() for MulticoreFuture ... done
[09:31:34.048] result() for MulticoreFuture ...
[09:31:34.048] result() for MulticoreFuture ... done
[09:31:34.048] signalConditions() ...
[09:31:34.049]  - include = ‘immediateCondition’
[09:31:34.049]  - exclude = 
[09:31:34.049]  - resignal = FALSE
[09:31:34.049]  - Number of conditions: 4
[09:31:34.049] signalConditions() ... done
[09:31:34.049] Future state: ‘finished’
[09:31:34.049] result() for MulticoreFuture ...
[09:31:34.049] result() for MulticoreFuture ... done
[09:31:34.050] signalConditions() ...
[09:31:34.050]  - include = ‘condition’
[09:31:34.050]  - exclude = ‘immediateCondition’
[09:31:34.050]  - resignal = TRUE
[09:31:34.050]  - Number of conditions: 4
[09:31:34.050]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.039] result() for MulticoreFuture ...
[09:31:34.050]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.039] result() for MulticoreFuture ... done
[09:31:34.050]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.040] result() for MulticoreFuture ...
[09:31:34.051]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.040] result() for MulticoreFuture ... done
[09:31:34.051] signalConditions() ... done
value(b) = 2
[09:31:34.051] result() for MulticoreFuture ...
[09:31:34.051] result() for MulticoreFuture ... done
[09:31:34.051] result() for MulticoreFuture ...
[09:31:34.051] result() for MulticoreFuture ... done
[09:31:34.051] signalConditions() ...
[09:31:34.051]  - include = ‘immediateCondition’
[09:31:34.052]  - exclude = 
[09:31:34.052]  - resignal = FALSE
[09:31:34.052]  - Number of conditions: 4
[09:31:34.052] signalConditions() ... done
[09:31:34.052] Future state: ‘finished’
[09:31:34.052] result() for MulticoreFuture ...
[09:31:34.052] result() for MulticoreFuture ... done
[09:31:34.052] signalConditions() ...
[09:31:34.053]  - include = ‘condition’
[09:31:34.053]  - exclude = ‘immediateCondition’
[09:31:34.053]  - resignal = TRUE
[09:31:34.053]  - Number of conditions: 4
[09:31:34.053]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.039] result() for MulticoreFuture ...
[09:31:34.053]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.039] result() for MulticoreFuture ... done
[09:31:34.053]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.040] result() for MulticoreFuture ...
[09:31:34.053]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.040] result() for MulticoreFuture ... done
[09:31:34.054] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.054] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.054] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:34.055] - globals found: [2] ‘{’, ‘pkg’
[09:31:34.055] Searching for globals ... DONE
[09:31:34.056] Resolving globals: TRUE
[09:31:34.056] Resolving any globals that are futures ...
[09:31:34.056] - globals: [2] ‘{’, ‘pkg’
[09:31:34.056] Resolving any globals that are futures ... DONE
[09:31:34.056] Resolving futures part of globals (recursively) ...
[09:31:34.057] resolve() on list ...
[09:31:34.059]  recursive: 99
[09:31:34.059]  length: 1
[09:31:34.059]  elements: ‘pkg’
[09:31:34.060]  length: 0 (resolved future 1)
[09:31:34.060] resolve() on list ... DONE
[09:31:34.060] - globals: [1] ‘pkg’
[09:31:34.060] Resolving futures part of globals (recursively) ... DONE
[09:31:34.060] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:34.061] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:34.061] - globals: [1] ‘pkg’
[09:31:34.062] 
[09:31:34.062] getGlobalsAndPackages() ... DONE
[09:31:34.062] Packages needed by the future expression (n = 0): <none>
[09:31:34.062] Packages needed by future strategies (n = 0): <none>
[09:31:34.063] {
[09:31:34.063]     {
[09:31:34.063]         {
[09:31:34.063]             ...future.startTime <- base::Sys.time()
[09:31:34.063]             {
[09:31:34.063]                 {
[09:31:34.063]                   {
[09:31:34.063]                     base::local({
[09:31:34.063]                       has_future <- base::requireNamespace("future", 
[09:31:34.063]                         quietly = TRUE)
[09:31:34.063]                       if (has_future) {
[09:31:34.063]                         ns <- base::getNamespace("future")
[09:31:34.063]                         version <- ns[[".package"]][["version"]]
[09:31:34.063]                         if (is.null(version)) 
[09:31:34.063]                           version <- utils::packageVersion("future")
[09:31:34.063]                       }
[09:31:34.063]                       else {
[09:31:34.063]                         version <- NULL
[09:31:34.063]                       }
[09:31:34.063]                       if (!has_future || version < "1.8.0") {
[09:31:34.063]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.063]                           "", base::R.version$version.string), 
[09:31:34.063]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:34.063]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.063]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.063]                             "release", "version")], collapse = " "), 
[09:31:34.063]                           hostname = base::Sys.info()[["nodename"]])
[09:31:34.063]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.063]                           info)
[09:31:34.063]                         info <- base::paste(info, collapse = "; ")
[09:31:34.063]                         if (!has_future) {
[09:31:34.063]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.063]                             info)
[09:31:34.063]                         }
[09:31:34.063]                         else {
[09:31:34.063]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.063]                             info, version)
[09:31:34.063]                         }
[09:31:34.063]                         base::stop(msg)
[09:31:34.063]                       }
[09:31:34.063]                     })
[09:31:34.063]                   }
[09:31:34.063]                   ...future.strategy.old <- future::plan("list")
[09:31:34.063]                   options(future.plan = NULL)
[09:31:34.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.063]                 }
[09:31:34.063]                 ...future.workdir <- getwd()
[09:31:34.063]             }
[09:31:34.063]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.063]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.063]         }
[09:31:34.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.063]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:34.063]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.063]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.063]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.063]             base::names(...future.oldOptions))
[09:31:34.063]     }
[09:31:34.063]     if (FALSE) {
[09:31:34.063]     }
[09:31:34.063]     else {
[09:31:34.063]         if (TRUE) {
[09:31:34.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.063]                 open = "w")
[09:31:34.063]         }
[09:31:34.063]         else {
[09:31:34.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.063]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.063]         }
[09:31:34.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.063]             base::sink(type = "output", split = FALSE)
[09:31:34.063]             base::close(...future.stdout)
[09:31:34.063]         }, add = TRUE)
[09:31:34.063]     }
[09:31:34.063]     ...future.frame <- base::sys.nframe()
[09:31:34.063]     ...future.conditions <- base::list()
[09:31:34.063]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.063]     if (FALSE) {
[09:31:34.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.063]     }
[09:31:34.063]     ...future.result <- base::tryCatch({
[09:31:34.063]         base::withCallingHandlers({
[09:31:34.063]             ...future.value <- base::withVisible(base::local({
[09:31:34.063]                 pkg
[09:31:34.063]             }))
[09:31:34.063]             future::FutureResult(value = ...future.value$value, 
[09:31:34.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.063]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.063]                     ...future.globalenv.names))
[09:31:34.063]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.063]         }, condition = base::local({
[09:31:34.063]             c <- base::c
[09:31:34.063]             inherits <- base::inherits
[09:31:34.063]             invokeRestart <- base::invokeRestart
[09:31:34.063]             length <- base::length
[09:31:34.063]             list <- base::list
[09:31:34.063]             seq.int <- base::seq.int
[09:31:34.063]             signalCondition <- base::signalCondition
[09:31:34.063]             sys.calls <- base::sys.calls
[09:31:34.063]             `[[` <- base::`[[`
[09:31:34.063]             `+` <- base::`+`
[09:31:34.063]             `<<-` <- base::`<<-`
[09:31:34.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.063]                   3L)]
[09:31:34.063]             }
[09:31:34.063]             function(cond) {
[09:31:34.063]                 is_error <- inherits(cond, "error")
[09:31:34.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.063]                   NULL)
[09:31:34.063]                 if (is_error) {
[09:31:34.063]                   sessionInformation <- function() {
[09:31:34.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.063]                       search = base::search(), system = base::Sys.info())
[09:31:34.063]                   }
[09:31:34.063]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.063]                     cond$call), session = sessionInformation(), 
[09:31:34.063]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.063]                   signalCondition(cond)
[09:31:34.063]                 }
[09:31:34.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.063]                 "immediateCondition"))) {
[09:31:34.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.063]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.063]                   if (TRUE && !signal) {
[09:31:34.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.063]                     {
[09:31:34.063]                       inherits <- base::inherits
[09:31:34.063]                       invokeRestart <- base::invokeRestart
[09:31:34.063]                       is.null <- base::is.null
[09:31:34.063]                       muffled <- FALSE
[09:31:34.063]                       if (inherits(cond, "message")) {
[09:31:34.063]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.063]                         if (muffled) 
[09:31:34.063]                           invokeRestart("muffleMessage")
[09:31:34.063]                       }
[09:31:34.063]                       else if (inherits(cond, "warning")) {
[09:31:34.063]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.063]                         if (muffled) 
[09:31:34.063]                           invokeRestart("muffleWarning")
[09:31:34.063]                       }
[09:31:34.063]                       else if (inherits(cond, "condition")) {
[09:31:34.063]                         if (!is.null(pattern)) {
[09:31:34.063]                           computeRestarts <- base::computeRestarts
[09:31:34.063]                           grepl <- base::grepl
[09:31:34.063]                           restarts <- computeRestarts(cond)
[09:31:34.063]                           for (restart in restarts) {
[09:31:34.063]                             name <- restart$name
[09:31:34.063]                             if (is.null(name)) 
[09:31:34.063]                               next
[09:31:34.063]                             if (!grepl(pattern, name)) 
[09:31:34.063]                               next
[09:31:34.063]                             invokeRestart(restart)
[09:31:34.063]                             muffled <- TRUE
[09:31:34.063]                             break
[09:31:34.063]                           }
[09:31:34.063]                         }
[09:31:34.063]                       }
[09:31:34.063]                       invisible(muffled)
[09:31:34.063]                     }
[09:31:34.063]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.063]                   }
[09:31:34.063]                 }
[09:31:34.063]                 else {
[09:31:34.063]                   if (TRUE) {
[09:31:34.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.063]                     {
[09:31:34.063]                       inherits <- base::inherits
[09:31:34.063]                       invokeRestart <- base::invokeRestart
[09:31:34.063]                       is.null <- base::is.null
[09:31:34.063]                       muffled <- FALSE
[09:31:34.063]                       if (inherits(cond, "message")) {
[09:31:34.063]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.063]                         if (muffled) 
[09:31:34.063]                           invokeRestart("muffleMessage")
[09:31:34.063]                       }
[09:31:34.063]                       else if (inherits(cond, "warning")) {
[09:31:34.063]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.063]                         if (muffled) 
[09:31:34.063]                           invokeRestart("muffleWarning")
[09:31:34.063]                       }
[09:31:34.063]                       else if (inherits(cond, "condition")) {
[09:31:34.063]                         if (!is.null(pattern)) {
[09:31:34.063]                           computeRestarts <- base::computeRestarts
[09:31:34.063]                           grepl <- base::grepl
[09:31:34.063]                           restarts <- computeRestarts(cond)
[09:31:34.063]                           for (restart in restarts) {
[09:31:34.063]                             name <- restart$name
[09:31:34.063]                             if (is.null(name)) 
[09:31:34.063]                               next
[09:31:34.063]                             if (!grepl(pattern, name)) 
[09:31:34.063]                               next
[09:31:34.063]                             invokeRestart(restart)
[09:31:34.063]                             muffled <- TRUE
[09:31:34.063]                             break
[09:31:34.063]                           }
[09:31:34.063]                         }
[09:31:34.063]                       }
[09:31:34.063]                       invisible(muffled)
[09:31:34.063]                     }
[09:31:34.063]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.063]                   }
[09:31:34.063]                 }
[09:31:34.063]             }
[09:31:34.063]         }))
[09:31:34.063]     }, error = function(ex) {
[09:31:34.063]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.063]                 ...future.rng), started = ...future.startTime, 
[09:31:34.063]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.063]             version = "1.8"), class = "FutureResult")
[09:31:34.063]     }, finally = {
[09:31:34.063]         if (!identical(...future.workdir, getwd())) 
[09:31:34.063]             setwd(...future.workdir)
[09:31:34.063]         {
[09:31:34.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.063]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.063]             }
[09:31:34.063]             base::options(...future.oldOptions)
[09:31:34.063]             if (.Platform$OS.type == "windows") {
[09:31:34.063]                 old_names <- names(...future.oldEnvVars)
[09:31:34.063]                 envs <- base::Sys.getenv()
[09:31:34.063]                 names <- names(envs)
[09:31:34.063]                 common <- intersect(names, old_names)
[09:31:34.063]                 added <- setdiff(names, old_names)
[09:31:34.063]                 removed <- setdiff(old_names, names)
[09:31:34.063]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.063]                   envs[common]]
[09:31:34.063]                 NAMES <- toupper(changed)
[09:31:34.063]                 args <- list()
[09:31:34.063]                 for (kk in seq_along(NAMES)) {
[09:31:34.063]                   name <- changed[[kk]]
[09:31:34.063]                   NAME <- NAMES[[kk]]
[09:31:34.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.063]                     next
[09:31:34.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.063]                 }
[09:31:34.063]                 NAMES <- toupper(added)
[09:31:34.063]                 for (kk in seq_along(NAMES)) {
[09:31:34.063]                   name <- added[[kk]]
[09:31:34.063]                   NAME <- NAMES[[kk]]
[09:31:34.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.063]                     next
[09:31:34.063]                   args[[name]] <- ""
[09:31:34.063]                 }
[09:31:34.063]                 NAMES <- toupper(removed)
[09:31:34.063]                 for (kk in seq_along(NAMES)) {
[09:31:34.063]                   name <- removed[[kk]]
[09:31:34.063]                   NAME <- NAMES[[kk]]
[09:31:34.063]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.063]                     next
[09:31:34.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.063]                 }
[09:31:34.063]                 if (length(args) > 0) 
[09:31:34.063]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.063]             }
[09:31:34.063]             else {
[09:31:34.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.063]             }
[09:31:34.063]             {
[09:31:34.063]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.063]                   0L) {
[09:31:34.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.063]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.063]                   base::options(opts)
[09:31:34.063]                 }
[09:31:34.063]                 {
[09:31:34.063]                   {
[09:31:34.063]                     NULL
[09:31:34.063]                     RNGkind("Mersenne-Twister")
[09:31:34.063]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:34.063]                       inherits = FALSE)
[09:31:34.063]                   }
[09:31:34.063]                   options(future.plan = NULL)
[09:31:34.063]                   if (is.na(NA_character_)) 
[09:31:34.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.063]                     .init = FALSE)
[09:31:34.063]                 }
[09:31:34.063]             }
[09:31:34.063]         }
[09:31:34.063]     })
[09:31:34.063]     if (TRUE) {
[09:31:34.063]         base::sink(type = "output", split = FALSE)
[09:31:34.063]         if (TRUE) {
[09:31:34.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.063]         }
[09:31:34.063]         else {
[09:31:34.063]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.063]         }
[09:31:34.063]         base::close(...future.stdout)
[09:31:34.063]         ...future.stdout <- NULL
[09:31:34.063]     }
[09:31:34.063]     ...future.result$conditions <- ...future.conditions
[09:31:34.063]     ...future.result$finished <- base::Sys.time()
[09:31:34.063]     ...future.result
[09:31:34.063] }
[09:31:34.065] assign_globals() ...
[09:31:34.065] List of 1
[09:31:34.065]  $ pkg: chr "foo"
[09:31:34.065]  - attr(*, "where")=List of 1
[09:31:34.065]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:34.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.065]  - attr(*, "resolved")= logi TRUE
[09:31:34.065]  - attr(*, "total_size")= num 112
[09:31:34.067] - copied ‘pkg’ to environment
[09:31:34.067] assign_globals() ... done
[09:31:34.068] plan(): Setting new future strategy stack:
[09:31:34.068] List of future strategies:
[09:31:34.068] 1. sequential:
[09:31:34.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.068]    - tweaked: FALSE
[09:31:34.068]    - call: NULL
[09:31:34.068] plan(): nbrOfWorkers() = 1
[09:31:34.069] plan(): Setting new future strategy stack:
[09:31:34.069] List of future strategies:
[09:31:34.069] 1. multicore:
[09:31:34.069]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.069]    - tweaked: FALSE
[09:31:34.069]    - call: plan(strategy)
[09:31:34.073] plan(): nbrOfWorkers() = 2
[09:31:34.073] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.074] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.075] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.077] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:34.077] Searching for globals ... DONE
[09:31:34.077] Resolving globals: TRUE
[09:31:34.077] Resolving any globals that are futures ...
[09:31:34.077] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:34.077] Resolving any globals that are futures ... DONE
[09:31:34.077] Resolving futures part of globals (recursively) ...
[09:31:34.078] resolve() on list ...
[09:31:34.078]  recursive: 99
[09:31:34.078]  length: 1
[09:31:34.078]  elements: ‘a’
[09:31:34.078]  length: 0 (resolved future 1)
[09:31:34.078] resolve() on list ... DONE
[09:31:34.078] - globals: [1] ‘a’
[09:31:34.078] Resolving futures part of globals (recursively) ... DONE
[09:31:34.078] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:34.079] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:34.079] - globals: [1] ‘a’
[09:31:34.079] 
[09:31:34.079] getGlobalsAndPackages() ... DONE
[09:31:34.079] run() for ‘Future’ ...
[09:31:34.079] - state: ‘created’
[09:31:34.080] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.083] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.083] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.083]   - Field: ‘label’
[09:31:34.083]   - Field: ‘local’
[09:31:34.083]   - Field: ‘owner’
[09:31:34.083]   - Field: ‘envir’
[09:31:34.083]   - Field: ‘workers’
[09:31:34.084]   - Field: ‘packages’
[09:31:34.084]   - Field: ‘gc’
[09:31:34.084]   - Field: ‘job’
[09:31:34.084]   - Field: ‘conditions’
[09:31:34.084]   - Field: ‘expr’
[09:31:34.084]   - Field: ‘uuid’
[09:31:34.084]   - Field: ‘seed’
[09:31:34.084]   - Field: ‘version’
[09:31:34.084]   - Field: ‘result’
[09:31:34.084]   - Field: ‘asynchronous’
[09:31:34.085]   - Field: ‘calls’
[09:31:34.085]   - Field: ‘globals’
[09:31:34.085]   - Field: ‘stdout’
[09:31:34.085]   - Field: ‘earlySignal’
[09:31:34.085]   - Field: ‘lazy’
[09:31:34.085]   - Field: ‘state’
[09:31:34.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.085] - Launch lazy future ...
[09:31:34.085] Packages needed by the future expression (n = 0): <none>
[09:31:34.086] Packages needed by future strategies (n = 0): <none>
[09:31:34.086] {
[09:31:34.086]     {
[09:31:34.086]         {
[09:31:34.086]             ...future.startTime <- base::Sys.time()
[09:31:34.086]             {
[09:31:34.086]                 {
[09:31:34.086]                   {
[09:31:34.086]                     {
[09:31:34.086]                       base::local({
[09:31:34.086]                         has_future <- base::requireNamespace("future", 
[09:31:34.086]                           quietly = TRUE)
[09:31:34.086]                         if (has_future) {
[09:31:34.086]                           ns <- base::getNamespace("future")
[09:31:34.086]                           version <- ns[[".package"]][["version"]]
[09:31:34.086]                           if (is.null(version)) 
[09:31:34.086]                             version <- utils::packageVersion("future")
[09:31:34.086]                         }
[09:31:34.086]                         else {
[09:31:34.086]                           version <- NULL
[09:31:34.086]                         }
[09:31:34.086]                         if (!has_future || version < "1.8.0") {
[09:31:34.086]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.086]                             "", base::R.version$version.string), 
[09:31:34.086]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.086]                               "release", "version")], collapse = " "), 
[09:31:34.086]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.086]                             info)
[09:31:34.086]                           info <- base::paste(info, collapse = "; ")
[09:31:34.086]                           if (!has_future) {
[09:31:34.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.086]                               info)
[09:31:34.086]                           }
[09:31:34.086]                           else {
[09:31:34.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.086]                               info, version)
[09:31:34.086]                           }
[09:31:34.086]                           base::stop(msg)
[09:31:34.086]                         }
[09:31:34.086]                       })
[09:31:34.086]                     }
[09:31:34.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.086]                     base::options(mc.cores = 1L)
[09:31:34.086]                   }
[09:31:34.086]                   ...future.strategy.old <- future::plan("list")
[09:31:34.086]                   options(future.plan = NULL)
[09:31:34.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.086]                 }
[09:31:34.086]                 ...future.workdir <- getwd()
[09:31:34.086]             }
[09:31:34.086]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.086]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.086]         }
[09:31:34.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.086]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.086]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.086]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.086]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.086]             base::names(...future.oldOptions))
[09:31:34.086]     }
[09:31:34.086]     if (FALSE) {
[09:31:34.086]     }
[09:31:34.086]     else {
[09:31:34.086]         if (TRUE) {
[09:31:34.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.086]                 open = "w")
[09:31:34.086]         }
[09:31:34.086]         else {
[09:31:34.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.086]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.086]         }
[09:31:34.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.086]             base::sink(type = "output", split = FALSE)
[09:31:34.086]             base::close(...future.stdout)
[09:31:34.086]         }, add = TRUE)
[09:31:34.086]     }
[09:31:34.086]     ...future.frame <- base::sys.nframe()
[09:31:34.086]     ...future.conditions <- base::list()
[09:31:34.086]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.086]     if (FALSE) {
[09:31:34.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.086]     }
[09:31:34.086]     ...future.result <- base::tryCatch({
[09:31:34.086]         base::withCallingHandlers({
[09:31:34.086]             ...future.value <- base::withVisible(base::local({
[09:31:34.086]                 withCallingHandlers({
[09:31:34.086]                   {
[09:31:34.086]                     b <- a
[09:31:34.086]                     a <- 2
[09:31:34.086]                     a * b
[09:31:34.086]                   }
[09:31:34.086]                 }, immediateCondition = function(cond) {
[09:31:34.086]                   save_rds <- function (object, pathname, ...) 
[09:31:34.086]                   {
[09:31:34.086]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.086]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.086]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.086]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.086]                         fi_tmp[["mtime"]])
[09:31:34.086]                     }
[09:31:34.086]                     tryCatch({
[09:31:34.086]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.086]                     }, error = function(ex) {
[09:31:34.086]                       msg <- conditionMessage(ex)
[09:31:34.086]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.086]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.086]                         fi_tmp[["mtime"]], msg)
[09:31:34.086]                       ex$message <- msg
[09:31:34.086]                       stop(ex)
[09:31:34.086]                     })
[09:31:34.086]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.086]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.086]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.086]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.086]                       fi <- file.info(pathname)
[09:31:34.086]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.086]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.086]                         fi[["size"]], fi[["mtime"]])
[09:31:34.086]                       stop(msg)
[09:31:34.086]                     }
[09:31:34.086]                     invisible(pathname)
[09:31:34.086]                   }
[09:31:34.086]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.086]                     rootPath = tempdir()) 
[09:31:34.086]                   {
[09:31:34.086]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.086]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.086]                       tmpdir = path, fileext = ".rds")
[09:31:34.086]                     save_rds(obj, file)
[09:31:34.086]                   }
[09:31:34.086]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.086]                   {
[09:31:34.086]                     inherits <- base::inherits
[09:31:34.086]                     invokeRestart <- base::invokeRestart
[09:31:34.086]                     is.null <- base::is.null
[09:31:34.086]                     muffled <- FALSE
[09:31:34.086]                     if (inherits(cond, "message")) {
[09:31:34.086]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.086]                       if (muffled) 
[09:31:34.086]                         invokeRestart("muffleMessage")
[09:31:34.086]                     }
[09:31:34.086]                     else if (inherits(cond, "warning")) {
[09:31:34.086]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.086]                       if (muffled) 
[09:31:34.086]                         invokeRestart("muffleWarning")
[09:31:34.086]                     }
[09:31:34.086]                     else if (inherits(cond, "condition")) {
[09:31:34.086]                       if (!is.null(pattern)) {
[09:31:34.086]                         computeRestarts <- base::computeRestarts
[09:31:34.086]                         grepl <- base::grepl
[09:31:34.086]                         restarts <- computeRestarts(cond)
[09:31:34.086]                         for (restart in restarts) {
[09:31:34.086]                           name <- restart$name
[09:31:34.086]                           if (is.null(name)) 
[09:31:34.086]                             next
[09:31:34.086]                           if (!grepl(pattern, name)) 
[09:31:34.086]                             next
[09:31:34.086]                           invokeRestart(restart)
[09:31:34.086]                           muffled <- TRUE
[09:31:34.086]                           break
[09:31:34.086]                         }
[09:31:34.086]                       }
[09:31:34.086]                     }
[09:31:34.086]                     invisible(muffled)
[09:31:34.086]                   }
[09:31:34.086]                   muffleCondition(cond)
[09:31:34.086]                 })
[09:31:34.086]             }))
[09:31:34.086]             future::FutureResult(value = ...future.value$value, 
[09:31:34.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.086]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.086]                     ...future.globalenv.names))
[09:31:34.086]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.086]         }, condition = base::local({
[09:31:34.086]             c <- base::c
[09:31:34.086]             inherits <- base::inherits
[09:31:34.086]             invokeRestart <- base::invokeRestart
[09:31:34.086]             length <- base::length
[09:31:34.086]             list <- base::list
[09:31:34.086]             seq.int <- base::seq.int
[09:31:34.086]             signalCondition <- base::signalCondition
[09:31:34.086]             sys.calls <- base::sys.calls
[09:31:34.086]             `[[` <- base::`[[`
[09:31:34.086]             `+` <- base::`+`
[09:31:34.086]             `<<-` <- base::`<<-`
[09:31:34.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.086]                   3L)]
[09:31:34.086]             }
[09:31:34.086]             function(cond) {
[09:31:34.086]                 is_error <- inherits(cond, "error")
[09:31:34.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.086]                   NULL)
[09:31:34.086]                 if (is_error) {
[09:31:34.086]                   sessionInformation <- function() {
[09:31:34.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.086]                       search = base::search(), system = base::Sys.info())
[09:31:34.086]                   }
[09:31:34.086]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.086]                     cond$call), session = sessionInformation(), 
[09:31:34.086]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.086]                   signalCondition(cond)
[09:31:34.086]                 }
[09:31:34.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.086]                 "immediateCondition"))) {
[09:31:34.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.086]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.086]                   if (TRUE && !signal) {
[09:31:34.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.086]                     {
[09:31:34.086]                       inherits <- base::inherits
[09:31:34.086]                       invokeRestart <- base::invokeRestart
[09:31:34.086]                       is.null <- base::is.null
[09:31:34.086]                       muffled <- FALSE
[09:31:34.086]                       if (inherits(cond, "message")) {
[09:31:34.086]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.086]                         if (muffled) 
[09:31:34.086]                           invokeRestart("muffleMessage")
[09:31:34.086]                       }
[09:31:34.086]                       else if (inherits(cond, "warning")) {
[09:31:34.086]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.086]                         if (muffled) 
[09:31:34.086]                           invokeRestart("muffleWarning")
[09:31:34.086]                       }
[09:31:34.086]                       else if (inherits(cond, "condition")) {
[09:31:34.086]                         if (!is.null(pattern)) {
[09:31:34.086]                           computeRestarts <- base::computeRestarts
[09:31:34.086]                           grepl <- base::grepl
[09:31:34.086]                           restarts <- computeRestarts(cond)
[09:31:34.086]                           for (restart in restarts) {
[09:31:34.086]                             name <- restart$name
[09:31:34.086]                             if (is.null(name)) 
[09:31:34.086]                               next
[09:31:34.086]                             if (!grepl(pattern, name)) 
[09:31:34.086]                               next
[09:31:34.086]                             invokeRestart(restart)
[09:31:34.086]                             muffled <- TRUE
[09:31:34.086]                             break
[09:31:34.086]                           }
[09:31:34.086]                         }
[09:31:34.086]                       }
[09:31:34.086]                       invisible(muffled)
[09:31:34.086]                     }
[09:31:34.086]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.086]                   }
[09:31:34.086]                 }
[09:31:34.086]                 else {
[09:31:34.086]                   if (TRUE) {
[09:31:34.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.086]                     {
[09:31:34.086]                       inherits <- base::inherits
[09:31:34.086]                       invokeRestart <- base::invokeRestart
[09:31:34.086]                       is.null <- base::is.null
[09:31:34.086]                       muffled <- FALSE
[09:31:34.086]                       if (inherits(cond, "message")) {
[09:31:34.086]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.086]                         if (muffled) 
[09:31:34.086]                           invokeRestart("muffleMessage")
[09:31:34.086]                       }
[09:31:34.086]                       else if (inherits(cond, "warning")) {
[09:31:34.086]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.086]                         if (muffled) 
[09:31:34.086]                           invokeRestart("muffleWarning")
[09:31:34.086]                       }
[09:31:34.086]                       else if (inherits(cond, "condition")) {
[09:31:34.086]                         if (!is.null(pattern)) {
[09:31:34.086]                           computeRestarts <- base::computeRestarts
[09:31:34.086]                           grepl <- base::grepl
[09:31:34.086]                           restarts <- computeRestarts(cond)
[09:31:34.086]                           for (restart in restarts) {
[09:31:34.086]                             name <- restart$name
[09:31:34.086]                             if (is.null(name)) 
[09:31:34.086]                               next
[09:31:34.086]                             if (!grepl(pattern, name)) 
[09:31:34.086]                               next
[09:31:34.086]                             invokeRestart(restart)
[09:31:34.086]                             muffled <- TRUE
[09:31:34.086]                             break
[09:31:34.086]                           }
[09:31:34.086]                         }
[09:31:34.086]                       }
[09:31:34.086]                       invisible(muffled)
[09:31:34.086]                     }
[09:31:34.086]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.086]                   }
[09:31:34.086]                 }
[09:31:34.086]             }
[09:31:34.086]         }))
[09:31:34.086]     }, error = function(ex) {
[09:31:34.086]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.086]                 ...future.rng), started = ...future.startTime, 
[09:31:34.086]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.086]             version = "1.8"), class = "FutureResult")
[09:31:34.086]     }, finally = {
[09:31:34.086]         if (!identical(...future.workdir, getwd())) 
[09:31:34.086]             setwd(...future.workdir)
[09:31:34.086]         {
[09:31:34.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.086]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.086]             }
[09:31:34.086]             base::options(...future.oldOptions)
[09:31:34.086]             if (.Platform$OS.type == "windows") {
[09:31:34.086]                 old_names <- names(...future.oldEnvVars)
[09:31:34.086]                 envs <- base::Sys.getenv()
[09:31:34.086]                 names <- names(envs)
[09:31:34.086]                 common <- intersect(names, old_names)
[09:31:34.086]                 added <- setdiff(names, old_names)
[09:31:34.086]                 removed <- setdiff(old_names, names)
[09:31:34.086]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.086]                   envs[common]]
[09:31:34.086]                 NAMES <- toupper(changed)
[09:31:34.086]                 args <- list()
[09:31:34.086]                 for (kk in seq_along(NAMES)) {
[09:31:34.086]                   name <- changed[[kk]]
[09:31:34.086]                   NAME <- NAMES[[kk]]
[09:31:34.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.086]                     next
[09:31:34.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.086]                 }
[09:31:34.086]                 NAMES <- toupper(added)
[09:31:34.086]                 for (kk in seq_along(NAMES)) {
[09:31:34.086]                   name <- added[[kk]]
[09:31:34.086]                   NAME <- NAMES[[kk]]
[09:31:34.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.086]                     next
[09:31:34.086]                   args[[name]] <- ""
[09:31:34.086]                 }
[09:31:34.086]                 NAMES <- toupper(removed)
[09:31:34.086]                 for (kk in seq_along(NAMES)) {
[09:31:34.086]                   name <- removed[[kk]]
[09:31:34.086]                   NAME <- NAMES[[kk]]
[09:31:34.086]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.086]                     next
[09:31:34.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.086]                 }
[09:31:34.086]                 if (length(args) > 0) 
[09:31:34.086]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.086]             }
[09:31:34.086]             else {
[09:31:34.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.086]             }
[09:31:34.086]             {
[09:31:34.086]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.086]                   0L) {
[09:31:34.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.086]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.086]                   base::options(opts)
[09:31:34.086]                 }
[09:31:34.086]                 {
[09:31:34.086]                   {
[09:31:34.086]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.086]                     NULL
[09:31:34.086]                   }
[09:31:34.086]                   options(future.plan = NULL)
[09:31:34.086]                   if (is.na(NA_character_)) 
[09:31:34.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.086]                     .init = FALSE)
[09:31:34.086]                 }
[09:31:34.086]             }
[09:31:34.086]         }
[09:31:34.086]     })
[09:31:34.086]     if (TRUE) {
[09:31:34.086]         base::sink(type = "output", split = FALSE)
[09:31:34.086]         if (TRUE) {
[09:31:34.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.086]         }
[09:31:34.086]         else {
[09:31:34.086]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.086]         }
[09:31:34.086]         base::close(...future.stdout)
[09:31:34.086]         ...future.stdout <- NULL
[09:31:34.086]     }
[09:31:34.086]     ...future.result$conditions <- ...future.conditions
[09:31:34.086]     ...future.result$finished <- base::Sys.time()
[09:31:34.086]     ...future.result
[09:31:34.086] }
[09:31:34.088] assign_globals() ...
[09:31:34.088] List of 1
[09:31:34.088]  $ a: num 3
[09:31:34.088]  - attr(*, "where")=List of 1
[09:31:34.088]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.088]  - attr(*, "resolved")= logi TRUE
[09:31:34.088]  - attr(*, "total_size")= num 56
[09:31:34.088]  - attr(*, "already-done")= logi TRUE
[09:31:34.092] - copied ‘a’ to environment
[09:31:34.093] assign_globals() ... done
[09:31:34.093] requestCore(): workers = 2
[09:31:34.095] MulticoreFuture started
[09:31:34.095] - Launch lazy future ... done
[09:31:34.095] run() for ‘MulticoreFuture’ ... done
[09:31:34.096] plan(): Setting new future strategy stack:
[09:31:34.096] result() for MulticoreFuture ...
[09:31:34.096] List of future strategies:
[09:31:34.096] 1. sequential:
[09:31:34.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.096]    - tweaked: FALSE
[09:31:34.096]    - call: NULL
[09:31:34.097] plan(): nbrOfWorkers() = 1
[09:31:34.100] plan(): Setting new future strategy stack:
[09:31:34.100] List of future strategies:
[09:31:34.100] 1. multicore:
[09:31:34.100]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.100]    - tweaked: FALSE
[09:31:34.100]    - call: plan(strategy)
[09:31:34.105] plan(): nbrOfWorkers() = 2
[09:31:34.106] result() for MulticoreFuture ...
[09:31:34.107] result() for MulticoreFuture ... done
[09:31:34.107] result() for MulticoreFuture ... done
[09:31:34.107] result() for MulticoreFuture ...
[09:31:34.107] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.108] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.108] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.111] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:34.111] Searching for globals ... DONE
[09:31:34.111] Resolving globals: TRUE
[09:31:34.111] Resolving any globals that are futures ...
[09:31:34.111] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:34.111] Resolving any globals that are futures ... DONE
[09:31:34.112] Resolving futures part of globals (recursively) ...
[09:31:34.112] resolve() on list ...
[09:31:34.112]  recursive: 99
[09:31:34.112]  length: 1
[09:31:34.112]  elements: ‘a’
[09:31:34.113]  length: 0 (resolved future 1)
[09:31:34.113] resolve() on list ... DONE
[09:31:34.113] - globals: [1] ‘a’
[09:31:34.113] Resolving futures part of globals (recursively) ... DONE
[09:31:34.113] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:34.113] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:34.114] - globals: [1] ‘a’
[09:31:34.114] 
[09:31:34.114] getGlobalsAndPackages() ... DONE
[09:31:34.114] run() for ‘Future’ ...
[09:31:34.114] - state: ‘created’
[09:31:34.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.118] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.119]   - Field: ‘label’
[09:31:34.119]   - Field: ‘local’
[09:31:34.119]   - Field: ‘owner’
[09:31:34.119]   - Field: ‘envir’
[09:31:34.119]   - Field: ‘workers’
[09:31:34.119]   - Field: ‘packages’
[09:31:34.119]   - Field: ‘gc’
[09:31:34.120]   - Field: ‘job’
[09:31:34.120]   - Field: ‘conditions’
[09:31:34.120]   - Field: ‘expr’
[09:31:34.120]   - Field: ‘uuid’
[09:31:34.120]   - Field: ‘seed’
[09:31:34.120]   - Field: ‘version’
[09:31:34.120]   - Field: ‘result’
[09:31:34.120]   - Field: ‘asynchronous’
[09:31:34.120]   - Field: ‘calls’
[09:31:34.121]   - Field: ‘globals’
[09:31:34.121]   - Field: ‘stdout’
[09:31:34.121]   - Field: ‘earlySignal’
[09:31:34.121]   - Field: ‘lazy’
[09:31:34.121]   - Field: ‘state’
[09:31:34.121] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.121] - Launch lazy future ...
[09:31:34.122] Packages needed by the future expression (n = 0): <none>
[09:31:34.122] Packages needed by future strategies (n = 0): <none>
[09:31:34.122] {
[09:31:34.122]     {
[09:31:34.122]         {
[09:31:34.122]             ...future.startTime <- base::Sys.time()
[09:31:34.122]             {
[09:31:34.122]                 {
[09:31:34.122]                   {
[09:31:34.122]                     {
[09:31:34.122]                       base::local({
[09:31:34.122]                         has_future <- base::requireNamespace("future", 
[09:31:34.122]                           quietly = TRUE)
[09:31:34.122]                         if (has_future) {
[09:31:34.122]                           ns <- base::getNamespace("future")
[09:31:34.122]                           version <- ns[[".package"]][["version"]]
[09:31:34.122]                           if (is.null(version)) 
[09:31:34.122]                             version <- utils::packageVersion("future")
[09:31:34.122]                         }
[09:31:34.122]                         else {
[09:31:34.122]                           version <- NULL
[09:31:34.122]                         }
[09:31:34.122]                         if (!has_future || version < "1.8.0") {
[09:31:34.122]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.122]                             "", base::R.version$version.string), 
[09:31:34.122]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.122]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.122]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.122]                               "release", "version")], collapse = " "), 
[09:31:34.122]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.122]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.122]                             info)
[09:31:34.122]                           info <- base::paste(info, collapse = "; ")
[09:31:34.122]                           if (!has_future) {
[09:31:34.122]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.122]                               info)
[09:31:34.122]                           }
[09:31:34.122]                           else {
[09:31:34.122]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.122]                               info, version)
[09:31:34.122]                           }
[09:31:34.122]                           base::stop(msg)
[09:31:34.122]                         }
[09:31:34.122]                       })
[09:31:34.122]                     }
[09:31:34.122]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.122]                     base::options(mc.cores = 1L)
[09:31:34.122]                   }
[09:31:34.122]                   ...future.strategy.old <- future::plan("list")
[09:31:34.122]                   options(future.plan = NULL)
[09:31:34.122]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.122]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.122]                 }
[09:31:34.122]                 ...future.workdir <- getwd()
[09:31:34.122]             }
[09:31:34.122]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.122]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.122]         }
[09:31:34.122]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.122]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.122]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.122]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.122]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.122]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.122]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.122]             base::names(...future.oldOptions))
[09:31:34.122]     }
[09:31:34.122]     if (FALSE) {
[09:31:34.122]     }
[09:31:34.122]     else {
[09:31:34.122]         if (TRUE) {
[09:31:34.122]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.122]                 open = "w")
[09:31:34.122]         }
[09:31:34.122]         else {
[09:31:34.122]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.122]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.122]         }
[09:31:34.122]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.122]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.122]             base::sink(type = "output", split = FALSE)
[09:31:34.122]             base::close(...future.stdout)
[09:31:34.122]         }, add = TRUE)
[09:31:34.122]     }
[09:31:34.122]     ...future.frame <- base::sys.nframe()
[09:31:34.122]     ...future.conditions <- base::list()
[09:31:34.122]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.122]     if (FALSE) {
[09:31:34.122]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.122]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.122]     }
[09:31:34.122]     ...future.result <- base::tryCatch({
[09:31:34.122]         base::withCallingHandlers({
[09:31:34.122]             ...future.value <- base::withVisible(base::local({
[09:31:34.122]                 withCallingHandlers({
[09:31:34.122]                   {
[09:31:34.122]                     b <- a
[09:31:34.122]                     a <- 2
[09:31:34.122]                     a * b
[09:31:34.122]                   }
[09:31:34.122]                 }, immediateCondition = function(cond) {
[09:31:34.122]                   save_rds <- function (object, pathname, ...) 
[09:31:34.122]                   {
[09:31:34.122]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.122]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.122]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.122]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.122]                         fi_tmp[["mtime"]])
[09:31:34.122]                     }
[09:31:34.122]                     tryCatch({
[09:31:34.122]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.122]                     }, error = function(ex) {
[09:31:34.122]                       msg <- conditionMessage(ex)
[09:31:34.122]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.122]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.122]                         fi_tmp[["mtime"]], msg)
[09:31:34.122]                       ex$message <- msg
[09:31:34.122]                       stop(ex)
[09:31:34.122]                     })
[09:31:34.122]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.122]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.122]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.122]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.122]                       fi <- file.info(pathname)
[09:31:34.122]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.122]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.122]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.122]                         fi[["size"]], fi[["mtime"]])
[09:31:34.122]                       stop(msg)
[09:31:34.122]                     }
[09:31:34.122]                     invisible(pathname)
[09:31:34.122]                   }
[09:31:34.122]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.122]                     rootPath = tempdir()) 
[09:31:34.122]                   {
[09:31:34.122]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.122]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.122]                       tmpdir = path, fileext = ".rds")
[09:31:34.122]                     save_rds(obj, file)
[09:31:34.122]                   }
[09:31:34.122]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.122]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.122]                   {
[09:31:34.122]                     inherits <- base::inherits
[09:31:34.122]                     invokeRestart <- base::invokeRestart
[09:31:34.122]                     is.null <- base::is.null
[09:31:34.122]                     muffled <- FALSE
[09:31:34.122]                     if (inherits(cond, "message")) {
[09:31:34.122]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.122]                       if (muffled) 
[09:31:34.122]                         invokeRestart("muffleMessage")
[09:31:34.122]                     }
[09:31:34.122]                     else if (inherits(cond, "warning")) {
[09:31:34.122]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.122]                       if (muffled) 
[09:31:34.122]                         invokeRestart("muffleWarning")
[09:31:34.122]                     }
[09:31:34.122]                     else if (inherits(cond, "condition")) {
[09:31:34.122]                       if (!is.null(pattern)) {
[09:31:34.122]                         computeRestarts <- base::computeRestarts
[09:31:34.122]                         grepl <- base::grepl
[09:31:34.122]                         restarts <- computeRestarts(cond)
[09:31:34.122]                         for (restart in restarts) {
[09:31:34.122]                           name <- restart$name
[09:31:34.122]                           if (is.null(name)) 
[09:31:34.122]                             next
[09:31:34.122]                           if (!grepl(pattern, name)) 
[09:31:34.122]                             next
[09:31:34.122]                           invokeRestart(restart)
[09:31:34.122]                           muffled <- TRUE
[09:31:34.122]                           break
[09:31:34.122]                         }
[09:31:34.122]                       }
[09:31:34.122]                     }
[09:31:34.122]                     invisible(muffled)
[09:31:34.122]                   }
[09:31:34.122]                   muffleCondition(cond)
[09:31:34.122]                 })
[09:31:34.122]             }))
[09:31:34.122]             future::FutureResult(value = ...future.value$value, 
[09:31:34.122]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.122]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.122]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.122]                     ...future.globalenv.names))
[09:31:34.122]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.122]         }, condition = base::local({
[09:31:34.122]             c <- base::c
[09:31:34.122]             inherits <- base::inherits
[09:31:34.122]             invokeRestart <- base::invokeRestart
[09:31:34.122]             length <- base::length
[09:31:34.122]             list <- base::list
[09:31:34.122]             seq.int <- base::seq.int
[09:31:34.122]             signalCondition <- base::signalCondition
[09:31:34.122]             sys.calls <- base::sys.calls
[09:31:34.122]             `[[` <- base::`[[`
[09:31:34.122]             `+` <- base::`+`
[09:31:34.122]             `<<-` <- base::`<<-`
[09:31:34.122]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.122]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.122]                   3L)]
[09:31:34.122]             }
[09:31:34.122]             function(cond) {
[09:31:34.122]                 is_error <- inherits(cond, "error")
[09:31:34.122]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.122]                   NULL)
[09:31:34.122]                 if (is_error) {
[09:31:34.122]                   sessionInformation <- function() {
[09:31:34.122]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.122]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.122]                       search = base::search(), system = base::Sys.info())
[09:31:34.122]                   }
[09:31:34.122]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.122]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.122]                     cond$call), session = sessionInformation(), 
[09:31:34.122]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.122]                   signalCondition(cond)
[09:31:34.122]                 }
[09:31:34.122]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.122]                 "immediateCondition"))) {
[09:31:34.122]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.122]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.122]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.122]                   if (TRUE && !signal) {
[09:31:34.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.122]                     {
[09:31:34.122]                       inherits <- base::inherits
[09:31:34.122]                       invokeRestart <- base::invokeRestart
[09:31:34.122]                       is.null <- base::is.null
[09:31:34.122]                       muffled <- FALSE
[09:31:34.122]                       if (inherits(cond, "message")) {
[09:31:34.122]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.122]                         if (muffled) 
[09:31:34.122]                           invokeRestart("muffleMessage")
[09:31:34.122]                       }
[09:31:34.122]                       else if (inherits(cond, "warning")) {
[09:31:34.122]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.122]                         if (muffled) 
[09:31:34.122]                           invokeRestart("muffleWarning")
[09:31:34.122]                       }
[09:31:34.122]                       else if (inherits(cond, "condition")) {
[09:31:34.122]                         if (!is.null(pattern)) {
[09:31:34.122]                           computeRestarts <- base::computeRestarts
[09:31:34.122]                           grepl <- base::grepl
[09:31:34.122]                           restarts <- computeRestarts(cond)
[09:31:34.122]                           for (restart in restarts) {
[09:31:34.122]                             name <- restart$name
[09:31:34.122]                             if (is.null(name)) 
[09:31:34.122]                               next
[09:31:34.122]                             if (!grepl(pattern, name)) 
[09:31:34.122]                               next
[09:31:34.122]                             invokeRestart(restart)
[09:31:34.122]                             muffled <- TRUE
[09:31:34.122]                             break
[09:31:34.122]                           }
[09:31:34.122]                         }
[09:31:34.122]                       }
[09:31:34.122]                       invisible(muffled)
[09:31:34.122]                     }
[09:31:34.122]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.122]                   }
[09:31:34.122]                 }
[09:31:34.122]                 else {
[09:31:34.122]                   if (TRUE) {
[09:31:34.122]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.122]                     {
[09:31:34.122]                       inherits <- base::inherits
[09:31:34.122]                       invokeRestart <- base::invokeRestart
[09:31:34.122]                       is.null <- base::is.null
[09:31:34.122]                       muffled <- FALSE
[09:31:34.122]                       if (inherits(cond, "message")) {
[09:31:34.122]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.122]                         if (muffled) 
[09:31:34.122]                           invokeRestart("muffleMessage")
[09:31:34.122]                       }
[09:31:34.122]                       else if (inherits(cond, "warning")) {
[09:31:34.122]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.122]                         if (muffled) 
[09:31:34.122]                           invokeRestart("muffleWarning")
[09:31:34.122]                       }
[09:31:34.122]                       else if (inherits(cond, "condition")) {
[09:31:34.122]                         if (!is.null(pattern)) {
[09:31:34.122]                           computeRestarts <- base::computeRestarts
[09:31:34.122]                           grepl <- base::grepl
[09:31:34.122]                           restarts <- computeRestarts(cond)
[09:31:34.122]                           for (restart in restarts) {
[09:31:34.122]                             name <- restart$name
[09:31:34.122]                             if (is.null(name)) 
[09:31:34.122]                               next
[09:31:34.122]                             if (!grepl(pattern, name)) 
[09:31:34.122]                               next
[09:31:34.122]                             invokeRestart(restart)
[09:31:34.122]                             muffled <- TRUE
[09:31:34.122]                             break
[09:31:34.122]                           }
[09:31:34.122]                         }
[09:31:34.122]                       }
[09:31:34.122]                       invisible(muffled)
[09:31:34.122]                     }
[09:31:34.122]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.122]                   }
[09:31:34.122]                 }
[09:31:34.122]             }
[09:31:34.122]         }))
[09:31:34.122]     }, error = function(ex) {
[09:31:34.122]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.122]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.122]                 ...future.rng), started = ...future.startTime, 
[09:31:34.122]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.122]             version = "1.8"), class = "FutureResult")
[09:31:34.122]     }, finally = {
[09:31:34.122]         if (!identical(...future.workdir, getwd())) 
[09:31:34.122]             setwd(...future.workdir)
[09:31:34.122]         {
[09:31:34.122]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.122]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.122]             }
[09:31:34.122]             base::options(...future.oldOptions)
[09:31:34.122]             if (.Platform$OS.type == "windows") {
[09:31:34.122]                 old_names <- names(...future.oldEnvVars)
[09:31:34.122]                 envs <- base::Sys.getenv()
[09:31:34.122]                 names <- names(envs)
[09:31:34.122]                 common <- intersect(names, old_names)
[09:31:34.122]                 added <- setdiff(names, old_names)
[09:31:34.122]                 removed <- setdiff(old_names, names)
[09:31:34.122]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.122]                   envs[common]]
[09:31:34.122]                 NAMES <- toupper(changed)
[09:31:34.122]                 args <- list()
[09:31:34.122]                 for (kk in seq_along(NAMES)) {
[09:31:34.122]                   name <- changed[[kk]]
[09:31:34.122]                   NAME <- NAMES[[kk]]
[09:31:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.122]                     next
[09:31:34.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.122]                 }
[09:31:34.122]                 NAMES <- toupper(added)
[09:31:34.122]                 for (kk in seq_along(NAMES)) {
[09:31:34.122]                   name <- added[[kk]]
[09:31:34.122]                   NAME <- NAMES[[kk]]
[09:31:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.122]                     next
[09:31:34.122]                   args[[name]] <- ""
[09:31:34.122]                 }
[09:31:34.122]                 NAMES <- toupper(removed)
[09:31:34.122]                 for (kk in seq_along(NAMES)) {
[09:31:34.122]                   name <- removed[[kk]]
[09:31:34.122]                   NAME <- NAMES[[kk]]
[09:31:34.122]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.122]                     next
[09:31:34.122]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.122]                 }
[09:31:34.122]                 if (length(args) > 0) 
[09:31:34.122]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.122]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.122]             }
[09:31:34.122]             else {
[09:31:34.122]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.122]             }
[09:31:34.122]             {
[09:31:34.122]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.122]                   0L) {
[09:31:34.122]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.122]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.122]                   base::options(opts)
[09:31:34.122]                 }
[09:31:34.122]                 {
[09:31:34.122]                   {
[09:31:34.122]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.122]                     NULL
[09:31:34.122]                   }
[09:31:34.122]                   options(future.plan = NULL)
[09:31:34.122]                   if (is.na(NA_character_)) 
[09:31:34.122]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.122]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.122]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.122]                     .init = FALSE)
[09:31:34.122]                 }
[09:31:34.122]             }
[09:31:34.122]         }
[09:31:34.122]     })
[09:31:34.122]     if (TRUE) {
[09:31:34.122]         base::sink(type = "output", split = FALSE)
[09:31:34.122]         if (TRUE) {
[09:31:34.122]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.122]         }
[09:31:34.122]         else {
[09:31:34.122]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.122]         }
[09:31:34.122]         base::close(...future.stdout)
[09:31:34.122]         ...future.stdout <- NULL
[09:31:34.122]     }
[09:31:34.122]     ...future.result$conditions <- ...future.conditions
[09:31:34.122]     ...future.result$finished <- base::Sys.time()
[09:31:34.122]     ...future.result
[09:31:34.122] }
[09:31:34.125] assign_globals() ...
[09:31:34.125] List of 1
[09:31:34.125]  $ a: num 3
[09:31:34.125]  - attr(*, "where")=List of 1
[09:31:34.125]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.125]  - attr(*, "resolved")= logi TRUE
[09:31:34.125]  - attr(*, "total_size")= num 56
[09:31:34.125]  - attr(*, "already-done")= logi TRUE
[09:31:34.128] - copied ‘a’ to environment
[09:31:34.128] assign_globals() ... done
[09:31:34.128] requestCore(): workers = 2
[09:31:34.130] MulticoreFuture started
[09:31:34.130] - Launch lazy future ... done
[09:31:34.131] run() for ‘MulticoreFuture’ ... done
[09:31:34.131] result() for MulticoreFuture ...
[09:31:34.131] plan(): Setting new future strategy stack:
[09:31:34.131] List of future strategies:
[09:31:34.131] 1. sequential:
[09:31:34.131]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.131]    - tweaked: FALSE
[09:31:34.131]    - call: NULL
[09:31:34.132] plan(): nbrOfWorkers() = 1
[09:31:34.139] plan(): Setting new future strategy stack:
[09:31:34.140] List of future strategies:
[09:31:34.140] 1. multicore:
[09:31:34.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.140]    - tweaked: FALSE
[09:31:34.140]    - call: plan(strategy)
[09:31:34.147] plan(): nbrOfWorkers() = 2
[09:31:34.148] result() for MulticoreFuture ...
[09:31:34.148] result() for MulticoreFuture ... done
[09:31:34.148] result() for MulticoreFuture ... done
[09:31:34.150] result() for MulticoreFuture ...
[09:31:34.151] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.152] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.152] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.156] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.156] Searching for globals ... DONE
[09:31:34.156] Resolving globals: TRUE
[09:31:34.156] Resolving any globals that are futures ...
[09:31:34.156] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.156] Resolving any globals that are futures ... DONE
[09:31:34.157] Resolving futures part of globals (recursively) ...
[09:31:34.157] resolve() on list ...
[09:31:34.157]  recursive: 99
[09:31:34.157]  length: 2
[09:31:34.157]  elements: ‘a’, ‘ii’
[09:31:34.158]  length: 1 (resolved future 1)
[09:31:34.158]  length: 0 (resolved future 2)
[09:31:34.158] resolve() on list ... DONE
[09:31:34.158] - globals: [2] ‘a’, ‘ii’
[09:31:34.158] Resolving futures part of globals (recursively) ... DONE
[09:31:34.158] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.159] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.159] - globals: [2] ‘a’, ‘ii’
[09:31:34.159] 
[09:31:34.159] getGlobalsAndPackages() ... DONE
[09:31:34.159] run() for ‘Future’ ...
[09:31:34.159] - state: ‘created’
[09:31:34.160] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.164]   - Field: ‘label’
[09:31:34.164]   - Field: ‘local’
[09:31:34.164]   - Field: ‘owner’
[09:31:34.164]   - Field: ‘envir’
[09:31:34.164]   - Field: ‘workers’
[09:31:34.164]   - Field: ‘packages’
[09:31:34.164]   - Field: ‘gc’
[09:31:34.164]   - Field: ‘job’
[09:31:34.165]   - Field: ‘conditions’
[09:31:34.165]   - Field: ‘expr’
[09:31:34.165]   - Field: ‘uuid’
[09:31:34.165]   - Field: ‘seed’
[09:31:34.165]   - Field: ‘version’
[09:31:34.165]   - Field: ‘result’
[09:31:34.165]   - Field: ‘asynchronous’
[09:31:34.165]   - Field: ‘calls’
[09:31:34.165]   - Field: ‘globals’
[09:31:34.165]   - Field: ‘stdout’
[09:31:34.166]   - Field: ‘earlySignal’
[09:31:34.166]   - Field: ‘lazy’
[09:31:34.166]   - Field: ‘state’
[09:31:34.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.166] - Launch lazy future ...
[09:31:34.166] Packages needed by the future expression (n = 0): <none>
[09:31:34.166] Packages needed by future strategies (n = 0): <none>
[09:31:34.167] {
[09:31:34.167]     {
[09:31:34.167]         {
[09:31:34.167]             ...future.startTime <- base::Sys.time()
[09:31:34.167]             {
[09:31:34.167]                 {
[09:31:34.167]                   {
[09:31:34.167]                     {
[09:31:34.167]                       base::local({
[09:31:34.167]                         has_future <- base::requireNamespace("future", 
[09:31:34.167]                           quietly = TRUE)
[09:31:34.167]                         if (has_future) {
[09:31:34.167]                           ns <- base::getNamespace("future")
[09:31:34.167]                           version <- ns[[".package"]][["version"]]
[09:31:34.167]                           if (is.null(version)) 
[09:31:34.167]                             version <- utils::packageVersion("future")
[09:31:34.167]                         }
[09:31:34.167]                         else {
[09:31:34.167]                           version <- NULL
[09:31:34.167]                         }
[09:31:34.167]                         if (!has_future || version < "1.8.0") {
[09:31:34.167]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.167]                             "", base::R.version$version.string), 
[09:31:34.167]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.167]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.167]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.167]                               "release", "version")], collapse = " "), 
[09:31:34.167]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.167]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.167]                             info)
[09:31:34.167]                           info <- base::paste(info, collapse = "; ")
[09:31:34.167]                           if (!has_future) {
[09:31:34.167]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.167]                               info)
[09:31:34.167]                           }
[09:31:34.167]                           else {
[09:31:34.167]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.167]                               info, version)
[09:31:34.167]                           }
[09:31:34.167]                           base::stop(msg)
[09:31:34.167]                         }
[09:31:34.167]                       })
[09:31:34.167]                     }
[09:31:34.167]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.167]                     base::options(mc.cores = 1L)
[09:31:34.167]                   }
[09:31:34.167]                   ...future.strategy.old <- future::plan("list")
[09:31:34.167]                   options(future.plan = NULL)
[09:31:34.167]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.167]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.167]                 }
[09:31:34.167]                 ...future.workdir <- getwd()
[09:31:34.167]             }
[09:31:34.167]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.167]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.167]         }
[09:31:34.167]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.167]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.167]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.167]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.167]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.167]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.167]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.167]             base::names(...future.oldOptions))
[09:31:34.167]     }
[09:31:34.167]     if (FALSE) {
[09:31:34.167]     }
[09:31:34.167]     else {
[09:31:34.167]         if (TRUE) {
[09:31:34.167]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.167]                 open = "w")
[09:31:34.167]         }
[09:31:34.167]         else {
[09:31:34.167]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.167]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.167]         }
[09:31:34.167]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.167]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.167]             base::sink(type = "output", split = FALSE)
[09:31:34.167]             base::close(...future.stdout)
[09:31:34.167]         }, add = TRUE)
[09:31:34.167]     }
[09:31:34.167]     ...future.frame <- base::sys.nframe()
[09:31:34.167]     ...future.conditions <- base::list()
[09:31:34.167]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.167]     if (FALSE) {
[09:31:34.167]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.167]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.167]     }
[09:31:34.167]     ...future.result <- base::tryCatch({
[09:31:34.167]         base::withCallingHandlers({
[09:31:34.167]             ...future.value <- base::withVisible(base::local({
[09:31:34.167]                 withCallingHandlers({
[09:31:34.167]                   {
[09:31:34.167]                     b <- a * ii
[09:31:34.167]                     a <- 0
[09:31:34.167]                     b
[09:31:34.167]                   }
[09:31:34.167]                 }, immediateCondition = function(cond) {
[09:31:34.167]                   save_rds <- function (object, pathname, ...) 
[09:31:34.167]                   {
[09:31:34.167]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.167]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.167]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.167]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.167]                         fi_tmp[["mtime"]])
[09:31:34.167]                     }
[09:31:34.167]                     tryCatch({
[09:31:34.167]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.167]                     }, error = function(ex) {
[09:31:34.167]                       msg <- conditionMessage(ex)
[09:31:34.167]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.167]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.167]                         fi_tmp[["mtime"]], msg)
[09:31:34.167]                       ex$message <- msg
[09:31:34.167]                       stop(ex)
[09:31:34.167]                     })
[09:31:34.167]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.167]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.167]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.167]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.167]                       fi <- file.info(pathname)
[09:31:34.167]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.167]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.167]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.167]                         fi[["size"]], fi[["mtime"]])
[09:31:34.167]                       stop(msg)
[09:31:34.167]                     }
[09:31:34.167]                     invisible(pathname)
[09:31:34.167]                   }
[09:31:34.167]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.167]                     rootPath = tempdir()) 
[09:31:34.167]                   {
[09:31:34.167]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.167]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.167]                       tmpdir = path, fileext = ".rds")
[09:31:34.167]                     save_rds(obj, file)
[09:31:34.167]                   }
[09:31:34.167]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.167]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.167]                   {
[09:31:34.167]                     inherits <- base::inherits
[09:31:34.167]                     invokeRestart <- base::invokeRestart
[09:31:34.167]                     is.null <- base::is.null
[09:31:34.167]                     muffled <- FALSE
[09:31:34.167]                     if (inherits(cond, "message")) {
[09:31:34.167]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.167]                       if (muffled) 
[09:31:34.167]                         invokeRestart("muffleMessage")
[09:31:34.167]                     }
[09:31:34.167]                     else if (inherits(cond, "warning")) {
[09:31:34.167]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.167]                       if (muffled) 
[09:31:34.167]                         invokeRestart("muffleWarning")
[09:31:34.167]                     }
[09:31:34.167]                     else if (inherits(cond, "condition")) {
[09:31:34.167]                       if (!is.null(pattern)) {
[09:31:34.167]                         computeRestarts <- base::computeRestarts
[09:31:34.167]                         grepl <- base::grepl
[09:31:34.167]                         restarts <- computeRestarts(cond)
[09:31:34.167]                         for (restart in restarts) {
[09:31:34.167]                           name <- restart$name
[09:31:34.167]                           if (is.null(name)) 
[09:31:34.167]                             next
[09:31:34.167]                           if (!grepl(pattern, name)) 
[09:31:34.167]                             next
[09:31:34.167]                           invokeRestart(restart)
[09:31:34.167]                           muffled <- TRUE
[09:31:34.167]                           break
[09:31:34.167]                         }
[09:31:34.167]                       }
[09:31:34.167]                     }
[09:31:34.167]                     invisible(muffled)
[09:31:34.167]                   }
[09:31:34.167]                   muffleCondition(cond)
[09:31:34.167]                 })
[09:31:34.167]             }))
[09:31:34.167]             future::FutureResult(value = ...future.value$value, 
[09:31:34.167]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.167]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.167]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.167]                     ...future.globalenv.names))
[09:31:34.167]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.167]         }, condition = base::local({
[09:31:34.167]             c <- base::c
[09:31:34.167]             inherits <- base::inherits
[09:31:34.167]             invokeRestart <- base::invokeRestart
[09:31:34.167]             length <- base::length
[09:31:34.167]             list <- base::list
[09:31:34.167]             seq.int <- base::seq.int
[09:31:34.167]             signalCondition <- base::signalCondition
[09:31:34.167]             sys.calls <- base::sys.calls
[09:31:34.167]             `[[` <- base::`[[`
[09:31:34.167]             `+` <- base::`+`
[09:31:34.167]             `<<-` <- base::`<<-`
[09:31:34.167]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.167]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.167]                   3L)]
[09:31:34.167]             }
[09:31:34.167]             function(cond) {
[09:31:34.167]                 is_error <- inherits(cond, "error")
[09:31:34.167]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.167]                   NULL)
[09:31:34.167]                 if (is_error) {
[09:31:34.167]                   sessionInformation <- function() {
[09:31:34.167]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.167]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.167]                       search = base::search(), system = base::Sys.info())
[09:31:34.167]                   }
[09:31:34.167]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.167]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.167]                     cond$call), session = sessionInformation(), 
[09:31:34.167]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.167]                   signalCondition(cond)
[09:31:34.167]                 }
[09:31:34.167]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.167]                 "immediateCondition"))) {
[09:31:34.167]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.167]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.167]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.167]                   if (TRUE && !signal) {
[09:31:34.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.167]                     {
[09:31:34.167]                       inherits <- base::inherits
[09:31:34.167]                       invokeRestart <- base::invokeRestart
[09:31:34.167]                       is.null <- base::is.null
[09:31:34.167]                       muffled <- FALSE
[09:31:34.167]                       if (inherits(cond, "message")) {
[09:31:34.167]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.167]                         if (muffled) 
[09:31:34.167]                           invokeRestart("muffleMessage")
[09:31:34.167]                       }
[09:31:34.167]                       else if (inherits(cond, "warning")) {
[09:31:34.167]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.167]                         if (muffled) 
[09:31:34.167]                           invokeRestart("muffleWarning")
[09:31:34.167]                       }
[09:31:34.167]                       else if (inherits(cond, "condition")) {
[09:31:34.167]                         if (!is.null(pattern)) {
[09:31:34.167]                           computeRestarts <- base::computeRestarts
[09:31:34.167]                           grepl <- base::grepl
[09:31:34.167]                           restarts <- computeRestarts(cond)
[09:31:34.167]                           for (restart in restarts) {
[09:31:34.167]                             name <- restart$name
[09:31:34.167]                             if (is.null(name)) 
[09:31:34.167]                               next
[09:31:34.167]                             if (!grepl(pattern, name)) 
[09:31:34.167]                               next
[09:31:34.167]                             invokeRestart(restart)
[09:31:34.167]                             muffled <- TRUE
[09:31:34.167]                             break
[09:31:34.167]                           }
[09:31:34.167]                         }
[09:31:34.167]                       }
[09:31:34.167]                       invisible(muffled)
[09:31:34.167]                     }
[09:31:34.167]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.167]                   }
[09:31:34.167]                 }
[09:31:34.167]                 else {
[09:31:34.167]                   if (TRUE) {
[09:31:34.167]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.167]                     {
[09:31:34.167]                       inherits <- base::inherits
[09:31:34.167]                       invokeRestart <- base::invokeRestart
[09:31:34.167]                       is.null <- base::is.null
[09:31:34.167]                       muffled <- FALSE
[09:31:34.167]                       if (inherits(cond, "message")) {
[09:31:34.167]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.167]                         if (muffled) 
[09:31:34.167]                           invokeRestart("muffleMessage")
[09:31:34.167]                       }
[09:31:34.167]                       else if (inherits(cond, "warning")) {
[09:31:34.167]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.167]                         if (muffled) 
[09:31:34.167]                           invokeRestart("muffleWarning")
[09:31:34.167]                       }
[09:31:34.167]                       else if (inherits(cond, "condition")) {
[09:31:34.167]                         if (!is.null(pattern)) {
[09:31:34.167]                           computeRestarts <- base::computeRestarts
[09:31:34.167]                           grepl <- base::grepl
[09:31:34.167]                           restarts <- computeRestarts(cond)
[09:31:34.167]                           for (restart in restarts) {
[09:31:34.167]                             name <- restart$name
[09:31:34.167]                             if (is.null(name)) 
[09:31:34.167]                               next
[09:31:34.167]                             if (!grepl(pattern, name)) 
[09:31:34.167]                               next
[09:31:34.167]                             invokeRestart(restart)
[09:31:34.167]                             muffled <- TRUE
[09:31:34.167]                             break
[09:31:34.167]                           }
[09:31:34.167]                         }
[09:31:34.167]                       }
[09:31:34.167]                       invisible(muffled)
[09:31:34.167]                     }
[09:31:34.167]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.167]                   }
[09:31:34.167]                 }
[09:31:34.167]             }
[09:31:34.167]         }))
[09:31:34.167]     }, error = function(ex) {
[09:31:34.167]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.167]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.167]                 ...future.rng), started = ...future.startTime, 
[09:31:34.167]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.167]             version = "1.8"), class = "FutureResult")
[09:31:34.167]     }, finally = {
[09:31:34.167]         if (!identical(...future.workdir, getwd())) 
[09:31:34.167]             setwd(...future.workdir)
[09:31:34.167]         {
[09:31:34.167]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.167]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.167]             }
[09:31:34.167]             base::options(...future.oldOptions)
[09:31:34.167]             if (.Platform$OS.type == "windows") {
[09:31:34.167]                 old_names <- names(...future.oldEnvVars)
[09:31:34.167]                 envs <- base::Sys.getenv()
[09:31:34.167]                 names <- names(envs)
[09:31:34.167]                 common <- intersect(names, old_names)
[09:31:34.167]                 added <- setdiff(names, old_names)
[09:31:34.167]                 removed <- setdiff(old_names, names)
[09:31:34.167]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.167]                   envs[common]]
[09:31:34.167]                 NAMES <- toupper(changed)
[09:31:34.167]                 args <- list()
[09:31:34.167]                 for (kk in seq_along(NAMES)) {
[09:31:34.167]                   name <- changed[[kk]]
[09:31:34.167]                   NAME <- NAMES[[kk]]
[09:31:34.167]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.167]                     next
[09:31:34.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.167]                 }
[09:31:34.167]                 NAMES <- toupper(added)
[09:31:34.167]                 for (kk in seq_along(NAMES)) {
[09:31:34.167]                   name <- added[[kk]]
[09:31:34.167]                   NAME <- NAMES[[kk]]
[09:31:34.167]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.167]                     next
[09:31:34.167]                   args[[name]] <- ""
[09:31:34.167]                 }
[09:31:34.167]                 NAMES <- toupper(removed)
[09:31:34.167]                 for (kk in seq_along(NAMES)) {
[09:31:34.167]                   name <- removed[[kk]]
[09:31:34.167]                   NAME <- NAMES[[kk]]
[09:31:34.167]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.167]                     next
[09:31:34.167]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.167]                 }
[09:31:34.167]                 if (length(args) > 0) 
[09:31:34.167]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.167]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.167]             }
[09:31:34.167]             else {
[09:31:34.167]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.167]             }
[09:31:34.167]             {
[09:31:34.167]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.167]                   0L) {
[09:31:34.167]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.167]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.167]                   base::options(opts)
[09:31:34.167]                 }
[09:31:34.167]                 {
[09:31:34.167]                   {
[09:31:34.167]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.167]                     NULL
[09:31:34.167]                   }
[09:31:34.167]                   options(future.plan = NULL)
[09:31:34.167]                   if (is.na(NA_character_)) 
[09:31:34.167]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.167]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.167]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.167]                     .init = FALSE)
[09:31:34.167]                 }
[09:31:34.167]             }
[09:31:34.167]         }
[09:31:34.167]     })
[09:31:34.167]     if (TRUE) {
[09:31:34.167]         base::sink(type = "output", split = FALSE)
[09:31:34.167]         if (TRUE) {
[09:31:34.167]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.167]         }
[09:31:34.167]         else {
[09:31:34.167]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.167]         }
[09:31:34.167]         base::close(...future.stdout)
[09:31:34.167]         ...future.stdout <- NULL
[09:31:34.167]     }
[09:31:34.167]     ...future.result$conditions <- ...future.conditions
[09:31:34.167]     ...future.result$finished <- base::Sys.time()
[09:31:34.167]     ...future.result
[09:31:34.167] }
[09:31:34.169] assign_globals() ...
[09:31:34.169] List of 2
[09:31:34.169]  $ a : num 1
[09:31:34.169]  $ ii: int 1
[09:31:34.169]  - attr(*, "where")=List of 2
[09:31:34.169]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.169]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.169]  - attr(*, "resolved")= logi TRUE
[09:31:34.169]  - attr(*, "total_size")= num 112
[09:31:34.169]  - attr(*, "already-done")= logi TRUE
[09:31:34.173] - copied ‘a’ to environment
[09:31:34.173] - copied ‘ii’ to environment
[09:31:34.173] assign_globals() ... done
[09:31:34.173] requestCore(): workers = 2
[09:31:34.175] MulticoreFuture started
[09:31:34.175] - Launch lazy future ... done
[09:31:34.175] run() for ‘MulticoreFuture’ ... done
[09:31:34.176] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.177] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.176] List of future strategies:
[09:31:34.176] 1. sequential:
[09:31:34.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.176]    - tweaked: FALSE
[09:31:34.176]    - call: NULL
[09:31:34.177] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
 [09:31:34.177] plan(): nbrOfWorkers() = 1
 R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.179] plan(): Setting new future strategy stack:
[09:31:34.179] List of future strategies:
[09:31:34.179] 1. multicore:
[09:31:34.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.179]    - tweaked: FALSE
[09:31:34.179]    - call: plan(strategy)
[09:31:34.184] plan(): nbrOfWorkers() = 2
[09:31:34.181] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.184] Searching for globals ... DONE
[09:31:34.185] Resolving globals: TRUE
[09:31:34.185] Resolving any globals that are futures ...
[09:31:34.185] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.186] Resolving any globals that are futures ... DONE
[09:31:34.187] Resolving futures part of globals (recursively) ...
[09:31:34.188] resolve() on list ...
[09:31:34.188]  recursive: 99
[09:31:34.189]  length: 2
[09:31:34.189]  elements: ‘a’, ‘ii’
[09:31:34.189]  length: 1 (resolved future 1)
[09:31:34.189]  length: 0 (resolved future 2)
[09:31:34.190] resolve() on list ... DONE
[09:31:34.190] - globals: [2] ‘a’, ‘ii’
[09:31:34.190] Resolving futures part of globals (recursively) ... DONE
[09:31:34.190] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.191] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.191] - globals: [2] ‘a’, ‘ii’
[09:31:34.191] 
[09:31:34.192] getGlobalsAndPackages() ... DONE
[09:31:34.192] run() for ‘Future’ ...
[09:31:34.192] - state: ‘created’
[09:31:34.193] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.197] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.197]   - Field: ‘label’
[09:31:34.197]   - Field: ‘local’
[09:31:34.198]   - Field: ‘owner’
[09:31:34.198]   - Field: ‘envir’
[09:31:34.198]   - Field: ‘workers’
[09:31:34.198]   - Field: ‘packages’
[09:31:34.198]   - Field: ‘gc’
[09:31:34.198]   - Field: ‘job’
[09:31:34.198]   - Field: ‘conditions’
[09:31:34.199]   - Field: ‘expr’
[09:31:34.199]   - Field: ‘uuid’
[09:31:34.199]   - Field: ‘seed’
[09:31:34.199]   - Field: ‘version’
[09:31:34.199]   - Field: ‘result’
[09:31:34.199]   - Field: ‘asynchronous’
[09:31:34.199]   - Field: ‘calls’
[09:31:34.199]   - Field: ‘globals’
[09:31:34.200]   - Field: ‘stdout’
[09:31:34.200]   - Field: ‘earlySignal’
[09:31:34.200]   - Field: ‘lazy’
[09:31:34.200]   - Field: ‘state’
[09:31:34.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.200] - Launch lazy future ...
[09:31:34.201] Packages needed by the future expression (n = 0): <none>
[09:31:34.201] Packages needed by future strategies (n = 0): <none>
[09:31:34.201] {
[09:31:34.201]     {
[09:31:34.201]         {
[09:31:34.201]             ...future.startTime <- base::Sys.time()
[09:31:34.201]             {
[09:31:34.201]                 {
[09:31:34.201]                   {
[09:31:34.201]                     {
[09:31:34.201]                       base::local({
[09:31:34.201]                         has_future <- base::requireNamespace("future", 
[09:31:34.201]                           quietly = TRUE)
[09:31:34.201]                         if (has_future) {
[09:31:34.201]                           ns <- base::getNamespace("future")
[09:31:34.201]                           version <- ns[[".package"]][["version"]]
[09:31:34.201]                           if (is.null(version)) 
[09:31:34.201]                             version <- utils::packageVersion("future")
[09:31:34.201]                         }
[09:31:34.201]                         else {
[09:31:34.201]                           version <- NULL
[09:31:34.201]                         }
[09:31:34.201]                         if (!has_future || version < "1.8.0") {
[09:31:34.201]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.201]                             "", base::R.version$version.string), 
[09:31:34.201]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.201]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.201]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.201]                               "release", "version")], collapse = " "), 
[09:31:34.201]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.201]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.201]                             info)
[09:31:34.201]                           info <- base::paste(info, collapse = "; ")
[09:31:34.201]                           if (!has_future) {
[09:31:34.201]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.201]                               info)
[09:31:34.201]                           }
[09:31:34.201]                           else {
[09:31:34.201]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.201]                               info, version)
[09:31:34.201]                           }
[09:31:34.201]                           base::stop(msg)
[09:31:34.201]                         }
[09:31:34.201]                       })
[09:31:34.201]                     }
[09:31:34.201]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.201]                     base::options(mc.cores = 1L)
[09:31:34.201]                   }
[09:31:34.201]                   ...future.strategy.old <- future::plan("list")
[09:31:34.201]                   options(future.plan = NULL)
[09:31:34.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.201]                 }
[09:31:34.201]                 ...future.workdir <- getwd()
[09:31:34.201]             }
[09:31:34.201]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.201]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.201]         }
[09:31:34.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.201]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.201]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.201]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.201]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.201]             base::names(...future.oldOptions))
[09:31:34.201]     }
[09:31:34.201]     if (FALSE) {
[09:31:34.201]     }
[09:31:34.201]     else {
[09:31:34.201]         if (TRUE) {
[09:31:34.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.201]                 open = "w")
[09:31:34.201]         }
[09:31:34.201]         else {
[09:31:34.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.201]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.201]         }
[09:31:34.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.201]             base::sink(type = "output", split = FALSE)
[09:31:34.201]             base::close(...future.stdout)
[09:31:34.201]         }, add = TRUE)
[09:31:34.201]     }
[09:31:34.201]     ...future.frame <- base::sys.nframe()
[09:31:34.201]     ...future.conditions <- base::list()
[09:31:34.201]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.201]     if (FALSE) {
[09:31:34.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.201]     }
[09:31:34.201]     ...future.result <- base::tryCatch({
[09:31:34.201]         base::withCallingHandlers({
[09:31:34.201]             ...future.value <- base::withVisible(base::local({
[09:31:34.201]                 withCallingHandlers({
[09:31:34.201]                   {
[09:31:34.201]                     b <- a * ii
[09:31:34.201]                     a <- 0
[09:31:34.201]                     b
[09:31:34.201]                   }
[09:31:34.201]                 }, immediateCondition = function(cond) {
[09:31:34.201]                   save_rds <- function (object, pathname, ...) 
[09:31:34.201]                   {
[09:31:34.201]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.201]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.201]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.201]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.201]                         fi_tmp[["mtime"]])
[09:31:34.201]                     }
[09:31:34.201]                     tryCatch({
[09:31:34.201]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.201]                     }, error = function(ex) {
[09:31:34.201]                       msg <- conditionMessage(ex)
[09:31:34.201]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.201]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.201]                         fi_tmp[["mtime"]], msg)
[09:31:34.201]                       ex$message <- msg
[09:31:34.201]                       stop(ex)
[09:31:34.201]                     })
[09:31:34.201]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.201]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.201]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.201]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.201]                       fi <- file.info(pathname)
[09:31:34.201]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.201]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.201]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.201]                         fi[["size"]], fi[["mtime"]])
[09:31:34.201]                       stop(msg)
[09:31:34.201]                     }
[09:31:34.201]                     invisible(pathname)
[09:31:34.201]                   }
[09:31:34.201]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.201]                     rootPath = tempdir()) 
[09:31:34.201]                   {
[09:31:34.201]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.201]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.201]                       tmpdir = path, fileext = ".rds")
[09:31:34.201]                     save_rds(obj, file)
[09:31:34.201]                   }
[09:31:34.201]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.201]                   {
[09:31:34.201]                     inherits <- base::inherits
[09:31:34.201]                     invokeRestart <- base::invokeRestart
[09:31:34.201]                     is.null <- base::is.null
[09:31:34.201]                     muffled <- FALSE
[09:31:34.201]                     if (inherits(cond, "message")) {
[09:31:34.201]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.201]                       if (muffled) 
[09:31:34.201]                         invokeRestart("muffleMessage")
[09:31:34.201]                     }
[09:31:34.201]                     else if (inherits(cond, "warning")) {
[09:31:34.201]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.201]                       if (muffled) 
[09:31:34.201]                         invokeRestart("muffleWarning")
[09:31:34.201]                     }
[09:31:34.201]                     else if (inherits(cond, "condition")) {
[09:31:34.201]                       if (!is.null(pattern)) {
[09:31:34.201]                         computeRestarts <- base::computeRestarts
[09:31:34.201]                         grepl <- base::grepl
[09:31:34.201]                         restarts <- computeRestarts(cond)
[09:31:34.201]                         for (restart in restarts) {
[09:31:34.201]                           name <- restart$name
[09:31:34.201]                           if (is.null(name)) 
[09:31:34.201]                             next
[09:31:34.201]                           if (!grepl(pattern, name)) 
[09:31:34.201]                             next
[09:31:34.201]                           invokeRestart(restart)
[09:31:34.201]                           muffled <- TRUE
[09:31:34.201]                           break
[09:31:34.201]                         }
[09:31:34.201]                       }
[09:31:34.201]                     }
[09:31:34.201]                     invisible(muffled)
[09:31:34.201]                   }
[09:31:34.201]                   muffleCondition(cond)
[09:31:34.201]                 })
[09:31:34.201]             }))
[09:31:34.201]             future::FutureResult(value = ...future.value$value, 
[09:31:34.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.201]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.201]                     ...future.globalenv.names))
[09:31:34.201]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.201]         }, condition = base::local({
[09:31:34.201]             c <- base::c
[09:31:34.201]             inherits <- base::inherits
[09:31:34.201]             invokeRestart <- base::invokeRestart
[09:31:34.201]             length <- base::length
[09:31:34.201]             list <- base::list
[09:31:34.201]             seq.int <- base::seq.int
[09:31:34.201]             signalCondition <- base::signalCondition
[09:31:34.201]             sys.calls <- base::sys.calls
[09:31:34.201]             `[[` <- base::`[[`
[09:31:34.201]             `+` <- base::`+`
[09:31:34.201]             `<<-` <- base::`<<-`
[09:31:34.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.201]                   3L)]
[09:31:34.201]             }
[09:31:34.201]             function(cond) {
[09:31:34.201]                 is_error <- inherits(cond, "error")
[09:31:34.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.201]                   NULL)
[09:31:34.201]                 if (is_error) {
[09:31:34.201]                   sessionInformation <- function() {
[09:31:34.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.201]                       search = base::search(), system = base::Sys.info())
[09:31:34.201]                   }
[09:31:34.201]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.201]                     cond$call), session = sessionInformation(), 
[09:31:34.201]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.201]                   signalCondition(cond)
[09:31:34.201]                 }
[09:31:34.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.201]                 "immediateCondition"))) {
[09:31:34.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.201]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.201]                   if (TRUE && !signal) {
[09:31:34.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.201]                     {
[09:31:34.201]                       inherits <- base::inherits
[09:31:34.201]                       invokeRestart <- base::invokeRestart
[09:31:34.201]                       is.null <- base::is.null
[09:31:34.201]                       muffled <- FALSE
[09:31:34.201]                       if (inherits(cond, "message")) {
[09:31:34.201]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.201]                         if (muffled) 
[09:31:34.201]                           invokeRestart("muffleMessage")
[09:31:34.201]                       }
[09:31:34.201]                       else if (inherits(cond, "warning")) {
[09:31:34.201]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.201]                         if (muffled) 
[09:31:34.201]                           invokeRestart("muffleWarning")
[09:31:34.201]                       }
[09:31:34.201]                       else if (inherits(cond, "condition")) {
[09:31:34.201]                         if (!is.null(pattern)) {
[09:31:34.201]                           computeRestarts <- base::computeRestarts
[09:31:34.201]                           grepl <- base::grepl
[09:31:34.201]                           restarts <- computeRestarts(cond)
[09:31:34.201]                           for (restart in restarts) {
[09:31:34.201]                             name <- restart$name
[09:31:34.201]                             if (is.null(name)) 
[09:31:34.201]                               next
[09:31:34.201]                             if (!grepl(pattern, name)) 
[09:31:34.201]                               next
[09:31:34.201]                             invokeRestart(restart)
[09:31:34.201]                             muffled <- TRUE
[09:31:34.201]                             break
[09:31:34.201]                           }
[09:31:34.201]                         }
[09:31:34.201]                       }
[09:31:34.201]                       invisible(muffled)
[09:31:34.201]                     }
[09:31:34.201]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.201]                   }
[09:31:34.201]                 }
[09:31:34.201]                 else {
[09:31:34.201]                   if (TRUE) {
[09:31:34.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.201]                     {
[09:31:34.201]                       inherits <- base::inherits
[09:31:34.201]                       invokeRestart <- base::invokeRestart
[09:31:34.201]                       is.null <- base::is.null
[09:31:34.201]                       muffled <- FALSE
[09:31:34.201]                       if (inherits(cond, "message")) {
[09:31:34.201]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.201]                         if (muffled) 
[09:31:34.201]                           invokeRestart("muffleMessage")
[09:31:34.201]                       }
[09:31:34.201]                       else if (inherits(cond, "warning")) {
[09:31:34.201]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.201]                         if (muffled) 
[09:31:34.201]                           invokeRestart("muffleWarning")
[09:31:34.201]                       }
[09:31:34.201]                       else if (inherits(cond, "condition")) {
[09:31:34.201]                         if (!is.null(pattern)) {
[09:31:34.201]                           computeRestarts <- base::computeRestarts
[09:31:34.201]                           grepl <- base::grepl
[09:31:34.201]                           restarts <- computeRestarts(cond)
[09:31:34.201]                           for (restart in restarts) {
[09:31:34.201]                             name <- restart$name
[09:31:34.201]                             if (is.null(name)) 
[09:31:34.201]                               next
[09:31:34.201]                             if (!grepl(pattern, name)) 
[09:31:34.201]                               next
[09:31:34.201]                             invokeRestart(restart)
[09:31:34.201]                             muffled <- TRUE
[09:31:34.201]                             break
[09:31:34.201]                           }
[09:31:34.201]                         }
[09:31:34.201]                       }
[09:31:34.201]                       invisible(muffled)
[09:31:34.201]                     }
[09:31:34.201]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.201]                   }
[09:31:34.201]                 }
[09:31:34.201]             }
[09:31:34.201]         }))
[09:31:34.201]     }, error = function(ex) {
[09:31:34.201]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.201]                 ...future.rng), started = ...future.startTime, 
[09:31:34.201]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.201]             version = "1.8"), class = "FutureResult")
[09:31:34.201]     }, finally = {
[09:31:34.201]         if (!identical(...future.workdir, getwd())) 
[09:31:34.201]             setwd(...future.workdir)
[09:31:34.201]         {
[09:31:34.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.201]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.201]             }
[09:31:34.201]             base::options(...future.oldOptions)
[09:31:34.201]             if (.Platform$OS.type == "windows") {
[09:31:34.201]                 old_names <- names(...future.oldEnvVars)
[09:31:34.201]                 envs <- base::Sys.getenv()
[09:31:34.201]                 names <- names(envs)
[09:31:34.201]                 common <- intersect(names, old_names)
[09:31:34.201]                 added <- setdiff(names, old_names)
[09:31:34.201]                 removed <- setdiff(old_names, names)
[09:31:34.201]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.201]                   envs[common]]
[09:31:34.201]                 NAMES <- toupper(changed)
[09:31:34.201]                 args <- list()
[09:31:34.201]                 for (kk in seq_along(NAMES)) {
[09:31:34.201]                   name <- changed[[kk]]
[09:31:34.201]                   NAME <- NAMES[[kk]]
[09:31:34.201]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.201]                     next
[09:31:34.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.201]                 }
[09:31:34.201]                 NAMES <- toupper(added)
[09:31:34.201]                 for (kk in seq_along(NAMES)) {
[09:31:34.201]                   name <- added[[kk]]
[09:31:34.201]                   NAME <- NAMES[[kk]]
[09:31:34.201]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.201]                     next
[09:31:34.201]                   args[[name]] <- ""
[09:31:34.201]                 }
[09:31:34.201]                 NAMES <- toupper(removed)
[09:31:34.201]                 for (kk in seq_along(NAMES)) {
[09:31:34.201]                   name <- removed[[kk]]
[09:31:34.201]                   NAME <- NAMES[[kk]]
[09:31:34.201]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.201]                     next
[09:31:34.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.201]                 }
[09:31:34.201]                 if (length(args) > 0) 
[09:31:34.201]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.201]             }
[09:31:34.201]             else {
[09:31:34.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.201]             }
[09:31:34.201]             {
[09:31:34.201]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.201]                   0L) {
[09:31:34.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.201]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.201]                   base::options(opts)
[09:31:34.201]                 }
[09:31:34.201]                 {
[09:31:34.201]                   {
[09:31:34.201]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.201]                     NULL
[09:31:34.201]                   }
[09:31:34.201]                   options(future.plan = NULL)
[09:31:34.201]                   if (is.na(NA_character_)) 
[09:31:34.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.201]                     .init = FALSE)
[09:31:34.201]                 }
[09:31:34.201]             }
[09:31:34.201]         }
[09:31:34.201]     })
[09:31:34.201]     if (TRUE) {
[09:31:34.201]         base::sink(type = "output", split = FALSE)
[09:31:34.201]         if (TRUE) {
[09:31:34.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.201]         }
[09:31:34.201]         else {
[09:31:34.201]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.201]         }
[09:31:34.201]         base::close(...future.stdout)
[09:31:34.201]         ...future.stdout <- NULL
[09:31:34.201]     }
[09:31:34.201]     ...future.result$conditions <- ...future.conditions
[09:31:34.201]     ...future.result$finished <- base::Sys.time()
[09:31:34.201]     ...future.result
[09:31:34.201] }
[09:31:34.204] assign_globals() ...
[09:31:34.204] List of 2
[09:31:34.204]  $ a : num 1
[09:31:34.204]  $ ii: int 2
[09:31:34.204]  - attr(*, "where")=List of 2
[09:31:34.204]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.204]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.204]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.204]  - attr(*, "resolved")= logi TRUE
[09:31:34.204]  - attr(*, "total_size")= num 112
[09:31:34.204]  - attr(*, "already-done")= logi TRUE
[09:31:34.208] - copied ‘a’ to environment
[09:31:34.209] - copied ‘ii’ to environment
[09:31:34.209] assign_globals() ... done
[09:31:34.209] requestCore(): workers = 2
[09:31:34.211] MulticoreFuture started
[09:31:34.211] - Launch lazy future ... done
[09:31:34.212] run() for ‘MulticoreFuture’ ... done
[09:31:34.212] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.213] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.213] Searching for globals...
[09:31:34.212] List of future strategies:
[09:31:34.212] 1. sequential:
[09:31:34.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.212]    - tweaked: FALSE
[09:31:34.212]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.214] plan(): nbrOfWorkers() = 1
[09:31:34.215] plan(): Setting new future strategy stack:
[09:31:34.216] List of future strategies:
[09:31:34.216] 1. multicore:
[09:31:34.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.216]    - tweaked: FALSE
[09:31:34.216]    - call: plan(strategy)
[09:31:34.217] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.217] Searching for globals ... DONE
[09:31:34.217] Resolving globals: TRUE
[09:31:34.217] Resolving any globals that are futures ...
[09:31:34.218] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.218] Resolving any globals that are futures ... DONE
[09:31:34.218] Resolving futures part of globals (recursively) ...
[09:31:34.219] resolve() on list ...
[09:31:34.219]  recursive: 99
[09:31:34.219]  length: 2
[09:31:34.219]  elements: ‘a’, ‘ii’
[09:31:34.220]  length: 1 (resolved future 1)
[09:31:34.220]  length: 0 (resolved future 2)
[09:31:34.220] resolve() on list ... DONE
[09:31:34.220] - globals: [2] ‘a’, ‘ii’
[09:31:34.220] Resolving futures part of globals (recursively) ... DONE
[09:31:34.220] plan(): nbrOfWorkers() = 2
[09:31:34.220] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.221] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.221] - globals: [2] ‘a’, ‘ii’
[09:31:34.221] 
[09:31:34.222] getGlobalsAndPackages() ... DONE
[09:31:34.222] run() for ‘Future’ ...
[09:31:34.222] - state: ‘created’
[09:31:34.222] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.232] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.232] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.232]   - Field: ‘label’
[09:31:34.233]   - Field: ‘local’
[09:31:34.233]   - Field: ‘owner’
[09:31:34.233]   - Field: ‘envir’
[09:31:34.233]   - Field: ‘workers’
[09:31:34.233]   - Field: ‘packages’
[09:31:34.234]   - Field: ‘gc’
[09:31:34.234]   - Field: ‘job’
[09:31:34.234]   - Field: ‘conditions’
[09:31:34.234]   - Field: ‘expr’
[09:31:34.234]   - Field: ‘uuid’
[09:31:34.234]   - Field: ‘seed’
[09:31:34.235]   - Field: ‘version’
[09:31:34.235]   - Field: ‘result’
[09:31:34.235]   - Field: ‘asynchronous’
[09:31:34.235]   - Field: ‘calls’
[09:31:34.235]   - Field: ‘globals’
[09:31:34.235]   - Field: ‘stdout’
[09:31:34.235]   - Field: ‘earlySignal’
[09:31:34.236]   - Field: ‘lazy’
[09:31:34.236]   - Field: ‘state’
[09:31:34.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.236] - Launch lazy future ...
[09:31:34.236] Packages needed by the future expression (n = 0): <none>
[09:31:34.237] Packages needed by future strategies (n = 0): <none>
[09:31:34.237] {
[09:31:34.237]     {
[09:31:34.237]         {
[09:31:34.237]             ...future.startTime <- base::Sys.time()
[09:31:34.237]             {
[09:31:34.237]                 {
[09:31:34.237]                   {
[09:31:34.237]                     {
[09:31:34.237]                       base::local({
[09:31:34.237]                         has_future <- base::requireNamespace("future", 
[09:31:34.237]                           quietly = TRUE)
[09:31:34.237]                         if (has_future) {
[09:31:34.237]                           ns <- base::getNamespace("future")
[09:31:34.237]                           version <- ns[[".package"]][["version"]]
[09:31:34.237]                           if (is.null(version)) 
[09:31:34.237]                             version <- utils::packageVersion("future")
[09:31:34.237]                         }
[09:31:34.237]                         else {
[09:31:34.237]                           version <- NULL
[09:31:34.237]                         }
[09:31:34.237]                         if (!has_future || version < "1.8.0") {
[09:31:34.237]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.237]                             "", base::R.version$version.string), 
[09:31:34.237]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.237]                               "release", "version")], collapse = " "), 
[09:31:34.237]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.237]                             info)
[09:31:34.237]                           info <- base::paste(info, collapse = "; ")
[09:31:34.237]                           if (!has_future) {
[09:31:34.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.237]                               info)
[09:31:34.237]                           }
[09:31:34.237]                           else {
[09:31:34.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.237]                               info, version)
[09:31:34.237]                           }
[09:31:34.237]                           base::stop(msg)
[09:31:34.237]                         }
[09:31:34.237]                       })
[09:31:34.237]                     }
[09:31:34.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.237]                     base::options(mc.cores = 1L)
[09:31:34.237]                   }
[09:31:34.237]                   ...future.strategy.old <- future::plan("list")
[09:31:34.237]                   options(future.plan = NULL)
[09:31:34.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.237]                 }
[09:31:34.237]                 ...future.workdir <- getwd()
[09:31:34.237]             }
[09:31:34.237]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.237]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.237]         }
[09:31:34.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.237]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.237]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.237]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.237]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.237]             base::names(...future.oldOptions))
[09:31:34.237]     }
[09:31:34.237]     if (FALSE) {
[09:31:34.237]     }
[09:31:34.237]     else {
[09:31:34.237]         if (TRUE) {
[09:31:34.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.237]                 open = "w")
[09:31:34.237]         }
[09:31:34.237]         else {
[09:31:34.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.237]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.237]         }
[09:31:34.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.237]             base::sink(type = "output", split = FALSE)
[09:31:34.237]             base::close(...future.stdout)
[09:31:34.237]         }, add = TRUE)
[09:31:34.237]     }
[09:31:34.237]     ...future.frame <- base::sys.nframe()
[09:31:34.237]     ...future.conditions <- base::list()
[09:31:34.237]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.237]     if (FALSE) {
[09:31:34.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.237]     }
[09:31:34.237]     ...future.result <- base::tryCatch({
[09:31:34.237]         base::withCallingHandlers({
[09:31:34.237]             ...future.value <- base::withVisible(base::local({
[09:31:34.237]                 withCallingHandlers({
[09:31:34.237]                   {
[09:31:34.237]                     b <- a * ii
[09:31:34.237]                     a <- 0
[09:31:34.237]                     b
[09:31:34.237]                   }
[09:31:34.237]                 }, immediateCondition = function(cond) {
[09:31:34.237]                   save_rds <- function (object, pathname, ...) 
[09:31:34.237]                   {
[09:31:34.237]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.237]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.237]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.237]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.237]                         fi_tmp[["mtime"]])
[09:31:34.237]                     }
[09:31:34.237]                     tryCatch({
[09:31:34.237]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.237]                     }, error = function(ex) {
[09:31:34.237]                       msg <- conditionMessage(ex)
[09:31:34.237]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.237]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.237]                         fi_tmp[["mtime"]], msg)
[09:31:34.237]                       ex$message <- msg
[09:31:34.237]                       stop(ex)
[09:31:34.237]                     })
[09:31:34.237]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.237]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.237]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.237]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.237]                       fi <- file.info(pathname)
[09:31:34.237]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.237]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.237]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.237]                         fi[["size"]], fi[["mtime"]])
[09:31:34.237]                       stop(msg)
[09:31:34.237]                     }
[09:31:34.237]                     invisible(pathname)
[09:31:34.237]                   }
[09:31:34.237]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.237]                     rootPath = tempdir()) 
[09:31:34.237]                   {
[09:31:34.237]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.237]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.237]                       tmpdir = path, fileext = ".rds")
[09:31:34.237]                     save_rds(obj, file)
[09:31:34.237]                   }
[09:31:34.237]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.237]                   {
[09:31:34.237]                     inherits <- base::inherits
[09:31:34.237]                     invokeRestart <- base::invokeRestart
[09:31:34.237]                     is.null <- base::is.null
[09:31:34.237]                     muffled <- FALSE
[09:31:34.237]                     if (inherits(cond, "message")) {
[09:31:34.237]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.237]                       if (muffled) 
[09:31:34.237]                         invokeRestart("muffleMessage")
[09:31:34.237]                     }
[09:31:34.237]                     else if (inherits(cond, "warning")) {
[09:31:34.237]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.237]                       if (muffled) 
[09:31:34.237]                         invokeRestart("muffleWarning")
[09:31:34.237]                     }
[09:31:34.237]                     else if (inherits(cond, "condition")) {
[09:31:34.237]                       if (!is.null(pattern)) {
[09:31:34.237]                         computeRestarts <- base::computeRestarts
[09:31:34.237]                         grepl <- base::grepl
[09:31:34.237]                         restarts <- computeRestarts(cond)
[09:31:34.237]                         for (restart in restarts) {
[09:31:34.237]                           name <- restart$name
[09:31:34.237]                           if (is.null(name)) 
[09:31:34.237]                             next
[09:31:34.237]                           if (!grepl(pattern, name)) 
[09:31:34.237]                             next
[09:31:34.237]                           invokeRestart(restart)
[09:31:34.237]                           muffled <- TRUE
[09:31:34.237]                           break
[09:31:34.237]                         }
[09:31:34.237]                       }
[09:31:34.237]                     }
[09:31:34.237]                     invisible(muffled)
[09:31:34.237]                   }
[09:31:34.237]                   muffleCondition(cond)
[09:31:34.237]                 })
[09:31:34.237]             }))
[09:31:34.237]             future::FutureResult(value = ...future.value$value, 
[09:31:34.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.237]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.237]                     ...future.globalenv.names))
[09:31:34.237]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.237]         }, condition = base::local({
[09:31:34.237]             c <- base::c
[09:31:34.237]             inherits <- base::inherits
[09:31:34.237]             invokeRestart <- base::invokeRestart
[09:31:34.237]             length <- base::length
[09:31:34.237]             list <- base::list
[09:31:34.237]             seq.int <- base::seq.int
[09:31:34.237]             signalCondition <- base::signalCondition
[09:31:34.237]             sys.calls <- base::sys.calls
[09:31:34.237]             `[[` <- base::`[[`
[09:31:34.237]             `+` <- base::`+`
[09:31:34.237]             `<<-` <- base::`<<-`
[09:31:34.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.237]                   3L)]
[09:31:34.237]             }
[09:31:34.237]             function(cond) {
[09:31:34.237]                 is_error <- inherits(cond, "error")
[09:31:34.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.237]                   NULL)
[09:31:34.237]                 if (is_error) {
[09:31:34.237]                   sessionInformation <- function() {
[09:31:34.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.237]                       search = base::search(), system = base::Sys.info())
[09:31:34.237]                   }
[09:31:34.237]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.237]                     cond$call), session = sessionInformation(), 
[09:31:34.237]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.237]                   signalCondition(cond)
[09:31:34.237]                 }
[09:31:34.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.237]                 "immediateCondition"))) {
[09:31:34.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.237]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.237]                   if (TRUE && !signal) {
[09:31:34.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.237]                     {
[09:31:34.237]                       inherits <- base::inherits
[09:31:34.237]                       invokeRestart <- base::invokeRestart
[09:31:34.237]                       is.null <- base::is.null
[09:31:34.237]                       muffled <- FALSE
[09:31:34.237]                       if (inherits(cond, "message")) {
[09:31:34.237]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.237]                         if (muffled) 
[09:31:34.237]                           invokeRestart("muffleMessage")
[09:31:34.237]                       }
[09:31:34.237]                       else if (inherits(cond, "warning")) {
[09:31:34.237]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.237]                         if (muffled) 
[09:31:34.237]                           invokeRestart("muffleWarning")
[09:31:34.237]                       }
[09:31:34.237]                       else if (inherits(cond, "condition")) {
[09:31:34.237]                         if (!is.null(pattern)) {
[09:31:34.237]                           computeRestarts <- base::computeRestarts
[09:31:34.237]                           grepl <- base::grepl
[09:31:34.237]                           restarts <- computeRestarts(cond)
[09:31:34.237]                           for (restart in restarts) {
[09:31:34.237]                             name <- restart$name
[09:31:34.237]                             if (is.null(name)) 
[09:31:34.237]                               next
[09:31:34.237]                             if (!grepl(pattern, name)) 
[09:31:34.237]                               next
[09:31:34.237]                             invokeRestart(restart)
[09:31:34.237]                             muffled <- TRUE
[09:31:34.237]                             break
[09:31:34.237]                           }
[09:31:34.237]                         }
[09:31:34.237]                       }
[09:31:34.237]                       invisible(muffled)
[09:31:34.237]                     }
[09:31:34.237]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.237]                   }
[09:31:34.237]                 }
[09:31:34.237]                 else {
[09:31:34.237]                   if (TRUE) {
[09:31:34.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.237]                     {
[09:31:34.237]                       inherits <- base::inherits
[09:31:34.237]                       invokeRestart <- base::invokeRestart
[09:31:34.237]                       is.null <- base::is.null
[09:31:34.237]                       muffled <- FALSE
[09:31:34.237]                       if (inherits(cond, "message")) {
[09:31:34.237]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.237]                         if (muffled) 
[09:31:34.237]                           invokeRestart("muffleMessage")
[09:31:34.237]                       }
[09:31:34.237]                       else if (inherits(cond, "warning")) {
[09:31:34.237]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.237]                         if (muffled) 
[09:31:34.237]                           invokeRestart("muffleWarning")
[09:31:34.237]                       }
[09:31:34.237]                       else if (inherits(cond, "condition")) {
[09:31:34.237]                         if (!is.null(pattern)) {
[09:31:34.237]                           computeRestarts <- base::computeRestarts
[09:31:34.237]                           grepl <- base::grepl
[09:31:34.237]                           restarts <- computeRestarts(cond)
[09:31:34.237]                           for (restart in restarts) {
[09:31:34.237]                             name <- restart$name
[09:31:34.237]                             if (is.null(name)) 
[09:31:34.237]                               next
[09:31:34.237]                             if (!grepl(pattern, name)) 
[09:31:34.237]                               next
[09:31:34.237]                             invokeRestart(restart)
[09:31:34.237]                             muffled <- TRUE
[09:31:34.237]                             break
[09:31:34.237]                           }
[09:31:34.237]                         }
[09:31:34.237]                       }
[09:31:34.237]                       invisible(muffled)
[09:31:34.237]                     }
[09:31:34.237]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.237]                   }
[09:31:34.237]                 }
[09:31:34.237]             }
[09:31:34.237]         }))
[09:31:34.237]     }, error = function(ex) {
[09:31:34.237]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.237]                 ...future.rng), started = ...future.startTime, 
[09:31:34.237]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.237]             version = "1.8"), class = "FutureResult")
[09:31:34.237]     }, finally = {
[09:31:34.237]         if (!identical(...future.workdir, getwd())) 
[09:31:34.237]             setwd(...future.workdir)
[09:31:34.237]         {
[09:31:34.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.237]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.237]             }
[09:31:34.237]             base::options(...future.oldOptions)
[09:31:34.237]             if (.Platform$OS.type == "windows") {
[09:31:34.237]                 old_names <- names(...future.oldEnvVars)
[09:31:34.237]                 envs <- base::Sys.getenv()
[09:31:34.237]                 names <- names(envs)
[09:31:34.237]                 common <- intersect(names, old_names)
[09:31:34.237]                 added <- setdiff(names, old_names)
[09:31:34.237]                 removed <- setdiff(old_names, names)
[09:31:34.237]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.237]                   envs[common]]
[09:31:34.237]                 NAMES <- toupper(changed)
[09:31:34.237]                 args <- list()
[09:31:34.237]                 for (kk in seq_along(NAMES)) {
[09:31:34.237]                   name <- changed[[kk]]
[09:31:34.237]                   NAME <- NAMES[[kk]]
[09:31:34.237]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.237]                     next
[09:31:34.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.237]                 }
[09:31:34.237]                 NAMES <- toupper(added)
[09:31:34.237]                 for (kk in seq_along(NAMES)) {
[09:31:34.237]                   name <- added[[kk]]
[09:31:34.237]                   NAME <- NAMES[[kk]]
[09:31:34.237]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.237]                     next
[09:31:34.237]                   args[[name]] <- ""
[09:31:34.237]                 }
[09:31:34.237]                 NAMES <- toupper(removed)
[09:31:34.237]                 for (kk in seq_along(NAMES)) {
[09:31:34.237]                   name <- removed[[kk]]
[09:31:34.237]                   NAME <- NAMES[[kk]]
[09:31:34.237]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.237]                     next
[09:31:34.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.237]                 }
[09:31:34.237]                 if (length(args) > 0) 
[09:31:34.237]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.237]             }
[09:31:34.237]             else {
[09:31:34.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.237]             }
[09:31:34.237]             {
[09:31:34.237]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.237]                   0L) {
[09:31:34.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.237]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.237]                   base::options(opts)
[09:31:34.237]                 }
[09:31:34.237]                 {
[09:31:34.237]                   {
[09:31:34.237]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.237]                     NULL
[09:31:34.237]                   }
[09:31:34.237]                   options(future.plan = NULL)
[09:31:34.237]                   if (is.na(NA_character_)) 
[09:31:34.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.237]                     .init = FALSE)
[09:31:34.237]                 }
[09:31:34.237]             }
[09:31:34.237]         }
[09:31:34.237]     })
[09:31:34.237]     if (TRUE) {
[09:31:34.237]         base::sink(type = "output", split = FALSE)
[09:31:34.237]         if (TRUE) {
[09:31:34.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.237]         }
[09:31:34.237]         else {
[09:31:34.237]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.237]         }
[09:31:34.237]         base::close(...future.stdout)
[09:31:34.237]         ...future.stdout <- NULL
[09:31:34.237]     }
[09:31:34.237]     ...future.result$conditions <- ...future.conditions
[09:31:34.237]     ...future.result$finished <- base::Sys.time()
[09:31:34.237]     ...future.result
[09:31:34.237] }
[09:31:34.240] assign_globals() ...
[09:31:34.240] List of 2
[09:31:34.240]  $ a : num 1
[09:31:34.240]  $ ii: int 3
[09:31:34.240]  - attr(*, "where")=List of 2
[09:31:34.240]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.240]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.240]  - attr(*, "resolved")= logi TRUE
[09:31:34.240]  - attr(*, "total_size")= num 112
[09:31:34.240]  - attr(*, "already-done")= logi TRUE
[09:31:34.244] - copied ‘a’ to environment
[09:31:34.245] - copied ‘ii’ to environment
[09:31:34.245] assign_globals() ... done
[09:31:34.245] requestCore(): workers = 2
[09:31:34.245] Poll #1 (0): usedCores() = 2, workers = 2
[09:31:34.273] result() for MulticoreFuture ...
[09:31:34.273] result() for MulticoreFuture ...
[09:31:34.273] result() for MulticoreFuture ... done
[09:31:34.274] result() for MulticoreFuture ... done
[09:31:34.274] result() for MulticoreFuture ...
[09:31:34.274] result() for MulticoreFuture ... done
[09:31:34.277] MulticoreFuture started
[09:31:34.277] - Launch lazy future ... done
[09:31:34.277] run() for ‘MulticoreFuture’ ... done
[09:31:34.278] plan(): Setting new future strategy stack:
[09:31:34.278] result() for MulticoreFuture ...
[09:31:34.279] result() for MulticoreFuture ... done
[09:31:34.278] List of future strategies:
[09:31:34.278] 1. sequential:
[09:31:34.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.278]    - tweaked: FALSE
[09:31:34.278]    - call: NULL
[09:31:34.279] result() for MulticoreFuture ...
[09:31:34.280] plan(): nbrOfWorkers() = 1
[09:31:34.280] result() for MulticoreFuture ... done
[09:31:34.280] result() for MulticoreFuture ...
[09:31:34.281] result() for MulticoreFuture ...
[09:31:34.281] result() for MulticoreFuture ... done
[09:31:34.282] result() for MulticoreFuture ... done
[09:31:34.282] result() for MulticoreFuture ...
[09:31:34.282] result() for MulticoreFuture ... done
[09:31:34.282] plan(): Setting new future strategy stack:
[09:31:34.282] result() for MulticoreFuture ...
[09:31:34.282] List of future strategies:
[09:31:34.282] 1. multicore:
[09:31:34.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.282]    - tweaked: FALSE
[09:31:34.282]    - call: plan(strategy)
[09:31:34.289] plan(): nbrOfWorkers() = 2
[09:31:34.290] result() for MulticoreFuture ...
[09:31:34.290] result() for MulticoreFuture ... done
[09:31:34.290] result() for MulticoreFuture ... done
[09:31:34.290] result() for MulticoreFuture ...
[09:31:34.290] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.292] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.292] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.295] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.295] Searching for globals ... DONE
[09:31:34.296] Resolving globals: TRUE
[09:31:34.296] Resolving any globals that are futures ...
[09:31:34.296] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.296] Resolving any globals that are futures ... DONE
[09:31:34.296] Resolving futures part of globals (recursively) ...
[09:31:34.297] resolve() on list ...
[09:31:34.297]  recursive: 99
[09:31:34.297]  length: 2
[09:31:34.297]  elements: ‘a’, ‘ii’
[09:31:34.297]  length: 1 (resolved future 1)
[09:31:34.297]  length: 0 (resolved future 2)
[09:31:34.297] resolve() on list ... DONE
[09:31:34.298] - globals: [2] ‘a’, ‘ii’
[09:31:34.298] Resolving futures part of globals (recursively) ... DONE
[09:31:34.298] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.298] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.299] - globals: [2] ‘a’, ‘ii’
[09:31:34.299] 
[09:31:34.299] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.299] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.300] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.302] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.302] Searching for globals ... DONE
[09:31:34.302] Resolving globals: TRUE
[09:31:34.302] Resolving any globals that are futures ...
[09:31:34.302] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.302] Resolving any globals that are futures ... DONE
[09:31:34.303] Resolving futures part of globals (recursively) ...
[09:31:34.303] resolve() on list ...
[09:31:34.303]  recursive: 99
[09:31:34.303]  length: 2
[09:31:34.303]  elements: ‘a’, ‘ii’
[09:31:34.303]  length: 1 (resolved future 1)
[09:31:34.304]  length: 0 (resolved future 2)
[09:31:34.304] resolve() on list ... DONE
[09:31:34.304] - globals: [2] ‘a’, ‘ii’
[09:31:34.304] Resolving futures part of globals (recursively) ... DONE
[09:31:34.304] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.305] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.305] - globals: [2] ‘a’, ‘ii’
[09:31:34.305] 
[09:31:34.305] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.306] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.306] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.308] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.308] Searching for globals ... DONE
[09:31:34.308] Resolving globals: TRUE
[09:31:34.308] Resolving any globals that are futures ...
[09:31:34.308] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:34.308] Resolving any globals that are futures ... DONE
[09:31:34.309] Resolving futures part of globals (recursively) ...
[09:31:34.309] resolve() on list ...
[09:31:34.309]  recursive: 99
[09:31:34.309]  length: 2
[09:31:34.309]  elements: ‘a’, ‘ii’
[09:31:34.309]  length: 1 (resolved future 1)
[09:31:34.309]  length: 0 (resolved future 2)
[09:31:34.310] resolve() on list ... DONE
[09:31:34.310] - globals: [2] ‘a’, ‘ii’
[09:31:34.310] Resolving futures part of globals (recursively) ... DONE
[09:31:34.310] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:34.310] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:34.310] - globals: [2] ‘a’, ‘ii’
[09:31:34.310] 
[09:31:34.311] getGlobalsAndPackages() ... DONE
[09:31:34.311] run() for ‘Future’ ...
[09:31:34.311] - state: ‘created’
[09:31:34.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.315] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.315]   - Field: ‘label’
[09:31:34.315]   - Field: ‘local’
[09:31:34.316]   - Field: ‘owner’
[09:31:34.318]   - Field: ‘envir’
[09:31:34.318]   - Field: ‘workers’
[09:31:34.318]   - Field: ‘packages’
[09:31:34.318]   - Field: ‘gc’
[09:31:34.318]   - Field: ‘job’
[09:31:34.318]   - Field: ‘conditions’
[09:31:34.318]   - Field: ‘expr’
[09:31:34.318]   - Field: ‘uuid’
[09:31:34.318]   - Field: ‘seed’
[09:31:34.319]   - Field: ‘version’
[09:31:34.319]   - Field: ‘result’
[09:31:34.319]   - Field: ‘asynchronous’
[09:31:34.319]   - Field: ‘calls’
[09:31:34.319]   - Field: ‘globals’
[09:31:34.319]   - Field: ‘stdout’
[09:31:34.319]   - Field: ‘earlySignal’
[09:31:34.319]   - Field: ‘lazy’
[09:31:34.319]   - Field: ‘state’
[09:31:34.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.320] - Launch lazy future ...
[09:31:34.320] Packages needed by the future expression (n = 0): <none>
[09:31:34.320] Packages needed by future strategies (n = 0): <none>
[09:31:34.321] {
[09:31:34.321]     {
[09:31:34.321]         {
[09:31:34.321]             ...future.startTime <- base::Sys.time()
[09:31:34.321]             {
[09:31:34.321]                 {
[09:31:34.321]                   {
[09:31:34.321]                     {
[09:31:34.321]                       base::local({
[09:31:34.321]                         has_future <- base::requireNamespace("future", 
[09:31:34.321]                           quietly = TRUE)
[09:31:34.321]                         if (has_future) {
[09:31:34.321]                           ns <- base::getNamespace("future")
[09:31:34.321]                           version <- ns[[".package"]][["version"]]
[09:31:34.321]                           if (is.null(version)) 
[09:31:34.321]                             version <- utils::packageVersion("future")
[09:31:34.321]                         }
[09:31:34.321]                         else {
[09:31:34.321]                           version <- NULL
[09:31:34.321]                         }
[09:31:34.321]                         if (!has_future || version < "1.8.0") {
[09:31:34.321]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.321]                             "", base::R.version$version.string), 
[09:31:34.321]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.321]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.321]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.321]                               "release", "version")], collapse = " "), 
[09:31:34.321]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.321]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.321]                             info)
[09:31:34.321]                           info <- base::paste(info, collapse = "; ")
[09:31:34.321]                           if (!has_future) {
[09:31:34.321]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.321]                               info)
[09:31:34.321]                           }
[09:31:34.321]                           else {
[09:31:34.321]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.321]                               info, version)
[09:31:34.321]                           }
[09:31:34.321]                           base::stop(msg)
[09:31:34.321]                         }
[09:31:34.321]                       })
[09:31:34.321]                     }
[09:31:34.321]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.321]                     base::options(mc.cores = 1L)
[09:31:34.321]                   }
[09:31:34.321]                   ...future.strategy.old <- future::plan("list")
[09:31:34.321]                   options(future.plan = NULL)
[09:31:34.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.321]                 }
[09:31:34.321]                 ...future.workdir <- getwd()
[09:31:34.321]             }
[09:31:34.321]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.321]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.321]         }
[09:31:34.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.321]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.321]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.321]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.321]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.321]             base::names(...future.oldOptions))
[09:31:34.321]     }
[09:31:34.321]     if (FALSE) {
[09:31:34.321]     }
[09:31:34.321]     else {
[09:31:34.321]         if (TRUE) {
[09:31:34.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.321]                 open = "w")
[09:31:34.321]         }
[09:31:34.321]         else {
[09:31:34.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.321]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.321]         }
[09:31:34.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.321]             base::sink(type = "output", split = FALSE)
[09:31:34.321]             base::close(...future.stdout)
[09:31:34.321]         }, add = TRUE)
[09:31:34.321]     }
[09:31:34.321]     ...future.frame <- base::sys.nframe()
[09:31:34.321]     ...future.conditions <- base::list()
[09:31:34.321]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.321]     if (FALSE) {
[09:31:34.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.321]     }
[09:31:34.321]     ...future.result <- base::tryCatch({
[09:31:34.321]         base::withCallingHandlers({
[09:31:34.321]             ...future.value <- base::withVisible(base::local({
[09:31:34.321]                 withCallingHandlers({
[09:31:34.321]                   {
[09:31:34.321]                     b <- a * ii
[09:31:34.321]                     a <- 0
[09:31:34.321]                     b
[09:31:34.321]                   }
[09:31:34.321]                 }, immediateCondition = function(cond) {
[09:31:34.321]                   save_rds <- function (object, pathname, ...) 
[09:31:34.321]                   {
[09:31:34.321]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.321]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.321]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.321]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.321]                         fi_tmp[["mtime"]])
[09:31:34.321]                     }
[09:31:34.321]                     tryCatch({
[09:31:34.321]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.321]                     }, error = function(ex) {
[09:31:34.321]                       msg <- conditionMessage(ex)
[09:31:34.321]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.321]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.321]                         fi_tmp[["mtime"]], msg)
[09:31:34.321]                       ex$message <- msg
[09:31:34.321]                       stop(ex)
[09:31:34.321]                     })
[09:31:34.321]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.321]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.321]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.321]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.321]                       fi <- file.info(pathname)
[09:31:34.321]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.321]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.321]                         fi[["size"]], fi[["mtime"]])
[09:31:34.321]                       stop(msg)
[09:31:34.321]                     }
[09:31:34.321]                     invisible(pathname)
[09:31:34.321]                   }
[09:31:34.321]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.321]                     rootPath = tempdir()) 
[09:31:34.321]                   {
[09:31:34.321]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.321]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.321]                       tmpdir = path, fileext = ".rds")
[09:31:34.321]                     save_rds(obj, file)
[09:31:34.321]                   }
[09:31:34.321]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.321]                   {
[09:31:34.321]                     inherits <- base::inherits
[09:31:34.321]                     invokeRestart <- base::invokeRestart
[09:31:34.321]                     is.null <- base::is.null
[09:31:34.321]                     muffled <- FALSE
[09:31:34.321]                     if (inherits(cond, "message")) {
[09:31:34.321]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.321]                       if (muffled) 
[09:31:34.321]                         invokeRestart("muffleMessage")
[09:31:34.321]                     }
[09:31:34.321]                     else if (inherits(cond, "warning")) {
[09:31:34.321]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.321]                       if (muffled) 
[09:31:34.321]                         invokeRestart("muffleWarning")
[09:31:34.321]                     }
[09:31:34.321]                     else if (inherits(cond, "condition")) {
[09:31:34.321]                       if (!is.null(pattern)) {
[09:31:34.321]                         computeRestarts <- base::computeRestarts
[09:31:34.321]                         grepl <- base::grepl
[09:31:34.321]                         restarts <- computeRestarts(cond)
[09:31:34.321]                         for (restart in restarts) {
[09:31:34.321]                           name <- restart$name
[09:31:34.321]                           if (is.null(name)) 
[09:31:34.321]                             next
[09:31:34.321]                           if (!grepl(pattern, name)) 
[09:31:34.321]                             next
[09:31:34.321]                           invokeRestart(restart)
[09:31:34.321]                           muffled <- TRUE
[09:31:34.321]                           break
[09:31:34.321]                         }
[09:31:34.321]                       }
[09:31:34.321]                     }
[09:31:34.321]                     invisible(muffled)
[09:31:34.321]                   }
[09:31:34.321]                   muffleCondition(cond)
[09:31:34.321]                 })
[09:31:34.321]             }))
[09:31:34.321]             future::FutureResult(value = ...future.value$value, 
[09:31:34.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.321]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.321]                     ...future.globalenv.names))
[09:31:34.321]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.321]         }, condition = base::local({
[09:31:34.321]             c <- base::c
[09:31:34.321]             inherits <- base::inherits
[09:31:34.321]             invokeRestart <- base::invokeRestart
[09:31:34.321]             length <- base::length
[09:31:34.321]             list <- base::list
[09:31:34.321]             seq.int <- base::seq.int
[09:31:34.321]             signalCondition <- base::signalCondition
[09:31:34.321]             sys.calls <- base::sys.calls
[09:31:34.321]             `[[` <- base::`[[`
[09:31:34.321]             `+` <- base::`+`
[09:31:34.321]             `<<-` <- base::`<<-`
[09:31:34.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.321]                   3L)]
[09:31:34.321]             }
[09:31:34.321]             function(cond) {
[09:31:34.321]                 is_error <- inherits(cond, "error")
[09:31:34.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.321]                   NULL)
[09:31:34.321]                 if (is_error) {
[09:31:34.321]                   sessionInformation <- function() {
[09:31:34.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.321]                       search = base::search(), system = base::Sys.info())
[09:31:34.321]                   }
[09:31:34.321]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.321]                     cond$call), session = sessionInformation(), 
[09:31:34.321]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.321]                   signalCondition(cond)
[09:31:34.321]                 }
[09:31:34.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.321]                 "immediateCondition"))) {
[09:31:34.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.321]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.321]                   if (TRUE && !signal) {
[09:31:34.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.321]                     {
[09:31:34.321]                       inherits <- base::inherits
[09:31:34.321]                       invokeRestart <- base::invokeRestart
[09:31:34.321]                       is.null <- base::is.null
[09:31:34.321]                       muffled <- FALSE
[09:31:34.321]                       if (inherits(cond, "message")) {
[09:31:34.321]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.321]                         if (muffled) 
[09:31:34.321]                           invokeRestart("muffleMessage")
[09:31:34.321]                       }
[09:31:34.321]                       else if (inherits(cond, "warning")) {
[09:31:34.321]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.321]                         if (muffled) 
[09:31:34.321]                           invokeRestart("muffleWarning")
[09:31:34.321]                       }
[09:31:34.321]                       else if (inherits(cond, "condition")) {
[09:31:34.321]                         if (!is.null(pattern)) {
[09:31:34.321]                           computeRestarts <- base::computeRestarts
[09:31:34.321]                           grepl <- base::grepl
[09:31:34.321]                           restarts <- computeRestarts(cond)
[09:31:34.321]                           for (restart in restarts) {
[09:31:34.321]                             name <- restart$name
[09:31:34.321]                             if (is.null(name)) 
[09:31:34.321]                               next
[09:31:34.321]                             if (!grepl(pattern, name)) 
[09:31:34.321]                               next
[09:31:34.321]                             invokeRestart(restart)
[09:31:34.321]                             muffled <- TRUE
[09:31:34.321]                             break
[09:31:34.321]                           }
[09:31:34.321]                         }
[09:31:34.321]                       }
[09:31:34.321]                       invisible(muffled)
[09:31:34.321]                     }
[09:31:34.321]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.321]                   }
[09:31:34.321]                 }
[09:31:34.321]                 else {
[09:31:34.321]                   if (TRUE) {
[09:31:34.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.321]                     {
[09:31:34.321]                       inherits <- base::inherits
[09:31:34.321]                       invokeRestart <- base::invokeRestart
[09:31:34.321]                       is.null <- base::is.null
[09:31:34.321]                       muffled <- FALSE
[09:31:34.321]                       if (inherits(cond, "message")) {
[09:31:34.321]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.321]                         if (muffled) 
[09:31:34.321]                           invokeRestart("muffleMessage")
[09:31:34.321]                       }
[09:31:34.321]                       else if (inherits(cond, "warning")) {
[09:31:34.321]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.321]                         if (muffled) 
[09:31:34.321]                           invokeRestart("muffleWarning")
[09:31:34.321]                       }
[09:31:34.321]                       else if (inherits(cond, "condition")) {
[09:31:34.321]                         if (!is.null(pattern)) {
[09:31:34.321]                           computeRestarts <- base::computeRestarts
[09:31:34.321]                           grepl <- base::grepl
[09:31:34.321]                           restarts <- computeRestarts(cond)
[09:31:34.321]                           for (restart in restarts) {
[09:31:34.321]                             name <- restart$name
[09:31:34.321]                             if (is.null(name)) 
[09:31:34.321]                               next
[09:31:34.321]                             if (!grepl(pattern, name)) 
[09:31:34.321]                               next
[09:31:34.321]                             invokeRestart(restart)
[09:31:34.321]                             muffled <- TRUE
[09:31:34.321]                             break
[09:31:34.321]                           }
[09:31:34.321]                         }
[09:31:34.321]                       }
[09:31:34.321]                       invisible(muffled)
[09:31:34.321]                     }
[09:31:34.321]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.321]                   }
[09:31:34.321]                 }
[09:31:34.321]             }
[09:31:34.321]         }))
[09:31:34.321]     }, error = function(ex) {
[09:31:34.321]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.321]                 ...future.rng), started = ...future.startTime, 
[09:31:34.321]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.321]             version = "1.8"), class = "FutureResult")
[09:31:34.321]     }, finally = {
[09:31:34.321]         if (!identical(...future.workdir, getwd())) 
[09:31:34.321]             setwd(...future.workdir)
[09:31:34.321]         {
[09:31:34.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.321]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.321]             }
[09:31:34.321]             base::options(...future.oldOptions)
[09:31:34.321]             if (.Platform$OS.type == "windows") {
[09:31:34.321]                 old_names <- names(...future.oldEnvVars)
[09:31:34.321]                 envs <- base::Sys.getenv()
[09:31:34.321]                 names <- names(envs)
[09:31:34.321]                 common <- intersect(names, old_names)
[09:31:34.321]                 added <- setdiff(names, old_names)
[09:31:34.321]                 removed <- setdiff(old_names, names)
[09:31:34.321]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.321]                   envs[common]]
[09:31:34.321]                 NAMES <- toupper(changed)
[09:31:34.321]                 args <- list()
[09:31:34.321]                 for (kk in seq_along(NAMES)) {
[09:31:34.321]                   name <- changed[[kk]]
[09:31:34.321]                   NAME <- NAMES[[kk]]
[09:31:34.321]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.321]                     next
[09:31:34.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.321]                 }
[09:31:34.321]                 NAMES <- toupper(added)
[09:31:34.321]                 for (kk in seq_along(NAMES)) {
[09:31:34.321]                   name <- added[[kk]]
[09:31:34.321]                   NAME <- NAMES[[kk]]
[09:31:34.321]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.321]                     next
[09:31:34.321]                   args[[name]] <- ""
[09:31:34.321]                 }
[09:31:34.321]                 NAMES <- toupper(removed)
[09:31:34.321]                 for (kk in seq_along(NAMES)) {
[09:31:34.321]                   name <- removed[[kk]]
[09:31:34.321]                   NAME <- NAMES[[kk]]
[09:31:34.321]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.321]                     next
[09:31:34.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.321]                 }
[09:31:34.321]                 if (length(args) > 0) 
[09:31:34.321]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.321]             }
[09:31:34.321]             else {
[09:31:34.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.321]             }
[09:31:34.321]             {
[09:31:34.321]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.321]                   0L) {
[09:31:34.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.321]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.321]                   base::options(opts)
[09:31:34.321]                 }
[09:31:34.321]                 {
[09:31:34.321]                   {
[09:31:34.321]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.321]                     NULL
[09:31:34.321]                   }
[09:31:34.321]                   options(future.plan = NULL)
[09:31:34.321]                   if (is.na(NA_character_)) 
[09:31:34.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.321]                     .init = FALSE)
[09:31:34.321]                 }
[09:31:34.321]             }
[09:31:34.321]         }
[09:31:34.321]     })
[09:31:34.321]     if (TRUE) {
[09:31:34.321]         base::sink(type = "output", split = FALSE)
[09:31:34.321]         if (TRUE) {
[09:31:34.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.321]         }
[09:31:34.321]         else {
[09:31:34.321]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.321]         }
[09:31:34.321]         base::close(...future.stdout)
[09:31:34.321]         ...future.stdout <- NULL
[09:31:34.321]     }
[09:31:34.321]     ...future.result$conditions <- ...future.conditions
[09:31:34.321]     ...future.result$finished <- base::Sys.time()
[09:31:34.321]     ...future.result
[09:31:34.321] }
[09:31:34.323] assign_globals() ...
[09:31:34.323] List of 2
[09:31:34.323]  $ a : num 1
[09:31:34.323]  $ ii: int 1
[09:31:34.323]  - attr(*, "where")=List of 2
[09:31:34.323]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.323]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.323]  - attr(*, "resolved")= logi TRUE
[09:31:34.323]  - attr(*, "total_size")= num 112
[09:31:34.323]  - attr(*, "already-done")= logi TRUE
[09:31:34.326] - copied ‘a’ to environment
[09:31:34.327] - copied ‘ii’ to environment
[09:31:34.327] assign_globals() ... done
[09:31:34.327] requestCore(): workers = 2
[09:31:34.329] MulticoreFuture started
[09:31:34.329] - Launch lazy future ... done
[09:31:34.329] run() for ‘MulticoreFuture’ ... done
[09:31:34.330] plan(): Setting new future strategy stack:
[09:31:34.330] result() for MulticoreFuture ...
[09:31:34.330] List of future strategies:
[09:31:34.330] 1. sequential:
[09:31:34.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.330]    - tweaked: FALSE
[09:31:34.330]    - call: NULL
[09:31:34.331] plan(): nbrOfWorkers() = 1
[09:31:34.334] plan(): Setting new future strategy stack:
[09:31:34.334] List of future strategies:
[09:31:34.334] 1. multicore:
[09:31:34.334]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.334]    - tweaked: FALSE
[09:31:34.334]    - call: plan(strategy)
[09:31:34.340] plan(): nbrOfWorkers() = 2
[09:31:34.340] result() for MulticoreFuture ...
[09:31:34.341] result() for MulticoreFuture ... done
[09:31:34.341] result() for MulticoreFuture ... done
[09:31:34.341] result() for MulticoreFuture ...
[09:31:34.341] result() for MulticoreFuture ... done
[09:31:34.342] run() for ‘Future’ ...
[09:31:34.342] - state: ‘created’
[09:31:34.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.346]   - Field: ‘label’
[09:31:34.347]   - Field: ‘local’
[09:31:34.347]   - Field: ‘owner’
[09:31:34.347]   - Field: ‘envir’
[09:31:34.347]   - Field: ‘workers’
[09:31:34.347]   - Field: ‘packages’
[09:31:34.347]   - Field: ‘gc’
[09:31:34.347]   - Field: ‘job’
[09:31:34.347]   - Field: ‘conditions’
[09:31:34.347]   - Field: ‘expr’
[09:31:34.348]   - Field: ‘uuid’
[09:31:34.348]   - Field: ‘seed’
[09:31:34.348]   - Field: ‘version’
[09:31:34.348]   - Field: ‘result’
[09:31:34.348]   - Field: ‘asynchronous’
[09:31:34.348]   - Field: ‘calls’
[09:31:34.348]   - Field: ‘globals’
[09:31:34.349]   - Field: ‘stdout’
[09:31:34.349]   - Field: ‘earlySignal’
[09:31:34.349]   - Field: ‘lazy’
[09:31:34.349]   - Field: ‘state’
[09:31:34.349] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.349] - Launch lazy future ...
[09:31:34.349] Packages needed by the future expression (n = 0): <none>
[09:31:34.350] Packages needed by future strategies (n = 0): <none>
[09:31:34.350] {
[09:31:34.350]     {
[09:31:34.350]         {
[09:31:34.350]             ...future.startTime <- base::Sys.time()
[09:31:34.350]             {
[09:31:34.350]                 {
[09:31:34.350]                   {
[09:31:34.350]                     {
[09:31:34.350]                       base::local({
[09:31:34.350]                         has_future <- base::requireNamespace("future", 
[09:31:34.350]                           quietly = TRUE)
[09:31:34.350]                         if (has_future) {
[09:31:34.350]                           ns <- base::getNamespace("future")
[09:31:34.350]                           version <- ns[[".package"]][["version"]]
[09:31:34.350]                           if (is.null(version)) 
[09:31:34.350]                             version <- utils::packageVersion("future")
[09:31:34.350]                         }
[09:31:34.350]                         else {
[09:31:34.350]                           version <- NULL
[09:31:34.350]                         }
[09:31:34.350]                         if (!has_future || version < "1.8.0") {
[09:31:34.350]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.350]                             "", base::R.version$version.string), 
[09:31:34.350]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.350]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.350]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.350]                               "release", "version")], collapse = " "), 
[09:31:34.350]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.350]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.350]                             info)
[09:31:34.350]                           info <- base::paste(info, collapse = "; ")
[09:31:34.350]                           if (!has_future) {
[09:31:34.350]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.350]                               info)
[09:31:34.350]                           }
[09:31:34.350]                           else {
[09:31:34.350]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.350]                               info, version)
[09:31:34.350]                           }
[09:31:34.350]                           base::stop(msg)
[09:31:34.350]                         }
[09:31:34.350]                       })
[09:31:34.350]                     }
[09:31:34.350]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.350]                     base::options(mc.cores = 1L)
[09:31:34.350]                   }
[09:31:34.350]                   ...future.strategy.old <- future::plan("list")
[09:31:34.350]                   options(future.plan = NULL)
[09:31:34.350]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.350]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.350]                 }
[09:31:34.350]                 ...future.workdir <- getwd()
[09:31:34.350]             }
[09:31:34.350]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.350]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.350]         }
[09:31:34.350]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.350]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.350]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.350]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.350]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.350]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.350]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.350]             base::names(...future.oldOptions))
[09:31:34.350]     }
[09:31:34.350]     if (FALSE) {
[09:31:34.350]     }
[09:31:34.350]     else {
[09:31:34.350]         if (TRUE) {
[09:31:34.350]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.350]                 open = "w")
[09:31:34.350]         }
[09:31:34.350]         else {
[09:31:34.350]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.350]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.350]         }
[09:31:34.350]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.350]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.350]             base::sink(type = "output", split = FALSE)
[09:31:34.350]             base::close(...future.stdout)
[09:31:34.350]         }, add = TRUE)
[09:31:34.350]     }
[09:31:34.350]     ...future.frame <- base::sys.nframe()
[09:31:34.350]     ...future.conditions <- base::list()
[09:31:34.350]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.350]     if (FALSE) {
[09:31:34.350]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.350]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.350]     }
[09:31:34.350]     ...future.result <- base::tryCatch({
[09:31:34.350]         base::withCallingHandlers({
[09:31:34.350]             ...future.value <- base::withVisible(base::local({
[09:31:34.350]                 withCallingHandlers({
[09:31:34.350]                   {
[09:31:34.350]                     b <- a * ii
[09:31:34.350]                     a <- 0
[09:31:34.350]                     b
[09:31:34.350]                   }
[09:31:34.350]                 }, immediateCondition = function(cond) {
[09:31:34.350]                   save_rds <- function (object, pathname, ...) 
[09:31:34.350]                   {
[09:31:34.350]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.350]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.350]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.350]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.350]                         fi_tmp[["mtime"]])
[09:31:34.350]                     }
[09:31:34.350]                     tryCatch({
[09:31:34.350]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.350]                     }, error = function(ex) {
[09:31:34.350]                       msg <- conditionMessage(ex)
[09:31:34.350]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.350]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.350]                         fi_tmp[["mtime"]], msg)
[09:31:34.350]                       ex$message <- msg
[09:31:34.350]                       stop(ex)
[09:31:34.350]                     })
[09:31:34.350]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.350]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.350]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.350]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.350]                       fi <- file.info(pathname)
[09:31:34.350]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.350]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.350]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.350]                         fi[["size"]], fi[["mtime"]])
[09:31:34.350]                       stop(msg)
[09:31:34.350]                     }
[09:31:34.350]                     invisible(pathname)
[09:31:34.350]                   }
[09:31:34.350]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.350]                     rootPath = tempdir()) 
[09:31:34.350]                   {
[09:31:34.350]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.350]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.350]                       tmpdir = path, fileext = ".rds")
[09:31:34.350]                     save_rds(obj, file)
[09:31:34.350]                   }
[09:31:34.350]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.350]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.350]                   {
[09:31:34.350]                     inherits <- base::inherits
[09:31:34.350]                     invokeRestart <- base::invokeRestart
[09:31:34.350]                     is.null <- base::is.null
[09:31:34.350]                     muffled <- FALSE
[09:31:34.350]                     if (inherits(cond, "message")) {
[09:31:34.350]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.350]                       if (muffled) 
[09:31:34.350]                         invokeRestart("muffleMessage")
[09:31:34.350]                     }
[09:31:34.350]                     else if (inherits(cond, "warning")) {
[09:31:34.350]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.350]                       if (muffled) 
[09:31:34.350]                         invokeRestart("muffleWarning")
[09:31:34.350]                     }
[09:31:34.350]                     else if (inherits(cond, "condition")) {
[09:31:34.350]                       if (!is.null(pattern)) {
[09:31:34.350]                         computeRestarts <- base::computeRestarts
[09:31:34.350]                         grepl <- base::grepl
[09:31:34.350]                         restarts <- computeRestarts(cond)
[09:31:34.350]                         for (restart in restarts) {
[09:31:34.350]                           name <- restart$name
[09:31:34.350]                           if (is.null(name)) 
[09:31:34.350]                             next
[09:31:34.350]                           if (!grepl(pattern, name)) 
[09:31:34.350]                             next
[09:31:34.350]                           invokeRestart(restart)
[09:31:34.350]                           muffled <- TRUE
[09:31:34.350]                           break
[09:31:34.350]                         }
[09:31:34.350]                       }
[09:31:34.350]                     }
[09:31:34.350]                     invisible(muffled)
[09:31:34.350]                   }
[09:31:34.350]                   muffleCondition(cond)
[09:31:34.350]                 })
[09:31:34.350]             }))
[09:31:34.350]             future::FutureResult(value = ...future.value$value, 
[09:31:34.350]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.350]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.350]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.350]                     ...future.globalenv.names))
[09:31:34.350]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.350]         }, condition = base::local({
[09:31:34.350]             c <- base::c
[09:31:34.350]             inherits <- base::inherits
[09:31:34.350]             invokeRestart <- base::invokeRestart
[09:31:34.350]             length <- base::length
[09:31:34.350]             list <- base::list
[09:31:34.350]             seq.int <- base::seq.int
[09:31:34.350]             signalCondition <- base::signalCondition
[09:31:34.350]             sys.calls <- base::sys.calls
[09:31:34.350]             `[[` <- base::`[[`
[09:31:34.350]             `+` <- base::`+`
[09:31:34.350]             `<<-` <- base::`<<-`
[09:31:34.350]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.350]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.350]                   3L)]
[09:31:34.350]             }
[09:31:34.350]             function(cond) {
[09:31:34.350]                 is_error <- inherits(cond, "error")
[09:31:34.350]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.350]                   NULL)
[09:31:34.350]                 if (is_error) {
[09:31:34.350]                   sessionInformation <- function() {
[09:31:34.350]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.350]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.350]                       search = base::search(), system = base::Sys.info())
[09:31:34.350]                   }
[09:31:34.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.350]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.350]                     cond$call), session = sessionInformation(), 
[09:31:34.350]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.350]                   signalCondition(cond)
[09:31:34.350]                 }
[09:31:34.350]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.350]                 "immediateCondition"))) {
[09:31:34.350]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.350]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.350]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.350]                   if (TRUE && !signal) {
[09:31:34.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.350]                     {
[09:31:34.350]                       inherits <- base::inherits
[09:31:34.350]                       invokeRestart <- base::invokeRestart
[09:31:34.350]                       is.null <- base::is.null
[09:31:34.350]                       muffled <- FALSE
[09:31:34.350]                       if (inherits(cond, "message")) {
[09:31:34.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.350]                         if (muffled) 
[09:31:34.350]                           invokeRestart("muffleMessage")
[09:31:34.350]                       }
[09:31:34.350]                       else if (inherits(cond, "warning")) {
[09:31:34.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.350]                         if (muffled) 
[09:31:34.350]                           invokeRestart("muffleWarning")
[09:31:34.350]                       }
[09:31:34.350]                       else if (inherits(cond, "condition")) {
[09:31:34.350]                         if (!is.null(pattern)) {
[09:31:34.350]                           computeRestarts <- base::computeRestarts
[09:31:34.350]                           grepl <- base::grepl
[09:31:34.350]                           restarts <- computeRestarts(cond)
[09:31:34.350]                           for (restart in restarts) {
[09:31:34.350]                             name <- restart$name
[09:31:34.350]                             if (is.null(name)) 
[09:31:34.350]                               next
[09:31:34.350]                             if (!grepl(pattern, name)) 
[09:31:34.350]                               next
[09:31:34.350]                             invokeRestart(restart)
[09:31:34.350]                             muffled <- TRUE
[09:31:34.350]                             break
[09:31:34.350]                           }
[09:31:34.350]                         }
[09:31:34.350]                       }
[09:31:34.350]                       invisible(muffled)
[09:31:34.350]                     }
[09:31:34.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.350]                   }
[09:31:34.350]                 }
[09:31:34.350]                 else {
[09:31:34.350]                   if (TRUE) {
[09:31:34.350]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.350]                     {
[09:31:34.350]                       inherits <- base::inherits
[09:31:34.350]                       invokeRestart <- base::invokeRestart
[09:31:34.350]                       is.null <- base::is.null
[09:31:34.350]                       muffled <- FALSE
[09:31:34.350]                       if (inherits(cond, "message")) {
[09:31:34.350]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.350]                         if (muffled) 
[09:31:34.350]                           invokeRestart("muffleMessage")
[09:31:34.350]                       }
[09:31:34.350]                       else if (inherits(cond, "warning")) {
[09:31:34.350]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.350]                         if (muffled) 
[09:31:34.350]                           invokeRestart("muffleWarning")
[09:31:34.350]                       }
[09:31:34.350]                       else if (inherits(cond, "condition")) {
[09:31:34.350]                         if (!is.null(pattern)) {
[09:31:34.350]                           computeRestarts <- base::computeRestarts
[09:31:34.350]                           grepl <- base::grepl
[09:31:34.350]                           restarts <- computeRestarts(cond)
[09:31:34.350]                           for (restart in restarts) {
[09:31:34.350]                             name <- restart$name
[09:31:34.350]                             if (is.null(name)) 
[09:31:34.350]                               next
[09:31:34.350]                             if (!grepl(pattern, name)) 
[09:31:34.350]                               next
[09:31:34.350]                             invokeRestart(restart)
[09:31:34.350]                             muffled <- TRUE
[09:31:34.350]                             break
[09:31:34.350]                           }
[09:31:34.350]                         }
[09:31:34.350]                       }
[09:31:34.350]                       invisible(muffled)
[09:31:34.350]                     }
[09:31:34.350]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.350]                   }
[09:31:34.350]                 }
[09:31:34.350]             }
[09:31:34.350]         }))
[09:31:34.350]     }, error = function(ex) {
[09:31:34.350]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.350]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.350]                 ...future.rng), started = ...future.startTime, 
[09:31:34.350]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.350]             version = "1.8"), class = "FutureResult")
[09:31:34.350]     }, finally = {
[09:31:34.350]         if (!identical(...future.workdir, getwd())) 
[09:31:34.350]             setwd(...future.workdir)
[09:31:34.350]         {
[09:31:34.350]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.350]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.350]             }
[09:31:34.350]             base::options(...future.oldOptions)
[09:31:34.350]             if (.Platform$OS.type == "windows") {
[09:31:34.350]                 old_names <- names(...future.oldEnvVars)
[09:31:34.350]                 envs <- base::Sys.getenv()
[09:31:34.350]                 names <- names(envs)
[09:31:34.350]                 common <- intersect(names, old_names)
[09:31:34.350]                 added <- setdiff(names, old_names)
[09:31:34.350]                 removed <- setdiff(old_names, names)
[09:31:34.350]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.350]                   envs[common]]
[09:31:34.350]                 NAMES <- toupper(changed)
[09:31:34.350]                 args <- list()
[09:31:34.350]                 for (kk in seq_along(NAMES)) {
[09:31:34.350]                   name <- changed[[kk]]
[09:31:34.350]                   NAME <- NAMES[[kk]]
[09:31:34.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.350]                     next
[09:31:34.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.350]                 }
[09:31:34.350]                 NAMES <- toupper(added)
[09:31:34.350]                 for (kk in seq_along(NAMES)) {
[09:31:34.350]                   name <- added[[kk]]
[09:31:34.350]                   NAME <- NAMES[[kk]]
[09:31:34.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.350]                     next
[09:31:34.350]                   args[[name]] <- ""
[09:31:34.350]                 }
[09:31:34.350]                 NAMES <- toupper(removed)
[09:31:34.350]                 for (kk in seq_along(NAMES)) {
[09:31:34.350]                   name <- removed[[kk]]
[09:31:34.350]                   NAME <- NAMES[[kk]]
[09:31:34.350]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.350]                     next
[09:31:34.350]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.350]                 }
[09:31:34.350]                 if (length(args) > 0) 
[09:31:34.350]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.350]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.350]             }
[09:31:34.350]             else {
[09:31:34.350]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.350]             }
[09:31:34.350]             {
[09:31:34.350]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.350]                   0L) {
[09:31:34.350]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.350]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.350]                   base::options(opts)
[09:31:34.350]                 }
[09:31:34.350]                 {
[09:31:34.350]                   {
[09:31:34.350]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.350]                     NULL
[09:31:34.350]                   }
[09:31:34.350]                   options(future.plan = NULL)
[09:31:34.350]                   if (is.na(NA_character_)) 
[09:31:34.350]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.350]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.350]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.350]                     .init = FALSE)
[09:31:34.350]                 }
[09:31:34.350]             }
[09:31:34.350]         }
[09:31:34.350]     })
[09:31:34.350]     if (TRUE) {
[09:31:34.350]         base::sink(type = "output", split = FALSE)
[09:31:34.350]         if (TRUE) {
[09:31:34.350]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.350]         }
[09:31:34.350]         else {
[09:31:34.350]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.350]         }
[09:31:34.350]         base::close(...future.stdout)
[09:31:34.350]         ...future.stdout <- NULL
[09:31:34.350]     }
[09:31:34.350]     ...future.result$conditions <- ...future.conditions
[09:31:34.350]     ...future.result$finished <- base::Sys.time()
[09:31:34.350]     ...future.result
[09:31:34.350] }
[09:31:34.353] assign_globals() ...
[09:31:34.353] List of 2
[09:31:34.353]  $ a : num 1
[09:31:34.353]  $ ii: int 2
[09:31:34.353]  - attr(*, "where")=List of 2
[09:31:34.353]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.353]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.353]  - attr(*, "resolved")= logi TRUE
[09:31:34.353]  - attr(*, "total_size")= num 112
[09:31:34.353]  - attr(*, "already-done")= logi TRUE
[09:31:34.357] - copied ‘a’ to environment
[09:31:34.357] - copied ‘ii’ to environment
[09:31:34.357] assign_globals() ... done
[09:31:34.357] requestCore(): workers = 2
[09:31:34.359] MulticoreFuture started
[09:31:34.359] - Launch lazy future ... done
[09:31:34.359] run() for ‘MulticoreFuture’ ... done
[09:31:34.360] result() for MulticoreFuture ...
[09:31:34.360] plan(): Setting new future strategy stack:
[09:31:34.360] List of future strategies:
[09:31:34.360] 1. sequential:
[09:31:34.360]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.360]    - tweaked: FALSE
[09:31:34.360]    - call: NULL
[09:31:34.361] plan(): nbrOfWorkers() = 1
[09:31:34.363] plan(): Setting new future strategy stack:
[09:31:34.363] List of future strategies:
[09:31:34.363] 1. multicore:
[09:31:34.363]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.363]    - tweaked: FALSE
[09:31:34.363]    - call: plan(strategy)
[09:31:34.368] plan(): nbrOfWorkers() = 2
[09:31:34.369] result() for MulticoreFuture ...
[09:31:34.369] result() for MulticoreFuture ... done
[09:31:34.369] result() for MulticoreFuture ... done
[09:31:34.370] result() for MulticoreFuture ...
[09:31:34.370] result() for MulticoreFuture ... done
[09:31:34.370] run() for ‘Future’ ...
[09:31:34.370] - state: ‘created’
[09:31:34.370] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.375]   - Field: ‘label’
[09:31:34.375]   - Field: ‘local’
[09:31:34.375]   - Field: ‘owner’
[09:31:34.375]   - Field: ‘envir’
[09:31:34.375]   - Field: ‘workers’
[09:31:34.375]   - Field: ‘packages’
[09:31:34.376]   - Field: ‘gc’
[09:31:34.376]   - Field: ‘job’
[09:31:34.376]   - Field: ‘conditions’
[09:31:34.376]   - Field: ‘expr’
[09:31:34.376]   - Field: ‘uuid’
[09:31:34.376]   - Field: ‘seed’
[09:31:34.376]   - Field: ‘version’
[09:31:34.376]   - Field: ‘result’
[09:31:34.377]   - Field: ‘asynchronous’
[09:31:34.377]   - Field: ‘calls’
[09:31:34.377]   - Field: ‘globals’
[09:31:34.377]   - Field: ‘stdout’
[09:31:34.377]   - Field: ‘earlySignal’
[09:31:34.377]   - Field: ‘lazy’
[09:31:34.377]   - Field: ‘state’
[09:31:34.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.377] - Launch lazy future ...
[09:31:34.378] Packages needed by the future expression (n = 0): <none>
[09:31:34.378] Packages needed by future strategies (n = 0): <none>
[09:31:34.378] {
[09:31:34.378]     {
[09:31:34.378]         {
[09:31:34.378]             ...future.startTime <- base::Sys.time()
[09:31:34.378]             {
[09:31:34.378]                 {
[09:31:34.378]                   {
[09:31:34.378]                     {
[09:31:34.378]                       base::local({
[09:31:34.378]                         has_future <- base::requireNamespace("future", 
[09:31:34.378]                           quietly = TRUE)
[09:31:34.378]                         if (has_future) {
[09:31:34.378]                           ns <- base::getNamespace("future")
[09:31:34.378]                           version <- ns[[".package"]][["version"]]
[09:31:34.378]                           if (is.null(version)) 
[09:31:34.378]                             version <- utils::packageVersion("future")
[09:31:34.378]                         }
[09:31:34.378]                         else {
[09:31:34.378]                           version <- NULL
[09:31:34.378]                         }
[09:31:34.378]                         if (!has_future || version < "1.8.0") {
[09:31:34.378]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.378]                             "", base::R.version$version.string), 
[09:31:34.378]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.378]                               "release", "version")], collapse = " "), 
[09:31:34.378]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.378]                             info)
[09:31:34.378]                           info <- base::paste(info, collapse = "; ")
[09:31:34.378]                           if (!has_future) {
[09:31:34.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.378]                               info)
[09:31:34.378]                           }
[09:31:34.378]                           else {
[09:31:34.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.378]                               info, version)
[09:31:34.378]                           }
[09:31:34.378]                           base::stop(msg)
[09:31:34.378]                         }
[09:31:34.378]                       })
[09:31:34.378]                     }
[09:31:34.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.378]                     base::options(mc.cores = 1L)
[09:31:34.378]                   }
[09:31:34.378]                   ...future.strategy.old <- future::plan("list")
[09:31:34.378]                   options(future.plan = NULL)
[09:31:34.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.378]                 }
[09:31:34.378]                 ...future.workdir <- getwd()
[09:31:34.378]             }
[09:31:34.378]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.378]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.378]         }
[09:31:34.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.378]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.378]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.378]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.378]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.378]             base::names(...future.oldOptions))
[09:31:34.378]     }
[09:31:34.378]     if (FALSE) {
[09:31:34.378]     }
[09:31:34.378]     else {
[09:31:34.378]         if (TRUE) {
[09:31:34.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.378]                 open = "w")
[09:31:34.378]         }
[09:31:34.378]         else {
[09:31:34.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.378]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.378]         }
[09:31:34.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.378]             base::sink(type = "output", split = FALSE)
[09:31:34.378]             base::close(...future.stdout)
[09:31:34.378]         }, add = TRUE)
[09:31:34.378]     }
[09:31:34.378]     ...future.frame <- base::sys.nframe()
[09:31:34.378]     ...future.conditions <- base::list()
[09:31:34.378]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.378]     if (FALSE) {
[09:31:34.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.378]     }
[09:31:34.378]     ...future.result <- base::tryCatch({
[09:31:34.378]         base::withCallingHandlers({
[09:31:34.378]             ...future.value <- base::withVisible(base::local({
[09:31:34.378]                 withCallingHandlers({
[09:31:34.378]                   {
[09:31:34.378]                     b <- a * ii
[09:31:34.378]                     a <- 0
[09:31:34.378]                     b
[09:31:34.378]                   }
[09:31:34.378]                 }, immediateCondition = function(cond) {
[09:31:34.378]                   save_rds <- function (object, pathname, ...) 
[09:31:34.378]                   {
[09:31:34.378]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.378]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.378]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.378]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.378]                         fi_tmp[["mtime"]])
[09:31:34.378]                     }
[09:31:34.378]                     tryCatch({
[09:31:34.378]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.378]                     }, error = function(ex) {
[09:31:34.378]                       msg <- conditionMessage(ex)
[09:31:34.378]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.378]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.378]                         fi_tmp[["mtime"]], msg)
[09:31:34.378]                       ex$message <- msg
[09:31:34.378]                       stop(ex)
[09:31:34.378]                     })
[09:31:34.378]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.378]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.378]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.378]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.378]                       fi <- file.info(pathname)
[09:31:34.378]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.378]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.378]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.378]                         fi[["size"]], fi[["mtime"]])
[09:31:34.378]                       stop(msg)
[09:31:34.378]                     }
[09:31:34.378]                     invisible(pathname)
[09:31:34.378]                   }
[09:31:34.378]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.378]                     rootPath = tempdir()) 
[09:31:34.378]                   {
[09:31:34.378]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.378]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.378]                       tmpdir = path, fileext = ".rds")
[09:31:34.378]                     save_rds(obj, file)
[09:31:34.378]                   }
[09:31:34.378]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.378]                   {
[09:31:34.378]                     inherits <- base::inherits
[09:31:34.378]                     invokeRestart <- base::invokeRestart
[09:31:34.378]                     is.null <- base::is.null
[09:31:34.378]                     muffled <- FALSE
[09:31:34.378]                     if (inherits(cond, "message")) {
[09:31:34.378]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.378]                       if (muffled) 
[09:31:34.378]                         invokeRestart("muffleMessage")
[09:31:34.378]                     }
[09:31:34.378]                     else if (inherits(cond, "warning")) {
[09:31:34.378]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.378]                       if (muffled) 
[09:31:34.378]                         invokeRestart("muffleWarning")
[09:31:34.378]                     }
[09:31:34.378]                     else if (inherits(cond, "condition")) {
[09:31:34.378]                       if (!is.null(pattern)) {
[09:31:34.378]                         computeRestarts <- base::computeRestarts
[09:31:34.378]                         grepl <- base::grepl
[09:31:34.378]                         restarts <- computeRestarts(cond)
[09:31:34.378]                         for (restart in restarts) {
[09:31:34.378]                           name <- restart$name
[09:31:34.378]                           if (is.null(name)) 
[09:31:34.378]                             next
[09:31:34.378]                           if (!grepl(pattern, name)) 
[09:31:34.378]                             next
[09:31:34.378]                           invokeRestart(restart)
[09:31:34.378]                           muffled <- TRUE
[09:31:34.378]                           break
[09:31:34.378]                         }
[09:31:34.378]                       }
[09:31:34.378]                     }
[09:31:34.378]                     invisible(muffled)
[09:31:34.378]                   }
[09:31:34.378]                   muffleCondition(cond)
[09:31:34.378]                 })
[09:31:34.378]             }))
[09:31:34.378]             future::FutureResult(value = ...future.value$value, 
[09:31:34.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.378]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.378]                     ...future.globalenv.names))
[09:31:34.378]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.378]         }, condition = base::local({
[09:31:34.378]             c <- base::c
[09:31:34.378]             inherits <- base::inherits
[09:31:34.378]             invokeRestart <- base::invokeRestart
[09:31:34.378]             length <- base::length
[09:31:34.378]             list <- base::list
[09:31:34.378]             seq.int <- base::seq.int
[09:31:34.378]             signalCondition <- base::signalCondition
[09:31:34.378]             sys.calls <- base::sys.calls
[09:31:34.378]             `[[` <- base::`[[`
[09:31:34.378]             `+` <- base::`+`
[09:31:34.378]             `<<-` <- base::`<<-`
[09:31:34.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.378]                   3L)]
[09:31:34.378]             }
[09:31:34.378]             function(cond) {
[09:31:34.378]                 is_error <- inherits(cond, "error")
[09:31:34.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.378]                   NULL)
[09:31:34.378]                 if (is_error) {
[09:31:34.378]                   sessionInformation <- function() {
[09:31:34.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.378]                       search = base::search(), system = base::Sys.info())
[09:31:34.378]                   }
[09:31:34.378]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.378]                     cond$call), session = sessionInformation(), 
[09:31:34.378]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.378]                   signalCondition(cond)
[09:31:34.378]                 }
[09:31:34.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.378]                 "immediateCondition"))) {
[09:31:34.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.378]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.378]                   if (TRUE && !signal) {
[09:31:34.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.378]                     {
[09:31:34.378]                       inherits <- base::inherits
[09:31:34.378]                       invokeRestart <- base::invokeRestart
[09:31:34.378]                       is.null <- base::is.null
[09:31:34.378]                       muffled <- FALSE
[09:31:34.378]                       if (inherits(cond, "message")) {
[09:31:34.378]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.378]                         if (muffled) 
[09:31:34.378]                           invokeRestart("muffleMessage")
[09:31:34.378]                       }
[09:31:34.378]                       else if (inherits(cond, "warning")) {
[09:31:34.378]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.378]                         if (muffled) 
[09:31:34.378]                           invokeRestart("muffleWarning")
[09:31:34.378]                       }
[09:31:34.378]                       else if (inherits(cond, "condition")) {
[09:31:34.378]                         if (!is.null(pattern)) {
[09:31:34.378]                           computeRestarts <- base::computeRestarts
[09:31:34.378]                           grepl <- base::grepl
[09:31:34.378]                           restarts <- computeRestarts(cond)
[09:31:34.378]                           for (restart in restarts) {
[09:31:34.378]                             name <- restart$name
[09:31:34.378]                             if (is.null(name)) 
[09:31:34.378]                               next
[09:31:34.378]                             if (!grepl(pattern, name)) 
[09:31:34.378]                               next
[09:31:34.378]                             invokeRestart(restart)
[09:31:34.378]                             muffled <- TRUE
[09:31:34.378]                             break
[09:31:34.378]                           }
[09:31:34.378]                         }
[09:31:34.378]                       }
[09:31:34.378]                       invisible(muffled)
[09:31:34.378]                     }
[09:31:34.378]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.378]                   }
[09:31:34.378]                 }
[09:31:34.378]                 else {
[09:31:34.378]                   if (TRUE) {
[09:31:34.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.378]                     {
[09:31:34.378]                       inherits <- base::inherits
[09:31:34.378]                       invokeRestart <- base::invokeRestart
[09:31:34.378]                       is.null <- base::is.null
[09:31:34.378]                       muffled <- FALSE
[09:31:34.378]                       if (inherits(cond, "message")) {
[09:31:34.378]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.378]                         if (muffled) 
[09:31:34.378]                           invokeRestart("muffleMessage")
[09:31:34.378]                       }
[09:31:34.378]                       else if (inherits(cond, "warning")) {
[09:31:34.378]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.378]                         if (muffled) 
[09:31:34.378]                           invokeRestart("muffleWarning")
[09:31:34.378]                       }
[09:31:34.378]                       else if (inherits(cond, "condition")) {
[09:31:34.378]                         if (!is.null(pattern)) {
[09:31:34.378]                           computeRestarts <- base::computeRestarts
[09:31:34.378]                           grepl <- base::grepl
[09:31:34.378]                           restarts <- computeRestarts(cond)
[09:31:34.378]                           for (restart in restarts) {
[09:31:34.378]                             name <- restart$name
[09:31:34.378]                             if (is.null(name)) 
[09:31:34.378]                               next
[09:31:34.378]                             if (!grepl(pattern, name)) 
[09:31:34.378]                               next
[09:31:34.378]                             invokeRestart(restart)
[09:31:34.378]                             muffled <- TRUE
[09:31:34.378]                             break
[09:31:34.378]                           }
[09:31:34.378]                         }
[09:31:34.378]                       }
[09:31:34.378]                       invisible(muffled)
[09:31:34.378]                     }
[09:31:34.378]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.378]                   }
[09:31:34.378]                 }
[09:31:34.378]             }
[09:31:34.378]         }))
[09:31:34.378]     }, error = function(ex) {
[09:31:34.378]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.378]                 ...future.rng), started = ...future.startTime, 
[09:31:34.378]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.378]             version = "1.8"), class = "FutureResult")
[09:31:34.378]     }, finally = {
[09:31:34.378]         if (!identical(...future.workdir, getwd())) 
[09:31:34.378]             setwd(...future.workdir)
[09:31:34.378]         {
[09:31:34.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.378]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.378]             }
[09:31:34.378]             base::options(...future.oldOptions)
[09:31:34.378]             if (.Platform$OS.type == "windows") {
[09:31:34.378]                 old_names <- names(...future.oldEnvVars)
[09:31:34.378]                 envs <- base::Sys.getenv()
[09:31:34.378]                 names <- names(envs)
[09:31:34.378]                 common <- intersect(names, old_names)
[09:31:34.378]                 added <- setdiff(names, old_names)
[09:31:34.378]                 removed <- setdiff(old_names, names)
[09:31:34.378]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.378]                   envs[common]]
[09:31:34.378]                 NAMES <- toupper(changed)
[09:31:34.378]                 args <- list()
[09:31:34.378]                 for (kk in seq_along(NAMES)) {
[09:31:34.378]                   name <- changed[[kk]]
[09:31:34.378]                   NAME <- NAMES[[kk]]
[09:31:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.378]                     next
[09:31:34.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.378]                 }
[09:31:34.378]                 NAMES <- toupper(added)
[09:31:34.378]                 for (kk in seq_along(NAMES)) {
[09:31:34.378]                   name <- added[[kk]]
[09:31:34.378]                   NAME <- NAMES[[kk]]
[09:31:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.378]                     next
[09:31:34.378]                   args[[name]] <- ""
[09:31:34.378]                 }
[09:31:34.378]                 NAMES <- toupper(removed)
[09:31:34.378]                 for (kk in seq_along(NAMES)) {
[09:31:34.378]                   name <- removed[[kk]]
[09:31:34.378]                   NAME <- NAMES[[kk]]
[09:31:34.378]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.378]                     next
[09:31:34.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.378]                 }
[09:31:34.378]                 if (length(args) > 0) 
[09:31:34.378]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.378]             }
[09:31:34.378]             else {
[09:31:34.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.378]             }
[09:31:34.378]             {
[09:31:34.378]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.378]                   0L) {
[09:31:34.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.378]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.378]                   base::options(opts)
[09:31:34.378]                 }
[09:31:34.378]                 {
[09:31:34.378]                   {
[09:31:34.378]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.378]                     NULL
[09:31:34.378]                   }
[09:31:34.378]                   options(future.plan = NULL)
[09:31:34.378]                   if (is.na(NA_character_)) 
[09:31:34.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.378]                     .init = FALSE)
[09:31:34.378]                 }
[09:31:34.378]             }
[09:31:34.378]         }
[09:31:34.378]     })
[09:31:34.378]     if (TRUE) {
[09:31:34.378]         base::sink(type = "output", split = FALSE)
[09:31:34.378]         if (TRUE) {
[09:31:34.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.378]         }
[09:31:34.378]         else {
[09:31:34.378]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.378]         }
[09:31:34.378]         base::close(...future.stdout)
[09:31:34.378]         ...future.stdout <- NULL
[09:31:34.378]     }
[09:31:34.378]     ...future.result$conditions <- ...future.conditions
[09:31:34.378]     ...future.result$finished <- base::Sys.time()
[09:31:34.378]     ...future.result
[09:31:34.378] }
[09:31:34.381] assign_globals() ...
[09:31:34.381] List of 2
[09:31:34.381]  $ a : num 1
[09:31:34.381]  $ ii: int 3
[09:31:34.381]  - attr(*, "where")=List of 2
[09:31:34.381]   ..$ a :<environment: R_EmptyEnv> 
[09:31:34.381]   ..$ ii:<environment: R_EmptyEnv> 
[09:31:34.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.381]  - attr(*, "resolved")= logi TRUE
[09:31:34.381]  - attr(*, "total_size")= num 112
[09:31:34.381]  - attr(*, "already-done")= logi TRUE
[09:31:34.388] - copied ‘a’ to environment
[09:31:34.388] - copied ‘ii’ to environment
[09:31:34.388] assign_globals() ... done
[09:31:34.389] requestCore(): workers = 2
[09:31:34.390] MulticoreFuture started
[09:31:34.391] - Launch lazy future ... done
[09:31:34.391] run() for ‘MulticoreFuture’ ... done
[09:31:34.391] result() for MulticoreFuture ...
[09:31:34.391] plan(): Setting new future strategy stack:
[09:31:34.392] List of future strategies:
[09:31:34.392] 1. sequential:
[09:31:34.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.392]    - tweaked: FALSE
[09:31:34.392]    - call: NULL
[09:31:34.393] plan(): nbrOfWorkers() = 1
[09:31:34.396] plan(): Setting new future strategy stack:
[09:31:34.397] List of future strategies:
[09:31:34.397] 1. multicore:
[09:31:34.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.397]    - tweaked: FALSE
[09:31:34.397]    - call: plan(strategy)
[09:31:34.403] plan(): nbrOfWorkers() = 2
[09:31:34.404] result() for MulticoreFuture ...
[09:31:34.404] result() for MulticoreFuture ... done
[09:31:34.405] result() for MulticoreFuture ... done
[09:31:34.405] result() for MulticoreFuture ...
[09:31:34.405] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.406] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.406] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.407] 
[09:31:34.407] Searching for globals ... DONE
[09:31:34.408] - globals: [0] <none>
[09:31:34.408] getGlobalsAndPackages() ... DONE
[09:31:34.408] run() for ‘Future’ ...
[09:31:34.408] - state: ‘created’
[09:31:34.409] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.413] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.413]   - Field: ‘label’
[09:31:34.413]   - Field: ‘local’
[09:31:34.413]   - Field: ‘owner’
[09:31:34.414]   - Field: ‘envir’
[09:31:34.414]   - Field: ‘workers’
[09:31:34.414]   - Field: ‘packages’
[09:31:34.414]   - Field: ‘gc’
[09:31:34.414]   - Field: ‘job’
[09:31:34.414]   - Field: ‘conditions’
[09:31:34.414]   - Field: ‘expr’
[09:31:34.414]   - Field: ‘uuid’
[09:31:34.415]   - Field: ‘seed’
[09:31:34.415]   - Field: ‘version’
[09:31:34.415]   - Field: ‘result’
[09:31:34.415]   - Field: ‘asynchronous’
[09:31:34.415]   - Field: ‘calls’
[09:31:34.415]   - Field: ‘globals’
[09:31:34.415]   - Field: ‘stdout’
[09:31:34.415]   - Field: ‘earlySignal’
[09:31:34.415]   - Field: ‘lazy’
[09:31:34.416]   - Field: ‘state’
[09:31:34.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.416] - Launch lazy future ...
[09:31:34.416] Packages needed by the future expression (n = 0): <none>
[09:31:34.416] Packages needed by future strategies (n = 0): <none>
[09:31:34.417] {
[09:31:34.417]     {
[09:31:34.417]         {
[09:31:34.417]             ...future.startTime <- base::Sys.time()
[09:31:34.417]             {
[09:31:34.417]                 {
[09:31:34.417]                   {
[09:31:34.417]                     {
[09:31:34.417]                       base::local({
[09:31:34.417]                         has_future <- base::requireNamespace("future", 
[09:31:34.417]                           quietly = TRUE)
[09:31:34.417]                         if (has_future) {
[09:31:34.417]                           ns <- base::getNamespace("future")
[09:31:34.417]                           version <- ns[[".package"]][["version"]]
[09:31:34.417]                           if (is.null(version)) 
[09:31:34.417]                             version <- utils::packageVersion("future")
[09:31:34.417]                         }
[09:31:34.417]                         else {
[09:31:34.417]                           version <- NULL
[09:31:34.417]                         }
[09:31:34.417]                         if (!has_future || version < "1.8.0") {
[09:31:34.417]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.417]                             "", base::R.version$version.string), 
[09:31:34.417]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.417]                               "release", "version")], collapse = " "), 
[09:31:34.417]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.417]                             info)
[09:31:34.417]                           info <- base::paste(info, collapse = "; ")
[09:31:34.417]                           if (!has_future) {
[09:31:34.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.417]                               info)
[09:31:34.417]                           }
[09:31:34.417]                           else {
[09:31:34.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.417]                               info, version)
[09:31:34.417]                           }
[09:31:34.417]                           base::stop(msg)
[09:31:34.417]                         }
[09:31:34.417]                       })
[09:31:34.417]                     }
[09:31:34.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.417]                     base::options(mc.cores = 1L)
[09:31:34.417]                   }
[09:31:34.417]                   ...future.strategy.old <- future::plan("list")
[09:31:34.417]                   options(future.plan = NULL)
[09:31:34.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.417]                 }
[09:31:34.417]                 ...future.workdir <- getwd()
[09:31:34.417]             }
[09:31:34.417]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.417]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.417]         }
[09:31:34.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.417]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.417]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.417]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.417]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.417]             base::names(...future.oldOptions))
[09:31:34.417]     }
[09:31:34.417]     if (FALSE) {
[09:31:34.417]     }
[09:31:34.417]     else {
[09:31:34.417]         if (TRUE) {
[09:31:34.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.417]                 open = "w")
[09:31:34.417]         }
[09:31:34.417]         else {
[09:31:34.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.417]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.417]         }
[09:31:34.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.417]             base::sink(type = "output", split = FALSE)
[09:31:34.417]             base::close(...future.stdout)
[09:31:34.417]         }, add = TRUE)
[09:31:34.417]     }
[09:31:34.417]     ...future.frame <- base::sys.nframe()
[09:31:34.417]     ...future.conditions <- base::list()
[09:31:34.417]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.417]     if (FALSE) {
[09:31:34.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.417]     }
[09:31:34.417]     ...future.result <- base::tryCatch({
[09:31:34.417]         base::withCallingHandlers({
[09:31:34.417]             ...future.value <- base::withVisible(base::local({
[09:31:34.417]                 withCallingHandlers({
[09:31:34.417]                   1
[09:31:34.417]                 }, immediateCondition = function(cond) {
[09:31:34.417]                   save_rds <- function (object, pathname, ...) 
[09:31:34.417]                   {
[09:31:34.417]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.417]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.417]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.417]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.417]                         fi_tmp[["mtime"]])
[09:31:34.417]                     }
[09:31:34.417]                     tryCatch({
[09:31:34.417]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.417]                     }, error = function(ex) {
[09:31:34.417]                       msg <- conditionMessage(ex)
[09:31:34.417]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.417]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.417]                         fi_tmp[["mtime"]], msg)
[09:31:34.417]                       ex$message <- msg
[09:31:34.417]                       stop(ex)
[09:31:34.417]                     })
[09:31:34.417]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.417]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.417]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.417]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.417]                       fi <- file.info(pathname)
[09:31:34.417]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.417]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.417]                         fi[["size"]], fi[["mtime"]])
[09:31:34.417]                       stop(msg)
[09:31:34.417]                     }
[09:31:34.417]                     invisible(pathname)
[09:31:34.417]                   }
[09:31:34.417]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.417]                     rootPath = tempdir()) 
[09:31:34.417]                   {
[09:31:34.417]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.417]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.417]                       tmpdir = path, fileext = ".rds")
[09:31:34.417]                     save_rds(obj, file)
[09:31:34.417]                   }
[09:31:34.417]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.417]                   {
[09:31:34.417]                     inherits <- base::inherits
[09:31:34.417]                     invokeRestart <- base::invokeRestart
[09:31:34.417]                     is.null <- base::is.null
[09:31:34.417]                     muffled <- FALSE
[09:31:34.417]                     if (inherits(cond, "message")) {
[09:31:34.417]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.417]                       if (muffled) 
[09:31:34.417]                         invokeRestart("muffleMessage")
[09:31:34.417]                     }
[09:31:34.417]                     else if (inherits(cond, "warning")) {
[09:31:34.417]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.417]                       if (muffled) 
[09:31:34.417]                         invokeRestart("muffleWarning")
[09:31:34.417]                     }
[09:31:34.417]                     else if (inherits(cond, "condition")) {
[09:31:34.417]                       if (!is.null(pattern)) {
[09:31:34.417]                         computeRestarts <- base::computeRestarts
[09:31:34.417]                         grepl <- base::grepl
[09:31:34.417]                         restarts <- computeRestarts(cond)
[09:31:34.417]                         for (restart in restarts) {
[09:31:34.417]                           name <- restart$name
[09:31:34.417]                           if (is.null(name)) 
[09:31:34.417]                             next
[09:31:34.417]                           if (!grepl(pattern, name)) 
[09:31:34.417]                             next
[09:31:34.417]                           invokeRestart(restart)
[09:31:34.417]                           muffled <- TRUE
[09:31:34.417]                           break
[09:31:34.417]                         }
[09:31:34.417]                       }
[09:31:34.417]                     }
[09:31:34.417]                     invisible(muffled)
[09:31:34.417]                   }
[09:31:34.417]                   muffleCondition(cond)
[09:31:34.417]                 })
[09:31:34.417]             }))
[09:31:34.417]             future::FutureResult(value = ...future.value$value, 
[09:31:34.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.417]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.417]                     ...future.globalenv.names))
[09:31:34.417]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.417]         }, condition = base::local({
[09:31:34.417]             c <- base::c
[09:31:34.417]             inherits <- base::inherits
[09:31:34.417]             invokeRestart <- base::invokeRestart
[09:31:34.417]             length <- base::length
[09:31:34.417]             list <- base::list
[09:31:34.417]             seq.int <- base::seq.int
[09:31:34.417]             signalCondition <- base::signalCondition
[09:31:34.417]             sys.calls <- base::sys.calls
[09:31:34.417]             `[[` <- base::`[[`
[09:31:34.417]             `+` <- base::`+`
[09:31:34.417]             `<<-` <- base::`<<-`
[09:31:34.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.417]                   3L)]
[09:31:34.417]             }
[09:31:34.417]             function(cond) {
[09:31:34.417]                 is_error <- inherits(cond, "error")
[09:31:34.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.417]                   NULL)
[09:31:34.417]                 if (is_error) {
[09:31:34.417]                   sessionInformation <- function() {
[09:31:34.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.417]                       search = base::search(), system = base::Sys.info())
[09:31:34.417]                   }
[09:31:34.417]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.417]                     cond$call), session = sessionInformation(), 
[09:31:34.417]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.417]                   signalCondition(cond)
[09:31:34.417]                 }
[09:31:34.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.417]                 "immediateCondition"))) {
[09:31:34.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.417]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.417]                   if (TRUE && !signal) {
[09:31:34.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.417]                     {
[09:31:34.417]                       inherits <- base::inherits
[09:31:34.417]                       invokeRestart <- base::invokeRestart
[09:31:34.417]                       is.null <- base::is.null
[09:31:34.417]                       muffled <- FALSE
[09:31:34.417]                       if (inherits(cond, "message")) {
[09:31:34.417]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.417]                         if (muffled) 
[09:31:34.417]                           invokeRestart("muffleMessage")
[09:31:34.417]                       }
[09:31:34.417]                       else if (inherits(cond, "warning")) {
[09:31:34.417]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.417]                         if (muffled) 
[09:31:34.417]                           invokeRestart("muffleWarning")
[09:31:34.417]                       }
[09:31:34.417]                       else if (inherits(cond, "condition")) {
[09:31:34.417]                         if (!is.null(pattern)) {
[09:31:34.417]                           computeRestarts <- base::computeRestarts
[09:31:34.417]                           grepl <- base::grepl
[09:31:34.417]                           restarts <- computeRestarts(cond)
[09:31:34.417]                           for (restart in restarts) {
[09:31:34.417]                             name <- restart$name
[09:31:34.417]                             if (is.null(name)) 
[09:31:34.417]                               next
[09:31:34.417]                             if (!grepl(pattern, name)) 
[09:31:34.417]                               next
[09:31:34.417]                             invokeRestart(restart)
[09:31:34.417]                             muffled <- TRUE
[09:31:34.417]                             break
[09:31:34.417]                           }
[09:31:34.417]                         }
[09:31:34.417]                       }
[09:31:34.417]                       invisible(muffled)
[09:31:34.417]                     }
[09:31:34.417]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.417]                   }
[09:31:34.417]                 }
[09:31:34.417]                 else {
[09:31:34.417]                   if (TRUE) {
[09:31:34.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.417]                     {
[09:31:34.417]                       inherits <- base::inherits
[09:31:34.417]                       invokeRestart <- base::invokeRestart
[09:31:34.417]                       is.null <- base::is.null
[09:31:34.417]                       muffled <- FALSE
[09:31:34.417]                       if (inherits(cond, "message")) {
[09:31:34.417]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.417]                         if (muffled) 
[09:31:34.417]                           invokeRestart("muffleMessage")
[09:31:34.417]                       }
[09:31:34.417]                       else if (inherits(cond, "warning")) {
[09:31:34.417]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.417]                         if (muffled) 
[09:31:34.417]                           invokeRestart("muffleWarning")
[09:31:34.417]                       }
[09:31:34.417]                       else if (inherits(cond, "condition")) {
[09:31:34.417]                         if (!is.null(pattern)) {
[09:31:34.417]                           computeRestarts <- base::computeRestarts
[09:31:34.417]                           grepl <- base::grepl
[09:31:34.417]                           restarts <- computeRestarts(cond)
[09:31:34.417]                           for (restart in restarts) {
[09:31:34.417]                             name <- restart$name
[09:31:34.417]                             if (is.null(name)) 
[09:31:34.417]                               next
[09:31:34.417]                             if (!grepl(pattern, name)) 
[09:31:34.417]                               next
[09:31:34.417]                             invokeRestart(restart)
[09:31:34.417]                             muffled <- TRUE
[09:31:34.417]                             break
[09:31:34.417]                           }
[09:31:34.417]                         }
[09:31:34.417]                       }
[09:31:34.417]                       invisible(muffled)
[09:31:34.417]                     }
[09:31:34.417]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.417]                   }
[09:31:34.417]                 }
[09:31:34.417]             }
[09:31:34.417]         }))
[09:31:34.417]     }, error = function(ex) {
[09:31:34.417]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.417]                 ...future.rng), started = ...future.startTime, 
[09:31:34.417]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.417]             version = "1.8"), class = "FutureResult")
[09:31:34.417]     }, finally = {
[09:31:34.417]         if (!identical(...future.workdir, getwd())) 
[09:31:34.417]             setwd(...future.workdir)
[09:31:34.417]         {
[09:31:34.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.417]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.417]             }
[09:31:34.417]             base::options(...future.oldOptions)
[09:31:34.417]             if (.Platform$OS.type == "windows") {
[09:31:34.417]                 old_names <- names(...future.oldEnvVars)
[09:31:34.417]                 envs <- base::Sys.getenv()
[09:31:34.417]                 names <- names(envs)
[09:31:34.417]                 common <- intersect(names, old_names)
[09:31:34.417]                 added <- setdiff(names, old_names)
[09:31:34.417]                 removed <- setdiff(old_names, names)
[09:31:34.417]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.417]                   envs[common]]
[09:31:34.417]                 NAMES <- toupper(changed)
[09:31:34.417]                 args <- list()
[09:31:34.417]                 for (kk in seq_along(NAMES)) {
[09:31:34.417]                   name <- changed[[kk]]
[09:31:34.417]                   NAME <- NAMES[[kk]]
[09:31:34.417]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.417]                     next
[09:31:34.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.417]                 }
[09:31:34.417]                 NAMES <- toupper(added)
[09:31:34.417]                 for (kk in seq_along(NAMES)) {
[09:31:34.417]                   name <- added[[kk]]
[09:31:34.417]                   NAME <- NAMES[[kk]]
[09:31:34.417]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.417]                     next
[09:31:34.417]                   args[[name]] <- ""
[09:31:34.417]                 }
[09:31:34.417]                 NAMES <- toupper(removed)
[09:31:34.417]                 for (kk in seq_along(NAMES)) {
[09:31:34.417]                   name <- removed[[kk]]
[09:31:34.417]                   NAME <- NAMES[[kk]]
[09:31:34.417]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.417]                     next
[09:31:34.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.417]                 }
[09:31:34.417]                 if (length(args) > 0) 
[09:31:34.417]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.417]             }
[09:31:34.417]             else {
[09:31:34.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.417]             }
[09:31:34.417]             {
[09:31:34.417]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.417]                   0L) {
[09:31:34.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.417]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.417]                   base::options(opts)
[09:31:34.417]                 }
[09:31:34.417]                 {
[09:31:34.417]                   {
[09:31:34.417]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.417]                     NULL
[09:31:34.417]                   }
[09:31:34.417]                   options(future.plan = NULL)
[09:31:34.417]                   if (is.na(NA_character_)) 
[09:31:34.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.417]                     .init = FALSE)
[09:31:34.417]                 }
[09:31:34.417]             }
[09:31:34.417]         }
[09:31:34.417]     })
[09:31:34.417]     if (TRUE) {
[09:31:34.417]         base::sink(type = "output", split = FALSE)
[09:31:34.417]         if (TRUE) {
[09:31:34.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.417]         }
[09:31:34.417]         else {
[09:31:34.417]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.417]         }
[09:31:34.417]         base::close(...future.stdout)
[09:31:34.417]         ...future.stdout <- NULL
[09:31:34.417]     }
[09:31:34.417]     ...future.result$conditions <- ...future.conditions
[09:31:34.417]     ...future.result$finished <- base::Sys.time()
[09:31:34.417]     ...future.result
[09:31:34.417] }
[09:31:34.419] requestCore(): workers = 2
[09:31:34.421] MulticoreFuture started
[09:31:34.422] - Launch lazy future ... done
[09:31:34.422] run() for ‘MulticoreFuture’ ... done
[09:31:34.422] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.422] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.423] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.422] List of future strategies:
[09:31:34.422] 1. sequential:
[09:31:34.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.422]    - tweaked: FALSE
[09:31:34.422]    - call: NULL
[09:31:34.424] plan(): nbrOfWorkers() = 1
[09:31:34.425] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:34.425] Searching for globals ... DONE
[09:31:34.425] Resolving globals: TRUE
[09:31:34.425] Resolving any globals that are futures ...
[09:31:34.425] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:34.425] Resolving any globals that are futures ... DONE
[09:31:34.425] plan(): Setting new future strategy stack:
[09:31:34.426] List of future strategies:
[09:31:34.426] 1. multicore:
[09:31:34.426]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.426]    - tweaked: FALSE
[09:31:34.426]    - call: plan(strategy)
[09:31:34.426] Resolving futures part of globals (recursively) ...
[09:31:34.427] resolve() on list ...
[09:31:34.427]  recursive: 99
[09:31:34.427]  length: 1
[09:31:34.427]  elements: ‘a’
[09:31:34.430] plan(): nbrOfWorkers() = 2
[09:31:34.431] Future #1
[09:31:34.431] result() for MulticoreFuture ...
[09:31:34.432] result() for MulticoreFuture ...
[09:31:34.432] result() for MulticoreFuture ... done
[09:31:34.432] result() for MulticoreFuture ... done
[09:31:34.432] result() for MulticoreFuture ...
[09:31:34.433] result() for MulticoreFuture ... done
[09:31:34.433] A MulticoreFuture was resolved
[09:31:34.433]  length: 0 (resolved future 1)
[09:31:34.433] resolve() on list ... DONE
[09:31:34.433] - globals: [1] ‘a’
[09:31:34.433] Resolving futures part of globals (recursively) ... DONE
[09:31:34.436] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[09:31:34.436] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:34.437] - globals: [1] ‘a’
[09:31:34.437] - packages: [1] ‘future’
[09:31:34.437] getGlobalsAndPackages() ... DONE
[09:31:34.437] run() for ‘Future’ ...
[09:31:34.437] - state: ‘created’
[09:31:34.437] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.442] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.442]   - Field: ‘label’
[09:31:34.442]   - Field: ‘local’
[09:31:34.442]   - Field: ‘owner’
[09:31:34.442]   - Field: ‘envir’
[09:31:34.442]   - Field: ‘workers’
[09:31:34.442]   - Field: ‘packages’
[09:31:34.443]   - Field: ‘gc’
[09:31:34.443]   - Field: ‘job’
[09:31:34.443]   - Field: ‘conditions’
[09:31:34.443]   - Field: ‘expr’
[09:31:34.443]   - Field: ‘uuid’
[09:31:34.443]   - Field: ‘seed’
[09:31:34.443]   - Field: ‘version’
[09:31:34.443]   - Field: ‘result’
[09:31:34.443]   - Field: ‘asynchronous’
[09:31:34.444]   - Field: ‘calls’
[09:31:34.444]   - Field: ‘globals’
[09:31:34.444]   - Field: ‘stdout’
[09:31:34.444]   - Field: ‘earlySignal’
[09:31:34.444]   - Field: ‘lazy’
[09:31:34.444]   - Field: ‘state’
[09:31:34.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.444] - Launch lazy future ...
[09:31:34.445] Packages needed by the future expression (n = 1): ‘future’
[09:31:34.445] Packages needed by future strategies (n = 0): <none>
[09:31:34.446] {
[09:31:34.446]     {
[09:31:34.446]         {
[09:31:34.446]             ...future.startTime <- base::Sys.time()
[09:31:34.446]             {
[09:31:34.446]                 {
[09:31:34.446]                   {
[09:31:34.446]                     {
[09:31:34.446]                       {
[09:31:34.446]                         base::local({
[09:31:34.446]                           has_future <- base::requireNamespace("future", 
[09:31:34.446]                             quietly = TRUE)
[09:31:34.446]                           if (has_future) {
[09:31:34.446]                             ns <- base::getNamespace("future")
[09:31:34.446]                             version <- ns[[".package"]][["version"]]
[09:31:34.446]                             if (is.null(version)) 
[09:31:34.446]                               version <- utils::packageVersion("future")
[09:31:34.446]                           }
[09:31:34.446]                           else {
[09:31:34.446]                             version <- NULL
[09:31:34.446]                           }
[09:31:34.446]                           if (!has_future || version < "1.8.0") {
[09:31:34.446]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.446]                               "", base::R.version$version.string), 
[09:31:34.446]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:34.446]                                 base::R.version$platform, 8 * 
[09:31:34.446]                                   base::.Machine$sizeof.pointer), 
[09:31:34.446]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.446]                                 "release", "version")], collapse = " "), 
[09:31:34.446]                               hostname = base::Sys.info()[["nodename"]])
[09:31:34.446]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.446]                               info)
[09:31:34.446]                             info <- base::paste(info, collapse = "; ")
[09:31:34.446]                             if (!has_future) {
[09:31:34.446]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.446]                                 info)
[09:31:34.446]                             }
[09:31:34.446]                             else {
[09:31:34.446]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.446]                                 info, version)
[09:31:34.446]                             }
[09:31:34.446]                             base::stop(msg)
[09:31:34.446]                           }
[09:31:34.446]                         })
[09:31:34.446]                       }
[09:31:34.446]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.446]                       base::options(mc.cores = 1L)
[09:31:34.446]                     }
[09:31:34.446]                     base::local({
[09:31:34.446]                       for (pkg in "future") {
[09:31:34.446]                         base::loadNamespace(pkg)
[09:31:34.446]                         base::library(pkg, character.only = TRUE)
[09:31:34.446]                       }
[09:31:34.446]                     })
[09:31:34.446]                   }
[09:31:34.446]                   ...future.strategy.old <- future::plan("list")
[09:31:34.446]                   options(future.plan = NULL)
[09:31:34.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.446]                 }
[09:31:34.446]                 ...future.workdir <- getwd()
[09:31:34.446]             }
[09:31:34.446]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.446]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.446]         }
[09:31:34.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.446]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.446]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.446]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.446]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.446]             base::names(...future.oldOptions))
[09:31:34.446]     }
[09:31:34.446]     if (FALSE) {
[09:31:34.446]     }
[09:31:34.446]     else {
[09:31:34.446]         if (TRUE) {
[09:31:34.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.446]                 open = "w")
[09:31:34.446]         }
[09:31:34.446]         else {
[09:31:34.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.446]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.446]         }
[09:31:34.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.446]             base::sink(type = "output", split = FALSE)
[09:31:34.446]             base::close(...future.stdout)
[09:31:34.446]         }, add = TRUE)
[09:31:34.446]     }
[09:31:34.446]     ...future.frame <- base::sys.nframe()
[09:31:34.446]     ...future.conditions <- base::list()
[09:31:34.446]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.446]     if (FALSE) {
[09:31:34.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.446]     }
[09:31:34.446]     ...future.result <- base::tryCatch({
[09:31:34.446]         base::withCallingHandlers({
[09:31:34.446]             ...future.value <- base::withVisible(base::local({
[09:31:34.446]                 withCallingHandlers({
[09:31:34.446]                   value(a) + 1
[09:31:34.446]                 }, immediateCondition = function(cond) {
[09:31:34.446]                   save_rds <- function (object, pathname, ...) 
[09:31:34.446]                   {
[09:31:34.446]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.446]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.446]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.446]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.446]                         fi_tmp[["mtime"]])
[09:31:34.446]                     }
[09:31:34.446]                     tryCatch({
[09:31:34.446]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.446]                     }, error = function(ex) {
[09:31:34.446]                       msg <- conditionMessage(ex)
[09:31:34.446]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.446]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.446]                         fi_tmp[["mtime"]], msg)
[09:31:34.446]                       ex$message <- msg
[09:31:34.446]                       stop(ex)
[09:31:34.446]                     })
[09:31:34.446]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.446]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.446]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.446]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.446]                       fi <- file.info(pathname)
[09:31:34.446]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.446]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.446]                         fi[["size"]], fi[["mtime"]])
[09:31:34.446]                       stop(msg)
[09:31:34.446]                     }
[09:31:34.446]                     invisible(pathname)
[09:31:34.446]                   }
[09:31:34.446]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.446]                     rootPath = tempdir()) 
[09:31:34.446]                   {
[09:31:34.446]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.446]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.446]                       tmpdir = path, fileext = ".rds")
[09:31:34.446]                     save_rds(obj, file)
[09:31:34.446]                   }
[09:31:34.446]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.446]                   {
[09:31:34.446]                     inherits <- base::inherits
[09:31:34.446]                     invokeRestart <- base::invokeRestart
[09:31:34.446]                     is.null <- base::is.null
[09:31:34.446]                     muffled <- FALSE
[09:31:34.446]                     if (inherits(cond, "message")) {
[09:31:34.446]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.446]                       if (muffled) 
[09:31:34.446]                         invokeRestart("muffleMessage")
[09:31:34.446]                     }
[09:31:34.446]                     else if (inherits(cond, "warning")) {
[09:31:34.446]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.446]                       if (muffled) 
[09:31:34.446]                         invokeRestart("muffleWarning")
[09:31:34.446]                     }
[09:31:34.446]                     else if (inherits(cond, "condition")) {
[09:31:34.446]                       if (!is.null(pattern)) {
[09:31:34.446]                         computeRestarts <- base::computeRestarts
[09:31:34.446]                         grepl <- base::grepl
[09:31:34.446]                         restarts <- computeRestarts(cond)
[09:31:34.446]                         for (restart in restarts) {
[09:31:34.446]                           name <- restart$name
[09:31:34.446]                           if (is.null(name)) 
[09:31:34.446]                             next
[09:31:34.446]                           if (!grepl(pattern, name)) 
[09:31:34.446]                             next
[09:31:34.446]                           invokeRestart(restart)
[09:31:34.446]                           muffled <- TRUE
[09:31:34.446]                           break
[09:31:34.446]                         }
[09:31:34.446]                       }
[09:31:34.446]                     }
[09:31:34.446]                     invisible(muffled)
[09:31:34.446]                   }
[09:31:34.446]                   muffleCondition(cond)
[09:31:34.446]                 })
[09:31:34.446]             }))
[09:31:34.446]             future::FutureResult(value = ...future.value$value, 
[09:31:34.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.446]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.446]                     ...future.globalenv.names))
[09:31:34.446]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.446]         }, condition = base::local({
[09:31:34.446]             c <- base::c
[09:31:34.446]             inherits <- base::inherits
[09:31:34.446]             invokeRestart <- base::invokeRestart
[09:31:34.446]             length <- base::length
[09:31:34.446]             list <- base::list
[09:31:34.446]             seq.int <- base::seq.int
[09:31:34.446]             signalCondition <- base::signalCondition
[09:31:34.446]             sys.calls <- base::sys.calls
[09:31:34.446]             `[[` <- base::`[[`
[09:31:34.446]             `+` <- base::`+`
[09:31:34.446]             `<<-` <- base::`<<-`
[09:31:34.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.446]                   3L)]
[09:31:34.446]             }
[09:31:34.446]             function(cond) {
[09:31:34.446]                 is_error <- inherits(cond, "error")
[09:31:34.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.446]                   NULL)
[09:31:34.446]                 if (is_error) {
[09:31:34.446]                   sessionInformation <- function() {
[09:31:34.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.446]                       search = base::search(), system = base::Sys.info())
[09:31:34.446]                   }
[09:31:34.446]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.446]                     cond$call), session = sessionInformation(), 
[09:31:34.446]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.446]                   signalCondition(cond)
[09:31:34.446]                 }
[09:31:34.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.446]                 "immediateCondition"))) {
[09:31:34.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.446]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.446]                   if (TRUE && !signal) {
[09:31:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.446]                     {
[09:31:34.446]                       inherits <- base::inherits
[09:31:34.446]                       invokeRestart <- base::invokeRestart
[09:31:34.446]                       is.null <- base::is.null
[09:31:34.446]                       muffled <- FALSE
[09:31:34.446]                       if (inherits(cond, "message")) {
[09:31:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.446]                         if (muffled) 
[09:31:34.446]                           invokeRestart("muffleMessage")
[09:31:34.446]                       }
[09:31:34.446]                       else if (inherits(cond, "warning")) {
[09:31:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.446]                         if (muffled) 
[09:31:34.446]                           invokeRestart("muffleWarning")
[09:31:34.446]                       }
[09:31:34.446]                       else if (inherits(cond, "condition")) {
[09:31:34.446]                         if (!is.null(pattern)) {
[09:31:34.446]                           computeRestarts <- base::computeRestarts
[09:31:34.446]                           grepl <- base::grepl
[09:31:34.446]                           restarts <- computeRestarts(cond)
[09:31:34.446]                           for (restart in restarts) {
[09:31:34.446]                             name <- restart$name
[09:31:34.446]                             if (is.null(name)) 
[09:31:34.446]                               next
[09:31:34.446]                             if (!grepl(pattern, name)) 
[09:31:34.446]                               next
[09:31:34.446]                             invokeRestart(restart)
[09:31:34.446]                             muffled <- TRUE
[09:31:34.446]                             break
[09:31:34.446]                           }
[09:31:34.446]                         }
[09:31:34.446]                       }
[09:31:34.446]                       invisible(muffled)
[09:31:34.446]                     }
[09:31:34.446]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.446]                   }
[09:31:34.446]                 }
[09:31:34.446]                 else {
[09:31:34.446]                   if (TRUE) {
[09:31:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.446]                     {
[09:31:34.446]                       inherits <- base::inherits
[09:31:34.446]                       invokeRestart <- base::invokeRestart
[09:31:34.446]                       is.null <- base::is.null
[09:31:34.446]                       muffled <- FALSE
[09:31:34.446]                       if (inherits(cond, "message")) {
[09:31:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.446]                         if (muffled) 
[09:31:34.446]                           invokeRestart("muffleMessage")
[09:31:34.446]                       }
[09:31:34.446]                       else if (inherits(cond, "warning")) {
[09:31:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.446]                         if (muffled) 
[09:31:34.446]                           invokeRestart("muffleWarning")
[09:31:34.446]                       }
[09:31:34.446]                       else if (inherits(cond, "condition")) {
[09:31:34.446]                         if (!is.null(pattern)) {
[09:31:34.446]                           computeRestarts <- base::computeRestarts
[09:31:34.446]                           grepl <- base::grepl
[09:31:34.446]                           restarts <- computeRestarts(cond)
[09:31:34.446]                           for (restart in restarts) {
[09:31:34.446]                             name <- restart$name
[09:31:34.446]                             if (is.null(name)) 
[09:31:34.446]                               next
[09:31:34.446]                             if (!grepl(pattern, name)) 
[09:31:34.446]                               next
[09:31:34.446]                             invokeRestart(restart)
[09:31:34.446]                             muffled <- TRUE
[09:31:34.446]                             break
[09:31:34.446]                           }
[09:31:34.446]                         }
[09:31:34.446]                       }
[09:31:34.446]                       invisible(muffled)
[09:31:34.446]                     }
[09:31:34.446]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.446]                   }
[09:31:34.446]                 }
[09:31:34.446]             }
[09:31:34.446]         }))
[09:31:34.446]     }, error = function(ex) {
[09:31:34.446]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.446]                 ...future.rng), started = ...future.startTime, 
[09:31:34.446]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.446]             version = "1.8"), class = "FutureResult")
[09:31:34.446]     }, finally = {
[09:31:34.446]         if (!identical(...future.workdir, getwd())) 
[09:31:34.446]             setwd(...future.workdir)
[09:31:34.446]         {
[09:31:34.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.446]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.446]             }
[09:31:34.446]             base::options(...future.oldOptions)
[09:31:34.446]             if (.Platform$OS.type == "windows") {
[09:31:34.446]                 old_names <- names(...future.oldEnvVars)
[09:31:34.446]                 envs <- base::Sys.getenv()
[09:31:34.446]                 names <- names(envs)
[09:31:34.446]                 common <- intersect(names, old_names)
[09:31:34.446]                 added <- setdiff(names, old_names)
[09:31:34.446]                 removed <- setdiff(old_names, names)
[09:31:34.446]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.446]                   envs[common]]
[09:31:34.446]                 NAMES <- toupper(changed)
[09:31:34.446]                 args <- list()
[09:31:34.446]                 for (kk in seq_along(NAMES)) {
[09:31:34.446]                   name <- changed[[kk]]
[09:31:34.446]                   NAME <- NAMES[[kk]]
[09:31:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.446]                     next
[09:31:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.446]                 }
[09:31:34.446]                 NAMES <- toupper(added)
[09:31:34.446]                 for (kk in seq_along(NAMES)) {
[09:31:34.446]                   name <- added[[kk]]
[09:31:34.446]                   NAME <- NAMES[[kk]]
[09:31:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.446]                     next
[09:31:34.446]                   args[[name]] <- ""
[09:31:34.446]                 }
[09:31:34.446]                 NAMES <- toupper(removed)
[09:31:34.446]                 for (kk in seq_along(NAMES)) {
[09:31:34.446]                   name <- removed[[kk]]
[09:31:34.446]                   NAME <- NAMES[[kk]]
[09:31:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.446]                     next
[09:31:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.446]                 }
[09:31:34.446]                 if (length(args) > 0) 
[09:31:34.446]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.446]             }
[09:31:34.446]             else {
[09:31:34.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.446]             }
[09:31:34.446]             {
[09:31:34.446]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.446]                   0L) {
[09:31:34.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.446]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.446]                   base::options(opts)
[09:31:34.446]                 }
[09:31:34.446]                 {
[09:31:34.446]                   {
[09:31:34.446]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.446]                     NULL
[09:31:34.446]                   }
[09:31:34.446]                   options(future.plan = NULL)
[09:31:34.446]                   if (is.na(NA_character_)) 
[09:31:34.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.446]                     .init = FALSE)
[09:31:34.446]                 }
[09:31:34.446]             }
[09:31:34.446]         }
[09:31:34.446]     })
[09:31:34.446]     if (TRUE) {
[09:31:34.446]         base::sink(type = "output", split = FALSE)
[09:31:34.446]         if (TRUE) {
[09:31:34.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.446]         }
[09:31:34.446]         else {
[09:31:34.446]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.446]         }
[09:31:34.446]         base::close(...future.stdout)
[09:31:34.446]         ...future.stdout <- NULL
[09:31:34.446]     }
[09:31:34.446]     ...future.result$conditions <- ...future.conditions
[09:31:34.446]     ...future.result$finished <- base::Sys.time()
[09:31:34.446]     ...future.result
[09:31:34.446] }
[09:31:34.450] assign_globals() ...
[09:31:34.450] List of 1
[09:31:34.450]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e218e6a3d8> 
[09:31:34.450]  - attr(*, "where")=List of 1
[09:31:34.450]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.450]  - attr(*, "resolved")= logi TRUE
[09:31:34.450]  - attr(*, "total_size")= num 1647480
[09:31:34.450]  - attr(*, "already-done")= logi TRUE
[09:31:34.454] - copied ‘a’ to environment
[09:31:34.454] assign_globals() ... done
[09:31:34.454] requestCore(): workers = 2
[09:31:34.456] MulticoreFuture started
[09:31:34.456] - Launch lazy future ... done
[09:31:34.456] run() for ‘MulticoreFuture’ ... done
[09:31:34.457] result() for MulticoreFuture ...
[09:31:34.457] plan(): Setting new future strategy stack:
[09:31:34.457] List of future strategies:
[09:31:34.457] 1. sequential:
[09:31:34.457]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.457]    - tweaked: FALSE
[09:31:34.457]    - call: NULL
[09:31:34.459] plan(): nbrOfWorkers() = 1
[09:31:34.464] plan(): Setting new future strategy stack:
[09:31:34.465] List of future strategies:
[09:31:34.465] 1. multicore:
[09:31:34.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.465]    - tweaked: FALSE
[09:31:34.465]    - call: plan(strategy)
[09:31:34.471] plan(): nbrOfWorkers() = 2
[09:31:34.472] result() for MulticoreFuture ...
[09:31:34.472] result() for MulticoreFuture ... done
[09:31:34.472] signalConditions() ...
[09:31:34.472]  - include = ‘immediateCondition’
[09:31:34.473]  - exclude = 
[09:31:34.473]  - resignal = FALSE
[09:31:34.473]  - Number of conditions: 4
[09:31:34.473] signalConditions() ... done
[09:31:34.473] result() for MulticoreFuture ... done
[09:31:34.474] result() for MulticoreFuture ...
[09:31:34.474] result() for MulticoreFuture ... done
[09:31:34.474] signalConditions() ...
[09:31:34.474]  - include = ‘immediateCondition’
[09:31:34.474]  - exclude = 
[09:31:34.475]  - resignal = FALSE
[09:31:34.475]  - Number of conditions: 4
[09:31:34.475] signalConditions() ... done
[09:31:34.475] Future state: ‘finished’
[09:31:34.475] result() for MulticoreFuture ...
[09:31:34.475] result() for MulticoreFuture ... done
[09:31:34.476] signalConditions() ...
[09:31:34.476]  - include = ‘condition’
[09:31:34.476]  - exclude = ‘immediateCondition’
[09:31:34.476]  - resignal = TRUE
[09:31:34.476]  - Number of conditions: 4
[09:31:34.476]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.461] result() for MulticoreFuture ...
[09:31:34.476]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.462] result() for MulticoreFuture ... done
[09:31:34.477]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.462] result() for MulticoreFuture ...
[09:31:34.477]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.463] result() for MulticoreFuture ... done
[09:31:34.477] signalConditions() ... done
value(b) = 2
[09:31:34.477] result() for MulticoreFuture ...
[09:31:34.477] result() for MulticoreFuture ... done
[09:31:34.478] result() for MulticoreFuture ...
[09:31:34.478] result() for MulticoreFuture ... done
[09:31:34.478] signalConditions() ...
[09:31:34.478]  - include = ‘immediateCondition’
[09:31:34.478]  - exclude = 
[09:31:34.478]  - resignal = FALSE
[09:31:34.478]  - Number of conditions: 4
[09:31:34.478] signalConditions() ... done
[09:31:34.478] Future state: ‘finished’
[09:31:34.479] result() for MulticoreFuture ...
[09:31:34.479] result() for MulticoreFuture ... done
[09:31:34.479] signalConditions() ...
[09:31:34.479]  - include = ‘condition’
[09:31:34.479]  - exclude = ‘immediateCondition’
[09:31:34.479]  - resignal = TRUE
[09:31:34.479]  - Number of conditions: 4
[09:31:34.479]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.461] result() for MulticoreFuture ...
[09:31:34.480]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.462] result() for MulticoreFuture ... done
[09:31:34.480]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.462] result() for MulticoreFuture ...
[09:31:34.480]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.463] result() for MulticoreFuture ... done
[09:31:34.480] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.480] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.481] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.481] 
[09:31:34.481] Searching for globals ... DONE
[09:31:34.481] - globals: [0] <none>
[09:31:34.481] getGlobalsAndPackages() ... DONE
[09:31:34.482] run() for ‘Future’ ...
[09:31:34.482] - state: ‘created’
[09:31:34.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.486]   - Field: ‘label’
[09:31:34.486]   - Field: ‘local’
[09:31:34.486]   - Field: ‘owner’
[09:31:34.487]   - Field: ‘envir’
[09:31:34.487]   - Field: ‘workers’
[09:31:34.487]   - Field: ‘packages’
[09:31:34.487]   - Field: ‘gc’
[09:31:34.487]   - Field: ‘job’
[09:31:34.487]   - Field: ‘conditions’
[09:31:34.487]   - Field: ‘expr’
[09:31:34.487]   - Field: ‘uuid’
[09:31:34.487]   - Field: ‘seed’
[09:31:34.487]   - Field: ‘version’
[09:31:34.488]   - Field: ‘result’
[09:31:34.488]   - Field: ‘asynchronous’
[09:31:34.488]   - Field: ‘calls’
[09:31:34.488]   - Field: ‘globals’
[09:31:34.488]   - Field: ‘stdout’
[09:31:34.488]   - Field: ‘earlySignal’
[09:31:34.488]   - Field: ‘lazy’
[09:31:34.488]   - Field: ‘state’
[09:31:34.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.489] - Launch lazy future ...
[09:31:34.489] Packages needed by the future expression (n = 0): <none>
[09:31:34.489] Packages needed by future strategies (n = 0): <none>
[09:31:34.490] {
[09:31:34.490]     {
[09:31:34.490]         {
[09:31:34.490]             ...future.startTime <- base::Sys.time()
[09:31:34.490]             {
[09:31:34.490]                 {
[09:31:34.490]                   {
[09:31:34.490]                     {
[09:31:34.490]                       base::local({
[09:31:34.490]                         has_future <- base::requireNamespace("future", 
[09:31:34.490]                           quietly = TRUE)
[09:31:34.490]                         if (has_future) {
[09:31:34.490]                           ns <- base::getNamespace("future")
[09:31:34.490]                           version <- ns[[".package"]][["version"]]
[09:31:34.490]                           if (is.null(version)) 
[09:31:34.490]                             version <- utils::packageVersion("future")
[09:31:34.490]                         }
[09:31:34.490]                         else {
[09:31:34.490]                           version <- NULL
[09:31:34.490]                         }
[09:31:34.490]                         if (!has_future || version < "1.8.0") {
[09:31:34.490]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.490]                             "", base::R.version$version.string), 
[09:31:34.490]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.490]                               "release", "version")], collapse = " "), 
[09:31:34.490]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.490]                             info)
[09:31:34.490]                           info <- base::paste(info, collapse = "; ")
[09:31:34.490]                           if (!has_future) {
[09:31:34.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.490]                               info)
[09:31:34.490]                           }
[09:31:34.490]                           else {
[09:31:34.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.490]                               info, version)
[09:31:34.490]                           }
[09:31:34.490]                           base::stop(msg)
[09:31:34.490]                         }
[09:31:34.490]                       })
[09:31:34.490]                     }
[09:31:34.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.490]                     base::options(mc.cores = 1L)
[09:31:34.490]                   }
[09:31:34.490]                   ...future.strategy.old <- future::plan("list")
[09:31:34.490]                   options(future.plan = NULL)
[09:31:34.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.490]                 }
[09:31:34.490]                 ...future.workdir <- getwd()
[09:31:34.490]             }
[09:31:34.490]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.490]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.490]         }
[09:31:34.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.490]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.490]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.490]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.490]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.490]             base::names(...future.oldOptions))
[09:31:34.490]     }
[09:31:34.490]     if (FALSE) {
[09:31:34.490]     }
[09:31:34.490]     else {
[09:31:34.490]         if (TRUE) {
[09:31:34.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.490]                 open = "w")
[09:31:34.490]         }
[09:31:34.490]         else {
[09:31:34.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.490]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.490]         }
[09:31:34.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.490]             base::sink(type = "output", split = FALSE)
[09:31:34.490]             base::close(...future.stdout)
[09:31:34.490]         }, add = TRUE)
[09:31:34.490]     }
[09:31:34.490]     ...future.frame <- base::sys.nframe()
[09:31:34.490]     ...future.conditions <- base::list()
[09:31:34.490]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.490]     if (FALSE) {
[09:31:34.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.490]     }
[09:31:34.490]     ...future.result <- base::tryCatch({
[09:31:34.490]         base::withCallingHandlers({
[09:31:34.490]             ...future.value <- base::withVisible(base::local({
[09:31:34.490]                 withCallingHandlers({
[09:31:34.490]                   1
[09:31:34.490]                 }, immediateCondition = function(cond) {
[09:31:34.490]                   save_rds <- function (object, pathname, ...) 
[09:31:34.490]                   {
[09:31:34.490]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.490]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.490]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.490]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.490]                         fi_tmp[["mtime"]])
[09:31:34.490]                     }
[09:31:34.490]                     tryCatch({
[09:31:34.490]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.490]                     }, error = function(ex) {
[09:31:34.490]                       msg <- conditionMessage(ex)
[09:31:34.490]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.490]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.490]                         fi_tmp[["mtime"]], msg)
[09:31:34.490]                       ex$message <- msg
[09:31:34.490]                       stop(ex)
[09:31:34.490]                     })
[09:31:34.490]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.490]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.490]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.490]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.490]                       fi <- file.info(pathname)
[09:31:34.490]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.490]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.490]                         fi[["size"]], fi[["mtime"]])
[09:31:34.490]                       stop(msg)
[09:31:34.490]                     }
[09:31:34.490]                     invisible(pathname)
[09:31:34.490]                   }
[09:31:34.490]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.490]                     rootPath = tempdir()) 
[09:31:34.490]                   {
[09:31:34.490]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.490]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.490]                       tmpdir = path, fileext = ".rds")
[09:31:34.490]                     save_rds(obj, file)
[09:31:34.490]                   }
[09:31:34.490]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.490]                   {
[09:31:34.490]                     inherits <- base::inherits
[09:31:34.490]                     invokeRestart <- base::invokeRestart
[09:31:34.490]                     is.null <- base::is.null
[09:31:34.490]                     muffled <- FALSE
[09:31:34.490]                     if (inherits(cond, "message")) {
[09:31:34.490]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.490]                       if (muffled) 
[09:31:34.490]                         invokeRestart("muffleMessage")
[09:31:34.490]                     }
[09:31:34.490]                     else if (inherits(cond, "warning")) {
[09:31:34.490]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.490]                       if (muffled) 
[09:31:34.490]                         invokeRestart("muffleWarning")
[09:31:34.490]                     }
[09:31:34.490]                     else if (inherits(cond, "condition")) {
[09:31:34.490]                       if (!is.null(pattern)) {
[09:31:34.490]                         computeRestarts <- base::computeRestarts
[09:31:34.490]                         grepl <- base::grepl
[09:31:34.490]                         restarts <- computeRestarts(cond)
[09:31:34.490]                         for (restart in restarts) {
[09:31:34.490]                           name <- restart$name
[09:31:34.490]                           if (is.null(name)) 
[09:31:34.490]                             next
[09:31:34.490]                           if (!grepl(pattern, name)) 
[09:31:34.490]                             next
[09:31:34.490]                           invokeRestart(restart)
[09:31:34.490]                           muffled <- TRUE
[09:31:34.490]                           break
[09:31:34.490]                         }
[09:31:34.490]                       }
[09:31:34.490]                     }
[09:31:34.490]                     invisible(muffled)
[09:31:34.490]                   }
[09:31:34.490]                   muffleCondition(cond)
[09:31:34.490]                 })
[09:31:34.490]             }))
[09:31:34.490]             future::FutureResult(value = ...future.value$value, 
[09:31:34.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.490]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.490]                     ...future.globalenv.names))
[09:31:34.490]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.490]         }, condition = base::local({
[09:31:34.490]             c <- base::c
[09:31:34.490]             inherits <- base::inherits
[09:31:34.490]             invokeRestart <- base::invokeRestart
[09:31:34.490]             length <- base::length
[09:31:34.490]             list <- base::list
[09:31:34.490]             seq.int <- base::seq.int
[09:31:34.490]             signalCondition <- base::signalCondition
[09:31:34.490]             sys.calls <- base::sys.calls
[09:31:34.490]             `[[` <- base::`[[`
[09:31:34.490]             `+` <- base::`+`
[09:31:34.490]             `<<-` <- base::`<<-`
[09:31:34.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.490]                   3L)]
[09:31:34.490]             }
[09:31:34.490]             function(cond) {
[09:31:34.490]                 is_error <- inherits(cond, "error")
[09:31:34.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.490]                   NULL)
[09:31:34.490]                 if (is_error) {
[09:31:34.490]                   sessionInformation <- function() {
[09:31:34.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.490]                       search = base::search(), system = base::Sys.info())
[09:31:34.490]                   }
[09:31:34.490]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.490]                     cond$call), session = sessionInformation(), 
[09:31:34.490]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.490]                   signalCondition(cond)
[09:31:34.490]                 }
[09:31:34.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.490]                 "immediateCondition"))) {
[09:31:34.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.490]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.490]                   if (TRUE && !signal) {
[09:31:34.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.490]                     {
[09:31:34.490]                       inherits <- base::inherits
[09:31:34.490]                       invokeRestart <- base::invokeRestart
[09:31:34.490]                       is.null <- base::is.null
[09:31:34.490]                       muffled <- FALSE
[09:31:34.490]                       if (inherits(cond, "message")) {
[09:31:34.490]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.490]                         if (muffled) 
[09:31:34.490]                           invokeRestart("muffleMessage")
[09:31:34.490]                       }
[09:31:34.490]                       else if (inherits(cond, "warning")) {
[09:31:34.490]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.490]                         if (muffled) 
[09:31:34.490]                           invokeRestart("muffleWarning")
[09:31:34.490]                       }
[09:31:34.490]                       else if (inherits(cond, "condition")) {
[09:31:34.490]                         if (!is.null(pattern)) {
[09:31:34.490]                           computeRestarts <- base::computeRestarts
[09:31:34.490]                           grepl <- base::grepl
[09:31:34.490]                           restarts <- computeRestarts(cond)
[09:31:34.490]                           for (restart in restarts) {
[09:31:34.490]                             name <- restart$name
[09:31:34.490]                             if (is.null(name)) 
[09:31:34.490]                               next
[09:31:34.490]                             if (!grepl(pattern, name)) 
[09:31:34.490]                               next
[09:31:34.490]                             invokeRestart(restart)
[09:31:34.490]                             muffled <- TRUE
[09:31:34.490]                             break
[09:31:34.490]                           }
[09:31:34.490]                         }
[09:31:34.490]                       }
[09:31:34.490]                       invisible(muffled)
[09:31:34.490]                     }
[09:31:34.490]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.490]                   }
[09:31:34.490]                 }
[09:31:34.490]                 else {
[09:31:34.490]                   if (TRUE) {
[09:31:34.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.490]                     {
[09:31:34.490]                       inherits <- base::inherits
[09:31:34.490]                       invokeRestart <- base::invokeRestart
[09:31:34.490]                       is.null <- base::is.null
[09:31:34.490]                       muffled <- FALSE
[09:31:34.490]                       if (inherits(cond, "message")) {
[09:31:34.490]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.490]                         if (muffled) 
[09:31:34.490]                           invokeRestart("muffleMessage")
[09:31:34.490]                       }
[09:31:34.490]                       else if (inherits(cond, "warning")) {
[09:31:34.490]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.490]                         if (muffled) 
[09:31:34.490]                           invokeRestart("muffleWarning")
[09:31:34.490]                       }
[09:31:34.490]                       else if (inherits(cond, "condition")) {
[09:31:34.490]                         if (!is.null(pattern)) {
[09:31:34.490]                           computeRestarts <- base::computeRestarts
[09:31:34.490]                           grepl <- base::grepl
[09:31:34.490]                           restarts <- computeRestarts(cond)
[09:31:34.490]                           for (restart in restarts) {
[09:31:34.490]                             name <- restart$name
[09:31:34.490]                             if (is.null(name)) 
[09:31:34.490]                               next
[09:31:34.490]                             if (!grepl(pattern, name)) 
[09:31:34.490]                               next
[09:31:34.490]                             invokeRestart(restart)
[09:31:34.490]                             muffled <- TRUE
[09:31:34.490]                             break
[09:31:34.490]                           }
[09:31:34.490]                         }
[09:31:34.490]                       }
[09:31:34.490]                       invisible(muffled)
[09:31:34.490]                     }
[09:31:34.490]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.490]                   }
[09:31:34.490]                 }
[09:31:34.490]             }
[09:31:34.490]         }))
[09:31:34.490]     }, error = function(ex) {
[09:31:34.490]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.490]                 ...future.rng), started = ...future.startTime, 
[09:31:34.490]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.490]             version = "1.8"), class = "FutureResult")
[09:31:34.490]     }, finally = {
[09:31:34.490]         if (!identical(...future.workdir, getwd())) 
[09:31:34.490]             setwd(...future.workdir)
[09:31:34.490]         {
[09:31:34.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.490]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.490]             }
[09:31:34.490]             base::options(...future.oldOptions)
[09:31:34.490]             if (.Platform$OS.type == "windows") {
[09:31:34.490]                 old_names <- names(...future.oldEnvVars)
[09:31:34.490]                 envs <- base::Sys.getenv()
[09:31:34.490]                 names <- names(envs)
[09:31:34.490]                 common <- intersect(names, old_names)
[09:31:34.490]                 added <- setdiff(names, old_names)
[09:31:34.490]                 removed <- setdiff(old_names, names)
[09:31:34.490]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.490]                   envs[common]]
[09:31:34.490]                 NAMES <- toupper(changed)
[09:31:34.490]                 args <- list()
[09:31:34.490]                 for (kk in seq_along(NAMES)) {
[09:31:34.490]                   name <- changed[[kk]]
[09:31:34.490]                   NAME <- NAMES[[kk]]
[09:31:34.490]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.490]                     next
[09:31:34.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.490]                 }
[09:31:34.490]                 NAMES <- toupper(added)
[09:31:34.490]                 for (kk in seq_along(NAMES)) {
[09:31:34.490]                   name <- added[[kk]]
[09:31:34.490]                   NAME <- NAMES[[kk]]
[09:31:34.490]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.490]                     next
[09:31:34.490]                   args[[name]] <- ""
[09:31:34.490]                 }
[09:31:34.490]                 NAMES <- toupper(removed)
[09:31:34.490]                 for (kk in seq_along(NAMES)) {
[09:31:34.490]                   name <- removed[[kk]]
[09:31:34.490]                   NAME <- NAMES[[kk]]
[09:31:34.490]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.490]                     next
[09:31:34.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.490]                 }
[09:31:34.490]                 if (length(args) > 0) 
[09:31:34.490]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.490]             }
[09:31:34.490]             else {
[09:31:34.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.490]             }
[09:31:34.490]             {
[09:31:34.490]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.490]                   0L) {
[09:31:34.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.490]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.490]                   base::options(opts)
[09:31:34.490]                 }
[09:31:34.490]                 {
[09:31:34.490]                   {
[09:31:34.490]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.490]                     NULL
[09:31:34.490]                   }
[09:31:34.490]                   options(future.plan = NULL)
[09:31:34.490]                   if (is.na(NA_character_)) 
[09:31:34.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.490]                     .init = FALSE)
[09:31:34.490]                 }
[09:31:34.490]             }
[09:31:34.490]         }
[09:31:34.490]     })
[09:31:34.490]     if (TRUE) {
[09:31:34.490]         base::sink(type = "output", split = FALSE)
[09:31:34.490]         if (TRUE) {
[09:31:34.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.490]         }
[09:31:34.490]         else {
[09:31:34.490]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.490]         }
[09:31:34.490]         base::close(...future.stdout)
[09:31:34.490]         ...future.stdout <- NULL
[09:31:34.490]     }
[09:31:34.490]     ...future.result$conditions <- ...future.conditions
[09:31:34.490]     ...future.result$finished <- base::Sys.time()
[09:31:34.490]     ...future.result
[09:31:34.490] }
[09:31:34.494] requestCore(): workers = 2
[09:31:34.497] MulticoreFuture started
[09:31:34.497] - Launch lazy future ... done
[09:31:34.497] run() for ‘MulticoreFuture’ ... done
[09:31:34.498] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.498] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.498] List of future strategies:
[09:31:34.498] 1. sequential:
[09:31:34.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.498]    - tweaked: FALSE
[09:31:34.498]    - call: NULL
[09:31:34.499] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.499] plan(): nbrOfWorkers() = 1
[09:31:34.502] plan(): Setting new future strategy stack:
[09:31:34.502] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:34.502] Searching for globals ... DONE
[09:31:34.502] List of future strategies:
[09:31:34.502] 1. multicore:
[09:31:34.502]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.502]    - tweaked: FALSE
[09:31:34.502]    - call: plan(strategy)
[09:31:34.502] Resolving globals: TRUE
[09:31:34.503] Resolving any globals that are futures ...
[09:31:34.503] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:34.503] Resolving any globals that are futures ... DONE
[09:31:34.504] Resolving futures part of globals (recursively) ...
[09:31:34.505] resolve() on list ...
[09:31:34.505]  recursive: 99
[09:31:34.505]  length: 1
[09:31:34.506]  elements: ‘a’
[09:31:34.507] plan(): nbrOfWorkers() = 2
[09:31:34.508] Future #1
[09:31:34.508] result() for MulticoreFuture ...
[09:31:34.510] result() for MulticoreFuture ...
[09:31:34.510] result() for MulticoreFuture ... done
[09:31:34.510] result() for MulticoreFuture ... done
[09:31:34.510] result() for MulticoreFuture ...
[09:31:34.511] result() for MulticoreFuture ... done
[09:31:34.511] A MulticoreFuture was resolved
[09:31:34.511]  length: 0 (resolved future 1)
[09:31:34.512] resolve() on list ... DONE
[09:31:34.512] - globals: [1] ‘a’
[09:31:34.512] Resolving futures part of globals (recursively) ... DONE
[09:31:34.517] The total size of the 1 globals is 1.57 MiB (1647480 bytes)
[09:31:34.517] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:34.518] - globals: [1] ‘a’
[09:31:34.521] - packages: [1] ‘future’
[09:31:34.522] getGlobalsAndPackages() ... DONE
[09:31:34.522] run() for ‘Future’ ...
[09:31:34.523] - state: ‘created’
[09:31:34.523] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.528] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.529]   - Field: ‘label’
[09:31:34.529]   - Field: ‘local’
[09:31:34.529]   - Field: ‘owner’
[09:31:34.529]   - Field: ‘envir’
[09:31:34.529]   - Field: ‘workers’
[09:31:34.530]   - Field: ‘packages’
[09:31:34.530]   - Field: ‘gc’
[09:31:34.530]   - Field: ‘job’
[09:31:34.530]   - Field: ‘conditions’
[09:31:34.530]   - Field: ‘expr’
[09:31:34.531]   - Field: ‘uuid’
[09:31:34.531]   - Field: ‘seed’
[09:31:34.531]   - Field: ‘version’
[09:31:34.531]   - Field: ‘result’
[09:31:34.531]   - Field: ‘asynchronous’
[09:31:34.531]   - Field: ‘calls’
[09:31:34.531]   - Field: ‘globals’
[09:31:34.532]   - Field: ‘stdout’
[09:31:34.532]   - Field: ‘earlySignal’
[09:31:34.532]   - Field: ‘lazy’
[09:31:34.532]   - Field: ‘state’
[09:31:34.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.533] - Launch lazy future ...
[09:31:34.533] Packages needed by the future expression (n = 1): ‘future’
[09:31:34.533] Packages needed by future strategies (n = 0): <none>
[09:31:34.534] {
[09:31:34.534]     {
[09:31:34.534]         {
[09:31:34.534]             ...future.startTime <- base::Sys.time()
[09:31:34.534]             {
[09:31:34.534]                 {
[09:31:34.534]                   {
[09:31:34.534]                     {
[09:31:34.534]                       {
[09:31:34.534]                         base::local({
[09:31:34.534]                           has_future <- base::requireNamespace("future", 
[09:31:34.534]                             quietly = TRUE)
[09:31:34.534]                           if (has_future) {
[09:31:34.534]                             ns <- base::getNamespace("future")
[09:31:34.534]                             version <- ns[[".package"]][["version"]]
[09:31:34.534]                             if (is.null(version)) 
[09:31:34.534]                               version <- utils::packageVersion("future")
[09:31:34.534]                           }
[09:31:34.534]                           else {
[09:31:34.534]                             version <- NULL
[09:31:34.534]                           }
[09:31:34.534]                           if (!has_future || version < "1.8.0") {
[09:31:34.534]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.534]                               "", base::R.version$version.string), 
[09:31:34.534]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:34.534]                                 base::R.version$platform, 8 * 
[09:31:34.534]                                   base::.Machine$sizeof.pointer), 
[09:31:34.534]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.534]                                 "release", "version")], collapse = " "), 
[09:31:34.534]                               hostname = base::Sys.info()[["nodename"]])
[09:31:34.534]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.534]                               info)
[09:31:34.534]                             info <- base::paste(info, collapse = "; ")
[09:31:34.534]                             if (!has_future) {
[09:31:34.534]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.534]                                 info)
[09:31:34.534]                             }
[09:31:34.534]                             else {
[09:31:34.534]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.534]                                 info, version)
[09:31:34.534]                             }
[09:31:34.534]                             base::stop(msg)
[09:31:34.534]                           }
[09:31:34.534]                         })
[09:31:34.534]                       }
[09:31:34.534]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.534]                       base::options(mc.cores = 1L)
[09:31:34.534]                     }
[09:31:34.534]                     base::local({
[09:31:34.534]                       for (pkg in "future") {
[09:31:34.534]                         base::loadNamespace(pkg)
[09:31:34.534]                         base::library(pkg, character.only = TRUE)
[09:31:34.534]                       }
[09:31:34.534]                     })
[09:31:34.534]                   }
[09:31:34.534]                   ...future.strategy.old <- future::plan("list")
[09:31:34.534]                   options(future.plan = NULL)
[09:31:34.534]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.534]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.534]                 }
[09:31:34.534]                 ...future.workdir <- getwd()
[09:31:34.534]             }
[09:31:34.534]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.534]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.534]         }
[09:31:34.534]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.534]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.534]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.534]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.534]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.534]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.534]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.534]             base::names(...future.oldOptions))
[09:31:34.534]     }
[09:31:34.534]     if (FALSE) {
[09:31:34.534]     }
[09:31:34.534]     else {
[09:31:34.534]         if (TRUE) {
[09:31:34.534]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.534]                 open = "w")
[09:31:34.534]         }
[09:31:34.534]         else {
[09:31:34.534]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.534]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.534]         }
[09:31:34.534]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.534]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.534]             base::sink(type = "output", split = FALSE)
[09:31:34.534]             base::close(...future.stdout)
[09:31:34.534]         }, add = TRUE)
[09:31:34.534]     }
[09:31:34.534]     ...future.frame <- base::sys.nframe()
[09:31:34.534]     ...future.conditions <- base::list()
[09:31:34.534]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.534]     if (FALSE) {
[09:31:34.534]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.534]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.534]     }
[09:31:34.534]     ...future.result <- base::tryCatch({
[09:31:34.534]         base::withCallingHandlers({
[09:31:34.534]             ...future.value <- base::withVisible(base::local({
[09:31:34.534]                 withCallingHandlers({
[09:31:34.534]                   value(a) + 1
[09:31:34.534]                 }, immediateCondition = function(cond) {
[09:31:34.534]                   save_rds <- function (object, pathname, ...) 
[09:31:34.534]                   {
[09:31:34.534]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.534]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.534]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.534]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.534]                         fi_tmp[["mtime"]])
[09:31:34.534]                     }
[09:31:34.534]                     tryCatch({
[09:31:34.534]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.534]                     }, error = function(ex) {
[09:31:34.534]                       msg <- conditionMessage(ex)
[09:31:34.534]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.534]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.534]                         fi_tmp[["mtime"]], msg)
[09:31:34.534]                       ex$message <- msg
[09:31:34.534]                       stop(ex)
[09:31:34.534]                     })
[09:31:34.534]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.534]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.534]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.534]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.534]                       fi <- file.info(pathname)
[09:31:34.534]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.534]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.534]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.534]                         fi[["size"]], fi[["mtime"]])
[09:31:34.534]                       stop(msg)
[09:31:34.534]                     }
[09:31:34.534]                     invisible(pathname)
[09:31:34.534]                   }
[09:31:34.534]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.534]                     rootPath = tempdir()) 
[09:31:34.534]                   {
[09:31:34.534]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.534]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.534]                       tmpdir = path, fileext = ".rds")
[09:31:34.534]                     save_rds(obj, file)
[09:31:34.534]                   }
[09:31:34.534]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.534]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.534]                   {
[09:31:34.534]                     inherits <- base::inherits
[09:31:34.534]                     invokeRestart <- base::invokeRestart
[09:31:34.534]                     is.null <- base::is.null
[09:31:34.534]                     muffled <- FALSE
[09:31:34.534]                     if (inherits(cond, "message")) {
[09:31:34.534]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.534]                       if (muffled) 
[09:31:34.534]                         invokeRestart("muffleMessage")
[09:31:34.534]                     }
[09:31:34.534]                     else if (inherits(cond, "warning")) {
[09:31:34.534]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.534]                       if (muffled) 
[09:31:34.534]                         invokeRestart("muffleWarning")
[09:31:34.534]                     }
[09:31:34.534]                     else if (inherits(cond, "condition")) {
[09:31:34.534]                       if (!is.null(pattern)) {
[09:31:34.534]                         computeRestarts <- base::computeRestarts
[09:31:34.534]                         grepl <- base::grepl
[09:31:34.534]                         restarts <- computeRestarts(cond)
[09:31:34.534]                         for (restart in restarts) {
[09:31:34.534]                           name <- restart$name
[09:31:34.534]                           if (is.null(name)) 
[09:31:34.534]                             next
[09:31:34.534]                           if (!grepl(pattern, name)) 
[09:31:34.534]                             next
[09:31:34.534]                           invokeRestart(restart)
[09:31:34.534]                           muffled <- TRUE
[09:31:34.534]                           break
[09:31:34.534]                         }
[09:31:34.534]                       }
[09:31:34.534]                     }
[09:31:34.534]                     invisible(muffled)
[09:31:34.534]                   }
[09:31:34.534]                   muffleCondition(cond)
[09:31:34.534]                 })
[09:31:34.534]             }))
[09:31:34.534]             future::FutureResult(value = ...future.value$value, 
[09:31:34.534]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.534]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.534]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.534]                     ...future.globalenv.names))
[09:31:34.534]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.534]         }, condition = base::local({
[09:31:34.534]             c <- base::c
[09:31:34.534]             inherits <- base::inherits
[09:31:34.534]             invokeRestart <- base::invokeRestart
[09:31:34.534]             length <- base::length
[09:31:34.534]             list <- base::list
[09:31:34.534]             seq.int <- base::seq.int
[09:31:34.534]             signalCondition <- base::signalCondition
[09:31:34.534]             sys.calls <- base::sys.calls
[09:31:34.534]             `[[` <- base::`[[`
[09:31:34.534]             `+` <- base::`+`
[09:31:34.534]             `<<-` <- base::`<<-`
[09:31:34.534]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.534]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.534]                   3L)]
[09:31:34.534]             }
[09:31:34.534]             function(cond) {
[09:31:34.534]                 is_error <- inherits(cond, "error")
[09:31:34.534]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.534]                   NULL)
[09:31:34.534]                 if (is_error) {
[09:31:34.534]                   sessionInformation <- function() {
[09:31:34.534]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.534]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.534]                       search = base::search(), system = base::Sys.info())
[09:31:34.534]                   }
[09:31:34.534]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.534]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.534]                     cond$call), session = sessionInformation(), 
[09:31:34.534]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.534]                   signalCondition(cond)
[09:31:34.534]                 }
[09:31:34.534]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.534]                 "immediateCondition"))) {
[09:31:34.534]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.534]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.534]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.534]                   if (TRUE && !signal) {
[09:31:34.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.534]                     {
[09:31:34.534]                       inherits <- base::inherits
[09:31:34.534]                       invokeRestart <- base::invokeRestart
[09:31:34.534]                       is.null <- base::is.null
[09:31:34.534]                       muffled <- FALSE
[09:31:34.534]                       if (inherits(cond, "message")) {
[09:31:34.534]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.534]                         if (muffled) 
[09:31:34.534]                           invokeRestart("muffleMessage")
[09:31:34.534]                       }
[09:31:34.534]                       else if (inherits(cond, "warning")) {
[09:31:34.534]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.534]                         if (muffled) 
[09:31:34.534]                           invokeRestart("muffleWarning")
[09:31:34.534]                       }
[09:31:34.534]                       else if (inherits(cond, "condition")) {
[09:31:34.534]                         if (!is.null(pattern)) {
[09:31:34.534]                           computeRestarts <- base::computeRestarts
[09:31:34.534]                           grepl <- base::grepl
[09:31:34.534]                           restarts <- computeRestarts(cond)
[09:31:34.534]                           for (restart in restarts) {
[09:31:34.534]                             name <- restart$name
[09:31:34.534]                             if (is.null(name)) 
[09:31:34.534]                               next
[09:31:34.534]                             if (!grepl(pattern, name)) 
[09:31:34.534]                               next
[09:31:34.534]                             invokeRestart(restart)
[09:31:34.534]                             muffled <- TRUE
[09:31:34.534]                             break
[09:31:34.534]                           }
[09:31:34.534]                         }
[09:31:34.534]                       }
[09:31:34.534]                       invisible(muffled)
[09:31:34.534]                     }
[09:31:34.534]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.534]                   }
[09:31:34.534]                 }
[09:31:34.534]                 else {
[09:31:34.534]                   if (TRUE) {
[09:31:34.534]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.534]                     {
[09:31:34.534]                       inherits <- base::inherits
[09:31:34.534]                       invokeRestart <- base::invokeRestart
[09:31:34.534]                       is.null <- base::is.null
[09:31:34.534]                       muffled <- FALSE
[09:31:34.534]                       if (inherits(cond, "message")) {
[09:31:34.534]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.534]                         if (muffled) 
[09:31:34.534]                           invokeRestart("muffleMessage")
[09:31:34.534]                       }
[09:31:34.534]                       else if (inherits(cond, "warning")) {
[09:31:34.534]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.534]                         if (muffled) 
[09:31:34.534]                           invokeRestart("muffleWarning")
[09:31:34.534]                       }
[09:31:34.534]                       else if (inherits(cond, "condition")) {
[09:31:34.534]                         if (!is.null(pattern)) {
[09:31:34.534]                           computeRestarts <- base::computeRestarts
[09:31:34.534]                           grepl <- base::grepl
[09:31:34.534]                           restarts <- computeRestarts(cond)
[09:31:34.534]                           for (restart in restarts) {
[09:31:34.534]                             name <- restart$name
[09:31:34.534]                             if (is.null(name)) 
[09:31:34.534]                               next
[09:31:34.534]                             if (!grepl(pattern, name)) 
[09:31:34.534]                               next
[09:31:34.534]                             invokeRestart(restart)
[09:31:34.534]                             muffled <- TRUE
[09:31:34.534]                             break
[09:31:34.534]                           }
[09:31:34.534]                         }
[09:31:34.534]                       }
[09:31:34.534]                       invisible(muffled)
[09:31:34.534]                     }
[09:31:34.534]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.534]                   }
[09:31:34.534]                 }
[09:31:34.534]             }
[09:31:34.534]         }))
[09:31:34.534]     }, error = function(ex) {
[09:31:34.534]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.534]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.534]                 ...future.rng), started = ...future.startTime, 
[09:31:34.534]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.534]             version = "1.8"), class = "FutureResult")
[09:31:34.534]     }, finally = {
[09:31:34.534]         if (!identical(...future.workdir, getwd())) 
[09:31:34.534]             setwd(...future.workdir)
[09:31:34.534]         {
[09:31:34.534]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.534]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.534]             }
[09:31:34.534]             base::options(...future.oldOptions)
[09:31:34.534]             if (.Platform$OS.type == "windows") {
[09:31:34.534]                 old_names <- names(...future.oldEnvVars)
[09:31:34.534]                 envs <- base::Sys.getenv()
[09:31:34.534]                 names <- names(envs)
[09:31:34.534]                 common <- intersect(names, old_names)
[09:31:34.534]                 added <- setdiff(names, old_names)
[09:31:34.534]                 removed <- setdiff(old_names, names)
[09:31:34.534]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.534]                   envs[common]]
[09:31:34.534]                 NAMES <- toupper(changed)
[09:31:34.534]                 args <- list()
[09:31:34.534]                 for (kk in seq_along(NAMES)) {
[09:31:34.534]                   name <- changed[[kk]]
[09:31:34.534]                   NAME <- NAMES[[kk]]
[09:31:34.534]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.534]                     next
[09:31:34.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.534]                 }
[09:31:34.534]                 NAMES <- toupper(added)
[09:31:34.534]                 for (kk in seq_along(NAMES)) {
[09:31:34.534]                   name <- added[[kk]]
[09:31:34.534]                   NAME <- NAMES[[kk]]
[09:31:34.534]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.534]                     next
[09:31:34.534]                   args[[name]] <- ""
[09:31:34.534]                 }
[09:31:34.534]                 NAMES <- toupper(removed)
[09:31:34.534]                 for (kk in seq_along(NAMES)) {
[09:31:34.534]                   name <- removed[[kk]]
[09:31:34.534]                   NAME <- NAMES[[kk]]
[09:31:34.534]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.534]                     next
[09:31:34.534]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.534]                 }
[09:31:34.534]                 if (length(args) > 0) 
[09:31:34.534]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.534]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.534]             }
[09:31:34.534]             else {
[09:31:34.534]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.534]             }
[09:31:34.534]             {
[09:31:34.534]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.534]                   0L) {
[09:31:34.534]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.534]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.534]                   base::options(opts)
[09:31:34.534]                 }
[09:31:34.534]                 {
[09:31:34.534]                   {
[09:31:34.534]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.534]                     NULL
[09:31:34.534]                   }
[09:31:34.534]                   options(future.plan = NULL)
[09:31:34.534]                   if (is.na(NA_character_)) 
[09:31:34.534]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.534]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.534]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.534]                     .init = FALSE)
[09:31:34.534]                 }
[09:31:34.534]             }
[09:31:34.534]         }
[09:31:34.534]     })
[09:31:34.534]     if (TRUE) {
[09:31:34.534]         base::sink(type = "output", split = FALSE)
[09:31:34.534]         if (TRUE) {
[09:31:34.534]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.534]         }
[09:31:34.534]         else {
[09:31:34.534]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.534]         }
[09:31:34.534]         base::close(...future.stdout)
[09:31:34.534]         ...future.stdout <- NULL
[09:31:34.534]     }
[09:31:34.534]     ...future.result$conditions <- ...future.conditions
[09:31:34.534]     ...future.result$finished <- base::Sys.time()
[09:31:34.534]     ...future.result
[09:31:34.534] }
[09:31:34.537] assign_globals() ...
[09:31:34.537] List of 1
[09:31:34.537]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e21822bb20> 
[09:31:34.537]  - attr(*, "where")=List of 1
[09:31:34.537]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.537]  - attr(*, "resolved")= logi TRUE
[09:31:34.537]  - attr(*, "total_size")= num 1647480
[09:31:34.537]  - attr(*, "already-done")= logi TRUE
[09:31:34.541] - copied ‘a’ to environment
[09:31:34.541] assign_globals() ... done
[09:31:34.541] requestCore(): workers = 2
[09:31:34.543] MulticoreFuture started
[09:31:34.543] - Launch lazy future ... done
[09:31:34.544] run() for ‘MulticoreFuture’ ... done
[09:31:34.544] result() for MulticoreFuture ...
[09:31:34.545] plan(): Setting new future strategy stack:
[09:31:34.545] List of future strategies:
[09:31:34.545] 1. sequential:
[09:31:34.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.545]    - tweaked: FALSE
[09:31:34.545]    - call: NULL
[09:31:34.546] plan(): nbrOfWorkers() = 1
[09:31:34.550] plan(): Setting new future strategy stack:
[09:31:34.550] List of future strategies:
[09:31:34.550] 1. multicore:
[09:31:34.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.550]    - tweaked: FALSE
[09:31:34.550]    - call: plan(strategy)
[09:31:34.555] plan(): nbrOfWorkers() = 2
[09:31:34.556] result() for MulticoreFuture ...
[09:31:34.556] result() for MulticoreFuture ... done
[09:31:34.556] signalConditions() ...
[09:31:34.556]  - include = ‘immediateCondition’
[09:31:34.556]  - exclude = 
[09:31:34.556]  - resignal = FALSE
[09:31:34.557]  - Number of conditions: 4
[09:31:34.557] signalConditions() ... done
[09:31:34.557] result() for MulticoreFuture ... done
[09:31:34.557] result() for MulticoreFuture ...
[09:31:34.557] result() for MulticoreFuture ... done
[09:31:34.558] signalConditions() ...
[09:31:34.558]  - include = ‘immediateCondition’
[09:31:34.558]  - exclude = 
[09:31:34.558]  - resignal = FALSE
[09:31:34.558]  - Number of conditions: 4
[09:31:34.558] signalConditions() ... done
[09:31:34.558] Future state: ‘finished’
[09:31:34.559] result() for MulticoreFuture ...
[09:31:34.559] result() for MulticoreFuture ... done
[09:31:34.559] signalConditions() ...
[09:31:34.559]  - include = ‘condition’
[09:31:34.559]  - exclude = ‘immediateCondition’
[09:31:34.559]  - resignal = TRUE
[09:31:34.559]  - Number of conditions: 4
[09:31:34.560]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.547] result() for MulticoreFuture ...
[09:31:34.560]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ... done
[09:31:34.560]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ...
[09:31:34.560]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ... done
[09:31:34.560] signalConditions() ... done
value(b) = 2
[09:31:34.561] result() for MulticoreFuture ...
[09:31:34.561] result() for MulticoreFuture ... done
[09:31:34.561] result() for MulticoreFuture ...
[09:31:34.561] result() for MulticoreFuture ... done
[09:31:34.561] signalConditions() ...
[09:31:34.561]  - include = ‘immediateCondition’
[09:31:34.562]  - exclude = 
[09:31:34.562]  - resignal = FALSE
[09:31:34.562]  - Number of conditions: 4
[09:31:34.562] signalConditions() ... done
[09:31:34.562] Future state: ‘finished’
[09:31:34.562] result() for MulticoreFuture ...
[09:31:34.562] result() for MulticoreFuture ... done
[09:31:34.563] signalConditions() ...
[09:31:34.563]  - include = ‘condition’
[09:31:34.563]  - exclude = ‘immediateCondition’
[09:31:34.563]  - resignal = TRUE
[09:31:34.563]  - Number of conditions: 4
[09:31:34.563]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.547] result() for MulticoreFuture ...
[09:31:34.563]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ... done
[09:31:34.564]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ...
[09:31:34.564]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.548] result() for MulticoreFuture ... done
[09:31:34.564] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.564] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.564] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.565] 
[09:31:34.565] Searching for globals ... DONE
[09:31:34.565] - globals: [0] <none>
[09:31:34.565] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.566] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.566] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.567] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:34.567] Searching for globals ... DONE
[09:31:34.567] Resolving globals: TRUE
[09:31:34.567] Resolving any globals that are futures ...
[09:31:34.568] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:34.568] Resolving any globals that are futures ... DONE
[09:31:34.568] Resolving futures part of globals (recursively) ...
[09:31:34.568] resolve() on list ...
[09:31:34.569]  recursive: 99
[09:31:34.569]  length: 1
[09:31:34.569]  elements: ‘a’
[09:31:34.569] run() for ‘Future’ ...
[09:31:34.569] - state: ‘created’
[09:31:34.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.573] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.573]   - Field: ‘label’
[09:31:34.574]   - Field: ‘local’
[09:31:34.574]   - Field: ‘owner’
[09:31:34.574]   - Field: ‘envir’
[09:31:34.574]   - Field: ‘workers’
[09:31:34.574]   - Field: ‘packages’
[09:31:34.574]   - Field: ‘gc’
[09:31:34.574]   - Field: ‘job’
[09:31:34.575]   - Field: ‘conditions’
[09:31:34.575]   - Field: ‘expr’
[09:31:34.575]   - Field: ‘uuid’
[09:31:34.575]   - Field: ‘seed’
[09:31:34.575]   - Field: ‘version’
[09:31:34.575]   - Field: ‘result’
[09:31:34.575]   - Field: ‘asynchronous’
[09:31:34.576]   - Field: ‘calls’
[09:31:34.576]   - Field: ‘globals’
[09:31:34.576]   - Field: ‘stdout’
[09:31:34.576]   - Field: ‘earlySignal’
[09:31:34.576]   - Field: ‘lazy’
[09:31:34.576]   - Field: ‘state’
[09:31:34.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.577] - Launch lazy future ...
[09:31:34.577] Packages needed by the future expression (n = 0): <none>
[09:31:34.577] Packages needed by future strategies (n = 0): <none>
[09:31:34.580] {
[09:31:34.580]     {
[09:31:34.580]         {
[09:31:34.580]             ...future.startTime <- base::Sys.time()
[09:31:34.580]             {
[09:31:34.580]                 {
[09:31:34.580]                   {
[09:31:34.580]                     {
[09:31:34.580]                       base::local({
[09:31:34.580]                         has_future <- base::requireNamespace("future", 
[09:31:34.580]                           quietly = TRUE)
[09:31:34.580]                         if (has_future) {
[09:31:34.580]                           ns <- base::getNamespace("future")
[09:31:34.580]                           version <- ns[[".package"]][["version"]]
[09:31:34.580]                           if (is.null(version)) 
[09:31:34.580]                             version <- utils::packageVersion("future")
[09:31:34.580]                         }
[09:31:34.580]                         else {
[09:31:34.580]                           version <- NULL
[09:31:34.580]                         }
[09:31:34.580]                         if (!has_future || version < "1.8.0") {
[09:31:34.580]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.580]                             "", base::R.version$version.string), 
[09:31:34.580]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.580]                               "release", "version")], collapse = " "), 
[09:31:34.580]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.580]                             info)
[09:31:34.580]                           info <- base::paste(info, collapse = "; ")
[09:31:34.580]                           if (!has_future) {
[09:31:34.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.580]                               info)
[09:31:34.580]                           }
[09:31:34.580]                           else {
[09:31:34.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.580]                               info, version)
[09:31:34.580]                           }
[09:31:34.580]                           base::stop(msg)
[09:31:34.580]                         }
[09:31:34.580]                       })
[09:31:34.580]                     }
[09:31:34.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.580]                     base::options(mc.cores = 1L)
[09:31:34.580]                   }
[09:31:34.580]                   ...future.strategy.old <- future::plan("list")
[09:31:34.580]                   options(future.plan = NULL)
[09:31:34.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.580]                 }
[09:31:34.580]                 ...future.workdir <- getwd()
[09:31:34.580]             }
[09:31:34.580]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.580]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.580]         }
[09:31:34.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.580]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.580]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.580]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.580]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.580]             base::names(...future.oldOptions))
[09:31:34.580]     }
[09:31:34.580]     if (FALSE) {
[09:31:34.580]     }
[09:31:34.580]     else {
[09:31:34.580]         if (TRUE) {
[09:31:34.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.580]                 open = "w")
[09:31:34.580]         }
[09:31:34.580]         else {
[09:31:34.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.580]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.580]         }
[09:31:34.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.580]             base::sink(type = "output", split = FALSE)
[09:31:34.580]             base::close(...future.stdout)
[09:31:34.580]         }, add = TRUE)
[09:31:34.580]     }
[09:31:34.580]     ...future.frame <- base::sys.nframe()
[09:31:34.580]     ...future.conditions <- base::list()
[09:31:34.580]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.580]     if (FALSE) {
[09:31:34.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.580]     }
[09:31:34.580]     ...future.result <- base::tryCatch({
[09:31:34.580]         base::withCallingHandlers({
[09:31:34.580]             ...future.value <- base::withVisible(base::local({
[09:31:34.580]                 withCallingHandlers({
[09:31:34.580]                   1
[09:31:34.580]                 }, immediateCondition = function(cond) {
[09:31:34.580]                   save_rds <- function (object, pathname, ...) 
[09:31:34.580]                   {
[09:31:34.580]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.580]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.580]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.580]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.580]                         fi_tmp[["mtime"]])
[09:31:34.580]                     }
[09:31:34.580]                     tryCatch({
[09:31:34.580]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.580]                     }, error = function(ex) {
[09:31:34.580]                       msg <- conditionMessage(ex)
[09:31:34.580]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.580]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.580]                         fi_tmp[["mtime"]], msg)
[09:31:34.580]                       ex$message <- msg
[09:31:34.580]                       stop(ex)
[09:31:34.580]                     })
[09:31:34.580]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.580]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.580]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.580]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.580]                       fi <- file.info(pathname)
[09:31:34.580]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.580]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.580]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.580]                         fi[["size"]], fi[["mtime"]])
[09:31:34.580]                       stop(msg)
[09:31:34.580]                     }
[09:31:34.580]                     invisible(pathname)
[09:31:34.580]                   }
[09:31:34.580]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.580]                     rootPath = tempdir()) 
[09:31:34.580]                   {
[09:31:34.580]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.580]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.580]                       tmpdir = path, fileext = ".rds")
[09:31:34.580]                     save_rds(obj, file)
[09:31:34.580]                   }
[09:31:34.580]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.580]                   {
[09:31:34.580]                     inherits <- base::inherits
[09:31:34.580]                     invokeRestart <- base::invokeRestart
[09:31:34.580]                     is.null <- base::is.null
[09:31:34.580]                     muffled <- FALSE
[09:31:34.580]                     if (inherits(cond, "message")) {
[09:31:34.580]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.580]                       if (muffled) 
[09:31:34.580]                         invokeRestart("muffleMessage")
[09:31:34.580]                     }
[09:31:34.580]                     else if (inherits(cond, "warning")) {
[09:31:34.580]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.580]                       if (muffled) 
[09:31:34.580]                         invokeRestart("muffleWarning")
[09:31:34.580]                     }
[09:31:34.580]                     else if (inherits(cond, "condition")) {
[09:31:34.580]                       if (!is.null(pattern)) {
[09:31:34.580]                         computeRestarts <- base::computeRestarts
[09:31:34.580]                         grepl <- base::grepl
[09:31:34.580]                         restarts <- computeRestarts(cond)
[09:31:34.580]                         for (restart in restarts) {
[09:31:34.580]                           name <- restart$name
[09:31:34.580]                           if (is.null(name)) 
[09:31:34.580]                             next
[09:31:34.580]                           if (!grepl(pattern, name)) 
[09:31:34.580]                             next
[09:31:34.580]                           invokeRestart(restart)
[09:31:34.580]                           muffled <- TRUE
[09:31:34.580]                           break
[09:31:34.580]                         }
[09:31:34.580]                       }
[09:31:34.580]                     }
[09:31:34.580]                     invisible(muffled)
[09:31:34.580]                   }
[09:31:34.580]                   muffleCondition(cond)
[09:31:34.580]                 })
[09:31:34.580]             }))
[09:31:34.580]             future::FutureResult(value = ...future.value$value, 
[09:31:34.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.580]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.580]                     ...future.globalenv.names))
[09:31:34.580]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.580]         }, condition = base::local({
[09:31:34.580]             c <- base::c
[09:31:34.580]             inherits <- base::inherits
[09:31:34.580]             invokeRestart <- base::invokeRestart
[09:31:34.580]             length <- base::length
[09:31:34.580]             list <- base::list
[09:31:34.580]             seq.int <- base::seq.int
[09:31:34.580]             signalCondition <- base::signalCondition
[09:31:34.580]             sys.calls <- base::sys.calls
[09:31:34.580]             `[[` <- base::`[[`
[09:31:34.580]             `+` <- base::`+`
[09:31:34.580]             `<<-` <- base::`<<-`
[09:31:34.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.580]                   3L)]
[09:31:34.580]             }
[09:31:34.580]             function(cond) {
[09:31:34.580]                 is_error <- inherits(cond, "error")
[09:31:34.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.580]                   NULL)
[09:31:34.580]                 if (is_error) {
[09:31:34.580]                   sessionInformation <- function() {
[09:31:34.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.580]                       search = base::search(), system = base::Sys.info())
[09:31:34.580]                   }
[09:31:34.580]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.580]                     cond$call), session = sessionInformation(), 
[09:31:34.580]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.580]                   signalCondition(cond)
[09:31:34.580]                 }
[09:31:34.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.580]                 "immediateCondition"))) {
[09:31:34.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.580]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.580]                   if (TRUE && !signal) {
[09:31:34.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.580]                     {
[09:31:34.580]                       inherits <- base::inherits
[09:31:34.580]                       invokeRestart <- base::invokeRestart
[09:31:34.580]                       is.null <- base::is.null
[09:31:34.580]                       muffled <- FALSE
[09:31:34.580]                       if (inherits(cond, "message")) {
[09:31:34.580]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.580]                         if (muffled) 
[09:31:34.580]                           invokeRestart("muffleMessage")
[09:31:34.580]                       }
[09:31:34.580]                       else if (inherits(cond, "warning")) {
[09:31:34.580]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.580]                         if (muffled) 
[09:31:34.580]                           invokeRestart("muffleWarning")
[09:31:34.580]                       }
[09:31:34.580]                       else if (inherits(cond, "condition")) {
[09:31:34.580]                         if (!is.null(pattern)) {
[09:31:34.580]                           computeRestarts <- base::computeRestarts
[09:31:34.580]                           grepl <- base::grepl
[09:31:34.580]                           restarts <- computeRestarts(cond)
[09:31:34.580]                           for (restart in restarts) {
[09:31:34.580]                             name <- restart$name
[09:31:34.580]                             if (is.null(name)) 
[09:31:34.580]                               next
[09:31:34.580]                             if (!grepl(pattern, name)) 
[09:31:34.580]                               next
[09:31:34.580]                             invokeRestart(restart)
[09:31:34.580]                             muffled <- TRUE
[09:31:34.580]                             break
[09:31:34.580]                           }
[09:31:34.580]                         }
[09:31:34.580]                       }
[09:31:34.580]                       invisible(muffled)
[09:31:34.580]                     }
[09:31:34.580]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.580]                   }
[09:31:34.580]                 }
[09:31:34.580]                 else {
[09:31:34.580]                   if (TRUE) {
[09:31:34.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.580]                     {
[09:31:34.580]                       inherits <- base::inherits
[09:31:34.580]                       invokeRestart <- base::invokeRestart
[09:31:34.580]                       is.null <- base::is.null
[09:31:34.580]                       muffled <- FALSE
[09:31:34.580]                       if (inherits(cond, "message")) {
[09:31:34.580]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.580]                         if (muffled) 
[09:31:34.580]                           invokeRestart("muffleMessage")
[09:31:34.580]                       }
[09:31:34.580]                       else if (inherits(cond, "warning")) {
[09:31:34.580]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.580]                         if (muffled) 
[09:31:34.580]                           invokeRestart("muffleWarning")
[09:31:34.580]                       }
[09:31:34.580]                       else if (inherits(cond, "condition")) {
[09:31:34.580]                         if (!is.null(pattern)) {
[09:31:34.580]                           computeRestarts <- base::computeRestarts
[09:31:34.580]                           grepl <- base::grepl
[09:31:34.580]                           restarts <- computeRestarts(cond)
[09:31:34.580]                           for (restart in restarts) {
[09:31:34.580]                             name <- restart$name
[09:31:34.580]                             if (is.null(name)) 
[09:31:34.580]                               next
[09:31:34.580]                             if (!grepl(pattern, name)) 
[09:31:34.580]                               next
[09:31:34.580]                             invokeRestart(restart)
[09:31:34.580]                             muffled <- TRUE
[09:31:34.580]                             break
[09:31:34.580]                           }
[09:31:34.580]                         }
[09:31:34.580]                       }
[09:31:34.580]                       invisible(muffled)
[09:31:34.580]                     }
[09:31:34.580]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.580]                   }
[09:31:34.580]                 }
[09:31:34.580]             }
[09:31:34.580]         }))
[09:31:34.580]     }, error = function(ex) {
[09:31:34.580]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.580]                 ...future.rng), started = ...future.startTime, 
[09:31:34.580]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.580]             version = "1.8"), class = "FutureResult")
[09:31:34.580]     }, finally = {
[09:31:34.580]         if (!identical(...future.workdir, getwd())) 
[09:31:34.580]             setwd(...future.workdir)
[09:31:34.580]         {
[09:31:34.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.580]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.580]             }
[09:31:34.580]             base::options(...future.oldOptions)
[09:31:34.580]             if (.Platform$OS.type == "windows") {
[09:31:34.580]                 old_names <- names(...future.oldEnvVars)
[09:31:34.580]                 envs <- base::Sys.getenv()
[09:31:34.580]                 names <- names(envs)
[09:31:34.580]                 common <- intersect(names, old_names)
[09:31:34.580]                 added <- setdiff(names, old_names)
[09:31:34.580]                 removed <- setdiff(old_names, names)
[09:31:34.580]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.580]                   envs[common]]
[09:31:34.580]                 NAMES <- toupper(changed)
[09:31:34.580]                 args <- list()
[09:31:34.580]                 for (kk in seq_along(NAMES)) {
[09:31:34.580]                   name <- changed[[kk]]
[09:31:34.580]                   NAME <- NAMES[[kk]]
[09:31:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.580]                     next
[09:31:34.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.580]                 }
[09:31:34.580]                 NAMES <- toupper(added)
[09:31:34.580]                 for (kk in seq_along(NAMES)) {
[09:31:34.580]                   name <- added[[kk]]
[09:31:34.580]                   NAME <- NAMES[[kk]]
[09:31:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.580]                     next
[09:31:34.580]                   args[[name]] <- ""
[09:31:34.580]                 }
[09:31:34.580]                 NAMES <- toupper(removed)
[09:31:34.580]                 for (kk in seq_along(NAMES)) {
[09:31:34.580]                   name <- removed[[kk]]
[09:31:34.580]                   NAME <- NAMES[[kk]]
[09:31:34.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.580]                     next
[09:31:34.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.580]                 }
[09:31:34.580]                 if (length(args) > 0) 
[09:31:34.580]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.580]             }
[09:31:34.580]             else {
[09:31:34.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.580]             }
[09:31:34.580]             {
[09:31:34.580]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.580]                   0L) {
[09:31:34.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.580]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.580]                   base::options(opts)
[09:31:34.580]                 }
[09:31:34.580]                 {
[09:31:34.580]                   {
[09:31:34.580]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.580]                     NULL
[09:31:34.580]                   }
[09:31:34.580]                   options(future.plan = NULL)
[09:31:34.580]                   if (is.na(NA_character_)) 
[09:31:34.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.580]                     .init = FALSE)
[09:31:34.580]                 }
[09:31:34.580]             }
[09:31:34.580]         }
[09:31:34.580]     })
[09:31:34.580]     if (TRUE) {
[09:31:34.580]         base::sink(type = "output", split = FALSE)
[09:31:34.580]         if (TRUE) {
[09:31:34.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.580]         }
[09:31:34.580]         else {
[09:31:34.580]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.580]         }
[09:31:34.580]         base::close(...future.stdout)
[09:31:34.580]         ...future.stdout <- NULL
[09:31:34.580]     }
[09:31:34.580]     ...future.result$conditions <- ...future.conditions
[09:31:34.580]     ...future.result$finished <- base::Sys.time()
[09:31:34.580]     ...future.result
[09:31:34.580] }
[09:31:34.583] requestCore(): workers = 2
[09:31:34.585] MulticoreFuture started
[09:31:34.585] - Launch lazy future ... done
[09:31:34.585] run() for ‘MulticoreFuture’ ... done
[09:31:34.586] plan(): Setting new future strategy stack:
[09:31:34.586] List of future strategies:
[09:31:34.586] 1. sequential:
[09:31:34.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.586]    - tweaked: FALSE
[09:31:34.586]    - call: NULL
[09:31:34.587] plan(): nbrOfWorkers() = 1
[09:31:34.589] plan(): Setting new future strategy stack:
[09:31:34.589] List of future strategies:
[09:31:34.589] 1. multicore:
[09:31:34.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.589]    - tweaked: FALSE
[09:31:34.589]    - call: plan(strategy)
[09:31:34.595] plan(): nbrOfWorkers() = 2
[09:31:34.596] Future #1
[09:31:34.596] result() for MulticoreFuture ...
[09:31:34.597] result() for MulticoreFuture ...
[09:31:34.597] result() for MulticoreFuture ... done
[09:31:34.597] result() for MulticoreFuture ... done
[09:31:34.597] result() for MulticoreFuture ...
[09:31:34.597] result() for MulticoreFuture ... done
[09:31:34.598] A MulticoreFuture was resolved
[09:31:34.598]  length: 0 (resolved future 1)
[09:31:34.598] resolve() on list ... DONE
[09:31:34.598] - globals: [1] ‘a’
[09:31:34.598] Resolving futures part of globals (recursively) ... DONE
[09:31:34.602] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[09:31:34.603] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:34.603] - globals: [1] ‘a’
[09:31:34.603] - packages: [1] ‘future’
[09:31:34.603] getGlobalsAndPackages() ... DONE
[09:31:34.604] run() for ‘Future’ ...
[09:31:34.604] - state: ‘created’
[09:31:34.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.608] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.609]   - Field: ‘label’
[09:31:34.609]   - Field: ‘local’
[09:31:34.609]   - Field: ‘owner’
[09:31:34.609]   - Field: ‘envir’
[09:31:34.609]   - Field: ‘workers’
[09:31:34.609]   - Field: ‘packages’
[09:31:34.609]   - Field: ‘gc’
[09:31:34.609]   - Field: ‘job’
[09:31:34.609]   - Field: ‘conditions’
[09:31:34.610]   - Field: ‘expr’
[09:31:34.610]   - Field: ‘uuid’
[09:31:34.610]   - Field: ‘seed’
[09:31:34.610]   - Field: ‘version’
[09:31:34.610]   - Field: ‘result’
[09:31:34.610]   - Field: ‘asynchronous’
[09:31:34.610]   - Field: ‘calls’
[09:31:34.610]   - Field: ‘globals’
[09:31:34.610]   - Field: ‘stdout’
[09:31:34.611]   - Field: ‘earlySignal’
[09:31:34.611]   - Field: ‘lazy’
[09:31:34.611]   - Field: ‘state’
[09:31:34.611] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.611] - Launch lazy future ...
[09:31:34.611] Packages needed by the future expression (n = 1): ‘future’
[09:31:34.611] Packages needed by future strategies (n = 0): <none>
[09:31:34.612] {
[09:31:34.612]     {
[09:31:34.612]         {
[09:31:34.612]             ...future.startTime <- base::Sys.time()
[09:31:34.612]             {
[09:31:34.612]                 {
[09:31:34.612]                   {
[09:31:34.612]                     {
[09:31:34.612]                       {
[09:31:34.612]                         base::local({
[09:31:34.612]                           has_future <- base::requireNamespace("future", 
[09:31:34.612]                             quietly = TRUE)
[09:31:34.612]                           if (has_future) {
[09:31:34.612]                             ns <- base::getNamespace("future")
[09:31:34.612]                             version <- ns[[".package"]][["version"]]
[09:31:34.612]                             if (is.null(version)) 
[09:31:34.612]                               version <- utils::packageVersion("future")
[09:31:34.612]                           }
[09:31:34.612]                           else {
[09:31:34.612]                             version <- NULL
[09:31:34.612]                           }
[09:31:34.612]                           if (!has_future || version < "1.8.0") {
[09:31:34.612]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.612]                               "", base::R.version$version.string), 
[09:31:34.612]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:34.612]                                 base::R.version$platform, 8 * 
[09:31:34.612]                                   base::.Machine$sizeof.pointer), 
[09:31:34.612]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.612]                                 "release", "version")], collapse = " "), 
[09:31:34.612]                               hostname = base::Sys.info()[["nodename"]])
[09:31:34.612]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.612]                               info)
[09:31:34.612]                             info <- base::paste(info, collapse = "; ")
[09:31:34.612]                             if (!has_future) {
[09:31:34.612]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.612]                                 info)
[09:31:34.612]                             }
[09:31:34.612]                             else {
[09:31:34.612]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.612]                                 info, version)
[09:31:34.612]                             }
[09:31:34.612]                             base::stop(msg)
[09:31:34.612]                           }
[09:31:34.612]                         })
[09:31:34.612]                       }
[09:31:34.612]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.612]                       base::options(mc.cores = 1L)
[09:31:34.612]                     }
[09:31:34.612]                     base::local({
[09:31:34.612]                       for (pkg in "future") {
[09:31:34.612]                         base::loadNamespace(pkg)
[09:31:34.612]                         base::library(pkg, character.only = TRUE)
[09:31:34.612]                       }
[09:31:34.612]                     })
[09:31:34.612]                   }
[09:31:34.612]                   ...future.strategy.old <- future::plan("list")
[09:31:34.612]                   options(future.plan = NULL)
[09:31:34.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.612]                 }
[09:31:34.612]                 ...future.workdir <- getwd()
[09:31:34.612]             }
[09:31:34.612]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.612]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.612]         }
[09:31:34.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.612]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.612]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.612]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.612]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.612]             base::names(...future.oldOptions))
[09:31:34.612]     }
[09:31:34.612]     if (FALSE) {
[09:31:34.612]     }
[09:31:34.612]     else {
[09:31:34.612]         if (TRUE) {
[09:31:34.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.612]                 open = "w")
[09:31:34.612]         }
[09:31:34.612]         else {
[09:31:34.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.612]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.612]         }
[09:31:34.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.612]             base::sink(type = "output", split = FALSE)
[09:31:34.612]             base::close(...future.stdout)
[09:31:34.612]         }, add = TRUE)
[09:31:34.612]     }
[09:31:34.612]     ...future.frame <- base::sys.nframe()
[09:31:34.612]     ...future.conditions <- base::list()
[09:31:34.612]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.612]     if (FALSE) {
[09:31:34.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.612]     }
[09:31:34.612]     ...future.result <- base::tryCatch({
[09:31:34.612]         base::withCallingHandlers({
[09:31:34.612]             ...future.value <- base::withVisible(base::local({
[09:31:34.612]                 withCallingHandlers({
[09:31:34.612]                   value(a) + 1
[09:31:34.612]                 }, immediateCondition = function(cond) {
[09:31:34.612]                   save_rds <- function (object, pathname, ...) 
[09:31:34.612]                   {
[09:31:34.612]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.612]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.612]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.612]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.612]                         fi_tmp[["mtime"]])
[09:31:34.612]                     }
[09:31:34.612]                     tryCatch({
[09:31:34.612]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.612]                     }, error = function(ex) {
[09:31:34.612]                       msg <- conditionMessage(ex)
[09:31:34.612]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.612]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.612]                         fi_tmp[["mtime"]], msg)
[09:31:34.612]                       ex$message <- msg
[09:31:34.612]                       stop(ex)
[09:31:34.612]                     })
[09:31:34.612]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.612]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.612]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.612]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.612]                       fi <- file.info(pathname)
[09:31:34.612]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.612]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.612]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.612]                         fi[["size"]], fi[["mtime"]])
[09:31:34.612]                       stop(msg)
[09:31:34.612]                     }
[09:31:34.612]                     invisible(pathname)
[09:31:34.612]                   }
[09:31:34.612]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.612]                     rootPath = tempdir()) 
[09:31:34.612]                   {
[09:31:34.612]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.612]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.612]                       tmpdir = path, fileext = ".rds")
[09:31:34.612]                     save_rds(obj, file)
[09:31:34.612]                   }
[09:31:34.612]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.612]                   {
[09:31:34.612]                     inherits <- base::inherits
[09:31:34.612]                     invokeRestart <- base::invokeRestart
[09:31:34.612]                     is.null <- base::is.null
[09:31:34.612]                     muffled <- FALSE
[09:31:34.612]                     if (inherits(cond, "message")) {
[09:31:34.612]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.612]                       if (muffled) 
[09:31:34.612]                         invokeRestart("muffleMessage")
[09:31:34.612]                     }
[09:31:34.612]                     else if (inherits(cond, "warning")) {
[09:31:34.612]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.612]                       if (muffled) 
[09:31:34.612]                         invokeRestart("muffleWarning")
[09:31:34.612]                     }
[09:31:34.612]                     else if (inherits(cond, "condition")) {
[09:31:34.612]                       if (!is.null(pattern)) {
[09:31:34.612]                         computeRestarts <- base::computeRestarts
[09:31:34.612]                         grepl <- base::grepl
[09:31:34.612]                         restarts <- computeRestarts(cond)
[09:31:34.612]                         for (restart in restarts) {
[09:31:34.612]                           name <- restart$name
[09:31:34.612]                           if (is.null(name)) 
[09:31:34.612]                             next
[09:31:34.612]                           if (!grepl(pattern, name)) 
[09:31:34.612]                             next
[09:31:34.612]                           invokeRestart(restart)
[09:31:34.612]                           muffled <- TRUE
[09:31:34.612]                           break
[09:31:34.612]                         }
[09:31:34.612]                       }
[09:31:34.612]                     }
[09:31:34.612]                     invisible(muffled)
[09:31:34.612]                   }
[09:31:34.612]                   muffleCondition(cond)
[09:31:34.612]                 })
[09:31:34.612]             }))
[09:31:34.612]             future::FutureResult(value = ...future.value$value, 
[09:31:34.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.612]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.612]                     ...future.globalenv.names))
[09:31:34.612]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.612]         }, condition = base::local({
[09:31:34.612]             c <- base::c
[09:31:34.612]             inherits <- base::inherits
[09:31:34.612]             invokeRestart <- base::invokeRestart
[09:31:34.612]             length <- base::length
[09:31:34.612]             list <- base::list
[09:31:34.612]             seq.int <- base::seq.int
[09:31:34.612]             signalCondition <- base::signalCondition
[09:31:34.612]             sys.calls <- base::sys.calls
[09:31:34.612]             `[[` <- base::`[[`
[09:31:34.612]             `+` <- base::`+`
[09:31:34.612]             `<<-` <- base::`<<-`
[09:31:34.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.612]                   3L)]
[09:31:34.612]             }
[09:31:34.612]             function(cond) {
[09:31:34.612]                 is_error <- inherits(cond, "error")
[09:31:34.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.612]                   NULL)
[09:31:34.612]                 if (is_error) {
[09:31:34.612]                   sessionInformation <- function() {
[09:31:34.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.612]                       search = base::search(), system = base::Sys.info())
[09:31:34.612]                   }
[09:31:34.612]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.612]                     cond$call), session = sessionInformation(), 
[09:31:34.612]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.612]                   signalCondition(cond)
[09:31:34.612]                 }
[09:31:34.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.612]                 "immediateCondition"))) {
[09:31:34.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.612]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.612]                   if (TRUE && !signal) {
[09:31:34.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.612]                     {
[09:31:34.612]                       inherits <- base::inherits
[09:31:34.612]                       invokeRestart <- base::invokeRestart
[09:31:34.612]                       is.null <- base::is.null
[09:31:34.612]                       muffled <- FALSE
[09:31:34.612]                       if (inherits(cond, "message")) {
[09:31:34.612]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.612]                         if (muffled) 
[09:31:34.612]                           invokeRestart("muffleMessage")
[09:31:34.612]                       }
[09:31:34.612]                       else if (inherits(cond, "warning")) {
[09:31:34.612]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.612]                         if (muffled) 
[09:31:34.612]                           invokeRestart("muffleWarning")
[09:31:34.612]                       }
[09:31:34.612]                       else if (inherits(cond, "condition")) {
[09:31:34.612]                         if (!is.null(pattern)) {
[09:31:34.612]                           computeRestarts <- base::computeRestarts
[09:31:34.612]                           grepl <- base::grepl
[09:31:34.612]                           restarts <- computeRestarts(cond)
[09:31:34.612]                           for (restart in restarts) {
[09:31:34.612]                             name <- restart$name
[09:31:34.612]                             if (is.null(name)) 
[09:31:34.612]                               next
[09:31:34.612]                             if (!grepl(pattern, name)) 
[09:31:34.612]                               next
[09:31:34.612]                             invokeRestart(restart)
[09:31:34.612]                             muffled <- TRUE
[09:31:34.612]                             break
[09:31:34.612]                           }
[09:31:34.612]                         }
[09:31:34.612]                       }
[09:31:34.612]                       invisible(muffled)
[09:31:34.612]                     }
[09:31:34.612]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.612]                   }
[09:31:34.612]                 }
[09:31:34.612]                 else {
[09:31:34.612]                   if (TRUE) {
[09:31:34.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.612]                     {
[09:31:34.612]                       inherits <- base::inherits
[09:31:34.612]                       invokeRestart <- base::invokeRestart
[09:31:34.612]                       is.null <- base::is.null
[09:31:34.612]                       muffled <- FALSE
[09:31:34.612]                       if (inherits(cond, "message")) {
[09:31:34.612]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.612]                         if (muffled) 
[09:31:34.612]                           invokeRestart("muffleMessage")
[09:31:34.612]                       }
[09:31:34.612]                       else if (inherits(cond, "warning")) {
[09:31:34.612]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.612]                         if (muffled) 
[09:31:34.612]                           invokeRestart("muffleWarning")
[09:31:34.612]                       }
[09:31:34.612]                       else if (inherits(cond, "condition")) {
[09:31:34.612]                         if (!is.null(pattern)) {
[09:31:34.612]                           computeRestarts <- base::computeRestarts
[09:31:34.612]                           grepl <- base::grepl
[09:31:34.612]                           restarts <- computeRestarts(cond)
[09:31:34.612]                           for (restart in restarts) {
[09:31:34.612]                             name <- restart$name
[09:31:34.612]                             if (is.null(name)) 
[09:31:34.612]                               next
[09:31:34.612]                             if (!grepl(pattern, name)) 
[09:31:34.612]                               next
[09:31:34.612]                             invokeRestart(restart)
[09:31:34.612]                             muffled <- TRUE
[09:31:34.612]                             break
[09:31:34.612]                           }
[09:31:34.612]                         }
[09:31:34.612]                       }
[09:31:34.612]                       invisible(muffled)
[09:31:34.612]                     }
[09:31:34.612]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.612]                   }
[09:31:34.612]                 }
[09:31:34.612]             }
[09:31:34.612]         }))
[09:31:34.612]     }, error = function(ex) {
[09:31:34.612]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.612]                 ...future.rng), started = ...future.startTime, 
[09:31:34.612]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.612]             version = "1.8"), class = "FutureResult")
[09:31:34.612]     }, finally = {
[09:31:34.612]         if (!identical(...future.workdir, getwd())) 
[09:31:34.612]             setwd(...future.workdir)
[09:31:34.612]         {
[09:31:34.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.612]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.612]             }
[09:31:34.612]             base::options(...future.oldOptions)
[09:31:34.612]             if (.Platform$OS.type == "windows") {
[09:31:34.612]                 old_names <- names(...future.oldEnvVars)
[09:31:34.612]                 envs <- base::Sys.getenv()
[09:31:34.612]                 names <- names(envs)
[09:31:34.612]                 common <- intersect(names, old_names)
[09:31:34.612]                 added <- setdiff(names, old_names)
[09:31:34.612]                 removed <- setdiff(old_names, names)
[09:31:34.612]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.612]                   envs[common]]
[09:31:34.612]                 NAMES <- toupper(changed)
[09:31:34.612]                 args <- list()
[09:31:34.612]                 for (kk in seq_along(NAMES)) {
[09:31:34.612]                   name <- changed[[kk]]
[09:31:34.612]                   NAME <- NAMES[[kk]]
[09:31:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.612]                     next
[09:31:34.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.612]                 }
[09:31:34.612]                 NAMES <- toupper(added)
[09:31:34.612]                 for (kk in seq_along(NAMES)) {
[09:31:34.612]                   name <- added[[kk]]
[09:31:34.612]                   NAME <- NAMES[[kk]]
[09:31:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.612]                     next
[09:31:34.612]                   args[[name]] <- ""
[09:31:34.612]                 }
[09:31:34.612]                 NAMES <- toupper(removed)
[09:31:34.612]                 for (kk in seq_along(NAMES)) {
[09:31:34.612]                   name <- removed[[kk]]
[09:31:34.612]                   NAME <- NAMES[[kk]]
[09:31:34.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.612]                     next
[09:31:34.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.612]                 }
[09:31:34.612]                 if (length(args) > 0) 
[09:31:34.612]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.612]             }
[09:31:34.612]             else {
[09:31:34.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.612]             }
[09:31:34.612]             {
[09:31:34.612]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.612]                   0L) {
[09:31:34.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.612]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.612]                   base::options(opts)
[09:31:34.612]                 }
[09:31:34.612]                 {
[09:31:34.612]                   {
[09:31:34.612]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.612]                     NULL
[09:31:34.612]                   }
[09:31:34.612]                   options(future.plan = NULL)
[09:31:34.612]                   if (is.na(NA_character_)) 
[09:31:34.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.612]                     .init = FALSE)
[09:31:34.612]                 }
[09:31:34.612]             }
[09:31:34.612]         }
[09:31:34.612]     })
[09:31:34.612]     if (TRUE) {
[09:31:34.612]         base::sink(type = "output", split = FALSE)
[09:31:34.612]         if (TRUE) {
[09:31:34.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.612]         }
[09:31:34.612]         else {
[09:31:34.612]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.612]         }
[09:31:34.612]         base::close(...future.stdout)
[09:31:34.612]         ...future.stdout <- NULL
[09:31:34.612]     }
[09:31:34.612]     ...future.result$conditions <- ...future.conditions
[09:31:34.612]     ...future.result$finished <- base::Sys.time()
[09:31:34.612]     ...future.result
[09:31:34.612] }
[09:31:34.615] assign_globals() ...
[09:31:34.615] List of 1
[09:31:34.615]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e21a0a1a40> 
[09:31:34.615]  - attr(*, "where")=List of 1
[09:31:34.615]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.615]  - attr(*, "resolved")= logi TRUE
[09:31:34.615]  - attr(*, "total_size")= num 1647648
[09:31:34.615]  - attr(*, "already-done")= logi TRUE
[09:31:34.618] - copied ‘a’ to environment
[09:31:34.618] assign_globals() ... done
[09:31:34.618] requestCore(): workers = 2
[09:31:34.620] MulticoreFuture started
[09:31:34.620] - Launch lazy future ... done
[09:31:34.621] run() for ‘MulticoreFuture’ ... done
[09:31:34.621] result() for MulticoreFuture ...
[09:31:34.621] plan(): Setting new future strategy stack:
[09:31:34.622] List of future strategies:
[09:31:34.622] 1. sequential:
[09:31:34.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.622]    - tweaked: FALSE
[09:31:34.622]    - call: NULL
[09:31:34.623] plan(): nbrOfWorkers() = 1
[09:31:34.626] plan(): Setting new future strategy stack:
[09:31:34.626] List of future strategies:
[09:31:34.626] 1. multicore:
[09:31:34.626]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.626]    - tweaked: FALSE
[09:31:34.626]    - call: plan(strategy)
[09:31:34.631] plan(): nbrOfWorkers() = 2
[09:31:34.632] result() for MulticoreFuture ...
[09:31:34.632] result() for MulticoreFuture ... done
[09:31:34.632] signalConditions() ...
[09:31:34.633]  - include = ‘immediateCondition’
[09:31:34.633]  - exclude = 
[09:31:34.633]  - resignal = FALSE
[09:31:34.633]  - Number of conditions: 4
[09:31:34.633] signalConditions() ... done
[09:31:34.633] result() for MulticoreFuture ... done
[09:31:34.633] result() for MulticoreFuture ...
[09:31:34.633] result() for MulticoreFuture ... done
[09:31:34.634] signalConditions() ...
[09:31:34.634]  - include = ‘immediateCondition’
[09:31:34.634]  - exclude = 
[09:31:34.634]  - resignal = FALSE
[09:31:34.634]  - Number of conditions: 4
[09:31:34.634] signalConditions() ... done
[09:31:34.634] Future state: ‘finished’
[09:31:34.634] result() for MulticoreFuture ...
[09:31:34.635] result() for MulticoreFuture ... done
[09:31:34.635] signalConditions() ...
[09:31:34.635]  - include = ‘condition’
[09:31:34.635]  - exclude = ‘immediateCondition’
[09:31:34.635]  - resignal = TRUE
[09:31:34.635]  - Number of conditions: 4
[09:31:34.635]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.624] result() for MulticoreFuture ...
[09:31:34.635]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.624] result() for MulticoreFuture ... done
[09:31:34.635]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.625] result() for MulticoreFuture ...
[09:31:34.636]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.625] result() for MulticoreFuture ... done
[09:31:34.636] signalConditions() ... done
value(b) = 2
[09:31:34.636] result() for MulticoreFuture ...
[09:31:34.636] result() for MulticoreFuture ... done
[09:31:34.636] result() for MulticoreFuture ...
[09:31:34.636] result() for MulticoreFuture ... done
[09:31:34.637] signalConditions() ...
[09:31:34.637]  - include = ‘immediateCondition’
[09:31:34.637]  - exclude = 
[09:31:34.637]  - resignal = FALSE
[09:31:34.637]  - Number of conditions: 4
[09:31:34.637] signalConditions() ... done
[09:31:34.637] Future state: ‘finished’
[09:31:34.637] result() for MulticoreFuture ...
[09:31:34.637] result() for MulticoreFuture ... done
[09:31:34.638] signalConditions() ...
[09:31:34.638]  - include = ‘condition’
[09:31:34.638]  - exclude = ‘immediateCondition’
[09:31:34.638]  - resignal = TRUE
[09:31:34.638]  - Number of conditions: 4
[09:31:34.638]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.624] result() for MulticoreFuture ...
[09:31:34.638]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.624] result() for MulticoreFuture ... done
[09:31:34.638]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.625] result() for MulticoreFuture ...
[09:31:34.639]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.625] result() for MulticoreFuture ... done
[09:31:34.639] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.639] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.639] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.640] 
[09:31:34.640] Searching for globals ... DONE
[09:31:34.640] - globals: [0] <none>
[09:31:34.640] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.641] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.641] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.642] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:34.642] Searching for globals ... DONE
[09:31:34.642] Resolving globals: TRUE
[09:31:34.645] Resolving any globals that are futures ...
[09:31:34.645] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:34.645] Resolving any globals that are futures ... DONE
[09:31:34.646] Resolving futures part of globals (recursively) ...
[09:31:34.646] resolve() on list ...
[09:31:34.646]  recursive: 99
[09:31:34.646]  length: 1
[09:31:34.647]  elements: ‘a’
[09:31:34.647] run() for ‘Future’ ...
[09:31:34.647] - state: ‘created’
[09:31:34.647] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.651]   - Field: ‘label’
[09:31:34.651]   - Field: ‘local’
[09:31:34.651]   - Field: ‘owner’
[09:31:34.652]   - Field: ‘envir’
[09:31:34.652]   - Field: ‘workers’
[09:31:34.652]   - Field: ‘packages’
[09:31:34.652]   - Field: ‘gc’
[09:31:34.652]   - Field: ‘job’
[09:31:34.652]   - Field: ‘conditions’
[09:31:34.652]   - Field: ‘expr’
[09:31:34.652]   - Field: ‘uuid’
[09:31:34.653]   - Field: ‘seed’
[09:31:34.653]   - Field: ‘version’
[09:31:34.653]   - Field: ‘result’
[09:31:34.653]   - Field: ‘asynchronous’
[09:31:34.653]   - Field: ‘calls’
[09:31:34.653]   - Field: ‘globals’
[09:31:34.653]   - Field: ‘stdout’
[09:31:34.653]   - Field: ‘earlySignal’
[09:31:34.654]   - Field: ‘lazy’
[09:31:34.654]   - Field: ‘state’
[09:31:34.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.654] - Launch lazy future ...
[09:31:34.654] Packages needed by the future expression (n = 0): <none>
[09:31:34.654] Packages needed by future strategies (n = 0): <none>
[09:31:34.655] {
[09:31:34.655]     {
[09:31:34.655]         {
[09:31:34.655]             ...future.startTime <- base::Sys.time()
[09:31:34.655]             {
[09:31:34.655]                 {
[09:31:34.655]                   {
[09:31:34.655]                     {
[09:31:34.655]                       base::local({
[09:31:34.655]                         has_future <- base::requireNamespace("future", 
[09:31:34.655]                           quietly = TRUE)
[09:31:34.655]                         if (has_future) {
[09:31:34.655]                           ns <- base::getNamespace("future")
[09:31:34.655]                           version <- ns[[".package"]][["version"]]
[09:31:34.655]                           if (is.null(version)) 
[09:31:34.655]                             version <- utils::packageVersion("future")
[09:31:34.655]                         }
[09:31:34.655]                         else {
[09:31:34.655]                           version <- NULL
[09:31:34.655]                         }
[09:31:34.655]                         if (!has_future || version < "1.8.0") {
[09:31:34.655]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.655]                             "", base::R.version$version.string), 
[09:31:34.655]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.655]                               "release", "version")], collapse = " "), 
[09:31:34.655]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.655]                             info)
[09:31:34.655]                           info <- base::paste(info, collapse = "; ")
[09:31:34.655]                           if (!has_future) {
[09:31:34.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.655]                               info)
[09:31:34.655]                           }
[09:31:34.655]                           else {
[09:31:34.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.655]                               info, version)
[09:31:34.655]                           }
[09:31:34.655]                           base::stop(msg)
[09:31:34.655]                         }
[09:31:34.655]                       })
[09:31:34.655]                     }
[09:31:34.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.655]                     base::options(mc.cores = 1L)
[09:31:34.655]                   }
[09:31:34.655]                   ...future.strategy.old <- future::plan("list")
[09:31:34.655]                   options(future.plan = NULL)
[09:31:34.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.655]                 }
[09:31:34.655]                 ...future.workdir <- getwd()
[09:31:34.655]             }
[09:31:34.655]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.655]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.655]         }
[09:31:34.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.655]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.655]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.655]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.655]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.655]             base::names(...future.oldOptions))
[09:31:34.655]     }
[09:31:34.655]     if (FALSE) {
[09:31:34.655]     }
[09:31:34.655]     else {
[09:31:34.655]         if (TRUE) {
[09:31:34.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.655]                 open = "w")
[09:31:34.655]         }
[09:31:34.655]         else {
[09:31:34.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.655]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.655]         }
[09:31:34.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.655]             base::sink(type = "output", split = FALSE)
[09:31:34.655]             base::close(...future.stdout)
[09:31:34.655]         }, add = TRUE)
[09:31:34.655]     }
[09:31:34.655]     ...future.frame <- base::sys.nframe()
[09:31:34.655]     ...future.conditions <- base::list()
[09:31:34.655]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.655]     if (FALSE) {
[09:31:34.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.655]     }
[09:31:34.655]     ...future.result <- base::tryCatch({
[09:31:34.655]         base::withCallingHandlers({
[09:31:34.655]             ...future.value <- base::withVisible(base::local({
[09:31:34.655]                 withCallingHandlers({
[09:31:34.655]                   1
[09:31:34.655]                 }, immediateCondition = function(cond) {
[09:31:34.655]                   save_rds <- function (object, pathname, ...) 
[09:31:34.655]                   {
[09:31:34.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.655]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.655]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.655]                         fi_tmp[["mtime"]])
[09:31:34.655]                     }
[09:31:34.655]                     tryCatch({
[09:31:34.655]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.655]                     }, error = function(ex) {
[09:31:34.655]                       msg <- conditionMessage(ex)
[09:31:34.655]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.655]                         fi_tmp[["mtime"]], msg)
[09:31:34.655]                       ex$message <- msg
[09:31:34.655]                       stop(ex)
[09:31:34.655]                     })
[09:31:34.655]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.655]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.655]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.655]                       fi <- file.info(pathname)
[09:31:34.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.655]                         fi[["size"]], fi[["mtime"]])
[09:31:34.655]                       stop(msg)
[09:31:34.655]                     }
[09:31:34.655]                     invisible(pathname)
[09:31:34.655]                   }
[09:31:34.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.655]                     rootPath = tempdir()) 
[09:31:34.655]                   {
[09:31:34.655]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.655]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.655]                       tmpdir = path, fileext = ".rds")
[09:31:34.655]                     save_rds(obj, file)
[09:31:34.655]                   }
[09:31:34.655]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.655]                   {
[09:31:34.655]                     inherits <- base::inherits
[09:31:34.655]                     invokeRestart <- base::invokeRestart
[09:31:34.655]                     is.null <- base::is.null
[09:31:34.655]                     muffled <- FALSE
[09:31:34.655]                     if (inherits(cond, "message")) {
[09:31:34.655]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.655]                       if (muffled) 
[09:31:34.655]                         invokeRestart("muffleMessage")
[09:31:34.655]                     }
[09:31:34.655]                     else if (inherits(cond, "warning")) {
[09:31:34.655]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.655]                       if (muffled) 
[09:31:34.655]                         invokeRestart("muffleWarning")
[09:31:34.655]                     }
[09:31:34.655]                     else if (inherits(cond, "condition")) {
[09:31:34.655]                       if (!is.null(pattern)) {
[09:31:34.655]                         computeRestarts <- base::computeRestarts
[09:31:34.655]                         grepl <- base::grepl
[09:31:34.655]                         restarts <- computeRestarts(cond)
[09:31:34.655]                         for (restart in restarts) {
[09:31:34.655]                           name <- restart$name
[09:31:34.655]                           if (is.null(name)) 
[09:31:34.655]                             next
[09:31:34.655]                           if (!grepl(pattern, name)) 
[09:31:34.655]                             next
[09:31:34.655]                           invokeRestart(restart)
[09:31:34.655]                           muffled <- TRUE
[09:31:34.655]                           break
[09:31:34.655]                         }
[09:31:34.655]                       }
[09:31:34.655]                     }
[09:31:34.655]                     invisible(muffled)
[09:31:34.655]                   }
[09:31:34.655]                   muffleCondition(cond)
[09:31:34.655]                 })
[09:31:34.655]             }))
[09:31:34.655]             future::FutureResult(value = ...future.value$value, 
[09:31:34.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.655]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.655]                     ...future.globalenv.names))
[09:31:34.655]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.655]         }, condition = base::local({
[09:31:34.655]             c <- base::c
[09:31:34.655]             inherits <- base::inherits
[09:31:34.655]             invokeRestart <- base::invokeRestart
[09:31:34.655]             length <- base::length
[09:31:34.655]             list <- base::list
[09:31:34.655]             seq.int <- base::seq.int
[09:31:34.655]             signalCondition <- base::signalCondition
[09:31:34.655]             sys.calls <- base::sys.calls
[09:31:34.655]             `[[` <- base::`[[`
[09:31:34.655]             `+` <- base::`+`
[09:31:34.655]             `<<-` <- base::`<<-`
[09:31:34.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.655]                   3L)]
[09:31:34.655]             }
[09:31:34.655]             function(cond) {
[09:31:34.655]                 is_error <- inherits(cond, "error")
[09:31:34.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.655]                   NULL)
[09:31:34.655]                 if (is_error) {
[09:31:34.655]                   sessionInformation <- function() {
[09:31:34.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.655]                       search = base::search(), system = base::Sys.info())
[09:31:34.655]                   }
[09:31:34.655]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.655]                     cond$call), session = sessionInformation(), 
[09:31:34.655]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.655]                   signalCondition(cond)
[09:31:34.655]                 }
[09:31:34.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.655]                 "immediateCondition"))) {
[09:31:34.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.655]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.655]                   if (TRUE && !signal) {
[09:31:34.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.655]                     {
[09:31:34.655]                       inherits <- base::inherits
[09:31:34.655]                       invokeRestart <- base::invokeRestart
[09:31:34.655]                       is.null <- base::is.null
[09:31:34.655]                       muffled <- FALSE
[09:31:34.655]                       if (inherits(cond, "message")) {
[09:31:34.655]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.655]                         if (muffled) 
[09:31:34.655]                           invokeRestart("muffleMessage")
[09:31:34.655]                       }
[09:31:34.655]                       else if (inherits(cond, "warning")) {
[09:31:34.655]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.655]                         if (muffled) 
[09:31:34.655]                           invokeRestart("muffleWarning")
[09:31:34.655]                       }
[09:31:34.655]                       else if (inherits(cond, "condition")) {
[09:31:34.655]                         if (!is.null(pattern)) {
[09:31:34.655]                           computeRestarts <- base::computeRestarts
[09:31:34.655]                           grepl <- base::grepl
[09:31:34.655]                           restarts <- computeRestarts(cond)
[09:31:34.655]                           for (restart in restarts) {
[09:31:34.655]                             name <- restart$name
[09:31:34.655]                             if (is.null(name)) 
[09:31:34.655]                               next
[09:31:34.655]                             if (!grepl(pattern, name)) 
[09:31:34.655]                               next
[09:31:34.655]                             invokeRestart(restart)
[09:31:34.655]                             muffled <- TRUE
[09:31:34.655]                             break
[09:31:34.655]                           }
[09:31:34.655]                         }
[09:31:34.655]                       }
[09:31:34.655]                       invisible(muffled)
[09:31:34.655]                     }
[09:31:34.655]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.655]                   }
[09:31:34.655]                 }
[09:31:34.655]                 else {
[09:31:34.655]                   if (TRUE) {
[09:31:34.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.655]                     {
[09:31:34.655]                       inherits <- base::inherits
[09:31:34.655]                       invokeRestart <- base::invokeRestart
[09:31:34.655]                       is.null <- base::is.null
[09:31:34.655]                       muffled <- FALSE
[09:31:34.655]                       if (inherits(cond, "message")) {
[09:31:34.655]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.655]                         if (muffled) 
[09:31:34.655]                           invokeRestart("muffleMessage")
[09:31:34.655]                       }
[09:31:34.655]                       else if (inherits(cond, "warning")) {
[09:31:34.655]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.655]                         if (muffled) 
[09:31:34.655]                           invokeRestart("muffleWarning")
[09:31:34.655]                       }
[09:31:34.655]                       else if (inherits(cond, "condition")) {
[09:31:34.655]                         if (!is.null(pattern)) {
[09:31:34.655]                           computeRestarts <- base::computeRestarts
[09:31:34.655]                           grepl <- base::grepl
[09:31:34.655]                           restarts <- computeRestarts(cond)
[09:31:34.655]                           for (restart in restarts) {
[09:31:34.655]                             name <- restart$name
[09:31:34.655]                             if (is.null(name)) 
[09:31:34.655]                               next
[09:31:34.655]                             if (!grepl(pattern, name)) 
[09:31:34.655]                               next
[09:31:34.655]                             invokeRestart(restart)
[09:31:34.655]                             muffled <- TRUE
[09:31:34.655]                             break
[09:31:34.655]                           }
[09:31:34.655]                         }
[09:31:34.655]                       }
[09:31:34.655]                       invisible(muffled)
[09:31:34.655]                     }
[09:31:34.655]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.655]                   }
[09:31:34.655]                 }
[09:31:34.655]             }
[09:31:34.655]         }))
[09:31:34.655]     }, error = function(ex) {
[09:31:34.655]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.655]                 ...future.rng), started = ...future.startTime, 
[09:31:34.655]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.655]             version = "1.8"), class = "FutureResult")
[09:31:34.655]     }, finally = {
[09:31:34.655]         if (!identical(...future.workdir, getwd())) 
[09:31:34.655]             setwd(...future.workdir)
[09:31:34.655]         {
[09:31:34.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.655]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.655]             }
[09:31:34.655]             base::options(...future.oldOptions)
[09:31:34.655]             if (.Platform$OS.type == "windows") {
[09:31:34.655]                 old_names <- names(...future.oldEnvVars)
[09:31:34.655]                 envs <- base::Sys.getenv()
[09:31:34.655]                 names <- names(envs)
[09:31:34.655]                 common <- intersect(names, old_names)
[09:31:34.655]                 added <- setdiff(names, old_names)
[09:31:34.655]                 removed <- setdiff(old_names, names)
[09:31:34.655]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.655]                   envs[common]]
[09:31:34.655]                 NAMES <- toupper(changed)
[09:31:34.655]                 args <- list()
[09:31:34.655]                 for (kk in seq_along(NAMES)) {
[09:31:34.655]                   name <- changed[[kk]]
[09:31:34.655]                   NAME <- NAMES[[kk]]
[09:31:34.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.655]                     next
[09:31:34.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.655]                 }
[09:31:34.655]                 NAMES <- toupper(added)
[09:31:34.655]                 for (kk in seq_along(NAMES)) {
[09:31:34.655]                   name <- added[[kk]]
[09:31:34.655]                   NAME <- NAMES[[kk]]
[09:31:34.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.655]                     next
[09:31:34.655]                   args[[name]] <- ""
[09:31:34.655]                 }
[09:31:34.655]                 NAMES <- toupper(removed)
[09:31:34.655]                 for (kk in seq_along(NAMES)) {
[09:31:34.655]                   name <- removed[[kk]]
[09:31:34.655]                   NAME <- NAMES[[kk]]
[09:31:34.655]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.655]                     next
[09:31:34.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.655]                 }
[09:31:34.655]                 if (length(args) > 0) 
[09:31:34.655]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.655]             }
[09:31:34.655]             else {
[09:31:34.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.655]             }
[09:31:34.655]             {
[09:31:34.655]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.655]                   0L) {
[09:31:34.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.655]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.655]                   base::options(opts)
[09:31:34.655]                 }
[09:31:34.655]                 {
[09:31:34.655]                   {
[09:31:34.655]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.655]                     NULL
[09:31:34.655]                   }
[09:31:34.655]                   options(future.plan = NULL)
[09:31:34.655]                   if (is.na(NA_character_)) 
[09:31:34.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.655]                     .init = FALSE)
[09:31:34.655]                 }
[09:31:34.655]             }
[09:31:34.655]         }
[09:31:34.655]     })
[09:31:34.655]     if (TRUE) {
[09:31:34.655]         base::sink(type = "output", split = FALSE)
[09:31:34.655]         if (TRUE) {
[09:31:34.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.655]         }
[09:31:34.655]         else {
[09:31:34.655]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.655]         }
[09:31:34.655]         base::close(...future.stdout)
[09:31:34.655]         ...future.stdout <- NULL
[09:31:34.655]     }
[09:31:34.655]     ...future.result$conditions <- ...future.conditions
[09:31:34.655]     ...future.result$finished <- base::Sys.time()
[09:31:34.655]     ...future.result
[09:31:34.655] }
[09:31:34.657] requestCore(): workers = 2
[09:31:34.659] MulticoreFuture started
[09:31:34.660] - Launch lazy future ... done
[09:31:34.660] run() for ‘MulticoreFuture’ ... done
[09:31:34.660] plan(): Setting new future strategy stack:
[09:31:34.661] List of future strategies:
[09:31:34.661] 1. sequential:
[09:31:34.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.661]    - tweaked: FALSE
[09:31:34.661]    - call: NULL
[09:31:34.662] plan(): nbrOfWorkers() = 1
[09:31:34.664] plan(): Setting new future strategy stack:
[09:31:34.665] List of future strategies:
[09:31:34.665] 1. multicore:
[09:31:34.665]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.665]    - tweaked: FALSE
[09:31:34.665]    - call: plan(strategy)
[09:31:34.670] plan(): nbrOfWorkers() = 2
[09:31:34.671] Future #1
[09:31:34.671] result() for MulticoreFuture ...
[09:31:34.672] result() for MulticoreFuture ...
[09:31:34.672] result() for MulticoreFuture ... done
[09:31:34.672] result() for MulticoreFuture ... done
[09:31:34.672] result() for MulticoreFuture ...
[09:31:34.673] result() for MulticoreFuture ... done
[09:31:34.673] A MulticoreFuture was resolved
[09:31:34.673]  length: 0 (resolved future 1)
[09:31:34.673] resolve() on list ... DONE
[09:31:34.673] - globals: [1] ‘a’
[09:31:34.673] Resolving futures part of globals (recursively) ... DONE
[09:31:34.676] The total size of the 1 globals is 1.57 MiB (1647648 bytes)
[09:31:34.677] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:34.677] - globals: [1] ‘a’
[09:31:34.677] - packages: [1] ‘future’
[09:31:34.677] getGlobalsAndPackages() ... DONE
[09:31:34.678] run() for ‘Future’ ...
[09:31:34.678] - state: ‘created’
[09:31:34.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.682]   - Field: ‘label’
[09:31:34.682]   - Field: ‘local’
[09:31:34.682]   - Field: ‘owner’
[09:31:34.682]   - Field: ‘envir’
[09:31:34.683]   - Field: ‘workers’
[09:31:34.683]   - Field: ‘packages’
[09:31:34.683]   - Field: ‘gc’
[09:31:34.683]   - Field: ‘job’
[09:31:34.683]   - Field: ‘conditions’
[09:31:34.683]   - Field: ‘expr’
[09:31:34.683]   - Field: ‘uuid’
[09:31:34.683]   - Field: ‘seed’
[09:31:34.683]   - Field: ‘version’
[09:31:34.684]   - Field: ‘result’
[09:31:34.684]   - Field: ‘asynchronous’
[09:31:34.684]   - Field: ‘calls’
[09:31:34.684]   - Field: ‘globals’
[09:31:34.684]   - Field: ‘stdout’
[09:31:34.684]   - Field: ‘earlySignal’
[09:31:34.684]   - Field: ‘lazy’
[09:31:34.684]   - Field: ‘state’
[09:31:34.684] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.685] - Launch lazy future ...
[09:31:34.685] Packages needed by the future expression (n = 1): ‘future’
[09:31:34.685] Packages needed by future strategies (n = 0): <none>
[09:31:34.686] {
[09:31:34.686]     {
[09:31:34.686]         {
[09:31:34.686]             ...future.startTime <- base::Sys.time()
[09:31:34.686]             {
[09:31:34.686]                 {
[09:31:34.686]                   {
[09:31:34.686]                     {
[09:31:34.686]                       {
[09:31:34.686]                         base::local({
[09:31:34.686]                           has_future <- base::requireNamespace("future", 
[09:31:34.686]                             quietly = TRUE)
[09:31:34.686]                           if (has_future) {
[09:31:34.686]                             ns <- base::getNamespace("future")
[09:31:34.686]                             version <- ns[[".package"]][["version"]]
[09:31:34.686]                             if (is.null(version)) 
[09:31:34.686]                               version <- utils::packageVersion("future")
[09:31:34.686]                           }
[09:31:34.686]                           else {
[09:31:34.686]                             version <- NULL
[09:31:34.686]                           }
[09:31:34.686]                           if (!has_future || version < "1.8.0") {
[09:31:34.686]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.686]                               "", base::R.version$version.string), 
[09:31:34.686]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:34.686]                                 base::R.version$platform, 8 * 
[09:31:34.686]                                   base::.Machine$sizeof.pointer), 
[09:31:34.686]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.686]                                 "release", "version")], collapse = " "), 
[09:31:34.686]                               hostname = base::Sys.info()[["nodename"]])
[09:31:34.686]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.686]                               info)
[09:31:34.686]                             info <- base::paste(info, collapse = "; ")
[09:31:34.686]                             if (!has_future) {
[09:31:34.686]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.686]                                 info)
[09:31:34.686]                             }
[09:31:34.686]                             else {
[09:31:34.686]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.686]                                 info, version)
[09:31:34.686]                             }
[09:31:34.686]                             base::stop(msg)
[09:31:34.686]                           }
[09:31:34.686]                         })
[09:31:34.686]                       }
[09:31:34.686]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.686]                       base::options(mc.cores = 1L)
[09:31:34.686]                     }
[09:31:34.686]                     base::local({
[09:31:34.686]                       for (pkg in "future") {
[09:31:34.686]                         base::loadNamespace(pkg)
[09:31:34.686]                         base::library(pkg, character.only = TRUE)
[09:31:34.686]                       }
[09:31:34.686]                     })
[09:31:34.686]                   }
[09:31:34.686]                   ...future.strategy.old <- future::plan("list")
[09:31:34.686]                   options(future.plan = NULL)
[09:31:34.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.686]                 }
[09:31:34.686]                 ...future.workdir <- getwd()
[09:31:34.686]             }
[09:31:34.686]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.686]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.686]         }
[09:31:34.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.686]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.686]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.686]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.686]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.686]             base::names(...future.oldOptions))
[09:31:34.686]     }
[09:31:34.686]     if (FALSE) {
[09:31:34.686]     }
[09:31:34.686]     else {
[09:31:34.686]         if (TRUE) {
[09:31:34.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.686]                 open = "w")
[09:31:34.686]         }
[09:31:34.686]         else {
[09:31:34.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.686]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.686]         }
[09:31:34.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.686]             base::sink(type = "output", split = FALSE)
[09:31:34.686]             base::close(...future.stdout)
[09:31:34.686]         }, add = TRUE)
[09:31:34.686]     }
[09:31:34.686]     ...future.frame <- base::sys.nframe()
[09:31:34.686]     ...future.conditions <- base::list()
[09:31:34.686]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.686]     if (FALSE) {
[09:31:34.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.686]     }
[09:31:34.686]     ...future.result <- base::tryCatch({
[09:31:34.686]         base::withCallingHandlers({
[09:31:34.686]             ...future.value <- base::withVisible(base::local({
[09:31:34.686]                 withCallingHandlers({
[09:31:34.686]                   value(a) + 1
[09:31:34.686]                 }, immediateCondition = function(cond) {
[09:31:34.686]                   save_rds <- function (object, pathname, ...) 
[09:31:34.686]                   {
[09:31:34.686]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.686]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.686]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.686]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.686]                         fi_tmp[["mtime"]])
[09:31:34.686]                     }
[09:31:34.686]                     tryCatch({
[09:31:34.686]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.686]                     }, error = function(ex) {
[09:31:34.686]                       msg <- conditionMessage(ex)
[09:31:34.686]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.686]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.686]                         fi_tmp[["mtime"]], msg)
[09:31:34.686]                       ex$message <- msg
[09:31:34.686]                       stop(ex)
[09:31:34.686]                     })
[09:31:34.686]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.686]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.686]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.686]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.686]                       fi <- file.info(pathname)
[09:31:34.686]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.686]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.686]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.686]                         fi[["size"]], fi[["mtime"]])
[09:31:34.686]                       stop(msg)
[09:31:34.686]                     }
[09:31:34.686]                     invisible(pathname)
[09:31:34.686]                   }
[09:31:34.686]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.686]                     rootPath = tempdir()) 
[09:31:34.686]                   {
[09:31:34.686]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.686]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.686]                       tmpdir = path, fileext = ".rds")
[09:31:34.686]                     save_rds(obj, file)
[09:31:34.686]                   }
[09:31:34.686]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.686]                   {
[09:31:34.686]                     inherits <- base::inherits
[09:31:34.686]                     invokeRestart <- base::invokeRestart
[09:31:34.686]                     is.null <- base::is.null
[09:31:34.686]                     muffled <- FALSE
[09:31:34.686]                     if (inherits(cond, "message")) {
[09:31:34.686]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.686]                       if (muffled) 
[09:31:34.686]                         invokeRestart("muffleMessage")
[09:31:34.686]                     }
[09:31:34.686]                     else if (inherits(cond, "warning")) {
[09:31:34.686]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.686]                       if (muffled) 
[09:31:34.686]                         invokeRestart("muffleWarning")
[09:31:34.686]                     }
[09:31:34.686]                     else if (inherits(cond, "condition")) {
[09:31:34.686]                       if (!is.null(pattern)) {
[09:31:34.686]                         computeRestarts <- base::computeRestarts
[09:31:34.686]                         grepl <- base::grepl
[09:31:34.686]                         restarts <- computeRestarts(cond)
[09:31:34.686]                         for (restart in restarts) {
[09:31:34.686]                           name <- restart$name
[09:31:34.686]                           if (is.null(name)) 
[09:31:34.686]                             next
[09:31:34.686]                           if (!grepl(pattern, name)) 
[09:31:34.686]                             next
[09:31:34.686]                           invokeRestart(restart)
[09:31:34.686]                           muffled <- TRUE
[09:31:34.686]                           break
[09:31:34.686]                         }
[09:31:34.686]                       }
[09:31:34.686]                     }
[09:31:34.686]                     invisible(muffled)
[09:31:34.686]                   }
[09:31:34.686]                   muffleCondition(cond)
[09:31:34.686]                 })
[09:31:34.686]             }))
[09:31:34.686]             future::FutureResult(value = ...future.value$value, 
[09:31:34.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.686]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.686]                     ...future.globalenv.names))
[09:31:34.686]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.686]         }, condition = base::local({
[09:31:34.686]             c <- base::c
[09:31:34.686]             inherits <- base::inherits
[09:31:34.686]             invokeRestart <- base::invokeRestart
[09:31:34.686]             length <- base::length
[09:31:34.686]             list <- base::list
[09:31:34.686]             seq.int <- base::seq.int
[09:31:34.686]             signalCondition <- base::signalCondition
[09:31:34.686]             sys.calls <- base::sys.calls
[09:31:34.686]             `[[` <- base::`[[`
[09:31:34.686]             `+` <- base::`+`
[09:31:34.686]             `<<-` <- base::`<<-`
[09:31:34.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.686]                   3L)]
[09:31:34.686]             }
[09:31:34.686]             function(cond) {
[09:31:34.686]                 is_error <- inherits(cond, "error")
[09:31:34.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.686]                   NULL)
[09:31:34.686]                 if (is_error) {
[09:31:34.686]                   sessionInformation <- function() {
[09:31:34.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.686]                       search = base::search(), system = base::Sys.info())
[09:31:34.686]                   }
[09:31:34.686]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.686]                     cond$call), session = sessionInformation(), 
[09:31:34.686]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.686]                   signalCondition(cond)
[09:31:34.686]                 }
[09:31:34.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.686]                 "immediateCondition"))) {
[09:31:34.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.686]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.686]                   if (TRUE && !signal) {
[09:31:34.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.686]                     {
[09:31:34.686]                       inherits <- base::inherits
[09:31:34.686]                       invokeRestart <- base::invokeRestart
[09:31:34.686]                       is.null <- base::is.null
[09:31:34.686]                       muffled <- FALSE
[09:31:34.686]                       if (inherits(cond, "message")) {
[09:31:34.686]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.686]                         if (muffled) 
[09:31:34.686]                           invokeRestart("muffleMessage")
[09:31:34.686]                       }
[09:31:34.686]                       else if (inherits(cond, "warning")) {
[09:31:34.686]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.686]                         if (muffled) 
[09:31:34.686]                           invokeRestart("muffleWarning")
[09:31:34.686]                       }
[09:31:34.686]                       else if (inherits(cond, "condition")) {
[09:31:34.686]                         if (!is.null(pattern)) {
[09:31:34.686]                           computeRestarts <- base::computeRestarts
[09:31:34.686]                           grepl <- base::grepl
[09:31:34.686]                           restarts <- computeRestarts(cond)
[09:31:34.686]                           for (restart in restarts) {
[09:31:34.686]                             name <- restart$name
[09:31:34.686]                             if (is.null(name)) 
[09:31:34.686]                               next
[09:31:34.686]                             if (!grepl(pattern, name)) 
[09:31:34.686]                               next
[09:31:34.686]                             invokeRestart(restart)
[09:31:34.686]                             muffled <- TRUE
[09:31:34.686]                             break
[09:31:34.686]                           }
[09:31:34.686]                         }
[09:31:34.686]                       }
[09:31:34.686]                       invisible(muffled)
[09:31:34.686]                     }
[09:31:34.686]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.686]                   }
[09:31:34.686]                 }
[09:31:34.686]                 else {
[09:31:34.686]                   if (TRUE) {
[09:31:34.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.686]                     {
[09:31:34.686]                       inherits <- base::inherits
[09:31:34.686]                       invokeRestart <- base::invokeRestart
[09:31:34.686]                       is.null <- base::is.null
[09:31:34.686]                       muffled <- FALSE
[09:31:34.686]                       if (inherits(cond, "message")) {
[09:31:34.686]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.686]                         if (muffled) 
[09:31:34.686]                           invokeRestart("muffleMessage")
[09:31:34.686]                       }
[09:31:34.686]                       else if (inherits(cond, "warning")) {
[09:31:34.686]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.686]                         if (muffled) 
[09:31:34.686]                           invokeRestart("muffleWarning")
[09:31:34.686]                       }
[09:31:34.686]                       else if (inherits(cond, "condition")) {
[09:31:34.686]                         if (!is.null(pattern)) {
[09:31:34.686]                           computeRestarts <- base::computeRestarts
[09:31:34.686]                           grepl <- base::grepl
[09:31:34.686]                           restarts <- computeRestarts(cond)
[09:31:34.686]                           for (restart in restarts) {
[09:31:34.686]                             name <- restart$name
[09:31:34.686]                             if (is.null(name)) 
[09:31:34.686]                               next
[09:31:34.686]                             if (!grepl(pattern, name)) 
[09:31:34.686]                               next
[09:31:34.686]                             invokeRestart(restart)
[09:31:34.686]                             muffled <- TRUE
[09:31:34.686]                             break
[09:31:34.686]                           }
[09:31:34.686]                         }
[09:31:34.686]                       }
[09:31:34.686]                       invisible(muffled)
[09:31:34.686]                     }
[09:31:34.686]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.686]                   }
[09:31:34.686]                 }
[09:31:34.686]             }
[09:31:34.686]         }))
[09:31:34.686]     }, error = function(ex) {
[09:31:34.686]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.686]                 ...future.rng), started = ...future.startTime, 
[09:31:34.686]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.686]             version = "1.8"), class = "FutureResult")
[09:31:34.686]     }, finally = {
[09:31:34.686]         if (!identical(...future.workdir, getwd())) 
[09:31:34.686]             setwd(...future.workdir)
[09:31:34.686]         {
[09:31:34.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.686]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.686]             }
[09:31:34.686]             base::options(...future.oldOptions)
[09:31:34.686]             if (.Platform$OS.type == "windows") {
[09:31:34.686]                 old_names <- names(...future.oldEnvVars)
[09:31:34.686]                 envs <- base::Sys.getenv()
[09:31:34.686]                 names <- names(envs)
[09:31:34.686]                 common <- intersect(names, old_names)
[09:31:34.686]                 added <- setdiff(names, old_names)
[09:31:34.686]                 removed <- setdiff(old_names, names)
[09:31:34.686]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.686]                   envs[common]]
[09:31:34.686]                 NAMES <- toupper(changed)
[09:31:34.686]                 args <- list()
[09:31:34.686]                 for (kk in seq_along(NAMES)) {
[09:31:34.686]                   name <- changed[[kk]]
[09:31:34.686]                   NAME <- NAMES[[kk]]
[09:31:34.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.686]                     next
[09:31:34.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.686]                 }
[09:31:34.686]                 NAMES <- toupper(added)
[09:31:34.686]                 for (kk in seq_along(NAMES)) {
[09:31:34.686]                   name <- added[[kk]]
[09:31:34.686]                   NAME <- NAMES[[kk]]
[09:31:34.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.686]                     next
[09:31:34.686]                   args[[name]] <- ""
[09:31:34.686]                 }
[09:31:34.686]                 NAMES <- toupper(removed)
[09:31:34.686]                 for (kk in seq_along(NAMES)) {
[09:31:34.686]                   name <- removed[[kk]]
[09:31:34.686]                   NAME <- NAMES[[kk]]
[09:31:34.686]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.686]                     next
[09:31:34.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.686]                 }
[09:31:34.686]                 if (length(args) > 0) 
[09:31:34.686]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.686]             }
[09:31:34.686]             else {
[09:31:34.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.686]             }
[09:31:34.686]             {
[09:31:34.686]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.686]                   0L) {
[09:31:34.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.686]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.686]                   base::options(opts)
[09:31:34.686]                 }
[09:31:34.686]                 {
[09:31:34.686]                   {
[09:31:34.686]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.686]                     NULL
[09:31:34.686]                   }
[09:31:34.686]                   options(future.plan = NULL)
[09:31:34.686]                   if (is.na(NA_character_)) 
[09:31:34.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.686]                     .init = FALSE)
[09:31:34.686]                 }
[09:31:34.686]             }
[09:31:34.686]         }
[09:31:34.686]     })
[09:31:34.686]     if (TRUE) {
[09:31:34.686]         base::sink(type = "output", split = FALSE)
[09:31:34.686]         if (TRUE) {
[09:31:34.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.686]         }
[09:31:34.686]         else {
[09:31:34.686]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.686]         }
[09:31:34.686]         base::close(...future.stdout)
[09:31:34.686]         ...future.stdout <- NULL
[09:31:34.686]     }
[09:31:34.686]     ...future.result$conditions <- ...future.conditions
[09:31:34.686]     ...future.result$finished <- base::Sys.time()
[09:31:34.686]     ...future.result
[09:31:34.686] }
[09:31:34.688] assign_globals() ...
[09:31:34.688] List of 1
[09:31:34.688]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e21a95e148> 
[09:31:34.688]  - attr(*, "where")=List of 1
[09:31:34.688]   ..$ a:<environment: R_EmptyEnv> 
[09:31:34.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.688]  - attr(*, "resolved")= logi TRUE
[09:31:34.688]  - attr(*, "total_size")= num 1647648
[09:31:34.688]  - attr(*, "already-done")= logi TRUE
[09:31:34.691] - copied ‘a’ to environment
[09:31:34.692] assign_globals() ... done
[09:31:34.692] requestCore(): workers = 2
[09:31:34.693] MulticoreFuture started
[09:31:34.694] - Launch lazy future ... done
[09:31:34.694] run() for ‘MulticoreFuture’ ... done
[09:31:34.694] result() for MulticoreFuture ...
[09:31:34.695] plan(): Setting new future strategy stack:
[09:31:34.695] List of future strategies:
[09:31:34.695] 1. sequential:
[09:31:34.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.695]    - tweaked: FALSE
[09:31:34.695]    - call: NULL
[09:31:34.696] plan(): nbrOfWorkers() = 1
[09:31:34.699] plan(): Setting new future strategy stack:
[09:31:34.700] List of future strategies:
[09:31:34.700] 1. multicore:
[09:31:34.700]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.700]    - tweaked: FALSE
[09:31:34.700]    - call: plan(strategy)
[09:31:34.710] plan(): nbrOfWorkers() = 2
[09:31:34.711] result() for MulticoreFuture ...
[09:31:34.711] result() for MulticoreFuture ... done
[09:31:34.711] signalConditions() ...
[09:31:34.711]  - include = ‘immediateCondition’
[09:31:34.711]  - exclude = 
[09:31:34.711]  - resignal = FALSE
[09:31:34.711]  - Number of conditions: 4
[09:31:34.712] signalConditions() ... done
[09:31:34.712] result() for MulticoreFuture ... done
[09:31:34.712] result() for MulticoreFuture ...
[09:31:34.712] result() for MulticoreFuture ... done
[09:31:34.712] signalConditions() ...
[09:31:34.712]  - include = ‘immediateCondition’
[09:31:34.712]  - exclude = 
[09:31:34.713]  - resignal = FALSE
[09:31:34.713]  - Number of conditions: 4
[09:31:34.713] signalConditions() ... done
[09:31:34.713] Future state: ‘finished’
[09:31:34.713] result() for MulticoreFuture ...
[09:31:34.713] result() for MulticoreFuture ... done
[09:31:34.713] signalConditions() ...
[09:31:34.713]  - include = ‘condition’
[09:31:34.714]  - exclude = ‘immediateCondition’
[09:31:34.714]  - resignal = TRUE
[09:31:34.714]  - Number of conditions: 4
[09:31:34.716]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.697] result() for MulticoreFuture ...
[09:31:34.717]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ... done
[09:31:34.717]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ...
[09:31:34.717]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ... done
[09:31:34.717] signalConditions() ... done
value(b) = 2
[09:31:34.718] result() for MulticoreFuture ...
[09:31:34.718] result() for MulticoreFuture ... done
[09:31:34.718] result() for MulticoreFuture ...
[09:31:34.718] result() for MulticoreFuture ... done
[09:31:34.718] signalConditions() ...
[09:31:34.718]  - include = ‘immediateCondition’
[09:31:34.718]  - exclude = 
[09:31:34.718]  - resignal = FALSE
[09:31:34.718]  - Number of conditions: 4
[09:31:34.719] signalConditions() ... done
[09:31:34.719] Future state: ‘finished’
[09:31:34.719] result() for MulticoreFuture ...
[09:31:34.719] result() for MulticoreFuture ... done
[09:31:34.719] signalConditions() ...
[09:31:34.719]  - include = ‘condition’
[09:31:34.719]  - exclude = ‘immediateCondition’
[09:31:34.719]  - resignal = TRUE
[09:31:34.720]  - Number of conditions: 4
[09:31:34.720]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.697] result() for MulticoreFuture ...
[09:31:34.720]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ... done
[09:31:34.720]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ...
[09:31:34.720]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[09:31:34.698] result() for MulticoreFuture ... done
[09:31:34.720] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.721] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.721] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.722] - globals found: [2] ‘{’, ‘pkg’
[09:31:34.723] Searching for globals ... DONE
[09:31:34.723] Resolving globals: TRUE
[09:31:34.723] Resolving any globals that are futures ...
[09:31:34.723] - globals: [2] ‘{’, ‘pkg’
[09:31:34.723] Resolving any globals that are futures ... DONE
[09:31:34.724] Resolving futures part of globals (recursively) ...
[09:31:34.724] resolve() on list ...
[09:31:34.724]  recursive: 99
[09:31:34.724]  length: 1
[09:31:34.724]  elements: ‘pkg’
[09:31:34.725]  length: 0 (resolved future 1)
[09:31:34.725] resolve() on list ... DONE
[09:31:34.725] - globals: [1] ‘pkg’
[09:31:34.725] Resolving futures part of globals (recursively) ... DONE
[09:31:34.725] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:34.725] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:34.726] - globals: [1] ‘pkg’
[09:31:34.726] 
[09:31:34.726] getGlobalsAndPackages() ... DONE
[09:31:34.726] Packages needed by the future expression (n = 0): <none>
[09:31:34.726] Packages needed by future strategies (n = 0): <none>
[09:31:34.727] {
[09:31:34.727]     {
[09:31:34.727]         {
[09:31:34.727]             ...future.startTime <- base::Sys.time()
[09:31:34.727]             {
[09:31:34.727]                 {
[09:31:34.727]                   {
[09:31:34.727]                     base::local({
[09:31:34.727]                       has_future <- base::requireNamespace("future", 
[09:31:34.727]                         quietly = TRUE)
[09:31:34.727]                       if (has_future) {
[09:31:34.727]                         ns <- base::getNamespace("future")
[09:31:34.727]                         version <- ns[[".package"]][["version"]]
[09:31:34.727]                         if (is.null(version)) 
[09:31:34.727]                           version <- utils::packageVersion("future")
[09:31:34.727]                       }
[09:31:34.727]                       else {
[09:31:34.727]                         version <- NULL
[09:31:34.727]                       }
[09:31:34.727]                       if (!has_future || version < "1.8.0") {
[09:31:34.727]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.727]                           "", base::R.version$version.string), 
[09:31:34.727]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:34.727]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.727]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.727]                             "release", "version")], collapse = " "), 
[09:31:34.727]                           hostname = base::Sys.info()[["nodename"]])
[09:31:34.727]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.727]                           info)
[09:31:34.727]                         info <- base::paste(info, collapse = "; ")
[09:31:34.727]                         if (!has_future) {
[09:31:34.727]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.727]                             info)
[09:31:34.727]                         }
[09:31:34.727]                         else {
[09:31:34.727]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.727]                             info, version)
[09:31:34.727]                         }
[09:31:34.727]                         base::stop(msg)
[09:31:34.727]                       }
[09:31:34.727]                     })
[09:31:34.727]                   }
[09:31:34.727]                   ...future.strategy.old <- future::plan("list")
[09:31:34.727]                   options(future.plan = NULL)
[09:31:34.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.727]                 }
[09:31:34.727]                 ...future.workdir <- getwd()
[09:31:34.727]             }
[09:31:34.727]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.727]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.727]         }
[09:31:34.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.727]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.727]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.727]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.727]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.727]             base::names(...future.oldOptions))
[09:31:34.727]     }
[09:31:34.727]     if (FALSE) {
[09:31:34.727]     }
[09:31:34.727]     else {
[09:31:34.727]         if (TRUE) {
[09:31:34.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.727]                 open = "w")
[09:31:34.727]         }
[09:31:34.727]         else {
[09:31:34.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.727]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.727]         }
[09:31:34.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.727]             base::sink(type = "output", split = FALSE)
[09:31:34.727]             base::close(...future.stdout)
[09:31:34.727]         }, add = TRUE)
[09:31:34.727]     }
[09:31:34.727]     ...future.frame <- base::sys.nframe()
[09:31:34.727]     ...future.conditions <- base::list()
[09:31:34.727]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.727]     if (FALSE) {
[09:31:34.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.727]     }
[09:31:34.727]     ...future.result <- base::tryCatch({
[09:31:34.727]         base::withCallingHandlers({
[09:31:34.727]             ...future.value <- base::withVisible(base::local({
[09:31:34.727]                 pkg
[09:31:34.727]             }))
[09:31:34.727]             future::FutureResult(value = ...future.value$value, 
[09:31:34.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.727]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.727]                     ...future.globalenv.names))
[09:31:34.727]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.727]         }, condition = base::local({
[09:31:34.727]             c <- base::c
[09:31:34.727]             inherits <- base::inherits
[09:31:34.727]             invokeRestart <- base::invokeRestart
[09:31:34.727]             length <- base::length
[09:31:34.727]             list <- base::list
[09:31:34.727]             seq.int <- base::seq.int
[09:31:34.727]             signalCondition <- base::signalCondition
[09:31:34.727]             sys.calls <- base::sys.calls
[09:31:34.727]             `[[` <- base::`[[`
[09:31:34.727]             `+` <- base::`+`
[09:31:34.727]             `<<-` <- base::`<<-`
[09:31:34.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.727]                   3L)]
[09:31:34.727]             }
[09:31:34.727]             function(cond) {
[09:31:34.727]                 is_error <- inherits(cond, "error")
[09:31:34.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.727]                   NULL)
[09:31:34.727]                 if (is_error) {
[09:31:34.727]                   sessionInformation <- function() {
[09:31:34.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.727]                       search = base::search(), system = base::Sys.info())
[09:31:34.727]                   }
[09:31:34.727]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.727]                     cond$call), session = sessionInformation(), 
[09:31:34.727]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.727]                   signalCondition(cond)
[09:31:34.727]                 }
[09:31:34.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.727]                 "immediateCondition"))) {
[09:31:34.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.727]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.727]                   if (TRUE && !signal) {
[09:31:34.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.727]                     {
[09:31:34.727]                       inherits <- base::inherits
[09:31:34.727]                       invokeRestart <- base::invokeRestart
[09:31:34.727]                       is.null <- base::is.null
[09:31:34.727]                       muffled <- FALSE
[09:31:34.727]                       if (inherits(cond, "message")) {
[09:31:34.727]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.727]                         if (muffled) 
[09:31:34.727]                           invokeRestart("muffleMessage")
[09:31:34.727]                       }
[09:31:34.727]                       else if (inherits(cond, "warning")) {
[09:31:34.727]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.727]                         if (muffled) 
[09:31:34.727]                           invokeRestart("muffleWarning")
[09:31:34.727]                       }
[09:31:34.727]                       else if (inherits(cond, "condition")) {
[09:31:34.727]                         if (!is.null(pattern)) {
[09:31:34.727]                           computeRestarts <- base::computeRestarts
[09:31:34.727]                           grepl <- base::grepl
[09:31:34.727]                           restarts <- computeRestarts(cond)
[09:31:34.727]                           for (restart in restarts) {
[09:31:34.727]                             name <- restart$name
[09:31:34.727]                             if (is.null(name)) 
[09:31:34.727]                               next
[09:31:34.727]                             if (!grepl(pattern, name)) 
[09:31:34.727]                               next
[09:31:34.727]                             invokeRestart(restart)
[09:31:34.727]                             muffled <- TRUE
[09:31:34.727]                             break
[09:31:34.727]                           }
[09:31:34.727]                         }
[09:31:34.727]                       }
[09:31:34.727]                       invisible(muffled)
[09:31:34.727]                     }
[09:31:34.727]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.727]                   }
[09:31:34.727]                 }
[09:31:34.727]                 else {
[09:31:34.727]                   if (TRUE) {
[09:31:34.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.727]                     {
[09:31:34.727]                       inherits <- base::inherits
[09:31:34.727]                       invokeRestart <- base::invokeRestart
[09:31:34.727]                       is.null <- base::is.null
[09:31:34.727]                       muffled <- FALSE
[09:31:34.727]                       if (inherits(cond, "message")) {
[09:31:34.727]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.727]                         if (muffled) 
[09:31:34.727]                           invokeRestart("muffleMessage")
[09:31:34.727]                       }
[09:31:34.727]                       else if (inherits(cond, "warning")) {
[09:31:34.727]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.727]                         if (muffled) 
[09:31:34.727]                           invokeRestart("muffleWarning")
[09:31:34.727]                       }
[09:31:34.727]                       else if (inherits(cond, "condition")) {
[09:31:34.727]                         if (!is.null(pattern)) {
[09:31:34.727]                           computeRestarts <- base::computeRestarts
[09:31:34.727]                           grepl <- base::grepl
[09:31:34.727]                           restarts <- computeRestarts(cond)
[09:31:34.727]                           for (restart in restarts) {
[09:31:34.727]                             name <- restart$name
[09:31:34.727]                             if (is.null(name)) 
[09:31:34.727]                               next
[09:31:34.727]                             if (!grepl(pattern, name)) 
[09:31:34.727]                               next
[09:31:34.727]                             invokeRestart(restart)
[09:31:34.727]                             muffled <- TRUE
[09:31:34.727]                             break
[09:31:34.727]                           }
[09:31:34.727]                         }
[09:31:34.727]                       }
[09:31:34.727]                       invisible(muffled)
[09:31:34.727]                     }
[09:31:34.727]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.727]                   }
[09:31:34.727]                 }
[09:31:34.727]             }
[09:31:34.727]         }))
[09:31:34.727]     }, error = function(ex) {
[09:31:34.727]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.727]                 ...future.rng), started = ...future.startTime, 
[09:31:34.727]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.727]             version = "1.8"), class = "FutureResult")
[09:31:34.727]     }, finally = {
[09:31:34.727]         if (!identical(...future.workdir, getwd())) 
[09:31:34.727]             setwd(...future.workdir)
[09:31:34.727]         {
[09:31:34.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.727]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.727]             }
[09:31:34.727]             base::options(...future.oldOptions)
[09:31:34.727]             if (.Platform$OS.type == "windows") {
[09:31:34.727]                 old_names <- names(...future.oldEnvVars)
[09:31:34.727]                 envs <- base::Sys.getenv()
[09:31:34.727]                 names <- names(envs)
[09:31:34.727]                 common <- intersect(names, old_names)
[09:31:34.727]                 added <- setdiff(names, old_names)
[09:31:34.727]                 removed <- setdiff(old_names, names)
[09:31:34.727]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.727]                   envs[common]]
[09:31:34.727]                 NAMES <- toupper(changed)
[09:31:34.727]                 args <- list()
[09:31:34.727]                 for (kk in seq_along(NAMES)) {
[09:31:34.727]                   name <- changed[[kk]]
[09:31:34.727]                   NAME <- NAMES[[kk]]
[09:31:34.727]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.727]                     next
[09:31:34.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.727]                 }
[09:31:34.727]                 NAMES <- toupper(added)
[09:31:34.727]                 for (kk in seq_along(NAMES)) {
[09:31:34.727]                   name <- added[[kk]]
[09:31:34.727]                   NAME <- NAMES[[kk]]
[09:31:34.727]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.727]                     next
[09:31:34.727]                   args[[name]] <- ""
[09:31:34.727]                 }
[09:31:34.727]                 NAMES <- toupper(removed)
[09:31:34.727]                 for (kk in seq_along(NAMES)) {
[09:31:34.727]                   name <- removed[[kk]]
[09:31:34.727]                   NAME <- NAMES[[kk]]
[09:31:34.727]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.727]                     next
[09:31:34.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.727]                 }
[09:31:34.727]                 if (length(args) > 0) 
[09:31:34.727]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.727]             }
[09:31:34.727]             else {
[09:31:34.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.727]             }
[09:31:34.727]             {
[09:31:34.727]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.727]                   0L) {
[09:31:34.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.727]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.727]                   base::options(opts)
[09:31:34.727]                 }
[09:31:34.727]                 {
[09:31:34.727]                   {
[09:31:34.727]                     NULL
[09:31:34.727]                     RNGkind("Mersenne-Twister")
[09:31:34.727]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:34.727]                       inherits = FALSE)
[09:31:34.727]                   }
[09:31:34.727]                   options(future.plan = NULL)
[09:31:34.727]                   if (is.na(NA_character_)) 
[09:31:34.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.727]                     .init = FALSE)
[09:31:34.727]                 }
[09:31:34.727]             }
[09:31:34.727]         }
[09:31:34.727]     })
[09:31:34.727]     if (TRUE) {
[09:31:34.727]         base::sink(type = "output", split = FALSE)
[09:31:34.727]         if (TRUE) {
[09:31:34.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.727]         }
[09:31:34.727]         else {
[09:31:34.727]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.727]         }
[09:31:34.727]         base::close(...future.stdout)
[09:31:34.727]         ...future.stdout <- NULL
[09:31:34.727]     }
[09:31:34.727]     ...future.result$conditions <- ...future.conditions
[09:31:34.727]     ...future.result$finished <- base::Sys.time()
[09:31:34.727]     ...future.result
[09:31:34.727] }
[09:31:34.729] assign_globals() ...
[09:31:34.729] List of 1
[09:31:34.729]  $ pkg: chr "foo"
[09:31:34.729]  - attr(*, "where")=List of 1
[09:31:34.729]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:34.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.729]  - attr(*, "resolved")= logi TRUE
[09:31:34.729]  - attr(*, "total_size")= num 112
[09:31:34.731] - copied ‘pkg’ to environment
[09:31:34.731] assign_globals() ... done
[09:31:34.732] plan(): Setting new future strategy stack:
[09:31:34.732] List of future strategies:
[09:31:34.732] 1. sequential:
[09:31:34.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.732]    - tweaked: FALSE
[09:31:34.732]    - call: NULL
[09:31:34.732] plan(): nbrOfWorkers() = 1
[09:31:34.733] plan(): Setting new future strategy stack:
[09:31:34.733] List of future strategies:
[09:31:34.733] 1. multicore:
[09:31:34.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.733]    - tweaked: FALSE
[09:31:34.733]    - call: plan(strategy)
[09:31:34.737] plan(): nbrOfWorkers() = 2
[09:31:34.737] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.738] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.738] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.740] - globals found: [3] ‘{’, ‘<-’, ‘+’
[09:31:34.740] Searching for globals ... DONE
[09:31:34.740] Resolving globals: TRUE
[09:31:34.740] Resolving any globals that are futures ...
[09:31:34.740] - globals: [3] ‘{’, ‘<-’, ‘+’
[09:31:34.740] Resolving any globals that are futures ... DONE
[09:31:34.741] 
[09:31:34.741] 
[09:31:34.741] getGlobalsAndPackages() ... DONE
[09:31:34.741] run() for ‘Future’ ...
[09:31:34.741] - state: ‘created’
[09:31:34.741] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.745]   - Field: ‘label’
[09:31:34.745]   - Field: ‘local’
[09:31:34.745]   - Field: ‘owner’
[09:31:34.745]   - Field: ‘envir’
[09:31:34.745]   - Field: ‘workers’
[09:31:34.745]   - Field: ‘packages’
[09:31:34.746]   - Field: ‘gc’
[09:31:34.746]   - Field: ‘job’
[09:31:34.746]   - Field: ‘conditions’
[09:31:34.746]   - Field: ‘expr’
[09:31:34.746]   - Field: ‘uuid’
[09:31:34.746]   - Field: ‘seed’
[09:31:34.746]   - Field: ‘version’
[09:31:34.746]   - Field: ‘result’
[09:31:34.746]   - Field: ‘asynchronous’
[09:31:34.746]   - Field: ‘calls’
[09:31:34.746]   - Field: ‘globals’
[09:31:34.747]   - Field: ‘stdout’
[09:31:34.747]   - Field: ‘earlySignal’
[09:31:34.747]   - Field: ‘lazy’
[09:31:34.747]   - Field: ‘state’
[09:31:34.747] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.747] - Launch lazy future ...
[09:31:34.747] Packages needed by the future expression (n = 0): <none>
[09:31:34.747] Packages needed by future strategies (n = 0): <none>
[09:31:34.748] {
[09:31:34.748]     {
[09:31:34.748]         {
[09:31:34.748]             ...future.startTime <- base::Sys.time()
[09:31:34.748]             {
[09:31:34.748]                 {
[09:31:34.748]                   {
[09:31:34.748]                     {
[09:31:34.748]                       base::local({
[09:31:34.748]                         has_future <- base::requireNamespace("future", 
[09:31:34.748]                           quietly = TRUE)
[09:31:34.748]                         if (has_future) {
[09:31:34.748]                           ns <- base::getNamespace("future")
[09:31:34.748]                           version <- ns[[".package"]][["version"]]
[09:31:34.748]                           if (is.null(version)) 
[09:31:34.748]                             version <- utils::packageVersion("future")
[09:31:34.748]                         }
[09:31:34.748]                         else {
[09:31:34.748]                           version <- NULL
[09:31:34.748]                         }
[09:31:34.748]                         if (!has_future || version < "1.8.0") {
[09:31:34.748]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.748]                             "", base::R.version$version.string), 
[09:31:34.748]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.748]                               "release", "version")], collapse = " "), 
[09:31:34.748]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.748]                             info)
[09:31:34.748]                           info <- base::paste(info, collapse = "; ")
[09:31:34.748]                           if (!has_future) {
[09:31:34.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.748]                               info)
[09:31:34.748]                           }
[09:31:34.748]                           else {
[09:31:34.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.748]                               info, version)
[09:31:34.748]                           }
[09:31:34.748]                           base::stop(msg)
[09:31:34.748]                         }
[09:31:34.748]                       })
[09:31:34.748]                     }
[09:31:34.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.748]                     base::options(mc.cores = 1L)
[09:31:34.748]                   }
[09:31:34.748]                   ...future.strategy.old <- future::plan("list")
[09:31:34.748]                   options(future.plan = NULL)
[09:31:34.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.748]                 }
[09:31:34.748]                 ...future.workdir <- getwd()
[09:31:34.748]             }
[09:31:34.748]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.748]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.748]         }
[09:31:34.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.748]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.748]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.748]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.748]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.748]             base::names(...future.oldOptions))
[09:31:34.748]     }
[09:31:34.748]     if (FALSE) {
[09:31:34.748]     }
[09:31:34.748]     else {
[09:31:34.748]         if (TRUE) {
[09:31:34.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.748]                 open = "w")
[09:31:34.748]         }
[09:31:34.748]         else {
[09:31:34.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.748]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.748]         }
[09:31:34.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.748]             base::sink(type = "output", split = FALSE)
[09:31:34.748]             base::close(...future.stdout)
[09:31:34.748]         }, add = TRUE)
[09:31:34.748]     }
[09:31:34.748]     ...future.frame <- base::sys.nframe()
[09:31:34.748]     ...future.conditions <- base::list()
[09:31:34.748]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.748]     if (FALSE) {
[09:31:34.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.748]     }
[09:31:34.748]     ...future.result <- base::tryCatch({
[09:31:34.748]         base::withCallingHandlers({
[09:31:34.748]             ...future.value <- base::withVisible(base::local({
[09:31:34.748]                 withCallingHandlers({
[09:31:34.748]                   {
[09:31:34.748]                     x <- 0
[09:31:34.748]                     x <- x + 1
[09:31:34.748]                     x
[09:31:34.748]                   }
[09:31:34.748]                 }, immediateCondition = function(cond) {
[09:31:34.748]                   save_rds <- function (object, pathname, ...) 
[09:31:34.748]                   {
[09:31:34.748]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.748]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.748]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.748]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.748]                         fi_tmp[["mtime"]])
[09:31:34.748]                     }
[09:31:34.748]                     tryCatch({
[09:31:34.748]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.748]                     }, error = function(ex) {
[09:31:34.748]                       msg <- conditionMessage(ex)
[09:31:34.748]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.748]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.748]                         fi_tmp[["mtime"]], msg)
[09:31:34.748]                       ex$message <- msg
[09:31:34.748]                       stop(ex)
[09:31:34.748]                     })
[09:31:34.748]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.748]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.748]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.748]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.748]                       fi <- file.info(pathname)
[09:31:34.748]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.748]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.748]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.748]                         fi[["size"]], fi[["mtime"]])
[09:31:34.748]                       stop(msg)
[09:31:34.748]                     }
[09:31:34.748]                     invisible(pathname)
[09:31:34.748]                   }
[09:31:34.748]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.748]                     rootPath = tempdir()) 
[09:31:34.748]                   {
[09:31:34.748]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.748]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.748]                       tmpdir = path, fileext = ".rds")
[09:31:34.748]                     save_rds(obj, file)
[09:31:34.748]                   }
[09:31:34.748]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.748]                   {
[09:31:34.748]                     inherits <- base::inherits
[09:31:34.748]                     invokeRestart <- base::invokeRestart
[09:31:34.748]                     is.null <- base::is.null
[09:31:34.748]                     muffled <- FALSE
[09:31:34.748]                     if (inherits(cond, "message")) {
[09:31:34.748]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.748]                       if (muffled) 
[09:31:34.748]                         invokeRestart("muffleMessage")
[09:31:34.748]                     }
[09:31:34.748]                     else if (inherits(cond, "warning")) {
[09:31:34.748]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.748]                       if (muffled) 
[09:31:34.748]                         invokeRestart("muffleWarning")
[09:31:34.748]                     }
[09:31:34.748]                     else if (inherits(cond, "condition")) {
[09:31:34.748]                       if (!is.null(pattern)) {
[09:31:34.748]                         computeRestarts <- base::computeRestarts
[09:31:34.748]                         grepl <- base::grepl
[09:31:34.748]                         restarts <- computeRestarts(cond)
[09:31:34.748]                         for (restart in restarts) {
[09:31:34.748]                           name <- restart$name
[09:31:34.748]                           if (is.null(name)) 
[09:31:34.748]                             next
[09:31:34.748]                           if (!grepl(pattern, name)) 
[09:31:34.748]                             next
[09:31:34.748]                           invokeRestart(restart)
[09:31:34.748]                           muffled <- TRUE
[09:31:34.748]                           break
[09:31:34.748]                         }
[09:31:34.748]                       }
[09:31:34.748]                     }
[09:31:34.748]                     invisible(muffled)
[09:31:34.748]                   }
[09:31:34.748]                   muffleCondition(cond)
[09:31:34.748]                 })
[09:31:34.748]             }))
[09:31:34.748]             future::FutureResult(value = ...future.value$value, 
[09:31:34.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.748]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.748]                     ...future.globalenv.names))
[09:31:34.748]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.748]         }, condition = base::local({
[09:31:34.748]             c <- base::c
[09:31:34.748]             inherits <- base::inherits
[09:31:34.748]             invokeRestart <- base::invokeRestart
[09:31:34.748]             length <- base::length
[09:31:34.748]             list <- base::list
[09:31:34.748]             seq.int <- base::seq.int
[09:31:34.748]             signalCondition <- base::signalCondition
[09:31:34.748]             sys.calls <- base::sys.calls
[09:31:34.748]             `[[` <- base::`[[`
[09:31:34.748]             `+` <- base::`+`
[09:31:34.748]             `<<-` <- base::`<<-`
[09:31:34.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.748]                   3L)]
[09:31:34.748]             }
[09:31:34.748]             function(cond) {
[09:31:34.748]                 is_error <- inherits(cond, "error")
[09:31:34.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.748]                   NULL)
[09:31:34.748]                 if (is_error) {
[09:31:34.748]                   sessionInformation <- function() {
[09:31:34.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.748]                       search = base::search(), system = base::Sys.info())
[09:31:34.748]                   }
[09:31:34.748]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.748]                     cond$call), session = sessionInformation(), 
[09:31:34.748]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.748]                   signalCondition(cond)
[09:31:34.748]                 }
[09:31:34.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.748]                 "immediateCondition"))) {
[09:31:34.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.748]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.748]                   if (TRUE && !signal) {
[09:31:34.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.748]                     {
[09:31:34.748]                       inherits <- base::inherits
[09:31:34.748]                       invokeRestart <- base::invokeRestart
[09:31:34.748]                       is.null <- base::is.null
[09:31:34.748]                       muffled <- FALSE
[09:31:34.748]                       if (inherits(cond, "message")) {
[09:31:34.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.748]                         if (muffled) 
[09:31:34.748]                           invokeRestart("muffleMessage")
[09:31:34.748]                       }
[09:31:34.748]                       else if (inherits(cond, "warning")) {
[09:31:34.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.748]                         if (muffled) 
[09:31:34.748]                           invokeRestart("muffleWarning")
[09:31:34.748]                       }
[09:31:34.748]                       else if (inherits(cond, "condition")) {
[09:31:34.748]                         if (!is.null(pattern)) {
[09:31:34.748]                           computeRestarts <- base::computeRestarts
[09:31:34.748]                           grepl <- base::grepl
[09:31:34.748]                           restarts <- computeRestarts(cond)
[09:31:34.748]                           for (restart in restarts) {
[09:31:34.748]                             name <- restart$name
[09:31:34.748]                             if (is.null(name)) 
[09:31:34.748]                               next
[09:31:34.748]                             if (!grepl(pattern, name)) 
[09:31:34.748]                               next
[09:31:34.748]                             invokeRestart(restart)
[09:31:34.748]                             muffled <- TRUE
[09:31:34.748]                             break
[09:31:34.748]                           }
[09:31:34.748]                         }
[09:31:34.748]                       }
[09:31:34.748]                       invisible(muffled)
[09:31:34.748]                     }
[09:31:34.748]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.748]                   }
[09:31:34.748]                 }
[09:31:34.748]                 else {
[09:31:34.748]                   if (TRUE) {
[09:31:34.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.748]                     {
[09:31:34.748]                       inherits <- base::inherits
[09:31:34.748]                       invokeRestart <- base::invokeRestart
[09:31:34.748]                       is.null <- base::is.null
[09:31:34.748]                       muffled <- FALSE
[09:31:34.748]                       if (inherits(cond, "message")) {
[09:31:34.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.748]                         if (muffled) 
[09:31:34.748]                           invokeRestart("muffleMessage")
[09:31:34.748]                       }
[09:31:34.748]                       else if (inherits(cond, "warning")) {
[09:31:34.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.748]                         if (muffled) 
[09:31:34.748]                           invokeRestart("muffleWarning")
[09:31:34.748]                       }
[09:31:34.748]                       else if (inherits(cond, "condition")) {
[09:31:34.748]                         if (!is.null(pattern)) {
[09:31:34.748]                           computeRestarts <- base::computeRestarts
[09:31:34.748]                           grepl <- base::grepl
[09:31:34.748]                           restarts <- computeRestarts(cond)
[09:31:34.748]                           for (restart in restarts) {
[09:31:34.748]                             name <- restart$name
[09:31:34.748]                             if (is.null(name)) 
[09:31:34.748]                               next
[09:31:34.748]                             if (!grepl(pattern, name)) 
[09:31:34.748]                               next
[09:31:34.748]                             invokeRestart(restart)
[09:31:34.748]                             muffled <- TRUE
[09:31:34.748]                             break
[09:31:34.748]                           }
[09:31:34.748]                         }
[09:31:34.748]                       }
[09:31:34.748]                       invisible(muffled)
[09:31:34.748]                     }
[09:31:34.748]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.748]                   }
[09:31:34.748]                 }
[09:31:34.748]             }
[09:31:34.748]         }))
[09:31:34.748]     }, error = function(ex) {
[09:31:34.748]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.748]                 ...future.rng), started = ...future.startTime, 
[09:31:34.748]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.748]             version = "1.8"), class = "FutureResult")
[09:31:34.748]     }, finally = {
[09:31:34.748]         if (!identical(...future.workdir, getwd())) 
[09:31:34.748]             setwd(...future.workdir)
[09:31:34.748]         {
[09:31:34.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.748]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.748]             }
[09:31:34.748]             base::options(...future.oldOptions)
[09:31:34.748]             if (.Platform$OS.type == "windows") {
[09:31:34.748]                 old_names <- names(...future.oldEnvVars)
[09:31:34.748]                 envs <- base::Sys.getenv()
[09:31:34.748]                 names <- names(envs)
[09:31:34.748]                 common <- intersect(names, old_names)
[09:31:34.748]                 added <- setdiff(names, old_names)
[09:31:34.748]                 removed <- setdiff(old_names, names)
[09:31:34.748]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.748]                   envs[common]]
[09:31:34.748]                 NAMES <- toupper(changed)
[09:31:34.748]                 args <- list()
[09:31:34.748]                 for (kk in seq_along(NAMES)) {
[09:31:34.748]                   name <- changed[[kk]]
[09:31:34.748]                   NAME <- NAMES[[kk]]
[09:31:34.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.748]                     next
[09:31:34.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.748]                 }
[09:31:34.748]                 NAMES <- toupper(added)
[09:31:34.748]                 for (kk in seq_along(NAMES)) {
[09:31:34.748]                   name <- added[[kk]]
[09:31:34.748]                   NAME <- NAMES[[kk]]
[09:31:34.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.748]                     next
[09:31:34.748]                   args[[name]] <- ""
[09:31:34.748]                 }
[09:31:34.748]                 NAMES <- toupper(removed)
[09:31:34.748]                 for (kk in seq_along(NAMES)) {
[09:31:34.748]                   name <- removed[[kk]]
[09:31:34.748]                   NAME <- NAMES[[kk]]
[09:31:34.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.748]                     next
[09:31:34.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.748]                 }
[09:31:34.748]                 if (length(args) > 0) 
[09:31:34.748]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.748]             }
[09:31:34.748]             else {
[09:31:34.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.748]             }
[09:31:34.748]             {
[09:31:34.748]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.748]                   0L) {
[09:31:34.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.748]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.748]                   base::options(opts)
[09:31:34.748]                 }
[09:31:34.748]                 {
[09:31:34.748]                   {
[09:31:34.748]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.748]                     NULL
[09:31:34.748]                   }
[09:31:34.748]                   options(future.plan = NULL)
[09:31:34.748]                   if (is.na(NA_character_)) 
[09:31:34.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.748]                     .init = FALSE)
[09:31:34.748]                 }
[09:31:34.748]             }
[09:31:34.748]         }
[09:31:34.748]     })
[09:31:34.748]     if (TRUE) {
[09:31:34.748]         base::sink(type = "output", split = FALSE)
[09:31:34.748]         if (TRUE) {
[09:31:34.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.748]         }
[09:31:34.748]         else {
[09:31:34.748]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.748]         }
[09:31:34.748]         base::close(...future.stdout)
[09:31:34.748]         ...future.stdout <- NULL
[09:31:34.748]     }
[09:31:34.748]     ...future.result$conditions <- ...future.conditions
[09:31:34.748]     ...future.result$finished <- base::Sys.time()
[09:31:34.748]     ...future.result
[09:31:34.748] }
[09:31:34.750] requestCore(): workers = 2
[09:31:34.752] MulticoreFuture started
[09:31:34.752] - Launch lazy future ... done
[09:31:34.753] plan(): Setting new future strategy stack:
[09:31:34.757] run() for ‘MulticoreFuture’ ... done
[09:31:34.757] result() for MulticoreFuture ...
[09:31:34.757] List of future strategies:
[09:31:34.757] 1. sequential:
[09:31:34.757]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.757]    - tweaked: FALSE
[09:31:34.757]    - call: NULL
[09:31:34.758] plan(): nbrOfWorkers() = 1
[09:31:34.760] plan(): Setting new future strategy stack:
[09:31:34.761] List of future strategies:
[09:31:34.761] 1. multicore:
[09:31:34.761]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.761]    - tweaked: FALSE
[09:31:34.761]    - call: plan(strategy)
[09:31:34.766] plan(): nbrOfWorkers() = 2
[09:31:34.766] result() for MulticoreFuture ...
[09:31:34.767] result() for MulticoreFuture ... done
[09:31:34.767] result() for MulticoreFuture ... done
[09:31:34.767] result() for MulticoreFuture ...
[09:31:34.767] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.768] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.768] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.771] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:34.771] Searching for globals ... DONE
[09:31:34.771] Resolving globals: TRUE
[09:31:34.771] Resolving any globals that are futures ...
[09:31:34.771] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:34.771] Resolving any globals that are futures ... DONE
[09:31:34.772] Resolving futures part of globals (recursively) ...
[09:31:34.773] resolve() on list ...
[09:31:34.773]  recursive: 99
[09:31:34.773]  length: 1
[09:31:34.773]  elements: ‘x’
[09:31:34.773]  length: 0 (resolved future 1)
[09:31:34.773] resolve() on list ... DONE
[09:31:34.773] - globals: [1] ‘x’
[09:31:34.774] Resolving futures part of globals (recursively) ... DONE
[09:31:34.774] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:34.774] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[09:31:34.775] - globals: [1] ‘x’
[09:31:34.775] 
[09:31:34.775] getGlobalsAndPackages() ... DONE
[09:31:34.775] run() for ‘Future’ ...
[09:31:34.775] - state: ‘created’
[09:31:34.775] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.779] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.780]   - Field: ‘label’
[09:31:34.780]   - Field: ‘local’
[09:31:34.780]   - Field: ‘owner’
[09:31:34.780]   - Field: ‘envir’
[09:31:34.780]   - Field: ‘workers’
[09:31:34.780]   - Field: ‘packages’
[09:31:34.780]   - Field: ‘gc’
[09:31:34.780]   - Field: ‘job’
[09:31:34.780]   - Field: ‘conditions’
[09:31:34.781]   - Field: ‘expr’
[09:31:34.781]   - Field: ‘uuid’
[09:31:34.781]   - Field: ‘seed’
[09:31:34.781]   - Field: ‘version’
[09:31:34.781]   - Field: ‘result’
[09:31:34.781]   - Field: ‘asynchronous’
[09:31:34.781]   - Field: ‘calls’
[09:31:34.781]   - Field: ‘globals’
[09:31:34.781]   - Field: ‘stdout’
[09:31:34.782]   - Field: ‘earlySignal’
[09:31:34.782]   - Field: ‘lazy’
[09:31:34.782]   - Field: ‘state’
[09:31:34.782] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.782] - Launch lazy future ...
[09:31:34.782] Packages needed by the future expression (n = 0): <none>
[09:31:34.782] Packages needed by future strategies (n = 0): <none>
[09:31:34.783] {
[09:31:34.783]     {
[09:31:34.783]         {
[09:31:34.783]             ...future.startTime <- base::Sys.time()
[09:31:34.783]             {
[09:31:34.783]                 {
[09:31:34.783]                   {
[09:31:34.783]                     {
[09:31:34.783]                       base::local({
[09:31:34.783]                         has_future <- base::requireNamespace("future", 
[09:31:34.783]                           quietly = TRUE)
[09:31:34.783]                         if (has_future) {
[09:31:34.783]                           ns <- base::getNamespace("future")
[09:31:34.783]                           version <- ns[[".package"]][["version"]]
[09:31:34.783]                           if (is.null(version)) 
[09:31:34.783]                             version <- utils::packageVersion("future")
[09:31:34.783]                         }
[09:31:34.783]                         else {
[09:31:34.783]                           version <- NULL
[09:31:34.783]                         }
[09:31:34.783]                         if (!has_future || version < "1.8.0") {
[09:31:34.783]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.783]                             "", base::R.version$version.string), 
[09:31:34.783]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.783]                               "release", "version")], collapse = " "), 
[09:31:34.783]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.783]                             info)
[09:31:34.783]                           info <- base::paste(info, collapse = "; ")
[09:31:34.783]                           if (!has_future) {
[09:31:34.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.783]                               info)
[09:31:34.783]                           }
[09:31:34.783]                           else {
[09:31:34.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.783]                               info, version)
[09:31:34.783]                           }
[09:31:34.783]                           base::stop(msg)
[09:31:34.783]                         }
[09:31:34.783]                       })
[09:31:34.783]                     }
[09:31:34.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.783]                     base::options(mc.cores = 1L)
[09:31:34.783]                   }
[09:31:34.783]                   ...future.strategy.old <- future::plan("list")
[09:31:34.783]                   options(future.plan = NULL)
[09:31:34.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.783]                 }
[09:31:34.783]                 ...future.workdir <- getwd()
[09:31:34.783]             }
[09:31:34.783]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.783]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.783]         }
[09:31:34.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.783]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.783]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.783]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.783]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.783]             base::names(...future.oldOptions))
[09:31:34.783]     }
[09:31:34.783]     if (FALSE) {
[09:31:34.783]     }
[09:31:34.783]     else {
[09:31:34.783]         if (TRUE) {
[09:31:34.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.783]                 open = "w")
[09:31:34.783]         }
[09:31:34.783]         else {
[09:31:34.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.783]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.783]         }
[09:31:34.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.783]             base::sink(type = "output", split = FALSE)
[09:31:34.783]             base::close(...future.stdout)
[09:31:34.783]         }, add = TRUE)
[09:31:34.783]     }
[09:31:34.783]     ...future.frame <- base::sys.nframe()
[09:31:34.783]     ...future.conditions <- base::list()
[09:31:34.783]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.783]     if (FALSE) {
[09:31:34.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.783]     }
[09:31:34.783]     ...future.result <- base::tryCatch({
[09:31:34.783]         base::withCallingHandlers({
[09:31:34.783]             ...future.value <- base::withVisible(base::local({
[09:31:34.783]                 withCallingHandlers({
[09:31:34.783]                   {
[09:31:34.783]                     x <- x + 1
[09:31:34.783]                     x
[09:31:34.783]                   }
[09:31:34.783]                 }, immediateCondition = function(cond) {
[09:31:34.783]                   save_rds <- function (object, pathname, ...) 
[09:31:34.783]                   {
[09:31:34.783]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.783]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.783]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.783]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.783]                         fi_tmp[["mtime"]])
[09:31:34.783]                     }
[09:31:34.783]                     tryCatch({
[09:31:34.783]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.783]                     }, error = function(ex) {
[09:31:34.783]                       msg <- conditionMessage(ex)
[09:31:34.783]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.783]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.783]                         fi_tmp[["mtime"]], msg)
[09:31:34.783]                       ex$message <- msg
[09:31:34.783]                       stop(ex)
[09:31:34.783]                     })
[09:31:34.783]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.783]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.783]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.783]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.783]                       fi <- file.info(pathname)
[09:31:34.783]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.783]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.783]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.783]                         fi[["size"]], fi[["mtime"]])
[09:31:34.783]                       stop(msg)
[09:31:34.783]                     }
[09:31:34.783]                     invisible(pathname)
[09:31:34.783]                   }
[09:31:34.783]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.783]                     rootPath = tempdir()) 
[09:31:34.783]                   {
[09:31:34.783]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.783]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.783]                       tmpdir = path, fileext = ".rds")
[09:31:34.783]                     save_rds(obj, file)
[09:31:34.783]                   }
[09:31:34.783]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.783]                   {
[09:31:34.783]                     inherits <- base::inherits
[09:31:34.783]                     invokeRestart <- base::invokeRestart
[09:31:34.783]                     is.null <- base::is.null
[09:31:34.783]                     muffled <- FALSE
[09:31:34.783]                     if (inherits(cond, "message")) {
[09:31:34.783]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.783]                       if (muffled) 
[09:31:34.783]                         invokeRestart("muffleMessage")
[09:31:34.783]                     }
[09:31:34.783]                     else if (inherits(cond, "warning")) {
[09:31:34.783]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.783]                       if (muffled) 
[09:31:34.783]                         invokeRestart("muffleWarning")
[09:31:34.783]                     }
[09:31:34.783]                     else if (inherits(cond, "condition")) {
[09:31:34.783]                       if (!is.null(pattern)) {
[09:31:34.783]                         computeRestarts <- base::computeRestarts
[09:31:34.783]                         grepl <- base::grepl
[09:31:34.783]                         restarts <- computeRestarts(cond)
[09:31:34.783]                         for (restart in restarts) {
[09:31:34.783]                           name <- restart$name
[09:31:34.783]                           if (is.null(name)) 
[09:31:34.783]                             next
[09:31:34.783]                           if (!grepl(pattern, name)) 
[09:31:34.783]                             next
[09:31:34.783]                           invokeRestart(restart)
[09:31:34.783]                           muffled <- TRUE
[09:31:34.783]                           break
[09:31:34.783]                         }
[09:31:34.783]                       }
[09:31:34.783]                     }
[09:31:34.783]                     invisible(muffled)
[09:31:34.783]                   }
[09:31:34.783]                   muffleCondition(cond)
[09:31:34.783]                 })
[09:31:34.783]             }))
[09:31:34.783]             future::FutureResult(value = ...future.value$value, 
[09:31:34.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.783]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.783]                     ...future.globalenv.names))
[09:31:34.783]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.783]         }, condition = base::local({
[09:31:34.783]             c <- base::c
[09:31:34.783]             inherits <- base::inherits
[09:31:34.783]             invokeRestart <- base::invokeRestart
[09:31:34.783]             length <- base::length
[09:31:34.783]             list <- base::list
[09:31:34.783]             seq.int <- base::seq.int
[09:31:34.783]             signalCondition <- base::signalCondition
[09:31:34.783]             sys.calls <- base::sys.calls
[09:31:34.783]             `[[` <- base::`[[`
[09:31:34.783]             `+` <- base::`+`
[09:31:34.783]             `<<-` <- base::`<<-`
[09:31:34.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.783]                   3L)]
[09:31:34.783]             }
[09:31:34.783]             function(cond) {
[09:31:34.783]                 is_error <- inherits(cond, "error")
[09:31:34.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.783]                   NULL)
[09:31:34.783]                 if (is_error) {
[09:31:34.783]                   sessionInformation <- function() {
[09:31:34.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.783]                       search = base::search(), system = base::Sys.info())
[09:31:34.783]                   }
[09:31:34.783]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.783]                     cond$call), session = sessionInformation(), 
[09:31:34.783]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.783]                   signalCondition(cond)
[09:31:34.783]                 }
[09:31:34.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.783]                 "immediateCondition"))) {
[09:31:34.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.783]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.783]                   if (TRUE && !signal) {
[09:31:34.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.783]                     {
[09:31:34.783]                       inherits <- base::inherits
[09:31:34.783]                       invokeRestart <- base::invokeRestart
[09:31:34.783]                       is.null <- base::is.null
[09:31:34.783]                       muffled <- FALSE
[09:31:34.783]                       if (inherits(cond, "message")) {
[09:31:34.783]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.783]                         if (muffled) 
[09:31:34.783]                           invokeRestart("muffleMessage")
[09:31:34.783]                       }
[09:31:34.783]                       else if (inherits(cond, "warning")) {
[09:31:34.783]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.783]                         if (muffled) 
[09:31:34.783]                           invokeRestart("muffleWarning")
[09:31:34.783]                       }
[09:31:34.783]                       else if (inherits(cond, "condition")) {
[09:31:34.783]                         if (!is.null(pattern)) {
[09:31:34.783]                           computeRestarts <- base::computeRestarts
[09:31:34.783]                           grepl <- base::grepl
[09:31:34.783]                           restarts <- computeRestarts(cond)
[09:31:34.783]                           for (restart in restarts) {
[09:31:34.783]                             name <- restart$name
[09:31:34.783]                             if (is.null(name)) 
[09:31:34.783]                               next
[09:31:34.783]                             if (!grepl(pattern, name)) 
[09:31:34.783]                               next
[09:31:34.783]                             invokeRestart(restart)
[09:31:34.783]                             muffled <- TRUE
[09:31:34.783]                             break
[09:31:34.783]                           }
[09:31:34.783]                         }
[09:31:34.783]                       }
[09:31:34.783]                       invisible(muffled)
[09:31:34.783]                     }
[09:31:34.783]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.783]                   }
[09:31:34.783]                 }
[09:31:34.783]                 else {
[09:31:34.783]                   if (TRUE) {
[09:31:34.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.783]                     {
[09:31:34.783]                       inherits <- base::inherits
[09:31:34.783]                       invokeRestart <- base::invokeRestart
[09:31:34.783]                       is.null <- base::is.null
[09:31:34.783]                       muffled <- FALSE
[09:31:34.783]                       if (inherits(cond, "message")) {
[09:31:34.783]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.783]                         if (muffled) 
[09:31:34.783]                           invokeRestart("muffleMessage")
[09:31:34.783]                       }
[09:31:34.783]                       else if (inherits(cond, "warning")) {
[09:31:34.783]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.783]                         if (muffled) 
[09:31:34.783]                           invokeRestart("muffleWarning")
[09:31:34.783]                       }
[09:31:34.783]                       else if (inherits(cond, "condition")) {
[09:31:34.783]                         if (!is.null(pattern)) {
[09:31:34.783]                           computeRestarts <- base::computeRestarts
[09:31:34.783]                           grepl <- base::grepl
[09:31:34.783]                           restarts <- computeRestarts(cond)
[09:31:34.783]                           for (restart in restarts) {
[09:31:34.783]                             name <- restart$name
[09:31:34.783]                             if (is.null(name)) 
[09:31:34.783]                               next
[09:31:34.783]                             if (!grepl(pattern, name)) 
[09:31:34.783]                               next
[09:31:34.783]                             invokeRestart(restart)
[09:31:34.783]                             muffled <- TRUE
[09:31:34.783]                             break
[09:31:34.783]                           }
[09:31:34.783]                         }
[09:31:34.783]                       }
[09:31:34.783]                       invisible(muffled)
[09:31:34.783]                     }
[09:31:34.783]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.783]                   }
[09:31:34.783]                 }
[09:31:34.783]             }
[09:31:34.783]         }))
[09:31:34.783]     }, error = function(ex) {
[09:31:34.783]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.783]                 ...future.rng), started = ...future.startTime, 
[09:31:34.783]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.783]             version = "1.8"), class = "FutureResult")
[09:31:34.783]     }, finally = {
[09:31:34.783]         if (!identical(...future.workdir, getwd())) 
[09:31:34.783]             setwd(...future.workdir)
[09:31:34.783]         {
[09:31:34.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.783]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.783]             }
[09:31:34.783]             base::options(...future.oldOptions)
[09:31:34.783]             if (.Platform$OS.type == "windows") {
[09:31:34.783]                 old_names <- names(...future.oldEnvVars)
[09:31:34.783]                 envs <- base::Sys.getenv()
[09:31:34.783]                 names <- names(envs)
[09:31:34.783]                 common <- intersect(names, old_names)
[09:31:34.783]                 added <- setdiff(names, old_names)
[09:31:34.783]                 removed <- setdiff(old_names, names)
[09:31:34.783]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.783]                   envs[common]]
[09:31:34.783]                 NAMES <- toupper(changed)
[09:31:34.783]                 args <- list()
[09:31:34.783]                 for (kk in seq_along(NAMES)) {
[09:31:34.783]                   name <- changed[[kk]]
[09:31:34.783]                   NAME <- NAMES[[kk]]
[09:31:34.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.783]                     next
[09:31:34.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.783]                 }
[09:31:34.783]                 NAMES <- toupper(added)
[09:31:34.783]                 for (kk in seq_along(NAMES)) {
[09:31:34.783]                   name <- added[[kk]]
[09:31:34.783]                   NAME <- NAMES[[kk]]
[09:31:34.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.783]                     next
[09:31:34.783]                   args[[name]] <- ""
[09:31:34.783]                 }
[09:31:34.783]                 NAMES <- toupper(removed)
[09:31:34.783]                 for (kk in seq_along(NAMES)) {
[09:31:34.783]                   name <- removed[[kk]]
[09:31:34.783]                   NAME <- NAMES[[kk]]
[09:31:34.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.783]                     next
[09:31:34.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.783]                 }
[09:31:34.783]                 if (length(args) > 0) 
[09:31:34.783]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.783]             }
[09:31:34.783]             else {
[09:31:34.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.783]             }
[09:31:34.783]             {
[09:31:34.783]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.783]                   0L) {
[09:31:34.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.783]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.783]                   base::options(opts)
[09:31:34.783]                 }
[09:31:34.783]                 {
[09:31:34.783]                   {
[09:31:34.783]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.783]                     NULL
[09:31:34.783]                   }
[09:31:34.783]                   options(future.plan = NULL)
[09:31:34.783]                   if (is.na(NA_character_)) 
[09:31:34.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.783]                     .init = FALSE)
[09:31:34.783]                 }
[09:31:34.783]             }
[09:31:34.783]         }
[09:31:34.783]     })
[09:31:34.783]     if (TRUE) {
[09:31:34.783]         base::sink(type = "output", split = FALSE)
[09:31:34.783]         if (TRUE) {
[09:31:34.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.783]         }
[09:31:34.783]         else {
[09:31:34.783]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.783]         }
[09:31:34.783]         base::close(...future.stdout)
[09:31:34.783]         ...future.stdout <- NULL
[09:31:34.783]     }
[09:31:34.783]     ...future.result$conditions <- ...future.conditions
[09:31:34.783]     ...future.result$finished <- base::Sys.time()
[09:31:34.783]     ...future.result
[09:31:34.783] }
[09:31:34.785] assign_globals() ...
[09:31:34.785] List of 1
[09:31:34.785]  $ x: num 1
[09:31:34.785]  - attr(*, "where")=List of 1
[09:31:34.785]   ..$ x:<environment: R_EmptyEnv> 
[09:31:34.785]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.785]  - attr(*, "resolved")= logi TRUE
[09:31:34.785]  - attr(*, "total_size")= num 56
[09:31:34.785]  - attr(*, "already-done")= logi TRUE
[09:31:34.788] - copied ‘x’ to environment
[09:31:34.788] assign_globals() ... done
[09:31:34.788] requestCore(): workers = 2
[09:31:34.790] MulticoreFuture started
[09:31:34.791] - Launch lazy future ... done
[09:31:34.791] run() for ‘MulticoreFuture’ ... done
[09:31:34.791] result() for MulticoreFuture ...
[09:31:34.791] plan(): Setting new future strategy stack:
[09:31:34.792] List of future strategies:
[09:31:34.792] 1. sequential:
[09:31:34.792]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.792]    - tweaked: FALSE
[09:31:34.792]    - call: NULL
[09:31:34.793] plan(): nbrOfWorkers() = 1
[09:31:34.795] plan(): Setting new future strategy stack:
[09:31:34.795] List of future strategies:
[09:31:34.795] 1. multicore:
[09:31:34.795]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.795]    - tweaked: FALSE
[09:31:34.795]    - call: plan(strategy)
[09:31:34.800] plan(): nbrOfWorkers() = 2
[09:31:34.801] result() for MulticoreFuture ...
[09:31:34.801] result() for MulticoreFuture ... done
[09:31:34.801] result() for MulticoreFuture ... done
[09:31:34.801] result() for MulticoreFuture ...
[09:31:34.801] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.802] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.802] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:34.805] - globals found: [3] ‘{’, ‘<-’, ‘x’
[09:31:34.805] Searching for globals ... DONE
[09:31:34.805] Resolving globals: TRUE
[09:31:34.805] Resolving any globals that are futures ...
[09:31:34.805] - globals: [3] ‘{’, ‘<-’, ‘x’
[09:31:34.805] Resolving any globals that are futures ... DONE
[09:31:34.806] Resolving futures part of globals (recursively) ...
[09:31:34.806] resolve() on list ...
[09:31:34.806]  recursive: 99
[09:31:34.806]  length: 1
[09:31:34.807]  elements: ‘x’
[09:31:34.807]  length: 0 (resolved future 1)
[09:31:34.807] resolve() on list ... DONE
[09:31:34.807] - globals: [1] ‘x’
[09:31:34.807] Resolving futures part of globals (recursively) ... DONE
[09:31:34.807] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[09:31:34.808] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[09:31:34.808] - globals: [1] ‘x’
[09:31:34.808] 
[09:31:34.808] getGlobalsAndPackages() ... DONE
[09:31:34.809] run() for ‘Future’ ...
[09:31:34.809] - state: ‘created’
[09:31:34.809] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:31:34.813] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:34.813] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:31:34.813]   - Field: ‘label’
[09:31:34.813]   - Field: ‘local’
[09:31:34.813]   - Field: ‘owner’
[09:31:34.814]   - Field: ‘envir’
[09:31:34.814]   - Field: ‘workers’
[09:31:34.814]   - Field: ‘packages’
[09:31:34.816]   - Field: ‘gc’
[09:31:34.817]   - Field: ‘job’
[09:31:34.817]   - Field: ‘conditions’
[09:31:34.817]   - Field: ‘expr’
[09:31:34.817]   - Field: ‘uuid’
[09:31:34.817]   - Field: ‘seed’
[09:31:34.817]   - Field: ‘version’
[09:31:34.817]   - Field: ‘result’
[09:31:34.818]   - Field: ‘asynchronous’
[09:31:34.818]   - Field: ‘calls’
[09:31:34.818]   - Field: ‘globals’
[09:31:34.818]   - Field: ‘stdout’
[09:31:34.818]   - Field: ‘earlySignal’
[09:31:34.818]   - Field: ‘lazy’
[09:31:34.818]   - Field: ‘state’
[09:31:34.818] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:31:34.818] - Launch lazy future ...
[09:31:34.819] Packages needed by the future expression (n = 0): <none>
[09:31:34.819] Packages needed by future strategies (n = 0): <none>
[09:31:34.819] {
[09:31:34.819]     {
[09:31:34.819]         {
[09:31:34.819]             ...future.startTime <- base::Sys.time()
[09:31:34.819]             {
[09:31:34.819]                 {
[09:31:34.819]                   {
[09:31:34.819]                     {
[09:31:34.819]                       base::local({
[09:31:34.819]                         has_future <- base::requireNamespace("future", 
[09:31:34.819]                           quietly = TRUE)
[09:31:34.819]                         if (has_future) {
[09:31:34.819]                           ns <- base::getNamespace("future")
[09:31:34.819]                           version <- ns[[".package"]][["version"]]
[09:31:34.819]                           if (is.null(version)) 
[09:31:34.819]                             version <- utils::packageVersion("future")
[09:31:34.819]                         }
[09:31:34.819]                         else {
[09:31:34.819]                           version <- NULL
[09:31:34.819]                         }
[09:31:34.819]                         if (!has_future || version < "1.8.0") {
[09:31:34.819]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:34.819]                             "", base::R.version$version.string), 
[09:31:34.819]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:34.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:34.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:34.819]                               "release", "version")], collapse = " "), 
[09:31:34.819]                             hostname = base::Sys.info()[["nodename"]])
[09:31:34.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:34.819]                             info)
[09:31:34.819]                           info <- base::paste(info, collapse = "; ")
[09:31:34.819]                           if (!has_future) {
[09:31:34.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:34.819]                               info)
[09:31:34.819]                           }
[09:31:34.819]                           else {
[09:31:34.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:34.819]                               info, version)
[09:31:34.819]                           }
[09:31:34.819]                           base::stop(msg)
[09:31:34.819]                         }
[09:31:34.819]                       })
[09:31:34.819]                     }
[09:31:34.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:34.819]                     base::options(mc.cores = 1L)
[09:31:34.819]                   }
[09:31:34.819]                   ...future.strategy.old <- future::plan("list")
[09:31:34.819]                   options(future.plan = NULL)
[09:31:34.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:34.819]                 }
[09:31:34.819]                 ...future.workdir <- getwd()
[09:31:34.819]             }
[09:31:34.819]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:34.819]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:34.819]         }
[09:31:34.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:34.819]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:34.819]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:34.819]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:34.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:34.819]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:34.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:34.819]             base::names(...future.oldOptions))
[09:31:34.819]     }
[09:31:34.819]     if (FALSE) {
[09:31:34.819]     }
[09:31:34.819]     else {
[09:31:34.819]         if (TRUE) {
[09:31:34.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:34.819]                 open = "w")
[09:31:34.819]         }
[09:31:34.819]         else {
[09:31:34.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:34.819]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:34.819]         }
[09:31:34.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:34.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:34.819]             base::sink(type = "output", split = FALSE)
[09:31:34.819]             base::close(...future.stdout)
[09:31:34.819]         }, add = TRUE)
[09:31:34.819]     }
[09:31:34.819]     ...future.frame <- base::sys.nframe()
[09:31:34.819]     ...future.conditions <- base::list()
[09:31:34.819]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:34.819]     if (FALSE) {
[09:31:34.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:34.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:34.819]     }
[09:31:34.819]     ...future.result <- base::tryCatch({
[09:31:34.819]         base::withCallingHandlers({
[09:31:34.819]             ...future.value <- base::withVisible(base::local({
[09:31:34.819]                 withCallingHandlers({
[09:31:34.819]                   {
[09:31:34.819]                     x <- x()
[09:31:34.819]                     x
[09:31:34.819]                   }
[09:31:34.819]                 }, immediateCondition = function(cond) {
[09:31:34.819]                   save_rds <- function (object, pathname, ...) 
[09:31:34.819]                   {
[09:31:34.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:31:34.819]                     if (file_test("-f", pathname_tmp)) {
[09:31:34.819]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:31:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.819]                         fi_tmp[["mtime"]])
[09:31:34.819]                     }
[09:31:34.819]                     tryCatch({
[09:31:34.819]                       saveRDS(object, file = pathname_tmp, ...)
[09:31:34.819]                     }, error = function(ex) {
[09:31:34.819]                       msg <- conditionMessage(ex)
[09:31:34.819]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:31:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.819]                         fi_tmp[["mtime"]], msg)
[09:31:34.819]                       ex$message <- msg
[09:31:34.819]                       stop(ex)
[09:31:34.819]                     })
[09:31:34.819]                     stopifnot(file_test("-f", pathname_tmp))
[09:31:34.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:31:34.819]                     if (!res || file_test("-f", pathname_tmp)) {
[09:31:34.819]                       fi_tmp <- file.info(pathname_tmp)
[09:31:34.819]                       fi <- file.info(pathname)
[09:31:34.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:31:34.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:31:34.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:31:34.819]                         fi[["size"]], fi[["mtime"]])
[09:31:34.819]                       stop(msg)
[09:31:34.819]                     }
[09:31:34.819]                     invisible(pathname)
[09:31:34.819]                   }
[09:31:34.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:31:34.819]                     rootPath = tempdir()) 
[09:31:34.819]                   {
[09:31:34.819]                     obj <- list(time = Sys.time(), condition = cond)
[09:31:34.819]                     file <- tempfile(pattern = class(cond)[1], 
[09:31:34.819]                       tmpdir = path, fileext = ".rds")
[09:31:34.819]                     save_rds(obj, file)
[09:31:34.819]                   }
[09:31:34.819]                   saveImmediateCondition(cond, path = "/tmp/Rtmp8pv5D7/.future/immediateConditions")
[09:31:34.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.819]                   {
[09:31:34.819]                     inherits <- base::inherits
[09:31:34.819]                     invokeRestart <- base::invokeRestart
[09:31:34.819]                     is.null <- base::is.null
[09:31:34.819]                     muffled <- FALSE
[09:31:34.819]                     if (inherits(cond, "message")) {
[09:31:34.819]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:34.819]                       if (muffled) 
[09:31:34.819]                         invokeRestart("muffleMessage")
[09:31:34.819]                     }
[09:31:34.819]                     else if (inherits(cond, "warning")) {
[09:31:34.819]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:34.819]                       if (muffled) 
[09:31:34.819]                         invokeRestart("muffleWarning")
[09:31:34.819]                     }
[09:31:34.819]                     else if (inherits(cond, "condition")) {
[09:31:34.819]                       if (!is.null(pattern)) {
[09:31:34.819]                         computeRestarts <- base::computeRestarts
[09:31:34.819]                         grepl <- base::grepl
[09:31:34.819]                         restarts <- computeRestarts(cond)
[09:31:34.819]                         for (restart in restarts) {
[09:31:34.819]                           name <- restart$name
[09:31:34.819]                           if (is.null(name)) 
[09:31:34.819]                             next
[09:31:34.819]                           if (!grepl(pattern, name)) 
[09:31:34.819]                             next
[09:31:34.819]                           invokeRestart(restart)
[09:31:34.819]                           muffled <- TRUE
[09:31:34.819]                           break
[09:31:34.819]                         }
[09:31:34.819]                       }
[09:31:34.819]                     }
[09:31:34.819]                     invisible(muffled)
[09:31:34.819]                   }
[09:31:34.819]                   muffleCondition(cond)
[09:31:34.819]                 })
[09:31:34.819]             }))
[09:31:34.819]             future::FutureResult(value = ...future.value$value, 
[09:31:34.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.819]                   ...future.rng), globalenv = if (FALSE) 
[09:31:34.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:34.819]                     ...future.globalenv.names))
[09:31:34.819]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:34.819]         }, condition = base::local({
[09:31:34.819]             c <- base::c
[09:31:34.819]             inherits <- base::inherits
[09:31:34.819]             invokeRestart <- base::invokeRestart
[09:31:34.819]             length <- base::length
[09:31:34.819]             list <- base::list
[09:31:34.819]             seq.int <- base::seq.int
[09:31:34.819]             signalCondition <- base::signalCondition
[09:31:34.819]             sys.calls <- base::sys.calls
[09:31:34.819]             `[[` <- base::`[[`
[09:31:34.819]             `+` <- base::`+`
[09:31:34.819]             `<<-` <- base::`<<-`
[09:31:34.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:34.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:34.819]                   3L)]
[09:31:34.819]             }
[09:31:34.819]             function(cond) {
[09:31:34.819]                 is_error <- inherits(cond, "error")
[09:31:34.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:34.819]                   NULL)
[09:31:34.819]                 if (is_error) {
[09:31:34.819]                   sessionInformation <- function() {
[09:31:34.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:34.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:34.819]                       search = base::search(), system = base::Sys.info())
[09:31:34.819]                   }
[09:31:34.819]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:34.819]                     cond$call), session = sessionInformation(), 
[09:31:34.819]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:34.819]                   signalCondition(cond)
[09:31:34.819]                 }
[09:31:34.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:34.819]                 "immediateCondition"))) {
[09:31:34.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:34.819]                   ...future.conditions[[length(...future.conditions) + 
[09:31:34.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:34.819]                   if (TRUE && !signal) {
[09:31:34.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.819]                     {
[09:31:34.819]                       inherits <- base::inherits
[09:31:34.819]                       invokeRestart <- base::invokeRestart
[09:31:34.819]                       is.null <- base::is.null
[09:31:34.819]                       muffled <- FALSE
[09:31:34.819]                       if (inherits(cond, "message")) {
[09:31:34.819]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.819]                         if (muffled) 
[09:31:34.819]                           invokeRestart("muffleMessage")
[09:31:34.819]                       }
[09:31:34.819]                       else if (inherits(cond, "warning")) {
[09:31:34.819]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.819]                         if (muffled) 
[09:31:34.819]                           invokeRestart("muffleWarning")
[09:31:34.819]                       }
[09:31:34.819]                       else if (inherits(cond, "condition")) {
[09:31:34.819]                         if (!is.null(pattern)) {
[09:31:34.819]                           computeRestarts <- base::computeRestarts
[09:31:34.819]                           grepl <- base::grepl
[09:31:34.819]                           restarts <- computeRestarts(cond)
[09:31:34.819]                           for (restart in restarts) {
[09:31:34.819]                             name <- restart$name
[09:31:34.819]                             if (is.null(name)) 
[09:31:34.819]                               next
[09:31:34.819]                             if (!grepl(pattern, name)) 
[09:31:34.819]                               next
[09:31:34.819]                             invokeRestart(restart)
[09:31:34.819]                             muffled <- TRUE
[09:31:34.819]                             break
[09:31:34.819]                           }
[09:31:34.819]                         }
[09:31:34.819]                       }
[09:31:34.819]                       invisible(muffled)
[09:31:34.819]                     }
[09:31:34.819]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.819]                   }
[09:31:34.819]                 }
[09:31:34.819]                 else {
[09:31:34.819]                   if (TRUE) {
[09:31:34.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:34.819]                     {
[09:31:34.819]                       inherits <- base::inherits
[09:31:34.819]                       invokeRestart <- base::invokeRestart
[09:31:34.819]                       is.null <- base::is.null
[09:31:34.819]                       muffled <- FALSE
[09:31:34.819]                       if (inherits(cond, "message")) {
[09:31:34.819]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:34.819]                         if (muffled) 
[09:31:34.819]                           invokeRestart("muffleMessage")
[09:31:34.819]                       }
[09:31:34.819]                       else if (inherits(cond, "warning")) {
[09:31:34.819]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:34.819]                         if (muffled) 
[09:31:34.819]                           invokeRestart("muffleWarning")
[09:31:34.819]                       }
[09:31:34.819]                       else if (inherits(cond, "condition")) {
[09:31:34.819]                         if (!is.null(pattern)) {
[09:31:34.819]                           computeRestarts <- base::computeRestarts
[09:31:34.819]                           grepl <- base::grepl
[09:31:34.819]                           restarts <- computeRestarts(cond)
[09:31:34.819]                           for (restart in restarts) {
[09:31:34.819]                             name <- restart$name
[09:31:34.819]                             if (is.null(name)) 
[09:31:34.819]                               next
[09:31:34.819]                             if (!grepl(pattern, name)) 
[09:31:34.819]                               next
[09:31:34.819]                             invokeRestart(restart)
[09:31:34.819]                             muffled <- TRUE
[09:31:34.819]                             break
[09:31:34.819]                           }
[09:31:34.819]                         }
[09:31:34.819]                       }
[09:31:34.819]                       invisible(muffled)
[09:31:34.819]                     }
[09:31:34.819]                     muffleCondition(cond, pattern = "^muffle")
[09:31:34.819]                   }
[09:31:34.819]                 }
[09:31:34.819]             }
[09:31:34.819]         }))
[09:31:34.819]     }, error = function(ex) {
[09:31:34.819]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:34.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:34.819]                 ...future.rng), started = ...future.startTime, 
[09:31:34.819]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:34.819]             version = "1.8"), class = "FutureResult")
[09:31:34.819]     }, finally = {
[09:31:34.819]         if (!identical(...future.workdir, getwd())) 
[09:31:34.819]             setwd(...future.workdir)
[09:31:34.819]         {
[09:31:34.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:34.819]                 ...future.oldOptions$nwarnings <- NULL
[09:31:34.819]             }
[09:31:34.819]             base::options(...future.oldOptions)
[09:31:34.819]             if (.Platform$OS.type == "windows") {
[09:31:34.819]                 old_names <- names(...future.oldEnvVars)
[09:31:34.819]                 envs <- base::Sys.getenv()
[09:31:34.819]                 names <- names(envs)
[09:31:34.819]                 common <- intersect(names, old_names)
[09:31:34.819]                 added <- setdiff(names, old_names)
[09:31:34.819]                 removed <- setdiff(old_names, names)
[09:31:34.819]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:34.819]                   envs[common]]
[09:31:34.819]                 NAMES <- toupper(changed)
[09:31:34.819]                 args <- list()
[09:31:34.819]                 for (kk in seq_along(NAMES)) {
[09:31:34.819]                   name <- changed[[kk]]
[09:31:34.819]                   NAME <- NAMES[[kk]]
[09:31:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.819]                     next
[09:31:34.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.819]                 }
[09:31:34.819]                 NAMES <- toupper(added)
[09:31:34.819]                 for (kk in seq_along(NAMES)) {
[09:31:34.819]                   name <- added[[kk]]
[09:31:34.819]                   NAME <- NAMES[[kk]]
[09:31:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.819]                     next
[09:31:34.819]                   args[[name]] <- ""
[09:31:34.819]                 }
[09:31:34.819]                 NAMES <- toupper(removed)
[09:31:34.819]                 for (kk in seq_along(NAMES)) {
[09:31:34.819]                   name <- removed[[kk]]
[09:31:34.819]                   NAME <- NAMES[[kk]]
[09:31:34.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:34.819]                     next
[09:31:34.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:34.819]                 }
[09:31:34.819]                 if (length(args) > 0) 
[09:31:34.819]                   base::do.call(base::Sys.setenv, args = args)
[09:31:34.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:34.819]             }
[09:31:34.819]             else {
[09:31:34.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:34.819]             }
[09:31:34.819]             {
[09:31:34.819]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:34.819]                   0L) {
[09:31:34.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:34.819]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:34.819]                   base::options(opts)
[09:31:34.819]                 }
[09:31:34.819]                 {
[09:31:34.819]                   {
[09:31:34.819]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:34.819]                     NULL
[09:31:34.819]                   }
[09:31:34.819]                   options(future.plan = NULL)
[09:31:34.819]                   if (is.na(NA_character_)) 
[09:31:34.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:34.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:34.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:34.819]                     .init = FALSE)
[09:31:34.819]                 }
[09:31:34.819]             }
[09:31:34.819]         }
[09:31:34.819]     })
[09:31:34.819]     if (TRUE) {
[09:31:34.819]         base::sink(type = "output", split = FALSE)
[09:31:34.819]         if (TRUE) {
[09:31:34.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:34.819]         }
[09:31:34.819]         else {
[09:31:34.819]             ...future.result["stdout"] <- base::list(NULL)
[09:31:34.819]         }
[09:31:34.819]         base::close(...future.stdout)
[09:31:34.819]         ...future.stdout <- NULL
[09:31:34.819]     }
[09:31:34.819]     ...future.result$conditions <- ...future.conditions
[09:31:34.819]     ...future.result$finished <- base::Sys.time()
[09:31:34.819]     ...future.result
[09:31:34.819] }
[09:31:34.822] assign_globals() ...
[09:31:34.822] List of 1
[09:31:34.822]  $ x:function ()  
[09:31:34.822]  - attr(*, "where")=List of 1
[09:31:34.822]   ..$ x:<environment: R_EmptyEnv> 
[09:31:34.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:34.822]  - attr(*, "resolved")= logi TRUE
[09:31:34.822]  - attr(*, "total_size")= num 1032
[09:31:34.822]  - attr(*, "already-done")= logi TRUE
[09:31:34.825] - reassign environment for ‘x’
[09:31:34.825] - copied ‘x’ to environment
[09:31:34.825] assign_globals() ... done
[09:31:34.825] requestCore(): workers = 2
[09:31:34.827] MulticoreFuture started
[09:31:34.828] - Launch lazy future ... done
[09:31:34.828] run() for ‘MulticoreFuture’ ... done
[09:31:34.829] plan(): Setting new future strategy stack:
[09:31:34.829] result() for MulticoreFuture ...
[09:31:34.829] List of future strategies:
[09:31:34.829] 1. sequential:
[09:31:34.829]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:34.829]    - tweaked: FALSE
[09:31:34.829]    - call: NULL
[09:31:34.830] plan(): nbrOfWorkers() = 1
[09:31:34.833] plan(): Setting new future strategy stack:
[09:31:34.833] List of future strategies:
[09:31:34.833] 1. multicore:
[09:31:34.833]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:31:34.833]    - tweaked: FALSE
[09:31:34.833]    - call: plan(strategy)
[09:31:34.838] plan(): nbrOfWorkers() = 2
[09:31:34.839] result() for MulticoreFuture ...
[09:31:34.839] result() for MulticoreFuture ... done
[09:31:34.840] result() for MulticoreFuture ... done
[09:31:34.840] result() for MulticoreFuture ...
[09:31:34.840] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[09:31:34.841] plan(): Setting new future strategy stack:
[09:31:34.841] List of future strategies:
[09:31:34.841] 1. multisession:
[09:31:34.841]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:34.841]    - tweaked: FALSE
[09:31:34.841]    - call: plan(strategy)
[09:31:34.842] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:31:34.842] multisession:
[09:31:34.842] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:34.842] - tweaked: FALSE
[09:31:34.842] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:34.849] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:34.849] Not searching for globals
[09:31:34.849] - globals: [0] <none>
[09:31:34.849] getGlobalsAndPackages() ... DONE
[09:31:34.850] [local output] makeClusterPSOCK() ...
[09:31:34.895] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:31:34.897] [local output] Base port: 11234
[09:31:34.897] [local output] Getting setup options for 2 cluster nodes ...
[09:31:34.897] [local output]  - Node 1 of 2 ...
[09:31:34.897] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:34.898] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8pv5D7/worker.rank=1.parallelly.parent=44743.aec74168497b.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp8pv5D7/worker.rank=1.parallelly.parent=44743.aec74168497b.pid")'’
[09:31:35.084] - Possible to infer worker's PID: TRUE
[09:31:35.084] [local output] Rscript port: 11234

[09:31:35.085] [local output]  - Node 2 of 2 ...
[09:31:35.085] [local output] localMachine=TRUE => revtunnel=FALSE

[09:31:35.086] [local output] Rscript port: 11234

[09:31:35.086] [local output] Getting setup options for 2 cluster nodes ... done
[09:31:35.086] [local output]  - Parallel setup requested for some PSOCK nodes
[09:31:35.087] [local output] Setting up PSOCK nodes in parallel
[09:31:35.087] List of 36
[09:31:35.087]  $ worker          : chr "localhost"
[09:31:35.087]   ..- attr(*, "localhost")= logi TRUE
[09:31:35.087]  $ master          : chr "localhost"
[09:31:35.087]  $ port            : int 11234
[09:31:35.087]  $ connectTimeout  : num 120
[09:31:35.087]  $ timeout         : num 2592000
[09:31:35.087]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:31:35.087]  $ homogeneous     : logi TRUE
[09:31:35.087]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:31:35.087]  $ rscript_envs    : NULL
[09:31:35.087]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:35.087]  $ rscript_startup : NULL
[09:31:35.087]  $ rscript_sh      : chr "sh"
[09:31:35.087]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:35.087]  $ methods         : logi TRUE
[09:31:35.087]  $ socketOptions   : chr "no-delay"
[09:31:35.087]  $ useXDR          : logi FALSE
[09:31:35.087]  $ outfile         : chr "/dev/null"
[09:31:35.087]  $ renice          : int NA
[09:31:35.087]  $ rshcmd          : NULL
[09:31:35.087]  $ user            : chr(0) 
[09:31:35.087]  $ revtunnel       : logi FALSE
[09:31:35.087]  $ rshlogfile      : NULL
[09:31:35.087]  $ rshopts         : chr(0) 
[09:31:35.087]  $ rank            : int 1
[09:31:35.087]  $ manual          : logi FALSE
[09:31:35.087]  $ dryrun          : logi FALSE
[09:31:35.087]  $ quiet           : logi FALSE
[09:31:35.087]  $ setup_strategy  : chr "parallel"
[09:31:35.087]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:35.087]  $ pidfile         : chr "/tmp/Rtmp8pv5D7/worker.rank=1.parallelly.parent=44743.aec74168497b.pid"
[09:31:35.087]  $ rshcmd_label    : NULL
[09:31:35.087]  $ rsh_call        : NULL
[09:31:35.087]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:31:35.087]  $ localMachine    : logi TRUE
[09:31:35.087]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:31:35.087]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:31:35.087]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:31:35.087]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:31:35.087]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:31:35.087]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:31:35.087]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:31:35.087]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:31:35.087]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:31:35.087]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:31:35.087]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:31:35.087]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:31:35.087]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:31:35.087]  $ arguments       :List of 28
[09:31:35.087]   ..$ worker          : chr "localhost"
[09:31:35.087]   ..$ master          : NULL
[09:31:35.087]   ..$ port            : int 11234
[09:31:35.087]   ..$ connectTimeout  : num 120
[09:31:35.087]   ..$ timeout         : num 2592000
[09:31:35.087]   ..$ rscript         : NULL
[09:31:35.087]   ..$ homogeneous     : NULL
[09:31:35.087]   ..$ rscript_args    : NULL
[09:31:35.087]   ..$ rscript_envs    : NULL
[09:31:35.087]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:31:35.087]   ..$ rscript_startup : NULL
[09:31:35.087]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:31:35.087]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:31:35.087]   ..$ methods         : logi TRUE
[09:31:35.087]   ..$ socketOptions   : chr "no-delay"
[09:31:35.087]   ..$ useXDR          : logi FALSE
[09:31:35.087]   ..$ outfile         : chr "/dev/null"
[09:31:35.087]   ..$ renice          : int NA
[09:31:35.087]   ..$ rshcmd          : NULL
[09:31:35.087]   ..$ user            : NULL
[09:31:35.087]   ..$ revtunnel       : logi NA
[09:31:35.087]   ..$ rshlogfile      : NULL
[09:31:35.087]   ..$ rshopts         : NULL
[09:31:35.087]   ..$ rank            : int 1
[09:31:35.087]   ..$ manual          : logi FALSE
[09:31:35.087]   ..$ dryrun          : logi FALSE
[09:31:35.087]   ..$ quiet           : logi FALSE
[09:31:35.087]   ..$ setup_strategy  : chr "parallel"
[09:31:35.087]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:31:35.103] [local output] System call to launch all workers:
[09:31:35.103] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp8pv5D7/worker.rank=1.parallelly.parent=44743.aec74168497b.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11234 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:31:35.103] [local output] Starting PSOCK main server
[09:31:35.109] [local output] Workers launched
[09:31:35.109] [local output] Waiting for workers to connect back
[09:31:35.109]  - [local output] 0 workers out of 2 ready
[09:31:35.352]  - [local output] 0 workers out of 2 ready
[09:31:35.352]  - [local output] 1 workers out of 2 ready
[09:31:35.353]  - [local output] 1 workers out of 2 ready
[09:31:35.353]  - [local output] 2 workers out of 2 ready
[09:31:35.353] [local output] Launching of workers completed
[09:31:35.353] [local output] Collecting session information from workers
[09:31:35.354] [local output]  - Worker #1 of 2
[09:31:35.355] [local output]  - Worker #2 of 2
[09:31:35.355] [local output] makeClusterPSOCK() ... done
[09:31:35.366] Packages needed by the future expression (n = 0): <none>
[09:31:35.366] Packages needed by future strategies (n = 0): <none>
[09:31:35.366] {
[09:31:35.366]     {
[09:31:35.366]         {
[09:31:35.366]             ...future.startTime <- base::Sys.time()
[09:31:35.366]             {
[09:31:35.366]                 {
[09:31:35.366]                   {
[09:31:35.366]                     {
[09:31:35.366]                       base::local({
[09:31:35.366]                         has_future <- base::requireNamespace("future", 
[09:31:35.366]                           quietly = TRUE)
[09:31:35.366]                         if (has_future) {
[09:31:35.366]                           ns <- base::getNamespace("future")
[09:31:35.366]                           version <- ns[[".package"]][["version"]]
[09:31:35.366]                           if (is.null(version)) 
[09:31:35.366]                             version <- utils::packageVersion("future")
[09:31:35.366]                         }
[09:31:35.366]                         else {
[09:31:35.366]                           version <- NULL
[09:31:35.366]                         }
[09:31:35.366]                         if (!has_future || version < "1.8.0") {
[09:31:35.366]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.366]                             "", base::R.version$version.string), 
[09:31:35.366]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.366]                               "release", "version")], collapse = " "), 
[09:31:35.366]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.366]                             info)
[09:31:35.366]                           info <- base::paste(info, collapse = "; ")
[09:31:35.366]                           if (!has_future) {
[09:31:35.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.366]                               info)
[09:31:35.366]                           }
[09:31:35.366]                           else {
[09:31:35.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.366]                               info, version)
[09:31:35.366]                           }
[09:31:35.366]                           base::stop(msg)
[09:31:35.366]                         }
[09:31:35.366]                       })
[09:31:35.366]                     }
[09:31:35.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.366]                     base::options(mc.cores = 1L)
[09:31:35.366]                   }
[09:31:35.366]                   ...future.strategy.old <- future::plan("list")
[09:31:35.366]                   options(future.plan = NULL)
[09:31:35.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.366]                 }
[09:31:35.366]                 ...future.workdir <- getwd()
[09:31:35.366]             }
[09:31:35.366]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.366]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.366]         }
[09:31:35.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.366]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:35.366]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.366]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.366]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.366]             base::names(...future.oldOptions))
[09:31:35.366]     }
[09:31:35.366]     if (FALSE) {
[09:31:35.366]     }
[09:31:35.366]     else {
[09:31:35.366]         if (TRUE) {
[09:31:35.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.366]                 open = "w")
[09:31:35.366]         }
[09:31:35.366]         else {
[09:31:35.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.366]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.366]         }
[09:31:35.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.366]             base::sink(type = "output", split = FALSE)
[09:31:35.366]             base::close(...future.stdout)
[09:31:35.366]         }, add = TRUE)
[09:31:35.366]     }
[09:31:35.366]     ...future.frame <- base::sys.nframe()
[09:31:35.366]     ...future.conditions <- base::list()
[09:31:35.366]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.366]     if (FALSE) {
[09:31:35.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.366]     }
[09:31:35.366]     ...future.result <- base::tryCatch({
[09:31:35.366]         base::withCallingHandlers({
[09:31:35.366]             ...future.value <- base::withVisible(base::local({
[09:31:35.366]                 ...future.makeSendCondition <- base::local({
[09:31:35.366]                   sendCondition <- NULL
[09:31:35.366]                   function(frame = 1L) {
[09:31:35.366]                     if (is.function(sendCondition)) 
[09:31:35.366]                       return(sendCondition)
[09:31:35.366]                     ns <- getNamespace("parallel")
[09:31:35.366]                     if (exists("sendData", mode = "function", 
[09:31:35.366]                       envir = ns)) {
[09:31:35.366]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.366]                         envir = ns)
[09:31:35.366]                       envir <- sys.frame(frame)
[09:31:35.366]                       master <- NULL
[09:31:35.366]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.366]                         !identical(envir, emptyenv())) {
[09:31:35.366]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.366]                           inherits = FALSE)) {
[09:31:35.366]                           master <- get("master", mode = "list", 
[09:31:35.366]                             envir = envir, inherits = FALSE)
[09:31:35.366]                           if (inherits(master, c("SOCKnode", 
[09:31:35.366]                             "SOCK0node"))) {
[09:31:35.366]                             sendCondition <<- function(cond) {
[09:31:35.366]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.366]                                 success = TRUE)
[09:31:35.366]                               parallel_sendData(master, data)
[09:31:35.366]                             }
[09:31:35.366]                             return(sendCondition)
[09:31:35.366]                           }
[09:31:35.366]                         }
[09:31:35.366]                         frame <- frame + 1L
[09:31:35.366]                         envir <- sys.frame(frame)
[09:31:35.366]                       }
[09:31:35.366]                     }
[09:31:35.366]                     sendCondition <<- function(cond) NULL
[09:31:35.366]                   }
[09:31:35.366]                 })
[09:31:35.366]                 withCallingHandlers({
[09:31:35.366]                   NA
[09:31:35.366]                 }, immediateCondition = function(cond) {
[09:31:35.366]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.366]                   sendCondition(cond)
[09:31:35.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.366]                   {
[09:31:35.366]                     inherits <- base::inherits
[09:31:35.366]                     invokeRestart <- base::invokeRestart
[09:31:35.366]                     is.null <- base::is.null
[09:31:35.366]                     muffled <- FALSE
[09:31:35.366]                     if (inherits(cond, "message")) {
[09:31:35.366]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.366]                       if (muffled) 
[09:31:35.366]                         invokeRestart("muffleMessage")
[09:31:35.366]                     }
[09:31:35.366]                     else if (inherits(cond, "warning")) {
[09:31:35.366]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.366]                       if (muffled) 
[09:31:35.366]                         invokeRestart("muffleWarning")
[09:31:35.366]                     }
[09:31:35.366]                     else if (inherits(cond, "condition")) {
[09:31:35.366]                       if (!is.null(pattern)) {
[09:31:35.366]                         computeRestarts <- base::computeRestarts
[09:31:35.366]                         grepl <- base::grepl
[09:31:35.366]                         restarts <- computeRestarts(cond)
[09:31:35.366]                         for (restart in restarts) {
[09:31:35.366]                           name <- restart$name
[09:31:35.366]                           if (is.null(name)) 
[09:31:35.366]                             next
[09:31:35.366]                           if (!grepl(pattern, name)) 
[09:31:35.366]                             next
[09:31:35.366]                           invokeRestart(restart)
[09:31:35.366]                           muffled <- TRUE
[09:31:35.366]                           break
[09:31:35.366]                         }
[09:31:35.366]                       }
[09:31:35.366]                     }
[09:31:35.366]                     invisible(muffled)
[09:31:35.366]                   }
[09:31:35.366]                   muffleCondition(cond)
[09:31:35.366]                 })
[09:31:35.366]             }))
[09:31:35.366]             future::FutureResult(value = ...future.value$value, 
[09:31:35.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.366]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.366]                     ...future.globalenv.names))
[09:31:35.366]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.366]         }, condition = base::local({
[09:31:35.366]             c <- base::c
[09:31:35.366]             inherits <- base::inherits
[09:31:35.366]             invokeRestart <- base::invokeRestart
[09:31:35.366]             length <- base::length
[09:31:35.366]             list <- base::list
[09:31:35.366]             seq.int <- base::seq.int
[09:31:35.366]             signalCondition <- base::signalCondition
[09:31:35.366]             sys.calls <- base::sys.calls
[09:31:35.366]             `[[` <- base::`[[`
[09:31:35.366]             `+` <- base::`+`
[09:31:35.366]             `<<-` <- base::`<<-`
[09:31:35.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.366]                   3L)]
[09:31:35.366]             }
[09:31:35.366]             function(cond) {
[09:31:35.366]                 is_error <- inherits(cond, "error")
[09:31:35.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.366]                   NULL)
[09:31:35.366]                 if (is_error) {
[09:31:35.366]                   sessionInformation <- function() {
[09:31:35.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.366]                       search = base::search(), system = base::Sys.info())
[09:31:35.366]                   }
[09:31:35.366]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.366]                     cond$call), session = sessionInformation(), 
[09:31:35.366]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.366]                   signalCondition(cond)
[09:31:35.366]                 }
[09:31:35.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.366]                 "immediateCondition"))) {
[09:31:35.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.366]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.366]                   if (TRUE && !signal) {
[09:31:35.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.366]                     {
[09:31:35.366]                       inherits <- base::inherits
[09:31:35.366]                       invokeRestart <- base::invokeRestart
[09:31:35.366]                       is.null <- base::is.null
[09:31:35.366]                       muffled <- FALSE
[09:31:35.366]                       if (inherits(cond, "message")) {
[09:31:35.366]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.366]                         if (muffled) 
[09:31:35.366]                           invokeRestart("muffleMessage")
[09:31:35.366]                       }
[09:31:35.366]                       else if (inherits(cond, "warning")) {
[09:31:35.366]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.366]                         if (muffled) 
[09:31:35.366]                           invokeRestart("muffleWarning")
[09:31:35.366]                       }
[09:31:35.366]                       else if (inherits(cond, "condition")) {
[09:31:35.366]                         if (!is.null(pattern)) {
[09:31:35.366]                           computeRestarts <- base::computeRestarts
[09:31:35.366]                           grepl <- base::grepl
[09:31:35.366]                           restarts <- computeRestarts(cond)
[09:31:35.366]                           for (restart in restarts) {
[09:31:35.366]                             name <- restart$name
[09:31:35.366]                             if (is.null(name)) 
[09:31:35.366]                               next
[09:31:35.366]                             if (!grepl(pattern, name)) 
[09:31:35.366]                               next
[09:31:35.366]                             invokeRestart(restart)
[09:31:35.366]                             muffled <- TRUE
[09:31:35.366]                             break
[09:31:35.366]                           }
[09:31:35.366]                         }
[09:31:35.366]                       }
[09:31:35.366]                       invisible(muffled)
[09:31:35.366]                     }
[09:31:35.366]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.366]                   }
[09:31:35.366]                 }
[09:31:35.366]                 else {
[09:31:35.366]                   if (TRUE) {
[09:31:35.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.366]                     {
[09:31:35.366]                       inherits <- base::inherits
[09:31:35.366]                       invokeRestart <- base::invokeRestart
[09:31:35.366]                       is.null <- base::is.null
[09:31:35.366]                       muffled <- FALSE
[09:31:35.366]                       if (inherits(cond, "message")) {
[09:31:35.366]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.366]                         if (muffled) 
[09:31:35.366]                           invokeRestart("muffleMessage")
[09:31:35.366]                       }
[09:31:35.366]                       else if (inherits(cond, "warning")) {
[09:31:35.366]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.366]                         if (muffled) 
[09:31:35.366]                           invokeRestart("muffleWarning")
[09:31:35.366]                       }
[09:31:35.366]                       else if (inherits(cond, "condition")) {
[09:31:35.366]                         if (!is.null(pattern)) {
[09:31:35.366]                           computeRestarts <- base::computeRestarts
[09:31:35.366]                           grepl <- base::grepl
[09:31:35.366]                           restarts <- computeRestarts(cond)
[09:31:35.366]                           for (restart in restarts) {
[09:31:35.366]                             name <- restart$name
[09:31:35.366]                             if (is.null(name)) 
[09:31:35.366]                               next
[09:31:35.366]                             if (!grepl(pattern, name)) 
[09:31:35.366]                               next
[09:31:35.366]                             invokeRestart(restart)
[09:31:35.366]                             muffled <- TRUE
[09:31:35.366]                             break
[09:31:35.366]                           }
[09:31:35.366]                         }
[09:31:35.366]                       }
[09:31:35.366]                       invisible(muffled)
[09:31:35.366]                     }
[09:31:35.366]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.366]                   }
[09:31:35.366]                 }
[09:31:35.366]             }
[09:31:35.366]         }))
[09:31:35.366]     }, error = function(ex) {
[09:31:35.366]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.366]                 ...future.rng), started = ...future.startTime, 
[09:31:35.366]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.366]             version = "1.8"), class = "FutureResult")
[09:31:35.366]     }, finally = {
[09:31:35.366]         if (!identical(...future.workdir, getwd())) 
[09:31:35.366]             setwd(...future.workdir)
[09:31:35.366]         {
[09:31:35.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.366]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.366]             }
[09:31:35.366]             base::options(...future.oldOptions)
[09:31:35.366]             if (.Platform$OS.type == "windows") {
[09:31:35.366]                 old_names <- names(...future.oldEnvVars)
[09:31:35.366]                 envs <- base::Sys.getenv()
[09:31:35.366]                 names <- names(envs)
[09:31:35.366]                 common <- intersect(names, old_names)
[09:31:35.366]                 added <- setdiff(names, old_names)
[09:31:35.366]                 removed <- setdiff(old_names, names)
[09:31:35.366]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.366]                   envs[common]]
[09:31:35.366]                 NAMES <- toupper(changed)
[09:31:35.366]                 args <- list()
[09:31:35.366]                 for (kk in seq_along(NAMES)) {
[09:31:35.366]                   name <- changed[[kk]]
[09:31:35.366]                   NAME <- NAMES[[kk]]
[09:31:35.366]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.366]                     next
[09:31:35.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.366]                 }
[09:31:35.366]                 NAMES <- toupper(added)
[09:31:35.366]                 for (kk in seq_along(NAMES)) {
[09:31:35.366]                   name <- added[[kk]]
[09:31:35.366]                   NAME <- NAMES[[kk]]
[09:31:35.366]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.366]                     next
[09:31:35.366]                   args[[name]] <- ""
[09:31:35.366]                 }
[09:31:35.366]                 NAMES <- toupper(removed)
[09:31:35.366]                 for (kk in seq_along(NAMES)) {
[09:31:35.366]                   name <- removed[[kk]]
[09:31:35.366]                   NAME <- NAMES[[kk]]
[09:31:35.366]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.366]                     next
[09:31:35.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.366]                 }
[09:31:35.366]                 if (length(args) > 0) 
[09:31:35.366]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.366]             }
[09:31:35.366]             else {
[09:31:35.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.366]             }
[09:31:35.366]             {
[09:31:35.366]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.366]                   0L) {
[09:31:35.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.366]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.366]                   base::options(opts)
[09:31:35.366]                 }
[09:31:35.366]                 {
[09:31:35.366]                   {
[09:31:35.366]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.366]                     NULL
[09:31:35.366]                   }
[09:31:35.366]                   options(future.plan = NULL)
[09:31:35.366]                   if (is.na(NA_character_)) 
[09:31:35.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.366]                     .init = FALSE)
[09:31:35.366]                 }
[09:31:35.366]             }
[09:31:35.366]         }
[09:31:35.366]     })
[09:31:35.366]     if (TRUE) {
[09:31:35.366]         base::sink(type = "output", split = FALSE)
[09:31:35.366]         if (TRUE) {
[09:31:35.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.366]         }
[09:31:35.366]         else {
[09:31:35.366]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.366]         }
[09:31:35.366]         base::close(...future.stdout)
[09:31:35.366]         ...future.stdout <- NULL
[09:31:35.366]     }
[09:31:35.366]     ...future.result$conditions <- ...future.conditions
[09:31:35.366]     ...future.result$finished <- base::Sys.time()
[09:31:35.366]     ...future.result
[09:31:35.366] }
[09:31:35.418] MultisessionFuture started
[09:31:35.419] result() for ClusterFuture ...
[09:31:35.419] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.420] - Validating connection of MultisessionFuture
[09:31:35.451] - received message: FutureResult
[09:31:35.451] - Received FutureResult
[09:31:35.452] - Erased future from FutureRegistry
[09:31:35.452] result() for ClusterFuture ...
[09:31:35.452] - result already collected: FutureResult
[09:31:35.452] result() for ClusterFuture ... done
[09:31:35.452] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.452] result() for ClusterFuture ... done
[09:31:35.452] result() for ClusterFuture ...
[09:31:35.453] - result already collected: FutureResult
[09:31:35.453] result() for ClusterFuture ... done
[09:31:35.453] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:31:35.457] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.457] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.458] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.459] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:35.459] Searching for globals ... DONE
[09:31:35.460] Resolving globals: TRUE
[09:31:35.460] Resolving any globals that are futures ...
[09:31:35.460] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:35.460] Resolving any globals that are futures ... DONE
[09:31:35.460] 
[09:31:35.461] 
[09:31:35.461] getGlobalsAndPackages() ... DONE
[09:31:35.461] run() for ‘Future’ ...
[09:31:35.461] - state: ‘created’
[09:31:35.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.476]   - Field: ‘node’
[09:31:35.476]   - Field: ‘label’
[09:31:35.476]   - Field: ‘local’
[09:31:35.476]   - Field: ‘owner’
[09:31:35.476]   - Field: ‘envir’
[09:31:35.476]   - Field: ‘workers’
[09:31:35.476]   - Field: ‘packages’
[09:31:35.476]   - Field: ‘gc’
[09:31:35.477]   - Field: ‘conditions’
[09:31:35.477]   - Field: ‘persistent’
[09:31:35.477]   - Field: ‘expr’
[09:31:35.477]   - Field: ‘uuid’
[09:31:35.477]   - Field: ‘seed’
[09:31:35.477]   - Field: ‘version’
[09:31:35.477]   - Field: ‘result’
[09:31:35.477]   - Field: ‘asynchronous’
[09:31:35.477]   - Field: ‘calls’
[09:31:35.478]   - Field: ‘globals’
[09:31:35.478]   - Field: ‘stdout’
[09:31:35.478]   - Field: ‘earlySignal’
[09:31:35.478]   - Field: ‘lazy’
[09:31:35.478]   - Field: ‘state’
[09:31:35.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.478] - Launch lazy future ...
[09:31:35.479] Packages needed by the future expression (n = 0): <none>
[09:31:35.479] Packages needed by future strategies (n = 0): <none>
[09:31:35.479] {
[09:31:35.479]     {
[09:31:35.479]         {
[09:31:35.479]             ...future.startTime <- base::Sys.time()
[09:31:35.479]             {
[09:31:35.479]                 {
[09:31:35.479]                   {
[09:31:35.479]                     {
[09:31:35.479]                       base::local({
[09:31:35.479]                         has_future <- base::requireNamespace("future", 
[09:31:35.479]                           quietly = TRUE)
[09:31:35.479]                         if (has_future) {
[09:31:35.479]                           ns <- base::getNamespace("future")
[09:31:35.479]                           version <- ns[[".package"]][["version"]]
[09:31:35.479]                           if (is.null(version)) 
[09:31:35.479]                             version <- utils::packageVersion("future")
[09:31:35.479]                         }
[09:31:35.479]                         else {
[09:31:35.479]                           version <- NULL
[09:31:35.479]                         }
[09:31:35.479]                         if (!has_future || version < "1.8.0") {
[09:31:35.479]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.479]                             "", base::R.version$version.string), 
[09:31:35.479]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.479]                               "release", "version")], collapse = " "), 
[09:31:35.479]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.479]                             info)
[09:31:35.479]                           info <- base::paste(info, collapse = "; ")
[09:31:35.479]                           if (!has_future) {
[09:31:35.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.479]                               info)
[09:31:35.479]                           }
[09:31:35.479]                           else {
[09:31:35.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.479]                               info, version)
[09:31:35.479]                           }
[09:31:35.479]                           base::stop(msg)
[09:31:35.479]                         }
[09:31:35.479]                       })
[09:31:35.479]                     }
[09:31:35.479]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.479]                     base::options(mc.cores = 1L)
[09:31:35.479]                   }
[09:31:35.479]                   ...future.strategy.old <- future::plan("list")
[09:31:35.479]                   options(future.plan = NULL)
[09:31:35.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.479]                 }
[09:31:35.479]                 ...future.workdir <- getwd()
[09:31:35.479]             }
[09:31:35.479]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.479]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.479]         }
[09:31:35.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.479]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.479]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.479]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.479]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.479]             base::names(...future.oldOptions))
[09:31:35.479]     }
[09:31:35.479]     if (FALSE) {
[09:31:35.479]     }
[09:31:35.479]     else {
[09:31:35.479]         if (TRUE) {
[09:31:35.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.479]                 open = "w")
[09:31:35.479]         }
[09:31:35.479]         else {
[09:31:35.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.479]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.479]         }
[09:31:35.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.479]             base::sink(type = "output", split = FALSE)
[09:31:35.479]             base::close(...future.stdout)
[09:31:35.479]         }, add = TRUE)
[09:31:35.479]     }
[09:31:35.479]     ...future.frame <- base::sys.nframe()
[09:31:35.479]     ...future.conditions <- base::list()
[09:31:35.479]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.479]     if (FALSE) {
[09:31:35.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.479]     }
[09:31:35.479]     ...future.result <- base::tryCatch({
[09:31:35.479]         base::withCallingHandlers({
[09:31:35.479]             ...future.value <- base::withVisible(base::local({
[09:31:35.479]                 ...future.makeSendCondition <- base::local({
[09:31:35.479]                   sendCondition <- NULL
[09:31:35.479]                   function(frame = 1L) {
[09:31:35.479]                     if (is.function(sendCondition)) 
[09:31:35.479]                       return(sendCondition)
[09:31:35.479]                     ns <- getNamespace("parallel")
[09:31:35.479]                     if (exists("sendData", mode = "function", 
[09:31:35.479]                       envir = ns)) {
[09:31:35.479]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.479]                         envir = ns)
[09:31:35.479]                       envir <- sys.frame(frame)
[09:31:35.479]                       master <- NULL
[09:31:35.479]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.479]                         !identical(envir, emptyenv())) {
[09:31:35.479]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.479]                           inherits = FALSE)) {
[09:31:35.479]                           master <- get("master", mode = "list", 
[09:31:35.479]                             envir = envir, inherits = FALSE)
[09:31:35.479]                           if (inherits(master, c("SOCKnode", 
[09:31:35.479]                             "SOCK0node"))) {
[09:31:35.479]                             sendCondition <<- function(cond) {
[09:31:35.479]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.479]                                 success = TRUE)
[09:31:35.479]                               parallel_sendData(master, data)
[09:31:35.479]                             }
[09:31:35.479]                             return(sendCondition)
[09:31:35.479]                           }
[09:31:35.479]                         }
[09:31:35.479]                         frame <- frame + 1L
[09:31:35.479]                         envir <- sys.frame(frame)
[09:31:35.479]                       }
[09:31:35.479]                     }
[09:31:35.479]                     sendCondition <<- function(cond) NULL
[09:31:35.479]                   }
[09:31:35.479]                 })
[09:31:35.479]                 withCallingHandlers({
[09:31:35.479]                   {
[09:31:35.479]                     b <- a
[09:31:35.479]                     a <- 2
[09:31:35.479]                     a * b
[09:31:35.479]                   }
[09:31:35.479]                 }, immediateCondition = function(cond) {
[09:31:35.479]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.479]                   sendCondition(cond)
[09:31:35.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.479]                   {
[09:31:35.479]                     inherits <- base::inherits
[09:31:35.479]                     invokeRestart <- base::invokeRestart
[09:31:35.479]                     is.null <- base::is.null
[09:31:35.479]                     muffled <- FALSE
[09:31:35.479]                     if (inherits(cond, "message")) {
[09:31:35.479]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.479]                       if (muffled) 
[09:31:35.479]                         invokeRestart("muffleMessage")
[09:31:35.479]                     }
[09:31:35.479]                     else if (inherits(cond, "warning")) {
[09:31:35.479]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.479]                       if (muffled) 
[09:31:35.479]                         invokeRestart("muffleWarning")
[09:31:35.479]                     }
[09:31:35.479]                     else if (inherits(cond, "condition")) {
[09:31:35.479]                       if (!is.null(pattern)) {
[09:31:35.479]                         computeRestarts <- base::computeRestarts
[09:31:35.479]                         grepl <- base::grepl
[09:31:35.479]                         restarts <- computeRestarts(cond)
[09:31:35.479]                         for (restart in restarts) {
[09:31:35.479]                           name <- restart$name
[09:31:35.479]                           if (is.null(name)) 
[09:31:35.479]                             next
[09:31:35.479]                           if (!grepl(pattern, name)) 
[09:31:35.479]                             next
[09:31:35.479]                           invokeRestart(restart)
[09:31:35.479]                           muffled <- TRUE
[09:31:35.479]                           break
[09:31:35.479]                         }
[09:31:35.479]                       }
[09:31:35.479]                     }
[09:31:35.479]                     invisible(muffled)
[09:31:35.479]                   }
[09:31:35.479]                   muffleCondition(cond)
[09:31:35.479]                 })
[09:31:35.479]             }))
[09:31:35.479]             future::FutureResult(value = ...future.value$value, 
[09:31:35.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.479]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.479]                     ...future.globalenv.names))
[09:31:35.479]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.479]         }, condition = base::local({
[09:31:35.479]             c <- base::c
[09:31:35.479]             inherits <- base::inherits
[09:31:35.479]             invokeRestart <- base::invokeRestart
[09:31:35.479]             length <- base::length
[09:31:35.479]             list <- base::list
[09:31:35.479]             seq.int <- base::seq.int
[09:31:35.479]             signalCondition <- base::signalCondition
[09:31:35.479]             sys.calls <- base::sys.calls
[09:31:35.479]             `[[` <- base::`[[`
[09:31:35.479]             `+` <- base::`+`
[09:31:35.479]             `<<-` <- base::`<<-`
[09:31:35.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.479]                   3L)]
[09:31:35.479]             }
[09:31:35.479]             function(cond) {
[09:31:35.479]                 is_error <- inherits(cond, "error")
[09:31:35.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.479]                   NULL)
[09:31:35.479]                 if (is_error) {
[09:31:35.479]                   sessionInformation <- function() {
[09:31:35.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.479]                       search = base::search(), system = base::Sys.info())
[09:31:35.479]                   }
[09:31:35.479]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.479]                     cond$call), session = sessionInformation(), 
[09:31:35.479]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.479]                   signalCondition(cond)
[09:31:35.479]                 }
[09:31:35.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.479]                 "immediateCondition"))) {
[09:31:35.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.479]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.479]                   if (TRUE && !signal) {
[09:31:35.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.479]                     {
[09:31:35.479]                       inherits <- base::inherits
[09:31:35.479]                       invokeRestart <- base::invokeRestart
[09:31:35.479]                       is.null <- base::is.null
[09:31:35.479]                       muffled <- FALSE
[09:31:35.479]                       if (inherits(cond, "message")) {
[09:31:35.479]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.479]                         if (muffled) 
[09:31:35.479]                           invokeRestart("muffleMessage")
[09:31:35.479]                       }
[09:31:35.479]                       else if (inherits(cond, "warning")) {
[09:31:35.479]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.479]                         if (muffled) 
[09:31:35.479]                           invokeRestart("muffleWarning")
[09:31:35.479]                       }
[09:31:35.479]                       else if (inherits(cond, "condition")) {
[09:31:35.479]                         if (!is.null(pattern)) {
[09:31:35.479]                           computeRestarts <- base::computeRestarts
[09:31:35.479]                           grepl <- base::grepl
[09:31:35.479]                           restarts <- computeRestarts(cond)
[09:31:35.479]                           for (restart in restarts) {
[09:31:35.479]                             name <- restart$name
[09:31:35.479]                             if (is.null(name)) 
[09:31:35.479]                               next
[09:31:35.479]                             if (!grepl(pattern, name)) 
[09:31:35.479]                               next
[09:31:35.479]                             invokeRestart(restart)
[09:31:35.479]                             muffled <- TRUE
[09:31:35.479]                             break
[09:31:35.479]                           }
[09:31:35.479]                         }
[09:31:35.479]                       }
[09:31:35.479]                       invisible(muffled)
[09:31:35.479]                     }
[09:31:35.479]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.479]                   }
[09:31:35.479]                 }
[09:31:35.479]                 else {
[09:31:35.479]                   if (TRUE) {
[09:31:35.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.479]                     {
[09:31:35.479]                       inherits <- base::inherits
[09:31:35.479]                       invokeRestart <- base::invokeRestart
[09:31:35.479]                       is.null <- base::is.null
[09:31:35.479]                       muffled <- FALSE
[09:31:35.479]                       if (inherits(cond, "message")) {
[09:31:35.479]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.479]                         if (muffled) 
[09:31:35.479]                           invokeRestart("muffleMessage")
[09:31:35.479]                       }
[09:31:35.479]                       else if (inherits(cond, "warning")) {
[09:31:35.479]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.479]                         if (muffled) 
[09:31:35.479]                           invokeRestart("muffleWarning")
[09:31:35.479]                       }
[09:31:35.479]                       else if (inherits(cond, "condition")) {
[09:31:35.479]                         if (!is.null(pattern)) {
[09:31:35.479]                           computeRestarts <- base::computeRestarts
[09:31:35.479]                           grepl <- base::grepl
[09:31:35.479]                           restarts <- computeRestarts(cond)
[09:31:35.479]                           for (restart in restarts) {
[09:31:35.479]                             name <- restart$name
[09:31:35.479]                             if (is.null(name)) 
[09:31:35.479]                               next
[09:31:35.479]                             if (!grepl(pattern, name)) 
[09:31:35.479]                               next
[09:31:35.479]                             invokeRestart(restart)
[09:31:35.479]                             muffled <- TRUE
[09:31:35.479]                             break
[09:31:35.479]                           }
[09:31:35.479]                         }
[09:31:35.479]                       }
[09:31:35.479]                       invisible(muffled)
[09:31:35.479]                     }
[09:31:35.479]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.479]                   }
[09:31:35.479]                 }
[09:31:35.479]             }
[09:31:35.479]         }))
[09:31:35.479]     }, error = function(ex) {
[09:31:35.479]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.479]                 ...future.rng), started = ...future.startTime, 
[09:31:35.479]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.479]             version = "1.8"), class = "FutureResult")
[09:31:35.479]     }, finally = {
[09:31:35.479]         if (!identical(...future.workdir, getwd())) 
[09:31:35.479]             setwd(...future.workdir)
[09:31:35.479]         {
[09:31:35.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.479]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.479]             }
[09:31:35.479]             base::options(...future.oldOptions)
[09:31:35.479]             if (.Platform$OS.type == "windows") {
[09:31:35.479]                 old_names <- names(...future.oldEnvVars)
[09:31:35.479]                 envs <- base::Sys.getenv()
[09:31:35.479]                 names <- names(envs)
[09:31:35.479]                 common <- intersect(names, old_names)
[09:31:35.479]                 added <- setdiff(names, old_names)
[09:31:35.479]                 removed <- setdiff(old_names, names)
[09:31:35.479]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.479]                   envs[common]]
[09:31:35.479]                 NAMES <- toupper(changed)
[09:31:35.479]                 args <- list()
[09:31:35.479]                 for (kk in seq_along(NAMES)) {
[09:31:35.479]                   name <- changed[[kk]]
[09:31:35.479]                   NAME <- NAMES[[kk]]
[09:31:35.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.479]                     next
[09:31:35.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.479]                 }
[09:31:35.479]                 NAMES <- toupper(added)
[09:31:35.479]                 for (kk in seq_along(NAMES)) {
[09:31:35.479]                   name <- added[[kk]]
[09:31:35.479]                   NAME <- NAMES[[kk]]
[09:31:35.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.479]                     next
[09:31:35.479]                   args[[name]] <- ""
[09:31:35.479]                 }
[09:31:35.479]                 NAMES <- toupper(removed)
[09:31:35.479]                 for (kk in seq_along(NAMES)) {
[09:31:35.479]                   name <- removed[[kk]]
[09:31:35.479]                   NAME <- NAMES[[kk]]
[09:31:35.479]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.479]                     next
[09:31:35.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.479]                 }
[09:31:35.479]                 if (length(args) > 0) 
[09:31:35.479]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.479]             }
[09:31:35.479]             else {
[09:31:35.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.479]             }
[09:31:35.479]             {
[09:31:35.479]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.479]                   0L) {
[09:31:35.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.479]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.479]                   base::options(opts)
[09:31:35.479]                 }
[09:31:35.479]                 {
[09:31:35.479]                   {
[09:31:35.479]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.479]                     NULL
[09:31:35.479]                   }
[09:31:35.479]                   options(future.plan = NULL)
[09:31:35.479]                   if (is.na(NA_character_)) 
[09:31:35.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.479]                     .init = FALSE)
[09:31:35.479]                 }
[09:31:35.479]             }
[09:31:35.479]         }
[09:31:35.479]     })
[09:31:35.479]     if (TRUE) {
[09:31:35.479]         base::sink(type = "output", split = FALSE)
[09:31:35.479]         if (TRUE) {
[09:31:35.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.479]         }
[09:31:35.479]         else {
[09:31:35.479]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.479]         }
[09:31:35.479]         base::close(...future.stdout)
[09:31:35.479]         ...future.stdout <- NULL
[09:31:35.479]     }
[09:31:35.479]     ...future.result$conditions <- ...future.conditions
[09:31:35.479]     ...future.result$finished <- base::Sys.time()
[09:31:35.479]     ...future.result
[09:31:35.479] }
[09:31:35.483] MultisessionFuture started
[09:31:35.483] - Launch lazy future ... done
[09:31:35.483] run() for ‘MultisessionFuture’ ... done
[09:31:35.483] result() for ClusterFuture ...
[09:31:35.484] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.484] - Validating connection of MultisessionFuture
[09:31:35.486] - received message: FutureResult
[09:31:35.486] - Received FutureResult
[09:31:35.486] - Erased future from FutureRegistry
[09:31:35.486] result() for ClusterFuture ...
[09:31:35.486] - result already collected: FutureResult
[09:31:35.486] result() for ClusterFuture ... done
[09:31:35.487] signalConditions() ...
[09:31:35.487]  - include = ‘immediateCondition’
[09:31:35.487]  - exclude = 
[09:31:35.487]  - resignal = FALSE
[09:31:35.487]  - Number of conditions: 1
[09:31:35.487] signalConditions() ... done
[09:31:35.487] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.487] result() for ClusterFuture ... done
[09:31:35.487] result() for ClusterFuture ...
[09:31:35.487] - result already collected: FutureResult
[09:31:35.488] result() for ClusterFuture ... done
[09:31:35.488] signalConditions() ...
[09:31:35.488]  - include = ‘immediateCondition’
[09:31:35.488]  - exclude = 
[09:31:35.488]  - resignal = FALSE
[09:31:35.488]  - Number of conditions: 1
[09:31:35.488] signalConditions() ... done
[09:31:35.488] Future state: ‘finished’
[09:31:35.489] result() for ClusterFuture ...
[09:31:35.489] - result already collected: FutureResult
[09:31:35.489] result() for ClusterFuture ... done
[09:31:35.489] signalConditions() ...
[09:31:35.489]  - include = ‘condition’
[09:31:35.489]  - exclude = ‘immediateCondition’
[09:31:35.489]  - resignal = TRUE
[09:31:35.489]  - Number of conditions: 1
[09:31:35.489]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:35.490] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:35"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.506] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.506] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.508] - globals found: [3] ‘{’, ‘<-’, ‘*’
[09:31:35.508] Searching for globals ... DONE
[09:31:35.508] Resolving globals: TRUE
[09:31:35.508] Resolving any globals that are futures ...
[09:31:35.508] - globals: [3] ‘{’, ‘<-’, ‘*’
[09:31:35.509] Resolving any globals that are futures ... DONE
[09:31:35.509] 
[09:31:35.509] 
[09:31:35.509] getGlobalsAndPackages() ... DONE
[09:31:35.510] run() for ‘Future’ ...
[09:31:35.510] - state: ‘created’
[09:31:35.510] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.524] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.525]   - Field: ‘node’
[09:31:35.525]   - Field: ‘label’
[09:31:35.525]   - Field: ‘local’
[09:31:35.525]   - Field: ‘owner’
[09:31:35.525]   - Field: ‘envir’
[09:31:35.525]   - Field: ‘workers’
[09:31:35.525]   - Field: ‘packages’
[09:31:35.525]   - Field: ‘gc’
[09:31:35.525]   - Field: ‘conditions’
[09:31:35.526]   - Field: ‘persistent’
[09:31:35.526]   - Field: ‘expr’
[09:31:35.526]   - Field: ‘uuid’
[09:31:35.526]   - Field: ‘seed’
[09:31:35.526]   - Field: ‘version’
[09:31:35.526]   - Field: ‘result’
[09:31:35.526]   - Field: ‘asynchronous’
[09:31:35.526]   - Field: ‘calls’
[09:31:35.526]   - Field: ‘globals’
[09:31:35.527]   - Field: ‘stdout’
[09:31:35.527]   - Field: ‘earlySignal’
[09:31:35.527]   - Field: ‘lazy’
[09:31:35.527]   - Field: ‘state’
[09:31:35.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.527] - Launch lazy future ...
[09:31:35.527] Packages needed by the future expression (n = 0): <none>
[09:31:35.528] Packages needed by future strategies (n = 0): <none>
[09:31:35.528] {
[09:31:35.528]     {
[09:31:35.528]         {
[09:31:35.528]             ...future.startTime <- base::Sys.time()
[09:31:35.528]             {
[09:31:35.528]                 {
[09:31:35.528]                   {
[09:31:35.528]                     {
[09:31:35.528]                       base::local({
[09:31:35.528]                         has_future <- base::requireNamespace("future", 
[09:31:35.528]                           quietly = TRUE)
[09:31:35.528]                         if (has_future) {
[09:31:35.528]                           ns <- base::getNamespace("future")
[09:31:35.528]                           version <- ns[[".package"]][["version"]]
[09:31:35.528]                           if (is.null(version)) 
[09:31:35.528]                             version <- utils::packageVersion("future")
[09:31:35.528]                         }
[09:31:35.528]                         else {
[09:31:35.528]                           version <- NULL
[09:31:35.528]                         }
[09:31:35.528]                         if (!has_future || version < "1.8.0") {
[09:31:35.528]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.528]                             "", base::R.version$version.string), 
[09:31:35.528]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.528]                               "release", "version")], collapse = " "), 
[09:31:35.528]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.528]                             info)
[09:31:35.528]                           info <- base::paste(info, collapse = "; ")
[09:31:35.528]                           if (!has_future) {
[09:31:35.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.528]                               info)
[09:31:35.528]                           }
[09:31:35.528]                           else {
[09:31:35.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.528]                               info, version)
[09:31:35.528]                           }
[09:31:35.528]                           base::stop(msg)
[09:31:35.528]                         }
[09:31:35.528]                       })
[09:31:35.528]                     }
[09:31:35.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.528]                     base::options(mc.cores = 1L)
[09:31:35.528]                   }
[09:31:35.528]                   ...future.strategy.old <- future::plan("list")
[09:31:35.528]                   options(future.plan = NULL)
[09:31:35.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.528]                 }
[09:31:35.528]                 ...future.workdir <- getwd()
[09:31:35.528]             }
[09:31:35.528]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.528]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.528]         }
[09:31:35.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.528]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.528]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.528]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.528]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.528]             base::names(...future.oldOptions))
[09:31:35.528]     }
[09:31:35.528]     if (FALSE) {
[09:31:35.528]     }
[09:31:35.528]     else {
[09:31:35.528]         if (TRUE) {
[09:31:35.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.528]                 open = "w")
[09:31:35.528]         }
[09:31:35.528]         else {
[09:31:35.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.528]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.528]         }
[09:31:35.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.528]             base::sink(type = "output", split = FALSE)
[09:31:35.528]             base::close(...future.stdout)
[09:31:35.528]         }, add = TRUE)
[09:31:35.528]     }
[09:31:35.528]     ...future.frame <- base::sys.nframe()
[09:31:35.528]     ...future.conditions <- base::list()
[09:31:35.528]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.528]     if (FALSE) {
[09:31:35.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.528]     }
[09:31:35.528]     ...future.result <- base::tryCatch({
[09:31:35.528]         base::withCallingHandlers({
[09:31:35.528]             ...future.value <- base::withVisible(base::local({
[09:31:35.528]                 ...future.makeSendCondition <- base::local({
[09:31:35.528]                   sendCondition <- NULL
[09:31:35.528]                   function(frame = 1L) {
[09:31:35.528]                     if (is.function(sendCondition)) 
[09:31:35.528]                       return(sendCondition)
[09:31:35.528]                     ns <- getNamespace("parallel")
[09:31:35.528]                     if (exists("sendData", mode = "function", 
[09:31:35.528]                       envir = ns)) {
[09:31:35.528]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.528]                         envir = ns)
[09:31:35.528]                       envir <- sys.frame(frame)
[09:31:35.528]                       master <- NULL
[09:31:35.528]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.528]                         !identical(envir, emptyenv())) {
[09:31:35.528]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.528]                           inherits = FALSE)) {
[09:31:35.528]                           master <- get("master", mode = "list", 
[09:31:35.528]                             envir = envir, inherits = FALSE)
[09:31:35.528]                           if (inherits(master, c("SOCKnode", 
[09:31:35.528]                             "SOCK0node"))) {
[09:31:35.528]                             sendCondition <<- function(cond) {
[09:31:35.528]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.528]                                 success = TRUE)
[09:31:35.528]                               parallel_sendData(master, data)
[09:31:35.528]                             }
[09:31:35.528]                             return(sendCondition)
[09:31:35.528]                           }
[09:31:35.528]                         }
[09:31:35.528]                         frame <- frame + 1L
[09:31:35.528]                         envir <- sys.frame(frame)
[09:31:35.528]                       }
[09:31:35.528]                     }
[09:31:35.528]                     sendCondition <<- function(cond) NULL
[09:31:35.528]                   }
[09:31:35.528]                 })
[09:31:35.528]                 withCallingHandlers({
[09:31:35.528]                   {
[09:31:35.528]                     b <- a
[09:31:35.528]                     a <- 2
[09:31:35.528]                     a * b
[09:31:35.528]                   }
[09:31:35.528]                 }, immediateCondition = function(cond) {
[09:31:35.528]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.528]                   sendCondition(cond)
[09:31:35.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.528]                   {
[09:31:35.528]                     inherits <- base::inherits
[09:31:35.528]                     invokeRestart <- base::invokeRestart
[09:31:35.528]                     is.null <- base::is.null
[09:31:35.528]                     muffled <- FALSE
[09:31:35.528]                     if (inherits(cond, "message")) {
[09:31:35.528]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.528]                       if (muffled) 
[09:31:35.528]                         invokeRestart("muffleMessage")
[09:31:35.528]                     }
[09:31:35.528]                     else if (inherits(cond, "warning")) {
[09:31:35.528]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.528]                       if (muffled) 
[09:31:35.528]                         invokeRestart("muffleWarning")
[09:31:35.528]                     }
[09:31:35.528]                     else if (inherits(cond, "condition")) {
[09:31:35.528]                       if (!is.null(pattern)) {
[09:31:35.528]                         computeRestarts <- base::computeRestarts
[09:31:35.528]                         grepl <- base::grepl
[09:31:35.528]                         restarts <- computeRestarts(cond)
[09:31:35.528]                         for (restart in restarts) {
[09:31:35.528]                           name <- restart$name
[09:31:35.528]                           if (is.null(name)) 
[09:31:35.528]                             next
[09:31:35.528]                           if (!grepl(pattern, name)) 
[09:31:35.528]                             next
[09:31:35.528]                           invokeRestart(restart)
[09:31:35.528]                           muffled <- TRUE
[09:31:35.528]                           break
[09:31:35.528]                         }
[09:31:35.528]                       }
[09:31:35.528]                     }
[09:31:35.528]                     invisible(muffled)
[09:31:35.528]                   }
[09:31:35.528]                   muffleCondition(cond)
[09:31:35.528]                 })
[09:31:35.528]             }))
[09:31:35.528]             future::FutureResult(value = ...future.value$value, 
[09:31:35.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.528]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.528]                     ...future.globalenv.names))
[09:31:35.528]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.528]         }, condition = base::local({
[09:31:35.528]             c <- base::c
[09:31:35.528]             inherits <- base::inherits
[09:31:35.528]             invokeRestart <- base::invokeRestart
[09:31:35.528]             length <- base::length
[09:31:35.528]             list <- base::list
[09:31:35.528]             seq.int <- base::seq.int
[09:31:35.528]             signalCondition <- base::signalCondition
[09:31:35.528]             sys.calls <- base::sys.calls
[09:31:35.528]             `[[` <- base::`[[`
[09:31:35.528]             `+` <- base::`+`
[09:31:35.528]             `<<-` <- base::`<<-`
[09:31:35.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.528]                   3L)]
[09:31:35.528]             }
[09:31:35.528]             function(cond) {
[09:31:35.528]                 is_error <- inherits(cond, "error")
[09:31:35.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.528]                   NULL)
[09:31:35.528]                 if (is_error) {
[09:31:35.528]                   sessionInformation <- function() {
[09:31:35.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.528]                       search = base::search(), system = base::Sys.info())
[09:31:35.528]                   }
[09:31:35.528]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.528]                     cond$call), session = sessionInformation(), 
[09:31:35.528]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.528]                   signalCondition(cond)
[09:31:35.528]                 }
[09:31:35.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.528]                 "immediateCondition"))) {
[09:31:35.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.528]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.528]                   if (TRUE && !signal) {
[09:31:35.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.528]                     {
[09:31:35.528]                       inherits <- base::inherits
[09:31:35.528]                       invokeRestart <- base::invokeRestart
[09:31:35.528]                       is.null <- base::is.null
[09:31:35.528]                       muffled <- FALSE
[09:31:35.528]                       if (inherits(cond, "message")) {
[09:31:35.528]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.528]                         if (muffled) 
[09:31:35.528]                           invokeRestart("muffleMessage")
[09:31:35.528]                       }
[09:31:35.528]                       else if (inherits(cond, "warning")) {
[09:31:35.528]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.528]                         if (muffled) 
[09:31:35.528]                           invokeRestart("muffleWarning")
[09:31:35.528]                       }
[09:31:35.528]                       else if (inherits(cond, "condition")) {
[09:31:35.528]                         if (!is.null(pattern)) {
[09:31:35.528]                           computeRestarts <- base::computeRestarts
[09:31:35.528]                           grepl <- base::grepl
[09:31:35.528]                           restarts <- computeRestarts(cond)
[09:31:35.528]                           for (restart in restarts) {
[09:31:35.528]                             name <- restart$name
[09:31:35.528]                             if (is.null(name)) 
[09:31:35.528]                               next
[09:31:35.528]                             if (!grepl(pattern, name)) 
[09:31:35.528]                               next
[09:31:35.528]                             invokeRestart(restart)
[09:31:35.528]                             muffled <- TRUE
[09:31:35.528]                             break
[09:31:35.528]                           }
[09:31:35.528]                         }
[09:31:35.528]                       }
[09:31:35.528]                       invisible(muffled)
[09:31:35.528]                     }
[09:31:35.528]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.528]                   }
[09:31:35.528]                 }
[09:31:35.528]                 else {
[09:31:35.528]                   if (TRUE) {
[09:31:35.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.528]                     {
[09:31:35.528]                       inherits <- base::inherits
[09:31:35.528]                       invokeRestart <- base::invokeRestart
[09:31:35.528]                       is.null <- base::is.null
[09:31:35.528]                       muffled <- FALSE
[09:31:35.528]                       if (inherits(cond, "message")) {
[09:31:35.528]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.528]                         if (muffled) 
[09:31:35.528]                           invokeRestart("muffleMessage")
[09:31:35.528]                       }
[09:31:35.528]                       else if (inherits(cond, "warning")) {
[09:31:35.528]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.528]                         if (muffled) 
[09:31:35.528]                           invokeRestart("muffleWarning")
[09:31:35.528]                       }
[09:31:35.528]                       else if (inherits(cond, "condition")) {
[09:31:35.528]                         if (!is.null(pattern)) {
[09:31:35.528]                           computeRestarts <- base::computeRestarts
[09:31:35.528]                           grepl <- base::grepl
[09:31:35.528]                           restarts <- computeRestarts(cond)
[09:31:35.528]                           for (restart in restarts) {
[09:31:35.528]                             name <- restart$name
[09:31:35.528]                             if (is.null(name)) 
[09:31:35.528]                               next
[09:31:35.528]                             if (!grepl(pattern, name)) 
[09:31:35.528]                               next
[09:31:35.528]                             invokeRestart(restart)
[09:31:35.528]                             muffled <- TRUE
[09:31:35.528]                             break
[09:31:35.528]                           }
[09:31:35.528]                         }
[09:31:35.528]                       }
[09:31:35.528]                       invisible(muffled)
[09:31:35.528]                     }
[09:31:35.528]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.528]                   }
[09:31:35.528]                 }
[09:31:35.528]             }
[09:31:35.528]         }))
[09:31:35.528]     }, error = function(ex) {
[09:31:35.528]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.528]                 ...future.rng), started = ...future.startTime, 
[09:31:35.528]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.528]             version = "1.8"), class = "FutureResult")
[09:31:35.528]     }, finally = {
[09:31:35.528]         if (!identical(...future.workdir, getwd())) 
[09:31:35.528]             setwd(...future.workdir)
[09:31:35.528]         {
[09:31:35.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.528]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.528]             }
[09:31:35.528]             base::options(...future.oldOptions)
[09:31:35.528]             if (.Platform$OS.type == "windows") {
[09:31:35.528]                 old_names <- names(...future.oldEnvVars)
[09:31:35.528]                 envs <- base::Sys.getenv()
[09:31:35.528]                 names <- names(envs)
[09:31:35.528]                 common <- intersect(names, old_names)
[09:31:35.528]                 added <- setdiff(names, old_names)
[09:31:35.528]                 removed <- setdiff(old_names, names)
[09:31:35.528]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.528]                   envs[common]]
[09:31:35.528]                 NAMES <- toupper(changed)
[09:31:35.528]                 args <- list()
[09:31:35.528]                 for (kk in seq_along(NAMES)) {
[09:31:35.528]                   name <- changed[[kk]]
[09:31:35.528]                   NAME <- NAMES[[kk]]
[09:31:35.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.528]                     next
[09:31:35.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.528]                 }
[09:31:35.528]                 NAMES <- toupper(added)
[09:31:35.528]                 for (kk in seq_along(NAMES)) {
[09:31:35.528]                   name <- added[[kk]]
[09:31:35.528]                   NAME <- NAMES[[kk]]
[09:31:35.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.528]                     next
[09:31:35.528]                   args[[name]] <- ""
[09:31:35.528]                 }
[09:31:35.528]                 NAMES <- toupper(removed)
[09:31:35.528]                 for (kk in seq_along(NAMES)) {
[09:31:35.528]                   name <- removed[[kk]]
[09:31:35.528]                   NAME <- NAMES[[kk]]
[09:31:35.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.528]                     next
[09:31:35.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.528]                 }
[09:31:35.528]                 if (length(args) > 0) 
[09:31:35.528]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.528]             }
[09:31:35.528]             else {
[09:31:35.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.528]             }
[09:31:35.528]             {
[09:31:35.528]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.528]                   0L) {
[09:31:35.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.528]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.528]                   base::options(opts)
[09:31:35.528]                 }
[09:31:35.528]                 {
[09:31:35.528]                   {
[09:31:35.528]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.528]                     NULL
[09:31:35.528]                   }
[09:31:35.528]                   options(future.plan = NULL)
[09:31:35.528]                   if (is.na(NA_character_)) 
[09:31:35.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.528]                     .init = FALSE)
[09:31:35.528]                 }
[09:31:35.528]             }
[09:31:35.528]         }
[09:31:35.528]     })
[09:31:35.528]     if (TRUE) {
[09:31:35.528]         base::sink(type = "output", split = FALSE)
[09:31:35.528]         if (TRUE) {
[09:31:35.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.528]         }
[09:31:35.528]         else {
[09:31:35.528]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.528]         }
[09:31:35.528]         base::close(...future.stdout)
[09:31:35.528]         ...future.stdout <- NULL
[09:31:35.528]     }
[09:31:35.528]     ...future.result$conditions <- ...future.conditions
[09:31:35.528]     ...future.result$finished <- base::Sys.time()
[09:31:35.528]     ...future.result
[09:31:35.528] }
[09:31:35.531] MultisessionFuture started
[09:31:35.532] - Launch lazy future ... done
[09:31:35.532] run() for ‘MultisessionFuture’ ... done
[09:31:35.532] result() for ClusterFuture ...
[09:31:35.532] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.532] - Validating connection of MultisessionFuture
[09:31:35.538] - received message: FutureResult
[09:31:35.540] - Received FutureResult
[09:31:35.540] - Erased future from FutureRegistry
[09:31:35.540] result() for ClusterFuture ...
[09:31:35.540] - result already collected: FutureResult
[09:31:35.541] result() for ClusterFuture ... done
[09:31:35.541] signalConditions() ...
[09:31:35.541]  - include = ‘immediateCondition’
[09:31:35.541]  - exclude = 
[09:31:35.541]  - resignal = FALSE
[09:31:35.541]  - Number of conditions: 1
[09:31:35.541] signalConditions() ... done
[09:31:35.541] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.541] result() for ClusterFuture ... done
[09:31:35.541] result() for ClusterFuture ...
[09:31:35.541] - result already collected: FutureResult
[09:31:35.541] result() for ClusterFuture ... done
[09:31:35.542] signalConditions() ...
[09:31:35.542]  - include = ‘immediateCondition’
[09:31:35.542]  - exclude = 
[09:31:35.542]  - resignal = FALSE
[09:31:35.542]  - Number of conditions: 1
[09:31:35.542] signalConditions() ... done
[09:31:35.542] Future state: ‘finished’
[09:31:35.542] result() for ClusterFuture ...
[09:31:35.542] - result already collected: FutureResult
[09:31:35.542] result() for ClusterFuture ... done
[09:31:35.542] signalConditions() ...
[09:31:35.543]  - include = ‘condition’
[09:31:35.543]  - exclude = ‘immediateCondition’
[09:31:35.543]  - resignal = TRUE
[09:31:35.543]  - Number of conditions: 1
[09:31:35.543]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:35.543] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:35"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.556] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.557] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.558] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.558] Searching for globals ... DONE
[09:31:35.558] Resolving globals: TRUE
[09:31:35.558] Resolving any globals that are futures ...
[09:31:35.558] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.558] Resolving any globals that are futures ... DONE
[09:31:35.559] Resolving futures part of globals (recursively) ...
[09:31:35.559] resolve() on list ...
[09:31:35.559]  recursive: 99
[09:31:35.559]  length: 1
[09:31:35.559]  elements: ‘ii’
[09:31:35.559]  length: 0 (resolved future 1)
[09:31:35.560] resolve() on list ... DONE
[09:31:35.560] - globals: [1] ‘ii’
[09:31:35.560] Resolving futures part of globals (recursively) ... DONE
[09:31:35.560] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.560] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.560] - globals: [1] ‘ii’
[09:31:35.560] 
[09:31:35.560] getGlobalsAndPackages() ... DONE
[09:31:35.561] run() for ‘Future’ ...
[09:31:35.561] - state: ‘created’
[09:31:35.561] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.575] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.575] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.575]   - Field: ‘node’
[09:31:35.575]   - Field: ‘label’
[09:31:35.575]   - Field: ‘local’
[09:31:35.575]   - Field: ‘owner’
[09:31:35.575]   - Field: ‘envir’
[09:31:35.575]   - Field: ‘workers’
[09:31:35.576]   - Field: ‘packages’
[09:31:35.576]   - Field: ‘gc’
[09:31:35.576]   - Field: ‘conditions’
[09:31:35.576]   - Field: ‘persistent’
[09:31:35.576]   - Field: ‘expr’
[09:31:35.576]   - Field: ‘uuid’
[09:31:35.576]   - Field: ‘seed’
[09:31:35.576]   - Field: ‘version’
[09:31:35.576]   - Field: ‘result’
[09:31:35.576]   - Field: ‘asynchronous’
[09:31:35.576]   - Field: ‘calls’
[09:31:35.577]   - Field: ‘globals’
[09:31:35.577]   - Field: ‘stdout’
[09:31:35.577]   - Field: ‘earlySignal’
[09:31:35.577]   - Field: ‘lazy’
[09:31:35.577]   - Field: ‘state’
[09:31:35.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.577] - Launch lazy future ...
[09:31:35.577] Packages needed by the future expression (n = 0): <none>
[09:31:35.577] Packages needed by future strategies (n = 0): <none>
[09:31:35.578] {
[09:31:35.578]     {
[09:31:35.578]         {
[09:31:35.578]             ...future.startTime <- base::Sys.time()
[09:31:35.578]             {
[09:31:35.578]                 {
[09:31:35.578]                   {
[09:31:35.578]                     {
[09:31:35.578]                       base::local({
[09:31:35.578]                         has_future <- base::requireNamespace("future", 
[09:31:35.578]                           quietly = TRUE)
[09:31:35.578]                         if (has_future) {
[09:31:35.578]                           ns <- base::getNamespace("future")
[09:31:35.578]                           version <- ns[[".package"]][["version"]]
[09:31:35.578]                           if (is.null(version)) 
[09:31:35.578]                             version <- utils::packageVersion("future")
[09:31:35.578]                         }
[09:31:35.578]                         else {
[09:31:35.578]                           version <- NULL
[09:31:35.578]                         }
[09:31:35.578]                         if (!has_future || version < "1.8.0") {
[09:31:35.578]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.578]                             "", base::R.version$version.string), 
[09:31:35.578]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.578]                               "release", "version")], collapse = " "), 
[09:31:35.578]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.578]                             info)
[09:31:35.578]                           info <- base::paste(info, collapse = "; ")
[09:31:35.578]                           if (!has_future) {
[09:31:35.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.578]                               info)
[09:31:35.578]                           }
[09:31:35.578]                           else {
[09:31:35.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.578]                               info, version)
[09:31:35.578]                           }
[09:31:35.578]                           base::stop(msg)
[09:31:35.578]                         }
[09:31:35.578]                       })
[09:31:35.578]                     }
[09:31:35.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.578]                     base::options(mc.cores = 1L)
[09:31:35.578]                   }
[09:31:35.578]                   ...future.strategy.old <- future::plan("list")
[09:31:35.578]                   options(future.plan = NULL)
[09:31:35.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.578]                 }
[09:31:35.578]                 ...future.workdir <- getwd()
[09:31:35.578]             }
[09:31:35.578]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.578]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.578]         }
[09:31:35.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.578]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.578]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.578]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.578]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.578]             base::names(...future.oldOptions))
[09:31:35.578]     }
[09:31:35.578]     if (FALSE) {
[09:31:35.578]     }
[09:31:35.578]     else {
[09:31:35.578]         if (TRUE) {
[09:31:35.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.578]                 open = "w")
[09:31:35.578]         }
[09:31:35.578]         else {
[09:31:35.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.578]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.578]         }
[09:31:35.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.578]             base::sink(type = "output", split = FALSE)
[09:31:35.578]             base::close(...future.stdout)
[09:31:35.578]         }, add = TRUE)
[09:31:35.578]     }
[09:31:35.578]     ...future.frame <- base::sys.nframe()
[09:31:35.578]     ...future.conditions <- base::list()
[09:31:35.578]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.578]     if (FALSE) {
[09:31:35.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.578]     }
[09:31:35.578]     ...future.result <- base::tryCatch({
[09:31:35.578]         base::withCallingHandlers({
[09:31:35.578]             ...future.value <- base::withVisible(base::local({
[09:31:35.578]                 ...future.makeSendCondition <- base::local({
[09:31:35.578]                   sendCondition <- NULL
[09:31:35.578]                   function(frame = 1L) {
[09:31:35.578]                     if (is.function(sendCondition)) 
[09:31:35.578]                       return(sendCondition)
[09:31:35.578]                     ns <- getNamespace("parallel")
[09:31:35.578]                     if (exists("sendData", mode = "function", 
[09:31:35.578]                       envir = ns)) {
[09:31:35.578]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.578]                         envir = ns)
[09:31:35.578]                       envir <- sys.frame(frame)
[09:31:35.578]                       master <- NULL
[09:31:35.578]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.578]                         !identical(envir, emptyenv())) {
[09:31:35.578]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.578]                           inherits = FALSE)) {
[09:31:35.578]                           master <- get("master", mode = "list", 
[09:31:35.578]                             envir = envir, inherits = FALSE)
[09:31:35.578]                           if (inherits(master, c("SOCKnode", 
[09:31:35.578]                             "SOCK0node"))) {
[09:31:35.578]                             sendCondition <<- function(cond) {
[09:31:35.578]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.578]                                 success = TRUE)
[09:31:35.578]                               parallel_sendData(master, data)
[09:31:35.578]                             }
[09:31:35.578]                             return(sendCondition)
[09:31:35.578]                           }
[09:31:35.578]                         }
[09:31:35.578]                         frame <- frame + 1L
[09:31:35.578]                         envir <- sys.frame(frame)
[09:31:35.578]                       }
[09:31:35.578]                     }
[09:31:35.578]                     sendCondition <<- function(cond) NULL
[09:31:35.578]                   }
[09:31:35.578]                 })
[09:31:35.578]                 withCallingHandlers({
[09:31:35.578]                   {
[09:31:35.578]                     b <- a * ii
[09:31:35.578]                     a <- 0
[09:31:35.578]                     b
[09:31:35.578]                   }
[09:31:35.578]                 }, immediateCondition = function(cond) {
[09:31:35.578]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.578]                   sendCondition(cond)
[09:31:35.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.578]                   {
[09:31:35.578]                     inherits <- base::inherits
[09:31:35.578]                     invokeRestart <- base::invokeRestart
[09:31:35.578]                     is.null <- base::is.null
[09:31:35.578]                     muffled <- FALSE
[09:31:35.578]                     if (inherits(cond, "message")) {
[09:31:35.578]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.578]                       if (muffled) 
[09:31:35.578]                         invokeRestart("muffleMessage")
[09:31:35.578]                     }
[09:31:35.578]                     else if (inherits(cond, "warning")) {
[09:31:35.578]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.578]                       if (muffled) 
[09:31:35.578]                         invokeRestart("muffleWarning")
[09:31:35.578]                     }
[09:31:35.578]                     else if (inherits(cond, "condition")) {
[09:31:35.578]                       if (!is.null(pattern)) {
[09:31:35.578]                         computeRestarts <- base::computeRestarts
[09:31:35.578]                         grepl <- base::grepl
[09:31:35.578]                         restarts <- computeRestarts(cond)
[09:31:35.578]                         for (restart in restarts) {
[09:31:35.578]                           name <- restart$name
[09:31:35.578]                           if (is.null(name)) 
[09:31:35.578]                             next
[09:31:35.578]                           if (!grepl(pattern, name)) 
[09:31:35.578]                             next
[09:31:35.578]                           invokeRestart(restart)
[09:31:35.578]                           muffled <- TRUE
[09:31:35.578]                           break
[09:31:35.578]                         }
[09:31:35.578]                       }
[09:31:35.578]                     }
[09:31:35.578]                     invisible(muffled)
[09:31:35.578]                   }
[09:31:35.578]                   muffleCondition(cond)
[09:31:35.578]                 })
[09:31:35.578]             }))
[09:31:35.578]             future::FutureResult(value = ...future.value$value, 
[09:31:35.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.578]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.578]                     ...future.globalenv.names))
[09:31:35.578]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.578]         }, condition = base::local({
[09:31:35.578]             c <- base::c
[09:31:35.578]             inherits <- base::inherits
[09:31:35.578]             invokeRestart <- base::invokeRestart
[09:31:35.578]             length <- base::length
[09:31:35.578]             list <- base::list
[09:31:35.578]             seq.int <- base::seq.int
[09:31:35.578]             signalCondition <- base::signalCondition
[09:31:35.578]             sys.calls <- base::sys.calls
[09:31:35.578]             `[[` <- base::`[[`
[09:31:35.578]             `+` <- base::`+`
[09:31:35.578]             `<<-` <- base::`<<-`
[09:31:35.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.578]                   3L)]
[09:31:35.578]             }
[09:31:35.578]             function(cond) {
[09:31:35.578]                 is_error <- inherits(cond, "error")
[09:31:35.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.578]                   NULL)
[09:31:35.578]                 if (is_error) {
[09:31:35.578]                   sessionInformation <- function() {
[09:31:35.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.578]                       search = base::search(), system = base::Sys.info())
[09:31:35.578]                   }
[09:31:35.578]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.578]                     cond$call), session = sessionInformation(), 
[09:31:35.578]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.578]                   signalCondition(cond)
[09:31:35.578]                 }
[09:31:35.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.578]                 "immediateCondition"))) {
[09:31:35.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.578]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.578]                   if (TRUE && !signal) {
[09:31:35.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.578]                     {
[09:31:35.578]                       inherits <- base::inherits
[09:31:35.578]                       invokeRestart <- base::invokeRestart
[09:31:35.578]                       is.null <- base::is.null
[09:31:35.578]                       muffled <- FALSE
[09:31:35.578]                       if (inherits(cond, "message")) {
[09:31:35.578]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.578]                         if (muffled) 
[09:31:35.578]                           invokeRestart("muffleMessage")
[09:31:35.578]                       }
[09:31:35.578]                       else if (inherits(cond, "warning")) {
[09:31:35.578]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.578]                         if (muffled) 
[09:31:35.578]                           invokeRestart("muffleWarning")
[09:31:35.578]                       }
[09:31:35.578]                       else if (inherits(cond, "condition")) {
[09:31:35.578]                         if (!is.null(pattern)) {
[09:31:35.578]                           computeRestarts <- base::computeRestarts
[09:31:35.578]                           grepl <- base::grepl
[09:31:35.578]                           restarts <- computeRestarts(cond)
[09:31:35.578]                           for (restart in restarts) {
[09:31:35.578]                             name <- restart$name
[09:31:35.578]                             if (is.null(name)) 
[09:31:35.578]                               next
[09:31:35.578]                             if (!grepl(pattern, name)) 
[09:31:35.578]                               next
[09:31:35.578]                             invokeRestart(restart)
[09:31:35.578]                             muffled <- TRUE
[09:31:35.578]                             break
[09:31:35.578]                           }
[09:31:35.578]                         }
[09:31:35.578]                       }
[09:31:35.578]                       invisible(muffled)
[09:31:35.578]                     }
[09:31:35.578]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.578]                   }
[09:31:35.578]                 }
[09:31:35.578]                 else {
[09:31:35.578]                   if (TRUE) {
[09:31:35.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.578]                     {
[09:31:35.578]                       inherits <- base::inherits
[09:31:35.578]                       invokeRestart <- base::invokeRestart
[09:31:35.578]                       is.null <- base::is.null
[09:31:35.578]                       muffled <- FALSE
[09:31:35.578]                       if (inherits(cond, "message")) {
[09:31:35.578]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.578]                         if (muffled) 
[09:31:35.578]                           invokeRestart("muffleMessage")
[09:31:35.578]                       }
[09:31:35.578]                       else if (inherits(cond, "warning")) {
[09:31:35.578]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.578]                         if (muffled) 
[09:31:35.578]                           invokeRestart("muffleWarning")
[09:31:35.578]                       }
[09:31:35.578]                       else if (inherits(cond, "condition")) {
[09:31:35.578]                         if (!is.null(pattern)) {
[09:31:35.578]                           computeRestarts <- base::computeRestarts
[09:31:35.578]                           grepl <- base::grepl
[09:31:35.578]                           restarts <- computeRestarts(cond)
[09:31:35.578]                           for (restart in restarts) {
[09:31:35.578]                             name <- restart$name
[09:31:35.578]                             if (is.null(name)) 
[09:31:35.578]                               next
[09:31:35.578]                             if (!grepl(pattern, name)) 
[09:31:35.578]                               next
[09:31:35.578]                             invokeRestart(restart)
[09:31:35.578]                             muffled <- TRUE
[09:31:35.578]                             break
[09:31:35.578]                           }
[09:31:35.578]                         }
[09:31:35.578]                       }
[09:31:35.578]                       invisible(muffled)
[09:31:35.578]                     }
[09:31:35.578]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.578]                   }
[09:31:35.578]                 }
[09:31:35.578]             }
[09:31:35.578]         }))
[09:31:35.578]     }, error = function(ex) {
[09:31:35.578]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.578]                 ...future.rng), started = ...future.startTime, 
[09:31:35.578]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.578]             version = "1.8"), class = "FutureResult")
[09:31:35.578]     }, finally = {
[09:31:35.578]         if (!identical(...future.workdir, getwd())) 
[09:31:35.578]             setwd(...future.workdir)
[09:31:35.578]         {
[09:31:35.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.578]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.578]             }
[09:31:35.578]             base::options(...future.oldOptions)
[09:31:35.578]             if (.Platform$OS.type == "windows") {
[09:31:35.578]                 old_names <- names(...future.oldEnvVars)
[09:31:35.578]                 envs <- base::Sys.getenv()
[09:31:35.578]                 names <- names(envs)
[09:31:35.578]                 common <- intersect(names, old_names)
[09:31:35.578]                 added <- setdiff(names, old_names)
[09:31:35.578]                 removed <- setdiff(old_names, names)
[09:31:35.578]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.578]                   envs[common]]
[09:31:35.578]                 NAMES <- toupper(changed)
[09:31:35.578]                 args <- list()
[09:31:35.578]                 for (kk in seq_along(NAMES)) {
[09:31:35.578]                   name <- changed[[kk]]
[09:31:35.578]                   NAME <- NAMES[[kk]]
[09:31:35.578]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.578]                     next
[09:31:35.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.578]                 }
[09:31:35.578]                 NAMES <- toupper(added)
[09:31:35.578]                 for (kk in seq_along(NAMES)) {
[09:31:35.578]                   name <- added[[kk]]
[09:31:35.578]                   NAME <- NAMES[[kk]]
[09:31:35.578]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.578]                     next
[09:31:35.578]                   args[[name]] <- ""
[09:31:35.578]                 }
[09:31:35.578]                 NAMES <- toupper(removed)
[09:31:35.578]                 for (kk in seq_along(NAMES)) {
[09:31:35.578]                   name <- removed[[kk]]
[09:31:35.578]                   NAME <- NAMES[[kk]]
[09:31:35.578]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.578]                     next
[09:31:35.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.578]                 }
[09:31:35.578]                 if (length(args) > 0) 
[09:31:35.578]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.578]             }
[09:31:35.578]             else {
[09:31:35.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.578]             }
[09:31:35.578]             {
[09:31:35.578]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.578]                   0L) {
[09:31:35.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.578]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.578]                   base::options(opts)
[09:31:35.578]                 }
[09:31:35.578]                 {
[09:31:35.578]                   {
[09:31:35.578]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.578]                     NULL
[09:31:35.578]                   }
[09:31:35.578]                   options(future.plan = NULL)
[09:31:35.578]                   if (is.na(NA_character_)) 
[09:31:35.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.578]                     .init = FALSE)
[09:31:35.578]                 }
[09:31:35.578]             }
[09:31:35.578]         }
[09:31:35.578]     })
[09:31:35.578]     if (TRUE) {
[09:31:35.578]         base::sink(type = "output", split = FALSE)
[09:31:35.578]         if (TRUE) {
[09:31:35.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.578]         }
[09:31:35.578]         else {
[09:31:35.578]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.578]         }
[09:31:35.578]         base::close(...future.stdout)
[09:31:35.578]         ...future.stdout <- NULL
[09:31:35.578]     }
[09:31:35.578]     ...future.result$conditions <- ...future.conditions
[09:31:35.578]     ...future.result$finished <- base::Sys.time()
[09:31:35.578]     ...future.result
[09:31:35.578] }
[09:31:35.580] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:31:35.580] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:35.581] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:35.581] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:31:35.582] MultisessionFuture started
[09:31:35.582] - Launch lazy future ... done
[09:31:35.582] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.583] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.583] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.585] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.585] Searching for globals ... DONE
[09:31:35.585] Resolving globals: TRUE
[09:31:35.585] Resolving any globals that are futures ...
[09:31:35.585] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.585] Resolving any globals that are futures ... DONE
[09:31:35.586] Resolving futures part of globals (recursively) ...
[09:31:35.586] resolve() on list ...
[09:31:35.586]  recursive: 99
[09:31:35.586]  length: 1
[09:31:35.586]  elements: ‘ii’
[09:31:35.586]  length: 0 (resolved future 1)
[09:31:35.586] resolve() on list ... DONE
[09:31:35.586] - globals: [1] ‘ii’
[09:31:35.586] Resolving futures part of globals (recursively) ... DONE
[09:31:35.587] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.587] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.587] - globals: [1] ‘ii’
[09:31:35.587] 
[09:31:35.587] getGlobalsAndPackages() ... DONE
[09:31:35.587] run() for ‘Future’ ...
[09:31:35.587] - state: ‘created’
[09:31:35.588] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.601] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.601]   - Field: ‘node’
[09:31:35.601]   - Field: ‘label’
[09:31:35.601]   - Field: ‘local’
[09:31:35.601]   - Field: ‘owner’
[09:31:35.601]   - Field: ‘envir’
[09:31:35.601]   - Field: ‘workers’
[09:31:35.601]   - Field: ‘packages’
[09:31:35.602]   - Field: ‘gc’
[09:31:35.602]   - Field: ‘conditions’
[09:31:35.602]   - Field: ‘persistent’
[09:31:35.602]   - Field: ‘expr’
[09:31:35.602]   - Field: ‘uuid’
[09:31:35.602]   - Field: ‘seed’
[09:31:35.602]   - Field: ‘version’
[09:31:35.602]   - Field: ‘result’
[09:31:35.602]   - Field: ‘asynchronous’
[09:31:35.602]   - Field: ‘calls’
[09:31:35.602]   - Field: ‘globals’
[09:31:35.602]   - Field: ‘stdout’
[09:31:35.603]   - Field: ‘earlySignal’
[09:31:35.603]   - Field: ‘lazy’
[09:31:35.603]   - Field: ‘state’
[09:31:35.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.603] - Launch lazy future ...
[09:31:35.603] Packages needed by the future expression (n = 0): <none>
[09:31:35.603] Packages needed by future strategies (n = 0): <none>
[09:31:35.604] {
[09:31:35.604]     {
[09:31:35.604]         {
[09:31:35.604]             ...future.startTime <- base::Sys.time()
[09:31:35.604]             {
[09:31:35.604]                 {
[09:31:35.604]                   {
[09:31:35.604]                     {
[09:31:35.604]                       base::local({
[09:31:35.604]                         has_future <- base::requireNamespace("future", 
[09:31:35.604]                           quietly = TRUE)
[09:31:35.604]                         if (has_future) {
[09:31:35.604]                           ns <- base::getNamespace("future")
[09:31:35.604]                           version <- ns[[".package"]][["version"]]
[09:31:35.604]                           if (is.null(version)) 
[09:31:35.604]                             version <- utils::packageVersion("future")
[09:31:35.604]                         }
[09:31:35.604]                         else {
[09:31:35.604]                           version <- NULL
[09:31:35.604]                         }
[09:31:35.604]                         if (!has_future || version < "1.8.0") {
[09:31:35.604]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.604]                             "", base::R.version$version.string), 
[09:31:35.604]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.604]                               "release", "version")], collapse = " "), 
[09:31:35.604]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.604]                             info)
[09:31:35.604]                           info <- base::paste(info, collapse = "; ")
[09:31:35.604]                           if (!has_future) {
[09:31:35.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.604]                               info)
[09:31:35.604]                           }
[09:31:35.604]                           else {
[09:31:35.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.604]                               info, version)
[09:31:35.604]                           }
[09:31:35.604]                           base::stop(msg)
[09:31:35.604]                         }
[09:31:35.604]                       })
[09:31:35.604]                     }
[09:31:35.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.604]                     base::options(mc.cores = 1L)
[09:31:35.604]                   }
[09:31:35.604]                   ...future.strategy.old <- future::plan("list")
[09:31:35.604]                   options(future.plan = NULL)
[09:31:35.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.604]                 }
[09:31:35.604]                 ...future.workdir <- getwd()
[09:31:35.604]             }
[09:31:35.604]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.604]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.604]         }
[09:31:35.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.604]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.604]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.604]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.604]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.604]             base::names(...future.oldOptions))
[09:31:35.604]     }
[09:31:35.604]     if (FALSE) {
[09:31:35.604]     }
[09:31:35.604]     else {
[09:31:35.604]         if (TRUE) {
[09:31:35.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.604]                 open = "w")
[09:31:35.604]         }
[09:31:35.604]         else {
[09:31:35.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.604]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.604]         }
[09:31:35.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.604]             base::sink(type = "output", split = FALSE)
[09:31:35.604]             base::close(...future.stdout)
[09:31:35.604]         }, add = TRUE)
[09:31:35.604]     }
[09:31:35.604]     ...future.frame <- base::sys.nframe()
[09:31:35.604]     ...future.conditions <- base::list()
[09:31:35.604]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.604]     if (FALSE) {
[09:31:35.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.604]     }
[09:31:35.604]     ...future.result <- base::tryCatch({
[09:31:35.604]         base::withCallingHandlers({
[09:31:35.604]             ...future.value <- base::withVisible(base::local({
[09:31:35.604]                 ...future.makeSendCondition <- base::local({
[09:31:35.604]                   sendCondition <- NULL
[09:31:35.604]                   function(frame = 1L) {
[09:31:35.604]                     if (is.function(sendCondition)) 
[09:31:35.604]                       return(sendCondition)
[09:31:35.604]                     ns <- getNamespace("parallel")
[09:31:35.604]                     if (exists("sendData", mode = "function", 
[09:31:35.604]                       envir = ns)) {
[09:31:35.604]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.604]                         envir = ns)
[09:31:35.604]                       envir <- sys.frame(frame)
[09:31:35.604]                       master <- NULL
[09:31:35.604]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.604]                         !identical(envir, emptyenv())) {
[09:31:35.604]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.604]                           inherits = FALSE)) {
[09:31:35.604]                           master <- get("master", mode = "list", 
[09:31:35.604]                             envir = envir, inherits = FALSE)
[09:31:35.604]                           if (inherits(master, c("SOCKnode", 
[09:31:35.604]                             "SOCK0node"))) {
[09:31:35.604]                             sendCondition <<- function(cond) {
[09:31:35.604]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.604]                                 success = TRUE)
[09:31:35.604]                               parallel_sendData(master, data)
[09:31:35.604]                             }
[09:31:35.604]                             return(sendCondition)
[09:31:35.604]                           }
[09:31:35.604]                         }
[09:31:35.604]                         frame <- frame + 1L
[09:31:35.604]                         envir <- sys.frame(frame)
[09:31:35.604]                       }
[09:31:35.604]                     }
[09:31:35.604]                     sendCondition <<- function(cond) NULL
[09:31:35.604]                   }
[09:31:35.604]                 })
[09:31:35.604]                 withCallingHandlers({
[09:31:35.604]                   {
[09:31:35.604]                     b <- a * ii
[09:31:35.604]                     a <- 0
[09:31:35.604]                     b
[09:31:35.604]                   }
[09:31:35.604]                 }, immediateCondition = function(cond) {
[09:31:35.604]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.604]                   sendCondition(cond)
[09:31:35.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.604]                   {
[09:31:35.604]                     inherits <- base::inherits
[09:31:35.604]                     invokeRestart <- base::invokeRestart
[09:31:35.604]                     is.null <- base::is.null
[09:31:35.604]                     muffled <- FALSE
[09:31:35.604]                     if (inherits(cond, "message")) {
[09:31:35.604]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.604]                       if (muffled) 
[09:31:35.604]                         invokeRestart("muffleMessage")
[09:31:35.604]                     }
[09:31:35.604]                     else if (inherits(cond, "warning")) {
[09:31:35.604]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.604]                       if (muffled) 
[09:31:35.604]                         invokeRestart("muffleWarning")
[09:31:35.604]                     }
[09:31:35.604]                     else if (inherits(cond, "condition")) {
[09:31:35.604]                       if (!is.null(pattern)) {
[09:31:35.604]                         computeRestarts <- base::computeRestarts
[09:31:35.604]                         grepl <- base::grepl
[09:31:35.604]                         restarts <- computeRestarts(cond)
[09:31:35.604]                         for (restart in restarts) {
[09:31:35.604]                           name <- restart$name
[09:31:35.604]                           if (is.null(name)) 
[09:31:35.604]                             next
[09:31:35.604]                           if (!grepl(pattern, name)) 
[09:31:35.604]                             next
[09:31:35.604]                           invokeRestart(restart)
[09:31:35.604]                           muffled <- TRUE
[09:31:35.604]                           break
[09:31:35.604]                         }
[09:31:35.604]                       }
[09:31:35.604]                     }
[09:31:35.604]                     invisible(muffled)
[09:31:35.604]                   }
[09:31:35.604]                   muffleCondition(cond)
[09:31:35.604]                 })
[09:31:35.604]             }))
[09:31:35.604]             future::FutureResult(value = ...future.value$value, 
[09:31:35.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.604]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.604]                     ...future.globalenv.names))
[09:31:35.604]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.604]         }, condition = base::local({
[09:31:35.604]             c <- base::c
[09:31:35.604]             inherits <- base::inherits
[09:31:35.604]             invokeRestart <- base::invokeRestart
[09:31:35.604]             length <- base::length
[09:31:35.604]             list <- base::list
[09:31:35.604]             seq.int <- base::seq.int
[09:31:35.604]             signalCondition <- base::signalCondition
[09:31:35.604]             sys.calls <- base::sys.calls
[09:31:35.604]             `[[` <- base::`[[`
[09:31:35.604]             `+` <- base::`+`
[09:31:35.604]             `<<-` <- base::`<<-`
[09:31:35.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.604]                   3L)]
[09:31:35.604]             }
[09:31:35.604]             function(cond) {
[09:31:35.604]                 is_error <- inherits(cond, "error")
[09:31:35.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.604]                   NULL)
[09:31:35.604]                 if (is_error) {
[09:31:35.604]                   sessionInformation <- function() {
[09:31:35.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.604]                       search = base::search(), system = base::Sys.info())
[09:31:35.604]                   }
[09:31:35.604]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.604]                     cond$call), session = sessionInformation(), 
[09:31:35.604]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.604]                   signalCondition(cond)
[09:31:35.604]                 }
[09:31:35.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.604]                 "immediateCondition"))) {
[09:31:35.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.604]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.604]                   if (TRUE && !signal) {
[09:31:35.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.604]                     {
[09:31:35.604]                       inherits <- base::inherits
[09:31:35.604]                       invokeRestart <- base::invokeRestart
[09:31:35.604]                       is.null <- base::is.null
[09:31:35.604]                       muffled <- FALSE
[09:31:35.604]                       if (inherits(cond, "message")) {
[09:31:35.604]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.604]                         if (muffled) 
[09:31:35.604]                           invokeRestart("muffleMessage")
[09:31:35.604]                       }
[09:31:35.604]                       else if (inherits(cond, "warning")) {
[09:31:35.604]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.604]                         if (muffled) 
[09:31:35.604]                           invokeRestart("muffleWarning")
[09:31:35.604]                       }
[09:31:35.604]                       else if (inherits(cond, "condition")) {
[09:31:35.604]                         if (!is.null(pattern)) {
[09:31:35.604]                           computeRestarts <- base::computeRestarts
[09:31:35.604]                           grepl <- base::grepl
[09:31:35.604]                           restarts <- computeRestarts(cond)
[09:31:35.604]                           for (restart in restarts) {
[09:31:35.604]                             name <- restart$name
[09:31:35.604]                             if (is.null(name)) 
[09:31:35.604]                               next
[09:31:35.604]                             if (!grepl(pattern, name)) 
[09:31:35.604]                               next
[09:31:35.604]                             invokeRestart(restart)
[09:31:35.604]                             muffled <- TRUE
[09:31:35.604]                             break
[09:31:35.604]                           }
[09:31:35.604]                         }
[09:31:35.604]                       }
[09:31:35.604]                       invisible(muffled)
[09:31:35.604]                     }
[09:31:35.604]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.604]                   }
[09:31:35.604]                 }
[09:31:35.604]                 else {
[09:31:35.604]                   if (TRUE) {
[09:31:35.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.604]                     {
[09:31:35.604]                       inherits <- base::inherits
[09:31:35.604]                       invokeRestart <- base::invokeRestart
[09:31:35.604]                       is.null <- base::is.null
[09:31:35.604]                       muffled <- FALSE
[09:31:35.604]                       if (inherits(cond, "message")) {
[09:31:35.604]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.604]                         if (muffled) 
[09:31:35.604]                           invokeRestart("muffleMessage")
[09:31:35.604]                       }
[09:31:35.604]                       else if (inherits(cond, "warning")) {
[09:31:35.604]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.604]                         if (muffled) 
[09:31:35.604]                           invokeRestart("muffleWarning")
[09:31:35.604]                       }
[09:31:35.604]                       else if (inherits(cond, "condition")) {
[09:31:35.604]                         if (!is.null(pattern)) {
[09:31:35.604]                           computeRestarts <- base::computeRestarts
[09:31:35.604]                           grepl <- base::grepl
[09:31:35.604]                           restarts <- computeRestarts(cond)
[09:31:35.604]                           for (restart in restarts) {
[09:31:35.604]                             name <- restart$name
[09:31:35.604]                             if (is.null(name)) 
[09:31:35.604]                               next
[09:31:35.604]                             if (!grepl(pattern, name)) 
[09:31:35.604]                               next
[09:31:35.604]                             invokeRestart(restart)
[09:31:35.604]                             muffled <- TRUE
[09:31:35.604]                             break
[09:31:35.604]                           }
[09:31:35.604]                         }
[09:31:35.604]                       }
[09:31:35.604]                       invisible(muffled)
[09:31:35.604]                     }
[09:31:35.604]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.604]                   }
[09:31:35.604]                 }
[09:31:35.604]             }
[09:31:35.604]         }))
[09:31:35.604]     }, error = function(ex) {
[09:31:35.604]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.604]                 ...future.rng), started = ...future.startTime, 
[09:31:35.604]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.604]             version = "1.8"), class = "FutureResult")
[09:31:35.604]     }, finally = {
[09:31:35.604]         if (!identical(...future.workdir, getwd())) 
[09:31:35.604]             setwd(...future.workdir)
[09:31:35.604]         {
[09:31:35.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.604]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.604]             }
[09:31:35.604]             base::options(...future.oldOptions)
[09:31:35.604]             if (.Platform$OS.type == "windows") {
[09:31:35.604]                 old_names <- names(...future.oldEnvVars)
[09:31:35.604]                 envs <- base::Sys.getenv()
[09:31:35.604]                 names <- names(envs)
[09:31:35.604]                 common <- intersect(names, old_names)
[09:31:35.604]                 added <- setdiff(names, old_names)
[09:31:35.604]                 removed <- setdiff(old_names, names)
[09:31:35.604]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.604]                   envs[common]]
[09:31:35.604]                 NAMES <- toupper(changed)
[09:31:35.604]                 args <- list()
[09:31:35.604]                 for (kk in seq_along(NAMES)) {
[09:31:35.604]                   name <- changed[[kk]]
[09:31:35.604]                   NAME <- NAMES[[kk]]
[09:31:35.604]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.604]                     next
[09:31:35.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.604]                 }
[09:31:35.604]                 NAMES <- toupper(added)
[09:31:35.604]                 for (kk in seq_along(NAMES)) {
[09:31:35.604]                   name <- added[[kk]]
[09:31:35.604]                   NAME <- NAMES[[kk]]
[09:31:35.604]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.604]                     next
[09:31:35.604]                   args[[name]] <- ""
[09:31:35.604]                 }
[09:31:35.604]                 NAMES <- toupper(removed)
[09:31:35.604]                 for (kk in seq_along(NAMES)) {
[09:31:35.604]                   name <- removed[[kk]]
[09:31:35.604]                   NAME <- NAMES[[kk]]
[09:31:35.604]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.604]                     next
[09:31:35.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.604]                 }
[09:31:35.604]                 if (length(args) > 0) 
[09:31:35.604]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.604]             }
[09:31:35.604]             else {
[09:31:35.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.604]             }
[09:31:35.604]             {
[09:31:35.604]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.604]                   0L) {
[09:31:35.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.604]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.604]                   base::options(opts)
[09:31:35.604]                 }
[09:31:35.604]                 {
[09:31:35.604]                   {
[09:31:35.604]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.604]                     NULL
[09:31:35.604]                   }
[09:31:35.604]                   options(future.plan = NULL)
[09:31:35.604]                   if (is.na(NA_character_)) 
[09:31:35.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.604]                     .init = FALSE)
[09:31:35.604]                 }
[09:31:35.604]             }
[09:31:35.604]         }
[09:31:35.604]     })
[09:31:35.604]     if (TRUE) {
[09:31:35.604]         base::sink(type = "output", split = FALSE)
[09:31:35.604]         if (TRUE) {
[09:31:35.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.604]         }
[09:31:35.604]         else {
[09:31:35.604]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.604]         }
[09:31:35.604]         base::close(...future.stdout)
[09:31:35.604]         ...future.stdout <- NULL
[09:31:35.604]     }
[09:31:35.604]     ...future.result$conditions <- ...future.conditions
[09:31:35.604]     ...future.result$finished <- base::Sys.time()
[09:31:35.604]     ...future.result
[09:31:35.604] }
[09:31:35.656] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:31:35.656] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[09:31:35.657] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[09:31:35.657] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:31:35.657] MultisessionFuture started
[09:31:35.658] - Launch lazy future ... done
[09:31:35.658] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.658] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.658] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.660] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.660] Searching for globals ... DONE
[09:31:35.660] Resolving globals: TRUE
[09:31:35.660] Resolving any globals that are futures ...
[09:31:35.660] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.660] Resolving any globals that are futures ... DONE
[09:31:35.661] Resolving futures part of globals (recursively) ...
[09:31:35.661] resolve() on list ...
[09:31:35.661]  recursive: 99
[09:31:35.661]  length: 1
[09:31:35.661]  elements: ‘ii’
[09:31:35.661]  length: 0 (resolved future 1)
[09:31:35.661] resolve() on list ... DONE
[09:31:35.661] - globals: [1] ‘ii’
[09:31:35.662] Resolving futures part of globals (recursively) ... DONE
[09:31:35.662] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.662] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.662] - globals: [1] ‘ii’
[09:31:35.662] 
[09:31:35.662] getGlobalsAndPackages() ... DONE
[09:31:35.663] run() for ‘Future’ ...
[09:31:35.663] - state: ‘created’
[09:31:35.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.677]   - Field: ‘node’
[09:31:35.677]   - Field: ‘label’
[09:31:35.677]   - Field: ‘local’
[09:31:35.677]   - Field: ‘owner’
[09:31:35.677]   - Field: ‘envir’
[09:31:35.677]   - Field: ‘workers’
[09:31:35.677]   - Field: ‘packages’
[09:31:35.677]   - Field: ‘gc’
[09:31:35.678]   - Field: ‘conditions’
[09:31:35.678]   - Field: ‘persistent’
[09:31:35.678]   - Field: ‘expr’
[09:31:35.678]   - Field: ‘uuid’
[09:31:35.678]   - Field: ‘seed’
[09:31:35.678]   - Field: ‘version’
[09:31:35.678]   - Field: ‘result’
[09:31:35.678]   - Field: ‘asynchronous’
[09:31:35.678]   - Field: ‘calls’
[09:31:35.678]   - Field: ‘globals’
[09:31:35.678]   - Field: ‘stdout’
[09:31:35.679]   - Field: ‘earlySignal’
[09:31:35.679]   - Field: ‘lazy’
[09:31:35.679]   - Field: ‘state’
[09:31:35.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.679] - Launch lazy future ...
[09:31:35.679] Packages needed by the future expression (n = 0): <none>
[09:31:35.679] Packages needed by future strategies (n = 0): <none>
[09:31:35.680] {
[09:31:35.680]     {
[09:31:35.680]         {
[09:31:35.680]             ...future.startTime <- base::Sys.time()
[09:31:35.680]             {
[09:31:35.680]                 {
[09:31:35.680]                   {
[09:31:35.680]                     {
[09:31:35.680]                       base::local({
[09:31:35.680]                         has_future <- base::requireNamespace("future", 
[09:31:35.680]                           quietly = TRUE)
[09:31:35.680]                         if (has_future) {
[09:31:35.680]                           ns <- base::getNamespace("future")
[09:31:35.680]                           version <- ns[[".package"]][["version"]]
[09:31:35.680]                           if (is.null(version)) 
[09:31:35.680]                             version <- utils::packageVersion("future")
[09:31:35.680]                         }
[09:31:35.680]                         else {
[09:31:35.680]                           version <- NULL
[09:31:35.680]                         }
[09:31:35.680]                         if (!has_future || version < "1.8.0") {
[09:31:35.680]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.680]                             "", base::R.version$version.string), 
[09:31:35.680]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.680]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.680]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.680]                               "release", "version")], collapse = " "), 
[09:31:35.680]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.680]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.680]                             info)
[09:31:35.680]                           info <- base::paste(info, collapse = "; ")
[09:31:35.680]                           if (!has_future) {
[09:31:35.680]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.680]                               info)
[09:31:35.680]                           }
[09:31:35.680]                           else {
[09:31:35.680]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.680]                               info, version)
[09:31:35.680]                           }
[09:31:35.680]                           base::stop(msg)
[09:31:35.680]                         }
[09:31:35.680]                       })
[09:31:35.680]                     }
[09:31:35.680]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.680]                     base::options(mc.cores = 1L)
[09:31:35.680]                   }
[09:31:35.680]                   ...future.strategy.old <- future::plan("list")
[09:31:35.680]                   options(future.plan = NULL)
[09:31:35.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.680]                 }
[09:31:35.680]                 ...future.workdir <- getwd()
[09:31:35.680]             }
[09:31:35.680]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.680]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.680]         }
[09:31:35.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.680]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.680]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.680]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.680]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.680]             base::names(...future.oldOptions))
[09:31:35.680]     }
[09:31:35.680]     if (FALSE) {
[09:31:35.680]     }
[09:31:35.680]     else {
[09:31:35.680]         if (TRUE) {
[09:31:35.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.680]                 open = "w")
[09:31:35.680]         }
[09:31:35.680]         else {
[09:31:35.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.680]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.680]         }
[09:31:35.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.680]             base::sink(type = "output", split = FALSE)
[09:31:35.680]             base::close(...future.stdout)
[09:31:35.680]         }, add = TRUE)
[09:31:35.680]     }
[09:31:35.680]     ...future.frame <- base::sys.nframe()
[09:31:35.680]     ...future.conditions <- base::list()
[09:31:35.680]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.680]     if (FALSE) {
[09:31:35.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.680]     }
[09:31:35.680]     ...future.result <- base::tryCatch({
[09:31:35.680]         base::withCallingHandlers({
[09:31:35.680]             ...future.value <- base::withVisible(base::local({
[09:31:35.680]                 ...future.makeSendCondition <- base::local({
[09:31:35.680]                   sendCondition <- NULL
[09:31:35.680]                   function(frame = 1L) {
[09:31:35.680]                     if (is.function(sendCondition)) 
[09:31:35.680]                       return(sendCondition)
[09:31:35.680]                     ns <- getNamespace("parallel")
[09:31:35.680]                     if (exists("sendData", mode = "function", 
[09:31:35.680]                       envir = ns)) {
[09:31:35.680]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.680]                         envir = ns)
[09:31:35.680]                       envir <- sys.frame(frame)
[09:31:35.680]                       master <- NULL
[09:31:35.680]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.680]                         !identical(envir, emptyenv())) {
[09:31:35.680]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.680]                           inherits = FALSE)) {
[09:31:35.680]                           master <- get("master", mode = "list", 
[09:31:35.680]                             envir = envir, inherits = FALSE)
[09:31:35.680]                           if (inherits(master, c("SOCKnode", 
[09:31:35.680]                             "SOCK0node"))) {
[09:31:35.680]                             sendCondition <<- function(cond) {
[09:31:35.680]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.680]                                 success = TRUE)
[09:31:35.680]                               parallel_sendData(master, data)
[09:31:35.680]                             }
[09:31:35.680]                             return(sendCondition)
[09:31:35.680]                           }
[09:31:35.680]                         }
[09:31:35.680]                         frame <- frame + 1L
[09:31:35.680]                         envir <- sys.frame(frame)
[09:31:35.680]                       }
[09:31:35.680]                     }
[09:31:35.680]                     sendCondition <<- function(cond) NULL
[09:31:35.680]                   }
[09:31:35.680]                 })
[09:31:35.680]                 withCallingHandlers({
[09:31:35.680]                   {
[09:31:35.680]                     b <- a * ii
[09:31:35.680]                     a <- 0
[09:31:35.680]                     b
[09:31:35.680]                   }
[09:31:35.680]                 }, immediateCondition = function(cond) {
[09:31:35.680]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.680]                   sendCondition(cond)
[09:31:35.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.680]                   {
[09:31:35.680]                     inherits <- base::inherits
[09:31:35.680]                     invokeRestart <- base::invokeRestart
[09:31:35.680]                     is.null <- base::is.null
[09:31:35.680]                     muffled <- FALSE
[09:31:35.680]                     if (inherits(cond, "message")) {
[09:31:35.680]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.680]                       if (muffled) 
[09:31:35.680]                         invokeRestart("muffleMessage")
[09:31:35.680]                     }
[09:31:35.680]                     else if (inherits(cond, "warning")) {
[09:31:35.680]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.680]                       if (muffled) 
[09:31:35.680]                         invokeRestart("muffleWarning")
[09:31:35.680]                     }
[09:31:35.680]                     else if (inherits(cond, "condition")) {
[09:31:35.680]                       if (!is.null(pattern)) {
[09:31:35.680]                         computeRestarts <- base::computeRestarts
[09:31:35.680]                         grepl <- base::grepl
[09:31:35.680]                         restarts <- computeRestarts(cond)
[09:31:35.680]                         for (restart in restarts) {
[09:31:35.680]                           name <- restart$name
[09:31:35.680]                           if (is.null(name)) 
[09:31:35.680]                             next
[09:31:35.680]                           if (!grepl(pattern, name)) 
[09:31:35.680]                             next
[09:31:35.680]                           invokeRestart(restart)
[09:31:35.680]                           muffled <- TRUE
[09:31:35.680]                           break
[09:31:35.680]                         }
[09:31:35.680]                       }
[09:31:35.680]                     }
[09:31:35.680]                     invisible(muffled)
[09:31:35.680]                   }
[09:31:35.680]                   muffleCondition(cond)
[09:31:35.680]                 })
[09:31:35.680]             }))
[09:31:35.680]             future::FutureResult(value = ...future.value$value, 
[09:31:35.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.680]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.680]                     ...future.globalenv.names))
[09:31:35.680]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.680]         }, condition = base::local({
[09:31:35.680]             c <- base::c
[09:31:35.680]             inherits <- base::inherits
[09:31:35.680]             invokeRestart <- base::invokeRestart
[09:31:35.680]             length <- base::length
[09:31:35.680]             list <- base::list
[09:31:35.680]             seq.int <- base::seq.int
[09:31:35.680]             signalCondition <- base::signalCondition
[09:31:35.680]             sys.calls <- base::sys.calls
[09:31:35.680]             `[[` <- base::`[[`
[09:31:35.680]             `+` <- base::`+`
[09:31:35.680]             `<<-` <- base::`<<-`
[09:31:35.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.680]                   3L)]
[09:31:35.680]             }
[09:31:35.680]             function(cond) {
[09:31:35.680]                 is_error <- inherits(cond, "error")
[09:31:35.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.680]                   NULL)
[09:31:35.680]                 if (is_error) {
[09:31:35.680]                   sessionInformation <- function() {
[09:31:35.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.680]                       search = base::search(), system = base::Sys.info())
[09:31:35.680]                   }
[09:31:35.680]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.680]                     cond$call), session = sessionInformation(), 
[09:31:35.680]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.680]                   signalCondition(cond)
[09:31:35.680]                 }
[09:31:35.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.680]                 "immediateCondition"))) {
[09:31:35.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.680]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.680]                   if (TRUE && !signal) {
[09:31:35.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.680]                     {
[09:31:35.680]                       inherits <- base::inherits
[09:31:35.680]                       invokeRestart <- base::invokeRestart
[09:31:35.680]                       is.null <- base::is.null
[09:31:35.680]                       muffled <- FALSE
[09:31:35.680]                       if (inherits(cond, "message")) {
[09:31:35.680]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.680]                         if (muffled) 
[09:31:35.680]                           invokeRestart("muffleMessage")
[09:31:35.680]                       }
[09:31:35.680]                       else if (inherits(cond, "warning")) {
[09:31:35.680]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.680]                         if (muffled) 
[09:31:35.680]                           invokeRestart("muffleWarning")
[09:31:35.680]                       }
[09:31:35.680]                       else if (inherits(cond, "condition")) {
[09:31:35.680]                         if (!is.null(pattern)) {
[09:31:35.680]                           computeRestarts <- base::computeRestarts
[09:31:35.680]                           grepl <- base::grepl
[09:31:35.680]                           restarts <- computeRestarts(cond)
[09:31:35.680]                           for (restart in restarts) {
[09:31:35.680]                             name <- restart$name
[09:31:35.680]                             if (is.null(name)) 
[09:31:35.680]                               next
[09:31:35.680]                             if (!grepl(pattern, name)) 
[09:31:35.680]                               next
[09:31:35.680]                             invokeRestart(restart)
[09:31:35.680]                             muffled <- TRUE
[09:31:35.680]                             break
[09:31:35.680]                           }
[09:31:35.680]                         }
[09:31:35.680]                       }
[09:31:35.680]                       invisible(muffled)
[09:31:35.680]                     }
[09:31:35.680]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.680]                   }
[09:31:35.680]                 }
[09:31:35.680]                 else {
[09:31:35.680]                   if (TRUE) {
[09:31:35.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.680]                     {
[09:31:35.680]                       inherits <- base::inherits
[09:31:35.680]                       invokeRestart <- base::invokeRestart
[09:31:35.680]                       is.null <- base::is.null
[09:31:35.680]                       muffled <- FALSE
[09:31:35.680]                       if (inherits(cond, "message")) {
[09:31:35.680]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.680]                         if (muffled) 
[09:31:35.680]                           invokeRestart("muffleMessage")
[09:31:35.680]                       }
[09:31:35.680]                       else if (inherits(cond, "warning")) {
[09:31:35.680]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.680]                         if (muffled) 
[09:31:35.680]                           invokeRestart("muffleWarning")
[09:31:35.680]                       }
[09:31:35.680]                       else if (inherits(cond, "condition")) {
[09:31:35.680]                         if (!is.null(pattern)) {
[09:31:35.680]                           computeRestarts <- base::computeRestarts
[09:31:35.680]                           grepl <- base::grepl
[09:31:35.680]                           restarts <- computeRestarts(cond)
[09:31:35.680]                           for (restart in restarts) {
[09:31:35.680]                             name <- restart$name
[09:31:35.680]                             if (is.null(name)) 
[09:31:35.680]                               next
[09:31:35.680]                             if (!grepl(pattern, name)) 
[09:31:35.680]                               next
[09:31:35.680]                             invokeRestart(restart)
[09:31:35.680]                             muffled <- TRUE
[09:31:35.680]                             break
[09:31:35.680]                           }
[09:31:35.680]                         }
[09:31:35.680]                       }
[09:31:35.680]                       invisible(muffled)
[09:31:35.680]                     }
[09:31:35.680]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.680]                   }
[09:31:35.680]                 }
[09:31:35.680]             }
[09:31:35.680]         }))
[09:31:35.680]     }, error = function(ex) {
[09:31:35.680]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.680]                 ...future.rng), started = ...future.startTime, 
[09:31:35.680]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.680]             version = "1.8"), class = "FutureResult")
[09:31:35.680]     }, finally = {
[09:31:35.680]         if (!identical(...future.workdir, getwd())) 
[09:31:35.680]             setwd(...future.workdir)
[09:31:35.680]         {
[09:31:35.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.680]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.680]             }
[09:31:35.680]             base::options(...future.oldOptions)
[09:31:35.680]             if (.Platform$OS.type == "windows") {
[09:31:35.680]                 old_names <- names(...future.oldEnvVars)
[09:31:35.680]                 envs <- base::Sys.getenv()
[09:31:35.680]                 names <- names(envs)
[09:31:35.680]                 common <- intersect(names, old_names)
[09:31:35.680]                 added <- setdiff(names, old_names)
[09:31:35.680]                 removed <- setdiff(old_names, names)
[09:31:35.680]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.680]                   envs[common]]
[09:31:35.680]                 NAMES <- toupper(changed)
[09:31:35.680]                 args <- list()
[09:31:35.680]                 for (kk in seq_along(NAMES)) {
[09:31:35.680]                   name <- changed[[kk]]
[09:31:35.680]                   NAME <- NAMES[[kk]]
[09:31:35.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.680]                     next
[09:31:35.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.680]                 }
[09:31:35.680]                 NAMES <- toupper(added)
[09:31:35.680]                 for (kk in seq_along(NAMES)) {
[09:31:35.680]                   name <- added[[kk]]
[09:31:35.680]                   NAME <- NAMES[[kk]]
[09:31:35.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.680]                     next
[09:31:35.680]                   args[[name]] <- ""
[09:31:35.680]                 }
[09:31:35.680]                 NAMES <- toupper(removed)
[09:31:35.680]                 for (kk in seq_along(NAMES)) {
[09:31:35.680]                   name <- removed[[kk]]
[09:31:35.680]                   NAME <- NAMES[[kk]]
[09:31:35.680]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.680]                     next
[09:31:35.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.680]                 }
[09:31:35.680]                 if (length(args) > 0) 
[09:31:35.680]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.680]             }
[09:31:35.680]             else {
[09:31:35.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.680]             }
[09:31:35.680]             {
[09:31:35.680]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.680]                   0L) {
[09:31:35.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.680]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.680]                   base::options(opts)
[09:31:35.680]                 }
[09:31:35.680]                 {
[09:31:35.680]                   {
[09:31:35.680]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.680]                     NULL
[09:31:35.680]                   }
[09:31:35.680]                   options(future.plan = NULL)
[09:31:35.680]                   if (is.na(NA_character_)) 
[09:31:35.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.680]                     .init = FALSE)
[09:31:35.680]                 }
[09:31:35.680]             }
[09:31:35.680]         }
[09:31:35.680]     })
[09:31:35.680]     if (TRUE) {
[09:31:35.680]         base::sink(type = "output", split = FALSE)
[09:31:35.680]         if (TRUE) {
[09:31:35.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.680]         }
[09:31:35.680]         else {
[09:31:35.680]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.680]         }
[09:31:35.680]         base::close(...future.stdout)
[09:31:35.680]         ...future.stdout <- NULL
[09:31:35.680]     }
[09:31:35.680]     ...future.result$conditions <- ...future.conditions
[09:31:35.680]     ...future.result$finished <- base::Sys.time()
[09:31:35.680]     ...future.result
[09:31:35.680] }
[09:31:35.682] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:35.693] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.693] - Validating connection of MultisessionFuture
[09:31:35.693] - received message: FutureResult
[09:31:35.693] - Received FutureResult
[09:31:35.694] - Erased future from FutureRegistry
[09:31:35.694] result() for ClusterFuture ...
[09:31:35.694] - result already collected: FutureResult
[09:31:35.694] result() for ClusterFuture ... done
[09:31:35.694] signalConditions() ...
[09:31:35.694]  - include = ‘immediateCondition’
[09:31:35.694]  - exclude = 
[09:31:35.694]  - resignal = FALSE
[09:31:35.694]  - Number of conditions: 1
[09:31:35.694] signalConditions() ... done
[09:31:35.694] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.694] result() for ClusterFuture ...
[09:31:35.695] - result already collected: FutureResult
[09:31:35.695] result() for ClusterFuture ... done
[09:31:35.695] result() for ClusterFuture ...
[09:31:35.695] - result already collected: FutureResult
[09:31:35.695] result() for ClusterFuture ... done
[09:31:35.695] signalConditions() ...
[09:31:35.695]  - include = ‘immediateCondition’
[09:31:35.695]  - exclude = 
[09:31:35.695]  - resignal = FALSE
[09:31:35.695]  - Number of conditions: 1
[09:31:35.695] signalConditions() ... done
[09:31:35.696] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:31:35.696] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:35.697] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:35.697] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:31:35.697] MultisessionFuture started
[09:31:35.698] - Launch lazy future ... done
[09:31:35.698] run() for ‘MultisessionFuture’ ... done
[09:31:35.698] result() for ClusterFuture ...
[09:31:35.698] - result already collected: FutureResult
[09:31:35.698] result() for ClusterFuture ... done
[09:31:35.698] result() for ClusterFuture ...
[09:31:35.699] - result already collected: FutureResult
[09:31:35.699] result() for ClusterFuture ... done
[09:31:35.699] signalConditions() ...
[09:31:35.699]  - include = ‘immediateCondition’
[09:31:35.699]  - exclude = 
[09:31:35.699]  - resignal = FALSE
[09:31:35.699]  - Number of conditions: 1
[09:31:35.700] signalConditions() ... done
[09:31:35.700] Future state: ‘finished’
[09:31:35.700] result() for ClusterFuture ...
[09:31:35.700] - result already collected: FutureResult
[09:31:35.700] result() for ClusterFuture ... done
[09:31:35.700] signalConditions() ...
[09:31:35.700]  - include = ‘condition’
[09:31:35.701]  - exclude = ‘immediateCondition’
[09:31:35.701]  - resignal = TRUE
[09:31:35.701]  - Number of conditions: 1
[09:31:35.701]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:35.701] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:35"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.716] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.716] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.717] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.717] Searching for globals ... DONE
[09:31:35.718] Resolving globals: TRUE
[09:31:35.718] Resolving any globals that are futures ...
[09:31:35.718] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.718] Resolving any globals that are futures ... DONE
[09:31:35.718] Resolving futures part of globals (recursively) ...
[09:31:35.718] resolve() on list ...
[09:31:35.718]  recursive: 99
[09:31:35.719]  length: 1
[09:31:35.719]  elements: ‘ii’
[09:31:35.719]  length: 0 (resolved future 1)
[09:31:35.719] resolve() on list ... DONE
[09:31:35.719] - globals: [1] ‘ii’
[09:31:35.719] Resolving futures part of globals (recursively) ... DONE
[09:31:35.719] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.719] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.720] - globals: [1] ‘ii’
[09:31:35.720] 
[09:31:35.720] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.720] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.721] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.722] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.722] Searching for globals ... DONE
[09:31:35.722] Resolving globals: TRUE
[09:31:35.722] Resolving any globals that are futures ...
[09:31:35.722] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.722] Resolving any globals that are futures ... DONE
[09:31:35.722] Resolving futures part of globals (recursively) ...
[09:31:35.723] resolve() on list ...
[09:31:35.723]  recursive: 99
[09:31:35.723]  length: 1
[09:31:35.723]  elements: ‘ii’
[09:31:35.723]  length: 0 (resolved future 1)
[09:31:35.723] resolve() on list ... DONE
[09:31:35.723] - globals: [1] ‘ii’
[09:31:35.723] Resolving futures part of globals (recursively) ... DONE
[09:31:35.723] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.724] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.724] - globals: [1] ‘ii’
[09:31:35.724] 
[09:31:35.724] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.725] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.725] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.726] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.726] Searching for globals ... DONE
[09:31:35.726] Resolving globals: TRUE
[09:31:35.726] Resolving any globals that are futures ...
[09:31:35.726] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[09:31:35.727] Resolving any globals that are futures ... DONE
[09:31:35.727] Resolving futures part of globals (recursively) ...
[09:31:35.727] resolve() on list ...
[09:31:35.727]  recursive: 99
[09:31:35.727]  length: 1
[09:31:35.727]  elements: ‘ii’
[09:31:35.727]  length: 0 (resolved future 1)
[09:31:35.728] resolve() on list ... DONE
[09:31:35.728] - globals: [1] ‘ii’
[09:31:35.728] Resolving futures part of globals (recursively) ... DONE
[09:31:35.728] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:35.728] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (56 bytes of class ‘numeric’)
[09:31:35.728] - globals: [1] ‘ii’
[09:31:35.728] 
[09:31:35.728] getGlobalsAndPackages() ... DONE
[09:31:35.729] run() for ‘Future’ ...
[09:31:35.729] - state: ‘created’
[09:31:35.729] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.744]   - Field: ‘node’
[09:31:35.744]   - Field: ‘label’
[09:31:35.744]   - Field: ‘local’
[09:31:35.745]   - Field: ‘owner’
[09:31:35.745]   - Field: ‘envir’
[09:31:35.745]   - Field: ‘workers’
[09:31:35.745]   - Field: ‘packages’
[09:31:35.745]   - Field: ‘gc’
[09:31:35.745]   - Field: ‘conditions’
[09:31:35.745]   - Field: ‘persistent’
[09:31:35.745]   - Field: ‘expr’
[09:31:35.745]   - Field: ‘uuid’
[09:31:35.745]   - Field: ‘seed’
[09:31:35.745]   - Field: ‘version’
[09:31:35.746]   - Field: ‘result’
[09:31:35.746]   - Field: ‘asynchronous’
[09:31:35.746]   - Field: ‘calls’
[09:31:35.746]   - Field: ‘globals’
[09:31:35.746]   - Field: ‘stdout’
[09:31:35.746]   - Field: ‘earlySignal’
[09:31:35.746]   - Field: ‘lazy’
[09:31:35.746]   - Field: ‘state’
[09:31:35.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.746] - Launch lazy future ...
[09:31:35.747] Packages needed by the future expression (n = 0): <none>
[09:31:35.747] Packages needed by future strategies (n = 0): <none>
[09:31:35.747] {
[09:31:35.747]     {
[09:31:35.747]         {
[09:31:35.747]             ...future.startTime <- base::Sys.time()
[09:31:35.747]             {
[09:31:35.747]                 {
[09:31:35.747]                   {
[09:31:35.747]                     {
[09:31:35.747]                       base::local({
[09:31:35.747]                         has_future <- base::requireNamespace("future", 
[09:31:35.747]                           quietly = TRUE)
[09:31:35.747]                         if (has_future) {
[09:31:35.747]                           ns <- base::getNamespace("future")
[09:31:35.747]                           version <- ns[[".package"]][["version"]]
[09:31:35.747]                           if (is.null(version)) 
[09:31:35.747]                             version <- utils::packageVersion("future")
[09:31:35.747]                         }
[09:31:35.747]                         else {
[09:31:35.747]                           version <- NULL
[09:31:35.747]                         }
[09:31:35.747]                         if (!has_future || version < "1.8.0") {
[09:31:35.747]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.747]                             "", base::R.version$version.string), 
[09:31:35.747]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.747]                               "release", "version")], collapse = " "), 
[09:31:35.747]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.747]                             info)
[09:31:35.747]                           info <- base::paste(info, collapse = "; ")
[09:31:35.747]                           if (!has_future) {
[09:31:35.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.747]                               info)
[09:31:35.747]                           }
[09:31:35.747]                           else {
[09:31:35.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.747]                               info, version)
[09:31:35.747]                           }
[09:31:35.747]                           base::stop(msg)
[09:31:35.747]                         }
[09:31:35.747]                       })
[09:31:35.747]                     }
[09:31:35.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.747]                     base::options(mc.cores = 1L)
[09:31:35.747]                   }
[09:31:35.747]                   ...future.strategy.old <- future::plan("list")
[09:31:35.747]                   options(future.plan = NULL)
[09:31:35.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.747]                 }
[09:31:35.747]                 ...future.workdir <- getwd()
[09:31:35.747]             }
[09:31:35.747]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.747]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.747]         }
[09:31:35.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.747]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.747]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.747]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.747]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.747]             base::names(...future.oldOptions))
[09:31:35.747]     }
[09:31:35.747]     if (FALSE) {
[09:31:35.747]     }
[09:31:35.747]     else {
[09:31:35.747]         if (TRUE) {
[09:31:35.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.747]                 open = "w")
[09:31:35.747]         }
[09:31:35.747]         else {
[09:31:35.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.747]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.747]         }
[09:31:35.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.747]             base::sink(type = "output", split = FALSE)
[09:31:35.747]             base::close(...future.stdout)
[09:31:35.747]         }, add = TRUE)
[09:31:35.747]     }
[09:31:35.747]     ...future.frame <- base::sys.nframe()
[09:31:35.747]     ...future.conditions <- base::list()
[09:31:35.747]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.747]     if (FALSE) {
[09:31:35.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.747]     }
[09:31:35.747]     ...future.result <- base::tryCatch({
[09:31:35.747]         base::withCallingHandlers({
[09:31:35.747]             ...future.value <- base::withVisible(base::local({
[09:31:35.747]                 ...future.makeSendCondition <- base::local({
[09:31:35.747]                   sendCondition <- NULL
[09:31:35.747]                   function(frame = 1L) {
[09:31:35.747]                     if (is.function(sendCondition)) 
[09:31:35.747]                       return(sendCondition)
[09:31:35.747]                     ns <- getNamespace("parallel")
[09:31:35.747]                     if (exists("sendData", mode = "function", 
[09:31:35.747]                       envir = ns)) {
[09:31:35.747]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.747]                         envir = ns)
[09:31:35.747]                       envir <- sys.frame(frame)
[09:31:35.747]                       master <- NULL
[09:31:35.747]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.747]                         !identical(envir, emptyenv())) {
[09:31:35.747]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.747]                           inherits = FALSE)) {
[09:31:35.747]                           master <- get("master", mode = "list", 
[09:31:35.747]                             envir = envir, inherits = FALSE)
[09:31:35.747]                           if (inherits(master, c("SOCKnode", 
[09:31:35.747]                             "SOCK0node"))) {
[09:31:35.747]                             sendCondition <<- function(cond) {
[09:31:35.747]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.747]                                 success = TRUE)
[09:31:35.747]                               parallel_sendData(master, data)
[09:31:35.747]                             }
[09:31:35.747]                             return(sendCondition)
[09:31:35.747]                           }
[09:31:35.747]                         }
[09:31:35.747]                         frame <- frame + 1L
[09:31:35.747]                         envir <- sys.frame(frame)
[09:31:35.747]                       }
[09:31:35.747]                     }
[09:31:35.747]                     sendCondition <<- function(cond) NULL
[09:31:35.747]                   }
[09:31:35.747]                 })
[09:31:35.747]                 withCallingHandlers({
[09:31:35.747]                   {
[09:31:35.747]                     b <- a * ii
[09:31:35.747]                     a <- 0
[09:31:35.747]                     b
[09:31:35.747]                   }
[09:31:35.747]                 }, immediateCondition = function(cond) {
[09:31:35.747]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.747]                   sendCondition(cond)
[09:31:35.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.747]                   {
[09:31:35.747]                     inherits <- base::inherits
[09:31:35.747]                     invokeRestart <- base::invokeRestart
[09:31:35.747]                     is.null <- base::is.null
[09:31:35.747]                     muffled <- FALSE
[09:31:35.747]                     if (inherits(cond, "message")) {
[09:31:35.747]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.747]                       if (muffled) 
[09:31:35.747]                         invokeRestart("muffleMessage")
[09:31:35.747]                     }
[09:31:35.747]                     else if (inherits(cond, "warning")) {
[09:31:35.747]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.747]                       if (muffled) 
[09:31:35.747]                         invokeRestart("muffleWarning")
[09:31:35.747]                     }
[09:31:35.747]                     else if (inherits(cond, "condition")) {
[09:31:35.747]                       if (!is.null(pattern)) {
[09:31:35.747]                         computeRestarts <- base::computeRestarts
[09:31:35.747]                         grepl <- base::grepl
[09:31:35.747]                         restarts <- computeRestarts(cond)
[09:31:35.747]                         for (restart in restarts) {
[09:31:35.747]                           name <- restart$name
[09:31:35.747]                           if (is.null(name)) 
[09:31:35.747]                             next
[09:31:35.747]                           if (!grepl(pattern, name)) 
[09:31:35.747]                             next
[09:31:35.747]                           invokeRestart(restart)
[09:31:35.747]                           muffled <- TRUE
[09:31:35.747]                           break
[09:31:35.747]                         }
[09:31:35.747]                       }
[09:31:35.747]                     }
[09:31:35.747]                     invisible(muffled)
[09:31:35.747]                   }
[09:31:35.747]                   muffleCondition(cond)
[09:31:35.747]                 })
[09:31:35.747]             }))
[09:31:35.747]             future::FutureResult(value = ...future.value$value, 
[09:31:35.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.747]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.747]                     ...future.globalenv.names))
[09:31:35.747]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.747]         }, condition = base::local({
[09:31:35.747]             c <- base::c
[09:31:35.747]             inherits <- base::inherits
[09:31:35.747]             invokeRestart <- base::invokeRestart
[09:31:35.747]             length <- base::length
[09:31:35.747]             list <- base::list
[09:31:35.747]             seq.int <- base::seq.int
[09:31:35.747]             signalCondition <- base::signalCondition
[09:31:35.747]             sys.calls <- base::sys.calls
[09:31:35.747]             `[[` <- base::`[[`
[09:31:35.747]             `+` <- base::`+`
[09:31:35.747]             `<<-` <- base::`<<-`
[09:31:35.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.747]                   3L)]
[09:31:35.747]             }
[09:31:35.747]             function(cond) {
[09:31:35.747]                 is_error <- inherits(cond, "error")
[09:31:35.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.747]                   NULL)
[09:31:35.747]                 if (is_error) {
[09:31:35.747]                   sessionInformation <- function() {
[09:31:35.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.747]                       search = base::search(), system = base::Sys.info())
[09:31:35.747]                   }
[09:31:35.747]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.747]                     cond$call), session = sessionInformation(), 
[09:31:35.747]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.747]                   signalCondition(cond)
[09:31:35.747]                 }
[09:31:35.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.747]                 "immediateCondition"))) {
[09:31:35.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.747]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.747]                   if (TRUE && !signal) {
[09:31:35.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.747]                     {
[09:31:35.747]                       inherits <- base::inherits
[09:31:35.747]                       invokeRestart <- base::invokeRestart
[09:31:35.747]                       is.null <- base::is.null
[09:31:35.747]                       muffled <- FALSE
[09:31:35.747]                       if (inherits(cond, "message")) {
[09:31:35.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.747]                         if (muffled) 
[09:31:35.747]                           invokeRestart("muffleMessage")
[09:31:35.747]                       }
[09:31:35.747]                       else if (inherits(cond, "warning")) {
[09:31:35.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.747]                         if (muffled) 
[09:31:35.747]                           invokeRestart("muffleWarning")
[09:31:35.747]                       }
[09:31:35.747]                       else if (inherits(cond, "condition")) {
[09:31:35.747]                         if (!is.null(pattern)) {
[09:31:35.747]                           computeRestarts <- base::computeRestarts
[09:31:35.747]                           grepl <- base::grepl
[09:31:35.747]                           restarts <- computeRestarts(cond)
[09:31:35.747]                           for (restart in restarts) {
[09:31:35.747]                             name <- restart$name
[09:31:35.747]                             if (is.null(name)) 
[09:31:35.747]                               next
[09:31:35.747]                             if (!grepl(pattern, name)) 
[09:31:35.747]                               next
[09:31:35.747]                             invokeRestart(restart)
[09:31:35.747]                             muffled <- TRUE
[09:31:35.747]                             break
[09:31:35.747]                           }
[09:31:35.747]                         }
[09:31:35.747]                       }
[09:31:35.747]                       invisible(muffled)
[09:31:35.747]                     }
[09:31:35.747]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.747]                   }
[09:31:35.747]                 }
[09:31:35.747]                 else {
[09:31:35.747]                   if (TRUE) {
[09:31:35.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.747]                     {
[09:31:35.747]                       inherits <- base::inherits
[09:31:35.747]                       invokeRestart <- base::invokeRestart
[09:31:35.747]                       is.null <- base::is.null
[09:31:35.747]                       muffled <- FALSE
[09:31:35.747]                       if (inherits(cond, "message")) {
[09:31:35.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.747]                         if (muffled) 
[09:31:35.747]                           invokeRestart("muffleMessage")
[09:31:35.747]                       }
[09:31:35.747]                       else if (inherits(cond, "warning")) {
[09:31:35.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.747]                         if (muffled) 
[09:31:35.747]                           invokeRestart("muffleWarning")
[09:31:35.747]                       }
[09:31:35.747]                       else if (inherits(cond, "condition")) {
[09:31:35.747]                         if (!is.null(pattern)) {
[09:31:35.747]                           computeRestarts <- base::computeRestarts
[09:31:35.747]                           grepl <- base::grepl
[09:31:35.747]                           restarts <- computeRestarts(cond)
[09:31:35.747]                           for (restart in restarts) {
[09:31:35.747]                             name <- restart$name
[09:31:35.747]                             if (is.null(name)) 
[09:31:35.747]                               next
[09:31:35.747]                             if (!grepl(pattern, name)) 
[09:31:35.747]                               next
[09:31:35.747]                             invokeRestart(restart)
[09:31:35.747]                             muffled <- TRUE
[09:31:35.747]                             break
[09:31:35.747]                           }
[09:31:35.747]                         }
[09:31:35.747]                       }
[09:31:35.747]                       invisible(muffled)
[09:31:35.747]                     }
[09:31:35.747]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.747]                   }
[09:31:35.747]                 }
[09:31:35.747]             }
[09:31:35.747]         }))
[09:31:35.747]     }, error = function(ex) {
[09:31:35.747]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.747]                 ...future.rng), started = ...future.startTime, 
[09:31:35.747]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.747]             version = "1.8"), class = "FutureResult")
[09:31:35.747]     }, finally = {
[09:31:35.747]         if (!identical(...future.workdir, getwd())) 
[09:31:35.747]             setwd(...future.workdir)
[09:31:35.747]         {
[09:31:35.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.747]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.747]             }
[09:31:35.747]             base::options(...future.oldOptions)
[09:31:35.747]             if (.Platform$OS.type == "windows") {
[09:31:35.747]                 old_names <- names(...future.oldEnvVars)
[09:31:35.747]                 envs <- base::Sys.getenv()
[09:31:35.747]                 names <- names(envs)
[09:31:35.747]                 common <- intersect(names, old_names)
[09:31:35.747]                 added <- setdiff(names, old_names)
[09:31:35.747]                 removed <- setdiff(old_names, names)
[09:31:35.747]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.747]                   envs[common]]
[09:31:35.747]                 NAMES <- toupper(changed)
[09:31:35.747]                 args <- list()
[09:31:35.747]                 for (kk in seq_along(NAMES)) {
[09:31:35.747]                   name <- changed[[kk]]
[09:31:35.747]                   NAME <- NAMES[[kk]]
[09:31:35.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.747]                     next
[09:31:35.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.747]                 }
[09:31:35.747]                 NAMES <- toupper(added)
[09:31:35.747]                 for (kk in seq_along(NAMES)) {
[09:31:35.747]                   name <- added[[kk]]
[09:31:35.747]                   NAME <- NAMES[[kk]]
[09:31:35.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.747]                     next
[09:31:35.747]                   args[[name]] <- ""
[09:31:35.747]                 }
[09:31:35.747]                 NAMES <- toupper(removed)
[09:31:35.747]                 for (kk in seq_along(NAMES)) {
[09:31:35.747]                   name <- removed[[kk]]
[09:31:35.747]                   NAME <- NAMES[[kk]]
[09:31:35.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.747]                     next
[09:31:35.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.747]                 }
[09:31:35.747]                 if (length(args) > 0) 
[09:31:35.747]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.747]             }
[09:31:35.747]             else {
[09:31:35.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.747]             }
[09:31:35.747]             {
[09:31:35.747]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.747]                   0L) {
[09:31:35.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.747]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.747]                   base::options(opts)
[09:31:35.747]                 }
[09:31:35.747]                 {
[09:31:35.747]                   {
[09:31:35.747]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.747]                     NULL
[09:31:35.747]                   }
[09:31:35.747]                   options(future.plan = NULL)
[09:31:35.747]                   if (is.na(NA_character_)) 
[09:31:35.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.747]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.747]                     .init = FALSE)
[09:31:35.747]                 }
[09:31:35.747]             }
[09:31:35.747]         }
[09:31:35.747]     })
[09:31:35.747]     if (TRUE) {
[09:31:35.747]         base::sink(type = "output", split = FALSE)
[09:31:35.747]         if (TRUE) {
[09:31:35.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.747]         }
[09:31:35.747]         else {
[09:31:35.747]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.747]         }
[09:31:35.747]         base::close(...future.stdout)
[09:31:35.747]         ...future.stdout <- NULL
[09:31:35.747]     }
[09:31:35.747]     ...future.result$conditions <- ...future.conditions
[09:31:35.747]     ...future.result$finished <- base::Sys.time()
[09:31:35.747]     ...future.result
[09:31:35.747] }
[09:31:35.749] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:35.760] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.760] - Validating connection of MultisessionFuture
[09:31:35.761] - received message: FutureResult
[09:31:35.761] - Received FutureResult
[09:31:35.761] - Erased future from FutureRegistry
[09:31:35.761] result() for ClusterFuture ...
[09:31:35.761] - result already collected: FutureResult
[09:31:35.761] result() for ClusterFuture ... done
[09:31:35.761] signalConditions() ...
[09:31:35.761]  - include = ‘immediateCondition’
[09:31:35.761]  - exclude = 
[09:31:35.761]  - resignal = FALSE
[09:31:35.761]  - Number of conditions: 1
[09:31:35.762] signalConditions() ... done
[09:31:35.762] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.762] result() for ClusterFuture ...
[09:31:35.762] - result already collected: FutureResult
[09:31:35.762] result() for ClusterFuture ... done
[09:31:35.762] result() for ClusterFuture ...
[09:31:35.762] - result already collected: FutureResult
[09:31:35.762] result() for ClusterFuture ... done
[09:31:35.762] signalConditions() ...
[09:31:35.762]  - include = ‘immediateCondition’
[09:31:35.762]  - exclude = 
[09:31:35.763]  - resignal = FALSE
[09:31:35.763]  - Number of conditions: 1
[09:31:35.763] signalConditions() ... done
[09:31:35.763] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:31:35.763] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[09:31:35.764] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[09:31:35.764] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:31:35.764] MultisessionFuture started
[09:31:35.764] - Launch lazy future ... done
[09:31:35.765] run() for ‘MultisessionFuture’ ... done
[09:31:35.765] result() for ClusterFuture ...
[09:31:35.765] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.765] - Validating connection of MultisessionFuture
[09:31:35.766] - received message: FutureResult
[09:31:35.766] - Received FutureResult
[09:31:35.766] - Erased future from FutureRegistry
[09:31:35.767] result() for ClusterFuture ...
[09:31:35.767] - result already collected: FutureResult
[09:31:35.767] result() for ClusterFuture ... done
[09:31:35.767] signalConditions() ...
[09:31:35.767]  - include = ‘immediateCondition’
[09:31:35.767]  - exclude = 
[09:31:35.767]  - resignal = FALSE
[09:31:35.767]  - Number of conditions: 1
[09:31:35.767] signalConditions() ... done
[09:31:35.767] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.767] result() for ClusterFuture ... done
[09:31:35.767] result() for ClusterFuture ...
[09:31:35.768] - result already collected: FutureResult
[09:31:35.768] result() for ClusterFuture ... done
[09:31:35.768] signalConditions() ...
[09:31:35.768]  - include = ‘immediateCondition’
[09:31:35.768]  - exclude = 
[09:31:35.768]  - resignal = FALSE
[09:31:35.768]  - Number of conditions: 1
[09:31:35.768] signalConditions() ... done
[09:31:35.768] Future state: ‘finished’
[09:31:35.768] result() for ClusterFuture ...
[09:31:35.768] - result already collected: FutureResult
[09:31:35.769] result() for ClusterFuture ... done
[09:31:35.769] signalConditions() ...
[09:31:35.769]  - include = ‘condition’
[09:31:35.769]  - exclude = ‘immediateCondition’
[09:31:35.769]  - resignal = TRUE
[09:31:35.769]  - Number of conditions: 1
[09:31:35.769]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[09:31:35.769] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.0"
  .. .. .. .. ..$ year          : chr "2024"
  .. .. .. .. ..$ month         : chr "04"
  .. .. .. .. ..$ day           : chr "24"
  .. .. .. .. ..$ svn rev       : chr "86474"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.0 (2024-04-24)"
  .. .. .. .. ..$ nickname      : chr "Puppy Cup"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.5.0-1025-azure" "#26~22.04.1-Ubuntu SMP Thu Jul 11 22:33:04 UTC 2024" "8f1daa72e372" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2024-12-19 09:31:35"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.782] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.782] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.783] 
[09:31:35.783] Searching for globals ... DONE
[09:31:35.783] - globals: [0] <none>
[09:31:35.783] getGlobalsAndPackages() ... DONE
[09:31:35.783] run() for ‘Future’ ...
[09:31:35.783] - state: ‘created’
[09:31:35.784] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.797]   - Field: ‘node’
[09:31:35.797]   - Field: ‘label’
[09:31:35.797]   - Field: ‘local’
[09:31:35.797]   - Field: ‘owner’
[09:31:35.797]   - Field: ‘envir’
[09:31:35.797]   - Field: ‘workers’
[09:31:35.798]   - Field: ‘packages’
[09:31:35.798]   - Field: ‘gc’
[09:31:35.798]   - Field: ‘conditions’
[09:31:35.798]   - Field: ‘persistent’
[09:31:35.798]   - Field: ‘expr’
[09:31:35.798]   - Field: ‘uuid’
[09:31:35.798]   - Field: ‘seed’
[09:31:35.798]   - Field: ‘version’
[09:31:35.798]   - Field: ‘result’
[09:31:35.798]   - Field: ‘asynchronous’
[09:31:35.798]   - Field: ‘calls’
[09:31:35.798]   - Field: ‘globals’
[09:31:35.799]   - Field: ‘stdout’
[09:31:35.799]   - Field: ‘earlySignal’
[09:31:35.799]   - Field: ‘lazy’
[09:31:35.799]   - Field: ‘state’
[09:31:35.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.799] - Launch lazy future ...
[09:31:35.799] Packages needed by the future expression (n = 0): <none>
[09:31:35.799] Packages needed by future strategies (n = 0): <none>
[09:31:35.800] {
[09:31:35.800]     {
[09:31:35.800]         {
[09:31:35.800]             ...future.startTime <- base::Sys.time()
[09:31:35.800]             {
[09:31:35.800]                 {
[09:31:35.800]                   {
[09:31:35.800]                     {
[09:31:35.800]                       base::local({
[09:31:35.800]                         has_future <- base::requireNamespace("future", 
[09:31:35.800]                           quietly = TRUE)
[09:31:35.800]                         if (has_future) {
[09:31:35.800]                           ns <- base::getNamespace("future")
[09:31:35.800]                           version <- ns[[".package"]][["version"]]
[09:31:35.800]                           if (is.null(version)) 
[09:31:35.800]                             version <- utils::packageVersion("future")
[09:31:35.800]                         }
[09:31:35.800]                         else {
[09:31:35.800]                           version <- NULL
[09:31:35.800]                         }
[09:31:35.800]                         if (!has_future || version < "1.8.0") {
[09:31:35.800]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.800]                             "", base::R.version$version.string), 
[09:31:35.800]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.800]                               "release", "version")], collapse = " "), 
[09:31:35.800]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.800]                             info)
[09:31:35.800]                           info <- base::paste(info, collapse = "; ")
[09:31:35.800]                           if (!has_future) {
[09:31:35.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.800]                               info)
[09:31:35.800]                           }
[09:31:35.800]                           else {
[09:31:35.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.800]                               info, version)
[09:31:35.800]                           }
[09:31:35.800]                           base::stop(msg)
[09:31:35.800]                         }
[09:31:35.800]                       })
[09:31:35.800]                     }
[09:31:35.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.800]                     base::options(mc.cores = 1L)
[09:31:35.800]                   }
[09:31:35.800]                   ...future.strategy.old <- future::plan("list")
[09:31:35.800]                   options(future.plan = NULL)
[09:31:35.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.800]                 }
[09:31:35.800]                 ...future.workdir <- getwd()
[09:31:35.800]             }
[09:31:35.800]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.800]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.800]         }
[09:31:35.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.800]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.800]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.800]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.800]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.800]             base::names(...future.oldOptions))
[09:31:35.800]     }
[09:31:35.800]     if (FALSE) {
[09:31:35.800]     }
[09:31:35.800]     else {
[09:31:35.800]         if (TRUE) {
[09:31:35.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.800]                 open = "w")
[09:31:35.800]         }
[09:31:35.800]         else {
[09:31:35.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.800]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.800]         }
[09:31:35.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.800]             base::sink(type = "output", split = FALSE)
[09:31:35.800]             base::close(...future.stdout)
[09:31:35.800]         }, add = TRUE)
[09:31:35.800]     }
[09:31:35.800]     ...future.frame <- base::sys.nframe()
[09:31:35.800]     ...future.conditions <- base::list()
[09:31:35.800]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.800]     if (FALSE) {
[09:31:35.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.800]     }
[09:31:35.800]     ...future.result <- base::tryCatch({
[09:31:35.800]         base::withCallingHandlers({
[09:31:35.800]             ...future.value <- base::withVisible(base::local({
[09:31:35.800]                 ...future.makeSendCondition <- base::local({
[09:31:35.800]                   sendCondition <- NULL
[09:31:35.800]                   function(frame = 1L) {
[09:31:35.800]                     if (is.function(sendCondition)) 
[09:31:35.800]                       return(sendCondition)
[09:31:35.800]                     ns <- getNamespace("parallel")
[09:31:35.800]                     if (exists("sendData", mode = "function", 
[09:31:35.800]                       envir = ns)) {
[09:31:35.800]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.800]                         envir = ns)
[09:31:35.800]                       envir <- sys.frame(frame)
[09:31:35.800]                       master <- NULL
[09:31:35.800]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.800]                         !identical(envir, emptyenv())) {
[09:31:35.800]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.800]                           inherits = FALSE)) {
[09:31:35.800]                           master <- get("master", mode = "list", 
[09:31:35.800]                             envir = envir, inherits = FALSE)
[09:31:35.800]                           if (inherits(master, c("SOCKnode", 
[09:31:35.800]                             "SOCK0node"))) {
[09:31:35.800]                             sendCondition <<- function(cond) {
[09:31:35.800]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.800]                                 success = TRUE)
[09:31:35.800]                               parallel_sendData(master, data)
[09:31:35.800]                             }
[09:31:35.800]                             return(sendCondition)
[09:31:35.800]                           }
[09:31:35.800]                         }
[09:31:35.800]                         frame <- frame + 1L
[09:31:35.800]                         envir <- sys.frame(frame)
[09:31:35.800]                       }
[09:31:35.800]                     }
[09:31:35.800]                     sendCondition <<- function(cond) NULL
[09:31:35.800]                   }
[09:31:35.800]                 })
[09:31:35.800]                 withCallingHandlers({
[09:31:35.800]                   1
[09:31:35.800]                 }, immediateCondition = function(cond) {
[09:31:35.800]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.800]                   sendCondition(cond)
[09:31:35.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.800]                   {
[09:31:35.800]                     inherits <- base::inherits
[09:31:35.800]                     invokeRestart <- base::invokeRestart
[09:31:35.800]                     is.null <- base::is.null
[09:31:35.800]                     muffled <- FALSE
[09:31:35.800]                     if (inherits(cond, "message")) {
[09:31:35.800]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.800]                       if (muffled) 
[09:31:35.800]                         invokeRestart("muffleMessage")
[09:31:35.800]                     }
[09:31:35.800]                     else if (inherits(cond, "warning")) {
[09:31:35.800]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.800]                       if (muffled) 
[09:31:35.800]                         invokeRestart("muffleWarning")
[09:31:35.800]                     }
[09:31:35.800]                     else if (inherits(cond, "condition")) {
[09:31:35.800]                       if (!is.null(pattern)) {
[09:31:35.800]                         computeRestarts <- base::computeRestarts
[09:31:35.800]                         grepl <- base::grepl
[09:31:35.800]                         restarts <- computeRestarts(cond)
[09:31:35.800]                         for (restart in restarts) {
[09:31:35.800]                           name <- restart$name
[09:31:35.800]                           if (is.null(name)) 
[09:31:35.800]                             next
[09:31:35.800]                           if (!grepl(pattern, name)) 
[09:31:35.800]                             next
[09:31:35.800]                           invokeRestart(restart)
[09:31:35.800]                           muffled <- TRUE
[09:31:35.800]                           break
[09:31:35.800]                         }
[09:31:35.800]                       }
[09:31:35.800]                     }
[09:31:35.800]                     invisible(muffled)
[09:31:35.800]                   }
[09:31:35.800]                   muffleCondition(cond)
[09:31:35.800]                 })
[09:31:35.800]             }))
[09:31:35.800]             future::FutureResult(value = ...future.value$value, 
[09:31:35.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.800]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.800]                     ...future.globalenv.names))
[09:31:35.800]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.800]         }, condition = base::local({
[09:31:35.800]             c <- base::c
[09:31:35.800]             inherits <- base::inherits
[09:31:35.800]             invokeRestart <- base::invokeRestart
[09:31:35.800]             length <- base::length
[09:31:35.800]             list <- base::list
[09:31:35.800]             seq.int <- base::seq.int
[09:31:35.800]             signalCondition <- base::signalCondition
[09:31:35.800]             sys.calls <- base::sys.calls
[09:31:35.800]             `[[` <- base::`[[`
[09:31:35.800]             `+` <- base::`+`
[09:31:35.800]             `<<-` <- base::`<<-`
[09:31:35.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.800]                   3L)]
[09:31:35.800]             }
[09:31:35.800]             function(cond) {
[09:31:35.800]                 is_error <- inherits(cond, "error")
[09:31:35.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.800]                   NULL)
[09:31:35.800]                 if (is_error) {
[09:31:35.800]                   sessionInformation <- function() {
[09:31:35.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.800]                       search = base::search(), system = base::Sys.info())
[09:31:35.800]                   }
[09:31:35.800]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.800]                     cond$call), session = sessionInformation(), 
[09:31:35.800]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.800]                   signalCondition(cond)
[09:31:35.800]                 }
[09:31:35.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.800]                 "immediateCondition"))) {
[09:31:35.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.800]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.800]                   if (TRUE && !signal) {
[09:31:35.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.800]                     {
[09:31:35.800]                       inherits <- base::inherits
[09:31:35.800]                       invokeRestart <- base::invokeRestart
[09:31:35.800]                       is.null <- base::is.null
[09:31:35.800]                       muffled <- FALSE
[09:31:35.800]                       if (inherits(cond, "message")) {
[09:31:35.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.800]                         if (muffled) 
[09:31:35.800]                           invokeRestart("muffleMessage")
[09:31:35.800]                       }
[09:31:35.800]                       else if (inherits(cond, "warning")) {
[09:31:35.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.800]                         if (muffled) 
[09:31:35.800]                           invokeRestart("muffleWarning")
[09:31:35.800]                       }
[09:31:35.800]                       else if (inherits(cond, "condition")) {
[09:31:35.800]                         if (!is.null(pattern)) {
[09:31:35.800]                           computeRestarts <- base::computeRestarts
[09:31:35.800]                           grepl <- base::grepl
[09:31:35.800]                           restarts <- computeRestarts(cond)
[09:31:35.800]                           for (restart in restarts) {
[09:31:35.800]                             name <- restart$name
[09:31:35.800]                             if (is.null(name)) 
[09:31:35.800]                               next
[09:31:35.800]                             if (!grepl(pattern, name)) 
[09:31:35.800]                               next
[09:31:35.800]                             invokeRestart(restart)
[09:31:35.800]                             muffled <- TRUE
[09:31:35.800]                             break
[09:31:35.800]                           }
[09:31:35.800]                         }
[09:31:35.800]                       }
[09:31:35.800]                       invisible(muffled)
[09:31:35.800]                     }
[09:31:35.800]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.800]                   }
[09:31:35.800]                 }
[09:31:35.800]                 else {
[09:31:35.800]                   if (TRUE) {
[09:31:35.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.800]                     {
[09:31:35.800]                       inherits <- base::inherits
[09:31:35.800]                       invokeRestart <- base::invokeRestart
[09:31:35.800]                       is.null <- base::is.null
[09:31:35.800]                       muffled <- FALSE
[09:31:35.800]                       if (inherits(cond, "message")) {
[09:31:35.800]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.800]                         if (muffled) 
[09:31:35.800]                           invokeRestart("muffleMessage")
[09:31:35.800]                       }
[09:31:35.800]                       else if (inherits(cond, "warning")) {
[09:31:35.800]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.800]                         if (muffled) 
[09:31:35.800]                           invokeRestart("muffleWarning")
[09:31:35.800]                       }
[09:31:35.800]                       else if (inherits(cond, "condition")) {
[09:31:35.800]                         if (!is.null(pattern)) {
[09:31:35.800]                           computeRestarts <- base::computeRestarts
[09:31:35.800]                           grepl <- base::grepl
[09:31:35.800]                           restarts <- computeRestarts(cond)
[09:31:35.800]                           for (restart in restarts) {
[09:31:35.800]                             name <- restart$name
[09:31:35.800]                             if (is.null(name)) 
[09:31:35.800]                               next
[09:31:35.800]                             if (!grepl(pattern, name)) 
[09:31:35.800]                               next
[09:31:35.800]                             invokeRestart(restart)
[09:31:35.800]                             muffled <- TRUE
[09:31:35.800]                             break
[09:31:35.800]                           }
[09:31:35.800]                         }
[09:31:35.800]                       }
[09:31:35.800]                       invisible(muffled)
[09:31:35.800]                     }
[09:31:35.800]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.800]                   }
[09:31:35.800]                 }
[09:31:35.800]             }
[09:31:35.800]         }))
[09:31:35.800]     }, error = function(ex) {
[09:31:35.800]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.800]                 ...future.rng), started = ...future.startTime, 
[09:31:35.800]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.800]             version = "1.8"), class = "FutureResult")
[09:31:35.800]     }, finally = {
[09:31:35.800]         if (!identical(...future.workdir, getwd())) 
[09:31:35.800]             setwd(...future.workdir)
[09:31:35.800]         {
[09:31:35.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.800]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.800]             }
[09:31:35.800]             base::options(...future.oldOptions)
[09:31:35.800]             if (.Platform$OS.type == "windows") {
[09:31:35.800]                 old_names <- names(...future.oldEnvVars)
[09:31:35.800]                 envs <- base::Sys.getenv()
[09:31:35.800]                 names <- names(envs)
[09:31:35.800]                 common <- intersect(names, old_names)
[09:31:35.800]                 added <- setdiff(names, old_names)
[09:31:35.800]                 removed <- setdiff(old_names, names)
[09:31:35.800]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.800]                   envs[common]]
[09:31:35.800]                 NAMES <- toupper(changed)
[09:31:35.800]                 args <- list()
[09:31:35.800]                 for (kk in seq_along(NAMES)) {
[09:31:35.800]                   name <- changed[[kk]]
[09:31:35.800]                   NAME <- NAMES[[kk]]
[09:31:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.800]                     next
[09:31:35.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.800]                 }
[09:31:35.800]                 NAMES <- toupper(added)
[09:31:35.800]                 for (kk in seq_along(NAMES)) {
[09:31:35.800]                   name <- added[[kk]]
[09:31:35.800]                   NAME <- NAMES[[kk]]
[09:31:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.800]                     next
[09:31:35.800]                   args[[name]] <- ""
[09:31:35.800]                 }
[09:31:35.800]                 NAMES <- toupper(removed)
[09:31:35.800]                 for (kk in seq_along(NAMES)) {
[09:31:35.800]                   name <- removed[[kk]]
[09:31:35.800]                   NAME <- NAMES[[kk]]
[09:31:35.800]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.800]                     next
[09:31:35.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.800]                 }
[09:31:35.800]                 if (length(args) > 0) 
[09:31:35.800]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.800]             }
[09:31:35.800]             else {
[09:31:35.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.800]             }
[09:31:35.800]             {
[09:31:35.800]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.800]                   0L) {
[09:31:35.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.800]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.800]                   base::options(opts)
[09:31:35.800]                 }
[09:31:35.800]                 {
[09:31:35.800]                   {
[09:31:35.800]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.800]                     NULL
[09:31:35.800]                   }
[09:31:35.800]                   options(future.plan = NULL)
[09:31:35.800]                   if (is.na(NA_character_)) 
[09:31:35.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.800]                     .init = FALSE)
[09:31:35.800]                 }
[09:31:35.800]             }
[09:31:35.800]         }
[09:31:35.800]     })
[09:31:35.800]     if (TRUE) {
[09:31:35.800]         base::sink(type = "output", split = FALSE)
[09:31:35.800]         if (TRUE) {
[09:31:35.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.800]         }
[09:31:35.800]         else {
[09:31:35.800]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.800]         }
[09:31:35.800]         base::close(...future.stdout)
[09:31:35.800]         ...future.stdout <- NULL
[09:31:35.800]     }
[09:31:35.800]     ...future.result$conditions <- ...future.conditions
[09:31:35.800]     ...future.result$finished <- base::Sys.time()
[09:31:35.800]     ...future.result
[09:31:35.800] }
[09:31:35.802] MultisessionFuture started
[09:31:35.803] - Launch lazy future ... done
[09:31:35.803] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.803] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.803] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.804] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:35.804] Searching for globals ... DONE
[09:31:35.804] Resolving globals: TRUE
[09:31:35.804] Resolving any globals that are futures ...
[09:31:35.804] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:35.804] Resolving any globals that are futures ... DONE
[09:31:35.805] Resolving futures part of globals (recursively) ...
[09:31:35.805] resolve() on list ...
[09:31:35.805]  recursive: 99
[09:31:35.805]  length: 1
[09:31:35.805]  elements: ‘a’
[09:31:35.807] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.808] - Validating connection of MultisessionFuture
[09:31:35.808] - received message: FutureResult
[09:31:35.808] - Received FutureResult
[09:31:35.808] - Erased future from FutureRegistry
[09:31:35.808] result() for ClusterFuture ...
[09:31:35.808] - result already collected: FutureResult
[09:31:35.808] result() for ClusterFuture ... done
[09:31:35.808] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.808] Future #1
[09:31:35.808] result() for ClusterFuture ...
[09:31:35.809] - result already collected: FutureResult
[09:31:35.809] result() for ClusterFuture ... done
[09:31:35.809] result() for ClusterFuture ...
[09:31:35.809] - result already collected: FutureResult
[09:31:35.809] result() for ClusterFuture ... done
[09:31:35.809] A MultisessionFuture was resolved
[09:31:35.809]  length: 0 (resolved future 1)
[09:31:35.809] resolve() on list ... DONE
[09:31:35.809] - globals: [1] ‘a’
[09:31:35.809] Resolving futures part of globals (recursively) ... DONE
[09:31:35.810] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[09:31:35.811] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[09:31:35.811] - globals: [1] ‘a’
[09:31:35.811] - packages: [1] ‘future’
[09:31:35.811] getGlobalsAndPackages() ... DONE
[09:31:35.811] run() for ‘Future’ ...
[09:31:35.811] - state: ‘created’
[09:31:35.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.825]   - Field: ‘node’
[09:31:35.825]   - Field: ‘label’
[09:31:35.825]   - Field: ‘local’
[09:31:35.825]   - Field: ‘owner’
[09:31:35.825]   - Field: ‘envir’
[09:31:35.825]   - Field: ‘workers’
[09:31:35.826]   - Field: ‘packages’
[09:31:35.826]   - Field: ‘gc’
[09:31:35.826]   - Field: ‘conditions’
[09:31:35.826]   - Field: ‘persistent’
[09:31:35.826]   - Field: ‘expr’
[09:31:35.826]   - Field: ‘uuid’
[09:31:35.826]   - Field: ‘seed’
[09:31:35.826]   - Field: ‘version’
[09:31:35.826]   - Field: ‘result’
[09:31:35.826]   - Field: ‘asynchronous’
[09:31:35.826]   - Field: ‘calls’
[09:31:35.826]   - Field: ‘globals’
[09:31:35.827]   - Field: ‘stdout’
[09:31:35.827]   - Field: ‘earlySignal’
[09:31:35.827]   - Field: ‘lazy’
[09:31:35.827]   - Field: ‘state’
[09:31:35.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.827] - Launch lazy future ...
[09:31:35.827] Packages needed by the future expression (n = 1): ‘future’
[09:31:35.827] Packages needed by future strategies (n = 0): <none>
[09:31:35.828] {
[09:31:35.828]     {
[09:31:35.828]         {
[09:31:35.828]             ...future.startTime <- base::Sys.time()
[09:31:35.828]             {
[09:31:35.828]                 {
[09:31:35.828]                   {
[09:31:35.828]                     {
[09:31:35.828]                       {
[09:31:35.828]                         base::local({
[09:31:35.828]                           has_future <- base::requireNamespace("future", 
[09:31:35.828]                             quietly = TRUE)
[09:31:35.828]                           if (has_future) {
[09:31:35.828]                             ns <- base::getNamespace("future")
[09:31:35.828]                             version <- ns[[".package"]][["version"]]
[09:31:35.828]                             if (is.null(version)) 
[09:31:35.828]                               version <- utils::packageVersion("future")
[09:31:35.828]                           }
[09:31:35.828]                           else {
[09:31:35.828]                             version <- NULL
[09:31:35.828]                           }
[09:31:35.828]                           if (!has_future || version < "1.8.0") {
[09:31:35.828]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.828]                               "", base::R.version$version.string), 
[09:31:35.828]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:35.828]                                 base::R.version$platform, 8 * 
[09:31:35.828]                                   base::.Machine$sizeof.pointer), 
[09:31:35.828]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.828]                                 "release", "version")], collapse = " "), 
[09:31:35.828]                               hostname = base::Sys.info()[["nodename"]])
[09:31:35.828]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.828]                               info)
[09:31:35.828]                             info <- base::paste(info, collapse = "; ")
[09:31:35.828]                             if (!has_future) {
[09:31:35.828]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.828]                                 info)
[09:31:35.828]                             }
[09:31:35.828]                             else {
[09:31:35.828]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.828]                                 info, version)
[09:31:35.828]                             }
[09:31:35.828]                             base::stop(msg)
[09:31:35.828]                           }
[09:31:35.828]                         })
[09:31:35.828]                       }
[09:31:35.828]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.828]                       base::options(mc.cores = 1L)
[09:31:35.828]                     }
[09:31:35.828]                     base::local({
[09:31:35.828]                       for (pkg in "future") {
[09:31:35.828]                         base::loadNamespace(pkg)
[09:31:35.828]                         base::library(pkg, character.only = TRUE)
[09:31:35.828]                       }
[09:31:35.828]                     })
[09:31:35.828]                   }
[09:31:35.828]                   ...future.strategy.old <- future::plan("list")
[09:31:35.828]                   options(future.plan = NULL)
[09:31:35.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.828]                 }
[09:31:35.828]                 ...future.workdir <- getwd()
[09:31:35.828]             }
[09:31:35.828]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.828]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.828]         }
[09:31:35.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.828]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.828]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.828]             base::names(...future.oldOptions))
[09:31:35.828]     }
[09:31:35.828]     if (FALSE) {
[09:31:35.828]     }
[09:31:35.828]     else {
[09:31:35.828]         if (TRUE) {
[09:31:35.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.828]                 open = "w")
[09:31:35.828]         }
[09:31:35.828]         else {
[09:31:35.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.828]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.828]         }
[09:31:35.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.828]             base::sink(type = "output", split = FALSE)
[09:31:35.828]             base::close(...future.stdout)
[09:31:35.828]         }, add = TRUE)
[09:31:35.828]     }
[09:31:35.828]     ...future.frame <- base::sys.nframe()
[09:31:35.828]     ...future.conditions <- base::list()
[09:31:35.828]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.828]     if (FALSE) {
[09:31:35.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.828]     }
[09:31:35.828]     ...future.result <- base::tryCatch({
[09:31:35.828]         base::withCallingHandlers({
[09:31:35.828]             ...future.value <- base::withVisible(base::local({
[09:31:35.828]                 ...future.makeSendCondition <- base::local({
[09:31:35.828]                   sendCondition <- NULL
[09:31:35.828]                   function(frame = 1L) {
[09:31:35.828]                     if (is.function(sendCondition)) 
[09:31:35.828]                       return(sendCondition)
[09:31:35.828]                     ns <- getNamespace("parallel")
[09:31:35.828]                     if (exists("sendData", mode = "function", 
[09:31:35.828]                       envir = ns)) {
[09:31:35.828]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.828]                         envir = ns)
[09:31:35.828]                       envir <- sys.frame(frame)
[09:31:35.828]                       master <- NULL
[09:31:35.828]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.828]                         !identical(envir, emptyenv())) {
[09:31:35.828]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.828]                           inherits = FALSE)) {
[09:31:35.828]                           master <- get("master", mode = "list", 
[09:31:35.828]                             envir = envir, inherits = FALSE)
[09:31:35.828]                           if (inherits(master, c("SOCKnode", 
[09:31:35.828]                             "SOCK0node"))) {
[09:31:35.828]                             sendCondition <<- function(cond) {
[09:31:35.828]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.828]                                 success = TRUE)
[09:31:35.828]                               parallel_sendData(master, data)
[09:31:35.828]                             }
[09:31:35.828]                             return(sendCondition)
[09:31:35.828]                           }
[09:31:35.828]                         }
[09:31:35.828]                         frame <- frame + 1L
[09:31:35.828]                         envir <- sys.frame(frame)
[09:31:35.828]                       }
[09:31:35.828]                     }
[09:31:35.828]                     sendCondition <<- function(cond) NULL
[09:31:35.828]                   }
[09:31:35.828]                 })
[09:31:35.828]                 withCallingHandlers({
[09:31:35.828]                   value(a) + 1
[09:31:35.828]                 }, immediateCondition = function(cond) {
[09:31:35.828]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.828]                   sendCondition(cond)
[09:31:35.828]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.828]                   {
[09:31:35.828]                     inherits <- base::inherits
[09:31:35.828]                     invokeRestart <- base::invokeRestart
[09:31:35.828]                     is.null <- base::is.null
[09:31:35.828]                     muffled <- FALSE
[09:31:35.828]                     if (inherits(cond, "message")) {
[09:31:35.828]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.828]                       if (muffled) 
[09:31:35.828]                         invokeRestart("muffleMessage")
[09:31:35.828]                     }
[09:31:35.828]                     else if (inherits(cond, "warning")) {
[09:31:35.828]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.828]                       if (muffled) 
[09:31:35.828]                         invokeRestart("muffleWarning")
[09:31:35.828]                     }
[09:31:35.828]                     else if (inherits(cond, "condition")) {
[09:31:35.828]                       if (!is.null(pattern)) {
[09:31:35.828]                         computeRestarts <- base::computeRestarts
[09:31:35.828]                         grepl <- base::grepl
[09:31:35.828]                         restarts <- computeRestarts(cond)
[09:31:35.828]                         for (restart in restarts) {
[09:31:35.828]                           name <- restart$name
[09:31:35.828]                           if (is.null(name)) 
[09:31:35.828]                             next
[09:31:35.828]                           if (!grepl(pattern, name)) 
[09:31:35.828]                             next
[09:31:35.828]                           invokeRestart(restart)
[09:31:35.828]                           muffled <- TRUE
[09:31:35.828]                           break
[09:31:35.828]                         }
[09:31:35.828]                       }
[09:31:35.828]                     }
[09:31:35.828]                     invisible(muffled)
[09:31:35.828]                   }
[09:31:35.828]                   muffleCondition(cond)
[09:31:35.828]                 })
[09:31:35.828]             }))
[09:31:35.828]             future::FutureResult(value = ...future.value$value, 
[09:31:35.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.828]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.828]                     ...future.globalenv.names))
[09:31:35.828]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.828]         }, condition = base::local({
[09:31:35.828]             c <- base::c
[09:31:35.828]             inherits <- base::inherits
[09:31:35.828]             invokeRestart <- base::invokeRestart
[09:31:35.828]             length <- base::length
[09:31:35.828]             list <- base::list
[09:31:35.828]             seq.int <- base::seq.int
[09:31:35.828]             signalCondition <- base::signalCondition
[09:31:35.828]             sys.calls <- base::sys.calls
[09:31:35.828]             `[[` <- base::`[[`
[09:31:35.828]             `+` <- base::`+`
[09:31:35.828]             `<<-` <- base::`<<-`
[09:31:35.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.828]                   3L)]
[09:31:35.828]             }
[09:31:35.828]             function(cond) {
[09:31:35.828]                 is_error <- inherits(cond, "error")
[09:31:35.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.828]                   NULL)
[09:31:35.828]                 if (is_error) {
[09:31:35.828]                   sessionInformation <- function() {
[09:31:35.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.828]                       search = base::search(), system = base::Sys.info())
[09:31:35.828]                   }
[09:31:35.828]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.828]                     cond$call), session = sessionInformation(), 
[09:31:35.828]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.828]                   signalCondition(cond)
[09:31:35.828]                 }
[09:31:35.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.828]                 "immediateCondition"))) {
[09:31:35.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.828]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.828]                   if (TRUE && !signal) {
[09:31:35.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.828]                     {
[09:31:35.828]                       inherits <- base::inherits
[09:31:35.828]                       invokeRestart <- base::invokeRestart
[09:31:35.828]                       is.null <- base::is.null
[09:31:35.828]                       muffled <- FALSE
[09:31:35.828]                       if (inherits(cond, "message")) {
[09:31:35.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.828]                         if (muffled) 
[09:31:35.828]                           invokeRestart("muffleMessage")
[09:31:35.828]                       }
[09:31:35.828]                       else if (inherits(cond, "warning")) {
[09:31:35.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.828]                         if (muffled) 
[09:31:35.828]                           invokeRestart("muffleWarning")
[09:31:35.828]                       }
[09:31:35.828]                       else if (inherits(cond, "condition")) {
[09:31:35.828]                         if (!is.null(pattern)) {
[09:31:35.828]                           computeRestarts <- base::computeRestarts
[09:31:35.828]                           grepl <- base::grepl
[09:31:35.828]                           restarts <- computeRestarts(cond)
[09:31:35.828]                           for (restart in restarts) {
[09:31:35.828]                             name <- restart$name
[09:31:35.828]                             if (is.null(name)) 
[09:31:35.828]                               next
[09:31:35.828]                             if (!grepl(pattern, name)) 
[09:31:35.828]                               next
[09:31:35.828]                             invokeRestart(restart)
[09:31:35.828]                             muffled <- TRUE
[09:31:35.828]                             break
[09:31:35.828]                           }
[09:31:35.828]                         }
[09:31:35.828]                       }
[09:31:35.828]                       invisible(muffled)
[09:31:35.828]                     }
[09:31:35.828]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.828]                   }
[09:31:35.828]                 }
[09:31:35.828]                 else {
[09:31:35.828]                   if (TRUE) {
[09:31:35.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.828]                     {
[09:31:35.828]                       inherits <- base::inherits
[09:31:35.828]                       invokeRestart <- base::invokeRestart
[09:31:35.828]                       is.null <- base::is.null
[09:31:35.828]                       muffled <- FALSE
[09:31:35.828]                       if (inherits(cond, "message")) {
[09:31:35.828]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.828]                         if (muffled) 
[09:31:35.828]                           invokeRestart("muffleMessage")
[09:31:35.828]                       }
[09:31:35.828]                       else if (inherits(cond, "warning")) {
[09:31:35.828]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.828]                         if (muffled) 
[09:31:35.828]                           invokeRestart("muffleWarning")
[09:31:35.828]                       }
[09:31:35.828]                       else if (inherits(cond, "condition")) {
[09:31:35.828]                         if (!is.null(pattern)) {
[09:31:35.828]                           computeRestarts <- base::computeRestarts
[09:31:35.828]                           grepl <- base::grepl
[09:31:35.828]                           restarts <- computeRestarts(cond)
[09:31:35.828]                           for (restart in restarts) {
[09:31:35.828]                             name <- restart$name
[09:31:35.828]                             if (is.null(name)) 
[09:31:35.828]                               next
[09:31:35.828]                             if (!grepl(pattern, name)) 
[09:31:35.828]                               next
[09:31:35.828]                             invokeRestart(restart)
[09:31:35.828]                             muffled <- TRUE
[09:31:35.828]                             break
[09:31:35.828]                           }
[09:31:35.828]                         }
[09:31:35.828]                       }
[09:31:35.828]                       invisible(muffled)
[09:31:35.828]                     }
[09:31:35.828]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.828]                   }
[09:31:35.828]                 }
[09:31:35.828]             }
[09:31:35.828]         }))
[09:31:35.828]     }, error = function(ex) {
[09:31:35.828]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.828]                 ...future.rng), started = ...future.startTime, 
[09:31:35.828]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.828]             version = "1.8"), class = "FutureResult")
[09:31:35.828]     }, finally = {
[09:31:35.828]         if (!identical(...future.workdir, getwd())) 
[09:31:35.828]             setwd(...future.workdir)
[09:31:35.828]         {
[09:31:35.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.828]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.828]             }
[09:31:35.828]             base::options(...future.oldOptions)
[09:31:35.828]             if (.Platform$OS.type == "windows") {
[09:31:35.828]                 old_names <- names(...future.oldEnvVars)
[09:31:35.828]                 envs <- base::Sys.getenv()
[09:31:35.828]                 names <- names(envs)
[09:31:35.828]                 common <- intersect(names, old_names)
[09:31:35.828]                 added <- setdiff(names, old_names)
[09:31:35.828]                 removed <- setdiff(old_names, names)
[09:31:35.828]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.828]                   envs[common]]
[09:31:35.828]                 NAMES <- toupper(changed)
[09:31:35.828]                 args <- list()
[09:31:35.828]                 for (kk in seq_along(NAMES)) {
[09:31:35.828]                   name <- changed[[kk]]
[09:31:35.828]                   NAME <- NAMES[[kk]]
[09:31:35.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.828]                     next
[09:31:35.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.828]                 }
[09:31:35.828]                 NAMES <- toupper(added)
[09:31:35.828]                 for (kk in seq_along(NAMES)) {
[09:31:35.828]                   name <- added[[kk]]
[09:31:35.828]                   NAME <- NAMES[[kk]]
[09:31:35.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.828]                     next
[09:31:35.828]                   args[[name]] <- ""
[09:31:35.828]                 }
[09:31:35.828]                 NAMES <- toupper(removed)
[09:31:35.828]                 for (kk in seq_along(NAMES)) {
[09:31:35.828]                   name <- removed[[kk]]
[09:31:35.828]                   NAME <- NAMES[[kk]]
[09:31:35.828]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.828]                     next
[09:31:35.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.828]                 }
[09:31:35.828]                 if (length(args) > 0) 
[09:31:35.828]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.828]             }
[09:31:35.828]             else {
[09:31:35.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.828]             }
[09:31:35.828]             {
[09:31:35.828]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.828]                   0L) {
[09:31:35.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.828]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.828]                   base::options(opts)
[09:31:35.828]                 }
[09:31:35.828]                 {
[09:31:35.828]                   {
[09:31:35.828]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.828]                     NULL
[09:31:35.828]                   }
[09:31:35.828]                   options(future.plan = NULL)
[09:31:35.828]                   if (is.na(NA_character_)) 
[09:31:35.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.828]                     .init = FALSE)
[09:31:35.828]                 }
[09:31:35.828]             }
[09:31:35.828]         }
[09:31:35.828]     })
[09:31:35.828]     if (TRUE) {
[09:31:35.828]         base::sink(type = "output", split = FALSE)
[09:31:35.828]         if (TRUE) {
[09:31:35.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.828]         }
[09:31:35.828]         else {
[09:31:35.828]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.828]         }
[09:31:35.828]         base::close(...future.stdout)
[09:31:35.828]         ...future.stdout <- NULL
[09:31:35.828]     }
[09:31:35.828]     ...future.result$conditions <- ...future.conditions
[09:31:35.828]     ...future.result$finished <- base::Sys.time()
[09:31:35.828]     ...future.result
[09:31:35.828] }
[09:31:35.830] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[09:31:35.833] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[09:31:35.884] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[09:31:35.884] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[09:31:35.885] MultisessionFuture started
[09:31:35.885] - Launch lazy future ... done
[09:31:35.885] run() for ‘MultisessionFuture’ ... done
[09:31:35.885] result() for ClusterFuture ...
[09:31:35.885] receiveMessageFromWorker() for ClusterFuture ...
[09:31:35.885] - Validating connection of MultisessionFuture
[09:31:35.933] - received message: FutureResult
[09:31:35.933] - Received FutureResult
[09:31:35.933] - Erased future from FutureRegistry
[09:31:35.934] result() for ClusterFuture ...
[09:31:35.934] - result already collected: FutureResult
[09:31:35.934] result() for ClusterFuture ... done
[09:31:35.934] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:35.934] result() for ClusterFuture ... done
[09:31:35.934] result() for ClusterFuture ...
[09:31:35.934] - result already collected: FutureResult
[09:31:35.934] result() for ClusterFuture ... done
value(b) = 2
[09:31:35.934] result() for ClusterFuture ...
[09:31:35.934] - result already collected: FutureResult
[09:31:35.934] result() for ClusterFuture ... done
[09:31:35.935] result() for ClusterFuture ...
[09:31:35.935] - result already collected: FutureResult
[09:31:35.935] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.935] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.935] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.936] 
[09:31:35.936] Searching for globals ... DONE
[09:31:35.936] - globals: [0] <none>
[09:31:35.936] getGlobalsAndPackages() ... DONE
[09:31:35.936] run() for ‘Future’ ...
[09:31:35.936] - state: ‘created’
[09:31:35.936] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:35.951] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:35.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:35.951]   - Field: ‘node’
[09:31:35.951]   - Field: ‘label’
[09:31:35.951]   - Field: ‘local’
[09:31:35.951]   - Field: ‘owner’
[09:31:35.951]   - Field: ‘envir’
[09:31:35.951]   - Field: ‘workers’
[09:31:35.951]   - Field: ‘packages’
[09:31:35.951]   - Field: ‘gc’
[09:31:35.952]   - Field: ‘conditions’
[09:31:35.952]   - Field: ‘persistent’
[09:31:35.952]   - Field: ‘expr’
[09:31:35.952]   - Field: ‘uuid’
[09:31:35.952]   - Field: ‘seed’
[09:31:35.952]   - Field: ‘version’
[09:31:35.952]   - Field: ‘result’
[09:31:35.952]   - Field: ‘asynchronous’
[09:31:35.952]   - Field: ‘calls’
[09:31:35.952]   - Field: ‘globals’
[09:31:35.952]   - Field: ‘stdout’
[09:31:35.953]   - Field: ‘earlySignal’
[09:31:35.953]   - Field: ‘lazy’
[09:31:35.953]   - Field: ‘state’
[09:31:35.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:35.953] - Launch lazy future ...
[09:31:35.953] Packages needed by the future expression (n = 0): <none>
[09:31:35.953] Packages needed by future strategies (n = 0): <none>
[09:31:35.954] {
[09:31:35.954]     {
[09:31:35.954]         {
[09:31:35.954]             ...future.startTime <- base::Sys.time()
[09:31:35.954]             {
[09:31:35.954]                 {
[09:31:35.954]                   {
[09:31:35.954]                     {
[09:31:35.954]                       base::local({
[09:31:35.954]                         has_future <- base::requireNamespace("future", 
[09:31:35.954]                           quietly = TRUE)
[09:31:35.954]                         if (has_future) {
[09:31:35.954]                           ns <- base::getNamespace("future")
[09:31:35.954]                           version <- ns[[".package"]][["version"]]
[09:31:35.954]                           if (is.null(version)) 
[09:31:35.954]                             version <- utils::packageVersion("future")
[09:31:35.954]                         }
[09:31:35.954]                         else {
[09:31:35.954]                           version <- NULL
[09:31:35.954]                         }
[09:31:35.954]                         if (!has_future || version < "1.8.0") {
[09:31:35.954]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:35.954]                             "", base::R.version$version.string), 
[09:31:35.954]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:35.954]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:35.954]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:35.954]                               "release", "version")], collapse = " "), 
[09:31:35.954]                             hostname = base::Sys.info()[["nodename"]])
[09:31:35.954]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:35.954]                             info)
[09:31:35.954]                           info <- base::paste(info, collapse = "; ")
[09:31:35.954]                           if (!has_future) {
[09:31:35.954]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:35.954]                               info)
[09:31:35.954]                           }
[09:31:35.954]                           else {
[09:31:35.954]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:35.954]                               info, version)
[09:31:35.954]                           }
[09:31:35.954]                           base::stop(msg)
[09:31:35.954]                         }
[09:31:35.954]                       })
[09:31:35.954]                     }
[09:31:35.954]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:35.954]                     base::options(mc.cores = 1L)
[09:31:35.954]                   }
[09:31:35.954]                   ...future.strategy.old <- future::plan("list")
[09:31:35.954]                   options(future.plan = NULL)
[09:31:35.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:35.954]                 }
[09:31:35.954]                 ...future.workdir <- getwd()
[09:31:35.954]             }
[09:31:35.954]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:35.954]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:35.954]         }
[09:31:35.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:35.954]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:35.954]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:35.954]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:35.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:35.954]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:35.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:35.954]             base::names(...future.oldOptions))
[09:31:35.954]     }
[09:31:35.954]     if (FALSE) {
[09:31:35.954]     }
[09:31:35.954]     else {
[09:31:35.954]         if (TRUE) {
[09:31:35.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:35.954]                 open = "w")
[09:31:35.954]         }
[09:31:35.954]         else {
[09:31:35.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:35.954]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:35.954]         }
[09:31:35.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:35.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:35.954]             base::sink(type = "output", split = FALSE)
[09:31:35.954]             base::close(...future.stdout)
[09:31:35.954]         }, add = TRUE)
[09:31:35.954]     }
[09:31:35.954]     ...future.frame <- base::sys.nframe()
[09:31:35.954]     ...future.conditions <- base::list()
[09:31:35.954]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:35.954]     if (FALSE) {
[09:31:35.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:35.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:35.954]     }
[09:31:35.954]     ...future.result <- base::tryCatch({
[09:31:35.954]         base::withCallingHandlers({
[09:31:35.954]             ...future.value <- base::withVisible(base::local({
[09:31:35.954]                 ...future.makeSendCondition <- base::local({
[09:31:35.954]                   sendCondition <- NULL
[09:31:35.954]                   function(frame = 1L) {
[09:31:35.954]                     if (is.function(sendCondition)) 
[09:31:35.954]                       return(sendCondition)
[09:31:35.954]                     ns <- getNamespace("parallel")
[09:31:35.954]                     if (exists("sendData", mode = "function", 
[09:31:35.954]                       envir = ns)) {
[09:31:35.954]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:35.954]                         envir = ns)
[09:31:35.954]                       envir <- sys.frame(frame)
[09:31:35.954]                       master <- NULL
[09:31:35.954]                       while (!identical(envir, .GlobalEnv) && 
[09:31:35.954]                         !identical(envir, emptyenv())) {
[09:31:35.954]                         if (exists("master", mode = "list", envir = envir, 
[09:31:35.954]                           inherits = FALSE)) {
[09:31:35.954]                           master <- get("master", mode = "list", 
[09:31:35.954]                             envir = envir, inherits = FALSE)
[09:31:35.954]                           if (inherits(master, c("SOCKnode", 
[09:31:35.954]                             "SOCK0node"))) {
[09:31:35.954]                             sendCondition <<- function(cond) {
[09:31:35.954]                               data <- list(type = "VALUE", value = cond, 
[09:31:35.954]                                 success = TRUE)
[09:31:35.954]                               parallel_sendData(master, data)
[09:31:35.954]                             }
[09:31:35.954]                             return(sendCondition)
[09:31:35.954]                           }
[09:31:35.954]                         }
[09:31:35.954]                         frame <- frame + 1L
[09:31:35.954]                         envir <- sys.frame(frame)
[09:31:35.954]                       }
[09:31:35.954]                     }
[09:31:35.954]                     sendCondition <<- function(cond) NULL
[09:31:35.954]                   }
[09:31:35.954]                 })
[09:31:35.954]                 withCallingHandlers({
[09:31:35.954]                   1
[09:31:35.954]                 }, immediateCondition = function(cond) {
[09:31:35.954]                   sendCondition <- ...future.makeSendCondition()
[09:31:35.954]                   sendCondition(cond)
[09:31:35.954]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.954]                   {
[09:31:35.954]                     inherits <- base::inherits
[09:31:35.954]                     invokeRestart <- base::invokeRestart
[09:31:35.954]                     is.null <- base::is.null
[09:31:35.954]                     muffled <- FALSE
[09:31:35.954]                     if (inherits(cond, "message")) {
[09:31:35.954]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:35.954]                       if (muffled) 
[09:31:35.954]                         invokeRestart("muffleMessage")
[09:31:35.954]                     }
[09:31:35.954]                     else if (inherits(cond, "warning")) {
[09:31:35.954]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:35.954]                       if (muffled) 
[09:31:35.954]                         invokeRestart("muffleWarning")
[09:31:35.954]                     }
[09:31:35.954]                     else if (inherits(cond, "condition")) {
[09:31:35.954]                       if (!is.null(pattern)) {
[09:31:35.954]                         computeRestarts <- base::computeRestarts
[09:31:35.954]                         grepl <- base::grepl
[09:31:35.954]                         restarts <- computeRestarts(cond)
[09:31:35.954]                         for (restart in restarts) {
[09:31:35.954]                           name <- restart$name
[09:31:35.954]                           if (is.null(name)) 
[09:31:35.954]                             next
[09:31:35.954]                           if (!grepl(pattern, name)) 
[09:31:35.954]                             next
[09:31:35.954]                           invokeRestart(restart)
[09:31:35.954]                           muffled <- TRUE
[09:31:35.954]                           break
[09:31:35.954]                         }
[09:31:35.954]                       }
[09:31:35.954]                     }
[09:31:35.954]                     invisible(muffled)
[09:31:35.954]                   }
[09:31:35.954]                   muffleCondition(cond)
[09:31:35.954]                 })
[09:31:35.954]             }))
[09:31:35.954]             future::FutureResult(value = ...future.value$value, 
[09:31:35.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.954]                   ...future.rng), globalenv = if (FALSE) 
[09:31:35.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:35.954]                     ...future.globalenv.names))
[09:31:35.954]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:35.954]         }, condition = base::local({
[09:31:35.954]             c <- base::c
[09:31:35.954]             inherits <- base::inherits
[09:31:35.954]             invokeRestart <- base::invokeRestart
[09:31:35.954]             length <- base::length
[09:31:35.954]             list <- base::list
[09:31:35.954]             seq.int <- base::seq.int
[09:31:35.954]             signalCondition <- base::signalCondition
[09:31:35.954]             sys.calls <- base::sys.calls
[09:31:35.954]             `[[` <- base::`[[`
[09:31:35.954]             `+` <- base::`+`
[09:31:35.954]             `<<-` <- base::`<<-`
[09:31:35.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:35.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:35.954]                   3L)]
[09:31:35.954]             }
[09:31:35.954]             function(cond) {
[09:31:35.954]                 is_error <- inherits(cond, "error")
[09:31:35.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:35.954]                   NULL)
[09:31:35.954]                 if (is_error) {
[09:31:35.954]                   sessionInformation <- function() {
[09:31:35.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:35.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:35.954]                       search = base::search(), system = base::Sys.info())
[09:31:35.954]                   }
[09:31:35.954]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:35.954]                     cond$call), session = sessionInformation(), 
[09:31:35.954]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:35.954]                   signalCondition(cond)
[09:31:35.954]                 }
[09:31:35.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:35.954]                 "immediateCondition"))) {
[09:31:35.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:35.954]                   ...future.conditions[[length(...future.conditions) + 
[09:31:35.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:35.954]                   if (TRUE && !signal) {
[09:31:35.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.954]                     {
[09:31:35.954]                       inherits <- base::inherits
[09:31:35.954]                       invokeRestart <- base::invokeRestart
[09:31:35.954]                       is.null <- base::is.null
[09:31:35.954]                       muffled <- FALSE
[09:31:35.954]                       if (inherits(cond, "message")) {
[09:31:35.954]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.954]                         if (muffled) 
[09:31:35.954]                           invokeRestart("muffleMessage")
[09:31:35.954]                       }
[09:31:35.954]                       else if (inherits(cond, "warning")) {
[09:31:35.954]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.954]                         if (muffled) 
[09:31:35.954]                           invokeRestart("muffleWarning")
[09:31:35.954]                       }
[09:31:35.954]                       else if (inherits(cond, "condition")) {
[09:31:35.954]                         if (!is.null(pattern)) {
[09:31:35.954]                           computeRestarts <- base::computeRestarts
[09:31:35.954]                           grepl <- base::grepl
[09:31:35.954]                           restarts <- computeRestarts(cond)
[09:31:35.954]                           for (restart in restarts) {
[09:31:35.954]                             name <- restart$name
[09:31:35.954]                             if (is.null(name)) 
[09:31:35.954]                               next
[09:31:35.954]                             if (!grepl(pattern, name)) 
[09:31:35.954]                               next
[09:31:35.954]                             invokeRestart(restart)
[09:31:35.954]                             muffled <- TRUE
[09:31:35.954]                             break
[09:31:35.954]                           }
[09:31:35.954]                         }
[09:31:35.954]                       }
[09:31:35.954]                       invisible(muffled)
[09:31:35.954]                     }
[09:31:35.954]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.954]                   }
[09:31:35.954]                 }
[09:31:35.954]                 else {
[09:31:35.954]                   if (TRUE) {
[09:31:35.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:35.954]                     {
[09:31:35.954]                       inherits <- base::inherits
[09:31:35.954]                       invokeRestart <- base::invokeRestart
[09:31:35.954]                       is.null <- base::is.null
[09:31:35.954]                       muffled <- FALSE
[09:31:35.954]                       if (inherits(cond, "message")) {
[09:31:35.954]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:35.954]                         if (muffled) 
[09:31:35.954]                           invokeRestart("muffleMessage")
[09:31:35.954]                       }
[09:31:35.954]                       else if (inherits(cond, "warning")) {
[09:31:35.954]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:35.954]                         if (muffled) 
[09:31:35.954]                           invokeRestart("muffleWarning")
[09:31:35.954]                       }
[09:31:35.954]                       else if (inherits(cond, "condition")) {
[09:31:35.954]                         if (!is.null(pattern)) {
[09:31:35.954]                           computeRestarts <- base::computeRestarts
[09:31:35.954]                           grepl <- base::grepl
[09:31:35.954]                           restarts <- computeRestarts(cond)
[09:31:35.954]                           for (restart in restarts) {
[09:31:35.954]                             name <- restart$name
[09:31:35.954]                             if (is.null(name)) 
[09:31:35.954]                               next
[09:31:35.954]                             if (!grepl(pattern, name)) 
[09:31:35.954]                               next
[09:31:35.954]                             invokeRestart(restart)
[09:31:35.954]                             muffled <- TRUE
[09:31:35.954]                             break
[09:31:35.954]                           }
[09:31:35.954]                         }
[09:31:35.954]                       }
[09:31:35.954]                       invisible(muffled)
[09:31:35.954]                     }
[09:31:35.954]                     muffleCondition(cond, pattern = "^muffle")
[09:31:35.954]                   }
[09:31:35.954]                 }
[09:31:35.954]             }
[09:31:35.954]         }))
[09:31:35.954]     }, error = function(ex) {
[09:31:35.954]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:35.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:35.954]                 ...future.rng), started = ...future.startTime, 
[09:31:35.954]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:35.954]             version = "1.8"), class = "FutureResult")
[09:31:35.954]     }, finally = {
[09:31:35.954]         if (!identical(...future.workdir, getwd())) 
[09:31:35.954]             setwd(...future.workdir)
[09:31:35.954]         {
[09:31:35.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:35.954]                 ...future.oldOptions$nwarnings <- NULL
[09:31:35.954]             }
[09:31:35.954]             base::options(...future.oldOptions)
[09:31:35.954]             if (.Platform$OS.type == "windows") {
[09:31:35.954]                 old_names <- names(...future.oldEnvVars)
[09:31:35.954]                 envs <- base::Sys.getenv()
[09:31:35.954]                 names <- names(envs)
[09:31:35.954]                 common <- intersect(names, old_names)
[09:31:35.954]                 added <- setdiff(names, old_names)
[09:31:35.954]                 removed <- setdiff(old_names, names)
[09:31:35.954]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:35.954]                   envs[common]]
[09:31:35.954]                 NAMES <- toupper(changed)
[09:31:35.954]                 args <- list()
[09:31:35.954]                 for (kk in seq_along(NAMES)) {
[09:31:35.954]                   name <- changed[[kk]]
[09:31:35.954]                   NAME <- NAMES[[kk]]
[09:31:35.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.954]                     next
[09:31:35.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.954]                 }
[09:31:35.954]                 NAMES <- toupper(added)
[09:31:35.954]                 for (kk in seq_along(NAMES)) {
[09:31:35.954]                   name <- added[[kk]]
[09:31:35.954]                   NAME <- NAMES[[kk]]
[09:31:35.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.954]                     next
[09:31:35.954]                   args[[name]] <- ""
[09:31:35.954]                 }
[09:31:35.954]                 NAMES <- toupper(removed)
[09:31:35.954]                 for (kk in seq_along(NAMES)) {
[09:31:35.954]                   name <- removed[[kk]]
[09:31:35.954]                   NAME <- NAMES[[kk]]
[09:31:35.954]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:35.954]                     next
[09:31:35.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:35.954]                 }
[09:31:35.954]                 if (length(args) > 0) 
[09:31:35.954]                   base::do.call(base::Sys.setenv, args = args)
[09:31:35.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:35.954]             }
[09:31:35.954]             else {
[09:31:35.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:35.954]             }
[09:31:35.954]             {
[09:31:35.954]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:35.954]                   0L) {
[09:31:35.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:35.954]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:35.954]                   base::options(opts)
[09:31:35.954]                 }
[09:31:35.954]                 {
[09:31:35.954]                   {
[09:31:35.954]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:35.954]                     NULL
[09:31:35.954]                   }
[09:31:35.954]                   options(future.plan = NULL)
[09:31:35.954]                   if (is.na(NA_character_)) 
[09:31:35.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:35.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:35.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:35.954]                     .init = FALSE)
[09:31:35.954]                 }
[09:31:35.954]             }
[09:31:35.954]         }
[09:31:35.954]     })
[09:31:35.954]     if (TRUE) {
[09:31:35.954]         base::sink(type = "output", split = FALSE)
[09:31:35.954]         if (TRUE) {
[09:31:35.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:35.954]         }
[09:31:35.954]         else {
[09:31:35.954]             ...future.result["stdout"] <- base::list(NULL)
[09:31:35.954]         }
[09:31:35.954]         base::close(...future.stdout)
[09:31:35.954]         ...future.stdout <- NULL
[09:31:35.954]     }
[09:31:35.954]     ...future.result$conditions <- ...future.conditions
[09:31:35.954]     ...future.result$finished <- base::Sys.time()
[09:31:35.954]     ...future.result
[09:31:35.954] }
[09:31:35.956] MultisessionFuture started
[09:31:35.956] - Launch lazy future ... done
[09:31:35.957] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:35.957] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:35.957] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:35.958] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:35.958] Searching for globals ... DONE
[09:31:35.958] Resolving globals: TRUE
[09:31:35.958] Resolving any globals that are futures ...
[09:31:35.958] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:35.958] Resolving any globals that are futures ... DONE
[09:31:35.959] Resolving futures part of globals (recursively) ...
[09:31:35.959] resolve() on list ...
[09:31:35.959]  recursive: 99
[09:31:35.959]  length: 1
[09:31:35.959]  elements: ‘a’
[09:31:36.001] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.001] - Validating connection of MultisessionFuture
[09:31:36.001] - received message: FutureResult
[09:31:36.002] - Received FutureResult
[09:31:36.002] - Erased future from FutureRegistry
[09:31:36.002] result() for ClusterFuture ...
[09:31:36.002] - result already collected: FutureResult
[09:31:36.002] result() for ClusterFuture ... done
[09:31:36.002] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.002] Future #1
[09:31:36.002] result() for ClusterFuture ...
[09:31:36.002] - result already collected: FutureResult
[09:31:36.002] result() for ClusterFuture ... done
[09:31:36.002] result() for ClusterFuture ...
[09:31:36.003] - result already collected: FutureResult
[09:31:36.003] result() for ClusterFuture ... done
[09:31:36.003] A MultisessionFuture was resolved
[09:31:36.003]  length: 0 (resolved future 1)
[09:31:36.003] resolve() on list ... DONE
[09:31:36.003] - globals: [1] ‘a’
[09:31:36.003] Resolving futures part of globals (recursively) ... DONE
[09:31:36.004] The total size of the 1 globals is 10.29 KiB (10536 bytes)
[09:31:36.004] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.29 KiB of class ‘environment’)
[09:31:36.004] - globals: [1] ‘a’
[09:31:36.005] - packages: [1] ‘future’
[09:31:36.005] getGlobalsAndPackages() ... DONE
[09:31:36.005] run() for ‘Future’ ...
[09:31:36.005] - state: ‘created’
[09:31:36.005] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.019] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.020]   - Field: ‘node’
[09:31:36.020]   - Field: ‘label’
[09:31:36.020]   - Field: ‘local’
[09:31:36.020]   - Field: ‘owner’
[09:31:36.020]   - Field: ‘envir’
[09:31:36.020]   - Field: ‘workers’
[09:31:36.020]   - Field: ‘packages’
[09:31:36.020]   - Field: ‘gc’
[09:31:36.020]   - Field: ‘conditions’
[09:31:36.020]   - Field: ‘persistent’
[09:31:36.021]   - Field: ‘expr’
[09:31:36.021]   - Field: ‘uuid’
[09:31:36.021]   - Field: ‘seed’
[09:31:36.021]   - Field: ‘version’
[09:31:36.021]   - Field: ‘result’
[09:31:36.021]   - Field: ‘asynchronous’
[09:31:36.021]   - Field: ‘calls’
[09:31:36.021]   - Field: ‘globals’
[09:31:36.021]   - Field: ‘stdout’
[09:31:36.021]   - Field: ‘earlySignal’
[09:31:36.021]   - Field: ‘lazy’
[09:31:36.021]   - Field: ‘state’
[09:31:36.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.022] - Launch lazy future ...
[09:31:36.022] Packages needed by the future expression (n = 1): ‘future’
[09:31:36.022] Packages needed by future strategies (n = 0): <none>
[09:31:36.022] {
[09:31:36.022]     {
[09:31:36.022]         {
[09:31:36.022]             ...future.startTime <- base::Sys.time()
[09:31:36.022]             {
[09:31:36.022]                 {
[09:31:36.022]                   {
[09:31:36.022]                     {
[09:31:36.022]                       {
[09:31:36.022]                         base::local({
[09:31:36.022]                           has_future <- base::requireNamespace("future", 
[09:31:36.022]                             quietly = TRUE)
[09:31:36.022]                           if (has_future) {
[09:31:36.022]                             ns <- base::getNamespace("future")
[09:31:36.022]                             version <- ns[[".package"]][["version"]]
[09:31:36.022]                             if (is.null(version)) 
[09:31:36.022]                               version <- utils::packageVersion("future")
[09:31:36.022]                           }
[09:31:36.022]                           else {
[09:31:36.022]                             version <- NULL
[09:31:36.022]                           }
[09:31:36.022]                           if (!has_future || version < "1.8.0") {
[09:31:36.022]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.022]                               "", base::R.version$version.string), 
[09:31:36.022]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:36.022]                                 base::R.version$platform, 8 * 
[09:31:36.022]                                   base::.Machine$sizeof.pointer), 
[09:31:36.022]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.022]                                 "release", "version")], collapse = " "), 
[09:31:36.022]                               hostname = base::Sys.info()[["nodename"]])
[09:31:36.022]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.022]                               info)
[09:31:36.022]                             info <- base::paste(info, collapse = "; ")
[09:31:36.022]                             if (!has_future) {
[09:31:36.022]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.022]                                 info)
[09:31:36.022]                             }
[09:31:36.022]                             else {
[09:31:36.022]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.022]                                 info, version)
[09:31:36.022]                             }
[09:31:36.022]                             base::stop(msg)
[09:31:36.022]                           }
[09:31:36.022]                         })
[09:31:36.022]                       }
[09:31:36.022]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.022]                       base::options(mc.cores = 1L)
[09:31:36.022]                     }
[09:31:36.022]                     base::local({
[09:31:36.022]                       for (pkg in "future") {
[09:31:36.022]                         base::loadNamespace(pkg)
[09:31:36.022]                         base::library(pkg, character.only = TRUE)
[09:31:36.022]                       }
[09:31:36.022]                     })
[09:31:36.022]                   }
[09:31:36.022]                   ...future.strategy.old <- future::plan("list")
[09:31:36.022]                   options(future.plan = NULL)
[09:31:36.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.022]                 }
[09:31:36.022]                 ...future.workdir <- getwd()
[09:31:36.022]             }
[09:31:36.022]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.022]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.022]         }
[09:31:36.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.022]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.022]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.022]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.022]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.022]             base::names(...future.oldOptions))
[09:31:36.022]     }
[09:31:36.022]     if (FALSE) {
[09:31:36.022]     }
[09:31:36.022]     else {
[09:31:36.022]         if (TRUE) {
[09:31:36.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.022]                 open = "w")
[09:31:36.022]         }
[09:31:36.022]         else {
[09:31:36.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.022]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.022]         }
[09:31:36.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.022]             base::sink(type = "output", split = FALSE)
[09:31:36.022]             base::close(...future.stdout)
[09:31:36.022]         }, add = TRUE)
[09:31:36.022]     }
[09:31:36.022]     ...future.frame <- base::sys.nframe()
[09:31:36.022]     ...future.conditions <- base::list()
[09:31:36.022]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.022]     if (FALSE) {
[09:31:36.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.022]     }
[09:31:36.022]     ...future.result <- base::tryCatch({
[09:31:36.022]         base::withCallingHandlers({
[09:31:36.022]             ...future.value <- base::withVisible(base::local({
[09:31:36.022]                 ...future.makeSendCondition <- base::local({
[09:31:36.022]                   sendCondition <- NULL
[09:31:36.022]                   function(frame = 1L) {
[09:31:36.022]                     if (is.function(sendCondition)) 
[09:31:36.022]                       return(sendCondition)
[09:31:36.022]                     ns <- getNamespace("parallel")
[09:31:36.022]                     if (exists("sendData", mode = "function", 
[09:31:36.022]                       envir = ns)) {
[09:31:36.022]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.022]                         envir = ns)
[09:31:36.022]                       envir <- sys.frame(frame)
[09:31:36.022]                       master <- NULL
[09:31:36.022]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.022]                         !identical(envir, emptyenv())) {
[09:31:36.022]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.022]                           inherits = FALSE)) {
[09:31:36.022]                           master <- get("master", mode = "list", 
[09:31:36.022]                             envir = envir, inherits = FALSE)
[09:31:36.022]                           if (inherits(master, c("SOCKnode", 
[09:31:36.022]                             "SOCK0node"))) {
[09:31:36.022]                             sendCondition <<- function(cond) {
[09:31:36.022]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.022]                                 success = TRUE)
[09:31:36.022]                               parallel_sendData(master, data)
[09:31:36.022]                             }
[09:31:36.022]                             return(sendCondition)
[09:31:36.022]                           }
[09:31:36.022]                         }
[09:31:36.022]                         frame <- frame + 1L
[09:31:36.022]                         envir <- sys.frame(frame)
[09:31:36.022]                       }
[09:31:36.022]                     }
[09:31:36.022]                     sendCondition <<- function(cond) NULL
[09:31:36.022]                   }
[09:31:36.022]                 })
[09:31:36.022]                 withCallingHandlers({
[09:31:36.022]                   value(a) + 1
[09:31:36.022]                 }, immediateCondition = function(cond) {
[09:31:36.022]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.022]                   sendCondition(cond)
[09:31:36.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.022]                   {
[09:31:36.022]                     inherits <- base::inherits
[09:31:36.022]                     invokeRestart <- base::invokeRestart
[09:31:36.022]                     is.null <- base::is.null
[09:31:36.022]                     muffled <- FALSE
[09:31:36.022]                     if (inherits(cond, "message")) {
[09:31:36.022]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.022]                       if (muffled) 
[09:31:36.022]                         invokeRestart("muffleMessage")
[09:31:36.022]                     }
[09:31:36.022]                     else if (inherits(cond, "warning")) {
[09:31:36.022]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.022]                       if (muffled) 
[09:31:36.022]                         invokeRestart("muffleWarning")
[09:31:36.022]                     }
[09:31:36.022]                     else if (inherits(cond, "condition")) {
[09:31:36.022]                       if (!is.null(pattern)) {
[09:31:36.022]                         computeRestarts <- base::computeRestarts
[09:31:36.022]                         grepl <- base::grepl
[09:31:36.022]                         restarts <- computeRestarts(cond)
[09:31:36.022]                         for (restart in restarts) {
[09:31:36.022]                           name <- restart$name
[09:31:36.022]                           if (is.null(name)) 
[09:31:36.022]                             next
[09:31:36.022]                           if (!grepl(pattern, name)) 
[09:31:36.022]                             next
[09:31:36.022]                           invokeRestart(restart)
[09:31:36.022]                           muffled <- TRUE
[09:31:36.022]                           break
[09:31:36.022]                         }
[09:31:36.022]                       }
[09:31:36.022]                     }
[09:31:36.022]                     invisible(muffled)
[09:31:36.022]                   }
[09:31:36.022]                   muffleCondition(cond)
[09:31:36.022]                 })
[09:31:36.022]             }))
[09:31:36.022]             future::FutureResult(value = ...future.value$value, 
[09:31:36.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.022]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.022]                     ...future.globalenv.names))
[09:31:36.022]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.022]         }, condition = base::local({
[09:31:36.022]             c <- base::c
[09:31:36.022]             inherits <- base::inherits
[09:31:36.022]             invokeRestart <- base::invokeRestart
[09:31:36.022]             length <- base::length
[09:31:36.022]             list <- base::list
[09:31:36.022]             seq.int <- base::seq.int
[09:31:36.022]             signalCondition <- base::signalCondition
[09:31:36.022]             sys.calls <- base::sys.calls
[09:31:36.022]             `[[` <- base::`[[`
[09:31:36.022]             `+` <- base::`+`
[09:31:36.022]             `<<-` <- base::`<<-`
[09:31:36.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.022]                   3L)]
[09:31:36.022]             }
[09:31:36.022]             function(cond) {
[09:31:36.022]                 is_error <- inherits(cond, "error")
[09:31:36.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.022]                   NULL)
[09:31:36.022]                 if (is_error) {
[09:31:36.022]                   sessionInformation <- function() {
[09:31:36.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.022]                       search = base::search(), system = base::Sys.info())
[09:31:36.022]                   }
[09:31:36.022]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.022]                     cond$call), session = sessionInformation(), 
[09:31:36.022]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.022]                   signalCondition(cond)
[09:31:36.022]                 }
[09:31:36.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.022]                 "immediateCondition"))) {
[09:31:36.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.022]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.022]                   if (TRUE && !signal) {
[09:31:36.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.022]                     {
[09:31:36.022]                       inherits <- base::inherits
[09:31:36.022]                       invokeRestart <- base::invokeRestart
[09:31:36.022]                       is.null <- base::is.null
[09:31:36.022]                       muffled <- FALSE
[09:31:36.022]                       if (inherits(cond, "message")) {
[09:31:36.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.022]                         if (muffled) 
[09:31:36.022]                           invokeRestart("muffleMessage")
[09:31:36.022]                       }
[09:31:36.022]                       else if (inherits(cond, "warning")) {
[09:31:36.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.022]                         if (muffled) 
[09:31:36.022]                           invokeRestart("muffleWarning")
[09:31:36.022]                       }
[09:31:36.022]                       else if (inherits(cond, "condition")) {
[09:31:36.022]                         if (!is.null(pattern)) {
[09:31:36.022]                           computeRestarts <- base::computeRestarts
[09:31:36.022]                           grepl <- base::grepl
[09:31:36.022]                           restarts <- computeRestarts(cond)
[09:31:36.022]                           for (restart in restarts) {
[09:31:36.022]                             name <- restart$name
[09:31:36.022]                             if (is.null(name)) 
[09:31:36.022]                               next
[09:31:36.022]                             if (!grepl(pattern, name)) 
[09:31:36.022]                               next
[09:31:36.022]                             invokeRestart(restart)
[09:31:36.022]                             muffled <- TRUE
[09:31:36.022]                             break
[09:31:36.022]                           }
[09:31:36.022]                         }
[09:31:36.022]                       }
[09:31:36.022]                       invisible(muffled)
[09:31:36.022]                     }
[09:31:36.022]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.022]                   }
[09:31:36.022]                 }
[09:31:36.022]                 else {
[09:31:36.022]                   if (TRUE) {
[09:31:36.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.022]                     {
[09:31:36.022]                       inherits <- base::inherits
[09:31:36.022]                       invokeRestart <- base::invokeRestart
[09:31:36.022]                       is.null <- base::is.null
[09:31:36.022]                       muffled <- FALSE
[09:31:36.022]                       if (inherits(cond, "message")) {
[09:31:36.022]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.022]                         if (muffled) 
[09:31:36.022]                           invokeRestart("muffleMessage")
[09:31:36.022]                       }
[09:31:36.022]                       else if (inherits(cond, "warning")) {
[09:31:36.022]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.022]                         if (muffled) 
[09:31:36.022]                           invokeRestart("muffleWarning")
[09:31:36.022]                       }
[09:31:36.022]                       else if (inherits(cond, "condition")) {
[09:31:36.022]                         if (!is.null(pattern)) {
[09:31:36.022]                           computeRestarts <- base::computeRestarts
[09:31:36.022]                           grepl <- base::grepl
[09:31:36.022]                           restarts <- computeRestarts(cond)
[09:31:36.022]                           for (restart in restarts) {
[09:31:36.022]                             name <- restart$name
[09:31:36.022]                             if (is.null(name)) 
[09:31:36.022]                               next
[09:31:36.022]                             if (!grepl(pattern, name)) 
[09:31:36.022]                               next
[09:31:36.022]                             invokeRestart(restart)
[09:31:36.022]                             muffled <- TRUE
[09:31:36.022]                             break
[09:31:36.022]                           }
[09:31:36.022]                         }
[09:31:36.022]                       }
[09:31:36.022]                       invisible(muffled)
[09:31:36.022]                     }
[09:31:36.022]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.022]                   }
[09:31:36.022]                 }
[09:31:36.022]             }
[09:31:36.022]         }))
[09:31:36.022]     }, error = function(ex) {
[09:31:36.022]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.022]                 ...future.rng), started = ...future.startTime, 
[09:31:36.022]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.022]             version = "1.8"), class = "FutureResult")
[09:31:36.022]     }, finally = {
[09:31:36.022]         if (!identical(...future.workdir, getwd())) 
[09:31:36.022]             setwd(...future.workdir)
[09:31:36.022]         {
[09:31:36.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.022]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.022]             }
[09:31:36.022]             base::options(...future.oldOptions)
[09:31:36.022]             if (.Platform$OS.type == "windows") {
[09:31:36.022]                 old_names <- names(...future.oldEnvVars)
[09:31:36.022]                 envs <- base::Sys.getenv()
[09:31:36.022]                 names <- names(envs)
[09:31:36.022]                 common <- intersect(names, old_names)
[09:31:36.022]                 added <- setdiff(names, old_names)
[09:31:36.022]                 removed <- setdiff(old_names, names)
[09:31:36.022]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.022]                   envs[common]]
[09:31:36.022]                 NAMES <- toupper(changed)
[09:31:36.022]                 args <- list()
[09:31:36.022]                 for (kk in seq_along(NAMES)) {
[09:31:36.022]                   name <- changed[[kk]]
[09:31:36.022]                   NAME <- NAMES[[kk]]
[09:31:36.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.022]                     next
[09:31:36.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.022]                 }
[09:31:36.022]                 NAMES <- toupper(added)
[09:31:36.022]                 for (kk in seq_along(NAMES)) {
[09:31:36.022]                   name <- added[[kk]]
[09:31:36.022]                   NAME <- NAMES[[kk]]
[09:31:36.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.022]                     next
[09:31:36.022]                   args[[name]] <- ""
[09:31:36.022]                 }
[09:31:36.022]                 NAMES <- toupper(removed)
[09:31:36.022]                 for (kk in seq_along(NAMES)) {
[09:31:36.022]                   name <- removed[[kk]]
[09:31:36.022]                   NAME <- NAMES[[kk]]
[09:31:36.022]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.022]                     next
[09:31:36.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.022]                 }
[09:31:36.022]                 if (length(args) > 0) 
[09:31:36.022]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.022]             }
[09:31:36.022]             else {
[09:31:36.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.022]             }
[09:31:36.022]             {
[09:31:36.022]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.022]                   0L) {
[09:31:36.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.022]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.022]                   base::options(opts)
[09:31:36.022]                 }
[09:31:36.022]                 {
[09:31:36.022]                   {
[09:31:36.022]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.022]                     NULL
[09:31:36.022]                   }
[09:31:36.022]                   options(future.plan = NULL)
[09:31:36.022]                   if (is.na(NA_character_)) 
[09:31:36.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.022]                     .init = FALSE)
[09:31:36.022]                 }
[09:31:36.022]             }
[09:31:36.022]         }
[09:31:36.022]     })
[09:31:36.022]     if (TRUE) {
[09:31:36.022]         base::sink(type = "output", split = FALSE)
[09:31:36.022]         if (TRUE) {
[09:31:36.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.022]         }
[09:31:36.022]         else {
[09:31:36.022]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.022]         }
[09:31:36.022]         base::close(...future.stdout)
[09:31:36.022]         ...future.stdout <- NULL
[09:31:36.022]     }
[09:31:36.022]     ...future.result$conditions <- ...future.conditions
[09:31:36.022]     ...future.result$finished <- base::Sys.time()
[09:31:36.022]     ...future.result
[09:31:36.022] }
[09:31:36.025] Exporting 1 global objects (10.29 KiB) to cluster node #2 ...
[09:31:36.026] Exporting ‘a’ (10.29 KiB) to cluster node #2 ...
[09:31:36.076] Exporting ‘a’ (10.29 KiB) to cluster node #2 ... DONE
[09:31:36.076] Exporting 1 global objects (10.29 KiB) to cluster node #2 ... DONE
[09:31:36.077] MultisessionFuture started
[09:31:36.077] - Launch lazy future ... done
[09:31:36.077] run() for ‘MultisessionFuture’ ... done
[09:31:36.077] result() for ClusterFuture ...
[09:31:36.077] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.077] - Validating connection of MultisessionFuture
[09:31:36.122] - received message: FutureResult
[09:31:36.122] - Received FutureResult
[09:31:36.122] - Erased future from FutureRegistry
[09:31:36.122] result() for ClusterFuture ...
[09:31:36.122] - result already collected: FutureResult
[09:31:36.122] result() for ClusterFuture ... done
[09:31:36.122] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.122] result() for ClusterFuture ... done
[09:31:36.123] result() for ClusterFuture ...
[09:31:36.123] - result already collected: FutureResult
[09:31:36.123] result() for ClusterFuture ... done
value(b) = 2
[09:31:36.123] result() for ClusterFuture ...
[09:31:36.123] - result already collected: FutureResult
[09:31:36.123] result() for ClusterFuture ... done
[09:31:36.123] result() for ClusterFuture ...
[09:31:36.123] - result already collected: FutureResult
[09:31:36.123] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.124] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.124] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:36.124] 
[09:31:36.124] Searching for globals ... DONE
[09:31:36.125] - globals: [0] <none>
[09:31:36.125] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.125] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.125] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:36.126] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:36.126] Searching for globals ... DONE
[09:31:36.126] Resolving globals: TRUE
[09:31:36.126] Resolving any globals that are futures ...
[09:31:36.126] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:36.126] Resolving any globals that are futures ... DONE
[09:31:36.127] Resolving futures part of globals (recursively) ...
[09:31:36.127] resolve() on list ...
[09:31:36.127]  recursive: 99
[09:31:36.127]  length: 1
[09:31:36.127]  elements: ‘a’
[09:31:36.127] run() for ‘Future’ ...
[09:31:36.127] - state: ‘created’
[09:31:36.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.141]   - Field: ‘node’
[09:31:36.142]   - Field: ‘label’
[09:31:36.142]   - Field: ‘local’
[09:31:36.142]   - Field: ‘owner’
[09:31:36.142]   - Field: ‘envir’
[09:31:36.142]   - Field: ‘workers’
[09:31:36.142]   - Field: ‘packages’
[09:31:36.142]   - Field: ‘gc’
[09:31:36.142]   - Field: ‘conditions’
[09:31:36.142]   - Field: ‘persistent’
[09:31:36.142]   - Field: ‘expr’
[09:31:36.142]   - Field: ‘uuid’
[09:31:36.143]   - Field: ‘seed’
[09:31:36.143]   - Field: ‘version’
[09:31:36.143]   - Field: ‘result’
[09:31:36.143]   - Field: ‘asynchronous’
[09:31:36.143]   - Field: ‘calls’
[09:31:36.143]   - Field: ‘globals’
[09:31:36.143]   - Field: ‘stdout’
[09:31:36.143]   - Field: ‘earlySignal’
[09:31:36.143]   - Field: ‘lazy’
[09:31:36.143]   - Field: ‘state’
[09:31:36.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.144] - Launch lazy future ...
[09:31:36.144] Packages needed by the future expression (n = 0): <none>
[09:31:36.144] Packages needed by future strategies (n = 0): <none>
[09:31:36.144] {
[09:31:36.144]     {
[09:31:36.144]         {
[09:31:36.144]             ...future.startTime <- base::Sys.time()
[09:31:36.144]             {
[09:31:36.144]                 {
[09:31:36.144]                   {
[09:31:36.144]                     {
[09:31:36.144]                       base::local({
[09:31:36.144]                         has_future <- base::requireNamespace("future", 
[09:31:36.144]                           quietly = TRUE)
[09:31:36.144]                         if (has_future) {
[09:31:36.144]                           ns <- base::getNamespace("future")
[09:31:36.144]                           version <- ns[[".package"]][["version"]]
[09:31:36.144]                           if (is.null(version)) 
[09:31:36.144]                             version <- utils::packageVersion("future")
[09:31:36.144]                         }
[09:31:36.144]                         else {
[09:31:36.144]                           version <- NULL
[09:31:36.144]                         }
[09:31:36.144]                         if (!has_future || version < "1.8.0") {
[09:31:36.144]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.144]                             "", base::R.version$version.string), 
[09:31:36.144]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.144]                               "release", "version")], collapse = " "), 
[09:31:36.144]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.144]                             info)
[09:31:36.144]                           info <- base::paste(info, collapse = "; ")
[09:31:36.144]                           if (!has_future) {
[09:31:36.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.144]                               info)
[09:31:36.144]                           }
[09:31:36.144]                           else {
[09:31:36.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.144]                               info, version)
[09:31:36.144]                           }
[09:31:36.144]                           base::stop(msg)
[09:31:36.144]                         }
[09:31:36.144]                       })
[09:31:36.144]                     }
[09:31:36.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.144]                     base::options(mc.cores = 1L)
[09:31:36.144]                   }
[09:31:36.144]                   ...future.strategy.old <- future::plan("list")
[09:31:36.144]                   options(future.plan = NULL)
[09:31:36.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.144]                 }
[09:31:36.144]                 ...future.workdir <- getwd()
[09:31:36.144]             }
[09:31:36.144]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.144]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.144]         }
[09:31:36.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.144]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.144]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.144]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.144]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.144]             base::names(...future.oldOptions))
[09:31:36.144]     }
[09:31:36.144]     if (FALSE) {
[09:31:36.144]     }
[09:31:36.144]     else {
[09:31:36.144]         if (TRUE) {
[09:31:36.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.144]                 open = "w")
[09:31:36.144]         }
[09:31:36.144]         else {
[09:31:36.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.144]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.144]         }
[09:31:36.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.144]             base::sink(type = "output", split = FALSE)
[09:31:36.144]             base::close(...future.stdout)
[09:31:36.144]         }, add = TRUE)
[09:31:36.144]     }
[09:31:36.144]     ...future.frame <- base::sys.nframe()
[09:31:36.144]     ...future.conditions <- base::list()
[09:31:36.144]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.144]     if (FALSE) {
[09:31:36.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.144]     }
[09:31:36.144]     ...future.result <- base::tryCatch({
[09:31:36.144]         base::withCallingHandlers({
[09:31:36.144]             ...future.value <- base::withVisible(base::local({
[09:31:36.144]                 ...future.makeSendCondition <- base::local({
[09:31:36.144]                   sendCondition <- NULL
[09:31:36.144]                   function(frame = 1L) {
[09:31:36.144]                     if (is.function(sendCondition)) 
[09:31:36.144]                       return(sendCondition)
[09:31:36.144]                     ns <- getNamespace("parallel")
[09:31:36.144]                     if (exists("sendData", mode = "function", 
[09:31:36.144]                       envir = ns)) {
[09:31:36.144]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.144]                         envir = ns)
[09:31:36.144]                       envir <- sys.frame(frame)
[09:31:36.144]                       master <- NULL
[09:31:36.144]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.144]                         !identical(envir, emptyenv())) {
[09:31:36.144]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.144]                           inherits = FALSE)) {
[09:31:36.144]                           master <- get("master", mode = "list", 
[09:31:36.144]                             envir = envir, inherits = FALSE)
[09:31:36.144]                           if (inherits(master, c("SOCKnode", 
[09:31:36.144]                             "SOCK0node"))) {
[09:31:36.144]                             sendCondition <<- function(cond) {
[09:31:36.144]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.144]                                 success = TRUE)
[09:31:36.144]                               parallel_sendData(master, data)
[09:31:36.144]                             }
[09:31:36.144]                             return(sendCondition)
[09:31:36.144]                           }
[09:31:36.144]                         }
[09:31:36.144]                         frame <- frame + 1L
[09:31:36.144]                         envir <- sys.frame(frame)
[09:31:36.144]                       }
[09:31:36.144]                     }
[09:31:36.144]                     sendCondition <<- function(cond) NULL
[09:31:36.144]                   }
[09:31:36.144]                 })
[09:31:36.144]                 withCallingHandlers({
[09:31:36.144]                   1
[09:31:36.144]                 }, immediateCondition = function(cond) {
[09:31:36.144]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.144]                   sendCondition(cond)
[09:31:36.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.144]                   {
[09:31:36.144]                     inherits <- base::inherits
[09:31:36.144]                     invokeRestart <- base::invokeRestart
[09:31:36.144]                     is.null <- base::is.null
[09:31:36.144]                     muffled <- FALSE
[09:31:36.144]                     if (inherits(cond, "message")) {
[09:31:36.144]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.144]                       if (muffled) 
[09:31:36.144]                         invokeRestart("muffleMessage")
[09:31:36.144]                     }
[09:31:36.144]                     else if (inherits(cond, "warning")) {
[09:31:36.144]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.144]                       if (muffled) 
[09:31:36.144]                         invokeRestart("muffleWarning")
[09:31:36.144]                     }
[09:31:36.144]                     else if (inherits(cond, "condition")) {
[09:31:36.144]                       if (!is.null(pattern)) {
[09:31:36.144]                         computeRestarts <- base::computeRestarts
[09:31:36.144]                         grepl <- base::grepl
[09:31:36.144]                         restarts <- computeRestarts(cond)
[09:31:36.144]                         for (restart in restarts) {
[09:31:36.144]                           name <- restart$name
[09:31:36.144]                           if (is.null(name)) 
[09:31:36.144]                             next
[09:31:36.144]                           if (!grepl(pattern, name)) 
[09:31:36.144]                             next
[09:31:36.144]                           invokeRestart(restart)
[09:31:36.144]                           muffled <- TRUE
[09:31:36.144]                           break
[09:31:36.144]                         }
[09:31:36.144]                       }
[09:31:36.144]                     }
[09:31:36.144]                     invisible(muffled)
[09:31:36.144]                   }
[09:31:36.144]                   muffleCondition(cond)
[09:31:36.144]                 })
[09:31:36.144]             }))
[09:31:36.144]             future::FutureResult(value = ...future.value$value, 
[09:31:36.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.144]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.144]                     ...future.globalenv.names))
[09:31:36.144]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.144]         }, condition = base::local({
[09:31:36.144]             c <- base::c
[09:31:36.144]             inherits <- base::inherits
[09:31:36.144]             invokeRestart <- base::invokeRestart
[09:31:36.144]             length <- base::length
[09:31:36.144]             list <- base::list
[09:31:36.144]             seq.int <- base::seq.int
[09:31:36.144]             signalCondition <- base::signalCondition
[09:31:36.144]             sys.calls <- base::sys.calls
[09:31:36.144]             `[[` <- base::`[[`
[09:31:36.144]             `+` <- base::`+`
[09:31:36.144]             `<<-` <- base::`<<-`
[09:31:36.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.144]                   3L)]
[09:31:36.144]             }
[09:31:36.144]             function(cond) {
[09:31:36.144]                 is_error <- inherits(cond, "error")
[09:31:36.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.144]                   NULL)
[09:31:36.144]                 if (is_error) {
[09:31:36.144]                   sessionInformation <- function() {
[09:31:36.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.144]                       search = base::search(), system = base::Sys.info())
[09:31:36.144]                   }
[09:31:36.144]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.144]                     cond$call), session = sessionInformation(), 
[09:31:36.144]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.144]                   signalCondition(cond)
[09:31:36.144]                 }
[09:31:36.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.144]                 "immediateCondition"))) {
[09:31:36.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.144]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.144]                   if (TRUE && !signal) {
[09:31:36.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.144]                     {
[09:31:36.144]                       inherits <- base::inherits
[09:31:36.144]                       invokeRestart <- base::invokeRestart
[09:31:36.144]                       is.null <- base::is.null
[09:31:36.144]                       muffled <- FALSE
[09:31:36.144]                       if (inherits(cond, "message")) {
[09:31:36.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.144]                         if (muffled) 
[09:31:36.144]                           invokeRestart("muffleMessage")
[09:31:36.144]                       }
[09:31:36.144]                       else if (inherits(cond, "warning")) {
[09:31:36.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.144]                         if (muffled) 
[09:31:36.144]                           invokeRestart("muffleWarning")
[09:31:36.144]                       }
[09:31:36.144]                       else if (inherits(cond, "condition")) {
[09:31:36.144]                         if (!is.null(pattern)) {
[09:31:36.144]                           computeRestarts <- base::computeRestarts
[09:31:36.144]                           grepl <- base::grepl
[09:31:36.144]                           restarts <- computeRestarts(cond)
[09:31:36.144]                           for (restart in restarts) {
[09:31:36.144]                             name <- restart$name
[09:31:36.144]                             if (is.null(name)) 
[09:31:36.144]                               next
[09:31:36.144]                             if (!grepl(pattern, name)) 
[09:31:36.144]                               next
[09:31:36.144]                             invokeRestart(restart)
[09:31:36.144]                             muffled <- TRUE
[09:31:36.144]                             break
[09:31:36.144]                           }
[09:31:36.144]                         }
[09:31:36.144]                       }
[09:31:36.144]                       invisible(muffled)
[09:31:36.144]                     }
[09:31:36.144]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.144]                   }
[09:31:36.144]                 }
[09:31:36.144]                 else {
[09:31:36.144]                   if (TRUE) {
[09:31:36.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.144]                     {
[09:31:36.144]                       inherits <- base::inherits
[09:31:36.144]                       invokeRestart <- base::invokeRestart
[09:31:36.144]                       is.null <- base::is.null
[09:31:36.144]                       muffled <- FALSE
[09:31:36.144]                       if (inherits(cond, "message")) {
[09:31:36.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.144]                         if (muffled) 
[09:31:36.144]                           invokeRestart("muffleMessage")
[09:31:36.144]                       }
[09:31:36.144]                       else if (inherits(cond, "warning")) {
[09:31:36.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.144]                         if (muffled) 
[09:31:36.144]                           invokeRestart("muffleWarning")
[09:31:36.144]                       }
[09:31:36.144]                       else if (inherits(cond, "condition")) {
[09:31:36.144]                         if (!is.null(pattern)) {
[09:31:36.144]                           computeRestarts <- base::computeRestarts
[09:31:36.144]                           grepl <- base::grepl
[09:31:36.144]                           restarts <- computeRestarts(cond)
[09:31:36.144]                           for (restart in restarts) {
[09:31:36.144]                             name <- restart$name
[09:31:36.144]                             if (is.null(name)) 
[09:31:36.144]                               next
[09:31:36.144]                             if (!grepl(pattern, name)) 
[09:31:36.144]                               next
[09:31:36.144]                             invokeRestart(restart)
[09:31:36.144]                             muffled <- TRUE
[09:31:36.144]                             break
[09:31:36.144]                           }
[09:31:36.144]                         }
[09:31:36.144]                       }
[09:31:36.144]                       invisible(muffled)
[09:31:36.144]                     }
[09:31:36.144]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.144]                   }
[09:31:36.144]                 }
[09:31:36.144]             }
[09:31:36.144]         }))
[09:31:36.144]     }, error = function(ex) {
[09:31:36.144]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.144]                 ...future.rng), started = ...future.startTime, 
[09:31:36.144]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.144]             version = "1.8"), class = "FutureResult")
[09:31:36.144]     }, finally = {
[09:31:36.144]         if (!identical(...future.workdir, getwd())) 
[09:31:36.144]             setwd(...future.workdir)
[09:31:36.144]         {
[09:31:36.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.144]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.144]             }
[09:31:36.144]             base::options(...future.oldOptions)
[09:31:36.144]             if (.Platform$OS.type == "windows") {
[09:31:36.144]                 old_names <- names(...future.oldEnvVars)
[09:31:36.144]                 envs <- base::Sys.getenv()
[09:31:36.144]                 names <- names(envs)
[09:31:36.144]                 common <- intersect(names, old_names)
[09:31:36.144]                 added <- setdiff(names, old_names)
[09:31:36.144]                 removed <- setdiff(old_names, names)
[09:31:36.144]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.144]                   envs[common]]
[09:31:36.144]                 NAMES <- toupper(changed)
[09:31:36.144]                 args <- list()
[09:31:36.144]                 for (kk in seq_along(NAMES)) {
[09:31:36.144]                   name <- changed[[kk]]
[09:31:36.144]                   NAME <- NAMES[[kk]]
[09:31:36.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.144]                     next
[09:31:36.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.144]                 }
[09:31:36.144]                 NAMES <- toupper(added)
[09:31:36.144]                 for (kk in seq_along(NAMES)) {
[09:31:36.144]                   name <- added[[kk]]
[09:31:36.144]                   NAME <- NAMES[[kk]]
[09:31:36.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.144]                     next
[09:31:36.144]                   args[[name]] <- ""
[09:31:36.144]                 }
[09:31:36.144]                 NAMES <- toupper(removed)
[09:31:36.144]                 for (kk in seq_along(NAMES)) {
[09:31:36.144]                   name <- removed[[kk]]
[09:31:36.144]                   NAME <- NAMES[[kk]]
[09:31:36.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.144]                     next
[09:31:36.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.144]                 }
[09:31:36.144]                 if (length(args) > 0) 
[09:31:36.144]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.144]             }
[09:31:36.144]             else {
[09:31:36.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.144]             }
[09:31:36.144]             {
[09:31:36.144]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.144]                   0L) {
[09:31:36.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.144]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.144]                   base::options(opts)
[09:31:36.144]                 }
[09:31:36.144]                 {
[09:31:36.144]                   {
[09:31:36.144]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.144]                     NULL
[09:31:36.144]                   }
[09:31:36.144]                   options(future.plan = NULL)
[09:31:36.144]                   if (is.na(NA_character_)) 
[09:31:36.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.144]                     .init = FALSE)
[09:31:36.144]                 }
[09:31:36.144]             }
[09:31:36.144]         }
[09:31:36.144]     })
[09:31:36.144]     if (TRUE) {
[09:31:36.144]         base::sink(type = "output", split = FALSE)
[09:31:36.144]         if (TRUE) {
[09:31:36.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.144]         }
[09:31:36.144]         else {
[09:31:36.144]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.144]         }
[09:31:36.144]         base::close(...future.stdout)
[09:31:36.144]         ...future.stdout <- NULL
[09:31:36.144]     }
[09:31:36.144]     ...future.result$conditions <- ...future.conditions
[09:31:36.144]     ...future.result$finished <- base::Sys.time()
[09:31:36.144]     ...future.result
[09:31:36.144] }
[09:31:36.147] MultisessionFuture started
[09:31:36.147] - Launch lazy future ... done
[09:31:36.147] run() for ‘MultisessionFuture’ ... done
[09:31:36.190] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.190] - Validating connection of MultisessionFuture
[09:31:36.190] - received message: FutureResult
[09:31:36.190] - Received FutureResult
[09:31:36.190] - Erased future from FutureRegistry
[09:31:36.190] result() for ClusterFuture ...
[09:31:36.190] - result already collected: FutureResult
[09:31:36.190] result() for ClusterFuture ... done
[09:31:36.190] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.191] Future #1
[09:31:36.191] result() for ClusterFuture ...
[09:31:36.191] - result already collected: FutureResult
[09:31:36.191] result() for ClusterFuture ... done
[09:31:36.191] result() for ClusterFuture ...
[09:31:36.191] - result already collected: FutureResult
[09:31:36.191] result() for ClusterFuture ... done
[09:31:36.191] A MultisessionFuture was resolved
[09:31:36.191]  length: 0 (resolved future 1)
[09:31:36.191] resolve() on list ... DONE
[09:31:36.191] - globals: [1] ‘a’
[09:31:36.192] Resolving futures part of globals (recursively) ... DONE
[09:31:36.192] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[09:31:36.193] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[09:31:36.193] - globals: [1] ‘a’
[09:31:36.193] - packages: [1] ‘future’
[09:31:36.193] getGlobalsAndPackages() ... DONE
[09:31:36.193] run() for ‘Future’ ...
[09:31:36.194] - state: ‘created’
[09:31:36.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.207] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.208]   - Field: ‘node’
[09:31:36.208]   - Field: ‘label’
[09:31:36.208]   - Field: ‘local’
[09:31:36.208]   - Field: ‘owner’
[09:31:36.208]   - Field: ‘envir’
[09:31:36.208]   - Field: ‘workers’
[09:31:36.208]   - Field: ‘packages’
[09:31:36.208]   - Field: ‘gc’
[09:31:36.208]   - Field: ‘conditions’
[09:31:36.208]   - Field: ‘persistent’
[09:31:36.209]   - Field: ‘expr’
[09:31:36.209]   - Field: ‘uuid’
[09:31:36.209]   - Field: ‘seed’
[09:31:36.209]   - Field: ‘version’
[09:31:36.209]   - Field: ‘result’
[09:31:36.209]   - Field: ‘asynchronous’
[09:31:36.209]   - Field: ‘calls’
[09:31:36.209]   - Field: ‘globals’
[09:31:36.209]   - Field: ‘stdout’
[09:31:36.209]   - Field: ‘earlySignal’
[09:31:36.209]   - Field: ‘lazy’
[09:31:36.210]   - Field: ‘state’
[09:31:36.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.210] - Launch lazy future ...
[09:31:36.210] Packages needed by the future expression (n = 1): ‘future’
[09:31:36.210] Packages needed by future strategies (n = 0): <none>
[09:31:36.211] {
[09:31:36.211]     {
[09:31:36.211]         {
[09:31:36.211]             ...future.startTime <- base::Sys.time()
[09:31:36.211]             {
[09:31:36.211]                 {
[09:31:36.211]                   {
[09:31:36.211]                     {
[09:31:36.211]                       {
[09:31:36.211]                         base::local({
[09:31:36.211]                           has_future <- base::requireNamespace("future", 
[09:31:36.211]                             quietly = TRUE)
[09:31:36.211]                           if (has_future) {
[09:31:36.211]                             ns <- base::getNamespace("future")
[09:31:36.211]                             version <- ns[[".package"]][["version"]]
[09:31:36.211]                             if (is.null(version)) 
[09:31:36.211]                               version <- utils::packageVersion("future")
[09:31:36.211]                           }
[09:31:36.211]                           else {
[09:31:36.211]                             version <- NULL
[09:31:36.211]                           }
[09:31:36.211]                           if (!has_future || version < "1.8.0") {
[09:31:36.211]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.211]                               "", base::R.version$version.string), 
[09:31:36.211]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:36.211]                                 base::R.version$platform, 8 * 
[09:31:36.211]                                   base::.Machine$sizeof.pointer), 
[09:31:36.211]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.211]                                 "release", "version")], collapse = " "), 
[09:31:36.211]                               hostname = base::Sys.info()[["nodename"]])
[09:31:36.211]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.211]                               info)
[09:31:36.211]                             info <- base::paste(info, collapse = "; ")
[09:31:36.211]                             if (!has_future) {
[09:31:36.211]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.211]                                 info)
[09:31:36.211]                             }
[09:31:36.211]                             else {
[09:31:36.211]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.211]                                 info, version)
[09:31:36.211]                             }
[09:31:36.211]                             base::stop(msg)
[09:31:36.211]                           }
[09:31:36.211]                         })
[09:31:36.211]                       }
[09:31:36.211]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.211]                       base::options(mc.cores = 1L)
[09:31:36.211]                     }
[09:31:36.211]                     base::local({
[09:31:36.211]                       for (pkg in "future") {
[09:31:36.211]                         base::loadNamespace(pkg)
[09:31:36.211]                         base::library(pkg, character.only = TRUE)
[09:31:36.211]                       }
[09:31:36.211]                     })
[09:31:36.211]                   }
[09:31:36.211]                   ...future.strategy.old <- future::plan("list")
[09:31:36.211]                   options(future.plan = NULL)
[09:31:36.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.211]                 }
[09:31:36.211]                 ...future.workdir <- getwd()
[09:31:36.211]             }
[09:31:36.211]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.211]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.211]         }
[09:31:36.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.211]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.211]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.211]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.211]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.211]             base::names(...future.oldOptions))
[09:31:36.211]     }
[09:31:36.211]     if (FALSE) {
[09:31:36.211]     }
[09:31:36.211]     else {
[09:31:36.211]         if (TRUE) {
[09:31:36.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.211]                 open = "w")
[09:31:36.211]         }
[09:31:36.211]         else {
[09:31:36.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.211]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.211]         }
[09:31:36.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.211]             base::sink(type = "output", split = FALSE)
[09:31:36.211]             base::close(...future.stdout)
[09:31:36.211]         }, add = TRUE)
[09:31:36.211]     }
[09:31:36.211]     ...future.frame <- base::sys.nframe()
[09:31:36.211]     ...future.conditions <- base::list()
[09:31:36.211]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.211]     if (FALSE) {
[09:31:36.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.211]     }
[09:31:36.211]     ...future.result <- base::tryCatch({
[09:31:36.211]         base::withCallingHandlers({
[09:31:36.211]             ...future.value <- base::withVisible(base::local({
[09:31:36.211]                 ...future.makeSendCondition <- base::local({
[09:31:36.211]                   sendCondition <- NULL
[09:31:36.211]                   function(frame = 1L) {
[09:31:36.211]                     if (is.function(sendCondition)) 
[09:31:36.211]                       return(sendCondition)
[09:31:36.211]                     ns <- getNamespace("parallel")
[09:31:36.211]                     if (exists("sendData", mode = "function", 
[09:31:36.211]                       envir = ns)) {
[09:31:36.211]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.211]                         envir = ns)
[09:31:36.211]                       envir <- sys.frame(frame)
[09:31:36.211]                       master <- NULL
[09:31:36.211]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.211]                         !identical(envir, emptyenv())) {
[09:31:36.211]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.211]                           inherits = FALSE)) {
[09:31:36.211]                           master <- get("master", mode = "list", 
[09:31:36.211]                             envir = envir, inherits = FALSE)
[09:31:36.211]                           if (inherits(master, c("SOCKnode", 
[09:31:36.211]                             "SOCK0node"))) {
[09:31:36.211]                             sendCondition <<- function(cond) {
[09:31:36.211]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.211]                                 success = TRUE)
[09:31:36.211]                               parallel_sendData(master, data)
[09:31:36.211]                             }
[09:31:36.211]                             return(sendCondition)
[09:31:36.211]                           }
[09:31:36.211]                         }
[09:31:36.211]                         frame <- frame + 1L
[09:31:36.211]                         envir <- sys.frame(frame)
[09:31:36.211]                       }
[09:31:36.211]                     }
[09:31:36.211]                     sendCondition <<- function(cond) NULL
[09:31:36.211]                   }
[09:31:36.211]                 })
[09:31:36.211]                 withCallingHandlers({
[09:31:36.211]                   value(a) + 1
[09:31:36.211]                 }, immediateCondition = function(cond) {
[09:31:36.211]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.211]                   sendCondition(cond)
[09:31:36.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.211]                   {
[09:31:36.211]                     inherits <- base::inherits
[09:31:36.211]                     invokeRestart <- base::invokeRestart
[09:31:36.211]                     is.null <- base::is.null
[09:31:36.211]                     muffled <- FALSE
[09:31:36.211]                     if (inherits(cond, "message")) {
[09:31:36.211]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.211]                       if (muffled) 
[09:31:36.211]                         invokeRestart("muffleMessage")
[09:31:36.211]                     }
[09:31:36.211]                     else if (inherits(cond, "warning")) {
[09:31:36.211]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.211]                       if (muffled) 
[09:31:36.211]                         invokeRestart("muffleWarning")
[09:31:36.211]                     }
[09:31:36.211]                     else if (inherits(cond, "condition")) {
[09:31:36.211]                       if (!is.null(pattern)) {
[09:31:36.211]                         computeRestarts <- base::computeRestarts
[09:31:36.211]                         grepl <- base::grepl
[09:31:36.211]                         restarts <- computeRestarts(cond)
[09:31:36.211]                         for (restart in restarts) {
[09:31:36.211]                           name <- restart$name
[09:31:36.211]                           if (is.null(name)) 
[09:31:36.211]                             next
[09:31:36.211]                           if (!grepl(pattern, name)) 
[09:31:36.211]                             next
[09:31:36.211]                           invokeRestart(restart)
[09:31:36.211]                           muffled <- TRUE
[09:31:36.211]                           break
[09:31:36.211]                         }
[09:31:36.211]                       }
[09:31:36.211]                     }
[09:31:36.211]                     invisible(muffled)
[09:31:36.211]                   }
[09:31:36.211]                   muffleCondition(cond)
[09:31:36.211]                 })
[09:31:36.211]             }))
[09:31:36.211]             future::FutureResult(value = ...future.value$value, 
[09:31:36.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.211]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.211]                     ...future.globalenv.names))
[09:31:36.211]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.211]         }, condition = base::local({
[09:31:36.211]             c <- base::c
[09:31:36.211]             inherits <- base::inherits
[09:31:36.211]             invokeRestart <- base::invokeRestart
[09:31:36.211]             length <- base::length
[09:31:36.211]             list <- base::list
[09:31:36.211]             seq.int <- base::seq.int
[09:31:36.211]             signalCondition <- base::signalCondition
[09:31:36.211]             sys.calls <- base::sys.calls
[09:31:36.211]             `[[` <- base::`[[`
[09:31:36.211]             `+` <- base::`+`
[09:31:36.211]             `<<-` <- base::`<<-`
[09:31:36.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.211]                   3L)]
[09:31:36.211]             }
[09:31:36.211]             function(cond) {
[09:31:36.211]                 is_error <- inherits(cond, "error")
[09:31:36.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.211]                   NULL)
[09:31:36.211]                 if (is_error) {
[09:31:36.211]                   sessionInformation <- function() {
[09:31:36.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.211]                       search = base::search(), system = base::Sys.info())
[09:31:36.211]                   }
[09:31:36.211]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.211]                     cond$call), session = sessionInformation(), 
[09:31:36.211]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.211]                   signalCondition(cond)
[09:31:36.211]                 }
[09:31:36.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.211]                 "immediateCondition"))) {
[09:31:36.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.211]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.211]                   if (TRUE && !signal) {
[09:31:36.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.211]                     {
[09:31:36.211]                       inherits <- base::inherits
[09:31:36.211]                       invokeRestart <- base::invokeRestart
[09:31:36.211]                       is.null <- base::is.null
[09:31:36.211]                       muffled <- FALSE
[09:31:36.211]                       if (inherits(cond, "message")) {
[09:31:36.211]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.211]                         if (muffled) 
[09:31:36.211]                           invokeRestart("muffleMessage")
[09:31:36.211]                       }
[09:31:36.211]                       else if (inherits(cond, "warning")) {
[09:31:36.211]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.211]                         if (muffled) 
[09:31:36.211]                           invokeRestart("muffleWarning")
[09:31:36.211]                       }
[09:31:36.211]                       else if (inherits(cond, "condition")) {
[09:31:36.211]                         if (!is.null(pattern)) {
[09:31:36.211]                           computeRestarts <- base::computeRestarts
[09:31:36.211]                           grepl <- base::grepl
[09:31:36.211]                           restarts <- computeRestarts(cond)
[09:31:36.211]                           for (restart in restarts) {
[09:31:36.211]                             name <- restart$name
[09:31:36.211]                             if (is.null(name)) 
[09:31:36.211]                               next
[09:31:36.211]                             if (!grepl(pattern, name)) 
[09:31:36.211]                               next
[09:31:36.211]                             invokeRestart(restart)
[09:31:36.211]                             muffled <- TRUE
[09:31:36.211]                             break
[09:31:36.211]                           }
[09:31:36.211]                         }
[09:31:36.211]                       }
[09:31:36.211]                       invisible(muffled)
[09:31:36.211]                     }
[09:31:36.211]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.211]                   }
[09:31:36.211]                 }
[09:31:36.211]                 else {
[09:31:36.211]                   if (TRUE) {
[09:31:36.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.211]                     {
[09:31:36.211]                       inherits <- base::inherits
[09:31:36.211]                       invokeRestart <- base::invokeRestart
[09:31:36.211]                       is.null <- base::is.null
[09:31:36.211]                       muffled <- FALSE
[09:31:36.211]                       if (inherits(cond, "message")) {
[09:31:36.211]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.211]                         if (muffled) 
[09:31:36.211]                           invokeRestart("muffleMessage")
[09:31:36.211]                       }
[09:31:36.211]                       else if (inherits(cond, "warning")) {
[09:31:36.211]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.211]                         if (muffled) 
[09:31:36.211]                           invokeRestart("muffleWarning")
[09:31:36.211]                       }
[09:31:36.211]                       else if (inherits(cond, "condition")) {
[09:31:36.211]                         if (!is.null(pattern)) {
[09:31:36.211]                           computeRestarts <- base::computeRestarts
[09:31:36.211]                           grepl <- base::grepl
[09:31:36.211]                           restarts <- computeRestarts(cond)
[09:31:36.211]                           for (restart in restarts) {
[09:31:36.211]                             name <- restart$name
[09:31:36.211]                             if (is.null(name)) 
[09:31:36.211]                               next
[09:31:36.211]                             if (!grepl(pattern, name)) 
[09:31:36.211]                               next
[09:31:36.211]                             invokeRestart(restart)
[09:31:36.211]                             muffled <- TRUE
[09:31:36.211]                             break
[09:31:36.211]                           }
[09:31:36.211]                         }
[09:31:36.211]                       }
[09:31:36.211]                       invisible(muffled)
[09:31:36.211]                     }
[09:31:36.211]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.211]                   }
[09:31:36.211]                 }
[09:31:36.211]             }
[09:31:36.211]         }))
[09:31:36.211]     }, error = function(ex) {
[09:31:36.211]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.211]                 ...future.rng), started = ...future.startTime, 
[09:31:36.211]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.211]             version = "1.8"), class = "FutureResult")
[09:31:36.211]     }, finally = {
[09:31:36.211]         if (!identical(...future.workdir, getwd())) 
[09:31:36.211]             setwd(...future.workdir)
[09:31:36.211]         {
[09:31:36.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.211]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.211]             }
[09:31:36.211]             base::options(...future.oldOptions)
[09:31:36.211]             if (.Platform$OS.type == "windows") {
[09:31:36.211]                 old_names <- names(...future.oldEnvVars)
[09:31:36.211]                 envs <- base::Sys.getenv()
[09:31:36.211]                 names <- names(envs)
[09:31:36.211]                 common <- intersect(names, old_names)
[09:31:36.211]                 added <- setdiff(names, old_names)
[09:31:36.211]                 removed <- setdiff(old_names, names)
[09:31:36.211]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.211]                   envs[common]]
[09:31:36.211]                 NAMES <- toupper(changed)
[09:31:36.211]                 args <- list()
[09:31:36.211]                 for (kk in seq_along(NAMES)) {
[09:31:36.211]                   name <- changed[[kk]]
[09:31:36.211]                   NAME <- NAMES[[kk]]
[09:31:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.211]                     next
[09:31:36.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.211]                 }
[09:31:36.211]                 NAMES <- toupper(added)
[09:31:36.211]                 for (kk in seq_along(NAMES)) {
[09:31:36.211]                   name <- added[[kk]]
[09:31:36.211]                   NAME <- NAMES[[kk]]
[09:31:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.211]                     next
[09:31:36.211]                   args[[name]] <- ""
[09:31:36.211]                 }
[09:31:36.211]                 NAMES <- toupper(removed)
[09:31:36.211]                 for (kk in seq_along(NAMES)) {
[09:31:36.211]                   name <- removed[[kk]]
[09:31:36.211]                   NAME <- NAMES[[kk]]
[09:31:36.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.211]                     next
[09:31:36.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.211]                 }
[09:31:36.211]                 if (length(args) > 0) 
[09:31:36.211]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.211]             }
[09:31:36.211]             else {
[09:31:36.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.211]             }
[09:31:36.211]             {
[09:31:36.211]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.211]                   0L) {
[09:31:36.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.211]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.211]                   base::options(opts)
[09:31:36.211]                 }
[09:31:36.211]                 {
[09:31:36.211]                   {
[09:31:36.211]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.211]                     NULL
[09:31:36.211]                   }
[09:31:36.211]                   options(future.plan = NULL)
[09:31:36.211]                   if (is.na(NA_character_)) 
[09:31:36.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.211]                     .init = FALSE)
[09:31:36.211]                 }
[09:31:36.211]             }
[09:31:36.211]         }
[09:31:36.211]     })
[09:31:36.211]     if (TRUE) {
[09:31:36.211]         base::sink(type = "output", split = FALSE)
[09:31:36.211]         if (TRUE) {
[09:31:36.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.211]         }
[09:31:36.211]         else {
[09:31:36.211]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.211]         }
[09:31:36.211]         base::close(...future.stdout)
[09:31:36.211]         ...future.stdout <- NULL
[09:31:36.211]     }
[09:31:36.211]     ...future.result$conditions <- ...future.conditions
[09:31:36.211]     ...future.result$finished <- base::Sys.time()
[09:31:36.211]     ...future.result
[09:31:36.211] }
[09:31:36.213] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[09:31:36.214] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[09:31:36.264] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[09:31:36.264] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[09:31:36.265] MultisessionFuture started
[09:31:36.265] - Launch lazy future ... done
[09:31:36.265] run() for ‘MultisessionFuture’ ... done
[09:31:36.265] result() for ClusterFuture ...
[09:31:36.265] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.265] - Validating connection of MultisessionFuture
[09:31:36.310] - received message: FutureResult
[09:31:36.310] - Received FutureResult
[09:31:36.310] - Erased future from FutureRegistry
[09:31:36.310] result() for ClusterFuture ...
[09:31:36.310] - result already collected: FutureResult
[09:31:36.310] result() for ClusterFuture ... done
[09:31:36.310] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.310] result() for ClusterFuture ... done
[09:31:36.311] result() for ClusterFuture ...
[09:31:36.311] - result already collected: FutureResult
[09:31:36.311] result() for ClusterFuture ... done
value(b) = 2
[09:31:36.311] result() for ClusterFuture ...
[09:31:36.311] - result already collected: FutureResult
[09:31:36.311] result() for ClusterFuture ... done
[09:31:36.311] result() for ClusterFuture ...
[09:31:36.311] - result already collected: FutureResult
[09:31:36.311] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.312] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.312] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:36.312] 
[09:31:36.312] Searching for globals ... DONE
[09:31:36.313] - globals: [0] <none>
[09:31:36.313] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.313] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.313] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:36.314] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:36.314] Searching for globals ... DONE
[09:31:36.314] Resolving globals: TRUE
[09:31:36.314] Resolving any globals that are futures ...
[09:31:36.314] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:36.315] Resolving any globals that are futures ... DONE
[09:31:36.315] Resolving futures part of globals (recursively) ...
[09:31:36.315] resolve() on list ...
[09:31:36.315]  recursive: 99
[09:31:36.315]  length: 1
[09:31:36.315]  elements: ‘a’
[09:31:36.316] run() for ‘Future’ ...
[09:31:36.316] - state: ‘created’
[09:31:36.316] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.330] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.330]   - Field: ‘node’
[09:31:36.330]   - Field: ‘label’
[09:31:36.330]   - Field: ‘local’
[09:31:36.330]   - Field: ‘owner’
[09:31:36.330]   - Field: ‘envir’
[09:31:36.331]   - Field: ‘workers’
[09:31:36.331]   - Field: ‘packages’
[09:31:36.331]   - Field: ‘gc’
[09:31:36.331]   - Field: ‘conditions’
[09:31:36.331]   - Field: ‘persistent’
[09:31:36.331]   - Field: ‘expr’
[09:31:36.331]   - Field: ‘uuid’
[09:31:36.331]   - Field: ‘seed’
[09:31:36.331]   - Field: ‘version’
[09:31:36.331]   - Field: ‘result’
[09:31:36.333]   - Field: ‘asynchronous’
[09:31:36.334]   - Field: ‘calls’
[09:31:36.334]   - Field: ‘globals’
[09:31:36.334]   - Field: ‘stdout’
[09:31:36.334]   - Field: ‘earlySignal’
[09:31:36.334]   - Field: ‘lazy’
[09:31:36.334]   - Field: ‘state’
[09:31:36.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.334] - Launch lazy future ...
[09:31:36.334] Packages needed by the future expression (n = 0): <none>
[09:31:36.335] Packages needed by future strategies (n = 0): <none>
[09:31:36.335] {
[09:31:36.335]     {
[09:31:36.335]         {
[09:31:36.335]             ...future.startTime <- base::Sys.time()
[09:31:36.335]             {
[09:31:36.335]                 {
[09:31:36.335]                   {
[09:31:36.335]                     {
[09:31:36.335]                       base::local({
[09:31:36.335]                         has_future <- base::requireNamespace("future", 
[09:31:36.335]                           quietly = TRUE)
[09:31:36.335]                         if (has_future) {
[09:31:36.335]                           ns <- base::getNamespace("future")
[09:31:36.335]                           version <- ns[[".package"]][["version"]]
[09:31:36.335]                           if (is.null(version)) 
[09:31:36.335]                             version <- utils::packageVersion("future")
[09:31:36.335]                         }
[09:31:36.335]                         else {
[09:31:36.335]                           version <- NULL
[09:31:36.335]                         }
[09:31:36.335]                         if (!has_future || version < "1.8.0") {
[09:31:36.335]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.335]                             "", base::R.version$version.string), 
[09:31:36.335]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.335]                               "release", "version")], collapse = " "), 
[09:31:36.335]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.335]                             info)
[09:31:36.335]                           info <- base::paste(info, collapse = "; ")
[09:31:36.335]                           if (!has_future) {
[09:31:36.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.335]                               info)
[09:31:36.335]                           }
[09:31:36.335]                           else {
[09:31:36.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.335]                               info, version)
[09:31:36.335]                           }
[09:31:36.335]                           base::stop(msg)
[09:31:36.335]                         }
[09:31:36.335]                       })
[09:31:36.335]                     }
[09:31:36.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.335]                     base::options(mc.cores = 1L)
[09:31:36.335]                   }
[09:31:36.335]                   ...future.strategy.old <- future::plan("list")
[09:31:36.335]                   options(future.plan = NULL)
[09:31:36.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.335]                 }
[09:31:36.335]                 ...future.workdir <- getwd()
[09:31:36.335]             }
[09:31:36.335]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.335]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.335]         }
[09:31:36.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.335]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.335]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.335]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.335]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.335]             base::names(...future.oldOptions))
[09:31:36.335]     }
[09:31:36.335]     if (FALSE) {
[09:31:36.335]     }
[09:31:36.335]     else {
[09:31:36.335]         if (TRUE) {
[09:31:36.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.335]                 open = "w")
[09:31:36.335]         }
[09:31:36.335]         else {
[09:31:36.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.335]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.335]         }
[09:31:36.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.335]             base::sink(type = "output", split = FALSE)
[09:31:36.335]             base::close(...future.stdout)
[09:31:36.335]         }, add = TRUE)
[09:31:36.335]     }
[09:31:36.335]     ...future.frame <- base::sys.nframe()
[09:31:36.335]     ...future.conditions <- base::list()
[09:31:36.335]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.335]     if (FALSE) {
[09:31:36.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.335]     }
[09:31:36.335]     ...future.result <- base::tryCatch({
[09:31:36.335]         base::withCallingHandlers({
[09:31:36.335]             ...future.value <- base::withVisible(base::local({
[09:31:36.335]                 ...future.makeSendCondition <- base::local({
[09:31:36.335]                   sendCondition <- NULL
[09:31:36.335]                   function(frame = 1L) {
[09:31:36.335]                     if (is.function(sendCondition)) 
[09:31:36.335]                       return(sendCondition)
[09:31:36.335]                     ns <- getNamespace("parallel")
[09:31:36.335]                     if (exists("sendData", mode = "function", 
[09:31:36.335]                       envir = ns)) {
[09:31:36.335]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.335]                         envir = ns)
[09:31:36.335]                       envir <- sys.frame(frame)
[09:31:36.335]                       master <- NULL
[09:31:36.335]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.335]                         !identical(envir, emptyenv())) {
[09:31:36.335]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.335]                           inherits = FALSE)) {
[09:31:36.335]                           master <- get("master", mode = "list", 
[09:31:36.335]                             envir = envir, inherits = FALSE)
[09:31:36.335]                           if (inherits(master, c("SOCKnode", 
[09:31:36.335]                             "SOCK0node"))) {
[09:31:36.335]                             sendCondition <<- function(cond) {
[09:31:36.335]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.335]                                 success = TRUE)
[09:31:36.335]                               parallel_sendData(master, data)
[09:31:36.335]                             }
[09:31:36.335]                             return(sendCondition)
[09:31:36.335]                           }
[09:31:36.335]                         }
[09:31:36.335]                         frame <- frame + 1L
[09:31:36.335]                         envir <- sys.frame(frame)
[09:31:36.335]                       }
[09:31:36.335]                     }
[09:31:36.335]                     sendCondition <<- function(cond) NULL
[09:31:36.335]                   }
[09:31:36.335]                 })
[09:31:36.335]                 withCallingHandlers({
[09:31:36.335]                   1
[09:31:36.335]                 }, immediateCondition = function(cond) {
[09:31:36.335]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.335]                   sendCondition(cond)
[09:31:36.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.335]                   {
[09:31:36.335]                     inherits <- base::inherits
[09:31:36.335]                     invokeRestart <- base::invokeRestart
[09:31:36.335]                     is.null <- base::is.null
[09:31:36.335]                     muffled <- FALSE
[09:31:36.335]                     if (inherits(cond, "message")) {
[09:31:36.335]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.335]                       if (muffled) 
[09:31:36.335]                         invokeRestart("muffleMessage")
[09:31:36.335]                     }
[09:31:36.335]                     else if (inherits(cond, "warning")) {
[09:31:36.335]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.335]                       if (muffled) 
[09:31:36.335]                         invokeRestart("muffleWarning")
[09:31:36.335]                     }
[09:31:36.335]                     else if (inherits(cond, "condition")) {
[09:31:36.335]                       if (!is.null(pattern)) {
[09:31:36.335]                         computeRestarts <- base::computeRestarts
[09:31:36.335]                         grepl <- base::grepl
[09:31:36.335]                         restarts <- computeRestarts(cond)
[09:31:36.335]                         for (restart in restarts) {
[09:31:36.335]                           name <- restart$name
[09:31:36.335]                           if (is.null(name)) 
[09:31:36.335]                             next
[09:31:36.335]                           if (!grepl(pattern, name)) 
[09:31:36.335]                             next
[09:31:36.335]                           invokeRestart(restart)
[09:31:36.335]                           muffled <- TRUE
[09:31:36.335]                           break
[09:31:36.335]                         }
[09:31:36.335]                       }
[09:31:36.335]                     }
[09:31:36.335]                     invisible(muffled)
[09:31:36.335]                   }
[09:31:36.335]                   muffleCondition(cond)
[09:31:36.335]                 })
[09:31:36.335]             }))
[09:31:36.335]             future::FutureResult(value = ...future.value$value, 
[09:31:36.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.335]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.335]                     ...future.globalenv.names))
[09:31:36.335]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.335]         }, condition = base::local({
[09:31:36.335]             c <- base::c
[09:31:36.335]             inherits <- base::inherits
[09:31:36.335]             invokeRestart <- base::invokeRestart
[09:31:36.335]             length <- base::length
[09:31:36.335]             list <- base::list
[09:31:36.335]             seq.int <- base::seq.int
[09:31:36.335]             signalCondition <- base::signalCondition
[09:31:36.335]             sys.calls <- base::sys.calls
[09:31:36.335]             `[[` <- base::`[[`
[09:31:36.335]             `+` <- base::`+`
[09:31:36.335]             `<<-` <- base::`<<-`
[09:31:36.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.335]                   3L)]
[09:31:36.335]             }
[09:31:36.335]             function(cond) {
[09:31:36.335]                 is_error <- inherits(cond, "error")
[09:31:36.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.335]                   NULL)
[09:31:36.335]                 if (is_error) {
[09:31:36.335]                   sessionInformation <- function() {
[09:31:36.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.335]                       search = base::search(), system = base::Sys.info())
[09:31:36.335]                   }
[09:31:36.335]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.335]                     cond$call), session = sessionInformation(), 
[09:31:36.335]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.335]                   signalCondition(cond)
[09:31:36.335]                 }
[09:31:36.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.335]                 "immediateCondition"))) {
[09:31:36.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.335]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.335]                   if (TRUE && !signal) {
[09:31:36.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.335]                     {
[09:31:36.335]                       inherits <- base::inherits
[09:31:36.335]                       invokeRestart <- base::invokeRestart
[09:31:36.335]                       is.null <- base::is.null
[09:31:36.335]                       muffled <- FALSE
[09:31:36.335]                       if (inherits(cond, "message")) {
[09:31:36.335]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.335]                         if (muffled) 
[09:31:36.335]                           invokeRestart("muffleMessage")
[09:31:36.335]                       }
[09:31:36.335]                       else if (inherits(cond, "warning")) {
[09:31:36.335]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.335]                         if (muffled) 
[09:31:36.335]                           invokeRestart("muffleWarning")
[09:31:36.335]                       }
[09:31:36.335]                       else if (inherits(cond, "condition")) {
[09:31:36.335]                         if (!is.null(pattern)) {
[09:31:36.335]                           computeRestarts <- base::computeRestarts
[09:31:36.335]                           grepl <- base::grepl
[09:31:36.335]                           restarts <- computeRestarts(cond)
[09:31:36.335]                           for (restart in restarts) {
[09:31:36.335]                             name <- restart$name
[09:31:36.335]                             if (is.null(name)) 
[09:31:36.335]                               next
[09:31:36.335]                             if (!grepl(pattern, name)) 
[09:31:36.335]                               next
[09:31:36.335]                             invokeRestart(restart)
[09:31:36.335]                             muffled <- TRUE
[09:31:36.335]                             break
[09:31:36.335]                           }
[09:31:36.335]                         }
[09:31:36.335]                       }
[09:31:36.335]                       invisible(muffled)
[09:31:36.335]                     }
[09:31:36.335]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.335]                   }
[09:31:36.335]                 }
[09:31:36.335]                 else {
[09:31:36.335]                   if (TRUE) {
[09:31:36.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.335]                     {
[09:31:36.335]                       inherits <- base::inherits
[09:31:36.335]                       invokeRestart <- base::invokeRestart
[09:31:36.335]                       is.null <- base::is.null
[09:31:36.335]                       muffled <- FALSE
[09:31:36.335]                       if (inherits(cond, "message")) {
[09:31:36.335]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.335]                         if (muffled) 
[09:31:36.335]                           invokeRestart("muffleMessage")
[09:31:36.335]                       }
[09:31:36.335]                       else if (inherits(cond, "warning")) {
[09:31:36.335]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.335]                         if (muffled) 
[09:31:36.335]                           invokeRestart("muffleWarning")
[09:31:36.335]                       }
[09:31:36.335]                       else if (inherits(cond, "condition")) {
[09:31:36.335]                         if (!is.null(pattern)) {
[09:31:36.335]                           computeRestarts <- base::computeRestarts
[09:31:36.335]                           grepl <- base::grepl
[09:31:36.335]                           restarts <- computeRestarts(cond)
[09:31:36.335]                           for (restart in restarts) {
[09:31:36.335]                             name <- restart$name
[09:31:36.335]                             if (is.null(name)) 
[09:31:36.335]                               next
[09:31:36.335]                             if (!grepl(pattern, name)) 
[09:31:36.335]                               next
[09:31:36.335]                             invokeRestart(restart)
[09:31:36.335]                             muffled <- TRUE
[09:31:36.335]                             break
[09:31:36.335]                           }
[09:31:36.335]                         }
[09:31:36.335]                       }
[09:31:36.335]                       invisible(muffled)
[09:31:36.335]                     }
[09:31:36.335]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.335]                   }
[09:31:36.335]                 }
[09:31:36.335]             }
[09:31:36.335]         }))
[09:31:36.335]     }, error = function(ex) {
[09:31:36.335]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.335]                 ...future.rng), started = ...future.startTime, 
[09:31:36.335]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.335]             version = "1.8"), class = "FutureResult")
[09:31:36.335]     }, finally = {
[09:31:36.335]         if (!identical(...future.workdir, getwd())) 
[09:31:36.335]             setwd(...future.workdir)
[09:31:36.335]         {
[09:31:36.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.335]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.335]             }
[09:31:36.335]             base::options(...future.oldOptions)
[09:31:36.335]             if (.Platform$OS.type == "windows") {
[09:31:36.335]                 old_names <- names(...future.oldEnvVars)
[09:31:36.335]                 envs <- base::Sys.getenv()
[09:31:36.335]                 names <- names(envs)
[09:31:36.335]                 common <- intersect(names, old_names)
[09:31:36.335]                 added <- setdiff(names, old_names)
[09:31:36.335]                 removed <- setdiff(old_names, names)
[09:31:36.335]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.335]                   envs[common]]
[09:31:36.335]                 NAMES <- toupper(changed)
[09:31:36.335]                 args <- list()
[09:31:36.335]                 for (kk in seq_along(NAMES)) {
[09:31:36.335]                   name <- changed[[kk]]
[09:31:36.335]                   NAME <- NAMES[[kk]]
[09:31:36.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.335]                     next
[09:31:36.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.335]                 }
[09:31:36.335]                 NAMES <- toupper(added)
[09:31:36.335]                 for (kk in seq_along(NAMES)) {
[09:31:36.335]                   name <- added[[kk]]
[09:31:36.335]                   NAME <- NAMES[[kk]]
[09:31:36.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.335]                     next
[09:31:36.335]                   args[[name]] <- ""
[09:31:36.335]                 }
[09:31:36.335]                 NAMES <- toupper(removed)
[09:31:36.335]                 for (kk in seq_along(NAMES)) {
[09:31:36.335]                   name <- removed[[kk]]
[09:31:36.335]                   NAME <- NAMES[[kk]]
[09:31:36.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.335]                     next
[09:31:36.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.335]                 }
[09:31:36.335]                 if (length(args) > 0) 
[09:31:36.335]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.335]             }
[09:31:36.335]             else {
[09:31:36.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.335]             }
[09:31:36.335]             {
[09:31:36.335]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.335]                   0L) {
[09:31:36.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.335]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.335]                   base::options(opts)
[09:31:36.335]                 }
[09:31:36.335]                 {
[09:31:36.335]                   {
[09:31:36.335]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.335]                     NULL
[09:31:36.335]                   }
[09:31:36.335]                   options(future.plan = NULL)
[09:31:36.335]                   if (is.na(NA_character_)) 
[09:31:36.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.335]                     .init = FALSE)
[09:31:36.335]                 }
[09:31:36.335]             }
[09:31:36.335]         }
[09:31:36.335]     })
[09:31:36.335]     if (TRUE) {
[09:31:36.335]         base::sink(type = "output", split = FALSE)
[09:31:36.335]         if (TRUE) {
[09:31:36.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.335]         }
[09:31:36.335]         else {
[09:31:36.335]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.335]         }
[09:31:36.335]         base::close(...future.stdout)
[09:31:36.335]         ...future.stdout <- NULL
[09:31:36.335]     }
[09:31:36.335]     ...future.result$conditions <- ...future.conditions
[09:31:36.335]     ...future.result$finished <- base::Sys.time()
[09:31:36.335]     ...future.result
[09:31:36.335] }
[09:31:36.338] MultisessionFuture started
[09:31:36.338] - Launch lazy future ... done
[09:31:36.338] run() for ‘MultisessionFuture’ ... done
[09:31:36.382] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.382] - Validating connection of MultisessionFuture
[09:31:36.382] - received message: FutureResult
[09:31:36.382] - Received FutureResult
[09:31:36.382] - Erased future from FutureRegistry
[09:31:36.382] result() for ClusterFuture ...
[09:31:36.382] - result already collected: FutureResult
[09:31:36.382] result() for ClusterFuture ... done
[09:31:36.383] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.383] Future #1
[09:31:36.383] result() for ClusterFuture ...
[09:31:36.383] - result already collected: FutureResult
[09:31:36.383] result() for ClusterFuture ... done
[09:31:36.383] result() for ClusterFuture ...
[09:31:36.383] - result already collected: FutureResult
[09:31:36.383] result() for ClusterFuture ... done
[09:31:36.383] A MultisessionFuture was resolved
[09:31:36.383]  length: 0 (resolved future 1)
[09:31:36.384] resolve() on list ... DONE
[09:31:36.384] - globals: [1] ‘a’
[09:31:36.384] Resolving futures part of globals (recursively) ... DONE
[09:31:36.385] The total size of the 1 globals is 10.45 KiB (10704 bytes)
[09:31:36.385] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 10.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (10.45 KiB of class ‘environment’)
[09:31:36.385] - globals: [1] ‘a’
[09:31:36.385] - packages: [1] ‘future’
[09:31:36.385] getGlobalsAndPackages() ... DONE
[09:31:36.386] run() for ‘Future’ ...
[09:31:36.386] - state: ‘created’
[09:31:36.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.400]   - Field: ‘node’
[09:31:36.400]   - Field: ‘label’
[09:31:36.400]   - Field: ‘local’
[09:31:36.400]   - Field: ‘owner’
[09:31:36.400]   - Field: ‘envir’
[09:31:36.400]   - Field: ‘workers’
[09:31:36.400]   - Field: ‘packages’
[09:31:36.401]   - Field: ‘gc’
[09:31:36.401]   - Field: ‘conditions’
[09:31:36.401]   - Field: ‘persistent’
[09:31:36.401]   - Field: ‘expr’
[09:31:36.401]   - Field: ‘uuid’
[09:31:36.401]   - Field: ‘seed’
[09:31:36.401]   - Field: ‘version’
[09:31:36.401]   - Field: ‘result’
[09:31:36.401]   - Field: ‘asynchronous’
[09:31:36.401]   - Field: ‘calls’
[09:31:36.401]   - Field: ‘globals’
[09:31:36.401]   - Field: ‘stdout’
[09:31:36.402]   - Field: ‘earlySignal’
[09:31:36.402]   - Field: ‘lazy’
[09:31:36.402]   - Field: ‘state’
[09:31:36.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.402] - Launch lazy future ...
[09:31:36.402] Packages needed by the future expression (n = 1): ‘future’
[09:31:36.402] Packages needed by future strategies (n = 0): <none>
[09:31:36.403] {
[09:31:36.403]     {
[09:31:36.403]         {
[09:31:36.403]             ...future.startTime <- base::Sys.time()
[09:31:36.403]             {
[09:31:36.403]                 {
[09:31:36.403]                   {
[09:31:36.403]                     {
[09:31:36.403]                       {
[09:31:36.403]                         base::local({
[09:31:36.403]                           has_future <- base::requireNamespace("future", 
[09:31:36.403]                             quietly = TRUE)
[09:31:36.403]                           if (has_future) {
[09:31:36.403]                             ns <- base::getNamespace("future")
[09:31:36.403]                             version <- ns[[".package"]][["version"]]
[09:31:36.403]                             if (is.null(version)) 
[09:31:36.403]                               version <- utils::packageVersion("future")
[09:31:36.403]                           }
[09:31:36.403]                           else {
[09:31:36.403]                             version <- NULL
[09:31:36.403]                           }
[09:31:36.403]                           if (!has_future || version < "1.8.0") {
[09:31:36.403]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.403]                               "", base::R.version$version.string), 
[09:31:36.403]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:36.403]                                 base::R.version$platform, 8 * 
[09:31:36.403]                                   base::.Machine$sizeof.pointer), 
[09:31:36.403]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.403]                                 "release", "version")], collapse = " "), 
[09:31:36.403]                               hostname = base::Sys.info()[["nodename"]])
[09:31:36.403]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.403]                               info)
[09:31:36.403]                             info <- base::paste(info, collapse = "; ")
[09:31:36.403]                             if (!has_future) {
[09:31:36.403]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.403]                                 info)
[09:31:36.403]                             }
[09:31:36.403]                             else {
[09:31:36.403]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.403]                                 info, version)
[09:31:36.403]                             }
[09:31:36.403]                             base::stop(msg)
[09:31:36.403]                           }
[09:31:36.403]                         })
[09:31:36.403]                       }
[09:31:36.403]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.403]                       base::options(mc.cores = 1L)
[09:31:36.403]                     }
[09:31:36.403]                     base::local({
[09:31:36.403]                       for (pkg in "future") {
[09:31:36.403]                         base::loadNamespace(pkg)
[09:31:36.403]                         base::library(pkg, character.only = TRUE)
[09:31:36.403]                       }
[09:31:36.403]                     })
[09:31:36.403]                   }
[09:31:36.403]                   ...future.strategy.old <- future::plan("list")
[09:31:36.403]                   options(future.plan = NULL)
[09:31:36.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.403]                 }
[09:31:36.403]                 ...future.workdir <- getwd()
[09:31:36.403]             }
[09:31:36.403]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.403]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.403]         }
[09:31:36.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.403]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.403]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.403]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.403]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.403]             base::names(...future.oldOptions))
[09:31:36.403]     }
[09:31:36.403]     if (FALSE) {
[09:31:36.403]     }
[09:31:36.403]     else {
[09:31:36.403]         if (TRUE) {
[09:31:36.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.403]                 open = "w")
[09:31:36.403]         }
[09:31:36.403]         else {
[09:31:36.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.403]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.403]         }
[09:31:36.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.403]             base::sink(type = "output", split = FALSE)
[09:31:36.403]             base::close(...future.stdout)
[09:31:36.403]         }, add = TRUE)
[09:31:36.403]     }
[09:31:36.403]     ...future.frame <- base::sys.nframe()
[09:31:36.403]     ...future.conditions <- base::list()
[09:31:36.403]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.403]     if (FALSE) {
[09:31:36.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.403]     }
[09:31:36.403]     ...future.result <- base::tryCatch({
[09:31:36.403]         base::withCallingHandlers({
[09:31:36.403]             ...future.value <- base::withVisible(base::local({
[09:31:36.403]                 ...future.makeSendCondition <- base::local({
[09:31:36.403]                   sendCondition <- NULL
[09:31:36.403]                   function(frame = 1L) {
[09:31:36.403]                     if (is.function(sendCondition)) 
[09:31:36.403]                       return(sendCondition)
[09:31:36.403]                     ns <- getNamespace("parallel")
[09:31:36.403]                     if (exists("sendData", mode = "function", 
[09:31:36.403]                       envir = ns)) {
[09:31:36.403]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.403]                         envir = ns)
[09:31:36.403]                       envir <- sys.frame(frame)
[09:31:36.403]                       master <- NULL
[09:31:36.403]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.403]                         !identical(envir, emptyenv())) {
[09:31:36.403]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.403]                           inherits = FALSE)) {
[09:31:36.403]                           master <- get("master", mode = "list", 
[09:31:36.403]                             envir = envir, inherits = FALSE)
[09:31:36.403]                           if (inherits(master, c("SOCKnode", 
[09:31:36.403]                             "SOCK0node"))) {
[09:31:36.403]                             sendCondition <<- function(cond) {
[09:31:36.403]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.403]                                 success = TRUE)
[09:31:36.403]                               parallel_sendData(master, data)
[09:31:36.403]                             }
[09:31:36.403]                             return(sendCondition)
[09:31:36.403]                           }
[09:31:36.403]                         }
[09:31:36.403]                         frame <- frame + 1L
[09:31:36.403]                         envir <- sys.frame(frame)
[09:31:36.403]                       }
[09:31:36.403]                     }
[09:31:36.403]                     sendCondition <<- function(cond) NULL
[09:31:36.403]                   }
[09:31:36.403]                 })
[09:31:36.403]                 withCallingHandlers({
[09:31:36.403]                   value(a) + 1
[09:31:36.403]                 }, immediateCondition = function(cond) {
[09:31:36.403]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.403]                   sendCondition(cond)
[09:31:36.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.403]                   {
[09:31:36.403]                     inherits <- base::inherits
[09:31:36.403]                     invokeRestart <- base::invokeRestart
[09:31:36.403]                     is.null <- base::is.null
[09:31:36.403]                     muffled <- FALSE
[09:31:36.403]                     if (inherits(cond, "message")) {
[09:31:36.403]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.403]                       if (muffled) 
[09:31:36.403]                         invokeRestart("muffleMessage")
[09:31:36.403]                     }
[09:31:36.403]                     else if (inherits(cond, "warning")) {
[09:31:36.403]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.403]                       if (muffled) 
[09:31:36.403]                         invokeRestart("muffleWarning")
[09:31:36.403]                     }
[09:31:36.403]                     else if (inherits(cond, "condition")) {
[09:31:36.403]                       if (!is.null(pattern)) {
[09:31:36.403]                         computeRestarts <- base::computeRestarts
[09:31:36.403]                         grepl <- base::grepl
[09:31:36.403]                         restarts <- computeRestarts(cond)
[09:31:36.403]                         for (restart in restarts) {
[09:31:36.403]                           name <- restart$name
[09:31:36.403]                           if (is.null(name)) 
[09:31:36.403]                             next
[09:31:36.403]                           if (!grepl(pattern, name)) 
[09:31:36.403]                             next
[09:31:36.403]                           invokeRestart(restart)
[09:31:36.403]                           muffled <- TRUE
[09:31:36.403]                           break
[09:31:36.403]                         }
[09:31:36.403]                       }
[09:31:36.403]                     }
[09:31:36.403]                     invisible(muffled)
[09:31:36.403]                   }
[09:31:36.403]                   muffleCondition(cond)
[09:31:36.403]                 })
[09:31:36.403]             }))
[09:31:36.403]             future::FutureResult(value = ...future.value$value, 
[09:31:36.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.403]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.403]                     ...future.globalenv.names))
[09:31:36.403]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.403]         }, condition = base::local({
[09:31:36.403]             c <- base::c
[09:31:36.403]             inherits <- base::inherits
[09:31:36.403]             invokeRestart <- base::invokeRestart
[09:31:36.403]             length <- base::length
[09:31:36.403]             list <- base::list
[09:31:36.403]             seq.int <- base::seq.int
[09:31:36.403]             signalCondition <- base::signalCondition
[09:31:36.403]             sys.calls <- base::sys.calls
[09:31:36.403]             `[[` <- base::`[[`
[09:31:36.403]             `+` <- base::`+`
[09:31:36.403]             `<<-` <- base::`<<-`
[09:31:36.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.403]                   3L)]
[09:31:36.403]             }
[09:31:36.403]             function(cond) {
[09:31:36.403]                 is_error <- inherits(cond, "error")
[09:31:36.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.403]                   NULL)
[09:31:36.403]                 if (is_error) {
[09:31:36.403]                   sessionInformation <- function() {
[09:31:36.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.403]                       search = base::search(), system = base::Sys.info())
[09:31:36.403]                   }
[09:31:36.403]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.403]                     cond$call), session = sessionInformation(), 
[09:31:36.403]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.403]                   signalCondition(cond)
[09:31:36.403]                 }
[09:31:36.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.403]                 "immediateCondition"))) {
[09:31:36.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.403]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.403]                   if (TRUE && !signal) {
[09:31:36.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.403]                     {
[09:31:36.403]                       inherits <- base::inherits
[09:31:36.403]                       invokeRestart <- base::invokeRestart
[09:31:36.403]                       is.null <- base::is.null
[09:31:36.403]                       muffled <- FALSE
[09:31:36.403]                       if (inherits(cond, "message")) {
[09:31:36.403]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.403]                         if (muffled) 
[09:31:36.403]                           invokeRestart("muffleMessage")
[09:31:36.403]                       }
[09:31:36.403]                       else if (inherits(cond, "warning")) {
[09:31:36.403]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.403]                         if (muffled) 
[09:31:36.403]                           invokeRestart("muffleWarning")
[09:31:36.403]                       }
[09:31:36.403]                       else if (inherits(cond, "condition")) {
[09:31:36.403]                         if (!is.null(pattern)) {
[09:31:36.403]                           computeRestarts <- base::computeRestarts
[09:31:36.403]                           grepl <- base::grepl
[09:31:36.403]                           restarts <- computeRestarts(cond)
[09:31:36.403]                           for (restart in restarts) {
[09:31:36.403]                             name <- restart$name
[09:31:36.403]                             if (is.null(name)) 
[09:31:36.403]                               next
[09:31:36.403]                             if (!grepl(pattern, name)) 
[09:31:36.403]                               next
[09:31:36.403]                             invokeRestart(restart)
[09:31:36.403]                             muffled <- TRUE
[09:31:36.403]                             break
[09:31:36.403]                           }
[09:31:36.403]                         }
[09:31:36.403]                       }
[09:31:36.403]                       invisible(muffled)
[09:31:36.403]                     }
[09:31:36.403]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.403]                   }
[09:31:36.403]                 }
[09:31:36.403]                 else {
[09:31:36.403]                   if (TRUE) {
[09:31:36.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.403]                     {
[09:31:36.403]                       inherits <- base::inherits
[09:31:36.403]                       invokeRestart <- base::invokeRestart
[09:31:36.403]                       is.null <- base::is.null
[09:31:36.403]                       muffled <- FALSE
[09:31:36.403]                       if (inherits(cond, "message")) {
[09:31:36.403]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.403]                         if (muffled) 
[09:31:36.403]                           invokeRestart("muffleMessage")
[09:31:36.403]                       }
[09:31:36.403]                       else if (inherits(cond, "warning")) {
[09:31:36.403]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.403]                         if (muffled) 
[09:31:36.403]                           invokeRestart("muffleWarning")
[09:31:36.403]                       }
[09:31:36.403]                       else if (inherits(cond, "condition")) {
[09:31:36.403]                         if (!is.null(pattern)) {
[09:31:36.403]                           computeRestarts <- base::computeRestarts
[09:31:36.403]                           grepl <- base::grepl
[09:31:36.403]                           restarts <- computeRestarts(cond)
[09:31:36.403]                           for (restart in restarts) {
[09:31:36.403]                             name <- restart$name
[09:31:36.403]                             if (is.null(name)) 
[09:31:36.403]                               next
[09:31:36.403]                             if (!grepl(pattern, name)) 
[09:31:36.403]                               next
[09:31:36.403]                             invokeRestart(restart)
[09:31:36.403]                             muffled <- TRUE
[09:31:36.403]                             break
[09:31:36.403]                           }
[09:31:36.403]                         }
[09:31:36.403]                       }
[09:31:36.403]                       invisible(muffled)
[09:31:36.403]                     }
[09:31:36.403]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.403]                   }
[09:31:36.403]                 }
[09:31:36.403]             }
[09:31:36.403]         }))
[09:31:36.403]     }, error = function(ex) {
[09:31:36.403]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.403]                 ...future.rng), started = ...future.startTime, 
[09:31:36.403]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.403]             version = "1.8"), class = "FutureResult")
[09:31:36.403]     }, finally = {
[09:31:36.403]         if (!identical(...future.workdir, getwd())) 
[09:31:36.403]             setwd(...future.workdir)
[09:31:36.403]         {
[09:31:36.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.403]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.403]             }
[09:31:36.403]             base::options(...future.oldOptions)
[09:31:36.403]             if (.Platform$OS.type == "windows") {
[09:31:36.403]                 old_names <- names(...future.oldEnvVars)
[09:31:36.403]                 envs <- base::Sys.getenv()
[09:31:36.403]                 names <- names(envs)
[09:31:36.403]                 common <- intersect(names, old_names)
[09:31:36.403]                 added <- setdiff(names, old_names)
[09:31:36.403]                 removed <- setdiff(old_names, names)
[09:31:36.403]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.403]                   envs[common]]
[09:31:36.403]                 NAMES <- toupper(changed)
[09:31:36.403]                 args <- list()
[09:31:36.403]                 for (kk in seq_along(NAMES)) {
[09:31:36.403]                   name <- changed[[kk]]
[09:31:36.403]                   NAME <- NAMES[[kk]]
[09:31:36.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.403]                     next
[09:31:36.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.403]                 }
[09:31:36.403]                 NAMES <- toupper(added)
[09:31:36.403]                 for (kk in seq_along(NAMES)) {
[09:31:36.403]                   name <- added[[kk]]
[09:31:36.403]                   NAME <- NAMES[[kk]]
[09:31:36.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.403]                     next
[09:31:36.403]                   args[[name]] <- ""
[09:31:36.403]                 }
[09:31:36.403]                 NAMES <- toupper(removed)
[09:31:36.403]                 for (kk in seq_along(NAMES)) {
[09:31:36.403]                   name <- removed[[kk]]
[09:31:36.403]                   NAME <- NAMES[[kk]]
[09:31:36.403]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.403]                     next
[09:31:36.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.403]                 }
[09:31:36.403]                 if (length(args) > 0) 
[09:31:36.403]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.403]             }
[09:31:36.403]             else {
[09:31:36.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.403]             }
[09:31:36.403]             {
[09:31:36.403]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.403]                   0L) {
[09:31:36.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.403]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.403]                   base::options(opts)
[09:31:36.403]                 }
[09:31:36.403]                 {
[09:31:36.403]                   {
[09:31:36.403]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.403]                     NULL
[09:31:36.403]                   }
[09:31:36.403]                   options(future.plan = NULL)
[09:31:36.403]                   if (is.na(NA_character_)) 
[09:31:36.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.403]                     .init = FALSE)
[09:31:36.403]                 }
[09:31:36.403]             }
[09:31:36.403]         }
[09:31:36.403]     })
[09:31:36.403]     if (TRUE) {
[09:31:36.403]         base::sink(type = "output", split = FALSE)
[09:31:36.403]         if (TRUE) {
[09:31:36.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.403]         }
[09:31:36.403]         else {
[09:31:36.403]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.403]         }
[09:31:36.403]         base::close(...future.stdout)
[09:31:36.403]         ...future.stdout <- NULL
[09:31:36.403]     }
[09:31:36.403]     ...future.result$conditions <- ...future.conditions
[09:31:36.403]     ...future.result$finished <- base::Sys.time()
[09:31:36.403]     ...future.result
[09:31:36.403] }
[09:31:36.405] Exporting 1 global objects (10.45 KiB) to cluster node #2 ...
[09:31:36.406] Exporting ‘a’ (10.45 KiB) to cluster node #2 ...
[09:31:36.460] Exporting ‘a’ (10.45 KiB) to cluster node #2 ... DONE
[09:31:36.460] Exporting 1 global objects (10.45 KiB) to cluster node #2 ... DONE
[09:31:36.461] MultisessionFuture started
[09:31:36.461] - Launch lazy future ... done
[09:31:36.461] run() for ‘MultisessionFuture’ ... done
[09:31:36.461] result() for ClusterFuture ...
[09:31:36.461] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.461] - Validating connection of MultisessionFuture
[09:31:36.506] - received message: FutureResult
[09:31:36.506] - Received FutureResult
[09:31:36.506] - Erased future from FutureRegistry
[09:31:36.506] result() for ClusterFuture ...
[09:31:36.506] - result already collected: FutureResult
[09:31:36.506] result() for ClusterFuture ... done
[09:31:36.507] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.507] result() for ClusterFuture ... done
[09:31:36.507] result() for ClusterFuture ...
[09:31:36.507] - result already collected: FutureResult
[09:31:36.507] result() for ClusterFuture ... done
value(b) = 2
[09:31:36.507] result() for ClusterFuture ...
[09:31:36.507] - result already collected: FutureResult
[09:31:36.507] result() for ClusterFuture ... done
[09:31:36.507] result() for ClusterFuture ...
[09:31:36.507] - result already collected: FutureResult
[09:31:36.508] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.508] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.508] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[09:31:36.509] - globals found: [2] ‘{’, ‘pkg’
[09:31:36.509] Searching for globals ... DONE
[09:31:36.509] Resolving globals: TRUE
[09:31:36.509] Resolving any globals that are futures ...
[09:31:36.509] - globals: [2] ‘{’, ‘pkg’
[09:31:36.509] Resolving any globals that are futures ... DONE
[09:31:36.510] Resolving futures part of globals (recursively) ...
[09:31:36.510] resolve() on list ...
[09:31:36.510]  recursive: 99
[09:31:36.510]  length: 1
[09:31:36.510]  elements: ‘pkg’
[09:31:36.510]  length: 0 (resolved future 1)
[09:31:36.510] resolve() on list ... DONE
[09:31:36.510] - globals: [1] ‘pkg’
[09:31:36.511] Resolving futures part of globals (recursively) ... DONE
[09:31:36.511] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:36.511] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:36.511] - globals: [1] ‘pkg’
[09:31:36.511] 
[09:31:36.511] getGlobalsAndPackages() ... DONE
[09:31:36.512] Packages needed by the future expression (n = 0): <none>
[09:31:36.512] Packages needed by future strategies (n = 0): <none>
[09:31:36.512] {
[09:31:36.512]     {
[09:31:36.512]         {
[09:31:36.512]             ...future.startTime <- base::Sys.time()
[09:31:36.512]             {
[09:31:36.512]                 {
[09:31:36.512]                   {
[09:31:36.512]                     base::local({
[09:31:36.512]                       has_future <- base::requireNamespace("future", 
[09:31:36.512]                         quietly = TRUE)
[09:31:36.512]                       if (has_future) {
[09:31:36.512]                         ns <- base::getNamespace("future")
[09:31:36.512]                         version <- ns[[".package"]][["version"]]
[09:31:36.512]                         if (is.null(version)) 
[09:31:36.512]                           version <- utils::packageVersion("future")
[09:31:36.512]                       }
[09:31:36.512]                       else {
[09:31:36.512]                         version <- NULL
[09:31:36.512]                       }
[09:31:36.512]                       if (!has_future || version < "1.8.0") {
[09:31:36.512]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.512]                           "", base::R.version$version.string), 
[09:31:36.512]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:36.512]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.512]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.512]                             "release", "version")], collapse = " "), 
[09:31:36.512]                           hostname = base::Sys.info()[["nodename"]])
[09:31:36.512]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.512]                           info)
[09:31:36.512]                         info <- base::paste(info, collapse = "; ")
[09:31:36.512]                         if (!has_future) {
[09:31:36.512]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.512]                             info)
[09:31:36.512]                         }
[09:31:36.512]                         else {
[09:31:36.512]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.512]                             info, version)
[09:31:36.512]                         }
[09:31:36.512]                         base::stop(msg)
[09:31:36.512]                       }
[09:31:36.512]                     })
[09:31:36.512]                   }
[09:31:36.512]                   ...future.strategy.old <- future::plan("list")
[09:31:36.512]                   options(future.plan = NULL)
[09:31:36.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.512]                 }
[09:31:36.512]                 ...future.workdir <- getwd()
[09:31:36.512]             }
[09:31:36.512]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.512]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.512]         }
[09:31:36.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.512]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[09:31:36.512]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.512]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.512]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.512]             base::names(...future.oldOptions))
[09:31:36.512]     }
[09:31:36.512]     if (FALSE) {
[09:31:36.512]     }
[09:31:36.512]     else {
[09:31:36.512]         if (TRUE) {
[09:31:36.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.512]                 open = "w")
[09:31:36.512]         }
[09:31:36.512]         else {
[09:31:36.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.512]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.512]         }
[09:31:36.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.512]             base::sink(type = "output", split = FALSE)
[09:31:36.512]             base::close(...future.stdout)
[09:31:36.512]         }, add = TRUE)
[09:31:36.512]     }
[09:31:36.512]     ...future.frame <- base::sys.nframe()
[09:31:36.512]     ...future.conditions <- base::list()
[09:31:36.512]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.512]     if (FALSE) {
[09:31:36.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.512]     }
[09:31:36.512]     ...future.result <- base::tryCatch({
[09:31:36.512]         base::withCallingHandlers({
[09:31:36.512]             ...future.value <- base::withVisible(base::local({
[09:31:36.512]                 pkg
[09:31:36.512]             }))
[09:31:36.512]             future::FutureResult(value = ...future.value$value, 
[09:31:36.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.512]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.512]                     ...future.globalenv.names))
[09:31:36.512]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.512]         }, condition = base::local({
[09:31:36.512]             c <- base::c
[09:31:36.512]             inherits <- base::inherits
[09:31:36.512]             invokeRestart <- base::invokeRestart
[09:31:36.512]             length <- base::length
[09:31:36.512]             list <- base::list
[09:31:36.512]             seq.int <- base::seq.int
[09:31:36.512]             signalCondition <- base::signalCondition
[09:31:36.512]             sys.calls <- base::sys.calls
[09:31:36.512]             `[[` <- base::`[[`
[09:31:36.512]             `+` <- base::`+`
[09:31:36.512]             `<<-` <- base::`<<-`
[09:31:36.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.512]                   3L)]
[09:31:36.512]             }
[09:31:36.512]             function(cond) {
[09:31:36.512]                 is_error <- inherits(cond, "error")
[09:31:36.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.512]                   NULL)
[09:31:36.512]                 if (is_error) {
[09:31:36.512]                   sessionInformation <- function() {
[09:31:36.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.512]                       search = base::search(), system = base::Sys.info())
[09:31:36.512]                   }
[09:31:36.512]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.512]                     cond$call), session = sessionInformation(), 
[09:31:36.512]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.512]                   signalCondition(cond)
[09:31:36.512]                 }
[09:31:36.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.512]                 "immediateCondition"))) {
[09:31:36.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.512]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.512]                   if (TRUE && !signal) {
[09:31:36.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.512]                     {
[09:31:36.512]                       inherits <- base::inherits
[09:31:36.512]                       invokeRestart <- base::invokeRestart
[09:31:36.512]                       is.null <- base::is.null
[09:31:36.512]                       muffled <- FALSE
[09:31:36.512]                       if (inherits(cond, "message")) {
[09:31:36.512]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.512]                         if (muffled) 
[09:31:36.512]                           invokeRestart("muffleMessage")
[09:31:36.512]                       }
[09:31:36.512]                       else if (inherits(cond, "warning")) {
[09:31:36.512]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.512]                         if (muffled) 
[09:31:36.512]                           invokeRestart("muffleWarning")
[09:31:36.512]                       }
[09:31:36.512]                       else if (inherits(cond, "condition")) {
[09:31:36.512]                         if (!is.null(pattern)) {
[09:31:36.512]                           computeRestarts <- base::computeRestarts
[09:31:36.512]                           grepl <- base::grepl
[09:31:36.512]                           restarts <- computeRestarts(cond)
[09:31:36.512]                           for (restart in restarts) {
[09:31:36.512]                             name <- restart$name
[09:31:36.512]                             if (is.null(name)) 
[09:31:36.512]                               next
[09:31:36.512]                             if (!grepl(pattern, name)) 
[09:31:36.512]                               next
[09:31:36.512]                             invokeRestart(restart)
[09:31:36.512]                             muffled <- TRUE
[09:31:36.512]                             break
[09:31:36.512]                           }
[09:31:36.512]                         }
[09:31:36.512]                       }
[09:31:36.512]                       invisible(muffled)
[09:31:36.512]                     }
[09:31:36.512]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.512]                   }
[09:31:36.512]                 }
[09:31:36.512]                 else {
[09:31:36.512]                   if (TRUE) {
[09:31:36.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.512]                     {
[09:31:36.512]                       inherits <- base::inherits
[09:31:36.512]                       invokeRestart <- base::invokeRestart
[09:31:36.512]                       is.null <- base::is.null
[09:31:36.512]                       muffled <- FALSE
[09:31:36.512]                       if (inherits(cond, "message")) {
[09:31:36.512]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.512]                         if (muffled) 
[09:31:36.512]                           invokeRestart("muffleMessage")
[09:31:36.512]                       }
[09:31:36.512]                       else if (inherits(cond, "warning")) {
[09:31:36.512]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.512]                         if (muffled) 
[09:31:36.512]                           invokeRestart("muffleWarning")
[09:31:36.512]                       }
[09:31:36.512]                       else if (inherits(cond, "condition")) {
[09:31:36.512]                         if (!is.null(pattern)) {
[09:31:36.512]                           computeRestarts <- base::computeRestarts
[09:31:36.512]                           grepl <- base::grepl
[09:31:36.512]                           restarts <- computeRestarts(cond)
[09:31:36.512]                           for (restart in restarts) {
[09:31:36.512]                             name <- restart$name
[09:31:36.512]                             if (is.null(name)) 
[09:31:36.512]                               next
[09:31:36.512]                             if (!grepl(pattern, name)) 
[09:31:36.512]                               next
[09:31:36.512]                             invokeRestart(restart)
[09:31:36.512]                             muffled <- TRUE
[09:31:36.512]                             break
[09:31:36.512]                           }
[09:31:36.512]                         }
[09:31:36.512]                       }
[09:31:36.512]                       invisible(muffled)
[09:31:36.512]                     }
[09:31:36.512]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.512]                   }
[09:31:36.512]                 }
[09:31:36.512]             }
[09:31:36.512]         }))
[09:31:36.512]     }, error = function(ex) {
[09:31:36.512]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.512]                 ...future.rng), started = ...future.startTime, 
[09:31:36.512]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.512]             version = "1.8"), class = "FutureResult")
[09:31:36.512]     }, finally = {
[09:31:36.512]         if (!identical(...future.workdir, getwd())) 
[09:31:36.512]             setwd(...future.workdir)
[09:31:36.512]         {
[09:31:36.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.512]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.512]             }
[09:31:36.512]             base::options(...future.oldOptions)
[09:31:36.512]             if (.Platform$OS.type == "windows") {
[09:31:36.512]                 old_names <- names(...future.oldEnvVars)
[09:31:36.512]                 envs <- base::Sys.getenv()
[09:31:36.512]                 names <- names(envs)
[09:31:36.512]                 common <- intersect(names, old_names)
[09:31:36.512]                 added <- setdiff(names, old_names)
[09:31:36.512]                 removed <- setdiff(old_names, names)
[09:31:36.512]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.512]                   envs[common]]
[09:31:36.512]                 NAMES <- toupper(changed)
[09:31:36.512]                 args <- list()
[09:31:36.512]                 for (kk in seq_along(NAMES)) {
[09:31:36.512]                   name <- changed[[kk]]
[09:31:36.512]                   NAME <- NAMES[[kk]]
[09:31:36.512]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.512]                     next
[09:31:36.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.512]                 }
[09:31:36.512]                 NAMES <- toupper(added)
[09:31:36.512]                 for (kk in seq_along(NAMES)) {
[09:31:36.512]                   name <- added[[kk]]
[09:31:36.512]                   NAME <- NAMES[[kk]]
[09:31:36.512]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.512]                     next
[09:31:36.512]                   args[[name]] <- ""
[09:31:36.512]                 }
[09:31:36.512]                 NAMES <- toupper(removed)
[09:31:36.512]                 for (kk in seq_along(NAMES)) {
[09:31:36.512]                   name <- removed[[kk]]
[09:31:36.512]                   NAME <- NAMES[[kk]]
[09:31:36.512]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.512]                     next
[09:31:36.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.512]                 }
[09:31:36.512]                 if (length(args) > 0) 
[09:31:36.512]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.512]             }
[09:31:36.512]             else {
[09:31:36.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.512]             }
[09:31:36.512]             {
[09:31:36.512]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.512]                   0L) {
[09:31:36.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.512]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.512]                   base::options(opts)
[09:31:36.512]                 }
[09:31:36.512]                 {
[09:31:36.512]                   {
[09:31:36.512]                     NULL
[09:31:36.512]                     RNGkind("Mersenne-Twister")
[09:31:36.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:36.512]                       inherits = FALSE)
[09:31:36.512]                   }
[09:31:36.512]                   options(future.plan = NULL)
[09:31:36.512]                   if (is.na(NA_character_)) 
[09:31:36.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.512]                     .init = FALSE)
[09:31:36.512]                 }
[09:31:36.512]             }
[09:31:36.512]         }
[09:31:36.512]     })
[09:31:36.512]     if (TRUE) {
[09:31:36.512]         base::sink(type = "output", split = FALSE)
[09:31:36.512]         if (TRUE) {
[09:31:36.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.512]         }
[09:31:36.512]         else {
[09:31:36.512]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.512]         }
[09:31:36.512]         base::close(...future.stdout)
[09:31:36.512]         ...future.stdout <- NULL
[09:31:36.512]     }
[09:31:36.512]     ...future.result$conditions <- ...future.conditions
[09:31:36.512]     ...future.result$finished <- base::Sys.time()
[09:31:36.512]     ...future.result
[09:31:36.512] }
[09:31:36.514] assign_globals() ...
[09:31:36.514] List of 1
[09:31:36.514]  $ pkg: chr "foo"
[09:31:36.514]  - attr(*, "where")=List of 1
[09:31:36.514]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:36.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:36.514]  - attr(*, "resolved")= logi TRUE
[09:31:36.514]  - attr(*, "total_size")= num 112
[09:31:36.516] - copied ‘pkg’ to environment
[09:31:36.516] assign_globals() ... done
[09:31:36.516] plan(): Setting new future strategy stack:
[09:31:36.516] List of future strategies:
[09:31:36.516] 1. sequential:
[09:31:36.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:36.516]    - tweaked: FALSE
[09:31:36.516]    - call: NULL
[09:31:36.517] plan(): nbrOfWorkers() = 1
[09:31:36.518] plan(): Setting new future strategy stack:
[09:31:36.518] List of future strategies:
[09:31:36.518] 1. multisession:
[09:31:36.518]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:36.518]    - tweaked: FALSE
[09:31:36.518]    - call: plan(strategy)
[09:31:36.521] plan(): nbrOfWorkers() = 2
[09:31:36.521] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.522] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.522] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.524] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:36.524] Searching for globals ... DONE
[09:31:36.524] Resolving globals: TRUE
[09:31:36.524] Resolving any globals that are futures ...
[09:31:36.524] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:36.525] Resolving any globals that are futures ... DONE
[09:31:36.525] Resolving futures part of globals (recursively) ...
[09:31:36.525] resolve() on list ...
[09:31:36.525]  recursive: 99
[09:31:36.525]  length: 1
[09:31:36.525]  elements: ‘a’
[09:31:36.525]  length: 0 (resolved future 1)
[09:31:36.526] resolve() on list ... DONE
[09:31:36.526] - globals: [1] ‘a’
[09:31:36.526] Resolving futures part of globals (recursively) ... DONE
[09:31:36.526] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:36.526] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:36.526] - globals: [1] ‘a’
[09:31:36.526] 
[09:31:36.526] getGlobalsAndPackages() ... DONE
[09:31:36.527] run() for ‘Future’ ...
[09:31:36.527] - state: ‘created’
[09:31:36.527] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.541] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.541]   - Field: ‘node’
[09:31:36.541]   - Field: ‘label’
[09:31:36.541]   - Field: ‘local’
[09:31:36.541]   - Field: ‘owner’
[09:31:36.541]   - Field: ‘envir’
[09:31:36.541]   - Field: ‘workers’
[09:31:36.541]   - Field: ‘packages’
[09:31:36.541]   - Field: ‘gc’
[09:31:36.542]   - Field: ‘conditions’
[09:31:36.542]   - Field: ‘persistent’
[09:31:36.542]   - Field: ‘expr’
[09:31:36.542]   - Field: ‘uuid’
[09:31:36.542]   - Field: ‘seed’
[09:31:36.542]   - Field: ‘version’
[09:31:36.542]   - Field: ‘result’
[09:31:36.542]   - Field: ‘asynchronous’
[09:31:36.542]   - Field: ‘calls’
[09:31:36.542]   - Field: ‘globals’
[09:31:36.542]   - Field: ‘stdout’
[09:31:36.543]   - Field: ‘earlySignal’
[09:31:36.543]   - Field: ‘lazy’
[09:31:36.543]   - Field: ‘state’
[09:31:36.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.543] - Launch lazy future ...
[09:31:36.543] Packages needed by the future expression (n = 0): <none>
[09:31:36.543] Packages needed by future strategies (n = 0): <none>
[09:31:36.544] {
[09:31:36.544]     {
[09:31:36.544]         {
[09:31:36.544]             ...future.startTime <- base::Sys.time()
[09:31:36.544]             {
[09:31:36.544]                 {
[09:31:36.544]                   {
[09:31:36.544]                     {
[09:31:36.544]                       base::local({
[09:31:36.544]                         has_future <- base::requireNamespace("future", 
[09:31:36.544]                           quietly = TRUE)
[09:31:36.544]                         if (has_future) {
[09:31:36.544]                           ns <- base::getNamespace("future")
[09:31:36.544]                           version <- ns[[".package"]][["version"]]
[09:31:36.544]                           if (is.null(version)) 
[09:31:36.544]                             version <- utils::packageVersion("future")
[09:31:36.544]                         }
[09:31:36.544]                         else {
[09:31:36.544]                           version <- NULL
[09:31:36.544]                         }
[09:31:36.544]                         if (!has_future || version < "1.8.0") {
[09:31:36.544]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.544]                             "", base::R.version$version.string), 
[09:31:36.544]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.544]                               "release", "version")], collapse = " "), 
[09:31:36.544]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.544]                             info)
[09:31:36.544]                           info <- base::paste(info, collapse = "; ")
[09:31:36.544]                           if (!has_future) {
[09:31:36.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.544]                               info)
[09:31:36.544]                           }
[09:31:36.544]                           else {
[09:31:36.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.544]                               info, version)
[09:31:36.544]                           }
[09:31:36.544]                           base::stop(msg)
[09:31:36.544]                         }
[09:31:36.544]                       })
[09:31:36.544]                     }
[09:31:36.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.544]                     base::options(mc.cores = 1L)
[09:31:36.544]                   }
[09:31:36.544]                   ...future.strategy.old <- future::plan("list")
[09:31:36.544]                   options(future.plan = NULL)
[09:31:36.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.544]                 }
[09:31:36.544]                 ...future.workdir <- getwd()
[09:31:36.544]             }
[09:31:36.544]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.544]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.544]         }
[09:31:36.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.544]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.544]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.544]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.544]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.544]             base::names(...future.oldOptions))
[09:31:36.544]     }
[09:31:36.544]     if (FALSE) {
[09:31:36.544]     }
[09:31:36.544]     else {
[09:31:36.544]         if (TRUE) {
[09:31:36.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.544]                 open = "w")
[09:31:36.544]         }
[09:31:36.544]         else {
[09:31:36.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.544]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.544]         }
[09:31:36.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.544]             base::sink(type = "output", split = FALSE)
[09:31:36.544]             base::close(...future.stdout)
[09:31:36.544]         }, add = TRUE)
[09:31:36.544]     }
[09:31:36.544]     ...future.frame <- base::sys.nframe()
[09:31:36.544]     ...future.conditions <- base::list()
[09:31:36.544]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.544]     if (FALSE) {
[09:31:36.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.544]     }
[09:31:36.544]     ...future.result <- base::tryCatch({
[09:31:36.544]         base::withCallingHandlers({
[09:31:36.544]             ...future.value <- base::withVisible(base::local({
[09:31:36.544]                 ...future.makeSendCondition <- base::local({
[09:31:36.544]                   sendCondition <- NULL
[09:31:36.544]                   function(frame = 1L) {
[09:31:36.544]                     if (is.function(sendCondition)) 
[09:31:36.544]                       return(sendCondition)
[09:31:36.544]                     ns <- getNamespace("parallel")
[09:31:36.544]                     if (exists("sendData", mode = "function", 
[09:31:36.544]                       envir = ns)) {
[09:31:36.544]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.544]                         envir = ns)
[09:31:36.544]                       envir <- sys.frame(frame)
[09:31:36.544]                       master <- NULL
[09:31:36.544]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.544]                         !identical(envir, emptyenv())) {
[09:31:36.544]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.544]                           inherits = FALSE)) {
[09:31:36.544]                           master <- get("master", mode = "list", 
[09:31:36.544]                             envir = envir, inherits = FALSE)
[09:31:36.544]                           if (inherits(master, c("SOCKnode", 
[09:31:36.544]                             "SOCK0node"))) {
[09:31:36.544]                             sendCondition <<- function(cond) {
[09:31:36.544]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.544]                                 success = TRUE)
[09:31:36.544]                               parallel_sendData(master, data)
[09:31:36.544]                             }
[09:31:36.544]                             return(sendCondition)
[09:31:36.544]                           }
[09:31:36.544]                         }
[09:31:36.544]                         frame <- frame + 1L
[09:31:36.544]                         envir <- sys.frame(frame)
[09:31:36.544]                       }
[09:31:36.544]                     }
[09:31:36.544]                     sendCondition <<- function(cond) NULL
[09:31:36.544]                   }
[09:31:36.544]                 })
[09:31:36.544]                 withCallingHandlers({
[09:31:36.544]                   {
[09:31:36.544]                     b <- a
[09:31:36.544]                     a <- 2
[09:31:36.544]                     a * b
[09:31:36.544]                   }
[09:31:36.544]                 }, immediateCondition = function(cond) {
[09:31:36.544]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.544]                   sendCondition(cond)
[09:31:36.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.544]                   {
[09:31:36.544]                     inherits <- base::inherits
[09:31:36.544]                     invokeRestart <- base::invokeRestart
[09:31:36.544]                     is.null <- base::is.null
[09:31:36.544]                     muffled <- FALSE
[09:31:36.544]                     if (inherits(cond, "message")) {
[09:31:36.544]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.544]                       if (muffled) 
[09:31:36.544]                         invokeRestart("muffleMessage")
[09:31:36.544]                     }
[09:31:36.544]                     else if (inherits(cond, "warning")) {
[09:31:36.544]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.544]                       if (muffled) 
[09:31:36.544]                         invokeRestart("muffleWarning")
[09:31:36.544]                     }
[09:31:36.544]                     else if (inherits(cond, "condition")) {
[09:31:36.544]                       if (!is.null(pattern)) {
[09:31:36.544]                         computeRestarts <- base::computeRestarts
[09:31:36.544]                         grepl <- base::grepl
[09:31:36.544]                         restarts <- computeRestarts(cond)
[09:31:36.544]                         for (restart in restarts) {
[09:31:36.544]                           name <- restart$name
[09:31:36.544]                           if (is.null(name)) 
[09:31:36.544]                             next
[09:31:36.544]                           if (!grepl(pattern, name)) 
[09:31:36.544]                             next
[09:31:36.544]                           invokeRestart(restart)
[09:31:36.544]                           muffled <- TRUE
[09:31:36.544]                           break
[09:31:36.544]                         }
[09:31:36.544]                       }
[09:31:36.544]                     }
[09:31:36.544]                     invisible(muffled)
[09:31:36.544]                   }
[09:31:36.544]                   muffleCondition(cond)
[09:31:36.544]                 })
[09:31:36.544]             }))
[09:31:36.544]             future::FutureResult(value = ...future.value$value, 
[09:31:36.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.544]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.544]                     ...future.globalenv.names))
[09:31:36.544]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.544]         }, condition = base::local({
[09:31:36.544]             c <- base::c
[09:31:36.544]             inherits <- base::inherits
[09:31:36.544]             invokeRestart <- base::invokeRestart
[09:31:36.544]             length <- base::length
[09:31:36.544]             list <- base::list
[09:31:36.544]             seq.int <- base::seq.int
[09:31:36.544]             signalCondition <- base::signalCondition
[09:31:36.544]             sys.calls <- base::sys.calls
[09:31:36.544]             `[[` <- base::`[[`
[09:31:36.544]             `+` <- base::`+`
[09:31:36.544]             `<<-` <- base::`<<-`
[09:31:36.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.544]                   3L)]
[09:31:36.544]             }
[09:31:36.544]             function(cond) {
[09:31:36.544]                 is_error <- inherits(cond, "error")
[09:31:36.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.544]                   NULL)
[09:31:36.544]                 if (is_error) {
[09:31:36.544]                   sessionInformation <- function() {
[09:31:36.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.544]                       search = base::search(), system = base::Sys.info())
[09:31:36.544]                   }
[09:31:36.544]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.544]                     cond$call), session = sessionInformation(), 
[09:31:36.544]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.544]                   signalCondition(cond)
[09:31:36.544]                 }
[09:31:36.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.544]                 "immediateCondition"))) {
[09:31:36.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.544]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.544]                   if (TRUE && !signal) {
[09:31:36.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.544]                     {
[09:31:36.544]                       inherits <- base::inherits
[09:31:36.544]                       invokeRestart <- base::invokeRestart
[09:31:36.544]                       is.null <- base::is.null
[09:31:36.544]                       muffled <- FALSE
[09:31:36.544]                       if (inherits(cond, "message")) {
[09:31:36.544]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.544]                         if (muffled) 
[09:31:36.544]                           invokeRestart("muffleMessage")
[09:31:36.544]                       }
[09:31:36.544]                       else if (inherits(cond, "warning")) {
[09:31:36.544]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.544]                         if (muffled) 
[09:31:36.544]                           invokeRestart("muffleWarning")
[09:31:36.544]                       }
[09:31:36.544]                       else if (inherits(cond, "condition")) {
[09:31:36.544]                         if (!is.null(pattern)) {
[09:31:36.544]                           computeRestarts <- base::computeRestarts
[09:31:36.544]                           grepl <- base::grepl
[09:31:36.544]                           restarts <- computeRestarts(cond)
[09:31:36.544]                           for (restart in restarts) {
[09:31:36.544]                             name <- restart$name
[09:31:36.544]                             if (is.null(name)) 
[09:31:36.544]                               next
[09:31:36.544]                             if (!grepl(pattern, name)) 
[09:31:36.544]                               next
[09:31:36.544]                             invokeRestart(restart)
[09:31:36.544]                             muffled <- TRUE
[09:31:36.544]                             break
[09:31:36.544]                           }
[09:31:36.544]                         }
[09:31:36.544]                       }
[09:31:36.544]                       invisible(muffled)
[09:31:36.544]                     }
[09:31:36.544]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.544]                   }
[09:31:36.544]                 }
[09:31:36.544]                 else {
[09:31:36.544]                   if (TRUE) {
[09:31:36.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.544]                     {
[09:31:36.544]                       inherits <- base::inherits
[09:31:36.544]                       invokeRestart <- base::invokeRestart
[09:31:36.544]                       is.null <- base::is.null
[09:31:36.544]                       muffled <- FALSE
[09:31:36.544]                       if (inherits(cond, "message")) {
[09:31:36.544]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.544]                         if (muffled) 
[09:31:36.544]                           invokeRestart("muffleMessage")
[09:31:36.544]                       }
[09:31:36.544]                       else if (inherits(cond, "warning")) {
[09:31:36.544]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.544]                         if (muffled) 
[09:31:36.544]                           invokeRestart("muffleWarning")
[09:31:36.544]                       }
[09:31:36.544]                       else if (inherits(cond, "condition")) {
[09:31:36.544]                         if (!is.null(pattern)) {
[09:31:36.544]                           computeRestarts <- base::computeRestarts
[09:31:36.544]                           grepl <- base::grepl
[09:31:36.544]                           restarts <- computeRestarts(cond)
[09:31:36.544]                           for (restart in restarts) {
[09:31:36.544]                             name <- restart$name
[09:31:36.544]                             if (is.null(name)) 
[09:31:36.544]                               next
[09:31:36.544]                             if (!grepl(pattern, name)) 
[09:31:36.544]                               next
[09:31:36.544]                             invokeRestart(restart)
[09:31:36.544]                             muffled <- TRUE
[09:31:36.544]                             break
[09:31:36.544]                           }
[09:31:36.544]                         }
[09:31:36.544]                       }
[09:31:36.544]                       invisible(muffled)
[09:31:36.544]                     }
[09:31:36.544]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.544]                   }
[09:31:36.544]                 }
[09:31:36.544]             }
[09:31:36.544]         }))
[09:31:36.544]     }, error = function(ex) {
[09:31:36.544]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.544]                 ...future.rng), started = ...future.startTime, 
[09:31:36.544]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.544]             version = "1.8"), class = "FutureResult")
[09:31:36.544]     }, finally = {
[09:31:36.544]         if (!identical(...future.workdir, getwd())) 
[09:31:36.544]             setwd(...future.workdir)
[09:31:36.544]         {
[09:31:36.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.544]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.544]             }
[09:31:36.544]             base::options(...future.oldOptions)
[09:31:36.544]             if (.Platform$OS.type == "windows") {
[09:31:36.544]                 old_names <- names(...future.oldEnvVars)
[09:31:36.544]                 envs <- base::Sys.getenv()
[09:31:36.544]                 names <- names(envs)
[09:31:36.544]                 common <- intersect(names, old_names)
[09:31:36.544]                 added <- setdiff(names, old_names)
[09:31:36.544]                 removed <- setdiff(old_names, names)
[09:31:36.544]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.544]                   envs[common]]
[09:31:36.544]                 NAMES <- toupper(changed)
[09:31:36.544]                 args <- list()
[09:31:36.544]                 for (kk in seq_along(NAMES)) {
[09:31:36.544]                   name <- changed[[kk]]
[09:31:36.544]                   NAME <- NAMES[[kk]]
[09:31:36.544]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.544]                     next
[09:31:36.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.544]                 }
[09:31:36.544]                 NAMES <- toupper(added)
[09:31:36.544]                 for (kk in seq_along(NAMES)) {
[09:31:36.544]                   name <- added[[kk]]
[09:31:36.544]                   NAME <- NAMES[[kk]]
[09:31:36.544]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.544]                     next
[09:31:36.544]                   args[[name]] <- ""
[09:31:36.544]                 }
[09:31:36.544]                 NAMES <- toupper(removed)
[09:31:36.544]                 for (kk in seq_along(NAMES)) {
[09:31:36.544]                   name <- removed[[kk]]
[09:31:36.544]                   NAME <- NAMES[[kk]]
[09:31:36.544]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.544]                     next
[09:31:36.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.544]                 }
[09:31:36.544]                 if (length(args) > 0) 
[09:31:36.544]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.544]             }
[09:31:36.544]             else {
[09:31:36.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.544]             }
[09:31:36.544]             {
[09:31:36.544]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.544]                   0L) {
[09:31:36.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.544]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.544]                   base::options(opts)
[09:31:36.544]                 }
[09:31:36.544]                 {
[09:31:36.544]                   {
[09:31:36.544]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.544]                     NULL
[09:31:36.544]                   }
[09:31:36.544]                   options(future.plan = NULL)
[09:31:36.544]                   if (is.na(NA_character_)) 
[09:31:36.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.544]                     .init = FALSE)
[09:31:36.544]                 }
[09:31:36.544]             }
[09:31:36.544]         }
[09:31:36.544]     })
[09:31:36.544]     if (TRUE) {
[09:31:36.544]         base::sink(type = "output", split = FALSE)
[09:31:36.544]         if (TRUE) {
[09:31:36.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.544]         }
[09:31:36.544]         else {
[09:31:36.544]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.544]         }
[09:31:36.544]         base::close(...future.stdout)
[09:31:36.544]         ...future.stdout <- NULL
[09:31:36.544]     }
[09:31:36.544]     ...future.result$conditions <- ...future.conditions
[09:31:36.544]     ...future.result$finished <- base::Sys.time()
[09:31:36.544]     ...future.result
[09:31:36.544] }
[09:31:36.546] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:31:36.546] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[09:31:36.547] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.547] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:31:36.547] MultisessionFuture started
[09:31:36.547] - Launch lazy future ... done
[09:31:36.547] run() for ‘MultisessionFuture’ ... done
[09:31:36.547] result() for ClusterFuture ...
[09:31:36.548] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.548] - Validating connection of MultisessionFuture
[09:31:36.589] - received message: FutureResult
[09:31:36.589] - Received FutureResult
[09:31:36.590] - Erased future from FutureRegistry
[09:31:36.590] result() for ClusterFuture ...
[09:31:36.590] - result already collected: FutureResult
[09:31:36.590] result() for ClusterFuture ... done
[09:31:36.590] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.590] result() for ClusterFuture ... done
[09:31:36.590] result() for ClusterFuture ...
[09:31:36.590] - result already collected: FutureResult
[09:31:36.590] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.591] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.591] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.593] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:36.593] Searching for globals ... DONE
[09:31:36.593] Resolving globals: TRUE
[09:31:36.593] Resolving any globals that are futures ...
[09:31:36.593] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[09:31:36.593] Resolving any globals that are futures ... DONE
[09:31:36.594] Resolving futures part of globals (recursively) ...
[09:31:36.594] resolve() on list ...
[09:31:36.594]  recursive: 99
[09:31:36.594]  length: 1
[09:31:36.594]  elements: ‘a’
[09:31:36.594]  length: 0 (resolved future 1)
[09:31:36.594] resolve() on list ... DONE
[09:31:36.594] - globals: [1] ‘a’
[09:31:36.594] Resolving futures part of globals (recursively) ... DONE
[09:31:36.595] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:36.595] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (56 bytes of class ‘numeric’)
[09:31:36.595] - globals: [1] ‘a’
[09:31:36.595] 
[09:31:36.595] getGlobalsAndPackages() ... DONE
[09:31:36.595] run() for ‘Future’ ...
[09:31:36.595] - state: ‘created’
[09:31:36.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.609]   - Field: ‘node’
[09:31:36.609]   - Field: ‘label’
[09:31:36.609]   - Field: ‘local’
[09:31:36.609]   - Field: ‘owner’
[09:31:36.610]   - Field: ‘envir’
[09:31:36.610]   - Field: ‘workers’
[09:31:36.610]   - Field: ‘packages’
[09:31:36.610]   - Field: ‘gc’
[09:31:36.610]   - Field: ‘conditions’
[09:31:36.610]   - Field: ‘persistent’
[09:31:36.610]   - Field: ‘expr’
[09:31:36.610]   - Field: ‘uuid’
[09:31:36.610]   - Field: ‘seed’
[09:31:36.610]   - Field: ‘version’
[09:31:36.610]   - Field: ‘result’
[09:31:36.611]   - Field: ‘asynchronous’
[09:31:36.611]   - Field: ‘calls’
[09:31:36.611]   - Field: ‘globals’
[09:31:36.611]   - Field: ‘stdout’
[09:31:36.611]   - Field: ‘earlySignal’
[09:31:36.611]   - Field: ‘lazy’
[09:31:36.611]   - Field: ‘state’
[09:31:36.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.611] - Launch lazy future ...
[09:31:36.611] Packages needed by the future expression (n = 0): <none>
[09:31:36.612] Packages needed by future strategies (n = 0): <none>
[09:31:36.612] {
[09:31:36.612]     {
[09:31:36.612]         {
[09:31:36.612]             ...future.startTime <- base::Sys.time()
[09:31:36.612]             {
[09:31:36.612]                 {
[09:31:36.612]                   {
[09:31:36.612]                     {
[09:31:36.612]                       base::local({
[09:31:36.612]                         has_future <- base::requireNamespace("future", 
[09:31:36.612]                           quietly = TRUE)
[09:31:36.612]                         if (has_future) {
[09:31:36.612]                           ns <- base::getNamespace("future")
[09:31:36.612]                           version <- ns[[".package"]][["version"]]
[09:31:36.612]                           if (is.null(version)) 
[09:31:36.612]                             version <- utils::packageVersion("future")
[09:31:36.612]                         }
[09:31:36.612]                         else {
[09:31:36.612]                           version <- NULL
[09:31:36.612]                         }
[09:31:36.612]                         if (!has_future || version < "1.8.0") {
[09:31:36.612]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.612]                             "", base::R.version$version.string), 
[09:31:36.612]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.612]                               "release", "version")], collapse = " "), 
[09:31:36.612]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.612]                             info)
[09:31:36.612]                           info <- base::paste(info, collapse = "; ")
[09:31:36.612]                           if (!has_future) {
[09:31:36.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.612]                               info)
[09:31:36.612]                           }
[09:31:36.612]                           else {
[09:31:36.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.612]                               info, version)
[09:31:36.612]                           }
[09:31:36.612]                           base::stop(msg)
[09:31:36.612]                         }
[09:31:36.612]                       })
[09:31:36.612]                     }
[09:31:36.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.612]                     base::options(mc.cores = 1L)
[09:31:36.612]                   }
[09:31:36.612]                   ...future.strategy.old <- future::plan("list")
[09:31:36.612]                   options(future.plan = NULL)
[09:31:36.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.612]                 }
[09:31:36.612]                 ...future.workdir <- getwd()
[09:31:36.612]             }
[09:31:36.612]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.612]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.612]         }
[09:31:36.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.612]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.612]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.612]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.612]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.612]             base::names(...future.oldOptions))
[09:31:36.612]     }
[09:31:36.612]     if (FALSE) {
[09:31:36.612]     }
[09:31:36.612]     else {
[09:31:36.612]         if (TRUE) {
[09:31:36.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.612]                 open = "w")
[09:31:36.612]         }
[09:31:36.612]         else {
[09:31:36.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.612]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.612]         }
[09:31:36.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.612]             base::sink(type = "output", split = FALSE)
[09:31:36.612]             base::close(...future.stdout)
[09:31:36.612]         }, add = TRUE)
[09:31:36.612]     }
[09:31:36.612]     ...future.frame <- base::sys.nframe()
[09:31:36.612]     ...future.conditions <- base::list()
[09:31:36.612]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.612]     if (FALSE) {
[09:31:36.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.612]     }
[09:31:36.612]     ...future.result <- base::tryCatch({
[09:31:36.612]         base::withCallingHandlers({
[09:31:36.612]             ...future.value <- base::withVisible(base::local({
[09:31:36.612]                 ...future.makeSendCondition <- base::local({
[09:31:36.612]                   sendCondition <- NULL
[09:31:36.612]                   function(frame = 1L) {
[09:31:36.612]                     if (is.function(sendCondition)) 
[09:31:36.612]                       return(sendCondition)
[09:31:36.612]                     ns <- getNamespace("parallel")
[09:31:36.612]                     if (exists("sendData", mode = "function", 
[09:31:36.612]                       envir = ns)) {
[09:31:36.612]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.612]                         envir = ns)
[09:31:36.612]                       envir <- sys.frame(frame)
[09:31:36.612]                       master <- NULL
[09:31:36.612]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.612]                         !identical(envir, emptyenv())) {
[09:31:36.612]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.612]                           inherits = FALSE)) {
[09:31:36.612]                           master <- get("master", mode = "list", 
[09:31:36.612]                             envir = envir, inherits = FALSE)
[09:31:36.612]                           if (inherits(master, c("SOCKnode", 
[09:31:36.612]                             "SOCK0node"))) {
[09:31:36.612]                             sendCondition <<- function(cond) {
[09:31:36.612]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.612]                                 success = TRUE)
[09:31:36.612]                               parallel_sendData(master, data)
[09:31:36.612]                             }
[09:31:36.612]                             return(sendCondition)
[09:31:36.612]                           }
[09:31:36.612]                         }
[09:31:36.612]                         frame <- frame + 1L
[09:31:36.612]                         envir <- sys.frame(frame)
[09:31:36.612]                       }
[09:31:36.612]                     }
[09:31:36.612]                     sendCondition <<- function(cond) NULL
[09:31:36.612]                   }
[09:31:36.612]                 })
[09:31:36.612]                 withCallingHandlers({
[09:31:36.612]                   {
[09:31:36.612]                     b <- a
[09:31:36.612]                     a <- 2
[09:31:36.612]                     a * b
[09:31:36.612]                   }
[09:31:36.612]                 }, immediateCondition = function(cond) {
[09:31:36.612]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.612]                   sendCondition(cond)
[09:31:36.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.612]                   {
[09:31:36.612]                     inherits <- base::inherits
[09:31:36.612]                     invokeRestart <- base::invokeRestart
[09:31:36.612]                     is.null <- base::is.null
[09:31:36.612]                     muffled <- FALSE
[09:31:36.612]                     if (inherits(cond, "message")) {
[09:31:36.612]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.612]                       if (muffled) 
[09:31:36.612]                         invokeRestart("muffleMessage")
[09:31:36.612]                     }
[09:31:36.612]                     else if (inherits(cond, "warning")) {
[09:31:36.612]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.612]                       if (muffled) 
[09:31:36.612]                         invokeRestart("muffleWarning")
[09:31:36.612]                     }
[09:31:36.612]                     else if (inherits(cond, "condition")) {
[09:31:36.612]                       if (!is.null(pattern)) {
[09:31:36.612]                         computeRestarts <- base::computeRestarts
[09:31:36.612]                         grepl <- base::grepl
[09:31:36.612]                         restarts <- computeRestarts(cond)
[09:31:36.612]                         for (restart in restarts) {
[09:31:36.612]                           name <- restart$name
[09:31:36.612]                           if (is.null(name)) 
[09:31:36.612]                             next
[09:31:36.612]                           if (!grepl(pattern, name)) 
[09:31:36.612]                             next
[09:31:36.612]                           invokeRestart(restart)
[09:31:36.612]                           muffled <- TRUE
[09:31:36.612]                           break
[09:31:36.612]                         }
[09:31:36.612]                       }
[09:31:36.612]                     }
[09:31:36.612]                     invisible(muffled)
[09:31:36.612]                   }
[09:31:36.612]                   muffleCondition(cond)
[09:31:36.612]                 })
[09:31:36.612]             }))
[09:31:36.612]             future::FutureResult(value = ...future.value$value, 
[09:31:36.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.612]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.612]                     ...future.globalenv.names))
[09:31:36.612]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.612]         }, condition = base::local({
[09:31:36.612]             c <- base::c
[09:31:36.612]             inherits <- base::inherits
[09:31:36.612]             invokeRestart <- base::invokeRestart
[09:31:36.612]             length <- base::length
[09:31:36.612]             list <- base::list
[09:31:36.612]             seq.int <- base::seq.int
[09:31:36.612]             signalCondition <- base::signalCondition
[09:31:36.612]             sys.calls <- base::sys.calls
[09:31:36.612]             `[[` <- base::`[[`
[09:31:36.612]             `+` <- base::`+`
[09:31:36.612]             `<<-` <- base::`<<-`
[09:31:36.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.612]                   3L)]
[09:31:36.612]             }
[09:31:36.612]             function(cond) {
[09:31:36.612]                 is_error <- inherits(cond, "error")
[09:31:36.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.612]                   NULL)
[09:31:36.612]                 if (is_error) {
[09:31:36.612]                   sessionInformation <- function() {
[09:31:36.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.612]                       search = base::search(), system = base::Sys.info())
[09:31:36.612]                   }
[09:31:36.612]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.612]                     cond$call), session = sessionInformation(), 
[09:31:36.612]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.612]                   signalCondition(cond)
[09:31:36.612]                 }
[09:31:36.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.612]                 "immediateCondition"))) {
[09:31:36.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.612]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.612]                   if (TRUE && !signal) {
[09:31:36.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.612]                     {
[09:31:36.612]                       inherits <- base::inherits
[09:31:36.612]                       invokeRestart <- base::invokeRestart
[09:31:36.612]                       is.null <- base::is.null
[09:31:36.612]                       muffled <- FALSE
[09:31:36.612]                       if (inherits(cond, "message")) {
[09:31:36.612]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.612]                         if (muffled) 
[09:31:36.612]                           invokeRestart("muffleMessage")
[09:31:36.612]                       }
[09:31:36.612]                       else if (inherits(cond, "warning")) {
[09:31:36.612]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.612]                         if (muffled) 
[09:31:36.612]                           invokeRestart("muffleWarning")
[09:31:36.612]                       }
[09:31:36.612]                       else if (inherits(cond, "condition")) {
[09:31:36.612]                         if (!is.null(pattern)) {
[09:31:36.612]                           computeRestarts <- base::computeRestarts
[09:31:36.612]                           grepl <- base::grepl
[09:31:36.612]                           restarts <- computeRestarts(cond)
[09:31:36.612]                           for (restart in restarts) {
[09:31:36.612]                             name <- restart$name
[09:31:36.612]                             if (is.null(name)) 
[09:31:36.612]                               next
[09:31:36.612]                             if (!grepl(pattern, name)) 
[09:31:36.612]                               next
[09:31:36.612]                             invokeRestart(restart)
[09:31:36.612]                             muffled <- TRUE
[09:31:36.612]                             break
[09:31:36.612]                           }
[09:31:36.612]                         }
[09:31:36.612]                       }
[09:31:36.612]                       invisible(muffled)
[09:31:36.612]                     }
[09:31:36.612]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.612]                   }
[09:31:36.612]                 }
[09:31:36.612]                 else {
[09:31:36.612]                   if (TRUE) {
[09:31:36.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.612]                     {
[09:31:36.612]                       inherits <- base::inherits
[09:31:36.612]                       invokeRestart <- base::invokeRestart
[09:31:36.612]                       is.null <- base::is.null
[09:31:36.612]                       muffled <- FALSE
[09:31:36.612]                       if (inherits(cond, "message")) {
[09:31:36.612]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.612]                         if (muffled) 
[09:31:36.612]                           invokeRestart("muffleMessage")
[09:31:36.612]                       }
[09:31:36.612]                       else if (inherits(cond, "warning")) {
[09:31:36.612]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.612]                         if (muffled) 
[09:31:36.612]                           invokeRestart("muffleWarning")
[09:31:36.612]                       }
[09:31:36.612]                       else if (inherits(cond, "condition")) {
[09:31:36.612]                         if (!is.null(pattern)) {
[09:31:36.612]                           computeRestarts <- base::computeRestarts
[09:31:36.612]                           grepl <- base::grepl
[09:31:36.612]                           restarts <- computeRestarts(cond)
[09:31:36.612]                           for (restart in restarts) {
[09:31:36.612]                             name <- restart$name
[09:31:36.612]                             if (is.null(name)) 
[09:31:36.612]                               next
[09:31:36.612]                             if (!grepl(pattern, name)) 
[09:31:36.612]                               next
[09:31:36.612]                             invokeRestart(restart)
[09:31:36.612]                             muffled <- TRUE
[09:31:36.612]                             break
[09:31:36.612]                           }
[09:31:36.612]                         }
[09:31:36.612]                       }
[09:31:36.612]                       invisible(muffled)
[09:31:36.612]                     }
[09:31:36.612]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.612]                   }
[09:31:36.612]                 }
[09:31:36.612]             }
[09:31:36.612]         }))
[09:31:36.612]     }, error = function(ex) {
[09:31:36.612]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.612]                 ...future.rng), started = ...future.startTime, 
[09:31:36.612]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.612]             version = "1.8"), class = "FutureResult")
[09:31:36.612]     }, finally = {
[09:31:36.612]         if (!identical(...future.workdir, getwd())) 
[09:31:36.612]             setwd(...future.workdir)
[09:31:36.612]         {
[09:31:36.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.612]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.612]             }
[09:31:36.612]             base::options(...future.oldOptions)
[09:31:36.612]             if (.Platform$OS.type == "windows") {
[09:31:36.612]                 old_names <- names(...future.oldEnvVars)
[09:31:36.612]                 envs <- base::Sys.getenv()
[09:31:36.612]                 names <- names(envs)
[09:31:36.612]                 common <- intersect(names, old_names)
[09:31:36.612]                 added <- setdiff(names, old_names)
[09:31:36.612]                 removed <- setdiff(old_names, names)
[09:31:36.612]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.612]                   envs[common]]
[09:31:36.612]                 NAMES <- toupper(changed)
[09:31:36.612]                 args <- list()
[09:31:36.612]                 for (kk in seq_along(NAMES)) {
[09:31:36.612]                   name <- changed[[kk]]
[09:31:36.612]                   NAME <- NAMES[[kk]]
[09:31:36.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.612]                     next
[09:31:36.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.612]                 }
[09:31:36.612]                 NAMES <- toupper(added)
[09:31:36.612]                 for (kk in seq_along(NAMES)) {
[09:31:36.612]                   name <- added[[kk]]
[09:31:36.612]                   NAME <- NAMES[[kk]]
[09:31:36.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.612]                     next
[09:31:36.612]                   args[[name]] <- ""
[09:31:36.612]                 }
[09:31:36.612]                 NAMES <- toupper(removed)
[09:31:36.612]                 for (kk in seq_along(NAMES)) {
[09:31:36.612]                   name <- removed[[kk]]
[09:31:36.612]                   NAME <- NAMES[[kk]]
[09:31:36.612]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.612]                     next
[09:31:36.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.612]                 }
[09:31:36.612]                 if (length(args) > 0) 
[09:31:36.612]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.612]             }
[09:31:36.612]             else {
[09:31:36.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.612]             }
[09:31:36.612]             {
[09:31:36.612]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.612]                   0L) {
[09:31:36.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.612]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.612]                   base::options(opts)
[09:31:36.612]                 }
[09:31:36.612]                 {
[09:31:36.612]                   {
[09:31:36.612]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.612]                     NULL
[09:31:36.612]                   }
[09:31:36.612]                   options(future.plan = NULL)
[09:31:36.612]                   if (is.na(NA_character_)) 
[09:31:36.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.612]                     .init = FALSE)
[09:31:36.612]                 }
[09:31:36.612]             }
[09:31:36.612]         }
[09:31:36.612]     })
[09:31:36.612]     if (TRUE) {
[09:31:36.612]         base::sink(type = "output", split = FALSE)
[09:31:36.612]         if (TRUE) {
[09:31:36.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.612]         }
[09:31:36.612]         else {
[09:31:36.612]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.612]         }
[09:31:36.612]         base::close(...future.stdout)
[09:31:36.612]         ...future.stdout <- NULL
[09:31:36.612]     }
[09:31:36.612]     ...future.result$conditions <- ...future.conditions
[09:31:36.612]     ...future.result$finished <- base::Sys.time()
[09:31:36.612]     ...future.result
[09:31:36.612] }
[09:31:36.614] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:31:36.615] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[09:31:36.615] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.615] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:31:36.615] MultisessionFuture started
[09:31:36.616] - Launch lazy future ... done
[09:31:36.616] run() for ‘MultisessionFuture’ ... done
[09:31:36.616] result() for ClusterFuture ...
[09:31:36.616] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.616] - Validating connection of MultisessionFuture
[09:31:36.657] - received message: FutureResult
[09:31:36.657] - Received FutureResult
[09:31:36.658] - Erased future from FutureRegistry
[09:31:36.658] result() for ClusterFuture ...
[09:31:36.658] - result already collected: FutureResult
[09:31:36.658] result() for ClusterFuture ... done
[09:31:36.658] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.658] result() for ClusterFuture ... done
[09:31:36.658] result() for ClusterFuture ...
[09:31:36.658] - result already collected: FutureResult
[09:31:36.658] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.659] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.659] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.661] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.661] Searching for globals ... DONE
[09:31:36.661] Resolving globals: TRUE
[09:31:36.661] Resolving any globals that are futures ...
[09:31:36.661] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.661] Resolving any globals that are futures ... DONE
[09:31:36.662] Resolving futures part of globals (recursively) ...
[09:31:36.662] resolve() on list ...
[09:31:36.662]  recursive: 99
[09:31:36.662]  length: 2
[09:31:36.662]  elements: ‘a’, ‘ii’
[09:31:36.662]  length: 1 (resolved future 1)
[09:31:36.663]  length: 0 (resolved future 2)
[09:31:36.663] resolve() on list ... DONE
[09:31:36.663] - globals: [2] ‘a’, ‘ii’
[09:31:36.663] Resolving futures part of globals (recursively) ... DONE
[09:31:36.663] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.663] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.663] - globals: [2] ‘a’, ‘ii’
[09:31:36.664] 
[09:31:36.664] getGlobalsAndPackages() ... DONE
[09:31:36.664] run() for ‘Future’ ...
[09:31:36.664] - state: ‘created’
[09:31:36.664] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.678]   - Field: ‘node’
[09:31:36.678]   - Field: ‘label’
[09:31:36.678]   - Field: ‘local’
[09:31:36.678]   - Field: ‘owner’
[09:31:36.678]   - Field: ‘envir’
[09:31:36.678]   - Field: ‘workers’
[09:31:36.678]   - Field: ‘packages’
[09:31:36.678]   - Field: ‘gc’
[09:31:36.678]   - Field: ‘conditions’
[09:31:36.678]   - Field: ‘persistent’
[09:31:36.678]   - Field: ‘expr’
[09:31:36.679]   - Field: ‘uuid’
[09:31:36.679]   - Field: ‘seed’
[09:31:36.679]   - Field: ‘version’
[09:31:36.679]   - Field: ‘result’
[09:31:36.679]   - Field: ‘asynchronous’
[09:31:36.681]   - Field: ‘calls’
[09:31:36.681]   - Field: ‘globals’
[09:31:36.681]   - Field: ‘stdout’
[09:31:36.681]   - Field: ‘earlySignal’
[09:31:36.681]   - Field: ‘lazy’
[09:31:36.681]   - Field: ‘state’
[09:31:36.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.682] - Launch lazy future ...
[09:31:36.682] Packages needed by the future expression (n = 0): <none>
[09:31:36.682] Packages needed by future strategies (n = 0): <none>
[09:31:36.682] {
[09:31:36.682]     {
[09:31:36.682]         {
[09:31:36.682]             ...future.startTime <- base::Sys.time()
[09:31:36.682]             {
[09:31:36.682]                 {
[09:31:36.682]                   {
[09:31:36.682]                     {
[09:31:36.682]                       base::local({
[09:31:36.682]                         has_future <- base::requireNamespace("future", 
[09:31:36.682]                           quietly = TRUE)
[09:31:36.682]                         if (has_future) {
[09:31:36.682]                           ns <- base::getNamespace("future")
[09:31:36.682]                           version <- ns[[".package"]][["version"]]
[09:31:36.682]                           if (is.null(version)) 
[09:31:36.682]                             version <- utils::packageVersion("future")
[09:31:36.682]                         }
[09:31:36.682]                         else {
[09:31:36.682]                           version <- NULL
[09:31:36.682]                         }
[09:31:36.682]                         if (!has_future || version < "1.8.0") {
[09:31:36.682]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.682]                             "", base::R.version$version.string), 
[09:31:36.682]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.682]                               "release", "version")], collapse = " "), 
[09:31:36.682]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.682]                             info)
[09:31:36.682]                           info <- base::paste(info, collapse = "; ")
[09:31:36.682]                           if (!has_future) {
[09:31:36.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.682]                               info)
[09:31:36.682]                           }
[09:31:36.682]                           else {
[09:31:36.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.682]                               info, version)
[09:31:36.682]                           }
[09:31:36.682]                           base::stop(msg)
[09:31:36.682]                         }
[09:31:36.682]                       })
[09:31:36.682]                     }
[09:31:36.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.682]                     base::options(mc.cores = 1L)
[09:31:36.682]                   }
[09:31:36.682]                   ...future.strategy.old <- future::plan("list")
[09:31:36.682]                   options(future.plan = NULL)
[09:31:36.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.682]                 }
[09:31:36.682]                 ...future.workdir <- getwd()
[09:31:36.682]             }
[09:31:36.682]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.682]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.682]         }
[09:31:36.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.682]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.682]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.682]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.682]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.682]             base::names(...future.oldOptions))
[09:31:36.682]     }
[09:31:36.682]     if (FALSE) {
[09:31:36.682]     }
[09:31:36.682]     else {
[09:31:36.682]         if (TRUE) {
[09:31:36.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.682]                 open = "w")
[09:31:36.682]         }
[09:31:36.682]         else {
[09:31:36.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.682]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.682]         }
[09:31:36.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.682]             base::sink(type = "output", split = FALSE)
[09:31:36.682]             base::close(...future.stdout)
[09:31:36.682]         }, add = TRUE)
[09:31:36.682]     }
[09:31:36.682]     ...future.frame <- base::sys.nframe()
[09:31:36.682]     ...future.conditions <- base::list()
[09:31:36.682]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.682]     if (FALSE) {
[09:31:36.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.682]     }
[09:31:36.682]     ...future.result <- base::tryCatch({
[09:31:36.682]         base::withCallingHandlers({
[09:31:36.682]             ...future.value <- base::withVisible(base::local({
[09:31:36.682]                 ...future.makeSendCondition <- base::local({
[09:31:36.682]                   sendCondition <- NULL
[09:31:36.682]                   function(frame = 1L) {
[09:31:36.682]                     if (is.function(sendCondition)) 
[09:31:36.682]                       return(sendCondition)
[09:31:36.682]                     ns <- getNamespace("parallel")
[09:31:36.682]                     if (exists("sendData", mode = "function", 
[09:31:36.682]                       envir = ns)) {
[09:31:36.682]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.682]                         envir = ns)
[09:31:36.682]                       envir <- sys.frame(frame)
[09:31:36.682]                       master <- NULL
[09:31:36.682]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.682]                         !identical(envir, emptyenv())) {
[09:31:36.682]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.682]                           inherits = FALSE)) {
[09:31:36.682]                           master <- get("master", mode = "list", 
[09:31:36.682]                             envir = envir, inherits = FALSE)
[09:31:36.682]                           if (inherits(master, c("SOCKnode", 
[09:31:36.682]                             "SOCK0node"))) {
[09:31:36.682]                             sendCondition <<- function(cond) {
[09:31:36.682]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.682]                                 success = TRUE)
[09:31:36.682]                               parallel_sendData(master, data)
[09:31:36.682]                             }
[09:31:36.682]                             return(sendCondition)
[09:31:36.682]                           }
[09:31:36.682]                         }
[09:31:36.682]                         frame <- frame + 1L
[09:31:36.682]                         envir <- sys.frame(frame)
[09:31:36.682]                       }
[09:31:36.682]                     }
[09:31:36.682]                     sendCondition <<- function(cond) NULL
[09:31:36.682]                   }
[09:31:36.682]                 })
[09:31:36.682]                 withCallingHandlers({
[09:31:36.682]                   {
[09:31:36.682]                     b <- a * ii
[09:31:36.682]                     a <- 0
[09:31:36.682]                     b
[09:31:36.682]                   }
[09:31:36.682]                 }, immediateCondition = function(cond) {
[09:31:36.682]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.682]                   sendCondition(cond)
[09:31:36.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.682]                   {
[09:31:36.682]                     inherits <- base::inherits
[09:31:36.682]                     invokeRestart <- base::invokeRestart
[09:31:36.682]                     is.null <- base::is.null
[09:31:36.682]                     muffled <- FALSE
[09:31:36.682]                     if (inherits(cond, "message")) {
[09:31:36.682]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.682]                       if (muffled) 
[09:31:36.682]                         invokeRestart("muffleMessage")
[09:31:36.682]                     }
[09:31:36.682]                     else if (inherits(cond, "warning")) {
[09:31:36.682]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.682]                       if (muffled) 
[09:31:36.682]                         invokeRestart("muffleWarning")
[09:31:36.682]                     }
[09:31:36.682]                     else if (inherits(cond, "condition")) {
[09:31:36.682]                       if (!is.null(pattern)) {
[09:31:36.682]                         computeRestarts <- base::computeRestarts
[09:31:36.682]                         grepl <- base::grepl
[09:31:36.682]                         restarts <- computeRestarts(cond)
[09:31:36.682]                         for (restart in restarts) {
[09:31:36.682]                           name <- restart$name
[09:31:36.682]                           if (is.null(name)) 
[09:31:36.682]                             next
[09:31:36.682]                           if (!grepl(pattern, name)) 
[09:31:36.682]                             next
[09:31:36.682]                           invokeRestart(restart)
[09:31:36.682]                           muffled <- TRUE
[09:31:36.682]                           break
[09:31:36.682]                         }
[09:31:36.682]                       }
[09:31:36.682]                     }
[09:31:36.682]                     invisible(muffled)
[09:31:36.682]                   }
[09:31:36.682]                   muffleCondition(cond)
[09:31:36.682]                 })
[09:31:36.682]             }))
[09:31:36.682]             future::FutureResult(value = ...future.value$value, 
[09:31:36.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.682]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.682]                     ...future.globalenv.names))
[09:31:36.682]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.682]         }, condition = base::local({
[09:31:36.682]             c <- base::c
[09:31:36.682]             inherits <- base::inherits
[09:31:36.682]             invokeRestart <- base::invokeRestart
[09:31:36.682]             length <- base::length
[09:31:36.682]             list <- base::list
[09:31:36.682]             seq.int <- base::seq.int
[09:31:36.682]             signalCondition <- base::signalCondition
[09:31:36.682]             sys.calls <- base::sys.calls
[09:31:36.682]             `[[` <- base::`[[`
[09:31:36.682]             `+` <- base::`+`
[09:31:36.682]             `<<-` <- base::`<<-`
[09:31:36.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.682]                   3L)]
[09:31:36.682]             }
[09:31:36.682]             function(cond) {
[09:31:36.682]                 is_error <- inherits(cond, "error")
[09:31:36.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.682]                   NULL)
[09:31:36.682]                 if (is_error) {
[09:31:36.682]                   sessionInformation <- function() {
[09:31:36.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.682]                       search = base::search(), system = base::Sys.info())
[09:31:36.682]                   }
[09:31:36.682]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.682]                     cond$call), session = sessionInformation(), 
[09:31:36.682]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.682]                   signalCondition(cond)
[09:31:36.682]                 }
[09:31:36.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.682]                 "immediateCondition"))) {
[09:31:36.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.682]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.682]                   if (TRUE && !signal) {
[09:31:36.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.682]                     {
[09:31:36.682]                       inherits <- base::inherits
[09:31:36.682]                       invokeRestart <- base::invokeRestart
[09:31:36.682]                       is.null <- base::is.null
[09:31:36.682]                       muffled <- FALSE
[09:31:36.682]                       if (inherits(cond, "message")) {
[09:31:36.682]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.682]                         if (muffled) 
[09:31:36.682]                           invokeRestart("muffleMessage")
[09:31:36.682]                       }
[09:31:36.682]                       else if (inherits(cond, "warning")) {
[09:31:36.682]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.682]                         if (muffled) 
[09:31:36.682]                           invokeRestart("muffleWarning")
[09:31:36.682]                       }
[09:31:36.682]                       else if (inherits(cond, "condition")) {
[09:31:36.682]                         if (!is.null(pattern)) {
[09:31:36.682]                           computeRestarts <- base::computeRestarts
[09:31:36.682]                           grepl <- base::grepl
[09:31:36.682]                           restarts <- computeRestarts(cond)
[09:31:36.682]                           for (restart in restarts) {
[09:31:36.682]                             name <- restart$name
[09:31:36.682]                             if (is.null(name)) 
[09:31:36.682]                               next
[09:31:36.682]                             if (!grepl(pattern, name)) 
[09:31:36.682]                               next
[09:31:36.682]                             invokeRestart(restart)
[09:31:36.682]                             muffled <- TRUE
[09:31:36.682]                             break
[09:31:36.682]                           }
[09:31:36.682]                         }
[09:31:36.682]                       }
[09:31:36.682]                       invisible(muffled)
[09:31:36.682]                     }
[09:31:36.682]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.682]                   }
[09:31:36.682]                 }
[09:31:36.682]                 else {
[09:31:36.682]                   if (TRUE) {
[09:31:36.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.682]                     {
[09:31:36.682]                       inherits <- base::inherits
[09:31:36.682]                       invokeRestart <- base::invokeRestart
[09:31:36.682]                       is.null <- base::is.null
[09:31:36.682]                       muffled <- FALSE
[09:31:36.682]                       if (inherits(cond, "message")) {
[09:31:36.682]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.682]                         if (muffled) 
[09:31:36.682]                           invokeRestart("muffleMessage")
[09:31:36.682]                       }
[09:31:36.682]                       else if (inherits(cond, "warning")) {
[09:31:36.682]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.682]                         if (muffled) 
[09:31:36.682]                           invokeRestart("muffleWarning")
[09:31:36.682]                       }
[09:31:36.682]                       else if (inherits(cond, "condition")) {
[09:31:36.682]                         if (!is.null(pattern)) {
[09:31:36.682]                           computeRestarts <- base::computeRestarts
[09:31:36.682]                           grepl <- base::grepl
[09:31:36.682]                           restarts <- computeRestarts(cond)
[09:31:36.682]                           for (restart in restarts) {
[09:31:36.682]                             name <- restart$name
[09:31:36.682]                             if (is.null(name)) 
[09:31:36.682]                               next
[09:31:36.682]                             if (!grepl(pattern, name)) 
[09:31:36.682]                               next
[09:31:36.682]                             invokeRestart(restart)
[09:31:36.682]                             muffled <- TRUE
[09:31:36.682]                             break
[09:31:36.682]                           }
[09:31:36.682]                         }
[09:31:36.682]                       }
[09:31:36.682]                       invisible(muffled)
[09:31:36.682]                     }
[09:31:36.682]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.682]                   }
[09:31:36.682]                 }
[09:31:36.682]             }
[09:31:36.682]         }))
[09:31:36.682]     }, error = function(ex) {
[09:31:36.682]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.682]                 ...future.rng), started = ...future.startTime, 
[09:31:36.682]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.682]             version = "1.8"), class = "FutureResult")
[09:31:36.682]     }, finally = {
[09:31:36.682]         if (!identical(...future.workdir, getwd())) 
[09:31:36.682]             setwd(...future.workdir)
[09:31:36.682]         {
[09:31:36.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.682]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.682]             }
[09:31:36.682]             base::options(...future.oldOptions)
[09:31:36.682]             if (.Platform$OS.type == "windows") {
[09:31:36.682]                 old_names <- names(...future.oldEnvVars)
[09:31:36.682]                 envs <- base::Sys.getenv()
[09:31:36.682]                 names <- names(envs)
[09:31:36.682]                 common <- intersect(names, old_names)
[09:31:36.682]                 added <- setdiff(names, old_names)
[09:31:36.682]                 removed <- setdiff(old_names, names)
[09:31:36.682]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.682]                   envs[common]]
[09:31:36.682]                 NAMES <- toupper(changed)
[09:31:36.682]                 args <- list()
[09:31:36.682]                 for (kk in seq_along(NAMES)) {
[09:31:36.682]                   name <- changed[[kk]]
[09:31:36.682]                   NAME <- NAMES[[kk]]
[09:31:36.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.682]                     next
[09:31:36.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.682]                 }
[09:31:36.682]                 NAMES <- toupper(added)
[09:31:36.682]                 for (kk in seq_along(NAMES)) {
[09:31:36.682]                   name <- added[[kk]]
[09:31:36.682]                   NAME <- NAMES[[kk]]
[09:31:36.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.682]                     next
[09:31:36.682]                   args[[name]] <- ""
[09:31:36.682]                 }
[09:31:36.682]                 NAMES <- toupper(removed)
[09:31:36.682]                 for (kk in seq_along(NAMES)) {
[09:31:36.682]                   name <- removed[[kk]]
[09:31:36.682]                   NAME <- NAMES[[kk]]
[09:31:36.682]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.682]                     next
[09:31:36.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.682]                 }
[09:31:36.682]                 if (length(args) > 0) 
[09:31:36.682]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.682]             }
[09:31:36.682]             else {
[09:31:36.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.682]             }
[09:31:36.682]             {
[09:31:36.682]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.682]                   0L) {
[09:31:36.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.682]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.682]                   base::options(opts)
[09:31:36.682]                 }
[09:31:36.682]                 {
[09:31:36.682]                   {
[09:31:36.682]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.682]                     NULL
[09:31:36.682]                   }
[09:31:36.682]                   options(future.plan = NULL)
[09:31:36.682]                   if (is.na(NA_character_)) 
[09:31:36.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.682]                     .init = FALSE)
[09:31:36.682]                 }
[09:31:36.682]             }
[09:31:36.682]         }
[09:31:36.682]     })
[09:31:36.682]     if (TRUE) {
[09:31:36.682]         base::sink(type = "output", split = FALSE)
[09:31:36.682]         if (TRUE) {
[09:31:36.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.682]         }
[09:31:36.682]         else {
[09:31:36.682]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.682]         }
[09:31:36.682]         base::close(...future.stdout)
[09:31:36.682]         ...future.stdout <- NULL
[09:31:36.682]     }
[09:31:36.682]     ...future.result$conditions <- ...future.conditions
[09:31:36.682]     ...future.result$finished <- base::Sys.time()
[09:31:36.682]     ...future.result
[09:31:36.682] }
[09:31:36.685] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[09:31:36.685] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[09:31:36.685] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.685] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[09:31:36.686] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.686] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[09:31:36.686] MultisessionFuture started
[09:31:36.686] - Launch lazy future ... done
[09:31:36.686] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.687] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.687] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.689] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.689] Searching for globals ... DONE
[09:31:36.689] Resolving globals: TRUE
[09:31:36.689] Resolving any globals that are futures ...
[09:31:36.689] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.689] Resolving any globals that are futures ... DONE
[09:31:36.690] Resolving futures part of globals (recursively) ...
[09:31:36.690] resolve() on list ...
[09:31:36.690]  recursive: 99
[09:31:36.690]  length: 2
[09:31:36.690]  elements: ‘a’, ‘ii’
[09:31:36.690]  length: 1 (resolved future 1)
[09:31:36.690]  length: 0 (resolved future 2)
[09:31:36.690] resolve() on list ... DONE
[09:31:36.690] - globals: [2] ‘a’, ‘ii’
[09:31:36.690] Resolving futures part of globals (recursively) ... DONE
[09:31:36.691] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.691] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.691] - globals: [2] ‘a’, ‘ii’
[09:31:36.691] 
[09:31:36.691] getGlobalsAndPackages() ... DONE
[09:31:36.691] run() for ‘Future’ ...
[09:31:36.692] - state: ‘created’
[09:31:36.692] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.705] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.705]   - Field: ‘node’
[09:31:36.705]   - Field: ‘label’
[09:31:36.705]   - Field: ‘local’
[09:31:36.705]   - Field: ‘owner’
[09:31:36.705]   - Field: ‘envir’
[09:31:36.706]   - Field: ‘workers’
[09:31:36.706]   - Field: ‘packages’
[09:31:36.706]   - Field: ‘gc’
[09:31:36.706]   - Field: ‘conditions’
[09:31:36.706]   - Field: ‘persistent’
[09:31:36.706]   - Field: ‘expr’
[09:31:36.706]   - Field: ‘uuid’
[09:31:36.706]   - Field: ‘seed’
[09:31:36.706]   - Field: ‘version’
[09:31:36.706]   - Field: ‘result’
[09:31:36.706]   - Field: ‘asynchronous’
[09:31:36.706]   - Field: ‘calls’
[09:31:36.707]   - Field: ‘globals’
[09:31:36.707]   - Field: ‘stdout’
[09:31:36.707]   - Field: ‘earlySignal’
[09:31:36.707]   - Field: ‘lazy’
[09:31:36.707]   - Field: ‘state’
[09:31:36.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.707] - Launch lazy future ...
[09:31:36.707] Packages needed by the future expression (n = 0): <none>
[09:31:36.707] Packages needed by future strategies (n = 0): <none>
[09:31:36.708] {
[09:31:36.708]     {
[09:31:36.708]         {
[09:31:36.708]             ...future.startTime <- base::Sys.time()
[09:31:36.708]             {
[09:31:36.708]                 {
[09:31:36.708]                   {
[09:31:36.708]                     {
[09:31:36.708]                       base::local({
[09:31:36.708]                         has_future <- base::requireNamespace("future", 
[09:31:36.708]                           quietly = TRUE)
[09:31:36.708]                         if (has_future) {
[09:31:36.708]                           ns <- base::getNamespace("future")
[09:31:36.708]                           version <- ns[[".package"]][["version"]]
[09:31:36.708]                           if (is.null(version)) 
[09:31:36.708]                             version <- utils::packageVersion("future")
[09:31:36.708]                         }
[09:31:36.708]                         else {
[09:31:36.708]                           version <- NULL
[09:31:36.708]                         }
[09:31:36.708]                         if (!has_future || version < "1.8.0") {
[09:31:36.708]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.708]                             "", base::R.version$version.string), 
[09:31:36.708]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.708]                               "release", "version")], collapse = " "), 
[09:31:36.708]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.708]                             info)
[09:31:36.708]                           info <- base::paste(info, collapse = "; ")
[09:31:36.708]                           if (!has_future) {
[09:31:36.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.708]                               info)
[09:31:36.708]                           }
[09:31:36.708]                           else {
[09:31:36.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.708]                               info, version)
[09:31:36.708]                           }
[09:31:36.708]                           base::stop(msg)
[09:31:36.708]                         }
[09:31:36.708]                       })
[09:31:36.708]                     }
[09:31:36.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.708]                     base::options(mc.cores = 1L)
[09:31:36.708]                   }
[09:31:36.708]                   ...future.strategy.old <- future::plan("list")
[09:31:36.708]                   options(future.plan = NULL)
[09:31:36.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.708]                 }
[09:31:36.708]                 ...future.workdir <- getwd()
[09:31:36.708]             }
[09:31:36.708]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.708]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.708]         }
[09:31:36.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.708]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.708]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.708]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.708]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.708]             base::names(...future.oldOptions))
[09:31:36.708]     }
[09:31:36.708]     if (FALSE) {
[09:31:36.708]     }
[09:31:36.708]     else {
[09:31:36.708]         if (TRUE) {
[09:31:36.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.708]                 open = "w")
[09:31:36.708]         }
[09:31:36.708]         else {
[09:31:36.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.708]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.708]         }
[09:31:36.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.708]             base::sink(type = "output", split = FALSE)
[09:31:36.708]             base::close(...future.stdout)
[09:31:36.708]         }, add = TRUE)
[09:31:36.708]     }
[09:31:36.708]     ...future.frame <- base::sys.nframe()
[09:31:36.708]     ...future.conditions <- base::list()
[09:31:36.708]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.708]     if (FALSE) {
[09:31:36.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.708]     }
[09:31:36.708]     ...future.result <- base::tryCatch({
[09:31:36.708]         base::withCallingHandlers({
[09:31:36.708]             ...future.value <- base::withVisible(base::local({
[09:31:36.708]                 ...future.makeSendCondition <- base::local({
[09:31:36.708]                   sendCondition <- NULL
[09:31:36.708]                   function(frame = 1L) {
[09:31:36.708]                     if (is.function(sendCondition)) 
[09:31:36.708]                       return(sendCondition)
[09:31:36.708]                     ns <- getNamespace("parallel")
[09:31:36.708]                     if (exists("sendData", mode = "function", 
[09:31:36.708]                       envir = ns)) {
[09:31:36.708]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.708]                         envir = ns)
[09:31:36.708]                       envir <- sys.frame(frame)
[09:31:36.708]                       master <- NULL
[09:31:36.708]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.708]                         !identical(envir, emptyenv())) {
[09:31:36.708]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.708]                           inherits = FALSE)) {
[09:31:36.708]                           master <- get("master", mode = "list", 
[09:31:36.708]                             envir = envir, inherits = FALSE)
[09:31:36.708]                           if (inherits(master, c("SOCKnode", 
[09:31:36.708]                             "SOCK0node"))) {
[09:31:36.708]                             sendCondition <<- function(cond) {
[09:31:36.708]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.708]                                 success = TRUE)
[09:31:36.708]                               parallel_sendData(master, data)
[09:31:36.708]                             }
[09:31:36.708]                             return(sendCondition)
[09:31:36.708]                           }
[09:31:36.708]                         }
[09:31:36.708]                         frame <- frame + 1L
[09:31:36.708]                         envir <- sys.frame(frame)
[09:31:36.708]                       }
[09:31:36.708]                     }
[09:31:36.708]                     sendCondition <<- function(cond) NULL
[09:31:36.708]                   }
[09:31:36.708]                 })
[09:31:36.708]                 withCallingHandlers({
[09:31:36.708]                   {
[09:31:36.708]                     b <- a * ii
[09:31:36.708]                     a <- 0
[09:31:36.708]                     b
[09:31:36.708]                   }
[09:31:36.708]                 }, immediateCondition = function(cond) {
[09:31:36.708]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.708]                   sendCondition(cond)
[09:31:36.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.708]                   {
[09:31:36.708]                     inherits <- base::inherits
[09:31:36.708]                     invokeRestart <- base::invokeRestart
[09:31:36.708]                     is.null <- base::is.null
[09:31:36.708]                     muffled <- FALSE
[09:31:36.708]                     if (inherits(cond, "message")) {
[09:31:36.708]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.708]                       if (muffled) 
[09:31:36.708]                         invokeRestart("muffleMessage")
[09:31:36.708]                     }
[09:31:36.708]                     else if (inherits(cond, "warning")) {
[09:31:36.708]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.708]                       if (muffled) 
[09:31:36.708]                         invokeRestart("muffleWarning")
[09:31:36.708]                     }
[09:31:36.708]                     else if (inherits(cond, "condition")) {
[09:31:36.708]                       if (!is.null(pattern)) {
[09:31:36.708]                         computeRestarts <- base::computeRestarts
[09:31:36.708]                         grepl <- base::grepl
[09:31:36.708]                         restarts <- computeRestarts(cond)
[09:31:36.708]                         for (restart in restarts) {
[09:31:36.708]                           name <- restart$name
[09:31:36.708]                           if (is.null(name)) 
[09:31:36.708]                             next
[09:31:36.708]                           if (!grepl(pattern, name)) 
[09:31:36.708]                             next
[09:31:36.708]                           invokeRestart(restart)
[09:31:36.708]                           muffled <- TRUE
[09:31:36.708]                           break
[09:31:36.708]                         }
[09:31:36.708]                       }
[09:31:36.708]                     }
[09:31:36.708]                     invisible(muffled)
[09:31:36.708]                   }
[09:31:36.708]                   muffleCondition(cond)
[09:31:36.708]                 })
[09:31:36.708]             }))
[09:31:36.708]             future::FutureResult(value = ...future.value$value, 
[09:31:36.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.708]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.708]                     ...future.globalenv.names))
[09:31:36.708]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.708]         }, condition = base::local({
[09:31:36.708]             c <- base::c
[09:31:36.708]             inherits <- base::inherits
[09:31:36.708]             invokeRestart <- base::invokeRestart
[09:31:36.708]             length <- base::length
[09:31:36.708]             list <- base::list
[09:31:36.708]             seq.int <- base::seq.int
[09:31:36.708]             signalCondition <- base::signalCondition
[09:31:36.708]             sys.calls <- base::sys.calls
[09:31:36.708]             `[[` <- base::`[[`
[09:31:36.708]             `+` <- base::`+`
[09:31:36.708]             `<<-` <- base::`<<-`
[09:31:36.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.708]                   3L)]
[09:31:36.708]             }
[09:31:36.708]             function(cond) {
[09:31:36.708]                 is_error <- inherits(cond, "error")
[09:31:36.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.708]                   NULL)
[09:31:36.708]                 if (is_error) {
[09:31:36.708]                   sessionInformation <- function() {
[09:31:36.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.708]                       search = base::search(), system = base::Sys.info())
[09:31:36.708]                   }
[09:31:36.708]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.708]                     cond$call), session = sessionInformation(), 
[09:31:36.708]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.708]                   signalCondition(cond)
[09:31:36.708]                 }
[09:31:36.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.708]                 "immediateCondition"))) {
[09:31:36.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.708]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.708]                   if (TRUE && !signal) {
[09:31:36.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.708]                     {
[09:31:36.708]                       inherits <- base::inherits
[09:31:36.708]                       invokeRestart <- base::invokeRestart
[09:31:36.708]                       is.null <- base::is.null
[09:31:36.708]                       muffled <- FALSE
[09:31:36.708]                       if (inherits(cond, "message")) {
[09:31:36.708]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.708]                         if (muffled) 
[09:31:36.708]                           invokeRestart("muffleMessage")
[09:31:36.708]                       }
[09:31:36.708]                       else if (inherits(cond, "warning")) {
[09:31:36.708]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.708]                         if (muffled) 
[09:31:36.708]                           invokeRestart("muffleWarning")
[09:31:36.708]                       }
[09:31:36.708]                       else if (inherits(cond, "condition")) {
[09:31:36.708]                         if (!is.null(pattern)) {
[09:31:36.708]                           computeRestarts <- base::computeRestarts
[09:31:36.708]                           grepl <- base::grepl
[09:31:36.708]                           restarts <- computeRestarts(cond)
[09:31:36.708]                           for (restart in restarts) {
[09:31:36.708]                             name <- restart$name
[09:31:36.708]                             if (is.null(name)) 
[09:31:36.708]                               next
[09:31:36.708]                             if (!grepl(pattern, name)) 
[09:31:36.708]                               next
[09:31:36.708]                             invokeRestart(restart)
[09:31:36.708]                             muffled <- TRUE
[09:31:36.708]                             break
[09:31:36.708]                           }
[09:31:36.708]                         }
[09:31:36.708]                       }
[09:31:36.708]                       invisible(muffled)
[09:31:36.708]                     }
[09:31:36.708]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.708]                   }
[09:31:36.708]                 }
[09:31:36.708]                 else {
[09:31:36.708]                   if (TRUE) {
[09:31:36.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.708]                     {
[09:31:36.708]                       inherits <- base::inherits
[09:31:36.708]                       invokeRestart <- base::invokeRestart
[09:31:36.708]                       is.null <- base::is.null
[09:31:36.708]                       muffled <- FALSE
[09:31:36.708]                       if (inherits(cond, "message")) {
[09:31:36.708]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.708]                         if (muffled) 
[09:31:36.708]                           invokeRestart("muffleMessage")
[09:31:36.708]                       }
[09:31:36.708]                       else if (inherits(cond, "warning")) {
[09:31:36.708]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.708]                         if (muffled) 
[09:31:36.708]                           invokeRestart("muffleWarning")
[09:31:36.708]                       }
[09:31:36.708]                       else if (inherits(cond, "condition")) {
[09:31:36.708]                         if (!is.null(pattern)) {
[09:31:36.708]                           computeRestarts <- base::computeRestarts
[09:31:36.708]                           grepl <- base::grepl
[09:31:36.708]                           restarts <- computeRestarts(cond)
[09:31:36.708]                           for (restart in restarts) {
[09:31:36.708]                             name <- restart$name
[09:31:36.708]                             if (is.null(name)) 
[09:31:36.708]                               next
[09:31:36.708]                             if (!grepl(pattern, name)) 
[09:31:36.708]                               next
[09:31:36.708]                             invokeRestart(restart)
[09:31:36.708]                             muffled <- TRUE
[09:31:36.708]                             break
[09:31:36.708]                           }
[09:31:36.708]                         }
[09:31:36.708]                       }
[09:31:36.708]                       invisible(muffled)
[09:31:36.708]                     }
[09:31:36.708]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.708]                   }
[09:31:36.708]                 }
[09:31:36.708]             }
[09:31:36.708]         }))
[09:31:36.708]     }, error = function(ex) {
[09:31:36.708]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.708]                 ...future.rng), started = ...future.startTime, 
[09:31:36.708]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.708]             version = "1.8"), class = "FutureResult")
[09:31:36.708]     }, finally = {
[09:31:36.708]         if (!identical(...future.workdir, getwd())) 
[09:31:36.708]             setwd(...future.workdir)
[09:31:36.708]         {
[09:31:36.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.708]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.708]             }
[09:31:36.708]             base::options(...future.oldOptions)
[09:31:36.708]             if (.Platform$OS.type == "windows") {
[09:31:36.708]                 old_names <- names(...future.oldEnvVars)
[09:31:36.708]                 envs <- base::Sys.getenv()
[09:31:36.708]                 names <- names(envs)
[09:31:36.708]                 common <- intersect(names, old_names)
[09:31:36.708]                 added <- setdiff(names, old_names)
[09:31:36.708]                 removed <- setdiff(old_names, names)
[09:31:36.708]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.708]                   envs[common]]
[09:31:36.708]                 NAMES <- toupper(changed)
[09:31:36.708]                 args <- list()
[09:31:36.708]                 for (kk in seq_along(NAMES)) {
[09:31:36.708]                   name <- changed[[kk]]
[09:31:36.708]                   NAME <- NAMES[[kk]]
[09:31:36.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.708]                     next
[09:31:36.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.708]                 }
[09:31:36.708]                 NAMES <- toupper(added)
[09:31:36.708]                 for (kk in seq_along(NAMES)) {
[09:31:36.708]                   name <- added[[kk]]
[09:31:36.708]                   NAME <- NAMES[[kk]]
[09:31:36.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.708]                     next
[09:31:36.708]                   args[[name]] <- ""
[09:31:36.708]                 }
[09:31:36.708]                 NAMES <- toupper(removed)
[09:31:36.708]                 for (kk in seq_along(NAMES)) {
[09:31:36.708]                   name <- removed[[kk]]
[09:31:36.708]                   NAME <- NAMES[[kk]]
[09:31:36.708]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.708]                     next
[09:31:36.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.708]                 }
[09:31:36.708]                 if (length(args) > 0) 
[09:31:36.708]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.708]             }
[09:31:36.708]             else {
[09:31:36.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.708]             }
[09:31:36.708]             {
[09:31:36.708]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.708]                   0L) {
[09:31:36.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.708]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.708]                   base::options(opts)
[09:31:36.708]                 }
[09:31:36.708]                 {
[09:31:36.708]                   {
[09:31:36.708]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.708]                     NULL
[09:31:36.708]                   }
[09:31:36.708]                   options(future.plan = NULL)
[09:31:36.708]                   if (is.na(NA_character_)) 
[09:31:36.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.708]                     .init = FALSE)
[09:31:36.708]                 }
[09:31:36.708]             }
[09:31:36.708]         }
[09:31:36.708]     })
[09:31:36.708]     if (TRUE) {
[09:31:36.708]         base::sink(type = "output", split = FALSE)
[09:31:36.708]         if (TRUE) {
[09:31:36.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.708]         }
[09:31:36.708]         else {
[09:31:36.708]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.708]         }
[09:31:36.708]         base::close(...future.stdout)
[09:31:36.708]         ...future.stdout <- NULL
[09:31:36.708]     }
[09:31:36.708]     ...future.result$conditions <- ...future.conditions
[09:31:36.708]     ...future.result$finished <- base::Sys.time()
[09:31:36.708]     ...future.result
[09:31:36.708] }
[09:31:36.710] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:36.720] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.721] - Validating connection of MultisessionFuture
[09:31:36.721] - received message: FutureResult
[09:31:36.721] - Received FutureResult
[09:31:36.721] - Erased future from FutureRegistry
[09:31:36.721] result() for ClusterFuture ...
[09:31:36.721] - result already collected: FutureResult
[09:31:36.721] result() for ClusterFuture ... done
[09:31:36.721] signalConditions() ...
[09:31:36.722]  - include = ‘immediateCondition’
[09:31:36.722]  - exclude = 
[09:31:36.722]  - resignal = FALSE
[09:31:36.722]  - Number of conditions: 1
[09:31:36.722] signalConditions() ... done
[09:31:36.722] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.722] result() for ClusterFuture ...
[09:31:36.722] - result already collected: FutureResult
[09:31:36.722] result() for ClusterFuture ... done
[09:31:36.722] result() for ClusterFuture ...
[09:31:36.722] - result already collected: FutureResult
[09:31:36.723] result() for ClusterFuture ... done
[09:31:36.723] signalConditions() ...
[09:31:36.723]  - include = ‘immediateCondition’
[09:31:36.723]  - exclude = 
[09:31:36.723]  - resignal = FALSE
[09:31:36.723]  - Number of conditions: 1
[09:31:36.723] signalConditions() ... done
[09:31:36.724] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[09:31:36.724] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[09:31:36.724] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.724] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:36.725] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.725] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[09:31:36.725] MultisessionFuture started
[09:31:36.725] - Launch lazy future ... done
[09:31:36.726] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.726] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.727] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.729] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.729] Searching for globals ... DONE
[09:31:36.729] Resolving globals: TRUE
[09:31:36.729] Resolving any globals that are futures ...
[09:31:36.729] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.729] Resolving any globals that are futures ... DONE
[09:31:36.730] Resolving futures part of globals (recursively) ...
[09:31:36.730] resolve() on list ...
[09:31:36.730]  recursive: 99
[09:31:36.730]  length: 2
[09:31:36.730]  elements: ‘a’, ‘ii’
[09:31:36.730]  length: 1 (resolved future 1)
[09:31:36.730]  length: 0 (resolved future 2)
[09:31:36.731] resolve() on list ... DONE
[09:31:36.731] - globals: [2] ‘a’, ‘ii’
[09:31:36.731] Resolving futures part of globals (recursively) ... DONE
[09:31:36.731] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.731] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.731] - globals: [2] ‘a’, ‘ii’
[09:31:36.731] 
[09:31:36.732] getGlobalsAndPackages() ... DONE
[09:31:36.732] run() for ‘Future’ ...
[09:31:36.732] - state: ‘created’
[09:31:36.732] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.746]   - Field: ‘node’
[09:31:36.746]   - Field: ‘label’
[09:31:36.746]   - Field: ‘local’
[09:31:36.746]   - Field: ‘owner’
[09:31:36.746]   - Field: ‘envir’
[09:31:36.746]   - Field: ‘workers’
[09:31:36.746]   - Field: ‘packages’
[09:31:36.746]   - Field: ‘gc’
[09:31:36.746]   - Field: ‘conditions’
[09:31:36.746]   - Field: ‘persistent’
[09:31:36.746]   - Field: ‘expr’
[09:31:36.747]   - Field: ‘uuid’
[09:31:36.747]   - Field: ‘seed’
[09:31:36.747]   - Field: ‘version’
[09:31:36.747]   - Field: ‘result’
[09:31:36.747]   - Field: ‘asynchronous’
[09:31:36.747]   - Field: ‘calls’
[09:31:36.747]   - Field: ‘globals’
[09:31:36.747]   - Field: ‘stdout’
[09:31:36.747]   - Field: ‘earlySignal’
[09:31:36.747]   - Field: ‘lazy’
[09:31:36.747]   - Field: ‘state’
[09:31:36.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.748] - Launch lazy future ...
[09:31:36.748] Packages needed by the future expression (n = 0): <none>
[09:31:36.748] Packages needed by future strategies (n = 0): <none>
[09:31:36.748] {
[09:31:36.748]     {
[09:31:36.748]         {
[09:31:36.748]             ...future.startTime <- base::Sys.time()
[09:31:36.748]             {
[09:31:36.748]                 {
[09:31:36.748]                   {
[09:31:36.748]                     {
[09:31:36.748]                       base::local({
[09:31:36.748]                         has_future <- base::requireNamespace("future", 
[09:31:36.748]                           quietly = TRUE)
[09:31:36.748]                         if (has_future) {
[09:31:36.748]                           ns <- base::getNamespace("future")
[09:31:36.748]                           version <- ns[[".package"]][["version"]]
[09:31:36.748]                           if (is.null(version)) 
[09:31:36.748]                             version <- utils::packageVersion("future")
[09:31:36.748]                         }
[09:31:36.748]                         else {
[09:31:36.748]                           version <- NULL
[09:31:36.748]                         }
[09:31:36.748]                         if (!has_future || version < "1.8.0") {
[09:31:36.748]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.748]                             "", base::R.version$version.string), 
[09:31:36.748]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.748]                               "release", "version")], collapse = " "), 
[09:31:36.748]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.748]                             info)
[09:31:36.748]                           info <- base::paste(info, collapse = "; ")
[09:31:36.748]                           if (!has_future) {
[09:31:36.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.748]                               info)
[09:31:36.748]                           }
[09:31:36.748]                           else {
[09:31:36.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.748]                               info, version)
[09:31:36.748]                           }
[09:31:36.748]                           base::stop(msg)
[09:31:36.748]                         }
[09:31:36.748]                       })
[09:31:36.748]                     }
[09:31:36.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.748]                     base::options(mc.cores = 1L)
[09:31:36.748]                   }
[09:31:36.748]                   ...future.strategy.old <- future::plan("list")
[09:31:36.748]                   options(future.plan = NULL)
[09:31:36.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.748]                 }
[09:31:36.748]                 ...future.workdir <- getwd()
[09:31:36.748]             }
[09:31:36.748]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.748]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.748]         }
[09:31:36.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.748]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.748]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.748]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.748]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.748]             base::names(...future.oldOptions))
[09:31:36.748]     }
[09:31:36.748]     if (FALSE) {
[09:31:36.748]     }
[09:31:36.748]     else {
[09:31:36.748]         if (TRUE) {
[09:31:36.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.748]                 open = "w")
[09:31:36.748]         }
[09:31:36.748]         else {
[09:31:36.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.748]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.748]         }
[09:31:36.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.748]             base::sink(type = "output", split = FALSE)
[09:31:36.748]             base::close(...future.stdout)
[09:31:36.748]         }, add = TRUE)
[09:31:36.748]     }
[09:31:36.748]     ...future.frame <- base::sys.nframe()
[09:31:36.748]     ...future.conditions <- base::list()
[09:31:36.748]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.748]     if (FALSE) {
[09:31:36.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.748]     }
[09:31:36.748]     ...future.result <- base::tryCatch({
[09:31:36.748]         base::withCallingHandlers({
[09:31:36.748]             ...future.value <- base::withVisible(base::local({
[09:31:36.748]                 ...future.makeSendCondition <- base::local({
[09:31:36.748]                   sendCondition <- NULL
[09:31:36.748]                   function(frame = 1L) {
[09:31:36.748]                     if (is.function(sendCondition)) 
[09:31:36.748]                       return(sendCondition)
[09:31:36.748]                     ns <- getNamespace("parallel")
[09:31:36.748]                     if (exists("sendData", mode = "function", 
[09:31:36.748]                       envir = ns)) {
[09:31:36.748]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.748]                         envir = ns)
[09:31:36.748]                       envir <- sys.frame(frame)
[09:31:36.748]                       master <- NULL
[09:31:36.748]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.748]                         !identical(envir, emptyenv())) {
[09:31:36.748]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.748]                           inherits = FALSE)) {
[09:31:36.748]                           master <- get("master", mode = "list", 
[09:31:36.748]                             envir = envir, inherits = FALSE)
[09:31:36.748]                           if (inherits(master, c("SOCKnode", 
[09:31:36.748]                             "SOCK0node"))) {
[09:31:36.748]                             sendCondition <<- function(cond) {
[09:31:36.748]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.748]                                 success = TRUE)
[09:31:36.748]                               parallel_sendData(master, data)
[09:31:36.748]                             }
[09:31:36.748]                             return(sendCondition)
[09:31:36.748]                           }
[09:31:36.748]                         }
[09:31:36.748]                         frame <- frame + 1L
[09:31:36.748]                         envir <- sys.frame(frame)
[09:31:36.748]                       }
[09:31:36.748]                     }
[09:31:36.748]                     sendCondition <<- function(cond) NULL
[09:31:36.748]                   }
[09:31:36.748]                 })
[09:31:36.748]                 withCallingHandlers({
[09:31:36.748]                   {
[09:31:36.748]                     b <- a * ii
[09:31:36.748]                     a <- 0
[09:31:36.748]                     b
[09:31:36.748]                   }
[09:31:36.748]                 }, immediateCondition = function(cond) {
[09:31:36.748]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.748]                   sendCondition(cond)
[09:31:36.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.748]                   {
[09:31:36.748]                     inherits <- base::inherits
[09:31:36.748]                     invokeRestart <- base::invokeRestart
[09:31:36.748]                     is.null <- base::is.null
[09:31:36.748]                     muffled <- FALSE
[09:31:36.748]                     if (inherits(cond, "message")) {
[09:31:36.748]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.748]                       if (muffled) 
[09:31:36.748]                         invokeRestart("muffleMessage")
[09:31:36.748]                     }
[09:31:36.748]                     else if (inherits(cond, "warning")) {
[09:31:36.748]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.748]                       if (muffled) 
[09:31:36.748]                         invokeRestart("muffleWarning")
[09:31:36.748]                     }
[09:31:36.748]                     else if (inherits(cond, "condition")) {
[09:31:36.748]                       if (!is.null(pattern)) {
[09:31:36.748]                         computeRestarts <- base::computeRestarts
[09:31:36.748]                         grepl <- base::grepl
[09:31:36.748]                         restarts <- computeRestarts(cond)
[09:31:36.748]                         for (restart in restarts) {
[09:31:36.748]                           name <- restart$name
[09:31:36.748]                           if (is.null(name)) 
[09:31:36.748]                             next
[09:31:36.748]                           if (!grepl(pattern, name)) 
[09:31:36.748]                             next
[09:31:36.748]                           invokeRestart(restart)
[09:31:36.748]                           muffled <- TRUE
[09:31:36.748]                           break
[09:31:36.748]                         }
[09:31:36.748]                       }
[09:31:36.748]                     }
[09:31:36.748]                     invisible(muffled)
[09:31:36.748]                   }
[09:31:36.748]                   muffleCondition(cond)
[09:31:36.748]                 })
[09:31:36.748]             }))
[09:31:36.748]             future::FutureResult(value = ...future.value$value, 
[09:31:36.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.748]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.748]                     ...future.globalenv.names))
[09:31:36.748]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.748]         }, condition = base::local({
[09:31:36.748]             c <- base::c
[09:31:36.748]             inherits <- base::inherits
[09:31:36.748]             invokeRestart <- base::invokeRestart
[09:31:36.748]             length <- base::length
[09:31:36.748]             list <- base::list
[09:31:36.748]             seq.int <- base::seq.int
[09:31:36.748]             signalCondition <- base::signalCondition
[09:31:36.748]             sys.calls <- base::sys.calls
[09:31:36.748]             `[[` <- base::`[[`
[09:31:36.748]             `+` <- base::`+`
[09:31:36.748]             `<<-` <- base::`<<-`
[09:31:36.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.748]                   3L)]
[09:31:36.748]             }
[09:31:36.748]             function(cond) {
[09:31:36.748]                 is_error <- inherits(cond, "error")
[09:31:36.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.748]                   NULL)
[09:31:36.748]                 if (is_error) {
[09:31:36.748]                   sessionInformation <- function() {
[09:31:36.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.748]                       search = base::search(), system = base::Sys.info())
[09:31:36.748]                   }
[09:31:36.748]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.748]                     cond$call), session = sessionInformation(), 
[09:31:36.748]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.748]                   signalCondition(cond)
[09:31:36.748]                 }
[09:31:36.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.748]                 "immediateCondition"))) {
[09:31:36.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.748]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.748]                   if (TRUE && !signal) {
[09:31:36.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.748]                     {
[09:31:36.748]                       inherits <- base::inherits
[09:31:36.748]                       invokeRestart <- base::invokeRestart
[09:31:36.748]                       is.null <- base::is.null
[09:31:36.748]                       muffled <- FALSE
[09:31:36.748]                       if (inherits(cond, "message")) {
[09:31:36.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.748]                         if (muffled) 
[09:31:36.748]                           invokeRestart("muffleMessage")
[09:31:36.748]                       }
[09:31:36.748]                       else if (inherits(cond, "warning")) {
[09:31:36.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.748]                         if (muffled) 
[09:31:36.748]                           invokeRestart("muffleWarning")
[09:31:36.748]                       }
[09:31:36.748]                       else if (inherits(cond, "condition")) {
[09:31:36.748]                         if (!is.null(pattern)) {
[09:31:36.748]                           computeRestarts <- base::computeRestarts
[09:31:36.748]                           grepl <- base::grepl
[09:31:36.748]                           restarts <- computeRestarts(cond)
[09:31:36.748]                           for (restart in restarts) {
[09:31:36.748]                             name <- restart$name
[09:31:36.748]                             if (is.null(name)) 
[09:31:36.748]                               next
[09:31:36.748]                             if (!grepl(pattern, name)) 
[09:31:36.748]                               next
[09:31:36.748]                             invokeRestart(restart)
[09:31:36.748]                             muffled <- TRUE
[09:31:36.748]                             break
[09:31:36.748]                           }
[09:31:36.748]                         }
[09:31:36.748]                       }
[09:31:36.748]                       invisible(muffled)
[09:31:36.748]                     }
[09:31:36.748]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.748]                   }
[09:31:36.748]                 }
[09:31:36.748]                 else {
[09:31:36.748]                   if (TRUE) {
[09:31:36.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.748]                     {
[09:31:36.748]                       inherits <- base::inherits
[09:31:36.748]                       invokeRestart <- base::invokeRestart
[09:31:36.748]                       is.null <- base::is.null
[09:31:36.748]                       muffled <- FALSE
[09:31:36.748]                       if (inherits(cond, "message")) {
[09:31:36.748]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.748]                         if (muffled) 
[09:31:36.748]                           invokeRestart("muffleMessage")
[09:31:36.748]                       }
[09:31:36.748]                       else if (inherits(cond, "warning")) {
[09:31:36.748]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.748]                         if (muffled) 
[09:31:36.748]                           invokeRestart("muffleWarning")
[09:31:36.748]                       }
[09:31:36.748]                       else if (inherits(cond, "condition")) {
[09:31:36.748]                         if (!is.null(pattern)) {
[09:31:36.748]                           computeRestarts <- base::computeRestarts
[09:31:36.748]                           grepl <- base::grepl
[09:31:36.748]                           restarts <- computeRestarts(cond)
[09:31:36.748]                           for (restart in restarts) {
[09:31:36.748]                             name <- restart$name
[09:31:36.748]                             if (is.null(name)) 
[09:31:36.748]                               next
[09:31:36.748]                             if (!grepl(pattern, name)) 
[09:31:36.748]                               next
[09:31:36.748]                             invokeRestart(restart)
[09:31:36.748]                             muffled <- TRUE
[09:31:36.748]                             break
[09:31:36.748]                           }
[09:31:36.748]                         }
[09:31:36.748]                       }
[09:31:36.748]                       invisible(muffled)
[09:31:36.748]                     }
[09:31:36.748]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.748]                   }
[09:31:36.748]                 }
[09:31:36.748]             }
[09:31:36.748]         }))
[09:31:36.748]     }, error = function(ex) {
[09:31:36.748]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.748]                 ...future.rng), started = ...future.startTime, 
[09:31:36.748]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.748]             version = "1.8"), class = "FutureResult")
[09:31:36.748]     }, finally = {
[09:31:36.748]         if (!identical(...future.workdir, getwd())) 
[09:31:36.748]             setwd(...future.workdir)
[09:31:36.748]         {
[09:31:36.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.748]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.748]             }
[09:31:36.748]             base::options(...future.oldOptions)
[09:31:36.748]             if (.Platform$OS.type == "windows") {
[09:31:36.748]                 old_names <- names(...future.oldEnvVars)
[09:31:36.748]                 envs <- base::Sys.getenv()
[09:31:36.748]                 names <- names(envs)
[09:31:36.748]                 common <- intersect(names, old_names)
[09:31:36.748]                 added <- setdiff(names, old_names)
[09:31:36.748]                 removed <- setdiff(old_names, names)
[09:31:36.748]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.748]                   envs[common]]
[09:31:36.748]                 NAMES <- toupper(changed)
[09:31:36.748]                 args <- list()
[09:31:36.748]                 for (kk in seq_along(NAMES)) {
[09:31:36.748]                   name <- changed[[kk]]
[09:31:36.748]                   NAME <- NAMES[[kk]]
[09:31:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.748]                     next
[09:31:36.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.748]                 }
[09:31:36.748]                 NAMES <- toupper(added)
[09:31:36.748]                 for (kk in seq_along(NAMES)) {
[09:31:36.748]                   name <- added[[kk]]
[09:31:36.748]                   NAME <- NAMES[[kk]]
[09:31:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.748]                     next
[09:31:36.748]                   args[[name]] <- ""
[09:31:36.748]                 }
[09:31:36.748]                 NAMES <- toupper(removed)
[09:31:36.748]                 for (kk in seq_along(NAMES)) {
[09:31:36.748]                   name <- removed[[kk]]
[09:31:36.748]                   NAME <- NAMES[[kk]]
[09:31:36.748]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.748]                     next
[09:31:36.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.748]                 }
[09:31:36.748]                 if (length(args) > 0) 
[09:31:36.748]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.748]             }
[09:31:36.748]             else {
[09:31:36.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.748]             }
[09:31:36.748]             {
[09:31:36.748]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.748]                   0L) {
[09:31:36.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.748]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.748]                   base::options(opts)
[09:31:36.748]                 }
[09:31:36.748]                 {
[09:31:36.748]                   {
[09:31:36.748]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.748]                     NULL
[09:31:36.748]                   }
[09:31:36.748]                   options(future.plan = NULL)
[09:31:36.748]                   if (is.na(NA_character_)) 
[09:31:36.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.748]                     .init = FALSE)
[09:31:36.748]                 }
[09:31:36.748]             }
[09:31:36.748]         }
[09:31:36.748]     })
[09:31:36.748]     if (TRUE) {
[09:31:36.748]         base::sink(type = "output", split = FALSE)
[09:31:36.748]         if (TRUE) {
[09:31:36.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.748]         }
[09:31:36.748]         else {
[09:31:36.748]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.748]         }
[09:31:36.748]         base::close(...future.stdout)
[09:31:36.748]         ...future.stdout <- NULL
[09:31:36.748]     }
[09:31:36.748]     ...future.result$conditions <- ...future.conditions
[09:31:36.748]     ...future.result$finished <- base::Sys.time()
[09:31:36.748]     ...future.result
[09:31:36.748] }
[09:31:36.750] Poll #1 (0): usedNodes() = 2, workers = 2
[09:31:36.761] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.761] - Validating connection of MultisessionFuture
[09:31:36.761] - received message: FutureResult
[09:31:36.761] - Received FutureResult
[09:31:36.761] - Erased future from FutureRegistry
[09:31:36.762] result() for ClusterFuture ...
[09:31:36.762] - result already collected: FutureResult
[09:31:36.762] result() for ClusterFuture ... done
[09:31:36.762] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.762] result() for ClusterFuture ...
[09:31:36.762] - result already collected: FutureResult
[09:31:36.762] result() for ClusterFuture ... done
[09:31:36.762] result() for ClusterFuture ...
[09:31:36.762] - result already collected: FutureResult
[09:31:36.762] result() for ClusterFuture ... done
[09:31:36.763] Exporting 2 global objects (112 bytes) to cluster node #2 ...
[09:31:36.763] Exporting ‘a’ (56 bytes) to cluster node #2 ...
[09:31:36.763] Exporting ‘a’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.763] Exporting ‘ii’ (56 bytes) to cluster node #2 ...
[09:31:36.764] Exporting ‘ii’ (56 bytes) to cluster node #2 ... DONE
[09:31:36.764] Exporting 2 global objects (112 bytes) to cluster node #2 ... DONE
[09:31:36.764] MultisessionFuture started
[09:31:36.764] - Launch lazy future ... done
[09:31:36.765] run() for ‘MultisessionFuture’ ... done
[09:31:36.765] result() for ClusterFuture ...
[09:31:36.765] - result already collected: FutureResult
[09:31:36.765] result() for ClusterFuture ... done
[09:31:36.765] result() for ClusterFuture ...
[09:31:36.765] - result already collected: FutureResult
[09:31:36.765] result() for ClusterFuture ... done
[09:31:36.765] result() for ClusterFuture ...
[09:31:36.765] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.766] - Validating connection of MultisessionFuture
[09:31:36.766] - received message: FutureResult
[09:31:36.766] - Received FutureResult
[09:31:36.766] - Erased future from FutureRegistry
[09:31:36.766] result() for ClusterFuture ...
[09:31:36.766] - result already collected: FutureResult
[09:31:36.766] result() for ClusterFuture ... done
[09:31:36.766] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.766] result() for ClusterFuture ... done
[09:31:36.766] result() for ClusterFuture ...
[09:31:36.766] - result already collected: FutureResult
[09:31:36.767] result() for ClusterFuture ... done
[09:31:36.767] result() for ClusterFuture ...
[09:31:36.767] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.767] - Validating connection of MultisessionFuture
[09:31:36.809] - received message: FutureResult
[09:31:36.810] - Received FutureResult
[09:31:36.810] - Erased future from FutureRegistry
[09:31:36.810] result() for ClusterFuture ...
[09:31:36.810] - result already collected: FutureResult
[09:31:36.810] result() for ClusterFuture ... done
[09:31:36.810] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.810] result() for ClusterFuture ... done
[09:31:36.810] result() for ClusterFuture ...
[09:31:36.810] - result already collected: FutureResult
[09:31:36.810] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.811] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.811] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.813] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.813] Searching for globals ... DONE
[09:31:36.813] Resolving globals: TRUE
[09:31:36.813] Resolving any globals that are futures ...
[09:31:36.813] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.814] Resolving any globals that are futures ... DONE
[09:31:36.814] Resolving futures part of globals (recursively) ...
[09:31:36.814] resolve() on list ...
[09:31:36.814]  recursive: 99
[09:31:36.814]  length: 2
[09:31:36.814]  elements: ‘a’, ‘ii’
[09:31:36.814]  length: 1 (resolved future 1)
[09:31:36.815]  length: 0 (resolved future 2)
[09:31:36.815] resolve() on list ... DONE
[09:31:36.815] - globals: [2] ‘a’, ‘ii’
[09:31:36.815] Resolving futures part of globals (recursively) ... DONE
[09:31:36.815] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.815] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.815] - globals: [2] ‘a’, ‘ii’
[09:31:36.816] 
[09:31:36.816] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.816] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.816] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.818] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.818] Searching for globals ... DONE
[09:31:36.818] Resolving globals: TRUE
[09:31:36.818] Resolving any globals that are futures ...
[09:31:36.819] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.819] Resolving any globals that are futures ... DONE
[09:31:36.819] Resolving futures part of globals (recursively) ...
[09:31:36.819] resolve() on list ...
[09:31:36.819]  recursive: 99
[09:31:36.819]  length: 2
[09:31:36.819]  elements: ‘a’, ‘ii’
[09:31:36.820]  length: 1 (resolved future 1)
[09:31:36.820]  length: 0 (resolved future 2)
[09:31:36.820] resolve() on list ... DONE
[09:31:36.820] - globals: [2] ‘a’, ‘ii’
[09:31:36.820] Resolving futures part of globals (recursively) ... DONE
[09:31:36.820] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.820] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.821] - globals: [2] ‘a’, ‘ii’
[09:31:36.821] 
[09:31:36.821] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.821] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.822] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.823] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.823] Searching for globals ... DONE
[09:31:36.823] Resolving globals: TRUE
[09:31:36.824] Resolving any globals that are futures ...
[09:31:36.824] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[09:31:36.824] Resolving any globals that are futures ... DONE
[09:31:36.824] Resolving futures part of globals (recursively) ...
[09:31:36.824] resolve() on list ...
[09:31:36.824]  recursive: 99
[09:31:36.825]  length: 2
[09:31:36.825]  elements: ‘a’, ‘ii’
[09:31:36.825]  length: 1 (resolved future 1)
[09:31:36.825]  length: 0 (resolved future 2)
[09:31:36.825] resolve() on list ... DONE
[09:31:36.825] - globals: [2] ‘a’, ‘ii’
[09:31:36.825] Resolving futures part of globals (recursively) ... DONE
[09:31:36.825] The total size of the 2 globals is 112 bytes (112 bytes)
[09:31:36.826] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (56 bytes of class ‘numeric’) and ‘ii’ (56 bytes of class ‘numeric’)
[09:31:36.826] - globals: [2] ‘a’, ‘ii’
[09:31:36.826] 
[09:31:36.826] getGlobalsAndPackages() ... DONE
[09:31:36.826] run() for ‘Future’ ...
[09:31:36.826] - state: ‘created’
[09:31:36.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.841]   - Field: ‘node’
[09:31:36.841]   - Field: ‘label’
[09:31:36.841]   - Field: ‘local’
[09:31:36.841]   - Field: ‘owner’
[09:31:36.841]   - Field: ‘envir’
[09:31:36.841]   - Field: ‘workers’
[09:31:36.841]   - Field: ‘packages’
[09:31:36.841]   - Field: ‘gc’
[09:31:36.841]   - Field: ‘conditions’
[09:31:36.842]   - Field: ‘persistent’
[09:31:36.842]   - Field: ‘expr’
[09:31:36.842]   - Field: ‘uuid’
[09:31:36.842]   - Field: ‘seed’
[09:31:36.842]   - Field: ‘version’
[09:31:36.842]   - Field: ‘result’
[09:31:36.842]   - Field: ‘asynchronous’
[09:31:36.842]   - Field: ‘calls’
[09:31:36.842]   - Field: ‘globals’
[09:31:36.842]   - Field: ‘stdout’
[09:31:36.842]   - Field: ‘earlySignal’
[09:31:36.842]   - Field: ‘lazy’
[09:31:36.843]   - Field: ‘state’
[09:31:36.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.843] - Launch lazy future ...
[09:31:36.843] Packages needed by the future expression (n = 0): <none>
[09:31:36.843] Packages needed by future strategies (n = 0): <none>
[09:31:36.844] {
[09:31:36.844]     {
[09:31:36.844]         {
[09:31:36.844]             ...future.startTime <- base::Sys.time()
[09:31:36.844]             {
[09:31:36.844]                 {
[09:31:36.844]                   {
[09:31:36.844]                     {
[09:31:36.844]                       base::local({
[09:31:36.844]                         has_future <- base::requireNamespace("future", 
[09:31:36.844]                           quietly = TRUE)
[09:31:36.844]                         if (has_future) {
[09:31:36.844]                           ns <- base::getNamespace("future")
[09:31:36.844]                           version <- ns[[".package"]][["version"]]
[09:31:36.844]                           if (is.null(version)) 
[09:31:36.844]                             version <- utils::packageVersion("future")
[09:31:36.844]                         }
[09:31:36.844]                         else {
[09:31:36.844]                           version <- NULL
[09:31:36.844]                         }
[09:31:36.844]                         if (!has_future || version < "1.8.0") {
[09:31:36.844]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.844]                             "", base::R.version$version.string), 
[09:31:36.844]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.844]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.844]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.844]                               "release", "version")], collapse = " "), 
[09:31:36.844]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.844]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.844]                             info)
[09:31:36.844]                           info <- base::paste(info, collapse = "; ")
[09:31:36.844]                           if (!has_future) {
[09:31:36.844]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.844]                               info)
[09:31:36.844]                           }
[09:31:36.844]                           else {
[09:31:36.844]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.844]                               info, version)
[09:31:36.844]                           }
[09:31:36.844]                           base::stop(msg)
[09:31:36.844]                         }
[09:31:36.844]                       })
[09:31:36.844]                     }
[09:31:36.844]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.844]                     base::options(mc.cores = 1L)
[09:31:36.844]                   }
[09:31:36.844]                   ...future.strategy.old <- future::plan("list")
[09:31:36.844]                   options(future.plan = NULL)
[09:31:36.844]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.844]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.844]                 }
[09:31:36.844]                 ...future.workdir <- getwd()
[09:31:36.844]             }
[09:31:36.844]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.844]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.844]         }
[09:31:36.844]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.844]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.844]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.844]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.844]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.844]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.844]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.844]             base::names(...future.oldOptions))
[09:31:36.844]     }
[09:31:36.844]     if (FALSE) {
[09:31:36.844]     }
[09:31:36.844]     else {
[09:31:36.844]         if (TRUE) {
[09:31:36.844]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.844]                 open = "w")
[09:31:36.844]         }
[09:31:36.844]         else {
[09:31:36.844]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.844]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.844]         }
[09:31:36.844]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.844]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.844]             base::sink(type = "output", split = FALSE)
[09:31:36.844]             base::close(...future.stdout)
[09:31:36.844]         }, add = TRUE)
[09:31:36.844]     }
[09:31:36.844]     ...future.frame <- base::sys.nframe()
[09:31:36.844]     ...future.conditions <- base::list()
[09:31:36.844]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.844]     if (FALSE) {
[09:31:36.844]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.844]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.844]     }
[09:31:36.844]     ...future.result <- base::tryCatch({
[09:31:36.844]         base::withCallingHandlers({
[09:31:36.844]             ...future.value <- base::withVisible(base::local({
[09:31:36.844]                 ...future.makeSendCondition <- base::local({
[09:31:36.844]                   sendCondition <- NULL
[09:31:36.844]                   function(frame = 1L) {
[09:31:36.844]                     if (is.function(sendCondition)) 
[09:31:36.844]                       return(sendCondition)
[09:31:36.844]                     ns <- getNamespace("parallel")
[09:31:36.844]                     if (exists("sendData", mode = "function", 
[09:31:36.844]                       envir = ns)) {
[09:31:36.844]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.844]                         envir = ns)
[09:31:36.844]                       envir <- sys.frame(frame)
[09:31:36.844]                       master <- NULL
[09:31:36.844]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.844]                         !identical(envir, emptyenv())) {
[09:31:36.844]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.844]                           inherits = FALSE)) {
[09:31:36.844]                           master <- get("master", mode = "list", 
[09:31:36.844]                             envir = envir, inherits = FALSE)
[09:31:36.844]                           if (inherits(master, c("SOCKnode", 
[09:31:36.844]                             "SOCK0node"))) {
[09:31:36.844]                             sendCondition <<- function(cond) {
[09:31:36.844]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.844]                                 success = TRUE)
[09:31:36.844]                               parallel_sendData(master, data)
[09:31:36.844]                             }
[09:31:36.844]                             return(sendCondition)
[09:31:36.844]                           }
[09:31:36.844]                         }
[09:31:36.844]                         frame <- frame + 1L
[09:31:36.844]                         envir <- sys.frame(frame)
[09:31:36.844]                       }
[09:31:36.844]                     }
[09:31:36.844]                     sendCondition <<- function(cond) NULL
[09:31:36.844]                   }
[09:31:36.844]                 })
[09:31:36.844]                 withCallingHandlers({
[09:31:36.844]                   {
[09:31:36.844]                     b <- a * ii
[09:31:36.844]                     a <- 0
[09:31:36.844]                     b
[09:31:36.844]                   }
[09:31:36.844]                 }, immediateCondition = function(cond) {
[09:31:36.844]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.844]                   sendCondition(cond)
[09:31:36.844]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.844]                   {
[09:31:36.844]                     inherits <- base::inherits
[09:31:36.844]                     invokeRestart <- base::invokeRestart
[09:31:36.844]                     is.null <- base::is.null
[09:31:36.844]                     muffled <- FALSE
[09:31:36.844]                     if (inherits(cond, "message")) {
[09:31:36.844]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.844]                       if (muffled) 
[09:31:36.844]                         invokeRestart("muffleMessage")
[09:31:36.844]                     }
[09:31:36.844]                     else if (inherits(cond, "warning")) {
[09:31:36.844]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.844]                       if (muffled) 
[09:31:36.844]                         invokeRestart("muffleWarning")
[09:31:36.844]                     }
[09:31:36.844]                     else if (inherits(cond, "condition")) {
[09:31:36.844]                       if (!is.null(pattern)) {
[09:31:36.844]                         computeRestarts <- base::computeRestarts
[09:31:36.844]                         grepl <- base::grepl
[09:31:36.844]                         restarts <- computeRestarts(cond)
[09:31:36.844]                         for (restart in restarts) {
[09:31:36.844]                           name <- restart$name
[09:31:36.844]                           if (is.null(name)) 
[09:31:36.844]                             next
[09:31:36.844]                           if (!grepl(pattern, name)) 
[09:31:36.844]                             next
[09:31:36.844]                           invokeRestart(restart)
[09:31:36.844]                           muffled <- TRUE
[09:31:36.844]                           break
[09:31:36.844]                         }
[09:31:36.844]                       }
[09:31:36.844]                     }
[09:31:36.844]                     invisible(muffled)
[09:31:36.844]                   }
[09:31:36.844]                   muffleCondition(cond)
[09:31:36.844]                 })
[09:31:36.844]             }))
[09:31:36.844]             future::FutureResult(value = ...future.value$value, 
[09:31:36.844]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.844]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.844]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.844]                     ...future.globalenv.names))
[09:31:36.844]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.844]         }, condition = base::local({
[09:31:36.844]             c <- base::c
[09:31:36.844]             inherits <- base::inherits
[09:31:36.844]             invokeRestart <- base::invokeRestart
[09:31:36.844]             length <- base::length
[09:31:36.844]             list <- base::list
[09:31:36.844]             seq.int <- base::seq.int
[09:31:36.844]             signalCondition <- base::signalCondition
[09:31:36.844]             sys.calls <- base::sys.calls
[09:31:36.844]             `[[` <- base::`[[`
[09:31:36.844]             `+` <- base::`+`
[09:31:36.844]             `<<-` <- base::`<<-`
[09:31:36.844]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.844]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.844]                   3L)]
[09:31:36.844]             }
[09:31:36.844]             function(cond) {
[09:31:36.844]                 is_error <- inherits(cond, "error")
[09:31:36.844]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.844]                   NULL)
[09:31:36.844]                 if (is_error) {
[09:31:36.844]                   sessionInformation <- function() {
[09:31:36.844]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.844]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.844]                       search = base::search(), system = base::Sys.info())
[09:31:36.844]                   }
[09:31:36.844]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.844]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.844]                     cond$call), session = sessionInformation(), 
[09:31:36.844]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.844]                   signalCondition(cond)
[09:31:36.844]                 }
[09:31:36.844]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.844]                 "immediateCondition"))) {
[09:31:36.844]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.844]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.844]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.844]                   if (TRUE && !signal) {
[09:31:36.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.844]                     {
[09:31:36.844]                       inherits <- base::inherits
[09:31:36.844]                       invokeRestart <- base::invokeRestart
[09:31:36.844]                       is.null <- base::is.null
[09:31:36.844]                       muffled <- FALSE
[09:31:36.844]                       if (inherits(cond, "message")) {
[09:31:36.844]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.844]                         if (muffled) 
[09:31:36.844]                           invokeRestart("muffleMessage")
[09:31:36.844]                       }
[09:31:36.844]                       else if (inherits(cond, "warning")) {
[09:31:36.844]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.844]                         if (muffled) 
[09:31:36.844]                           invokeRestart("muffleWarning")
[09:31:36.844]                       }
[09:31:36.844]                       else if (inherits(cond, "condition")) {
[09:31:36.844]                         if (!is.null(pattern)) {
[09:31:36.844]                           computeRestarts <- base::computeRestarts
[09:31:36.844]                           grepl <- base::grepl
[09:31:36.844]                           restarts <- computeRestarts(cond)
[09:31:36.844]                           for (restart in restarts) {
[09:31:36.844]                             name <- restart$name
[09:31:36.844]                             if (is.null(name)) 
[09:31:36.844]                               next
[09:31:36.844]                             if (!grepl(pattern, name)) 
[09:31:36.844]                               next
[09:31:36.844]                             invokeRestart(restart)
[09:31:36.844]                             muffled <- TRUE
[09:31:36.844]                             break
[09:31:36.844]                           }
[09:31:36.844]                         }
[09:31:36.844]                       }
[09:31:36.844]                       invisible(muffled)
[09:31:36.844]                     }
[09:31:36.844]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.844]                   }
[09:31:36.844]                 }
[09:31:36.844]                 else {
[09:31:36.844]                   if (TRUE) {
[09:31:36.844]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.844]                     {
[09:31:36.844]                       inherits <- base::inherits
[09:31:36.844]                       invokeRestart <- base::invokeRestart
[09:31:36.844]                       is.null <- base::is.null
[09:31:36.844]                       muffled <- FALSE
[09:31:36.844]                       if (inherits(cond, "message")) {
[09:31:36.844]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.844]                         if (muffled) 
[09:31:36.844]                           invokeRestart("muffleMessage")
[09:31:36.844]                       }
[09:31:36.844]                       else if (inherits(cond, "warning")) {
[09:31:36.844]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.844]                         if (muffled) 
[09:31:36.844]                           invokeRestart("muffleWarning")
[09:31:36.844]                       }
[09:31:36.844]                       else if (inherits(cond, "condition")) {
[09:31:36.844]                         if (!is.null(pattern)) {
[09:31:36.844]                           computeRestarts <- base::computeRestarts
[09:31:36.844]                           grepl <- base::grepl
[09:31:36.844]                           restarts <- computeRestarts(cond)
[09:31:36.844]                           for (restart in restarts) {
[09:31:36.844]                             name <- restart$name
[09:31:36.844]                             if (is.null(name)) 
[09:31:36.844]                               next
[09:31:36.844]                             if (!grepl(pattern, name)) 
[09:31:36.844]                               next
[09:31:36.844]                             invokeRestart(restart)
[09:31:36.844]                             muffled <- TRUE
[09:31:36.844]                             break
[09:31:36.844]                           }
[09:31:36.844]                         }
[09:31:36.844]                       }
[09:31:36.844]                       invisible(muffled)
[09:31:36.844]                     }
[09:31:36.844]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.844]                   }
[09:31:36.844]                 }
[09:31:36.844]             }
[09:31:36.844]         }))
[09:31:36.844]     }, error = function(ex) {
[09:31:36.844]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.844]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.844]                 ...future.rng), started = ...future.startTime, 
[09:31:36.844]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.844]             version = "1.8"), class = "FutureResult")
[09:31:36.844]     }, finally = {
[09:31:36.844]         if (!identical(...future.workdir, getwd())) 
[09:31:36.844]             setwd(...future.workdir)
[09:31:36.844]         {
[09:31:36.844]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.844]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.844]             }
[09:31:36.844]             base::options(...future.oldOptions)
[09:31:36.844]             if (.Platform$OS.type == "windows") {
[09:31:36.844]                 old_names <- names(...future.oldEnvVars)
[09:31:36.844]                 envs <- base::Sys.getenv()
[09:31:36.844]                 names <- names(envs)
[09:31:36.844]                 common <- intersect(names, old_names)
[09:31:36.844]                 added <- setdiff(names, old_names)
[09:31:36.844]                 removed <- setdiff(old_names, names)
[09:31:36.844]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.844]                   envs[common]]
[09:31:36.844]                 NAMES <- toupper(changed)
[09:31:36.844]                 args <- list()
[09:31:36.844]                 for (kk in seq_along(NAMES)) {
[09:31:36.844]                   name <- changed[[kk]]
[09:31:36.844]                   NAME <- NAMES[[kk]]
[09:31:36.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.844]                     next
[09:31:36.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.844]                 }
[09:31:36.844]                 NAMES <- toupper(added)
[09:31:36.844]                 for (kk in seq_along(NAMES)) {
[09:31:36.844]                   name <- added[[kk]]
[09:31:36.844]                   NAME <- NAMES[[kk]]
[09:31:36.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.844]                     next
[09:31:36.844]                   args[[name]] <- ""
[09:31:36.844]                 }
[09:31:36.844]                 NAMES <- toupper(removed)
[09:31:36.844]                 for (kk in seq_along(NAMES)) {
[09:31:36.844]                   name <- removed[[kk]]
[09:31:36.844]                   NAME <- NAMES[[kk]]
[09:31:36.844]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.844]                     next
[09:31:36.844]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.844]                 }
[09:31:36.844]                 if (length(args) > 0) 
[09:31:36.844]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.844]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.844]             }
[09:31:36.844]             else {
[09:31:36.844]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.844]             }
[09:31:36.844]             {
[09:31:36.844]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.844]                   0L) {
[09:31:36.844]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.844]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.844]                   base::options(opts)
[09:31:36.844]                 }
[09:31:36.844]                 {
[09:31:36.844]                   {
[09:31:36.844]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.844]                     NULL
[09:31:36.844]                   }
[09:31:36.844]                   options(future.plan = NULL)
[09:31:36.844]                   if (is.na(NA_character_)) 
[09:31:36.844]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.844]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.844]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.844]                     .init = FALSE)
[09:31:36.844]                 }
[09:31:36.844]             }
[09:31:36.844]         }
[09:31:36.844]     })
[09:31:36.844]     if (TRUE) {
[09:31:36.844]         base::sink(type = "output", split = FALSE)
[09:31:36.844]         if (TRUE) {
[09:31:36.844]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.844]         }
[09:31:36.844]         else {
[09:31:36.844]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.844]         }
[09:31:36.844]         base::close(...future.stdout)
[09:31:36.844]         ...future.stdout <- NULL
[09:31:36.844]     }
[09:31:36.844]     ...future.result$conditions <- ...future.conditions
[09:31:36.844]     ...future.result$finished <- base::Sys.time()
[09:31:36.844]     ...future.result
[09:31:36.844] }
[09:31:36.846] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[09:31:36.846] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[09:31:36.847] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.847] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:36.847] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.847] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[09:31:36.848] MultisessionFuture started
[09:31:36.848] - Launch lazy future ... done
[09:31:36.848] run() for ‘MultisessionFuture’ ... done
[09:31:36.848] result() for ClusterFuture ...
[09:31:36.849] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.849] - Validating connection of MultisessionFuture
[09:31:36.850] - received message: FutureResult
[09:31:36.850] - Received FutureResult
[09:31:36.850] - Erased future from FutureRegistry
[09:31:36.850] result() for ClusterFuture ...
[09:31:36.850] - result already collected: FutureResult
[09:31:36.850] result() for ClusterFuture ... done
[09:31:36.850] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.851] result() for ClusterFuture ... done
[09:31:36.851] result() for ClusterFuture ...
[09:31:36.851] - result already collected: FutureResult
[09:31:36.851] result() for ClusterFuture ... done
[09:31:36.851] run() for ‘Future’ ...
[09:31:36.851] - state: ‘created’
[09:31:36.851] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.867] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.867]   - Field: ‘node’
[09:31:36.867]   - Field: ‘label’
[09:31:36.868]   - Field: ‘local’
[09:31:36.868]   - Field: ‘owner’
[09:31:36.868]   - Field: ‘envir’
[09:31:36.868]   - Field: ‘workers’
[09:31:36.868]   - Field: ‘packages’
[09:31:36.868]   - Field: ‘gc’
[09:31:36.868]   - Field: ‘conditions’
[09:31:36.868]   - Field: ‘persistent’
[09:31:36.868]   - Field: ‘expr’
[09:31:36.868]   - Field: ‘uuid’
[09:31:36.869]   - Field: ‘seed’
[09:31:36.869]   - Field: ‘version’
[09:31:36.869]   - Field: ‘result’
[09:31:36.869]   - Field: ‘asynchronous’
[09:31:36.869]   - Field: ‘calls’
[09:31:36.869]   - Field: ‘globals’
[09:31:36.869]   - Field: ‘stdout’
[09:31:36.869]   - Field: ‘earlySignal’
[09:31:36.869]   - Field: ‘lazy’
[09:31:36.869]   - Field: ‘state’
[09:31:36.869] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.869] - Launch lazy future ...
[09:31:36.870] Packages needed by the future expression (n = 0): <none>
[09:31:36.870] Packages needed by future strategies (n = 0): <none>
[09:31:36.870] {
[09:31:36.870]     {
[09:31:36.870]         {
[09:31:36.870]             ...future.startTime <- base::Sys.time()
[09:31:36.870]             {
[09:31:36.870]                 {
[09:31:36.870]                   {
[09:31:36.870]                     {
[09:31:36.870]                       base::local({
[09:31:36.870]                         has_future <- base::requireNamespace("future", 
[09:31:36.870]                           quietly = TRUE)
[09:31:36.870]                         if (has_future) {
[09:31:36.870]                           ns <- base::getNamespace("future")
[09:31:36.870]                           version <- ns[[".package"]][["version"]]
[09:31:36.870]                           if (is.null(version)) 
[09:31:36.870]                             version <- utils::packageVersion("future")
[09:31:36.870]                         }
[09:31:36.870]                         else {
[09:31:36.870]                           version <- NULL
[09:31:36.870]                         }
[09:31:36.870]                         if (!has_future || version < "1.8.0") {
[09:31:36.870]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.870]                             "", base::R.version$version.string), 
[09:31:36.870]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.870]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.870]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.870]                               "release", "version")], collapse = " "), 
[09:31:36.870]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.870]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.870]                             info)
[09:31:36.870]                           info <- base::paste(info, collapse = "; ")
[09:31:36.870]                           if (!has_future) {
[09:31:36.870]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.870]                               info)
[09:31:36.870]                           }
[09:31:36.870]                           else {
[09:31:36.870]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.870]                               info, version)
[09:31:36.870]                           }
[09:31:36.870]                           base::stop(msg)
[09:31:36.870]                         }
[09:31:36.870]                       })
[09:31:36.870]                     }
[09:31:36.870]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.870]                     base::options(mc.cores = 1L)
[09:31:36.870]                   }
[09:31:36.870]                   ...future.strategy.old <- future::plan("list")
[09:31:36.870]                   options(future.plan = NULL)
[09:31:36.870]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.870]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.870]                 }
[09:31:36.870]                 ...future.workdir <- getwd()
[09:31:36.870]             }
[09:31:36.870]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.870]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.870]         }
[09:31:36.870]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.870]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.870]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.870]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.870]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.870]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.870]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.870]             base::names(...future.oldOptions))
[09:31:36.870]     }
[09:31:36.870]     if (FALSE) {
[09:31:36.870]     }
[09:31:36.870]     else {
[09:31:36.870]         if (TRUE) {
[09:31:36.870]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.870]                 open = "w")
[09:31:36.870]         }
[09:31:36.870]         else {
[09:31:36.870]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.870]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.870]         }
[09:31:36.870]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.870]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.870]             base::sink(type = "output", split = FALSE)
[09:31:36.870]             base::close(...future.stdout)
[09:31:36.870]         }, add = TRUE)
[09:31:36.870]     }
[09:31:36.870]     ...future.frame <- base::sys.nframe()
[09:31:36.870]     ...future.conditions <- base::list()
[09:31:36.870]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.870]     if (FALSE) {
[09:31:36.870]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.870]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.870]     }
[09:31:36.870]     ...future.result <- base::tryCatch({
[09:31:36.870]         base::withCallingHandlers({
[09:31:36.870]             ...future.value <- base::withVisible(base::local({
[09:31:36.870]                 ...future.makeSendCondition <- base::local({
[09:31:36.870]                   sendCondition <- NULL
[09:31:36.870]                   function(frame = 1L) {
[09:31:36.870]                     if (is.function(sendCondition)) 
[09:31:36.870]                       return(sendCondition)
[09:31:36.870]                     ns <- getNamespace("parallel")
[09:31:36.870]                     if (exists("sendData", mode = "function", 
[09:31:36.870]                       envir = ns)) {
[09:31:36.870]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.870]                         envir = ns)
[09:31:36.870]                       envir <- sys.frame(frame)
[09:31:36.870]                       master <- NULL
[09:31:36.870]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.870]                         !identical(envir, emptyenv())) {
[09:31:36.870]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.870]                           inherits = FALSE)) {
[09:31:36.870]                           master <- get("master", mode = "list", 
[09:31:36.870]                             envir = envir, inherits = FALSE)
[09:31:36.870]                           if (inherits(master, c("SOCKnode", 
[09:31:36.870]                             "SOCK0node"))) {
[09:31:36.870]                             sendCondition <<- function(cond) {
[09:31:36.870]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.870]                                 success = TRUE)
[09:31:36.870]                               parallel_sendData(master, data)
[09:31:36.870]                             }
[09:31:36.870]                             return(sendCondition)
[09:31:36.870]                           }
[09:31:36.870]                         }
[09:31:36.870]                         frame <- frame + 1L
[09:31:36.870]                         envir <- sys.frame(frame)
[09:31:36.870]                       }
[09:31:36.870]                     }
[09:31:36.870]                     sendCondition <<- function(cond) NULL
[09:31:36.870]                   }
[09:31:36.870]                 })
[09:31:36.870]                 withCallingHandlers({
[09:31:36.870]                   {
[09:31:36.870]                     b <- a * ii
[09:31:36.870]                     a <- 0
[09:31:36.870]                     b
[09:31:36.870]                   }
[09:31:36.870]                 }, immediateCondition = function(cond) {
[09:31:36.870]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.870]                   sendCondition(cond)
[09:31:36.870]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.870]                   {
[09:31:36.870]                     inherits <- base::inherits
[09:31:36.870]                     invokeRestart <- base::invokeRestart
[09:31:36.870]                     is.null <- base::is.null
[09:31:36.870]                     muffled <- FALSE
[09:31:36.870]                     if (inherits(cond, "message")) {
[09:31:36.870]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.870]                       if (muffled) 
[09:31:36.870]                         invokeRestart("muffleMessage")
[09:31:36.870]                     }
[09:31:36.870]                     else if (inherits(cond, "warning")) {
[09:31:36.870]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.870]                       if (muffled) 
[09:31:36.870]                         invokeRestart("muffleWarning")
[09:31:36.870]                     }
[09:31:36.870]                     else if (inherits(cond, "condition")) {
[09:31:36.870]                       if (!is.null(pattern)) {
[09:31:36.870]                         computeRestarts <- base::computeRestarts
[09:31:36.870]                         grepl <- base::grepl
[09:31:36.870]                         restarts <- computeRestarts(cond)
[09:31:36.870]                         for (restart in restarts) {
[09:31:36.870]                           name <- restart$name
[09:31:36.870]                           if (is.null(name)) 
[09:31:36.870]                             next
[09:31:36.870]                           if (!grepl(pattern, name)) 
[09:31:36.870]                             next
[09:31:36.870]                           invokeRestart(restart)
[09:31:36.870]                           muffled <- TRUE
[09:31:36.870]                           break
[09:31:36.870]                         }
[09:31:36.870]                       }
[09:31:36.870]                     }
[09:31:36.870]                     invisible(muffled)
[09:31:36.870]                   }
[09:31:36.870]                   muffleCondition(cond)
[09:31:36.870]                 })
[09:31:36.870]             }))
[09:31:36.870]             future::FutureResult(value = ...future.value$value, 
[09:31:36.870]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.870]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.870]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.870]                     ...future.globalenv.names))
[09:31:36.870]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.870]         }, condition = base::local({
[09:31:36.870]             c <- base::c
[09:31:36.870]             inherits <- base::inherits
[09:31:36.870]             invokeRestart <- base::invokeRestart
[09:31:36.870]             length <- base::length
[09:31:36.870]             list <- base::list
[09:31:36.870]             seq.int <- base::seq.int
[09:31:36.870]             signalCondition <- base::signalCondition
[09:31:36.870]             sys.calls <- base::sys.calls
[09:31:36.870]             `[[` <- base::`[[`
[09:31:36.870]             `+` <- base::`+`
[09:31:36.870]             `<<-` <- base::`<<-`
[09:31:36.870]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.870]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.870]                   3L)]
[09:31:36.870]             }
[09:31:36.870]             function(cond) {
[09:31:36.870]                 is_error <- inherits(cond, "error")
[09:31:36.870]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.870]                   NULL)
[09:31:36.870]                 if (is_error) {
[09:31:36.870]                   sessionInformation <- function() {
[09:31:36.870]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.870]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.870]                       search = base::search(), system = base::Sys.info())
[09:31:36.870]                   }
[09:31:36.870]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.870]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.870]                     cond$call), session = sessionInformation(), 
[09:31:36.870]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.870]                   signalCondition(cond)
[09:31:36.870]                 }
[09:31:36.870]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.870]                 "immediateCondition"))) {
[09:31:36.870]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.870]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.870]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.870]                   if (TRUE && !signal) {
[09:31:36.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.870]                     {
[09:31:36.870]                       inherits <- base::inherits
[09:31:36.870]                       invokeRestart <- base::invokeRestart
[09:31:36.870]                       is.null <- base::is.null
[09:31:36.870]                       muffled <- FALSE
[09:31:36.870]                       if (inherits(cond, "message")) {
[09:31:36.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.870]                         if (muffled) 
[09:31:36.870]                           invokeRestart("muffleMessage")
[09:31:36.870]                       }
[09:31:36.870]                       else if (inherits(cond, "warning")) {
[09:31:36.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.870]                         if (muffled) 
[09:31:36.870]                           invokeRestart("muffleWarning")
[09:31:36.870]                       }
[09:31:36.870]                       else if (inherits(cond, "condition")) {
[09:31:36.870]                         if (!is.null(pattern)) {
[09:31:36.870]                           computeRestarts <- base::computeRestarts
[09:31:36.870]                           grepl <- base::grepl
[09:31:36.870]                           restarts <- computeRestarts(cond)
[09:31:36.870]                           for (restart in restarts) {
[09:31:36.870]                             name <- restart$name
[09:31:36.870]                             if (is.null(name)) 
[09:31:36.870]                               next
[09:31:36.870]                             if (!grepl(pattern, name)) 
[09:31:36.870]                               next
[09:31:36.870]                             invokeRestart(restart)
[09:31:36.870]                             muffled <- TRUE
[09:31:36.870]                             break
[09:31:36.870]                           }
[09:31:36.870]                         }
[09:31:36.870]                       }
[09:31:36.870]                       invisible(muffled)
[09:31:36.870]                     }
[09:31:36.870]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.870]                   }
[09:31:36.870]                 }
[09:31:36.870]                 else {
[09:31:36.870]                   if (TRUE) {
[09:31:36.870]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.870]                     {
[09:31:36.870]                       inherits <- base::inherits
[09:31:36.870]                       invokeRestart <- base::invokeRestart
[09:31:36.870]                       is.null <- base::is.null
[09:31:36.870]                       muffled <- FALSE
[09:31:36.870]                       if (inherits(cond, "message")) {
[09:31:36.870]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.870]                         if (muffled) 
[09:31:36.870]                           invokeRestart("muffleMessage")
[09:31:36.870]                       }
[09:31:36.870]                       else if (inherits(cond, "warning")) {
[09:31:36.870]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.870]                         if (muffled) 
[09:31:36.870]                           invokeRestart("muffleWarning")
[09:31:36.870]                       }
[09:31:36.870]                       else if (inherits(cond, "condition")) {
[09:31:36.870]                         if (!is.null(pattern)) {
[09:31:36.870]                           computeRestarts <- base::computeRestarts
[09:31:36.870]                           grepl <- base::grepl
[09:31:36.870]                           restarts <- computeRestarts(cond)
[09:31:36.870]                           for (restart in restarts) {
[09:31:36.870]                             name <- restart$name
[09:31:36.870]                             if (is.null(name)) 
[09:31:36.870]                               next
[09:31:36.870]                             if (!grepl(pattern, name)) 
[09:31:36.870]                               next
[09:31:36.870]                             invokeRestart(restart)
[09:31:36.870]                             muffled <- TRUE
[09:31:36.870]                             break
[09:31:36.870]                           }
[09:31:36.870]                         }
[09:31:36.870]                       }
[09:31:36.870]                       invisible(muffled)
[09:31:36.870]                     }
[09:31:36.870]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.870]                   }
[09:31:36.870]                 }
[09:31:36.870]             }
[09:31:36.870]         }))
[09:31:36.870]     }, error = function(ex) {
[09:31:36.870]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.870]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.870]                 ...future.rng), started = ...future.startTime, 
[09:31:36.870]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.870]             version = "1.8"), class = "FutureResult")
[09:31:36.870]     }, finally = {
[09:31:36.870]         if (!identical(...future.workdir, getwd())) 
[09:31:36.870]             setwd(...future.workdir)
[09:31:36.870]         {
[09:31:36.870]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.870]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.870]             }
[09:31:36.870]             base::options(...future.oldOptions)
[09:31:36.870]             if (.Platform$OS.type == "windows") {
[09:31:36.870]                 old_names <- names(...future.oldEnvVars)
[09:31:36.870]                 envs <- base::Sys.getenv()
[09:31:36.870]                 names <- names(envs)
[09:31:36.870]                 common <- intersect(names, old_names)
[09:31:36.870]                 added <- setdiff(names, old_names)
[09:31:36.870]                 removed <- setdiff(old_names, names)
[09:31:36.870]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.870]                   envs[common]]
[09:31:36.870]                 NAMES <- toupper(changed)
[09:31:36.870]                 args <- list()
[09:31:36.870]                 for (kk in seq_along(NAMES)) {
[09:31:36.870]                   name <- changed[[kk]]
[09:31:36.870]                   NAME <- NAMES[[kk]]
[09:31:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.870]                     next
[09:31:36.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.870]                 }
[09:31:36.870]                 NAMES <- toupper(added)
[09:31:36.870]                 for (kk in seq_along(NAMES)) {
[09:31:36.870]                   name <- added[[kk]]
[09:31:36.870]                   NAME <- NAMES[[kk]]
[09:31:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.870]                     next
[09:31:36.870]                   args[[name]] <- ""
[09:31:36.870]                 }
[09:31:36.870]                 NAMES <- toupper(removed)
[09:31:36.870]                 for (kk in seq_along(NAMES)) {
[09:31:36.870]                   name <- removed[[kk]]
[09:31:36.870]                   NAME <- NAMES[[kk]]
[09:31:36.870]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.870]                     next
[09:31:36.870]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.870]                 }
[09:31:36.870]                 if (length(args) > 0) 
[09:31:36.870]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.870]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.870]             }
[09:31:36.870]             else {
[09:31:36.870]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.870]             }
[09:31:36.870]             {
[09:31:36.870]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.870]                   0L) {
[09:31:36.870]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.870]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.870]                   base::options(opts)
[09:31:36.870]                 }
[09:31:36.870]                 {
[09:31:36.870]                   {
[09:31:36.870]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.870]                     NULL
[09:31:36.870]                   }
[09:31:36.870]                   options(future.plan = NULL)
[09:31:36.870]                   if (is.na(NA_character_)) 
[09:31:36.870]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.870]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.870]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.870]                     .init = FALSE)
[09:31:36.870]                 }
[09:31:36.870]             }
[09:31:36.870]         }
[09:31:36.870]     })
[09:31:36.870]     if (TRUE) {
[09:31:36.870]         base::sink(type = "output", split = FALSE)
[09:31:36.870]         if (TRUE) {
[09:31:36.870]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.870]         }
[09:31:36.870]         else {
[09:31:36.870]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.870]         }
[09:31:36.870]         base::close(...future.stdout)
[09:31:36.870]         ...future.stdout <- NULL
[09:31:36.870]     }
[09:31:36.870]     ...future.result$conditions <- ...future.conditions
[09:31:36.870]     ...future.result$finished <- base::Sys.time()
[09:31:36.870]     ...future.result
[09:31:36.870] }
[09:31:36.873] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[09:31:36.873] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[09:31:36.873] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.873] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:36.874] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.874] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[09:31:36.874] MultisessionFuture started
[09:31:36.874] - Launch lazy future ... done
[09:31:36.875] run() for ‘MultisessionFuture’ ... done
[09:31:36.875] result() for ClusterFuture ...
[09:31:36.875] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.875] - Validating connection of MultisessionFuture
[09:31:36.876] - received message: FutureResult
[09:31:36.876] - Received FutureResult
[09:31:36.876] - Erased future from FutureRegistry
[09:31:36.877] result() for ClusterFuture ...
[09:31:36.877] - result already collected: FutureResult
[09:31:36.877] result() for ClusterFuture ... done
[09:31:36.877] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.877] result() for ClusterFuture ... done
[09:31:36.877] result() for ClusterFuture ...
[09:31:36.877] - result already collected: FutureResult
[09:31:36.877] result() for ClusterFuture ... done
[09:31:36.877] run() for ‘Future’ ...
[09:31:36.877] - state: ‘created’
[09:31:36.877] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.892]   - Field: ‘node’
[09:31:36.892]   - Field: ‘label’
[09:31:36.892]   - Field: ‘local’
[09:31:36.892]   - Field: ‘owner’
[09:31:36.892]   - Field: ‘envir’
[09:31:36.892]   - Field: ‘workers’
[09:31:36.892]   - Field: ‘packages’
[09:31:36.892]   - Field: ‘gc’
[09:31:36.893]   - Field: ‘conditions’
[09:31:36.893]   - Field: ‘persistent’
[09:31:36.893]   - Field: ‘expr’
[09:31:36.893]   - Field: ‘uuid’
[09:31:36.893]   - Field: ‘seed’
[09:31:36.893]   - Field: ‘version’
[09:31:36.893]   - Field: ‘result’
[09:31:36.893]   - Field: ‘asynchronous’
[09:31:36.893]   - Field: ‘calls’
[09:31:36.893]   - Field: ‘globals’
[09:31:36.893]   - Field: ‘stdout’
[09:31:36.893]   - Field: ‘earlySignal’
[09:31:36.894]   - Field: ‘lazy’
[09:31:36.894]   - Field: ‘state’
[09:31:36.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.894] - Launch lazy future ...
[09:31:36.894] Packages needed by the future expression (n = 0): <none>
[09:31:36.894] Packages needed by future strategies (n = 0): <none>
[09:31:36.894] {
[09:31:36.894]     {
[09:31:36.894]         {
[09:31:36.894]             ...future.startTime <- base::Sys.time()
[09:31:36.894]             {
[09:31:36.894]                 {
[09:31:36.894]                   {
[09:31:36.894]                     {
[09:31:36.894]                       base::local({
[09:31:36.894]                         has_future <- base::requireNamespace("future", 
[09:31:36.894]                           quietly = TRUE)
[09:31:36.894]                         if (has_future) {
[09:31:36.894]                           ns <- base::getNamespace("future")
[09:31:36.894]                           version <- ns[[".package"]][["version"]]
[09:31:36.894]                           if (is.null(version)) 
[09:31:36.894]                             version <- utils::packageVersion("future")
[09:31:36.894]                         }
[09:31:36.894]                         else {
[09:31:36.894]                           version <- NULL
[09:31:36.894]                         }
[09:31:36.894]                         if (!has_future || version < "1.8.0") {
[09:31:36.894]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.894]                             "", base::R.version$version.string), 
[09:31:36.894]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.894]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.894]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.894]                               "release", "version")], collapse = " "), 
[09:31:36.894]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.894]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.894]                             info)
[09:31:36.894]                           info <- base::paste(info, collapse = "; ")
[09:31:36.894]                           if (!has_future) {
[09:31:36.894]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.894]                               info)
[09:31:36.894]                           }
[09:31:36.894]                           else {
[09:31:36.894]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.894]                               info, version)
[09:31:36.894]                           }
[09:31:36.894]                           base::stop(msg)
[09:31:36.894]                         }
[09:31:36.894]                       })
[09:31:36.894]                     }
[09:31:36.894]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.894]                     base::options(mc.cores = 1L)
[09:31:36.894]                   }
[09:31:36.894]                   ...future.strategy.old <- future::plan("list")
[09:31:36.894]                   options(future.plan = NULL)
[09:31:36.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.894]                 }
[09:31:36.894]                 ...future.workdir <- getwd()
[09:31:36.894]             }
[09:31:36.894]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.894]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.894]         }
[09:31:36.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.894]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.894]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.894]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.894]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.894]             base::names(...future.oldOptions))
[09:31:36.894]     }
[09:31:36.894]     if (FALSE) {
[09:31:36.894]     }
[09:31:36.894]     else {
[09:31:36.894]         if (TRUE) {
[09:31:36.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.894]                 open = "w")
[09:31:36.894]         }
[09:31:36.894]         else {
[09:31:36.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.894]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.894]         }
[09:31:36.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.894]             base::sink(type = "output", split = FALSE)
[09:31:36.894]             base::close(...future.stdout)
[09:31:36.894]         }, add = TRUE)
[09:31:36.894]     }
[09:31:36.894]     ...future.frame <- base::sys.nframe()
[09:31:36.894]     ...future.conditions <- base::list()
[09:31:36.894]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.894]     if (FALSE) {
[09:31:36.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.894]     }
[09:31:36.894]     ...future.result <- base::tryCatch({
[09:31:36.894]         base::withCallingHandlers({
[09:31:36.894]             ...future.value <- base::withVisible(base::local({
[09:31:36.894]                 ...future.makeSendCondition <- base::local({
[09:31:36.894]                   sendCondition <- NULL
[09:31:36.894]                   function(frame = 1L) {
[09:31:36.894]                     if (is.function(sendCondition)) 
[09:31:36.894]                       return(sendCondition)
[09:31:36.894]                     ns <- getNamespace("parallel")
[09:31:36.894]                     if (exists("sendData", mode = "function", 
[09:31:36.894]                       envir = ns)) {
[09:31:36.894]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.894]                         envir = ns)
[09:31:36.894]                       envir <- sys.frame(frame)
[09:31:36.894]                       master <- NULL
[09:31:36.894]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.894]                         !identical(envir, emptyenv())) {
[09:31:36.894]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.894]                           inherits = FALSE)) {
[09:31:36.894]                           master <- get("master", mode = "list", 
[09:31:36.894]                             envir = envir, inherits = FALSE)
[09:31:36.894]                           if (inherits(master, c("SOCKnode", 
[09:31:36.894]                             "SOCK0node"))) {
[09:31:36.894]                             sendCondition <<- function(cond) {
[09:31:36.894]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.894]                                 success = TRUE)
[09:31:36.894]                               parallel_sendData(master, data)
[09:31:36.894]                             }
[09:31:36.894]                             return(sendCondition)
[09:31:36.894]                           }
[09:31:36.894]                         }
[09:31:36.894]                         frame <- frame + 1L
[09:31:36.894]                         envir <- sys.frame(frame)
[09:31:36.894]                       }
[09:31:36.894]                     }
[09:31:36.894]                     sendCondition <<- function(cond) NULL
[09:31:36.894]                   }
[09:31:36.894]                 })
[09:31:36.894]                 withCallingHandlers({
[09:31:36.894]                   {
[09:31:36.894]                     b <- a * ii
[09:31:36.894]                     a <- 0
[09:31:36.894]                     b
[09:31:36.894]                   }
[09:31:36.894]                 }, immediateCondition = function(cond) {
[09:31:36.894]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.894]                   sendCondition(cond)
[09:31:36.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.894]                   {
[09:31:36.894]                     inherits <- base::inherits
[09:31:36.894]                     invokeRestart <- base::invokeRestart
[09:31:36.894]                     is.null <- base::is.null
[09:31:36.894]                     muffled <- FALSE
[09:31:36.894]                     if (inherits(cond, "message")) {
[09:31:36.894]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.894]                       if (muffled) 
[09:31:36.894]                         invokeRestart("muffleMessage")
[09:31:36.894]                     }
[09:31:36.894]                     else if (inherits(cond, "warning")) {
[09:31:36.894]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.894]                       if (muffled) 
[09:31:36.894]                         invokeRestart("muffleWarning")
[09:31:36.894]                     }
[09:31:36.894]                     else if (inherits(cond, "condition")) {
[09:31:36.894]                       if (!is.null(pattern)) {
[09:31:36.894]                         computeRestarts <- base::computeRestarts
[09:31:36.894]                         grepl <- base::grepl
[09:31:36.894]                         restarts <- computeRestarts(cond)
[09:31:36.894]                         for (restart in restarts) {
[09:31:36.894]                           name <- restart$name
[09:31:36.894]                           if (is.null(name)) 
[09:31:36.894]                             next
[09:31:36.894]                           if (!grepl(pattern, name)) 
[09:31:36.894]                             next
[09:31:36.894]                           invokeRestart(restart)
[09:31:36.894]                           muffled <- TRUE
[09:31:36.894]                           break
[09:31:36.894]                         }
[09:31:36.894]                       }
[09:31:36.894]                     }
[09:31:36.894]                     invisible(muffled)
[09:31:36.894]                   }
[09:31:36.894]                   muffleCondition(cond)
[09:31:36.894]                 })
[09:31:36.894]             }))
[09:31:36.894]             future::FutureResult(value = ...future.value$value, 
[09:31:36.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.894]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.894]                     ...future.globalenv.names))
[09:31:36.894]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.894]         }, condition = base::local({
[09:31:36.894]             c <- base::c
[09:31:36.894]             inherits <- base::inherits
[09:31:36.894]             invokeRestart <- base::invokeRestart
[09:31:36.894]             length <- base::length
[09:31:36.894]             list <- base::list
[09:31:36.894]             seq.int <- base::seq.int
[09:31:36.894]             signalCondition <- base::signalCondition
[09:31:36.894]             sys.calls <- base::sys.calls
[09:31:36.894]             `[[` <- base::`[[`
[09:31:36.894]             `+` <- base::`+`
[09:31:36.894]             `<<-` <- base::`<<-`
[09:31:36.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.894]                   3L)]
[09:31:36.894]             }
[09:31:36.894]             function(cond) {
[09:31:36.894]                 is_error <- inherits(cond, "error")
[09:31:36.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.894]                   NULL)
[09:31:36.894]                 if (is_error) {
[09:31:36.894]                   sessionInformation <- function() {
[09:31:36.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.894]                       search = base::search(), system = base::Sys.info())
[09:31:36.894]                   }
[09:31:36.894]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.894]                     cond$call), session = sessionInformation(), 
[09:31:36.894]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.894]                   signalCondition(cond)
[09:31:36.894]                 }
[09:31:36.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.894]                 "immediateCondition"))) {
[09:31:36.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.894]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.894]                   if (TRUE && !signal) {
[09:31:36.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.894]                     {
[09:31:36.894]                       inherits <- base::inherits
[09:31:36.894]                       invokeRestart <- base::invokeRestart
[09:31:36.894]                       is.null <- base::is.null
[09:31:36.894]                       muffled <- FALSE
[09:31:36.894]                       if (inherits(cond, "message")) {
[09:31:36.894]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.894]                         if (muffled) 
[09:31:36.894]                           invokeRestart("muffleMessage")
[09:31:36.894]                       }
[09:31:36.894]                       else if (inherits(cond, "warning")) {
[09:31:36.894]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.894]                         if (muffled) 
[09:31:36.894]                           invokeRestart("muffleWarning")
[09:31:36.894]                       }
[09:31:36.894]                       else if (inherits(cond, "condition")) {
[09:31:36.894]                         if (!is.null(pattern)) {
[09:31:36.894]                           computeRestarts <- base::computeRestarts
[09:31:36.894]                           grepl <- base::grepl
[09:31:36.894]                           restarts <- computeRestarts(cond)
[09:31:36.894]                           for (restart in restarts) {
[09:31:36.894]                             name <- restart$name
[09:31:36.894]                             if (is.null(name)) 
[09:31:36.894]                               next
[09:31:36.894]                             if (!grepl(pattern, name)) 
[09:31:36.894]                               next
[09:31:36.894]                             invokeRestart(restart)
[09:31:36.894]                             muffled <- TRUE
[09:31:36.894]                             break
[09:31:36.894]                           }
[09:31:36.894]                         }
[09:31:36.894]                       }
[09:31:36.894]                       invisible(muffled)
[09:31:36.894]                     }
[09:31:36.894]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.894]                   }
[09:31:36.894]                 }
[09:31:36.894]                 else {
[09:31:36.894]                   if (TRUE) {
[09:31:36.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.894]                     {
[09:31:36.894]                       inherits <- base::inherits
[09:31:36.894]                       invokeRestart <- base::invokeRestart
[09:31:36.894]                       is.null <- base::is.null
[09:31:36.894]                       muffled <- FALSE
[09:31:36.894]                       if (inherits(cond, "message")) {
[09:31:36.894]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.894]                         if (muffled) 
[09:31:36.894]                           invokeRestart("muffleMessage")
[09:31:36.894]                       }
[09:31:36.894]                       else if (inherits(cond, "warning")) {
[09:31:36.894]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.894]                         if (muffled) 
[09:31:36.894]                           invokeRestart("muffleWarning")
[09:31:36.894]                       }
[09:31:36.894]                       else if (inherits(cond, "condition")) {
[09:31:36.894]                         if (!is.null(pattern)) {
[09:31:36.894]                           computeRestarts <- base::computeRestarts
[09:31:36.894]                           grepl <- base::grepl
[09:31:36.894]                           restarts <- computeRestarts(cond)
[09:31:36.894]                           for (restart in restarts) {
[09:31:36.894]                             name <- restart$name
[09:31:36.894]                             if (is.null(name)) 
[09:31:36.894]                               next
[09:31:36.894]                             if (!grepl(pattern, name)) 
[09:31:36.894]                               next
[09:31:36.894]                             invokeRestart(restart)
[09:31:36.894]                             muffled <- TRUE
[09:31:36.894]                             break
[09:31:36.894]                           }
[09:31:36.894]                         }
[09:31:36.894]                       }
[09:31:36.894]                       invisible(muffled)
[09:31:36.894]                     }
[09:31:36.894]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.894]                   }
[09:31:36.894]                 }
[09:31:36.894]             }
[09:31:36.894]         }))
[09:31:36.894]     }, error = function(ex) {
[09:31:36.894]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.894]                 ...future.rng), started = ...future.startTime, 
[09:31:36.894]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.894]             version = "1.8"), class = "FutureResult")
[09:31:36.894]     }, finally = {
[09:31:36.894]         if (!identical(...future.workdir, getwd())) 
[09:31:36.894]             setwd(...future.workdir)
[09:31:36.894]         {
[09:31:36.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.894]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.894]             }
[09:31:36.894]             base::options(...future.oldOptions)
[09:31:36.894]             if (.Platform$OS.type == "windows") {
[09:31:36.894]                 old_names <- names(...future.oldEnvVars)
[09:31:36.894]                 envs <- base::Sys.getenv()
[09:31:36.894]                 names <- names(envs)
[09:31:36.894]                 common <- intersect(names, old_names)
[09:31:36.894]                 added <- setdiff(names, old_names)
[09:31:36.894]                 removed <- setdiff(old_names, names)
[09:31:36.894]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.894]                   envs[common]]
[09:31:36.894]                 NAMES <- toupper(changed)
[09:31:36.894]                 args <- list()
[09:31:36.894]                 for (kk in seq_along(NAMES)) {
[09:31:36.894]                   name <- changed[[kk]]
[09:31:36.894]                   NAME <- NAMES[[kk]]
[09:31:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.894]                     next
[09:31:36.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.894]                 }
[09:31:36.894]                 NAMES <- toupper(added)
[09:31:36.894]                 for (kk in seq_along(NAMES)) {
[09:31:36.894]                   name <- added[[kk]]
[09:31:36.894]                   NAME <- NAMES[[kk]]
[09:31:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.894]                     next
[09:31:36.894]                   args[[name]] <- ""
[09:31:36.894]                 }
[09:31:36.894]                 NAMES <- toupper(removed)
[09:31:36.894]                 for (kk in seq_along(NAMES)) {
[09:31:36.894]                   name <- removed[[kk]]
[09:31:36.894]                   NAME <- NAMES[[kk]]
[09:31:36.894]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.894]                     next
[09:31:36.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.894]                 }
[09:31:36.894]                 if (length(args) > 0) 
[09:31:36.894]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.894]             }
[09:31:36.894]             else {
[09:31:36.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.894]             }
[09:31:36.894]             {
[09:31:36.894]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.894]                   0L) {
[09:31:36.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.894]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.894]                   base::options(opts)
[09:31:36.894]                 }
[09:31:36.894]                 {
[09:31:36.894]                   {
[09:31:36.894]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.894]                     NULL
[09:31:36.894]                   }
[09:31:36.894]                   options(future.plan = NULL)
[09:31:36.894]                   if (is.na(NA_character_)) 
[09:31:36.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.894]                     .init = FALSE)
[09:31:36.894]                 }
[09:31:36.894]             }
[09:31:36.894]         }
[09:31:36.894]     })
[09:31:36.894]     if (TRUE) {
[09:31:36.894]         base::sink(type = "output", split = FALSE)
[09:31:36.894]         if (TRUE) {
[09:31:36.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.894]         }
[09:31:36.894]         else {
[09:31:36.894]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.894]         }
[09:31:36.894]         base::close(...future.stdout)
[09:31:36.894]         ...future.stdout <- NULL
[09:31:36.894]     }
[09:31:36.894]     ...future.result$conditions <- ...future.conditions
[09:31:36.894]     ...future.result$finished <- base::Sys.time()
[09:31:36.894]     ...future.result
[09:31:36.894] }
[09:31:36.897] Exporting 2 global objects (112 bytes) to cluster node #1 ...
[09:31:36.897] Exporting ‘a’ (56 bytes) to cluster node #1 ...
[09:31:36.897] Exporting ‘a’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.898] Exporting ‘ii’ (56 bytes) to cluster node #1 ...
[09:31:36.898] Exporting ‘ii’ (56 bytes) to cluster node #1 ... DONE
[09:31:36.898] Exporting 2 global objects (112 bytes) to cluster node #1 ... DONE
[09:31:36.898] MultisessionFuture started
[09:31:36.899] - Launch lazy future ... done
[09:31:36.899] run() for ‘MultisessionFuture’ ... done
[09:31:36.899] result() for ClusterFuture ...
[09:31:36.899] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.899] - Validating connection of MultisessionFuture
[09:31:36.900] - received message: FutureResult
[09:31:36.900] - Received FutureResult
[09:31:36.900] - Erased future from FutureRegistry
[09:31:36.901] result() for ClusterFuture ...
[09:31:36.901] - result already collected: FutureResult
[09:31:36.901] result() for ClusterFuture ... done
[09:31:36.901] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.901] result() for ClusterFuture ... done
[09:31:36.901] result() for ClusterFuture ...
[09:31:36.901] - result already collected: FutureResult
[09:31:36.901] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.902] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.902] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.902] 
[09:31:36.902] Searching for globals ... DONE
[09:31:36.902] - globals: [0] <none>
[09:31:36.902] getGlobalsAndPackages() ... DONE
[09:31:36.903] run() for ‘Future’ ...
[09:31:36.903] - state: ‘created’
[09:31:36.903] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.917]   - Field: ‘node’
[09:31:36.917]   - Field: ‘label’
[09:31:36.917]   - Field: ‘local’
[09:31:36.917]   - Field: ‘owner’
[09:31:36.917]   - Field: ‘envir’
[09:31:36.917]   - Field: ‘workers’
[09:31:36.918]   - Field: ‘packages’
[09:31:36.918]   - Field: ‘gc’
[09:31:36.918]   - Field: ‘conditions’
[09:31:36.918]   - Field: ‘persistent’
[09:31:36.918]   - Field: ‘expr’
[09:31:36.918]   - Field: ‘uuid’
[09:31:36.918]   - Field: ‘seed’
[09:31:36.918]   - Field: ‘version’
[09:31:36.918]   - Field: ‘result’
[09:31:36.918]   - Field: ‘asynchronous’
[09:31:36.918]   - Field: ‘calls’
[09:31:36.918]   - Field: ‘globals’
[09:31:36.919]   - Field: ‘stdout’
[09:31:36.919]   - Field: ‘earlySignal’
[09:31:36.919]   - Field: ‘lazy’
[09:31:36.919]   - Field: ‘state’
[09:31:36.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.919] - Launch lazy future ...
[09:31:36.919] Packages needed by the future expression (n = 0): <none>
[09:31:36.919] Packages needed by future strategies (n = 0): <none>
[09:31:36.920] {
[09:31:36.920]     {
[09:31:36.920]         {
[09:31:36.920]             ...future.startTime <- base::Sys.time()
[09:31:36.920]             {
[09:31:36.920]                 {
[09:31:36.920]                   {
[09:31:36.920]                     {
[09:31:36.920]                       base::local({
[09:31:36.920]                         has_future <- base::requireNamespace("future", 
[09:31:36.920]                           quietly = TRUE)
[09:31:36.920]                         if (has_future) {
[09:31:36.920]                           ns <- base::getNamespace("future")
[09:31:36.920]                           version <- ns[[".package"]][["version"]]
[09:31:36.920]                           if (is.null(version)) 
[09:31:36.920]                             version <- utils::packageVersion("future")
[09:31:36.920]                         }
[09:31:36.920]                         else {
[09:31:36.920]                           version <- NULL
[09:31:36.920]                         }
[09:31:36.920]                         if (!has_future || version < "1.8.0") {
[09:31:36.920]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.920]                             "", base::R.version$version.string), 
[09:31:36.920]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:36.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:36.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.920]                               "release", "version")], collapse = " "), 
[09:31:36.920]                             hostname = base::Sys.info()[["nodename"]])
[09:31:36.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.920]                             info)
[09:31:36.920]                           info <- base::paste(info, collapse = "; ")
[09:31:36.920]                           if (!has_future) {
[09:31:36.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.920]                               info)
[09:31:36.920]                           }
[09:31:36.920]                           else {
[09:31:36.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.920]                               info, version)
[09:31:36.920]                           }
[09:31:36.920]                           base::stop(msg)
[09:31:36.920]                         }
[09:31:36.920]                       })
[09:31:36.920]                     }
[09:31:36.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.920]                     base::options(mc.cores = 1L)
[09:31:36.920]                   }
[09:31:36.920]                   ...future.strategy.old <- future::plan("list")
[09:31:36.920]                   options(future.plan = NULL)
[09:31:36.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.920]                 }
[09:31:36.920]                 ...future.workdir <- getwd()
[09:31:36.920]             }
[09:31:36.920]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.920]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.920]         }
[09:31:36.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.920]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.920]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.920]             base::names(...future.oldOptions))
[09:31:36.920]     }
[09:31:36.920]     if (FALSE) {
[09:31:36.920]     }
[09:31:36.920]     else {
[09:31:36.920]         if (TRUE) {
[09:31:36.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.920]                 open = "w")
[09:31:36.920]         }
[09:31:36.920]         else {
[09:31:36.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.920]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.920]         }
[09:31:36.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.920]             base::sink(type = "output", split = FALSE)
[09:31:36.920]             base::close(...future.stdout)
[09:31:36.920]         }, add = TRUE)
[09:31:36.920]     }
[09:31:36.920]     ...future.frame <- base::sys.nframe()
[09:31:36.920]     ...future.conditions <- base::list()
[09:31:36.920]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.920]     if (FALSE) {
[09:31:36.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.920]     }
[09:31:36.920]     ...future.result <- base::tryCatch({
[09:31:36.920]         base::withCallingHandlers({
[09:31:36.920]             ...future.value <- base::withVisible(base::local({
[09:31:36.920]                 ...future.makeSendCondition <- base::local({
[09:31:36.920]                   sendCondition <- NULL
[09:31:36.920]                   function(frame = 1L) {
[09:31:36.920]                     if (is.function(sendCondition)) 
[09:31:36.920]                       return(sendCondition)
[09:31:36.920]                     ns <- getNamespace("parallel")
[09:31:36.920]                     if (exists("sendData", mode = "function", 
[09:31:36.920]                       envir = ns)) {
[09:31:36.920]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.920]                         envir = ns)
[09:31:36.920]                       envir <- sys.frame(frame)
[09:31:36.920]                       master <- NULL
[09:31:36.920]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.920]                         !identical(envir, emptyenv())) {
[09:31:36.920]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.920]                           inherits = FALSE)) {
[09:31:36.920]                           master <- get("master", mode = "list", 
[09:31:36.920]                             envir = envir, inherits = FALSE)
[09:31:36.920]                           if (inherits(master, c("SOCKnode", 
[09:31:36.920]                             "SOCK0node"))) {
[09:31:36.920]                             sendCondition <<- function(cond) {
[09:31:36.920]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.920]                                 success = TRUE)
[09:31:36.920]                               parallel_sendData(master, data)
[09:31:36.920]                             }
[09:31:36.920]                             return(sendCondition)
[09:31:36.920]                           }
[09:31:36.920]                         }
[09:31:36.920]                         frame <- frame + 1L
[09:31:36.920]                         envir <- sys.frame(frame)
[09:31:36.920]                       }
[09:31:36.920]                     }
[09:31:36.920]                     sendCondition <<- function(cond) NULL
[09:31:36.920]                   }
[09:31:36.920]                 })
[09:31:36.920]                 withCallingHandlers({
[09:31:36.920]                   1
[09:31:36.920]                 }, immediateCondition = function(cond) {
[09:31:36.920]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.920]                   sendCondition(cond)
[09:31:36.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.920]                   {
[09:31:36.920]                     inherits <- base::inherits
[09:31:36.920]                     invokeRestart <- base::invokeRestart
[09:31:36.920]                     is.null <- base::is.null
[09:31:36.920]                     muffled <- FALSE
[09:31:36.920]                     if (inherits(cond, "message")) {
[09:31:36.920]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.920]                       if (muffled) 
[09:31:36.920]                         invokeRestart("muffleMessage")
[09:31:36.920]                     }
[09:31:36.920]                     else if (inherits(cond, "warning")) {
[09:31:36.920]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.920]                       if (muffled) 
[09:31:36.920]                         invokeRestart("muffleWarning")
[09:31:36.920]                     }
[09:31:36.920]                     else if (inherits(cond, "condition")) {
[09:31:36.920]                       if (!is.null(pattern)) {
[09:31:36.920]                         computeRestarts <- base::computeRestarts
[09:31:36.920]                         grepl <- base::grepl
[09:31:36.920]                         restarts <- computeRestarts(cond)
[09:31:36.920]                         for (restart in restarts) {
[09:31:36.920]                           name <- restart$name
[09:31:36.920]                           if (is.null(name)) 
[09:31:36.920]                             next
[09:31:36.920]                           if (!grepl(pattern, name)) 
[09:31:36.920]                             next
[09:31:36.920]                           invokeRestart(restart)
[09:31:36.920]                           muffled <- TRUE
[09:31:36.920]                           break
[09:31:36.920]                         }
[09:31:36.920]                       }
[09:31:36.920]                     }
[09:31:36.920]                     invisible(muffled)
[09:31:36.920]                   }
[09:31:36.920]                   muffleCondition(cond)
[09:31:36.920]                 })
[09:31:36.920]             }))
[09:31:36.920]             future::FutureResult(value = ...future.value$value, 
[09:31:36.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.920]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.920]                     ...future.globalenv.names))
[09:31:36.920]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.920]         }, condition = base::local({
[09:31:36.920]             c <- base::c
[09:31:36.920]             inherits <- base::inherits
[09:31:36.920]             invokeRestart <- base::invokeRestart
[09:31:36.920]             length <- base::length
[09:31:36.920]             list <- base::list
[09:31:36.920]             seq.int <- base::seq.int
[09:31:36.920]             signalCondition <- base::signalCondition
[09:31:36.920]             sys.calls <- base::sys.calls
[09:31:36.920]             `[[` <- base::`[[`
[09:31:36.920]             `+` <- base::`+`
[09:31:36.920]             `<<-` <- base::`<<-`
[09:31:36.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.920]                   3L)]
[09:31:36.920]             }
[09:31:36.920]             function(cond) {
[09:31:36.920]                 is_error <- inherits(cond, "error")
[09:31:36.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.920]                   NULL)
[09:31:36.920]                 if (is_error) {
[09:31:36.920]                   sessionInformation <- function() {
[09:31:36.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.920]                       search = base::search(), system = base::Sys.info())
[09:31:36.920]                   }
[09:31:36.920]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.920]                     cond$call), session = sessionInformation(), 
[09:31:36.920]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.920]                   signalCondition(cond)
[09:31:36.920]                 }
[09:31:36.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.920]                 "immediateCondition"))) {
[09:31:36.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.920]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.920]                   if (TRUE && !signal) {
[09:31:36.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.920]                     {
[09:31:36.920]                       inherits <- base::inherits
[09:31:36.920]                       invokeRestart <- base::invokeRestart
[09:31:36.920]                       is.null <- base::is.null
[09:31:36.920]                       muffled <- FALSE
[09:31:36.920]                       if (inherits(cond, "message")) {
[09:31:36.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.920]                         if (muffled) 
[09:31:36.920]                           invokeRestart("muffleMessage")
[09:31:36.920]                       }
[09:31:36.920]                       else if (inherits(cond, "warning")) {
[09:31:36.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.920]                         if (muffled) 
[09:31:36.920]                           invokeRestart("muffleWarning")
[09:31:36.920]                       }
[09:31:36.920]                       else if (inherits(cond, "condition")) {
[09:31:36.920]                         if (!is.null(pattern)) {
[09:31:36.920]                           computeRestarts <- base::computeRestarts
[09:31:36.920]                           grepl <- base::grepl
[09:31:36.920]                           restarts <- computeRestarts(cond)
[09:31:36.920]                           for (restart in restarts) {
[09:31:36.920]                             name <- restart$name
[09:31:36.920]                             if (is.null(name)) 
[09:31:36.920]                               next
[09:31:36.920]                             if (!grepl(pattern, name)) 
[09:31:36.920]                               next
[09:31:36.920]                             invokeRestart(restart)
[09:31:36.920]                             muffled <- TRUE
[09:31:36.920]                             break
[09:31:36.920]                           }
[09:31:36.920]                         }
[09:31:36.920]                       }
[09:31:36.920]                       invisible(muffled)
[09:31:36.920]                     }
[09:31:36.920]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.920]                   }
[09:31:36.920]                 }
[09:31:36.920]                 else {
[09:31:36.920]                   if (TRUE) {
[09:31:36.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.920]                     {
[09:31:36.920]                       inherits <- base::inherits
[09:31:36.920]                       invokeRestart <- base::invokeRestart
[09:31:36.920]                       is.null <- base::is.null
[09:31:36.920]                       muffled <- FALSE
[09:31:36.920]                       if (inherits(cond, "message")) {
[09:31:36.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.920]                         if (muffled) 
[09:31:36.920]                           invokeRestart("muffleMessage")
[09:31:36.920]                       }
[09:31:36.920]                       else if (inherits(cond, "warning")) {
[09:31:36.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.920]                         if (muffled) 
[09:31:36.920]                           invokeRestart("muffleWarning")
[09:31:36.920]                       }
[09:31:36.920]                       else if (inherits(cond, "condition")) {
[09:31:36.920]                         if (!is.null(pattern)) {
[09:31:36.920]                           computeRestarts <- base::computeRestarts
[09:31:36.920]                           grepl <- base::grepl
[09:31:36.920]                           restarts <- computeRestarts(cond)
[09:31:36.920]                           for (restart in restarts) {
[09:31:36.920]                             name <- restart$name
[09:31:36.920]                             if (is.null(name)) 
[09:31:36.920]                               next
[09:31:36.920]                             if (!grepl(pattern, name)) 
[09:31:36.920]                               next
[09:31:36.920]                             invokeRestart(restart)
[09:31:36.920]                             muffled <- TRUE
[09:31:36.920]                             break
[09:31:36.920]                           }
[09:31:36.920]                         }
[09:31:36.920]                       }
[09:31:36.920]                       invisible(muffled)
[09:31:36.920]                     }
[09:31:36.920]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.920]                   }
[09:31:36.920]                 }
[09:31:36.920]             }
[09:31:36.920]         }))
[09:31:36.920]     }, error = function(ex) {
[09:31:36.920]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.920]                 ...future.rng), started = ...future.startTime, 
[09:31:36.920]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.920]             version = "1.8"), class = "FutureResult")
[09:31:36.920]     }, finally = {
[09:31:36.920]         if (!identical(...future.workdir, getwd())) 
[09:31:36.920]             setwd(...future.workdir)
[09:31:36.920]         {
[09:31:36.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.920]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.920]             }
[09:31:36.920]             base::options(...future.oldOptions)
[09:31:36.920]             if (.Platform$OS.type == "windows") {
[09:31:36.920]                 old_names <- names(...future.oldEnvVars)
[09:31:36.920]                 envs <- base::Sys.getenv()
[09:31:36.920]                 names <- names(envs)
[09:31:36.920]                 common <- intersect(names, old_names)
[09:31:36.920]                 added <- setdiff(names, old_names)
[09:31:36.920]                 removed <- setdiff(old_names, names)
[09:31:36.920]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.920]                   envs[common]]
[09:31:36.920]                 NAMES <- toupper(changed)
[09:31:36.920]                 args <- list()
[09:31:36.920]                 for (kk in seq_along(NAMES)) {
[09:31:36.920]                   name <- changed[[kk]]
[09:31:36.920]                   NAME <- NAMES[[kk]]
[09:31:36.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.920]                     next
[09:31:36.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.920]                 }
[09:31:36.920]                 NAMES <- toupper(added)
[09:31:36.920]                 for (kk in seq_along(NAMES)) {
[09:31:36.920]                   name <- added[[kk]]
[09:31:36.920]                   NAME <- NAMES[[kk]]
[09:31:36.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.920]                     next
[09:31:36.920]                   args[[name]] <- ""
[09:31:36.920]                 }
[09:31:36.920]                 NAMES <- toupper(removed)
[09:31:36.920]                 for (kk in seq_along(NAMES)) {
[09:31:36.920]                   name <- removed[[kk]]
[09:31:36.920]                   NAME <- NAMES[[kk]]
[09:31:36.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.920]                     next
[09:31:36.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.920]                 }
[09:31:36.920]                 if (length(args) > 0) 
[09:31:36.920]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.920]             }
[09:31:36.920]             else {
[09:31:36.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.920]             }
[09:31:36.920]             {
[09:31:36.920]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.920]                   0L) {
[09:31:36.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.920]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.920]                   base::options(opts)
[09:31:36.920]                 }
[09:31:36.920]                 {
[09:31:36.920]                   {
[09:31:36.920]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.920]                     NULL
[09:31:36.920]                   }
[09:31:36.920]                   options(future.plan = NULL)
[09:31:36.920]                   if (is.na(NA_character_)) 
[09:31:36.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.920]                     .init = FALSE)
[09:31:36.920]                 }
[09:31:36.920]             }
[09:31:36.920]         }
[09:31:36.920]     })
[09:31:36.920]     if (TRUE) {
[09:31:36.920]         base::sink(type = "output", split = FALSE)
[09:31:36.920]         if (TRUE) {
[09:31:36.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.920]         }
[09:31:36.920]         else {
[09:31:36.920]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.920]         }
[09:31:36.920]         base::close(...future.stdout)
[09:31:36.920]         ...future.stdout <- NULL
[09:31:36.920]     }
[09:31:36.920]     ...future.result$conditions <- ...future.conditions
[09:31:36.920]     ...future.result$finished <- base::Sys.time()
[09:31:36.920]     ...future.result
[09:31:36.920] }
[09:31:36.922] MultisessionFuture started
[09:31:36.923] - Launch lazy future ... done
[09:31:36.923] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:36.923] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:36.923] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:36.925] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:36.925] Searching for globals ... DONE
[09:31:36.925] Resolving globals: TRUE
[09:31:36.925] Resolving any globals that are futures ...
[09:31:36.925] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:36.925] Resolving any globals that are futures ... DONE
[09:31:36.925] Resolving futures part of globals (recursively) ...
[09:31:36.926] resolve() on list ...
[09:31:36.926]  recursive: 99
[09:31:36.926]  length: 1
[09:31:36.926]  elements: ‘a’
[09:31:36.926] receiveMessageFromWorker() for ClusterFuture ...
[09:31:36.927] - Validating connection of MultisessionFuture
[09:31:36.927] - received message: FutureResult
[09:31:36.927] - Received FutureResult
[09:31:36.927] - Erased future from FutureRegistry
[09:31:36.927] result() for ClusterFuture ...
[09:31:36.927] - result already collected: FutureResult
[09:31:36.927] result() for ClusterFuture ... done
[09:31:36.927] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:36.927] Future #1
[09:31:36.927] result() for ClusterFuture ...
[09:31:36.927] - result already collected: FutureResult
[09:31:36.928] result() for ClusterFuture ... done
[09:31:36.928] result() for ClusterFuture ...
[09:31:36.928] - result already collected: FutureResult
[09:31:36.928] result() for ClusterFuture ... done
[09:31:36.928] A MultisessionFuture was resolved
[09:31:36.928]  length: 0 (resolved future 1)
[09:31:36.928] resolve() on list ... DONE
[09:31:36.928] - globals: [1] ‘a’
[09:31:36.928] Resolving futures part of globals (recursively) ... DONE
[09:31:36.930] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[09:31:36.931] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:36.931] - globals: [1] ‘a’
[09:31:36.931] - packages: [1] ‘future’
[09:31:36.931] getGlobalsAndPackages() ... DONE
[09:31:36.931] run() for ‘Future’ ...
[09:31:36.931] - state: ‘created’
[09:31:36.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:36.944] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:36.945] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:36.945]   - Field: ‘node’
[09:31:36.945]   - Field: ‘label’
[09:31:36.945]   - Field: ‘local’
[09:31:36.945]   - Field: ‘owner’
[09:31:36.945]   - Field: ‘envir’
[09:31:36.945]   - Field: ‘workers’
[09:31:36.945]   - Field: ‘packages’
[09:31:36.945]   - Field: ‘gc’
[09:31:36.945]   - Field: ‘conditions’
[09:31:36.946]   - Field: ‘persistent’
[09:31:36.946]   - Field: ‘expr’
[09:31:36.946]   - Field: ‘uuid’
[09:31:36.946]   - Field: ‘seed’
[09:31:36.946]   - Field: ‘version’
[09:31:36.946]   - Field: ‘result’
[09:31:36.946]   - Field: ‘asynchronous’
[09:31:36.946]   - Field: ‘calls’
[09:31:36.946]   - Field: ‘globals’
[09:31:36.946]   - Field: ‘stdout’
[09:31:36.946]   - Field: ‘earlySignal’
[09:31:36.947]   - Field: ‘lazy’
[09:31:36.947]   - Field: ‘state’
[09:31:36.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:36.947] - Launch lazy future ...
[09:31:36.947] Packages needed by the future expression (n = 1): ‘future’
[09:31:36.947] Packages needed by future strategies (n = 0): <none>
[09:31:36.948] {
[09:31:36.948]     {
[09:31:36.948]         {
[09:31:36.948]             ...future.startTime <- base::Sys.time()
[09:31:36.948]             {
[09:31:36.948]                 {
[09:31:36.948]                   {
[09:31:36.948]                     {
[09:31:36.948]                       {
[09:31:36.948]                         base::local({
[09:31:36.948]                           has_future <- base::requireNamespace("future", 
[09:31:36.948]                             quietly = TRUE)
[09:31:36.948]                           if (has_future) {
[09:31:36.948]                             ns <- base::getNamespace("future")
[09:31:36.948]                             version <- ns[[".package"]][["version"]]
[09:31:36.948]                             if (is.null(version)) 
[09:31:36.948]                               version <- utils::packageVersion("future")
[09:31:36.948]                           }
[09:31:36.948]                           else {
[09:31:36.948]                             version <- NULL
[09:31:36.948]                           }
[09:31:36.948]                           if (!has_future || version < "1.8.0") {
[09:31:36.948]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:36.948]                               "", base::R.version$version.string), 
[09:31:36.948]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:36.948]                                 base::R.version$platform, 8 * 
[09:31:36.948]                                   base::.Machine$sizeof.pointer), 
[09:31:36.948]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:36.948]                                 "release", "version")], collapse = " "), 
[09:31:36.948]                               hostname = base::Sys.info()[["nodename"]])
[09:31:36.948]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:36.948]                               info)
[09:31:36.948]                             info <- base::paste(info, collapse = "; ")
[09:31:36.948]                             if (!has_future) {
[09:31:36.948]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:36.948]                                 info)
[09:31:36.948]                             }
[09:31:36.948]                             else {
[09:31:36.948]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:36.948]                                 info, version)
[09:31:36.948]                             }
[09:31:36.948]                             base::stop(msg)
[09:31:36.948]                           }
[09:31:36.948]                         })
[09:31:36.948]                       }
[09:31:36.948]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:36.948]                       base::options(mc.cores = 1L)
[09:31:36.948]                     }
[09:31:36.948]                     base::local({
[09:31:36.948]                       for (pkg in "future") {
[09:31:36.948]                         base::loadNamespace(pkg)
[09:31:36.948]                         base::library(pkg, character.only = TRUE)
[09:31:36.948]                       }
[09:31:36.948]                     })
[09:31:36.948]                   }
[09:31:36.948]                   ...future.strategy.old <- future::plan("list")
[09:31:36.948]                   options(future.plan = NULL)
[09:31:36.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:36.948]                 }
[09:31:36.948]                 ...future.workdir <- getwd()
[09:31:36.948]             }
[09:31:36.948]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:36.948]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:36.948]         }
[09:31:36.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:36.948]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:36.948]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:36.948]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:36.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:36.948]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:36.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:36.948]             base::names(...future.oldOptions))
[09:31:36.948]     }
[09:31:36.948]     if (FALSE) {
[09:31:36.948]     }
[09:31:36.948]     else {
[09:31:36.948]         if (TRUE) {
[09:31:36.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:36.948]                 open = "w")
[09:31:36.948]         }
[09:31:36.948]         else {
[09:31:36.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:36.948]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:36.948]         }
[09:31:36.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:36.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:36.948]             base::sink(type = "output", split = FALSE)
[09:31:36.948]             base::close(...future.stdout)
[09:31:36.948]         }, add = TRUE)
[09:31:36.948]     }
[09:31:36.948]     ...future.frame <- base::sys.nframe()
[09:31:36.948]     ...future.conditions <- base::list()
[09:31:36.948]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:36.948]     if (FALSE) {
[09:31:36.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:36.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:36.948]     }
[09:31:36.948]     ...future.result <- base::tryCatch({
[09:31:36.948]         base::withCallingHandlers({
[09:31:36.948]             ...future.value <- base::withVisible(base::local({
[09:31:36.948]                 ...future.makeSendCondition <- base::local({
[09:31:36.948]                   sendCondition <- NULL
[09:31:36.948]                   function(frame = 1L) {
[09:31:36.948]                     if (is.function(sendCondition)) 
[09:31:36.948]                       return(sendCondition)
[09:31:36.948]                     ns <- getNamespace("parallel")
[09:31:36.948]                     if (exists("sendData", mode = "function", 
[09:31:36.948]                       envir = ns)) {
[09:31:36.948]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:36.948]                         envir = ns)
[09:31:36.948]                       envir <- sys.frame(frame)
[09:31:36.948]                       master <- NULL
[09:31:36.948]                       while (!identical(envir, .GlobalEnv) && 
[09:31:36.948]                         !identical(envir, emptyenv())) {
[09:31:36.948]                         if (exists("master", mode = "list", envir = envir, 
[09:31:36.948]                           inherits = FALSE)) {
[09:31:36.948]                           master <- get("master", mode = "list", 
[09:31:36.948]                             envir = envir, inherits = FALSE)
[09:31:36.948]                           if (inherits(master, c("SOCKnode", 
[09:31:36.948]                             "SOCK0node"))) {
[09:31:36.948]                             sendCondition <<- function(cond) {
[09:31:36.948]                               data <- list(type = "VALUE", value = cond, 
[09:31:36.948]                                 success = TRUE)
[09:31:36.948]                               parallel_sendData(master, data)
[09:31:36.948]                             }
[09:31:36.948]                             return(sendCondition)
[09:31:36.948]                           }
[09:31:36.948]                         }
[09:31:36.948]                         frame <- frame + 1L
[09:31:36.948]                         envir <- sys.frame(frame)
[09:31:36.948]                       }
[09:31:36.948]                     }
[09:31:36.948]                     sendCondition <<- function(cond) NULL
[09:31:36.948]                   }
[09:31:36.948]                 })
[09:31:36.948]                 withCallingHandlers({
[09:31:36.948]                   value(a) + 1
[09:31:36.948]                 }, immediateCondition = function(cond) {
[09:31:36.948]                   sendCondition <- ...future.makeSendCondition()
[09:31:36.948]                   sendCondition(cond)
[09:31:36.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.948]                   {
[09:31:36.948]                     inherits <- base::inherits
[09:31:36.948]                     invokeRestart <- base::invokeRestart
[09:31:36.948]                     is.null <- base::is.null
[09:31:36.948]                     muffled <- FALSE
[09:31:36.948]                     if (inherits(cond, "message")) {
[09:31:36.948]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:36.948]                       if (muffled) 
[09:31:36.948]                         invokeRestart("muffleMessage")
[09:31:36.948]                     }
[09:31:36.948]                     else if (inherits(cond, "warning")) {
[09:31:36.948]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:36.948]                       if (muffled) 
[09:31:36.948]                         invokeRestart("muffleWarning")
[09:31:36.948]                     }
[09:31:36.948]                     else if (inherits(cond, "condition")) {
[09:31:36.948]                       if (!is.null(pattern)) {
[09:31:36.948]                         computeRestarts <- base::computeRestarts
[09:31:36.948]                         grepl <- base::grepl
[09:31:36.948]                         restarts <- computeRestarts(cond)
[09:31:36.948]                         for (restart in restarts) {
[09:31:36.948]                           name <- restart$name
[09:31:36.948]                           if (is.null(name)) 
[09:31:36.948]                             next
[09:31:36.948]                           if (!grepl(pattern, name)) 
[09:31:36.948]                             next
[09:31:36.948]                           invokeRestart(restart)
[09:31:36.948]                           muffled <- TRUE
[09:31:36.948]                           break
[09:31:36.948]                         }
[09:31:36.948]                       }
[09:31:36.948]                     }
[09:31:36.948]                     invisible(muffled)
[09:31:36.948]                   }
[09:31:36.948]                   muffleCondition(cond)
[09:31:36.948]                 })
[09:31:36.948]             }))
[09:31:36.948]             future::FutureResult(value = ...future.value$value, 
[09:31:36.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.948]                   ...future.rng), globalenv = if (FALSE) 
[09:31:36.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:36.948]                     ...future.globalenv.names))
[09:31:36.948]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:36.948]         }, condition = base::local({
[09:31:36.948]             c <- base::c
[09:31:36.948]             inherits <- base::inherits
[09:31:36.948]             invokeRestart <- base::invokeRestart
[09:31:36.948]             length <- base::length
[09:31:36.948]             list <- base::list
[09:31:36.948]             seq.int <- base::seq.int
[09:31:36.948]             signalCondition <- base::signalCondition
[09:31:36.948]             sys.calls <- base::sys.calls
[09:31:36.948]             `[[` <- base::`[[`
[09:31:36.948]             `+` <- base::`+`
[09:31:36.948]             `<<-` <- base::`<<-`
[09:31:36.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:36.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:36.948]                   3L)]
[09:31:36.948]             }
[09:31:36.948]             function(cond) {
[09:31:36.948]                 is_error <- inherits(cond, "error")
[09:31:36.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:36.948]                   NULL)
[09:31:36.948]                 if (is_error) {
[09:31:36.948]                   sessionInformation <- function() {
[09:31:36.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:36.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:36.948]                       search = base::search(), system = base::Sys.info())
[09:31:36.948]                   }
[09:31:36.948]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:36.948]                     cond$call), session = sessionInformation(), 
[09:31:36.948]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:36.948]                   signalCondition(cond)
[09:31:36.948]                 }
[09:31:36.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:36.948]                 "immediateCondition"))) {
[09:31:36.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:36.948]                   ...future.conditions[[length(...future.conditions) + 
[09:31:36.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:36.948]                   if (TRUE && !signal) {
[09:31:36.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.948]                     {
[09:31:36.948]                       inherits <- base::inherits
[09:31:36.948]                       invokeRestart <- base::invokeRestart
[09:31:36.948]                       is.null <- base::is.null
[09:31:36.948]                       muffled <- FALSE
[09:31:36.948]                       if (inherits(cond, "message")) {
[09:31:36.948]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.948]                         if (muffled) 
[09:31:36.948]                           invokeRestart("muffleMessage")
[09:31:36.948]                       }
[09:31:36.948]                       else if (inherits(cond, "warning")) {
[09:31:36.948]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.948]                         if (muffled) 
[09:31:36.948]                           invokeRestart("muffleWarning")
[09:31:36.948]                       }
[09:31:36.948]                       else if (inherits(cond, "condition")) {
[09:31:36.948]                         if (!is.null(pattern)) {
[09:31:36.948]                           computeRestarts <- base::computeRestarts
[09:31:36.948]                           grepl <- base::grepl
[09:31:36.948]                           restarts <- computeRestarts(cond)
[09:31:36.948]                           for (restart in restarts) {
[09:31:36.948]                             name <- restart$name
[09:31:36.948]                             if (is.null(name)) 
[09:31:36.948]                               next
[09:31:36.948]                             if (!grepl(pattern, name)) 
[09:31:36.948]                               next
[09:31:36.948]                             invokeRestart(restart)
[09:31:36.948]                             muffled <- TRUE
[09:31:36.948]                             break
[09:31:36.948]                           }
[09:31:36.948]                         }
[09:31:36.948]                       }
[09:31:36.948]                       invisible(muffled)
[09:31:36.948]                     }
[09:31:36.948]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.948]                   }
[09:31:36.948]                 }
[09:31:36.948]                 else {
[09:31:36.948]                   if (TRUE) {
[09:31:36.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:36.948]                     {
[09:31:36.948]                       inherits <- base::inherits
[09:31:36.948]                       invokeRestart <- base::invokeRestart
[09:31:36.948]                       is.null <- base::is.null
[09:31:36.948]                       muffled <- FALSE
[09:31:36.948]                       if (inherits(cond, "message")) {
[09:31:36.948]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:36.948]                         if (muffled) 
[09:31:36.948]                           invokeRestart("muffleMessage")
[09:31:36.948]                       }
[09:31:36.948]                       else if (inherits(cond, "warning")) {
[09:31:36.948]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:36.948]                         if (muffled) 
[09:31:36.948]                           invokeRestart("muffleWarning")
[09:31:36.948]                       }
[09:31:36.948]                       else if (inherits(cond, "condition")) {
[09:31:36.948]                         if (!is.null(pattern)) {
[09:31:36.948]                           computeRestarts <- base::computeRestarts
[09:31:36.948]                           grepl <- base::grepl
[09:31:36.948]                           restarts <- computeRestarts(cond)
[09:31:36.948]                           for (restart in restarts) {
[09:31:36.948]                             name <- restart$name
[09:31:36.948]                             if (is.null(name)) 
[09:31:36.948]                               next
[09:31:36.948]                             if (!grepl(pattern, name)) 
[09:31:36.948]                               next
[09:31:36.948]                             invokeRestart(restart)
[09:31:36.948]                             muffled <- TRUE
[09:31:36.948]                             break
[09:31:36.948]                           }
[09:31:36.948]                         }
[09:31:36.948]                       }
[09:31:36.948]                       invisible(muffled)
[09:31:36.948]                     }
[09:31:36.948]                     muffleCondition(cond, pattern = "^muffle")
[09:31:36.948]                   }
[09:31:36.948]                 }
[09:31:36.948]             }
[09:31:36.948]         }))
[09:31:36.948]     }, error = function(ex) {
[09:31:36.948]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:36.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:36.948]                 ...future.rng), started = ...future.startTime, 
[09:31:36.948]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:36.948]             version = "1.8"), class = "FutureResult")
[09:31:36.948]     }, finally = {
[09:31:36.948]         if (!identical(...future.workdir, getwd())) 
[09:31:36.948]             setwd(...future.workdir)
[09:31:36.948]         {
[09:31:36.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:36.948]                 ...future.oldOptions$nwarnings <- NULL
[09:31:36.948]             }
[09:31:36.948]             base::options(...future.oldOptions)
[09:31:36.948]             if (.Platform$OS.type == "windows") {
[09:31:36.948]                 old_names <- names(...future.oldEnvVars)
[09:31:36.948]                 envs <- base::Sys.getenv()
[09:31:36.948]                 names <- names(envs)
[09:31:36.948]                 common <- intersect(names, old_names)
[09:31:36.948]                 added <- setdiff(names, old_names)
[09:31:36.948]                 removed <- setdiff(old_names, names)
[09:31:36.948]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:36.948]                   envs[common]]
[09:31:36.948]                 NAMES <- toupper(changed)
[09:31:36.948]                 args <- list()
[09:31:36.948]                 for (kk in seq_along(NAMES)) {
[09:31:36.948]                   name <- changed[[kk]]
[09:31:36.948]                   NAME <- NAMES[[kk]]
[09:31:36.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.948]                     next
[09:31:36.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.948]                 }
[09:31:36.948]                 NAMES <- toupper(added)
[09:31:36.948]                 for (kk in seq_along(NAMES)) {
[09:31:36.948]                   name <- added[[kk]]
[09:31:36.948]                   NAME <- NAMES[[kk]]
[09:31:36.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.948]                     next
[09:31:36.948]                   args[[name]] <- ""
[09:31:36.948]                 }
[09:31:36.948]                 NAMES <- toupper(removed)
[09:31:36.948]                 for (kk in seq_along(NAMES)) {
[09:31:36.948]                   name <- removed[[kk]]
[09:31:36.948]                   NAME <- NAMES[[kk]]
[09:31:36.948]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:36.948]                     next
[09:31:36.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:36.948]                 }
[09:31:36.948]                 if (length(args) > 0) 
[09:31:36.948]                   base::do.call(base::Sys.setenv, args = args)
[09:31:36.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:36.948]             }
[09:31:36.948]             else {
[09:31:36.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:36.948]             }
[09:31:36.948]             {
[09:31:36.948]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:36.948]                   0L) {
[09:31:36.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:36.948]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:36.948]                   base::options(opts)
[09:31:36.948]                 }
[09:31:36.948]                 {
[09:31:36.948]                   {
[09:31:36.948]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:36.948]                     NULL
[09:31:36.948]                   }
[09:31:36.948]                   options(future.plan = NULL)
[09:31:36.948]                   if (is.na(NA_character_)) 
[09:31:36.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:36.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:36.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:36.948]                     .init = FALSE)
[09:31:36.948]                 }
[09:31:36.948]             }
[09:31:36.948]         }
[09:31:36.948]     })
[09:31:36.948]     if (TRUE) {
[09:31:36.948]         base::sink(type = "output", split = FALSE)
[09:31:36.948]         if (TRUE) {
[09:31:36.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:36.948]         }
[09:31:36.948]         else {
[09:31:36.948]             ...future.result["stdout"] <- base::list(NULL)
[09:31:36.948]         }
[09:31:36.948]         base::close(...future.stdout)
[09:31:36.948]         ...future.stdout <- NULL
[09:31:36.948]     }
[09:31:36.948]     ...future.result$conditions <- ...future.conditions
[09:31:36.948]     ...future.result$finished <- base::Sys.time()
[09:31:36.948]     ...future.result
[09:31:36.948] }
[09:31:36.950] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[09:31:36.952] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[09:31:37.004] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.004] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.005] MultisessionFuture started
[09:31:37.005] - Launch lazy future ... done
[09:31:37.005] run() for ‘MultisessionFuture’ ... done
[09:31:37.005] result() for ClusterFuture ...
[09:31:37.005] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.005] - Validating connection of MultisessionFuture
[09:31:37.053] - received message: FutureResult
[09:31:37.053] - Received FutureResult
[09:31:37.053] - Erased future from FutureRegistry
[09:31:37.054] result() for ClusterFuture ...
[09:31:37.054] - result already collected: FutureResult
[09:31:37.054] result() for ClusterFuture ... done
[09:31:37.054] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.054] result() for ClusterFuture ... done
[09:31:37.054] result() for ClusterFuture ...
[09:31:37.054] - result already collected: FutureResult
[09:31:37.054] result() for ClusterFuture ... done
value(b) = 2
[09:31:37.054] result() for ClusterFuture ...
[09:31:37.054] - result already collected: FutureResult
[09:31:37.055] result() for ClusterFuture ... done
[09:31:37.055] result() for ClusterFuture ...
[09:31:37.055] - result already collected: FutureResult
[09:31:37.055] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.055] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.055] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.056] 
[09:31:37.056] Searching for globals ... DONE
[09:31:37.056] - globals: [0] <none>
[09:31:37.056] getGlobalsAndPackages() ... DONE
[09:31:37.056] run() for ‘Future’ ...
[09:31:37.056] - state: ‘created’
[09:31:37.056] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.070] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.070]   - Field: ‘node’
[09:31:37.070]   - Field: ‘label’
[09:31:37.070]   - Field: ‘local’
[09:31:37.071]   - Field: ‘owner’
[09:31:37.071]   - Field: ‘envir’
[09:31:37.071]   - Field: ‘workers’
[09:31:37.071]   - Field: ‘packages’
[09:31:37.071]   - Field: ‘gc’
[09:31:37.071]   - Field: ‘conditions’
[09:31:37.071]   - Field: ‘persistent’
[09:31:37.071]   - Field: ‘expr’
[09:31:37.071]   - Field: ‘uuid’
[09:31:37.071]   - Field: ‘seed’
[09:31:37.071]   - Field: ‘version’
[09:31:37.071]   - Field: ‘result’
[09:31:37.072]   - Field: ‘asynchronous’
[09:31:37.072]   - Field: ‘calls’
[09:31:37.072]   - Field: ‘globals’
[09:31:37.072]   - Field: ‘stdout’
[09:31:37.072]   - Field: ‘earlySignal’
[09:31:37.072]   - Field: ‘lazy’
[09:31:37.072]   - Field: ‘state’
[09:31:37.072] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.072] - Launch lazy future ...
[09:31:37.073] Packages needed by the future expression (n = 0): <none>
[09:31:37.073] Packages needed by future strategies (n = 0): <none>
[09:31:37.073] {
[09:31:37.073]     {
[09:31:37.073]         {
[09:31:37.073]             ...future.startTime <- base::Sys.time()
[09:31:37.073]             {
[09:31:37.073]                 {
[09:31:37.073]                   {
[09:31:37.073]                     {
[09:31:37.073]                       base::local({
[09:31:37.073]                         has_future <- base::requireNamespace("future", 
[09:31:37.073]                           quietly = TRUE)
[09:31:37.073]                         if (has_future) {
[09:31:37.073]                           ns <- base::getNamespace("future")
[09:31:37.073]                           version <- ns[[".package"]][["version"]]
[09:31:37.073]                           if (is.null(version)) 
[09:31:37.073]                             version <- utils::packageVersion("future")
[09:31:37.073]                         }
[09:31:37.073]                         else {
[09:31:37.073]                           version <- NULL
[09:31:37.073]                         }
[09:31:37.073]                         if (!has_future || version < "1.8.0") {
[09:31:37.073]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.073]                             "", base::R.version$version.string), 
[09:31:37.073]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.073]                               "release", "version")], collapse = " "), 
[09:31:37.073]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.073]                             info)
[09:31:37.073]                           info <- base::paste(info, collapse = "; ")
[09:31:37.073]                           if (!has_future) {
[09:31:37.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.073]                               info)
[09:31:37.073]                           }
[09:31:37.073]                           else {
[09:31:37.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.073]                               info, version)
[09:31:37.073]                           }
[09:31:37.073]                           base::stop(msg)
[09:31:37.073]                         }
[09:31:37.073]                       })
[09:31:37.073]                     }
[09:31:37.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.073]                     base::options(mc.cores = 1L)
[09:31:37.073]                   }
[09:31:37.073]                   ...future.strategy.old <- future::plan("list")
[09:31:37.073]                   options(future.plan = NULL)
[09:31:37.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.073]                 }
[09:31:37.073]                 ...future.workdir <- getwd()
[09:31:37.073]             }
[09:31:37.073]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.073]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.073]         }
[09:31:37.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.073]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.073]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.073]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.073]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.073]             base::names(...future.oldOptions))
[09:31:37.073]     }
[09:31:37.073]     if (FALSE) {
[09:31:37.073]     }
[09:31:37.073]     else {
[09:31:37.073]         if (TRUE) {
[09:31:37.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.073]                 open = "w")
[09:31:37.073]         }
[09:31:37.073]         else {
[09:31:37.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.073]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.073]         }
[09:31:37.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.073]             base::sink(type = "output", split = FALSE)
[09:31:37.073]             base::close(...future.stdout)
[09:31:37.073]         }, add = TRUE)
[09:31:37.073]     }
[09:31:37.073]     ...future.frame <- base::sys.nframe()
[09:31:37.073]     ...future.conditions <- base::list()
[09:31:37.073]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.073]     if (FALSE) {
[09:31:37.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.073]     }
[09:31:37.073]     ...future.result <- base::tryCatch({
[09:31:37.073]         base::withCallingHandlers({
[09:31:37.073]             ...future.value <- base::withVisible(base::local({
[09:31:37.073]                 ...future.makeSendCondition <- base::local({
[09:31:37.073]                   sendCondition <- NULL
[09:31:37.073]                   function(frame = 1L) {
[09:31:37.073]                     if (is.function(sendCondition)) 
[09:31:37.073]                       return(sendCondition)
[09:31:37.073]                     ns <- getNamespace("parallel")
[09:31:37.073]                     if (exists("sendData", mode = "function", 
[09:31:37.073]                       envir = ns)) {
[09:31:37.073]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.073]                         envir = ns)
[09:31:37.073]                       envir <- sys.frame(frame)
[09:31:37.073]                       master <- NULL
[09:31:37.073]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.073]                         !identical(envir, emptyenv())) {
[09:31:37.073]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.073]                           inherits = FALSE)) {
[09:31:37.073]                           master <- get("master", mode = "list", 
[09:31:37.073]                             envir = envir, inherits = FALSE)
[09:31:37.073]                           if (inherits(master, c("SOCKnode", 
[09:31:37.073]                             "SOCK0node"))) {
[09:31:37.073]                             sendCondition <<- function(cond) {
[09:31:37.073]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.073]                                 success = TRUE)
[09:31:37.073]                               parallel_sendData(master, data)
[09:31:37.073]                             }
[09:31:37.073]                             return(sendCondition)
[09:31:37.073]                           }
[09:31:37.073]                         }
[09:31:37.073]                         frame <- frame + 1L
[09:31:37.073]                         envir <- sys.frame(frame)
[09:31:37.073]                       }
[09:31:37.073]                     }
[09:31:37.073]                     sendCondition <<- function(cond) NULL
[09:31:37.073]                   }
[09:31:37.073]                 })
[09:31:37.073]                 withCallingHandlers({
[09:31:37.073]                   1
[09:31:37.073]                 }, immediateCondition = function(cond) {
[09:31:37.073]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.073]                   sendCondition(cond)
[09:31:37.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.073]                   {
[09:31:37.073]                     inherits <- base::inherits
[09:31:37.073]                     invokeRestart <- base::invokeRestart
[09:31:37.073]                     is.null <- base::is.null
[09:31:37.073]                     muffled <- FALSE
[09:31:37.073]                     if (inherits(cond, "message")) {
[09:31:37.073]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.073]                       if (muffled) 
[09:31:37.073]                         invokeRestart("muffleMessage")
[09:31:37.073]                     }
[09:31:37.073]                     else if (inherits(cond, "warning")) {
[09:31:37.073]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.073]                       if (muffled) 
[09:31:37.073]                         invokeRestart("muffleWarning")
[09:31:37.073]                     }
[09:31:37.073]                     else if (inherits(cond, "condition")) {
[09:31:37.073]                       if (!is.null(pattern)) {
[09:31:37.073]                         computeRestarts <- base::computeRestarts
[09:31:37.073]                         grepl <- base::grepl
[09:31:37.073]                         restarts <- computeRestarts(cond)
[09:31:37.073]                         for (restart in restarts) {
[09:31:37.073]                           name <- restart$name
[09:31:37.073]                           if (is.null(name)) 
[09:31:37.073]                             next
[09:31:37.073]                           if (!grepl(pattern, name)) 
[09:31:37.073]                             next
[09:31:37.073]                           invokeRestart(restart)
[09:31:37.073]                           muffled <- TRUE
[09:31:37.073]                           break
[09:31:37.073]                         }
[09:31:37.073]                       }
[09:31:37.073]                     }
[09:31:37.073]                     invisible(muffled)
[09:31:37.073]                   }
[09:31:37.073]                   muffleCondition(cond)
[09:31:37.073]                 })
[09:31:37.073]             }))
[09:31:37.073]             future::FutureResult(value = ...future.value$value, 
[09:31:37.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.073]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.073]                     ...future.globalenv.names))
[09:31:37.073]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.073]         }, condition = base::local({
[09:31:37.073]             c <- base::c
[09:31:37.073]             inherits <- base::inherits
[09:31:37.073]             invokeRestart <- base::invokeRestart
[09:31:37.073]             length <- base::length
[09:31:37.073]             list <- base::list
[09:31:37.073]             seq.int <- base::seq.int
[09:31:37.073]             signalCondition <- base::signalCondition
[09:31:37.073]             sys.calls <- base::sys.calls
[09:31:37.073]             `[[` <- base::`[[`
[09:31:37.073]             `+` <- base::`+`
[09:31:37.073]             `<<-` <- base::`<<-`
[09:31:37.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.073]                   3L)]
[09:31:37.073]             }
[09:31:37.073]             function(cond) {
[09:31:37.073]                 is_error <- inherits(cond, "error")
[09:31:37.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.073]                   NULL)
[09:31:37.073]                 if (is_error) {
[09:31:37.073]                   sessionInformation <- function() {
[09:31:37.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.073]                       search = base::search(), system = base::Sys.info())
[09:31:37.073]                   }
[09:31:37.073]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.073]                     cond$call), session = sessionInformation(), 
[09:31:37.073]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.073]                   signalCondition(cond)
[09:31:37.073]                 }
[09:31:37.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.073]                 "immediateCondition"))) {
[09:31:37.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.073]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.073]                   if (TRUE && !signal) {
[09:31:37.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.073]                     {
[09:31:37.073]                       inherits <- base::inherits
[09:31:37.073]                       invokeRestart <- base::invokeRestart
[09:31:37.073]                       is.null <- base::is.null
[09:31:37.073]                       muffled <- FALSE
[09:31:37.073]                       if (inherits(cond, "message")) {
[09:31:37.073]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.073]                         if (muffled) 
[09:31:37.073]                           invokeRestart("muffleMessage")
[09:31:37.073]                       }
[09:31:37.073]                       else if (inherits(cond, "warning")) {
[09:31:37.073]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.073]                         if (muffled) 
[09:31:37.073]                           invokeRestart("muffleWarning")
[09:31:37.073]                       }
[09:31:37.073]                       else if (inherits(cond, "condition")) {
[09:31:37.073]                         if (!is.null(pattern)) {
[09:31:37.073]                           computeRestarts <- base::computeRestarts
[09:31:37.073]                           grepl <- base::grepl
[09:31:37.073]                           restarts <- computeRestarts(cond)
[09:31:37.073]                           for (restart in restarts) {
[09:31:37.073]                             name <- restart$name
[09:31:37.073]                             if (is.null(name)) 
[09:31:37.073]                               next
[09:31:37.073]                             if (!grepl(pattern, name)) 
[09:31:37.073]                               next
[09:31:37.073]                             invokeRestart(restart)
[09:31:37.073]                             muffled <- TRUE
[09:31:37.073]                             break
[09:31:37.073]                           }
[09:31:37.073]                         }
[09:31:37.073]                       }
[09:31:37.073]                       invisible(muffled)
[09:31:37.073]                     }
[09:31:37.073]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.073]                   }
[09:31:37.073]                 }
[09:31:37.073]                 else {
[09:31:37.073]                   if (TRUE) {
[09:31:37.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.073]                     {
[09:31:37.073]                       inherits <- base::inherits
[09:31:37.073]                       invokeRestart <- base::invokeRestart
[09:31:37.073]                       is.null <- base::is.null
[09:31:37.073]                       muffled <- FALSE
[09:31:37.073]                       if (inherits(cond, "message")) {
[09:31:37.073]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.073]                         if (muffled) 
[09:31:37.073]                           invokeRestart("muffleMessage")
[09:31:37.073]                       }
[09:31:37.073]                       else if (inherits(cond, "warning")) {
[09:31:37.073]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.073]                         if (muffled) 
[09:31:37.073]                           invokeRestart("muffleWarning")
[09:31:37.073]                       }
[09:31:37.073]                       else if (inherits(cond, "condition")) {
[09:31:37.073]                         if (!is.null(pattern)) {
[09:31:37.073]                           computeRestarts <- base::computeRestarts
[09:31:37.073]                           grepl <- base::grepl
[09:31:37.073]                           restarts <- computeRestarts(cond)
[09:31:37.073]                           for (restart in restarts) {
[09:31:37.073]                             name <- restart$name
[09:31:37.073]                             if (is.null(name)) 
[09:31:37.073]                               next
[09:31:37.073]                             if (!grepl(pattern, name)) 
[09:31:37.073]                               next
[09:31:37.073]                             invokeRestart(restart)
[09:31:37.073]                             muffled <- TRUE
[09:31:37.073]                             break
[09:31:37.073]                           }
[09:31:37.073]                         }
[09:31:37.073]                       }
[09:31:37.073]                       invisible(muffled)
[09:31:37.073]                     }
[09:31:37.073]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.073]                   }
[09:31:37.073]                 }
[09:31:37.073]             }
[09:31:37.073]         }))
[09:31:37.073]     }, error = function(ex) {
[09:31:37.073]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.073]                 ...future.rng), started = ...future.startTime, 
[09:31:37.073]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.073]             version = "1.8"), class = "FutureResult")
[09:31:37.073]     }, finally = {
[09:31:37.073]         if (!identical(...future.workdir, getwd())) 
[09:31:37.073]             setwd(...future.workdir)
[09:31:37.073]         {
[09:31:37.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.073]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.073]             }
[09:31:37.073]             base::options(...future.oldOptions)
[09:31:37.073]             if (.Platform$OS.type == "windows") {
[09:31:37.073]                 old_names <- names(...future.oldEnvVars)
[09:31:37.073]                 envs <- base::Sys.getenv()
[09:31:37.073]                 names <- names(envs)
[09:31:37.073]                 common <- intersect(names, old_names)
[09:31:37.073]                 added <- setdiff(names, old_names)
[09:31:37.073]                 removed <- setdiff(old_names, names)
[09:31:37.073]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.073]                   envs[common]]
[09:31:37.073]                 NAMES <- toupper(changed)
[09:31:37.073]                 args <- list()
[09:31:37.073]                 for (kk in seq_along(NAMES)) {
[09:31:37.073]                   name <- changed[[kk]]
[09:31:37.073]                   NAME <- NAMES[[kk]]
[09:31:37.073]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.073]                     next
[09:31:37.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.073]                 }
[09:31:37.073]                 NAMES <- toupper(added)
[09:31:37.073]                 for (kk in seq_along(NAMES)) {
[09:31:37.073]                   name <- added[[kk]]
[09:31:37.073]                   NAME <- NAMES[[kk]]
[09:31:37.073]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.073]                     next
[09:31:37.073]                   args[[name]] <- ""
[09:31:37.073]                 }
[09:31:37.073]                 NAMES <- toupper(removed)
[09:31:37.073]                 for (kk in seq_along(NAMES)) {
[09:31:37.073]                   name <- removed[[kk]]
[09:31:37.073]                   NAME <- NAMES[[kk]]
[09:31:37.073]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.073]                     next
[09:31:37.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.073]                 }
[09:31:37.073]                 if (length(args) > 0) 
[09:31:37.073]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.073]             }
[09:31:37.073]             else {
[09:31:37.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.073]             }
[09:31:37.073]             {
[09:31:37.073]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.073]                   0L) {
[09:31:37.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.073]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.073]                   base::options(opts)
[09:31:37.073]                 }
[09:31:37.073]                 {
[09:31:37.073]                   {
[09:31:37.073]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.073]                     NULL
[09:31:37.073]                   }
[09:31:37.073]                   options(future.plan = NULL)
[09:31:37.073]                   if (is.na(NA_character_)) 
[09:31:37.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.073]                     .init = FALSE)
[09:31:37.073]                 }
[09:31:37.073]             }
[09:31:37.073]         }
[09:31:37.073]     })
[09:31:37.073]     if (TRUE) {
[09:31:37.073]         base::sink(type = "output", split = FALSE)
[09:31:37.073]         if (TRUE) {
[09:31:37.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.073]         }
[09:31:37.073]         else {
[09:31:37.073]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.073]         }
[09:31:37.073]         base::close(...future.stdout)
[09:31:37.073]         ...future.stdout <- NULL
[09:31:37.073]     }
[09:31:37.073]     ...future.result$conditions <- ...future.conditions
[09:31:37.073]     ...future.result$finished <- base::Sys.time()
[09:31:37.073]     ...future.result
[09:31:37.073] }
[09:31:37.076] MultisessionFuture started
[09:31:37.076] - Launch lazy future ... done
[09:31:37.076] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.077] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.077] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.077] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:37.078] Searching for globals ... DONE
[09:31:37.078] Resolving globals: TRUE
[09:31:37.078] Resolving any globals that are futures ...
[09:31:37.078] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:37.078] Resolving any globals that are futures ... DONE
[09:31:37.078] Resolving futures part of globals (recursively) ...
[09:31:37.079] resolve() on list ...
[09:31:37.079]  recursive: 99
[09:31:37.079]  length: 1
[09:31:37.079]  elements: ‘a’
[09:31:37.122] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.122] - Validating connection of MultisessionFuture
[09:31:37.122] - received message: FutureResult
[09:31:37.122] - Received FutureResult
[09:31:37.122] - Erased future from FutureRegistry
[09:31:37.122] result() for ClusterFuture ...
[09:31:37.122] - result already collected: FutureResult
[09:31:37.122] result() for ClusterFuture ... done
[09:31:37.122] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.123] Future #1
[09:31:37.123] result() for ClusterFuture ...
[09:31:37.123] - result already collected: FutureResult
[09:31:37.123] result() for ClusterFuture ... done
[09:31:37.123] result() for ClusterFuture ...
[09:31:37.123] - result already collected: FutureResult
[09:31:37.123] result() for ClusterFuture ... done
[09:31:37.123] A MultisessionFuture was resolved
[09:31:37.123]  length: 0 (resolved future 1)
[09:31:37.123] resolve() on list ... DONE
[09:31:37.123] - globals: [1] ‘a’
[09:31:37.124] Resolving futures part of globals (recursively) ... DONE
[09:31:37.126] The total size of the 1 globals is 1.57 MiB (1647200 bytes)
[09:31:37.126] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:37.126] - globals: [1] ‘a’
[09:31:37.126] - packages: [1] ‘future’
[09:31:37.126] getGlobalsAndPackages() ... DONE
[09:31:37.127] run() for ‘Future’ ...
[09:31:37.127] - state: ‘created’
[09:31:37.127] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.141] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.141]   - Field: ‘node’
[09:31:37.141]   - Field: ‘label’
[09:31:37.141]   - Field: ‘local’
[09:31:37.141]   - Field: ‘owner’
[09:31:37.141]   - Field: ‘envir’
[09:31:37.141]   - Field: ‘workers’
[09:31:37.141]   - Field: ‘packages’
[09:31:37.141]   - Field: ‘gc’
[09:31:37.142]   - Field: ‘conditions’
[09:31:37.144]   - Field: ‘persistent’
[09:31:37.144]   - Field: ‘expr’
[09:31:37.144]   - Field: ‘uuid’
[09:31:37.144]   - Field: ‘seed’
[09:31:37.144]   - Field: ‘version’
[09:31:37.144]   - Field: ‘result’
[09:31:37.144]   - Field: ‘asynchronous’
[09:31:37.144]   - Field: ‘calls’
[09:31:37.144]   - Field: ‘globals’
[09:31:37.145]   - Field: ‘stdout’
[09:31:37.145]   - Field: ‘earlySignal’
[09:31:37.145]   - Field: ‘lazy’
[09:31:37.145]   - Field: ‘state’
[09:31:37.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.145] - Launch lazy future ...
[09:31:37.145] Packages needed by the future expression (n = 1): ‘future’
[09:31:37.145] Packages needed by future strategies (n = 0): <none>
[09:31:37.146] {
[09:31:37.146]     {
[09:31:37.146]         {
[09:31:37.146]             ...future.startTime <- base::Sys.time()
[09:31:37.146]             {
[09:31:37.146]                 {
[09:31:37.146]                   {
[09:31:37.146]                     {
[09:31:37.146]                       {
[09:31:37.146]                         base::local({
[09:31:37.146]                           has_future <- base::requireNamespace("future", 
[09:31:37.146]                             quietly = TRUE)
[09:31:37.146]                           if (has_future) {
[09:31:37.146]                             ns <- base::getNamespace("future")
[09:31:37.146]                             version <- ns[[".package"]][["version"]]
[09:31:37.146]                             if (is.null(version)) 
[09:31:37.146]                               version <- utils::packageVersion("future")
[09:31:37.146]                           }
[09:31:37.146]                           else {
[09:31:37.146]                             version <- NULL
[09:31:37.146]                           }
[09:31:37.146]                           if (!has_future || version < "1.8.0") {
[09:31:37.146]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.146]                               "", base::R.version$version.string), 
[09:31:37.146]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:37.146]                                 base::R.version$platform, 8 * 
[09:31:37.146]                                   base::.Machine$sizeof.pointer), 
[09:31:37.146]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.146]                                 "release", "version")], collapse = " "), 
[09:31:37.146]                               hostname = base::Sys.info()[["nodename"]])
[09:31:37.146]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.146]                               info)
[09:31:37.146]                             info <- base::paste(info, collapse = "; ")
[09:31:37.146]                             if (!has_future) {
[09:31:37.146]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.146]                                 info)
[09:31:37.146]                             }
[09:31:37.146]                             else {
[09:31:37.146]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.146]                                 info, version)
[09:31:37.146]                             }
[09:31:37.146]                             base::stop(msg)
[09:31:37.146]                           }
[09:31:37.146]                         })
[09:31:37.146]                       }
[09:31:37.146]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.146]                       base::options(mc.cores = 1L)
[09:31:37.146]                     }
[09:31:37.146]                     base::local({
[09:31:37.146]                       for (pkg in "future") {
[09:31:37.146]                         base::loadNamespace(pkg)
[09:31:37.146]                         base::library(pkg, character.only = TRUE)
[09:31:37.146]                       }
[09:31:37.146]                     })
[09:31:37.146]                   }
[09:31:37.146]                   ...future.strategy.old <- future::plan("list")
[09:31:37.146]                   options(future.plan = NULL)
[09:31:37.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.146]                 }
[09:31:37.146]                 ...future.workdir <- getwd()
[09:31:37.146]             }
[09:31:37.146]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.146]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.146]         }
[09:31:37.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.146]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.146]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.146]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.146]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.146]             base::names(...future.oldOptions))
[09:31:37.146]     }
[09:31:37.146]     if (FALSE) {
[09:31:37.146]     }
[09:31:37.146]     else {
[09:31:37.146]         if (TRUE) {
[09:31:37.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.146]                 open = "w")
[09:31:37.146]         }
[09:31:37.146]         else {
[09:31:37.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.146]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.146]         }
[09:31:37.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.146]             base::sink(type = "output", split = FALSE)
[09:31:37.146]             base::close(...future.stdout)
[09:31:37.146]         }, add = TRUE)
[09:31:37.146]     }
[09:31:37.146]     ...future.frame <- base::sys.nframe()
[09:31:37.146]     ...future.conditions <- base::list()
[09:31:37.146]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.146]     if (FALSE) {
[09:31:37.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.146]     }
[09:31:37.146]     ...future.result <- base::tryCatch({
[09:31:37.146]         base::withCallingHandlers({
[09:31:37.146]             ...future.value <- base::withVisible(base::local({
[09:31:37.146]                 ...future.makeSendCondition <- base::local({
[09:31:37.146]                   sendCondition <- NULL
[09:31:37.146]                   function(frame = 1L) {
[09:31:37.146]                     if (is.function(sendCondition)) 
[09:31:37.146]                       return(sendCondition)
[09:31:37.146]                     ns <- getNamespace("parallel")
[09:31:37.146]                     if (exists("sendData", mode = "function", 
[09:31:37.146]                       envir = ns)) {
[09:31:37.146]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.146]                         envir = ns)
[09:31:37.146]                       envir <- sys.frame(frame)
[09:31:37.146]                       master <- NULL
[09:31:37.146]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.146]                         !identical(envir, emptyenv())) {
[09:31:37.146]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.146]                           inherits = FALSE)) {
[09:31:37.146]                           master <- get("master", mode = "list", 
[09:31:37.146]                             envir = envir, inherits = FALSE)
[09:31:37.146]                           if (inherits(master, c("SOCKnode", 
[09:31:37.146]                             "SOCK0node"))) {
[09:31:37.146]                             sendCondition <<- function(cond) {
[09:31:37.146]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.146]                                 success = TRUE)
[09:31:37.146]                               parallel_sendData(master, data)
[09:31:37.146]                             }
[09:31:37.146]                             return(sendCondition)
[09:31:37.146]                           }
[09:31:37.146]                         }
[09:31:37.146]                         frame <- frame + 1L
[09:31:37.146]                         envir <- sys.frame(frame)
[09:31:37.146]                       }
[09:31:37.146]                     }
[09:31:37.146]                     sendCondition <<- function(cond) NULL
[09:31:37.146]                   }
[09:31:37.146]                 })
[09:31:37.146]                 withCallingHandlers({
[09:31:37.146]                   value(a) + 1
[09:31:37.146]                 }, immediateCondition = function(cond) {
[09:31:37.146]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.146]                   sendCondition(cond)
[09:31:37.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.146]                   {
[09:31:37.146]                     inherits <- base::inherits
[09:31:37.146]                     invokeRestart <- base::invokeRestart
[09:31:37.146]                     is.null <- base::is.null
[09:31:37.146]                     muffled <- FALSE
[09:31:37.146]                     if (inherits(cond, "message")) {
[09:31:37.146]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.146]                       if (muffled) 
[09:31:37.146]                         invokeRestart("muffleMessage")
[09:31:37.146]                     }
[09:31:37.146]                     else if (inherits(cond, "warning")) {
[09:31:37.146]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.146]                       if (muffled) 
[09:31:37.146]                         invokeRestart("muffleWarning")
[09:31:37.146]                     }
[09:31:37.146]                     else if (inherits(cond, "condition")) {
[09:31:37.146]                       if (!is.null(pattern)) {
[09:31:37.146]                         computeRestarts <- base::computeRestarts
[09:31:37.146]                         grepl <- base::grepl
[09:31:37.146]                         restarts <- computeRestarts(cond)
[09:31:37.146]                         for (restart in restarts) {
[09:31:37.146]                           name <- restart$name
[09:31:37.146]                           if (is.null(name)) 
[09:31:37.146]                             next
[09:31:37.146]                           if (!grepl(pattern, name)) 
[09:31:37.146]                             next
[09:31:37.146]                           invokeRestart(restart)
[09:31:37.146]                           muffled <- TRUE
[09:31:37.146]                           break
[09:31:37.146]                         }
[09:31:37.146]                       }
[09:31:37.146]                     }
[09:31:37.146]                     invisible(muffled)
[09:31:37.146]                   }
[09:31:37.146]                   muffleCondition(cond)
[09:31:37.146]                 })
[09:31:37.146]             }))
[09:31:37.146]             future::FutureResult(value = ...future.value$value, 
[09:31:37.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.146]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.146]                     ...future.globalenv.names))
[09:31:37.146]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.146]         }, condition = base::local({
[09:31:37.146]             c <- base::c
[09:31:37.146]             inherits <- base::inherits
[09:31:37.146]             invokeRestart <- base::invokeRestart
[09:31:37.146]             length <- base::length
[09:31:37.146]             list <- base::list
[09:31:37.146]             seq.int <- base::seq.int
[09:31:37.146]             signalCondition <- base::signalCondition
[09:31:37.146]             sys.calls <- base::sys.calls
[09:31:37.146]             `[[` <- base::`[[`
[09:31:37.146]             `+` <- base::`+`
[09:31:37.146]             `<<-` <- base::`<<-`
[09:31:37.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.146]                   3L)]
[09:31:37.146]             }
[09:31:37.146]             function(cond) {
[09:31:37.146]                 is_error <- inherits(cond, "error")
[09:31:37.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.146]                   NULL)
[09:31:37.146]                 if (is_error) {
[09:31:37.146]                   sessionInformation <- function() {
[09:31:37.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.146]                       search = base::search(), system = base::Sys.info())
[09:31:37.146]                   }
[09:31:37.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.146]                     cond$call), session = sessionInformation(), 
[09:31:37.146]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.146]                   signalCondition(cond)
[09:31:37.146]                 }
[09:31:37.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.146]                 "immediateCondition"))) {
[09:31:37.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.146]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.146]                   if (TRUE && !signal) {
[09:31:37.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.146]                     {
[09:31:37.146]                       inherits <- base::inherits
[09:31:37.146]                       invokeRestart <- base::invokeRestart
[09:31:37.146]                       is.null <- base::is.null
[09:31:37.146]                       muffled <- FALSE
[09:31:37.146]                       if (inherits(cond, "message")) {
[09:31:37.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.146]                         if (muffled) 
[09:31:37.146]                           invokeRestart("muffleMessage")
[09:31:37.146]                       }
[09:31:37.146]                       else if (inherits(cond, "warning")) {
[09:31:37.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.146]                         if (muffled) 
[09:31:37.146]                           invokeRestart("muffleWarning")
[09:31:37.146]                       }
[09:31:37.146]                       else if (inherits(cond, "condition")) {
[09:31:37.146]                         if (!is.null(pattern)) {
[09:31:37.146]                           computeRestarts <- base::computeRestarts
[09:31:37.146]                           grepl <- base::grepl
[09:31:37.146]                           restarts <- computeRestarts(cond)
[09:31:37.146]                           for (restart in restarts) {
[09:31:37.146]                             name <- restart$name
[09:31:37.146]                             if (is.null(name)) 
[09:31:37.146]                               next
[09:31:37.146]                             if (!grepl(pattern, name)) 
[09:31:37.146]                               next
[09:31:37.146]                             invokeRestart(restart)
[09:31:37.146]                             muffled <- TRUE
[09:31:37.146]                             break
[09:31:37.146]                           }
[09:31:37.146]                         }
[09:31:37.146]                       }
[09:31:37.146]                       invisible(muffled)
[09:31:37.146]                     }
[09:31:37.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.146]                   }
[09:31:37.146]                 }
[09:31:37.146]                 else {
[09:31:37.146]                   if (TRUE) {
[09:31:37.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.146]                     {
[09:31:37.146]                       inherits <- base::inherits
[09:31:37.146]                       invokeRestart <- base::invokeRestart
[09:31:37.146]                       is.null <- base::is.null
[09:31:37.146]                       muffled <- FALSE
[09:31:37.146]                       if (inherits(cond, "message")) {
[09:31:37.146]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.146]                         if (muffled) 
[09:31:37.146]                           invokeRestart("muffleMessage")
[09:31:37.146]                       }
[09:31:37.146]                       else if (inherits(cond, "warning")) {
[09:31:37.146]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.146]                         if (muffled) 
[09:31:37.146]                           invokeRestart("muffleWarning")
[09:31:37.146]                       }
[09:31:37.146]                       else if (inherits(cond, "condition")) {
[09:31:37.146]                         if (!is.null(pattern)) {
[09:31:37.146]                           computeRestarts <- base::computeRestarts
[09:31:37.146]                           grepl <- base::grepl
[09:31:37.146]                           restarts <- computeRestarts(cond)
[09:31:37.146]                           for (restart in restarts) {
[09:31:37.146]                             name <- restart$name
[09:31:37.146]                             if (is.null(name)) 
[09:31:37.146]                               next
[09:31:37.146]                             if (!grepl(pattern, name)) 
[09:31:37.146]                               next
[09:31:37.146]                             invokeRestart(restart)
[09:31:37.146]                             muffled <- TRUE
[09:31:37.146]                             break
[09:31:37.146]                           }
[09:31:37.146]                         }
[09:31:37.146]                       }
[09:31:37.146]                       invisible(muffled)
[09:31:37.146]                     }
[09:31:37.146]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.146]                   }
[09:31:37.146]                 }
[09:31:37.146]             }
[09:31:37.146]         }))
[09:31:37.146]     }, error = function(ex) {
[09:31:37.146]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.146]                 ...future.rng), started = ...future.startTime, 
[09:31:37.146]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.146]             version = "1.8"), class = "FutureResult")
[09:31:37.146]     }, finally = {
[09:31:37.146]         if (!identical(...future.workdir, getwd())) 
[09:31:37.146]             setwd(...future.workdir)
[09:31:37.146]         {
[09:31:37.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.146]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.146]             }
[09:31:37.146]             base::options(...future.oldOptions)
[09:31:37.146]             if (.Platform$OS.type == "windows") {
[09:31:37.146]                 old_names <- names(...future.oldEnvVars)
[09:31:37.146]                 envs <- base::Sys.getenv()
[09:31:37.146]                 names <- names(envs)
[09:31:37.146]                 common <- intersect(names, old_names)
[09:31:37.146]                 added <- setdiff(names, old_names)
[09:31:37.146]                 removed <- setdiff(old_names, names)
[09:31:37.146]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.146]                   envs[common]]
[09:31:37.146]                 NAMES <- toupper(changed)
[09:31:37.146]                 args <- list()
[09:31:37.146]                 for (kk in seq_along(NAMES)) {
[09:31:37.146]                   name <- changed[[kk]]
[09:31:37.146]                   NAME <- NAMES[[kk]]
[09:31:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.146]                     next
[09:31:37.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.146]                 }
[09:31:37.146]                 NAMES <- toupper(added)
[09:31:37.146]                 for (kk in seq_along(NAMES)) {
[09:31:37.146]                   name <- added[[kk]]
[09:31:37.146]                   NAME <- NAMES[[kk]]
[09:31:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.146]                     next
[09:31:37.146]                   args[[name]] <- ""
[09:31:37.146]                 }
[09:31:37.146]                 NAMES <- toupper(removed)
[09:31:37.146]                 for (kk in seq_along(NAMES)) {
[09:31:37.146]                   name <- removed[[kk]]
[09:31:37.146]                   NAME <- NAMES[[kk]]
[09:31:37.146]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.146]                     next
[09:31:37.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.146]                 }
[09:31:37.146]                 if (length(args) > 0) 
[09:31:37.146]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.146]             }
[09:31:37.146]             else {
[09:31:37.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.146]             }
[09:31:37.146]             {
[09:31:37.146]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.146]                   0L) {
[09:31:37.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.146]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.146]                   base::options(opts)
[09:31:37.146]                 }
[09:31:37.146]                 {
[09:31:37.146]                   {
[09:31:37.146]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.146]                     NULL
[09:31:37.146]                   }
[09:31:37.146]                   options(future.plan = NULL)
[09:31:37.146]                   if (is.na(NA_character_)) 
[09:31:37.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.146]                     .init = FALSE)
[09:31:37.146]                 }
[09:31:37.146]             }
[09:31:37.146]         }
[09:31:37.146]     })
[09:31:37.146]     if (TRUE) {
[09:31:37.146]         base::sink(type = "output", split = FALSE)
[09:31:37.146]         if (TRUE) {
[09:31:37.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.146]         }
[09:31:37.146]         else {
[09:31:37.146]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.146]         }
[09:31:37.146]         base::close(...future.stdout)
[09:31:37.146]         ...future.stdout <- NULL
[09:31:37.146]     }
[09:31:37.146]     ...future.result$conditions <- ...future.conditions
[09:31:37.146]     ...future.result$finished <- base::Sys.time()
[09:31:37.146]     ...future.result
[09:31:37.146] }
[09:31:37.148] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[09:31:37.150] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[09:31:37.200] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.200] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.201] MultisessionFuture started
[09:31:37.201] - Launch lazy future ... done
[09:31:37.201] run() for ‘MultisessionFuture’ ... done
[09:31:37.201] result() for ClusterFuture ...
[09:31:37.201] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.201] - Validating connection of MultisessionFuture
[09:31:37.246] - received message: FutureResult
[09:31:37.246] - Received FutureResult
[09:31:37.246] - Erased future from FutureRegistry
[09:31:37.246] result() for ClusterFuture ...
[09:31:37.246] - result already collected: FutureResult
[09:31:37.246] result() for ClusterFuture ... done
[09:31:37.246] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.246] result() for ClusterFuture ... done
[09:31:37.247] result() for ClusterFuture ...
[09:31:37.247] - result already collected: FutureResult
[09:31:37.247] result() for ClusterFuture ... done
value(b) = 2
[09:31:37.247] result() for ClusterFuture ...
[09:31:37.247] - result already collected: FutureResult
[09:31:37.247] result() for ClusterFuture ... done
[09:31:37.247] result() for ClusterFuture ...
[09:31:37.247] - result already collected: FutureResult
[09:31:37.247] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.248] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.248] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.248] 
[09:31:37.248] Searching for globals ... DONE
[09:31:37.248] - globals: [0] <none>
[09:31:37.248] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.249] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.249] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.250] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:37.250] Searching for globals ... DONE
[09:31:37.250] Resolving globals: TRUE
[09:31:37.250] Resolving any globals that are futures ...
[09:31:37.250] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:37.250] Resolving any globals that are futures ... DONE
[09:31:37.250] Resolving futures part of globals (recursively) ...
[09:31:37.251] resolve() on list ...
[09:31:37.251]  recursive: 99
[09:31:37.251]  length: 1
[09:31:37.251]  elements: ‘a’
[09:31:37.251] run() for ‘Future’ ...
[09:31:37.251] - state: ‘created’
[09:31:37.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.265] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.265] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.265]   - Field: ‘node’
[09:31:37.265]   - Field: ‘label’
[09:31:37.265]   - Field: ‘local’
[09:31:37.265]   - Field: ‘owner’
[09:31:37.265]   - Field: ‘envir’
[09:31:37.266]   - Field: ‘workers’
[09:31:37.266]   - Field: ‘packages’
[09:31:37.266]   - Field: ‘gc’
[09:31:37.266]   - Field: ‘conditions’
[09:31:37.266]   - Field: ‘persistent’
[09:31:37.266]   - Field: ‘expr’
[09:31:37.266]   - Field: ‘uuid’
[09:31:37.266]   - Field: ‘seed’
[09:31:37.266]   - Field: ‘version’
[09:31:37.266]   - Field: ‘result’
[09:31:37.266]   - Field: ‘asynchronous’
[09:31:37.266]   - Field: ‘calls’
[09:31:37.267]   - Field: ‘globals’
[09:31:37.267]   - Field: ‘stdout’
[09:31:37.267]   - Field: ‘earlySignal’
[09:31:37.267]   - Field: ‘lazy’
[09:31:37.267]   - Field: ‘state’
[09:31:37.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.267] - Launch lazy future ...
[09:31:37.267] Packages needed by the future expression (n = 0): <none>
[09:31:37.267] Packages needed by future strategies (n = 0): <none>
[09:31:37.268] {
[09:31:37.268]     {
[09:31:37.268]         {
[09:31:37.268]             ...future.startTime <- base::Sys.time()
[09:31:37.268]             {
[09:31:37.268]                 {
[09:31:37.268]                   {
[09:31:37.268]                     {
[09:31:37.268]                       base::local({
[09:31:37.268]                         has_future <- base::requireNamespace("future", 
[09:31:37.268]                           quietly = TRUE)
[09:31:37.268]                         if (has_future) {
[09:31:37.268]                           ns <- base::getNamespace("future")
[09:31:37.268]                           version <- ns[[".package"]][["version"]]
[09:31:37.268]                           if (is.null(version)) 
[09:31:37.268]                             version <- utils::packageVersion("future")
[09:31:37.268]                         }
[09:31:37.268]                         else {
[09:31:37.268]                           version <- NULL
[09:31:37.268]                         }
[09:31:37.268]                         if (!has_future || version < "1.8.0") {
[09:31:37.268]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.268]                             "", base::R.version$version.string), 
[09:31:37.268]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.268]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.268]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.268]                               "release", "version")], collapse = " "), 
[09:31:37.268]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.268]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.268]                             info)
[09:31:37.268]                           info <- base::paste(info, collapse = "; ")
[09:31:37.268]                           if (!has_future) {
[09:31:37.268]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.268]                               info)
[09:31:37.268]                           }
[09:31:37.268]                           else {
[09:31:37.268]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.268]                               info, version)
[09:31:37.268]                           }
[09:31:37.268]                           base::stop(msg)
[09:31:37.268]                         }
[09:31:37.268]                       })
[09:31:37.268]                     }
[09:31:37.268]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.268]                     base::options(mc.cores = 1L)
[09:31:37.268]                   }
[09:31:37.268]                   ...future.strategy.old <- future::plan("list")
[09:31:37.268]                   options(future.plan = NULL)
[09:31:37.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.268]                 }
[09:31:37.268]                 ...future.workdir <- getwd()
[09:31:37.268]             }
[09:31:37.268]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.268]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.268]         }
[09:31:37.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.268]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.268]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.268]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.268]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.268]             base::names(...future.oldOptions))
[09:31:37.268]     }
[09:31:37.268]     if (FALSE) {
[09:31:37.268]     }
[09:31:37.268]     else {
[09:31:37.268]         if (TRUE) {
[09:31:37.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.268]                 open = "w")
[09:31:37.268]         }
[09:31:37.268]         else {
[09:31:37.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.268]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.268]         }
[09:31:37.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.268]             base::sink(type = "output", split = FALSE)
[09:31:37.268]             base::close(...future.stdout)
[09:31:37.268]         }, add = TRUE)
[09:31:37.268]     }
[09:31:37.268]     ...future.frame <- base::sys.nframe()
[09:31:37.268]     ...future.conditions <- base::list()
[09:31:37.268]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.268]     if (FALSE) {
[09:31:37.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.268]     }
[09:31:37.268]     ...future.result <- base::tryCatch({
[09:31:37.268]         base::withCallingHandlers({
[09:31:37.268]             ...future.value <- base::withVisible(base::local({
[09:31:37.268]                 ...future.makeSendCondition <- base::local({
[09:31:37.268]                   sendCondition <- NULL
[09:31:37.268]                   function(frame = 1L) {
[09:31:37.268]                     if (is.function(sendCondition)) 
[09:31:37.268]                       return(sendCondition)
[09:31:37.268]                     ns <- getNamespace("parallel")
[09:31:37.268]                     if (exists("sendData", mode = "function", 
[09:31:37.268]                       envir = ns)) {
[09:31:37.268]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.268]                         envir = ns)
[09:31:37.268]                       envir <- sys.frame(frame)
[09:31:37.268]                       master <- NULL
[09:31:37.268]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.268]                         !identical(envir, emptyenv())) {
[09:31:37.268]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.268]                           inherits = FALSE)) {
[09:31:37.268]                           master <- get("master", mode = "list", 
[09:31:37.268]                             envir = envir, inherits = FALSE)
[09:31:37.268]                           if (inherits(master, c("SOCKnode", 
[09:31:37.268]                             "SOCK0node"))) {
[09:31:37.268]                             sendCondition <<- function(cond) {
[09:31:37.268]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.268]                                 success = TRUE)
[09:31:37.268]                               parallel_sendData(master, data)
[09:31:37.268]                             }
[09:31:37.268]                             return(sendCondition)
[09:31:37.268]                           }
[09:31:37.268]                         }
[09:31:37.268]                         frame <- frame + 1L
[09:31:37.268]                         envir <- sys.frame(frame)
[09:31:37.268]                       }
[09:31:37.268]                     }
[09:31:37.268]                     sendCondition <<- function(cond) NULL
[09:31:37.268]                   }
[09:31:37.268]                 })
[09:31:37.268]                 withCallingHandlers({
[09:31:37.268]                   1
[09:31:37.268]                 }, immediateCondition = function(cond) {
[09:31:37.268]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.268]                   sendCondition(cond)
[09:31:37.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.268]                   {
[09:31:37.268]                     inherits <- base::inherits
[09:31:37.268]                     invokeRestart <- base::invokeRestart
[09:31:37.268]                     is.null <- base::is.null
[09:31:37.268]                     muffled <- FALSE
[09:31:37.268]                     if (inherits(cond, "message")) {
[09:31:37.268]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.268]                       if (muffled) 
[09:31:37.268]                         invokeRestart("muffleMessage")
[09:31:37.268]                     }
[09:31:37.268]                     else if (inherits(cond, "warning")) {
[09:31:37.268]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.268]                       if (muffled) 
[09:31:37.268]                         invokeRestart("muffleWarning")
[09:31:37.268]                     }
[09:31:37.268]                     else if (inherits(cond, "condition")) {
[09:31:37.268]                       if (!is.null(pattern)) {
[09:31:37.268]                         computeRestarts <- base::computeRestarts
[09:31:37.268]                         grepl <- base::grepl
[09:31:37.268]                         restarts <- computeRestarts(cond)
[09:31:37.268]                         for (restart in restarts) {
[09:31:37.268]                           name <- restart$name
[09:31:37.268]                           if (is.null(name)) 
[09:31:37.268]                             next
[09:31:37.268]                           if (!grepl(pattern, name)) 
[09:31:37.268]                             next
[09:31:37.268]                           invokeRestart(restart)
[09:31:37.268]                           muffled <- TRUE
[09:31:37.268]                           break
[09:31:37.268]                         }
[09:31:37.268]                       }
[09:31:37.268]                     }
[09:31:37.268]                     invisible(muffled)
[09:31:37.268]                   }
[09:31:37.268]                   muffleCondition(cond)
[09:31:37.268]                 })
[09:31:37.268]             }))
[09:31:37.268]             future::FutureResult(value = ...future.value$value, 
[09:31:37.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.268]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.268]                     ...future.globalenv.names))
[09:31:37.268]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.268]         }, condition = base::local({
[09:31:37.268]             c <- base::c
[09:31:37.268]             inherits <- base::inherits
[09:31:37.268]             invokeRestart <- base::invokeRestart
[09:31:37.268]             length <- base::length
[09:31:37.268]             list <- base::list
[09:31:37.268]             seq.int <- base::seq.int
[09:31:37.268]             signalCondition <- base::signalCondition
[09:31:37.268]             sys.calls <- base::sys.calls
[09:31:37.268]             `[[` <- base::`[[`
[09:31:37.268]             `+` <- base::`+`
[09:31:37.268]             `<<-` <- base::`<<-`
[09:31:37.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.268]                   3L)]
[09:31:37.268]             }
[09:31:37.268]             function(cond) {
[09:31:37.268]                 is_error <- inherits(cond, "error")
[09:31:37.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.268]                   NULL)
[09:31:37.268]                 if (is_error) {
[09:31:37.268]                   sessionInformation <- function() {
[09:31:37.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.268]                       search = base::search(), system = base::Sys.info())
[09:31:37.268]                   }
[09:31:37.268]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.268]                     cond$call), session = sessionInformation(), 
[09:31:37.268]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.268]                   signalCondition(cond)
[09:31:37.268]                 }
[09:31:37.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.268]                 "immediateCondition"))) {
[09:31:37.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.268]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.268]                   if (TRUE && !signal) {
[09:31:37.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.268]                     {
[09:31:37.268]                       inherits <- base::inherits
[09:31:37.268]                       invokeRestart <- base::invokeRestart
[09:31:37.268]                       is.null <- base::is.null
[09:31:37.268]                       muffled <- FALSE
[09:31:37.268]                       if (inherits(cond, "message")) {
[09:31:37.268]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.268]                         if (muffled) 
[09:31:37.268]                           invokeRestart("muffleMessage")
[09:31:37.268]                       }
[09:31:37.268]                       else if (inherits(cond, "warning")) {
[09:31:37.268]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.268]                         if (muffled) 
[09:31:37.268]                           invokeRestart("muffleWarning")
[09:31:37.268]                       }
[09:31:37.268]                       else if (inherits(cond, "condition")) {
[09:31:37.268]                         if (!is.null(pattern)) {
[09:31:37.268]                           computeRestarts <- base::computeRestarts
[09:31:37.268]                           grepl <- base::grepl
[09:31:37.268]                           restarts <- computeRestarts(cond)
[09:31:37.268]                           for (restart in restarts) {
[09:31:37.268]                             name <- restart$name
[09:31:37.268]                             if (is.null(name)) 
[09:31:37.268]                               next
[09:31:37.268]                             if (!grepl(pattern, name)) 
[09:31:37.268]                               next
[09:31:37.268]                             invokeRestart(restart)
[09:31:37.268]                             muffled <- TRUE
[09:31:37.268]                             break
[09:31:37.268]                           }
[09:31:37.268]                         }
[09:31:37.268]                       }
[09:31:37.268]                       invisible(muffled)
[09:31:37.268]                     }
[09:31:37.268]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.268]                   }
[09:31:37.268]                 }
[09:31:37.268]                 else {
[09:31:37.268]                   if (TRUE) {
[09:31:37.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.268]                     {
[09:31:37.268]                       inherits <- base::inherits
[09:31:37.268]                       invokeRestart <- base::invokeRestart
[09:31:37.268]                       is.null <- base::is.null
[09:31:37.268]                       muffled <- FALSE
[09:31:37.268]                       if (inherits(cond, "message")) {
[09:31:37.268]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.268]                         if (muffled) 
[09:31:37.268]                           invokeRestart("muffleMessage")
[09:31:37.268]                       }
[09:31:37.268]                       else if (inherits(cond, "warning")) {
[09:31:37.268]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.268]                         if (muffled) 
[09:31:37.268]                           invokeRestart("muffleWarning")
[09:31:37.268]                       }
[09:31:37.268]                       else if (inherits(cond, "condition")) {
[09:31:37.268]                         if (!is.null(pattern)) {
[09:31:37.268]                           computeRestarts <- base::computeRestarts
[09:31:37.268]                           grepl <- base::grepl
[09:31:37.268]                           restarts <- computeRestarts(cond)
[09:31:37.268]                           for (restart in restarts) {
[09:31:37.268]                             name <- restart$name
[09:31:37.268]                             if (is.null(name)) 
[09:31:37.268]                               next
[09:31:37.268]                             if (!grepl(pattern, name)) 
[09:31:37.268]                               next
[09:31:37.268]                             invokeRestart(restart)
[09:31:37.268]                             muffled <- TRUE
[09:31:37.268]                             break
[09:31:37.268]                           }
[09:31:37.268]                         }
[09:31:37.268]                       }
[09:31:37.268]                       invisible(muffled)
[09:31:37.268]                     }
[09:31:37.268]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.268]                   }
[09:31:37.268]                 }
[09:31:37.268]             }
[09:31:37.268]         }))
[09:31:37.268]     }, error = function(ex) {
[09:31:37.268]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.268]                 ...future.rng), started = ...future.startTime, 
[09:31:37.268]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.268]             version = "1.8"), class = "FutureResult")
[09:31:37.268]     }, finally = {
[09:31:37.268]         if (!identical(...future.workdir, getwd())) 
[09:31:37.268]             setwd(...future.workdir)
[09:31:37.268]         {
[09:31:37.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.268]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.268]             }
[09:31:37.268]             base::options(...future.oldOptions)
[09:31:37.268]             if (.Platform$OS.type == "windows") {
[09:31:37.268]                 old_names <- names(...future.oldEnvVars)
[09:31:37.268]                 envs <- base::Sys.getenv()
[09:31:37.268]                 names <- names(envs)
[09:31:37.268]                 common <- intersect(names, old_names)
[09:31:37.268]                 added <- setdiff(names, old_names)
[09:31:37.268]                 removed <- setdiff(old_names, names)
[09:31:37.268]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.268]                   envs[common]]
[09:31:37.268]                 NAMES <- toupper(changed)
[09:31:37.268]                 args <- list()
[09:31:37.268]                 for (kk in seq_along(NAMES)) {
[09:31:37.268]                   name <- changed[[kk]]
[09:31:37.268]                   NAME <- NAMES[[kk]]
[09:31:37.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.268]                     next
[09:31:37.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.268]                 }
[09:31:37.268]                 NAMES <- toupper(added)
[09:31:37.268]                 for (kk in seq_along(NAMES)) {
[09:31:37.268]                   name <- added[[kk]]
[09:31:37.268]                   NAME <- NAMES[[kk]]
[09:31:37.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.268]                     next
[09:31:37.268]                   args[[name]] <- ""
[09:31:37.268]                 }
[09:31:37.268]                 NAMES <- toupper(removed)
[09:31:37.268]                 for (kk in seq_along(NAMES)) {
[09:31:37.268]                   name <- removed[[kk]]
[09:31:37.268]                   NAME <- NAMES[[kk]]
[09:31:37.268]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.268]                     next
[09:31:37.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.268]                 }
[09:31:37.268]                 if (length(args) > 0) 
[09:31:37.268]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.268]             }
[09:31:37.268]             else {
[09:31:37.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.268]             }
[09:31:37.268]             {
[09:31:37.268]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.268]                   0L) {
[09:31:37.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.268]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.268]                   base::options(opts)
[09:31:37.268]                 }
[09:31:37.268]                 {
[09:31:37.268]                   {
[09:31:37.268]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.268]                     NULL
[09:31:37.268]                   }
[09:31:37.268]                   options(future.plan = NULL)
[09:31:37.268]                   if (is.na(NA_character_)) 
[09:31:37.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.268]                     .init = FALSE)
[09:31:37.268]                 }
[09:31:37.268]             }
[09:31:37.268]         }
[09:31:37.268]     })
[09:31:37.268]     if (TRUE) {
[09:31:37.268]         base::sink(type = "output", split = FALSE)
[09:31:37.268]         if (TRUE) {
[09:31:37.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.268]         }
[09:31:37.268]         else {
[09:31:37.268]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.268]         }
[09:31:37.268]         base::close(...future.stdout)
[09:31:37.268]         ...future.stdout <- NULL
[09:31:37.268]     }
[09:31:37.268]     ...future.result$conditions <- ...future.conditions
[09:31:37.268]     ...future.result$finished <- base::Sys.time()
[09:31:37.268]     ...future.result
[09:31:37.268] }
[09:31:37.271] MultisessionFuture started
[09:31:37.271] - Launch lazy future ... done
[09:31:37.271] run() for ‘MultisessionFuture’ ... done
[09:31:37.314] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.314] - Validating connection of MultisessionFuture
[09:31:37.314] - received message: FutureResult
[09:31:37.314] - Received FutureResult
[09:31:37.314] - Erased future from FutureRegistry
[09:31:37.314] result() for ClusterFuture ...
[09:31:37.314] - result already collected: FutureResult
[09:31:37.314] result() for ClusterFuture ... done
[09:31:37.314] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.315] Future #1
[09:31:37.315] result() for ClusterFuture ...
[09:31:37.315] - result already collected: FutureResult
[09:31:37.315] result() for ClusterFuture ... done
[09:31:37.315] result() for ClusterFuture ...
[09:31:37.315] - result already collected: FutureResult
[09:31:37.315] result() for ClusterFuture ... done
[09:31:37.315] A MultisessionFuture was resolved
[09:31:37.315]  length: 0 (resolved future 1)
[09:31:37.315] resolve() on list ... DONE
[09:31:37.316] - globals: [1] ‘a’
[09:31:37.316] Resolving futures part of globals (recursively) ... DONE
[09:31:37.318] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[09:31:37.318] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:37.318] - globals: [1] ‘a’
[09:31:37.318] - packages: [1] ‘future’
[09:31:37.318] getGlobalsAndPackages() ... DONE
[09:31:37.318] run() for ‘Future’ ...
[09:31:37.319] - state: ‘created’
[09:31:37.319] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.332]   - Field: ‘node’
[09:31:37.332]   - Field: ‘label’
[09:31:37.333]   - Field: ‘local’
[09:31:37.333]   - Field: ‘owner’
[09:31:37.333]   - Field: ‘envir’
[09:31:37.333]   - Field: ‘workers’
[09:31:37.333]   - Field: ‘packages’
[09:31:37.333]   - Field: ‘gc’
[09:31:37.333]   - Field: ‘conditions’
[09:31:37.333]   - Field: ‘persistent’
[09:31:37.333]   - Field: ‘expr’
[09:31:37.333]   - Field: ‘uuid’
[09:31:37.333]   - Field: ‘seed’
[09:31:37.334]   - Field: ‘version’
[09:31:37.334]   - Field: ‘result’
[09:31:37.334]   - Field: ‘asynchronous’
[09:31:37.334]   - Field: ‘calls’
[09:31:37.334]   - Field: ‘globals’
[09:31:37.334]   - Field: ‘stdout’
[09:31:37.334]   - Field: ‘earlySignal’
[09:31:37.334]   - Field: ‘lazy’
[09:31:37.334]   - Field: ‘state’
[09:31:37.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.334] - Launch lazy future ...
[09:31:37.335] Packages needed by the future expression (n = 1): ‘future’
[09:31:37.335] Packages needed by future strategies (n = 0): <none>
[09:31:37.335] {
[09:31:37.335]     {
[09:31:37.335]         {
[09:31:37.335]             ...future.startTime <- base::Sys.time()
[09:31:37.335]             {
[09:31:37.335]                 {
[09:31:37.335]                   {
[09:31:37.335]                     {
[09:31:37.335]                       {
[09:31:37.335]                         base::local({
[09:31:37.335]                           has_future <- base::requireNamespace("future", 
[09:31:37.335]                             quietly = TRUE)
[09:31:37.335]                           if (has_future) {
[09:31:37.335]                             ns <- base::getNamespace("future")
[09:31:37.335]                             version <- ns[[".package"]][["version"]]
[09:31:37.335]                             if (is.null(version)) 
[09:31:37.335]                               version <- utils::packageVersion("future")
[09:31:37.335]                           }
[09:31:37.335]                           else {
[09:31:37.335]                             version <- NULL
[09:31:37.335]                           }
[09:31:37.335]                           if (!has_future || version < "1.8.0") {
[09:31:37.335]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.335]                               "", base::R.version$version.string), 
[09:31:37.335]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:37.335]                                 base::R.version$platform, 8 * 
[09:31:37.335]                                   base::.Machine$sizeof.pointer), 
[09:31:37.335]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.335]                                 "release", "version")], collapse = " "), 
[09:31:37.335]                               hostname = base::Sys.info()[["nodename"]])
[09:31:37.335]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.335]                               info)
[09:31:37.335]                             info <- base::paste(info, collapse = "; ")
[09:31:37.335]                             if (!has_future) {
[09:31:37.335]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.335]                                 info)
[09:31:37.335]                             }
[09:31:37.335]                             else {
[09:31:37.335]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.335]                                 info, version)
[09:31:37.335]                             }
[09:31:37.335]                             base::stop(msg)
[09:31:37.335]                           }
[09:31:37.335]                         })
[09:31:37.335]                       }
[09:31:37.335]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.335]                       base::options(mc.cores = 1L)
[09:31:37.335]                     }
[09:31:37.335]                     base::local({
[09:31:37.335]                       for (pkg in "future") {
[09:31:37.335]                         base::loadNamespace(pkg)
[09:31:37.335]                         base::library(pkg, character.only = TRUE)
[09:31:37.335]                       }
[09:31:37.335]                     })
[09:31:37.335]                   }
[09:31:37.335]                   ...future.strategy.old <- future::plan("list")
[09:31:37.335]                   options(future.plan = NULL)
[09:31:37.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.335]                 }
[09:31:37.335]                 ...future.workdir <- getwd()
[09:31:37.335]             }
[09:31:37.335]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.335]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.335]         }
[09:31:37.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.335]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.335]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.335]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.335]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.335]             base::names(...future.oldOptions))
[09:31:37.335]     }
[09:31:37.335]     if (FALSE) {
[09:31:37.335]     }
[09:31:37.335]     else {
[09:31:37.335]         if (TRUE) {
[09:31:37.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.335]                 open = "w")
[09:31:37.335]         }
[09:31:37.335]         else {
[09:31:37.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.335]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.335]         }
[09:31:37.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.335]             base::sink(type = "output", split = FALSE)
[09:31:37.335]             base::close(...future.stdout)
[09:31:37.335]         }, add = TRUE)
[09:31:37.335]     }
[09:31:37.335]     ...future.frame <- base::sys.nframe()
[09:31:37.335]     ...future.conditions <- base::list()
[09:31:37.335]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.335]     if (FALSE) {
[09:31:37.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.335]     }
[09:31:37.335]     ...future.result <- base::tryCatch({
[09:31:37.335]         base::withCallingHandlers({
[09:31:37.335]             ...future.value <- base::withVisible(base::local({
[09:31:37.335]                 ...future.makeSendCondition <- base::local({
[09:31:37.335]                   sendCondition <- NULL
[09:31:37.335]                   function(frame = 1L) {
[09:31:37.335]                     if (is.function(sendCondition)) 
[09:31:37.335]                       return(sendCondition)
[09:31:37.335]                     ns <- getNamespace("parallel")
[09:31:37.335]                     if (exists("sendData", mode = "function", 
[09:31:37.335]                       envir = ns)) {
[09:31:37.335]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.335]                         envir = ns)
[09:31:37.335]                       envir <- sys.frame(frame)
[09:31:37.335]                       master <- NULL
[09:31:37.335]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.335]                         !identical(envir, emptyenv())) {
[09:31:37.335]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.335]                           inherits = FALSE)) {
[09:31:37.335]                           master <- get("master", mode = "list", 
[09:31:37.335]                             envir = envir, inherits = FALSE)
[09:31:37.335]                           if (inherits(master, c("SOCKnode", 
[09:31:37.335]                             "SOCK0node"))) {
[09:31:37.335]                             sendCondition <<- function(cond) {
[09:31:37.335]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.335]                                 success = TRUE)
[09:31:37.335]                               parallel_sendData(master, data)
[09:31:37.335]                             }
[09:31:37.335]                             return(sendCondition)
[09:31:37.335]                           }
[09:31:37.335]                         }
[09:31:37.335]                         frame <- frame + 1L
[09:31:37.335]                         envir <- sys.frame(frame)
[09:31:37.335]                       }
[09:31:37.335]                     }
[09:31:37.335]                     sendCondition <<- function(cond) NULL
[09:31:37.335]                   }
[09:31:37.335]                 })
[09:31:37.335]                 withCallingHandlers({
[09:31:37.335]                   value(a) + 1
[09:31:37.335]                 }, immediateCondition = function(cond) {
[09:31:37.335]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.335]                   sendCondition(cond)
[09:31:37.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.335]                   {
[09:31:37.335]                     inherits <- base::inherits
[09:31:37.335]                     invokeRestart <- base::invokeRestart
[09:31:37.335]                     is.null <- base::is.null
[09:31:37.335]                     muffled <- FALSE
[09:31:37.335]                     if (inherits(cond, "message")) {
[09:31:37.335]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.335]                       if (muffled) 
[09:31:37.335]                         invokeRestart("muffleMessage")
[09:31:37.335]                     }
[09:31:37.335]                     else if (inherits(cond, "warning")) {
[09:31:37.335]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.335]                       if (muffled) 
[09:31:37.335]                         invokeRestart("muffleWarning")
[09:31:37.335]                     }
[09:31:37.335]                     else if (inherits(cond, "condition")) {
[09:31:37.335]                       if (!is.null(pattern)) {
[09:31:37.335]                         computeRestarts <- base::computeRestarts
[09:31:37.335]                         grepl <- base::grepl
[09:31:37.335]                         restarts <- computeRestarts(cond)
[09:31:37.335]                         for (restart in restarts) {
[09:31:37.335]                           name <- restart$name
[09:31:37.335]                           if (is.null(name)) 
[09:31:37.335]                             next
[09:31:37.335]                           if (!grepl(pattern, name)) 
[09:31:37.335]                             next
[09:31:37.335]                           invokeRestart(restart)
[09:31:37.335]                           muffled <- TRUE
[09:31:37.335]                           break
[09:31:37.335]                         }
[09:31:37.335]                       }
[09:31:37.335]                     }
[09:31:37.335]                     invisible(muffled)
[09:31:37.335]                   }
[09:31:37.335]                   muffleCondition(cond)
[09:31:37.335]                 })
[09:31:37.335]             }))
[09:31:37.335]             future::FutureResult(value = ...future.value$value, 
[09:31:37.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.335]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.335]                     ...future.globalenv.names))
[09:31:37.335]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.335]         }, condition = base::local({
[09:31:37.335]             c <- base::c
[09:31:37.335]             inherits <- base::inherits
[09:31:37.335]             invokeRestart <- base::invokeRestart
[09:31:37.335]             length <- base::length
[09:31:37.335]             list <- base::list
[09:31:37.335]             seq.int <- base::seq.int
[09:31:37.335]             signalCondition <- base::signalCondition
[09:31:37.335]             sys.calls <- base::sys.calls
[09:31:37.335]             `[[` <- base::`[[`
[09:31:37.335]             `+` <- base::`+`
[09:31:37.335]             `<<-` <- base::`<<-`
[09:31:37.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.335]                   3L)]
[09:31:37.335]             }
[09:31:37.335]             function(cond) {
[09:31:37.335]                 is_error <- inherits(cond, "error")
[09:31:37.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.335]                   NULL)
[09:31:37.335]                 if (is_error) {
[09:31:37.335]                   sessionInformation <- function() {
[09:31:37.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.335]                       search = base::search(), system = base::Sys.info())
[09:31:37.335]                   }
[09:31:37.335]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.335]                     cond$call), session = sessionInformation(), 
[09:31:37.335]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.335]                   signalCondition(cond)
[09:31:37.335]                 }
[09:31:37.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.335]                 "immediateCondition"))) {
[09:31:37.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.335]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.335]                   if (TRUE && !signal) {
[09:31:37.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.335]                     {
[09:31:37.335]                       inherits <- base::inherits
[09:31:37.335]                       invokeRestart <- base::invokeRestart
[09:31:37.335]                       is.null <- base::is.null
[09:31:37.335]                       muffled <- FALSE
[09:31:37.335]                       if (inherits(cond, "message")) {
[09:31:37.335]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.335]                         if (muffled) 
[09:31:37.335]                           invokeRestart("muffleMessage")
[09:31:37.335]                       }
[09:31:37.335]                       else if (inherits(cond, "warning")) {
[09:31:37.335]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.335]                         if (muffled) 
[09:31:37.335]                           invokeRestart("muffleWarning")
[09:31:37.335]                       }
[09:31:37.335]                       else if (inherits(cond, "condition")) {
[09:31:37.335]                         if (!is.null(pattern)) {
[09:31:37.335]                           computeRestarts <- base::computeRestarts
[09:31:37.335]                           grepl <- base::grepl
[09:31:37.335]                           restarts <- computeRestarts(cond)
[09:31:37.335]                           for (restart in restarts) {
[09:31:37.335]                             name <- restart$name
[09:31:37.335]                             if (is.null(name)) 
[09:31:37.335]                               next
[09:31:37.335]                             if (!grepl(pattern, name)) 
[09:31:37.335]                               next
[09:31:37.335]                             invokeRestart(restart)
[09:31:37.335]                             muffled <- TRUE
[09:31:37.335]                             break
[09:31:37.335]                           }
[09:31:37.335]                         }
[09:31:37.335]                       }
[09:31:37.335]                       invisible(muffled)
[09:31:37.335]                     }
[09:31:37.335]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.335]                   }
[09:31:37.335]                 }
[09:31:37.335]                 else {
[09:31:37.335]                   if (TRUE) {
[09:31:37.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.335]                     {
[09:31:37.335]                       inherits <- base::inherits
[09:31:37.335]                       invokeRestart <- base::invokeRestart
[09:31:37.335]                       is.null <- base::is.null
[09:31:37.335]                       muffled <- FALSE
[09:31:37.335]                       if (inherits(cond, "message")) {
[09:31:37.335]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.335]                         if (muffled) 
[09:31:37.335]                           invokeRestart("muffleMessage")
[09:31:37.335]                       }
[09:31:37.335]                       else if (inherits(cond, "warning")) {
[09:31:37.335]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.335]                         if (muffled) 
[09:31:37.335]                           invokeRestart("muffleWarning")
[09:31:37.335]                       }
[09:31:37.335]                       else if (inherits(cond, "condition")) {
[09:31:37.335]                         if (!is.null(pattern)) {
[09:31:37.335]                           computeRestarts <- base::computeRestarts
[09:31:37.335]                           grepl <- base::grepl
[09:31:37.335]                           restarts <- computeRestarts(cond)
[09:31:37.335]                           for (restart in restarts) {
[09:31:37.335]                             name <- restart$name
[09:31:37.335]                             if (is.null(name)) 
[09:31:37.335]                               next
[09:31:37.335]                             if (!grepl(pattern, name)) 
[09:31:37.335]                               next
[09:31:37.335]                             invokeRestart(restart)
[09:31:37.335]                             muffled <- TRUE
[09:31:37.335]                             break
[09:31:37.335]                           }
[09:31:37.335]                         }
[09:31:37.335]                       }
[09:31:37.335]                       invisible(muffled)
[09:31:37.335]                     }
[09:31:37.335]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.335]                   }
[09:31:37.335]                 }
[09:31:37.335]             }
[09:31:37.335]         }))
[09:31:37.335]     }, error = function(ex) {
[09:31:37.335]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.335]                 ...future.rng), started = ...future.startTime, 
[09:31:37.335]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.335]             version = "1.8"), class = "FutureResult")
[09:31:37.335]     }, finally = {
[09:31:37.335]         if (!identical(...future.workdir, getwd())) 
[09:31:37.335]             setwd(...future.workdir)
[09:31:37.335]         {
[09:31:37.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.335]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.335]             }
[09:31:37.335]             base::options(...future.oldOptions)
[09:31:37.335]             if (.Platform$OS.type == "windows") {
[09:31:37.335]                 old_names <- names(...future.oldEnvVars)
[09:31:37.335]                 envs <- base::Sys.getenv()
[09:31:37.335]                 names <- names(envs)
[09:31:37.335]                 common <- intersect(names, old_names)
[09:31:37.335]                 added <- setdiff(names, old_names)
[09:31:37.335]                 removed <- setdiff(old_names, names)
[09:31:37.335]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.335]                   envs[common]]
[09:31:37.335]                 NAMES <- toupper(changed)
[09:31:37.335]                 args <- list()
[09:31:37.335]                 for (kk in seq_along(NAMES)) {
[09:31:37.335]                   name <- changed[[kk]]
[09:31:37.335]                   NAME <- NAMES[[kk]]
[09:31:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.335]                     next
[09:31:37.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.335]                 }
[09:31:37.335]                 NAMES <- toupper(added)
[09:31:37.335]                 for (kk in seq_along(NAMES)) {
[09:31:37.335]                   name <- added[[kk]]
[09:31:37.335]                   NAME <- NAMES[[kk]]
[09:31:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.335]                     next
[09:31:37.335]                   args[[name]] <- ""
[09:31:37.335]                 }
[09:31:37.335]                 NAMES <- toupper(removed)
[09:31:37.335]                 for (kk in seq_along(NAMES)) {
[09:31:37.335]                   name <- removed[[kk]]
[09:31:37.335]                   NAME <- NAMES[[kk]]
[09:31:37.335]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.335]                     next
[09:31:37.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.335]                 }
[09:31:37.335]                 if (length(args) > 0) 
[09:31:37.335]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.335]             }
[09:31:37.335]             else {
[09:31:37.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.335]             }
[09:31:37.335]             {
[09:31:37.335]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.335]                   0L) {
[09:31:37.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.335]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.335]                   base::options(opts)
[09:31:37.335]                 }
[09:31:37.335]                 {
[09:31:37.335]                   {
[09:31:37.335]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.335]                     NULL
[09:31:37.335]                   }
[09:31:37.335]                   options(future.plan = NULL)
[09:31:37.335]                   if (is.na(NA_character_)) 
[09:31:37.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.335]                     .init = FALSE)
[09:31:37.335]                 }
[09:31:37.335]             }
[09:31:37.335]         }
[09:31:37.335]     })
[09:31:37.335]     if (TRUE) {
[09:31:37.335]         base::sink(type = "output", split = FALSE)
[09:31:37.335]         if (TRUE) {
[09:31:37.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.335]         }
[09:31:37.335]         else {
[09:31:37.335]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.335]         }
[09:31:37.335]         base::close(...future.stdout)
[09:31:37.335]         ...future.stdout <- NULL
[09:31:37.335]     }
[09:31:37.335]     ...future.result$conditions <- ...future.conditions
[09:31:37.335]     ...future.result$finished <- base::Sys.time()
[09:31:37.335]     ...future.result
[09:31:37.335] }
[09:31:37.338] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[09:31:37.339] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[09:31:37.392] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.392] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.393] MultisessionFuture started
[09:31:37.393] - Launch lazy future ... done
[09:31:37.393] run() for ‘MultisessionFuture’ ... done
[09:31:37.393] result() for ClusterFuture ...
[09:31:37.393] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.394] - Validating connection of MultisessionFuture
[09:31:37.438] - received message: FutureResult
[09:31:37.438] - Received FutureResult
[09:31:37.438] - Erased future from FutureRegistry
[09:31:37.438] result() for ClusterFuture ...
[09:31:37.438] - result already collected: FutureResult
[09:31:37.438] result() for ClusterFuture ... done
[09:31:37.438] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.438] result() for ClusterFuture ... done
[09:31:37.438] result() for ClusterFuture ...
[09:31:37.439] - result already collected: FutureResult
[09:31:37.439] result() for ClusterFuture ... done
value(b) = 2
[09:31:37.439] result() for ClusterFuture ...
[09:31:37.439] - result already collected: FutureResult
[09:31:37.439] result() for ClusterFuture ... done
[09:31:37.439] result() for ClusterFuture ...
[09:31:37.439] - result already collected: FutureResult
[09:31:37.439] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.439] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.440] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.440] 
[09:31:37.440] Searching for globals ... DONE
[09:31:37.440] - globals: [0] <none>
[09:31:37.440] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.441] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.441] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.442] - globals found: [3] ‘+’, ‘value’, ‘a’
[09:31:37.442] Searching for globals ... DONE
[09:31:37.442] Resolving globals: TRUE
[09:31:37.442] Resolving any globals that are futures ...
[09:31:37.442] - globals: [3] ‘+’, ‘value’, ‘a’
[09:31:37.442] Resolving any globals that are futures ... DONE
[09:31:37.442] Resolving futures part of globals (recursively) ...
[09:31:37.443] resolve() on list ...
[09:31:37.443]  recursive: 99
[09:31:37.443]  length: 1
[09:31:37.443]  elements: ‘a’
[09:31:37.443] run() for ‘Future’ ...
[09:31:37.443] - state: ‘created’
[09:31:37.443] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.457] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.457]   - Field: ‘node’
[09:31:37.457]   - Field: ‘label’
[09:31:37.457]   - Field: ‘local’
[09:31:37.457]   - Field: ‘owner’
[09:31:37.457]   - Field: ‘envir’
[09:31:37.457]   - Field: ‘workers’
[09:31:37.457]   - Field: ‘packages’
[09:31:37.457]   - Field: ‘gc’
[09:31:37.458]   - Field: ‘conditions’
[09:31:37.458]   - Field: ‘persistent’
[09:31:37.458]   - Field: ‘expr’
[09:31:37.458]   - Field: ‘uuid’
[09:31:37.458]   - Field: ‘seed’
[09:31:37.458]   - Field: ‘version’
[09:31:37.458]   - Field: ‘result’
[09:31:37.458]   - Field: ‘asynchronous’
[09:31:37.458]   - Field: ‘calls’
[09:31:37.458]   - Field: ‘globals’
[09:31:37.458]   - Field: ‘stdout’
[09:31:37.458]   - Field: ‘earlySignal’
[09:31:37.459]   - Field: ‘lazy’
[09:31:37.459]   - Field: ‘state’
[09:31:37.459] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.459] - Launch lazy future ...
[09:31:37.459] Packages needed by the future expression (n = 0): <none>
[09:31:37.459] Packages needed by future strategies (n = 0): <none>
[09:31:37.460] {
[09:31:37.460]     {
[09:31:37.460]         {
[09:31:37.460]             ...future.startTime <- base::Sys.time()
[09:31:37.460]             {
[09:31:37.460]                 {
[09:31:37.460]                   {
[09:31:37.460]                     {
[09:31:37.460]                       base::local({
[09:31:37.460]                         has_future <- base::requireNamespace("future", 
[09:31:37.460]                           quietly = TRUE)
[09:31:37.460]                         if (has_future) {
[09:31:37.460]                           ns <- base::getNamespace("future")
[09:31:37.460]                           version <- ns[[".package"]][["version"]]
[09:31:37.460]                           if (is.null(version)) 
[09:31:37.460]                             version <- utils::packageVersion("future")
[09:31:37.460]                         }
[09:31:37.460]                         else {
[09:31:37.460]                           version <- NULL
[09:31:37.460]                         }
[09:31:37.460]                         if (!has_future || version < "1.8.0") {
[09:31:37.460]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.460]                             "", base::R.version$version.string), 
[09:31:37.460]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.460]                               "release", "version")], collapse = " "), 
[09:31:37.460]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.460]                             info)
[09:31:37.460]                           info <- base::paste(info, collapse = "; ")
[09:31:37.460]                           if (!has_future) {
[09:31:37.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.460]                               info)
[09:31:37.460]                           }
[09:31:37.460]                           else {
[09:31:37.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.460]                               info, version)
[09:31:37.460]                           }
[09:31:37.460]                           base::stop(msg)
[09:31:37.460]                         }
[09:31:37.460]                       })
[09:31:37.460]                     }
[09:31:37.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.460]                     base::options(mc.cores = 1L)
[09:31:37.460]                   }
[09:31:37.460]                   ...future.strategy.old <- future::plan("list")
[09:31:37.460]                   options(future.plan = NULL)
[09:31:37.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.460]                 }
[09:31:37.460]                 ...future.workdir <- getwd()
[09:31:37.460]             }
[09:31:37.460]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.460]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.460]         }
[09:31:37.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.460]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.460]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.460]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.460]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.460]             base::names(...future.oldOptions))
[09:31:37.460]     }
[09:31:37.460]     if (FALSE) {
[09:31:37.460]     }
[09:31:37.460]     else {
[09:31:37.460]         if (TRUE) {
[09:31:37.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.460]                 open = "w")
[09:31:37.460]         }
[09:31:37.460]         else {
[09:31:37.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.460]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.460]         }
[09:31:37.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.460]             base::sink(type = "output", split = FALSE)
[09:31:37.460]             base::close(...future.stdout)
[09:31:37.460]         }, add = TRUE)
[09:31:37.460]     }
[09:31:37.460]     ...future.frame <- base::sys.nframe()
[09:31:37.460]     ...future.conditions <- base::list()
[09:31:37.460]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.460]     if (FALSE) {
[09:31:37.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.460]     }
[09:31:37.460]     ...future.result <- base::tryCatch({
[09:31:37.460]         base::withCallingHandlers({
[09:31:37.460]             ...future.value <- base::withVisible(base::local({
[09:31:37.460]                 ...future.makeSendCondition <- base::local({
[09:31:37.460]                   sendCondition <- NULL
[09:31:37.460]                   function(frame = 1L) {
[09:31:37.460]                     if (is.function(sendCondition)) 
[09:31:37.460]                       return(sendCondition)
[09:31:37.460]                     ns <- getNamespace("parallel")
[09:31:37.460]                     if (exists("sendData", mode = "function", 
[09:31:37.460]                       envir = ns)) {
[09:31:37.460]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.460]                         envir = ns)
[09:31:37.460]                       envir <- sys.frame(frame)
[09:31:37.460]                       master <- NULL
[09:31:37.460]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.460]                         !identical(envir, emptyenv())) {
[09:31:37.460]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.460]                           inherits = FALSE)) {
[09:31:37.460]                           master <- get("master", mode = "list", 
[09:31:37.460]                             envir = envir, inherits = FALSE)
[09:31:37.460]                           if (inherits(master, c("SOCKnode", 
[09:31:37.460]                             "SOCK0node"))) {
[09:31:37.460]                             sendCondition <<- function(cond) {
[09:31:37.460]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.460]                                 success = TRUE)
[09:31:37.460]                               parallel_sendData(master, data)
[09:31:37.460]                             }
[09:31:37.460]                             return(sendCondition)
[09:31:37.460]                           }
[09:31:37.460]                         }
[09:31:37.460]                         frame <- frame + 1L
[09:31:37.460]                         envir <- sys.frame(frame)
[09:31:37.460]                       }
[09:31:37.460]                     }
[09:31:37.460]                     sendCondition <<- function(cond) NULL
[09:31:37.460]                   }
[09:31:37.460]                 })
[09:31:37.460]                 withCallingHandlers({
[09:31:37.460]                   1
[09:31:37.460]                 }, immediateCondition = function(cond) {
[09:31:37.460]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.460]                   sendCondition(cond)
[09:31:37.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.460]                   {
[09:31:37.460]                     inherits <- base::inherits
[09:31:37.460]                     invokeRestart <- base::invokeRestart
[09:31:37.460]                     is.null <- base::is.null
[09:31:37.460]                     muffled <- FALSE
[09:31:37.460]                     if (inherits(cond, "message")) {
[09:31:37.460]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.460]                       if (muffled) 
[09:31:37.460]                         invokeRestart("muffleMessage")
[09:31:37.460]                     }
[09:31:37.460]                     else if (inherits(cond, "warning")) {
[09:31:37.460]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.460]                       if (muffled) 
[09:31:37.460]                         invokeRestart("muffleWarning")
[09:31:37.460]                     }
[09:31:37.460]                     else if (inherits(cond, "condition")) {
[09:31:37.460]                       if (!is.null(pattern)) {
[09:31:37.460]                         computeRestarts <- base::computeRestarts
[09:31:37.460]                         grepl <- base::grepl
[09:31:37.460]                         restarts <- computeRestarts(cond)
[09:31:37.460]                         for (restart in restarts) {
[09:31:37.460]                           name <- restart$name
[09:31:37.460]                           if (is.null(name)) 
[09:31:37.460]                             next
[09:31:37.460]                           if (!grepl(pattern, name)) 
[09:31:37.460]                             next
[09:31:37.460]                           invokeRestart(restart)
[09:31:37.460]                           muffled <- TRUE
[09:31:37.460]                           break
[09:31:37.460]                         }
[09:31:37.460]                       }
[09:31:37.460]                     }
[09:31:37.460]                     invisible(muffled)
[09:31:37.460]                   }
[09:31:37.460]                   muffleCondition(cond)
[09:31:37.460]                 })
[09:31:37.460]             }))
[09:31:37.460]             future::FutureResult(value = ...future.value$value, 
[09:31:37.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.460]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.460]                     ...future.globalenv.names))
[09:31:37.460]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.460]         }, condition = base::local({
[09:31:37.460]             c <- base::c
[09:31:37.460]             inherits <- base::inherits
[09:31:37.460]             invokeRestart <- base::invokeRestart
[09:31:37.460]             length <- base::length
[09:31:37.460]             list <- base::list
[09:31:37.460]             seq.int <- base::seq.int
[09:31:37.460]             signalCondition <- base::signalCondition
[09:31:37.460]             sys.calls <- base::sys.calls
[09:31:37.460]             `[[` <- base::`[[`
[09:31:37.460]             `+` <- base::`+`
[09:31:37.460]             `<<-` <- base::`<<-`
[09:31:37.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.460]                   3L)]
[09:31:37.460]             }
[09:31:37.460]             function(cond) {
[09:31:37.460]                 is_error <- inherits(cond, "error")
[09:31:37.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.460]                   NULL)
[09:31:37.460]                 if (is_error) {
[09:31:37.460]                   sessionInformation <- function() {
[09:31:37.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.460]                       search = base::search(), system = base::Sys.info())
[09:31:37.460]                   }
[09:31:37.460]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.460]                     cond$call), session = sessionInformation(), 
[09:31:37.460]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.460]                   signalCondition(cond)
[09:31:37.460]                 }
[09:31:37.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.460]                 "immediateCondition"))) {
[09:31:37.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.460]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.460]                   if (TRUE && !signal) {
[09:31:37.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.460]                     {
[09:31:37.460]                       inherits <- base::inherits
[09:31:37.460]                       invokeRestart <- base::invokeRestart
[09:31:37.460]                       is.null <- base::is.null
[09:31:37.460]                       muffled <- FALSE
[09:31:37.460]                       if (inherits(cond, "message")) {
[09:31:37.460]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.460]                         if (muffled) 
[09:31:37.460]                           invokeRestart("muffleMessage")
[09:31:37.460]                       }
[09:31:37.460]                       else if (inherits(cond, "warning")) {
[09:31:37.460]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.460]                         if (muffled) 
[09:31:37.460]                           invokeRestart("muffleWarning")
[09:31:37.460]                       }
[09:31:37.460]                       else if (inherits(cond, "condition")) {
[09:31:37.460]                         if (!is.null(pattern)) {
[09:31:37.460]                           computeRestarts <- base::computeRestarts
[09:31:37.460]                           grepl <- base::grepl
[09:31:37.460]                           restarts <- computeRestarts(cond)
[09:31:37.460]                           for (restart in restarts) {
[09:31:37.460]                             name <- restart$name
[09:31:37.460]                             if (is.null(name)) 
[09:31:37.460]                               next
[09:31:37.460]                             if (!grepl(pattern, name)) 
[09:31:37.460]                               next
[09:31:37.460]                             invokeRestart(restart)
[09:31:37.460]                             muffled <- TRUE
[09:31:37.460]                             break
[09:31:37.460]                           }
[09:31:37.460]                         }
[09:31:37.460]                       }
[09:31:37.460]                       invisible(muffled)
[09:31:37.460]                     }
[09:31:37.460]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.460]                   }
[09:31:37.460]                 }
[09:31:37.460]                 else {
[09:31:37.460]                   if (TRUE) {
[09:31:37.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.460]                     {
[09:31:37.460]                       inherits <- base::inherits
[09:31:37.460]                       invokeRestart <- base::invokeRestart
[09:31:37.460]                       is.null <- base::is.null
[09:31:37.460]                       muffled <- FALSE
[09:31:37.460]                       if (inherits(cond, "message")) {
[09:31:37.460]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.460]                         if (muffled) 
[09:31:37.460]                           invokeRestart("muffleMessage")
[09:31:37.460]                       }
[09:31:37.460]                       else if (inherits(cond, "warning")) {
[09:31:37.460]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.460]                         if (muffled) 
[09:31:37.460]                           invokeRestart("muffleWarning")
[09:31:37.460]                       }
[09:31:37.460]                       else if (inherits(cond, "condition")) {
[09:31:37.460]                         if (!is.null(pattern)) {
[09:31:37.460]                           computeRestarts <- base::computeRestarts
[09:31:37.460]                           grepl <- base::grepl
[09:31:37.460]                           restarts <- computeRestarts(cond)
[09:31:37.460]                           for (restart in restarts) {
[09:31:37.460]                             name <- restart$name
[09:31:37.460]                             if (is.null(name)) 
[09:31:37.460]                               next
[09:31:37.460]                             if (!grepl(pattern, name)) 
[09:31:37.460]                               next
[09:31:37.460]                             invokeRestart(restart)
[09:31:37.460]                             muffled <- TRUE
[09:31:37.460]                             break
[09:31:37.460]                           }
[09:31:37.460]                         }
[09:31:37.460]                       }
[09:31:37.460]                       invisible(muffled)
[09:31:37.460]                     }
[09:31:37.460]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.460]                   }
[09:31:37.460]                 }
[09:31:37.460]             }
[09:31:37.460]         }))
[09:31:37.460]     }, error = function(ex) {
[09:31:37.460]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.460]                 ...future.rng), started = ...future.startTime, 
[09:31:37.460]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.460]             version = "1.8"), class = "FutureResult")
[09:31:37.460]     }, finally = {
[09:31:37.460]         if (!identical(...future.workdir, getwd())) 
[09:31:37.460]             setwd(...future.workdir)
[09:31:37.460]         {
[09:31:37.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.460]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.460]             }
[09:31:37.460]             base::options(...future.oldOptions)
[09:31:37.460]             if (.Platform$OS.type == "windows") {
[09:31:37.460]                 old_names <- names(...future.oldEnvVars)
[09:31:37.460]                 envs <- base::Sys.getenv()
[09:31:37.460]                 names <- names(envs)
[09:31:37.460]                 common <- intersect(names, old_names)
[09:31:37.460]                 added <- setdiff(names, old_names)
[09:31:37.460]                 removed <- setdiff(old_names, names)
[09:31:37.460]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.460]                   envs[common]]
[09:31:37.460]                 NAMES <- toupper(changed)
[09:31:37.460]                 args <- list()
[09:31:37.460]                 for (kk in seq_along(NAMES)) {
[09:31:37.460]                   name <- changed[[kk]]
[09:31:37.460]                   NAME <- NAMES[[kk]]
[09:31:37.460]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.460]                     next
[09:31:37.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.460]                 }
[09:31:37.460]                 NAMES <- toupper(added)
[09:31:37.460]                 for (kk in seq_along(NAMES)) {
[09:31:37.460]                   name <- added[[kk]]
[09:31:37.460]                   NAME <- NAMES[[kk]]
[09:31:37.460]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.460]                     next
[09:31:37.460]                   args[[name]] <- ""
[09:31:37.460]                 }
[09:31:37.460]                 NAMES <- toupper(removed)
[09:31:37.460]                 for (kk in seq_along(NAMES)) {
[09:31:37.460]                   name <- removed[[kk]]
[09:31:37.460]                   NAME <- NAMES[[kk]]
[09:31:37.460]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.460]                     next
[09:31:37.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.460]                 }
[09:31:37.460]                 if (length(args) > 0) 
[09:31:37.460]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.460]             }
[09:31:37.460]             else {
[09:31:37.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.460]             }
[09:31:37.460]             {
[09:31:37.460]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.460]                   0L) {
[09:31:37.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.460]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.460]                   base::options(opts)
[09:31:37.460]                 }
[09:31:37.460]                 {
[09:31:37.460]                   {
[09:31:37.460]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.460]                     NULL
[09:31:37.460]                   }
[09:31:37.460]                   options(future.plan = NULL)
[09:31:37.460]                   if (is.na(NA_character_)) 
[09:31:37.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.460]                     .init = FALSE)
[09:31:37.460]                 }
[09:31:37.460]             }
[09:31:37.460]         }
[09:31:37.460]     })
[09:31:37.460]     if (TRUE) {
[09:31:37.460]         base::sink(type = "output", split = FALSE)
[09:31:37.460]         if (TRUE) {
[09:31:37.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.460]         }
[09:31:37.460]         else {
[09:31:37.460]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.460]         }
[09:31:37.460]         base::close(...future.stdout)
[09:31:37.460]         ...future.stdout <- NULL
[09:31:37.460]     }
[09:31:37.460]     ...future.result$conditions <- ...future.conditions
[09:31:37.460]     ...future.result$finished <- base::Sys.time()
[09:31:37.460]     ...future.result
[09:31:37.460] }
[09:31:37.462] MultisessionFuture started
[09:31:37.462] - Launch lazy future ... done
[09:31:37.462] run() for ‘MultisessionFuture’ ... done
[09:31:37.505] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.505] - Validating connection of MultisessionFuture
[09:31:37.505] - received message: FutureResult
[09:31:37.506] - Received FutureResult
[09:31:37.506] - Erased future from FutureRegistry
[09:31:37.506] result() for ClusterFuture ...
[09:31:37.506] - result already collected: FutureResult
[09:31:37.506] result() for ClusterFuture ... done
[09:31:37.506] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.506] Future #1
[09:31:37.506] result() for ClusterFuture ...
[09:31:37.506] - result already collected: FutureResult
[09:31:37.506] result() for ClusterFuture ... done
[09:31:37.506] result() for ClusterFuture ...
[09:31:37.507] - result already collected: FutureResult
[09:31:37.507] result() for ClusterFuture ... done
[09:31:37.507] A MultisessionFuture was resolved
[09:31:37.507]  length: 0 (resolved future 1)
[09:31:37.507] resolve() on list ... DONE
[09:31:37.507] - globals: [1] ‘a’
[09:31:37.507] Resolving futures part of globals (recursively) ... DONE
[09:31:37.509] The total size of the 1 globals is 1.57 MiB (1647368 bytes)
[09:31:37.509] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 1.57 MiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (1.57 MiB of class ‘environment’)
[09:31:37.509] - globals: [1] ‘a’
[09:31:37.510] - packages: [1] ‘future’
[09:31:37.510] getGlobalsAndPackages() ... DONE
[09:31:37.510] run() for ‘Future’ ...
[09:31:37.510] - state: ‘created’
[09:31:37.510] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.524] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.524]   - Field: ‘node’
[09:31:37.524]   - Field: ‘label’
[09:31:37.524]   - Field: ‘local’
[09:31:37.524]   - Field: ‘owner’
[09:31:37.524]   - Field: ‘envir’
[09:31:37.524]   - Field: ‘workers’
[09:31:37.524]   - Field: ‘packages’
[09:31:37.525]   - Field: ‘gc’
[09:31:37.525]   - Field: ‘conditions’
[09:31:37.525]   - Field: ‘persistent’
[09:31:37.525]   - Field: ‘expr’
[09:31:37.525]   - Field: ‘uuid’
[09:31:37.525]   - Field: ‘seed’
[09:31:37.525]   - Field: ‘version’
[09:31:37.525]   - Field: ‘result’
[09:31:37.525]   - Field: ‘asynchronous’
[09:31:37.525]   - Field: ‘calls’
[09:31:37.525]   - Field: ‘globals’
[09:31:37.525]   - Field: ‘stdout’
[09:31:37.526]   - Field: ‘earlySignal’
[09:31:37.526]   - Field: ‘lazy’
[09:31:37.526]   - Field: ‘state’
[09:31:37.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.526] - Launch lazy future ...
[09:31:37.526] Packages needed by the future expression (n = 1): ‘future’
[09:31:37.526] Packages needed by future strategies (n = 0): <none>
[09:31:37.527] {
[09:31:37.527]     {
[09:31:37.527]         {
[09:31:37.527]             ...future.startTime <- base::Sys.time()
[09:31:37.527]             {
[09:31:37.527]                 {
[09:31:37.527]                   {
[09:31:37.527]                     {
[09:31:37.527]                       {
[09:31:37.527]                         base::local({
[09:31:37.527]                           has_future <- base::requireNamespace("future", 
[09:31:37.527]                             quietly = TRUE)
[09:31:37.527]                           if (has_future) {
[09:31:37.527]                             ns <- base::getNamespace("future")
[09:31:37.527]                             version <- ns[[".package"]][["version"]]
[09:31:37.527]                             if (is.null(version)) 
[09:31:37.527]                               version <- utils::packageVersion("future")
[09:31:37.527]                           }
[09:31:37.527]                           else {
[09:31:37.527]                             version <- NULL
[09:31:37.527]                           }
[09:31:37.527]                           if (!has_future || version < "1.8.0") {
[09:31:37.527]                             info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.527]                               "", base::R.version$version.string), 
[09:31:37.527]                               platform = base::sprintf("%s (%s-bit)", 
[09:31:37.527]                                 base::R.version$platform, 8 * 
[09:31:37.527]                                   base::.Machine$sizeof.pointer), 
[09:31:37.527]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.527]                                 "release", "version")], collapse = " "), 
[09:31:37.527]                               hostname = base::Sys.info()[["nodename"]])
[09:31:37.527]                             info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.527]                               info)
[09:31:37.527]                             info <- base::paste(info, collapse = "; ")
[09:31:37.527]                             if (!has_future) {
[09:31:37.527]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.527]                                 info)
[09:31:37.527]                             }
[09:31:37.527]                             else {
[09:31:37.527]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.527]                                 info, version)
[09:31:37.527]                             }
[09:31:37.527]                             base::stop(msg)
[09:31:37.527]                           }
[09:31:37.527]                         })
[09:31:37.527]                       }
[09:31:37.527]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.527]                       base::options(mc.cores = 1L)
[09:31:37.527]                     }
[09:31:37.527]                     base::local({
[09:31:37.527]                       for (pkg in "future") {
[09:31:37.527]                         base::loadNamespace(pkg)
[09:31:37.527]                         base::library(pkg, character.only = TRUE)
[09:31:37.527]                       }
[09:31:37.527]                     })
[09:31:37.527]                   }
[09:31:37.527]                   ...future.strategy.old <- future::plan("list")
[09:31:37.527]                   options(future.plan = NULL)
[09:31:37.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.527]                 }
[09:31:37.527]                 ...future.workdir <- getwd()
[09:31:37.527]             }
[09:31:37.527]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.527]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.527]         }
[09:31:37.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.527]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.527]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.527]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.527]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.527]             base::names(...future.oldOptions))
[09:31:37.527]     }
[09:31:37.527]     if (FALSE) {
[09:31:37.527]     }
[09:31:37.527]     else {
[09:31:37.527]         if (TRUE) {
[09:31:37.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.527]                 open = "w")
[09:31:37.527]         }
[09:31:37.527]         else {
[09:31:37.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.527]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.527]         }
[09:31:37.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.527]             base::sink(type = "output", split = FALSE)
[09:31:37.527]             base::close(...future.stdout)
[09:31:37.527]         }, add = TRUE)
[09:31:37.527]     }
[09:31:37.527]     ...future.frame <- base::sys.nframe()
[09:31:37.527]     ...future.conditions <- base::list()
[09:31:37.527]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.527]     if (FALSE) {
[09:31:37.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.527]     }
[09:31:37.527]     ...future.result <- base::tryCatch({
[09:31:37.527]         base::withCallingHandlers({
[09:31:37.527]             ...future.value <- base::withVisible(base::local({
[09:31:37.527]                 ...future.makeSendCondition <- base::local({
[09:31:37.527]                   sendCondition <- NULL
[09:31:37.527]                   function(frame = 1L) {
[09:31:37.527]                     if (is.function(sendCondition)) 
[09:31:37.527]                       return(sendCondition)
[09:31:37.527]                     ns <- getNamespace("parallel")
[09:31:37.527]                     if (exists("sendData", mode = "function", 
[09:31:37.527]                       envir = ns)) {
[09:31:37.527]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.527]                         envir = ns)
[09:31:37.527]                       envir <- sys.frame(frame)
[09:31:37.527]                       master <- NULL
[09:31:37.527]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.527]                         !identical(envir, emptyenv())) {
[09:31:37.527]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.527]                           inherits = FALSE)) {
[09:31:37.527]                           master <- get("master", mode = "list", 
[09:31:37.527]                             envir = envir, inherits = FALSE)
[09:31:37.527]                           if (inherits(master, c("SOCKnode", 
[09:31:37.527]                             "SOCK0node"))) {
[09:31:37.527]                             sendCondition <<- function(cond) {
[09:31:37.527]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.527]                                 success = TRUE)
[09:31:37.527]                               parallel_sendData(master, data)
[09:31:37.527]                             }
[09:31:37.527]                             return(sendCondition)
[09:31:37.527]                           }
[09:31:37.527]                         }
[09:31:37.527]                         frame <- frame + 1L
[09:31:37.527]                         envir <- sys.frame(frame)
[09:31:37.527]                       }
[09:31:37.527]                     }
[09:31:37.527]                     sendCondition <<- function(cond) NULL
[09:31:37.527]                   }
[09:31:37.527]                 })
[09:31:37.527]                 withCallingHandlers({
[09:31:37.527]                   value(a) + 1
[09:31:37.527]                 }, immediateCondition = function(cond) {
[09:31:37.527]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.527]                   sendCondition(cond)
[09:31:37.527]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.527]                   {
[09:31:37.527]                     inherits <- base::inherits
[09:31:37.527]                     invokeRestart <- base::invokeRestart
[09:31:37.527]                     is.null <- base::is.null
[09:31:37.527]                     muffled <- FALSE
[09:31:37.527]                     if (inherits(cond, "message")) {
[09:31:37.527]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.527]                       if (muffled) 
[09:31:37.527]                         invokeRestart("muffleMessage")
[09:31:37.527]                     }
[09:31:37.527]                     else if (inherits(cond, "warning")) {
[09:31:37.527]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.527]                       if (muffled) 
[09:31:37.527]                         invokeRestart("muffleWarning")
[09:31:37.527]                     }
[09:31:37.527]                     else if (inherits(cond, "condition")) {
[09:31:37.527]                       if (!is.null(pattern)) {
[09:31:37.527]                         computeRestarts <- base::computeRestarts
[09:31:37.527]                         grepl <- base::grepl
[09:31:37.527]                         restarts <- computeRestarts(cond)
[09:31:37.527]                         for (restart in restarts) {
[09:31:37.527]                           name <- restart$name
[09:31:37.527]                           if (is.null(name)) 
[09:31:37.527]                             next
[09:31:37.527]                           if (!grepl(pattern, name)) 
[09:31:37.527]                             next
[09:31:37.527]                           invokeRestart(restart)
[09:31:37.527]                           muffled <- TRUE
[09:31:37.527]                           break
[09:31:37.527]                         }
[09:31:37.527]                       }
[09:31:37.527]                     }
[09:31:37.527]                     invisible(muffled)
[09:31:37.527]                   }
[09:31:37.527]                   muffleCondition(cond)
[09:31:37.527]                 })
[09:31:37.527]             }))
[09:31:37.527]             future::FutureResult(value = ...future.value$value, 
[09:31:37.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.527]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.527]                     ...future.globalenv.names))
[09:31:37.527]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.527]         }, condition = base::local({
[09:31:37.527]             c <- base::c
[09:31:37.527]             inherits <- base::inherits
[09:31:37.527]             invokeRestart <- base::invokeRestart
[09:31:37.527]             length <- base::length
[09:31:37.527]             list <- base::list
[09:31:37.527]             seq.int <- base::seq.int
[09:31:37.527]             signalCondition <- base::signalCondition
[09:31:37.527]             sys.calls <- base::sys.calls
[09:31:37.527]             `[[` <- base::`[[`
[09:31:37.527]             `+` <- base::`+`
[09:31:37.527]             `<<-` <- base::`<<-`
[09:31:37.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.527]                   3L)]
[09:31:37.527]             }
[09:31:37.527]             function(cond) {
[09:31:37.527]                 is_error <- inherits(cond, "error")
[09:31:37.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.527]                   NULL)
[09:31:37.527]                 if (is_error) {
[09:31:37.527]                   sessionInformation <- function() {
[09:31:37.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.527]                       search = base::search(), system = base::Sys.info())
[09:31:37.527]                   }
[09:31:37.527]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.527]                     cond$call), session = sessionInformation(), 
[09:31:37.527]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.527]                   signalCondition(cond)
[09:31:37.527]                 }
[09:31:37.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.527]                 "immediateCondition"))) {
[09:31:37.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.527]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.527]                   if (TRUE && !signal) {
[09:31:37.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.527]                     {
[09:31:37.527]                       inherits <- base::inherits
[09:31:37.527]                       invokeRestart <- base::invokeRestart
[09:31:37.527]                       is.null <- base::is.null
[09:31:37.527]                       muffled <- FALSE
[09:31:37.527]                       if (inherits(cond, "message")) {
[09:31:37.527]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.527]                         if (muffled) 
[09:31:37.527]                           invokeRestart("muffleMessage")
[09:31:37.527]                       }
[09:31:37.527]                       else if (inherits(cond, "warning")) {
[09:31:37.527]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.527]                         if (muffled) 
[09:31:37.527]                           invokeRestart("muffleWarning")
[09:31:37.527]                       }
[09:31:37.527]                       else if (inherits(cond, "condition")) {
[09:31:37.527]                         if (!is.null(pattern)) {
[09:31:37.527]                           computeRestarts <- base::computeRestarts
[09:31:37.527]                           grepl <- base::grepl
[09:31:37.527]                           restarts <- computeRestarts(cond)
[09:31:37.527]                           for (restart in restarts) {
[09:31:37.527]                             name <- restart$name
[09:31:37.527]                             if (is.null(name)) 
[09:31:37.527]                               next
[09:31:37.527]                             if (!grepl(pattern, name)) 
[09:31:37.527]                               next
[09:31:37.527]                             invokeRestart(restart)
[09:31:37.527]                             muffled <- TRUE
[09:31:37.527]                             break
[09:31:37.527]                           }
[09:31:37.527]                         }
[09:31:37.527]                       }
[09:31:37.527]                       invisible(muffled)
[09:31:37.527]                     }
[09:31:37.527]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.527]                   }
[09:31:37.527]                 }
[09:31:37.527]                 else {
[09:31:37.527]                   if (TRUE) {
[09:31:37.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.527]                     {
[09:31:37.527]                       inherits <- base::inherits
[09:31:37.527]                       invokeRestart <- base::invokeRestart
[09:31:37.527]                       is.null <- base::is.null
[09:31:37.527]                       muffled <- FALSE
[09:31:37.527]                       if (inherits(cond, "message")) {
[09:31:37.527]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.527]                         if (muffled) 
[09:31:37.527]                           invokeRestart("muffleMessage")
[09:31:37.527]                       }
[09:31:37.527]                       else if (inherits(cond, "warning")) {
[09:31:37.527]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.527]                         if (muffled) 
[09:31:37.527]                           invokeRestart("muffleWarning")
[09:31:37.527]                       }
[09:31:37.527]                       else if (inherits(cond, "condition")) {
[09:31:37.527]                         if (!is.null(pattern)) {
[09:31:37.527]                           computeRestarts <- base::computeRestarts
[09:31:37.527]                           grepl <- base::grepl
[09:31:37.527]                           restarts <- computeRestarts(cond)
[09:31:37.527]                           for (restart in restarts) {
[09:31:37.527]                             name <- restart$name
[09:31:37.527]                             if (is.null(name)) 
[09:31:37.527]                               next
[09:31:37.527]                             if (!grepl(pattern, name)) 
[09:31:37.527]                               next
[09:31:37.527]                             invokeRestart(restart)
[09:31:37.527]                             muffled <- TRUE
[09:31:37.527]                             break
[09:31:37.527]                           }
[09:31:37.527]                         }
[09:31:37.527]                       }
[09:31:37.527]                       invisible(muffled)
[09:31:37.527]                     }
[09:31:37.527]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.527]                   }
[09:31:37.527]                 }
[09:31:37.527]             }
[09:31:37.527]         }))
[09:31:37.527]     }, error = function(ex) {
[09:31:37.527]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.527]                 ...future.rng), started = ...future.startTime, 
[09:31:37.527]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.527]             version = "1.8"), class = "FutureResult")
[09:31:37.527]     }, finally = {
[09:31:37.527]         if (!identical(...future.workdir, getwd())) 
[09:31:37.527]             setwd(...future.workdir)
[09:31:37.527]         {
[09:31:37.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.527]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.527]             }
[09:31:37.527]             base::options(...future.oldOptions)
[09:31:37.527]             if (.Platform$OS.type == "windows") {
[09:31:37.527]                 old_names <- names(...future.oldEnvVars)
[09:31:37.527]                 envs <- base::Sys.getenv()
[09:31:37.527]                 names <- names(envs)
[09:31:37.527]                 common <- intersect(names, old_names)
[09:31:37.527]                 added <- setdiff(names, old_names)
[09:31:37.527]                 removed <- setdiff(old_names, names)
[09:31:37.527]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.527]                   envs[common]]
[09:31:37.527]                 NAMES <- toupper(changed)
[09:31:37.527]                 args <- list()
[09:31:37.527]                 for (kk in seq_along(NAMES)) {
[09:31:37.527]                   name <- changed[[kk]]
[09:31:37.527]                   NAME <- NAMES[[kk]]
[09:31:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.527]                     next
[09:31:37.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.527]                 }
[09:31:37.527]                 NAMES <- toupper(added)
[09:31:37.527]                 for (kk in seq_along(NAMES)) {
[09:31:37.527]                   name <- added[[kk]]
[09:31:37.527]                   NAME <- NAMES[[kk]]
[09:31:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.527]                     next
[09:31:37.527]                   args[[name]] <- ""
[09:31:37.527]                 }
[09:31:37.527]                 NAMES <- toupper(removed)
[09:31:37.527]                 for (kk in seq_along(NAMES)) {
[09:31:37.527]                   name <- removed[[kk]]
[09:31:37.527]                   NAME <- NAMES[[kk]]
[09:31:37.527]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.527]                     next
[09:31:37.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.527]                 }
[09:31:37.527]                 if (length(args) > 0) 
[09:31:37.527]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.527]             }
[09:31:37.527]             else {
[09:31:37.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.527]             }
[09:31:37.527]             {
[09:31:37.527]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.527]                   0L) {
[09:31:37.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.527]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.527]                   base::options(opts)
[09:31:37.527]                 }
[09:31:37.527]                 {
[09:31:37.527]                   {
[09:31:37.527]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.527]                     NULL
[09:31:37.527]                   }
[09:31:37.527]                   options(future.plan = NULL)
[09:31:37.527]                   if (is.na(NA_character_)) 
[09:31:37.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.527]                     .init = FALSE)
[09:31:37.527]                 }
[09:31:37.527]             }
[09:31:37.527]         }
[09:31:37.527]     })
[09:31:37.527]     if (TRUE) {
[09:31:37.527]         base::sink(type = "output", split = FALSE)
[09:31:37.527]         if (TRUE) {
[09:31:37.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.527]         }
[09:31:37.527]         else {
[09:31:37.527]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.527]         }
[09:31:37.527]         base::close(...future.stdout)
[09:31:37.527]         ...future.stdout <- NULL
[09:31:37.527]     }
[09:31:37.527]     ...future.result$conditions <- ...future.conditions
[09:31:37.527]     ...future.result$finished <- base::Sys.time()
[09:31:37.527]     ...future.result
[09:31:37.527] }
[09:31:37.529] Exporting 1 global objects (1.57 MiB) to cluster node #1 ...
[09:31:37.531] Exporting ‘a’ (1.57 MiB) to cluster node #1 ...
[09:31:37.584] Exporting ‘a’ (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.584] Exporting 1 global objects (1.57 MiB) to cluster node #1 ... DONE
[09:31:37.585] MultisessionFuture started
[09:31:37.585] - Launch lazy future ... done
[09:31:37.585] run() for ‘MultisessionFuture’ ... done
[09:31:37.585] result() for ClusterFuture ...
[09:31:37.585] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.585] - Validating connection of MultisessionFuture
[09:31:37.630] - received message: FutureResult
[09:31:37.630] - Received FutureResult
[09:31:37.630] - Erased future from FutureRegistry
[09:31:37.630] result() for ClusterFuture ...
[09:31:37.630] - result already collected: FutureResult
[09:31:37.630] result() for ClusterFuture ... done
[09:31:37.631] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.631] result() for ClusterFuture ... done
[09:31:37.631] result() for ClusterFuture ...
[09:31:37.631] - result already collected: FutureResult
[09:31:37.631] result() for ClusterFuture ... done
value(b) = 2
[09:31:37.631] result() for ClusterFuture ...
[09:31:37.631] - result already collected: FutureResult
[09:31:37.631] result() for ClusterFuture ... done
[09:31:37.632] result() for ClusterFuture ...
[09:31:37.632] - result already collected: FutureResult
[09:31:37.632] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.632] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.633] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.634] - globals found: [2] ‘{’, ‘pkg’
[09:31:37.634] Searching for globals ... DONE
[09:31:37.634] Resolving globals: TRUE
[09:31:37.634] Resolving any globals that are futures ...
[09:31:37.634] - globals: [2] ‘{’, ‘pkg’
[09:31:37.634] Resolving any globals that are futures ... DONE
[09:31:37.635] Resolving futures part of globals (recursively) ...
[09:31:37.635] resolve() on list ...
[09:31:37.635]  recursive: 99
[09:31:37.635]  length: 1
[09:31:37.635]  elements: ‘pkg’
[09:31:37.635]  length: 0 (resolved future 1)
[09:31:37.636] resolve() on list ... DONE
[09:31:37.636] - globals: [1] ‘pkg’
[09:31:37.636] Resolving futures part of globals (recursively) ... DONE
[09:31:37.636] The total size of the 1 globals is 112 bytes (112 bytes)
[09:31:37.636] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 112 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (112 bytes of class ‘character’)
[09:31:37.636] - globals: [1] ‘pkg’
[09:31:37.636] 
[09:31:37.637] getGlobalsAndPackages() ... DONE
[09:31:37.637] Packages needed by the future expression (n = 0): <none>
[09:31:37.637] Packages needed by future strategies (n = 0): <none>
[09:31:37.637] {
[09:31:37.637]     {
[09:31:37.637]         {
[09:31:37.637]             ...future.startTime <- base::Sys.time()
[09:31:37.637]             {
[09:31:37.637]                 {
[09:31:37.637]                   {
[09:31:37.637]                     base::local({
[09:31:37.637]                       has_future <- base::requireNamespace("future", 
[09:31:37.637]                         quietly = TRUE)
[09:31:37.637]                       if (has_future) {
[09:31:37.637]                         ns <- base::getNamespace("future")
[09:31:37.637]                         version <- ns[[".package"]][["version"]]
[09:31:37.637]                         if (is.null(version)) 
[09:31:37.637]                           version <- utils::packageVersion("future")
[09:31:37.637]                       }
[09:31:37.637]                       else {
[09:31:37.637]                         version <- NULL
[09:31:37.637]                       }
[09:31:37.637]                       if (!has_future || version < "1.8.0") {
[09:31:37.637]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.637]                           "", base::R.version$version.string), 
[09:31:37.637]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:37.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.637]                             "release", "version")], collapse = " "), 
[09:31:37.637]                           hostname = base::Sys.info()[["nodename"]])
[09:31:37.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.637]                           info)
[09:31:37.637]                         info <- base::paste(info, collapse = "; ")
[09:31:37.637]                         if (!has_future) {
[09:31:37.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.637]                             info)
[09:31:37.637]                         }
[09:31:37.637]                         else {
[09:31:37.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.637]                             info, version)
[09:31:37.637]                         }
[09:31:37.637]                         base::stop(msg)
[09:31:37.637]                       }
[09:31:37.637]                     })
[09:31:37.637]                   }
[09:31:37.637]                   ...future.strategy.old <- future::plan("list")
[09:31:37.637]                   options(future.plan = NULL)
[09:31:37.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.637]                 }
[09:31:37.637]                 ...future.workdir <- getwd()
[09:31:37.637]             }
[09:31:37.637]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.637]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.637]         }
[09:31:37.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.637]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.637]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.637]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.637]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.637]             base::names(...future.oldOptions))
[09:31:37.637]     }
[09:31:37.637]     if (FALSE) {
[09:31:37.637]     }
[09:31:37.637]     else {
[09:31:37.637]         if (TRUE) {
[09:31:37.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.637]                 open = "w")
[09:31:37.637]         }
[09:31:37.637]         else {
[09:31:37.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.637]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.637]         }
[09:31:37.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.637]             base::sink(type = "output", split = FALSE)
[09:31:37.637]             base::close(...future.stdout)
[09:31:37.637]         }, add = TRUE)
[09:31:37.637]     }
[09:31:37.637]     ...future.frame <- base::sys.nframe()
[09:31:37.637]     ...future.conditions <- base::list()
[09:31:37.637]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.637]     if (FALSE) {
[09:31:37.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.637]     }
[09:31:37.637]     ...future.result <- base::tryCatch({
[09:31:37.637]         base::withCallingHandlers({
[09:31:37.637]             ...future.value <- base::withVisible(base::local({
[09:31:37.637]                 pkg
[09:31:37.637]             }))
[09:31:37.637]             future::FutureResult(value = ...future.value$value, 
[09:31:37.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.637]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.637]                     ...future.globalenv.names))
[09:31:37.637]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.637]         }, condition = base::local({
[09:31:37.637]             c <- base::c
[09:31:37.637]             inherits <- base::inherits
[09:31:37.637]             invokeRestart <- base::invokeRestart
[09:31:37.637]             length <- base::length
[09:31:37.637]             list <- base::list
[09:31:37.637]             seq.int <- base::seq.int
[09:31:37.637]             signalCondition <- base::signalCondition
[09:31:37.637]             sys.calls <- base::sys.calls
[09:31:37.637]             `[[` <- base::`[[`
[09:31:37.637]             `+` <- base::`+`
[09:31:37.637]             `<<-` <- base::`<<-`
[09:31:37.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.637]                   3L)]
[09:31:37.637]             }
[09:31:37.637]             function(cond) {
[09:31:37.637]                 is_error <- inherits(cond, "error")
[09:31:37.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.637]                   NULL)
[09:31:37.637]                 if (is_error) {
[09:31:37.637]                   sessionInformation <- function() {
[09:31:37.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.637]                       search = base::search(), system = base::Sys.info())
[09:31:37.637]                   }
[09:31:37.637]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.637]                     cond$call), session = sessionInformation(), 
[09:31:37.637]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.637]                   signalCondition(cond)
[09:31:37.637]                 }
[09:31:37.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.637]                 "immediateCondition"))) {
[09:31:37.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.637]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.637]                   if (TRUE && !signal) {
[09:31:37.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.637]                     {
[09:31:37.637]                       inherits <- base::inherits
[09:31:37.637]                       invokeRestart <- base::invokeRestart
[09:31:37.637]                       is.null <- base::is.null
[09:31:37.637]                       muffled <- FALSE
[09:31:37.637]                       if (inherits(cond, "message")) {
[09:31:37.637]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.637]                         if (muffled) 
[09:31:37.637]                           invokeRestart("muffleMessage")
[09:31:37.637]                       }
[09:31:37.637]                       else if (inherits(cond, "warning")) {
[09:31:37.637]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.637]                         if (muffled) 
[09:31:37.637]                           invokeRestart("muffleWarning")
[09:31:37.637]                       }
[09:31:37.637]                       else if (inherits(cond, "condition")) {
[09:31:37.637]                         if (!is.null(pattern)) {
[09:31:37.637]                           computeRestarts <- base::computeRestarts
[09:31:37.637]                           grepl <- base::grepl
[09:31:37.637]                           restarts <- computeRestarts(cond)
[09:31:37.637]                           for (restart in restarts) {
[09:31:37.637]                             name <- restart$name
[09:31:37.637]                             if (is.null(name)) 
[09:31:37.637]                               next
[09:31:37.637]                             if (!grepl(pattern, name)) 
[09:31:37.637]                               next
[09:31:37.637]                             invokeRestart(restart)
[09:31:37.637]                             muffled <- TRUE
[09:31:37.637]                             break
[09:31:37.637]                           }
[09:31:37.637]                         }
[09:31:37.637]                       }
[09:31:37.637]                       invisible(muffled)
[09:31:37.637]                     }
[09:31:37.637]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.637]                   }
[09:31:37.637]                 }
[09:31:37.637]                 else {
[09:31:37.637]                   if (TRUE) {
[09:31:37.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.637]                     {
[09:31:37.637]                       inherits <- base::inherits
[09:31:37.637]                       invokeRestart <- base::invokeRestart
[09:31:37.637]                       is.null <- base::is.null
[09:31:37.637]                       muffled <- FALSE
[09:31:37.637]                       if (inherits(cond, "message")) {
[09:31:37.637]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.637]                         if (muffled) 
[09:31:37.637]                           invokeRestart("muffleMessage")
[09:31:37.637]                       }
[09:31:37.637]                       else if (inherits(cond, "warning")) {
[09:31:37.637]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.637]                         if (muffled) 
[09:31:37.637]                           invokeRestart("muffleWarning")
[09:31:37.637]                       }
[09:31:37.637]                       else if (inherits(cond, "condition")) {
[09:31:37.637]                         if (!is.null(pattern)) {
[09:31:37.637]                           computeRestarts <- base::computeRestarts
[09:31:37.637]                           grepl <- base::grepl
[09:31:37.637]                           restarts <- computeRestarts(cond)
[09:31:37.637]                           for (restart in restarts) {
[09:31:37.637]                             name <- restart$name
[09:31:37.637]                             if (is.null(name)) 
[09:31:37.637]                               next
[09:31:37.637]                             if (!grepl(pattern, name)) 
[09:31:37.637]                               next
[09:31:37.637]                             invokeRestart(restart)
[09:31:37.637]                             muffled <- TRUE
[09:31:37.637]                             break
[09:31:37.637]                           }
[09:31:37.637]                         }
[09:31:37.637]                       }
[09:31:37.637]                       invisible(muffled)
[09:31:37.637]                     }
[09:31:37.637]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.637]                   }
[09:31:37.637]                 }
[09:31:37.637]             }
[09:31:37.637]         }))
[09:31:37.637]     }, error = function(ex) {
[09:31:37.637]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.637]                 ...future.rng), started = ...future.startTime, 
[09:31:37.637]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.637]             version = "1.8"), class = "FutureResult")
[09:31:37.637]     }, finally = {
[09:31:37.637]         if (!identical(...future.workdir, getwd())) 
[09:31:37.637]             setwd(...future.workdir)
[09:31:37.637]         {
[09:31:37.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.637]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.637]             }
[09:31:37.637]             base::options(...future.oldOptions)
[09:31:37.637]             if (.Platform$OS.type == "windows") {
[09:31:37.637]                 old_names <- names(...future.oldEnvVars)
[09:31:37.637]                 envs <- base::Sys.getenv()
[09:31:37.637]                 names <- names(envs)
[09:31:37.637]                 common <- intersect(names, old_names)
[09:31:37.637]                 added <- setdiff(names, old_names)
[09:31:37.637]                 removed <- setdiff(old_names, names)
[09:31:37.637]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.637]                   envs[common]]
[09:31:37.637]                 NAMES <- toupper(changed)
[09:31:37.637]                 args <- list()
[09:31:37.637]                 for (kk in seq_along(NAMES)) {
[09:31:37.637]                   name <- changed[[kk]]
[09:31:37.637]                   NAME <- NAMES[[kk]]
[09:31:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.637]                     next
[09:31:37.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.637]                 }
[09:31:37.637]                 NAMES <- toupper(added)
[09:31:37.637]                 for (kk in seq_along(NAMES)) {
[09:31:37.637]                   name <- added[[kk]]
[09:31:37.637]                   NAME <- NAMES[[kk]]
[09:31:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.637]                     next
[09:31:37.637]                   args[[name]] <- ""
[09:31:37.637]                 }
[09:31:37.637]                 NAMES <- toupper(removed)
[09:31:37.637]                 for (kk in seq_along(NAMES)) {
[09:31:37.637]                   name <- removed[[kk]]
[09:31:37.637]                   NAME <- NAMES[[kk]]
[09:31:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.637]                     next
[09:31:37.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.637]                 }
[09:31:37.637]                 if (length(args) > 0) 
[09:31:37.637]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.637]             }
[09:31:37.637]             else {
[09:31:37.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.637]             }
[09:31:37.637]             {
[09:31:37.637]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.637]                   0L) {
[09:31:37.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.637]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.637]                   base::options(opts)
[09:31:37.637]                 }
[09:31:37.637]                 {
[09:31:37.637]                   {
[09:31:37.637]                     NULL
[09:31:37.637]                     RNGkind("Mersenne-Twister")
[09:31:37.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:37.637]                       inherits = FALSE)
[09:31:37.637]                   }
[09:31:37.637]                   options(future.plan = NULL)
[09:31:37.637]                   if (is.na(NA_character_)) 
[09:31:37.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.637]                     .init = FALSE)
[09:31:37.637]                 }
[09:31:37.637]             }
[09:31:37.637]         }
[09:31:37.637]     })
[09:31:37.637]     if (TRUE) {
[09:31:37.637]         base::sink(type = "output", split = FALSE)
[09:31:37.637]         if (TRUE) {
[09:31:37.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.637]         }
[09:31:37.637]         else {
[09:31:37.637]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.637]         }
[09:31:37.637]         base::close(...future.stdout)
[09:31:37.637]         ...future.stdout <- NULL
[09:31:37.637]     }
[09:31:37.637]     ...future.result$conditions <- ...future.conditions
[09:31:37.637]     ...future.result$finished <- base::Sys.time()
[09:31:37.637]     ...future.result
[09:31:37.637] }
[09:31:37.639] assign_globals() ...
[09:31:37.639] List of 1
[09:31:37.639]  $ pkg: chr "foo"
[09:31:37.639]  - attr(*, "where")=List of 1
[09:31:37.639]   ..$ pkg:<environment: R_EmptyEnv> 
[09:31:37.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:31:37.639]  - attr(*, "resolved")= logi TRUE
[09:31:37.639]  - attr(*, "total_size")= num 112
[09:31:37.641] - copied ‘pkg’ to environment
[09:31:37.641] assign_globals() ... done
[09:31:37.641] plan(): Setting new future strategy stack:
[09:31:37.641] List of future strategies:
[09:31:37.641] 1. sequential:
[09:31:37.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:37.641]    - tweaked: FALSE
[09:31:37.641]    - call: NULL
[09:31:37.642] plan(): nbrOfWorkers() = 1
[09:31:37.643] plan(): Setting new future strategy stack:
[09:31:37.643] List of future strategies:
[09:31:37.643] 1. multisession:
[09:31:37.643]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:31:37.643]    - tweaked: FALSE
[09:31:37.643]    - call: plan(strategy)
[09:31:37.646] plan(): nbrOfWorkers() = 2
[09:31:37.646] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.647] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.647] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.649] - globals found: [3] ‘{’, ‘<-’, ‘+’
[09:31:37.649] Searching for globals ... DONE
[09:31:37.649] Resolving globals: TRUE
[09:31:37.649] Resolving any globals that are futures ...
[09:31:37.649] - globals: [3] ‘{’, ‘<-’, ‘+’
[09:31:37.649] Resolving any globals that are futures ... DONE
[09:31:37.649] 
[09:31:37.649] 
[09:31:37.650] getGlobalsAndPackages() ... DONE
[09:31:37.650] run() for ‘Future’ ...
[09:31:37.650] - state: ‘created’
[09:31:37.650] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.664]   - Field: ‘node’
[09:31:37.664]   - Field: ‘label’
[09:31:37.664]   - Field: ‘local’
[09:31:37.665]   - Field: ‘owner’
[09:31:37.665]   - Field: ‘envir’
[09:31:37.665]   - Field: ‘workers’
[09:31:37.665]   - Field: ‘packages’
[09:31:37.665]   - Field: ‘gc’
[09:31:37.665]   - Field: ‘conditions’
[09:31:37.665]   - Field: ‘persistent’
[09:31:37.665]   - Field: ‘expr’
[09:31:37.665]   - Field: ‘uuid’
[09:31:37.665]   - Field: ‘seed’
[09:31:37.665]   - Field: ‘version’
[09:31:37.666]   - Field: ‘result’
[09:31:37.666]   - Field: ‘asynchronous’
[09:31:37.666]   - Field: ‘calls’
[09:31:37.666]   - Field: ‘globals’
[09:31:37.666]   - Field: ‘stdout’
[09:31:37.666]   - Field: ‘earlySignal’
[09:31:37.666]   - Field: ‘lazy’
[09:31:37.666]   - Field: ‘state’
[09:31:37.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.666] - Launch lazy future ...
[09:31:37.667] Packages needed by the future expression (n = 0): <none>
[09:31:37.667] Packages needed by future strategies (n = 0): <none>
[09:31:37.667] {
[09:31:37.667]     {
[09:31:37.667]         {
[09:31:37.667]             ...future.startTime <- base::Sys.time()
[09:31:37.667]             {
[09:31:37.667]                 {
[09:31:37.667]                   {
[09:31:37.667]                     {
[09:31:37.667]                       base::local({
[09:31:37.667]                         has_future <- base::requireNamespace("future", 
[09:31:37.667]                           quietly = TRUE)
[09:31:37.667]                         if (has_future) {
[09:31:37.667]                           ns <- base::getNamespace("future")
[09:31:37.667]                           version <- ns[[".package"]][["version"]]
[09:31:37.667]                           if (is.null(version)) 
[09:31:37.667]                             version <- utils::packageVersion("future")
[09:31:37.667]                         }
[09:31:37.667]                         else {
[09:31:37.667]                           version <- NULL
[09:31:37.667]                         }
[09:31:37.667]                         if (!has_future || version < "1.8.0") {
[09:31:37.667]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.667]                             "", base::R.version$version.string), 
[09:31:37.667]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.667]                               "release", "version")], collapse = " "), 
[09:31:37.667]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.667]                             info)
[09:31:37.667]                           info <- base::paste(info, collapse = "; ")
[09:31:37.667]                           if (!has_future) {
[09:31:37.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.667]                               info)
[09:31:37.667]                           }
[09:31:37.667]                           else {
[09:31:37.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.667]                               info, version)
[09:31:37.667]                           }
[09:31:37.667]                           base::stop(msg)
[09:31:37.667]                         }
[09:31:37.667]                       })
[09:31:37.667]                     }
[09:31:37.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.667]                     base::options(mc.cores = 1L)
[09:31:37.667]                   }
[09:31:37.667]                   ...future.strategy.old <- future::plan("list")
[09:31:37.667]                   options(future.plan = NULL)
[09:31:37.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.667]                 }
[09:31:37.667]                 ...future.workdir <- getwd()
[09:31:37.667]             }
[09:31:37.667]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.667]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.667]         }
[09:31:37.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.667]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.667]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.667]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.667]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.667]             base::names(...future.oldOptions))
[09:31:37.667]     }
[09:31:37.667]     if (FALSE) {
[09:31:37.667]     }
[09:31:37.667]     else {
[09:31:37.667]         if (TRUE) {
[09:31:37.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.667]                 open = "w")
[09:31:37.667]         }
[09:31:37.667]         else {
[09:31:37.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.667]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.667]         }
[09:31:37.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.667]             base::sink(type = "output", split = FALSE)
[09:31:37.667]             base::close(...future.stdout)
[09:31:37.667]         }, add = TRUE)
[09:31:37.667]     }
[09:31:37.667]     ...future.frame <- base::sys.nframe()
[09:31:37.667]     ...future.conditions <- base::list()
[09:31:37.667]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.667]     if (FALSE) {
[09:31:37.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.667]     }
[09:31:37.667]     ...future.result <- base::tryCatch({
[09:31:37.667]         base::withCallingHandlers({
[09:31:37.667]             ...future.value <- base::withVisible(base::local({
[09:31:37.667]                 ...future.makeSendCondition <- base::local({
[09:31:37.667]                   sendCondition <- NULL
[09:31:37.667]                   function(frame = 1L) {
[09:31:37.667]                     if (is.function(sendCondition)) 
[09:31:37.667]                       return(sendCondition)
[09:31:37.667]                     ns <- getNamespace("parallel")
[09:31:37.667]                     if (exists("sendData", mode = "function", 
[09:31:37.667]                       envir = ns)) {
[09:31:37.667]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.667]                         envir = ns)
[09:31:37.667]                       envir <- sys.frame(frame)
[09:31:37.667]                       master <- NULL
[09:31:37.667]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.667]                         !identical(envir, emptyenv())) {
[09:31:37.667]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.667]                           inherits = FALSE)) {
[09:31:37.667]                           master <- get("master", mode = "list", 
[09:31:37.667]                             envir = envir, inherits = FALSE)
[09:31:37.667]                           if (inherits(master, c("SOCKnode", 
[09:31:37.667]                             "SOCK0node"))) {
[09:31:37.667]                             sendCondition <<- function(cond) {
[09:31:37.667]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.667]                                 success = TRUE)
[09:31:37.667]                               parallel_sendData(master, data)
[09:31:37.667]                             }
[09:31:37.667]                             return(sendCondition)
[09:31:37.667]                           }
[09:31:37.667]                         }
[09:31:37.667]                         frame <- frame + 1L
[09:31:37.667]                         envir <- sys.frame(frame)
[09:31:37.667]                       }
[09:31:37.667]                     }
[09:31:37.667]                     sendCondition <<- function(cond) NULL
[09:31:37.667]                   }
[09:31:37.667]                 })
[09:31:37.667]                 withCallingHandlers({
[09:31:37.667]                   {
[09:31:37.667]                     x <- 0
[09:31:37.667]                     x <- x + 1
[09:31:37.667]                     x
[09:31:37.667]                   }
[09:31:37.667]                 }, immediateCondition = function(cond) {
[09:31:37.667]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.667]                   sendCondition(cond)
[09:31:37.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.667]                   {
[09:31:37.667]                     inherits <- base::inherits
[09:31:37.667]                     invokeRestart <- base::invokeRestart
[09:31:37.667]                     is.null <- base::is.null
[09:31:37.667]                     muffled <- FALSE
[09:31:37.667]                     if (inherits(cond, "message")) {
[09:31:37.667]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.667]                       if (muffled) 
[09:31:37.667]                         invokeRestart("muffleMessage")
[09:31:37.667]                     }
[09:31:37.667]                     else if (inherits(cond, "warning")) {
[09:31:37.667]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.667]                       if (muffled) 
[09:31:37.667]                         invokeRestart("muffleWarning")
[09:31:37.667]                     }
[09:31:37.667]                     else if (inherits(cond, "condition")) {
[09:31:37.667]                       if (!is.null(pattern)) {
[09:31:37.667]                         computeRestarts <- base::computeRestarts
[09:31:37.667]                         grepl <- base::grepl
[09:31:37.667]                         restarts <- computeRestarts(cond)
[09:31:37.667]                         for (restart in restarts) {
[09:31:37.667]                           name <- restart$name
[09:31:37.667]                           if (is.null(name)) 
[09:31:37.667]                             next
[09:31:37.667]                           if (!grepl(pattern, name)) 
[09:31:37.667]                             next
[09:31:37.667]                           invokeRestart(restart)
[09:31:37.667]                           muffled <- TRUE
[09:31:37.667]                           break
[09:31:37.667]                         }
[09:31:37.667]                       }
[09:31:37.667]                     }
[09:31:37.667]                     invisible(muffled)
[09:31:37.667]                   }
[09:31:37.667]                   muffleCondition(cond)
[09:31:37.667]                 })
[09:31:37.667]             }))
[09:31:37.667]             future::FutureResult(value = ...future.value$value, 
[09:31:37.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.667]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.667]                     ...future.globalenv.names))
[09:31:37.667]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.667]         }, condition = base::local({
[09:31:37.667]             c <- base::c
[09:31:37.667]             inherits <- base::inherits
[09:31:37.667]             invokeRestart <- base::invokeRestart
[09:31:37.667]             length <- base::length
[09:31:37.667]             list <- base::list
[09:31:37.667]             seq.int <- base::seq.int
[09:31:37.667]             signalCondition <- base::signalCondition
[09:31:37.667]             sys.calls <- base::sys.calls
[09:31:37.667]             `[[` <- base::`[[`
[09:31:37.667]             `+` <- base::`+`
[09:31:37.667]             `<<-` <- base::`<<-`
[09:31:37.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.667]                   3L)]
[09:31:37.667]             }
[09:31:37.667]             function(cond) {
[09:31:37.667]                 is_error <- inherits(cond, "error")
[09:31:37.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.667]                   NULL)
[09:31:37.667]                 if (is_error) {
[09:31:37.667]                   sessionInformation <- function() {
[09:31:37.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.667]                       search = base::search(), system = base::Sys.info())
[09:31:37.667]                   }
[09:31:37.667]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.667]                     cond$call), session = sessionInformation(), 
[09:31:37.667]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.667]                   signalCondition(cond)
[09:31:37.667]                 }
[09:31:37.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.667]                 "immediateCondition"))) {
[09:31:37.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.667]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.667]                   if (TRUE && !signal) {
[09:31:37.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.667]                     {
[09:31:37.667]                       inherits <- base::inherits
[09:31:37.667]                       invokeRestart <- base::invokeRestart
[09:31:37.667]                       is.null <- base::is.null
[09:31:37.667]                       muffled <- FALSE
[09:31:37.667]                       if (inherits(cond, "message")) {
[09:31:37.667]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.667]                         if (muffled) 
[09:31:37.667]                           invokeRestart("muffleMessage")
[09:31:37.667]                       }
[09:31:37.667]                       else if (inherits(cond, "warning")) {
[09:31:37.667]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.667]                         if (muffled) 
[09:31:37.667]                           invokeRestart("muffleWarning")
[09:31:37.667]                       }
[09:31:37.667]                       else if (inherits(cond, "condition")) {
[09:31:37.667]                         if (!is.null(pattern)) {
[09:31:37.667]                           computeRestarts <- base::computeRestarts
[09:31:37.667]                           grepl <- base::grepl
[09:31:37.667]                           restarts <- computeRestarts(cond)
[09:31:37.667]                           for (restart in restarts) {
[09:31:37.667]                             name <- restart$name
[09:31:37.667]                             if (is.null(name)) 
[09:31:37.667]                               next
[09:31:37.667]                             if (!grepl(pattern, name)) 
[09:31:37.667]                               next
[09:31:37.667]                             invokeRestart(restart)
[09:31:37.667]                             muffled <- TRUE
[09:31:37.667]                             break
[09:31:37.667]                           }
[09:31:37.667]                         }
[09:31:37.667]                       }
[09:31:37.667]                       invisible(muffled)
[09:31:37.667]                     }
[09:31:37.667]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.667]                   }
[09:31:37.667]                 }
[09:31:37.667]                 else {
[09:31:37.667]                   if (TRUE) {
[09:31:37.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.667]                     {
[09:31:37.667]                       inherits <- base::inherits
[09:31:37.667]                       invokeRestart <- base::invokeRestart
[09:31:37.667]                       is.null <- base::is.null
[09:31:37.667]                       muffled <- FALSE
[09:31:37.667]                       if (inherits(cond, "message")) {
[09:31:37.667]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.667]                         if (muffled) 
[09:31:37.667]                           invokeRestart("muffleMessage")
[09:31:37.667]                       }
[09:31:37.667]                       else if (inherits(cond, "warning")) {
[09:31:37.667]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.667]                         if (muffled) 
[09:31:37.667]                           invokeRestart("muffleWarning")
[09:31:37.667]                       }
[09:31:37.667]                       else if (inherits(cond, "condition")) {
[09:31:37.667]                         if (!is.null(pattern)) {
[09:31:37.667]                           computeRestarts <- base::computeRestarts
[09:31:37.667]                           grepl <- base::grepl
[09:31:37.667]                           restarts <- computeRestarts(cond)
[09:31:37.667]                           for (restart in restarts) {
[09:31:37.667]                             name <- restart$name
[09:31:37.667]                             if (is.null(name)) 
[09:31:37.667]                               next
[09:31:37.667]                             if (!grepl(pattern, name)) 
[09:31:37.667]                               next
[09:31:37.667]                             invokeRestart(restart)
[09:31:37.667]                             muffled <- TRUE
[09:31:37.667]                             break
[09:31:37.667]                           }
[09:31:37.667]                         }
[09:31:37.667]                       }
[09:31:37.667]                       invisible(muffled)
[09:31:37.667]                     }
[09:31:37.667]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.667]                   }
[09:31:37.667]                 }
[09:31:37.667]             }
[09:31:37.667]         }))
[09:31:37.667]     }, error = function(ex) {
[09:31:37.667]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.667]                 ...future.rng), started = ...future.startTime, 
[09:31:37.667]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.667]             version = "1.8"), class = "FutureResult")
[09:31:37.667]     }, finally = {
[09:31:37.667]         if (!identical(...future.workdir, getwd())) 
[09:31:37.667]             setwd(...future.workdir)
[09:31:37.667]         {
[09:31:37.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.667]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.667]             }
[09:31:37.667]             base::options(...future.oldOptions)
[09:31:37.667]             if (.Platform$OS.type == "windows") {
[09:31:37.667]                 old_names <- names(...future.oldEnvVars)
[09:31:37.667]                 envs <- base::Sys.getenv()
[09:31:37.667]                 names <- names(envs)
[09:31:37.667]                 common <- intersect(names, old_names)
[09:31:37.667]                 added <- setdiff(names, old_names)
[09:31:37.667]                 removed <- setdiff(old_names, names)
[09:31:37.667]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.667]                   envs[common]]
[09:31:37.667]                 NAMES <- toupper(changed)
[09:31:37.667]                 args <- list()
[09:31:37.667]                 for (kk in seq_along(NAMES)) {
[09:31:37.667]                   name <- changed[[kk]]
[09:31:37.667]                   NAME <- NAMES[[kk]]
[09:31:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.667]                     next
[09:31:37.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.667]                 }
[09:31:37.667]                 NAMES <- toupper(added)
[09:31:37.667]                 for (kk in seq_along(NAMES)) {
[09:31:37.667]                   name <- added[[kk]]
[09:31:37.667]                   NAME <- NAMES[[kk]]
[09:31:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.667]                     next
[09:31:37.667]                   args[[name]] <- ""
[09:31:37.667]                 }
[09:31:37.667]                 NAMES <- toupper(removed)
[09:31:37.667]                 for (kk in seq_along(NAMES)) {
[09:31:37.667]                   name <- removed[[kk]]
[09:31:37.667]                   NAME <- NAMES[[kk]]
[09:31:37.667]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.667]                     next
[09:31:37.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.667]                 }
[09:31:37.667]                 if (length(args) > 0) 
[09:31:37.667]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.667]             }
[09:31:37.667]             else {
[09:31:37.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.667]             }
[09:31:37.667]             {
[09:31:37.667]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.667]                   0L) {
[09:31:37.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.667]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.667]                   base::options(opts)
[09:31:37.667]                 }
[09:31:37.667]                 {
[09:31:37.667]                   {
[09:31:37.667]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.667]                     NULL
[09:31:37.667]                   }
[09:31:37.667]                   options(future.plan = NULL)
[09:31:37.667]                   if (is.na(NA_character_)) 
[09:31:37.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.667]                     .init = FALSE)
[09:31:37.667]                 }
[09:31:37.667]             }
[09:31:37.667]         }
[09:31:37.667]     })
[09:31:37.667]     if (TRUE) {
[09:31:37.667]         base::sink(type = "output", split = FALSE)
[09:31:37.667]         if (TRUE) {
[09:31:37.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.667]         }
[09:31:37.667]         else {
[09:31:37.667]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.667]         }
[09:31:37.667]         base::close(...future.stdout)
[09:31:37.667]         ...future.stdout <- NULL
[09:31:37.667]     }
[09:31:37.667]     ...future.result$conditions <- ...future.conditions
[09:31:37.667]     ...future.result$finished <- base::Sys.time()
[09:31:37.667]     ...future.result
[09:31:37.667] }
[09:31:37.670] MultisessionFuture started
[09:31:37.670] - Launch lazy future ... done
[09:31:37.670] run() for ‘MultisessionFuture’ ... done
[09:31:37.670] result() for ClusterFuture ...
[09:31:37.670] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.670] - Validating connection of MultisessionFuture
[09:31:37.713] - received message: FutureResult
[09:31:37.714] - Received FutureResult
[09:31:37.714] - Erased future from FutureRegistry
[09:31:37.714] result() for ClusterFuture ...
[09:31:37.714] - result already collected: FutureResult
[09:31:37.714] result() for ClusterFuture ... done
[09:31:37.714] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.714] result() for ClusterFuture ... done
[09:31:37.714] result() for ClusterFuture ...
[09:31:37.714] - result already collected: FutureResult
[09:31:37.714] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.715] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.715] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.716] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:37.716] Searching for globals ... DONE
[09:31:37.717] Resolving globals: TRUE
[09:31:37.717] Resolving any globals that are futures ...
[09:31:37.717] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[09:31:37.717] Resolving any globals that are futures ... DONE
[09:31:37.717] Resolving futures part of globals (recursively) ...
[09:31:37.717] resolve() on list ...
[09:31:37.717]  recursive: 99
[09:31:37.717]  length: 1
[09:31:37.718]  elements: ‘x’
[09:31:37.718]  length: 0 (resolved future 1)
[09:31:37.718] resolve() on list ... DONE
[09:31:37.718] - globals: [1] ‘x’
[09:31:37.718] Resolving futures part of globals (recursively) ... DONE
[09:31:37.718] The total size of the 1 globals is 56 bytes (56 bytes)
[09:31:37.718] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (56 bytes of class ‘numeric’)
[09:31:37.719] - globals: [1] ‘x’
[09:31:37.719] 
[09:31:37.719] getGlobalsAndPackages() ... DONE
[09:31:37.719] run() for ‘Future’ ...
[09:31:37.719] - state: ‘created’
[09:31:37.719] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.732] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.732] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.732]   - Field: ‘node’
[09:31:37.733]   - Field: ‘label’
[09:31:37.733]   - Field: ‘local’
[09:31:37.733]   - Field: ‘owner’
[09:31:37.733]   - Field: ‘envir’
[09:31:37.733]   - Field: ‘workers’
[09:31:37.733]   - Field: ‘packages’
[09:31:37.733]   - Field: ‘gc’
[09:31:37.733]   - Field: ‘conditions’
[09:31:37.733]   - Field: ‘persistent’
[09:31:37.733]   - Field: ‘expr’
[09:31:37.733]   - Field: ‘uuid’
[09:31:37.734]   - Field: ‘seed’
[09:31:37.734]   - Field: ‘version’
[09:31:37.734]   - Field: ‘result’
[09:31:37.734]   - Field: ‘asynchronous’
[09:31:37.734]   - Field: ‘calls’
[09:31:37.734]   - Field: ‘globals’
[09:31:37.734]   - Field: ‘stdout’
[09:31:37.734]   - Field: ‘earlySignal’
[09:31:37.734]   - Field: ‘lazy’
[09:31:37.734]   - Field: ‘state’
[09:31:37.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.735] - Launch lazy future ...
[09:31:37.735] Packages needed by the future expression (n = 0): <none>
[09:31:37.735] Packages needed by future strategies (n = 0): <none>
[09:31:37.735] {
[09:31:37.735]     {
[09:31:37.735]         {
[09:31:37.735]             ...future.startTime <- base::Sys.time()
[09:31:37.735]             {
[09:31:37.735]                 {
[09:31:37.735]                   {
[09:31:37.735]                     {
[09:31:37.735]                       base::local({
[09:31:37.735]                         has_future <- base::requireNamespace("future", 
[09:31:37.735]                           quietly = TRUE)
[09:31:37.735]                         if (has_future) {
[09:31:37.735]                           ns <- base::getNamespace("future")
[09:31:37.735]                           version <- ns[[".package"]][["version"]]
[09:31:37.735]                           if (is.null(version)) 
[09:31:37.735]                             version <- utils::packageVersion("future")
[09:31:37.735]                         }
[09:31:37.735]                         else {
[09:31:37.735]                           version <- NULL
[09:31:37.735]                         }
[09:31:37.735]                         if (!has_future || version < "1.8.0") {
[09:31:37.735]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.735]                             "", base::R.version$version.string), 
[09:31:37.735]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.735]                               "release", "version")], collapse = " "), 
[09:31:37.735]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.735]                             info)
[09:31:37.735]                           info <- base::paste(info, collapse = "; ")
[09:31:37.735]                           if (!has_future) {
[09:31:37.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.735]                               info)
[09:31:37.735]                           }
[09:31:37.735]                           else {
[09:31:37.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.735]                               info, version)
[09:31:37.735]                           }
[09:31:37.735]                           base::stop(msg)
[09:31:37.735]                         }
[09:31:37.735]                       })
[09:31:37.735]                     }
[09:31:37.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.735]                     base::options(mc.cores = 1L)
[09:31:37.735]                   }
[09:31:37.735]                   ...future.strategy.old <- future::plan("list")
[09:31:37.735]                   options(future.plan = NULL)
[09:31:37.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.735]                 }
[09:31:37.735]                 ...future.workdir <- getwd()
[09:31:37.735]             }
[09:31:37.735]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.735]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.735]         }
[09:31:37.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.735]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.735]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.735]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.735]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.735]             base::names(...future.oldOptions))
[09:31:37.735]     }
[09:31:37.735]     if (FALSE) {
[09:31:37.735]     }
[09:31:37.735]     else {
[09:31:37.735]         if (TRUE) {
[09:31:37.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.735]                 open = "w")
[09:31:37.735]         }
[09:31:37.735]         else {
[09:31:37.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.735]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.735]         }
[09:31:37.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.735]             base::sink(type = "output", split = FALSE)
[09:31:37.735]             base::close(...future.stdout)
[09:31:37.735]         }, add = TRUE)
[09:31:37.735]     }
[09:31:37.735]     ...future.frame <- base::sys.nframe()
[09:31:37.735]     ...future.conditions <- base::list()
[09:31:37.735]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.735]     if (FALSE) {
[09:31:37.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.735]     }
[09:31:37.735]     ...future.result <- base::tryCatch({
[09:31:37.735]         base::withCallingHandlers({
[09:31:37.735]             ...future.value <- base::withVisible(base::local({
[09:31:37.735]                 ...future.makeSendCondition <- base::local({
[09:31:37.735]                   sendCondition <- NULL
[09:31:37.735]                   function(frame = 1L) {
[09:31:37.735]                     if (is.function(sendCondition)) 
[09:31:37.735]                       return(sendCondition)
[09:31:37.735]                     ns <- getNamespace("parallel")
[09:31:37.735]                     if (exists("sendData", mode = "function", 
[09:31:37.735]                       envir = ns)) {
[09:31:37.735]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.735]                         envir = ns)
[09:31:37.735]                       envir <- sys.frame(frame)
[09:31:37.735]                       master <- NULL
[09:31:37.735]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.735]                         !identical(envir, emptyenv())) {
[09:31:37.735]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.735]                           inherits = FALSE)) {
[09:31:37.735]                           master <- get("master", mode = "list", 
[09:31:37.735]                             envir = envir, inherits = FALSE)
[09:31:37.735]                           if (inherits(master, c("SOCKnode", 
[09:31:37.735]                             "SOCK0node"))) {
[09:31:37.735]                             sendCondition <<- function(cond) {
[09:31:37.735]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.735]                                 success = TRUE)
[09:31:37.735]                               parallel_sendData(master, data)
[09:31:37.735]                             }
[09:31:37.735]                             return(sendCondition)
[09:31:37.735]                           }
[09:31:37.735]                         }
[09:31:37.735]                         frame <- frame + 1L
[09:31:37.735]                         envir <- sys.frame(frame)
[09:31:37.735]                       }
[09:31:37.735]                     }
[09:31:37.735]                     sendCondition <<- function(cond) NULL
[09:31:37.735]                   }
[09:31:37.735]                 })
[09:31:37.735]                 withCallingHandlers({
[09:31:37.735]                   {
[09:31:37.735]                     x <- x + 1
[09:31:37.735]                     x
[09:31:37.735]                   }
[09:31:37.735]                 }, immediateCondition = function(cond) {
[09:31:37.735]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.735]                   sendCondition(cond)
[09:31:37.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.735]                   {
[09:31:37.735]                     inherits <- base::inherits
[09:31:37.735]                     invokeRestart <- base::invokeRestart
[09:31:37.735]                     is.null <- base::is.null
[09:31:37.735]                     muffled <- FALSE
[09:31:37.735]                     if (inherits(cond, "message")) {
[09:31:37.735]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.735]                       if (muffled) 
[09:31:37.735]                         invokeRestart("muffleMessage")
[09:31:37.735]                     }
[09:31:37.735]                     else if (inherits(cond, "warning")) {
[09:31:37.735]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.735]                       if (muffled) 
[09:31:37.735]                         invokeRestart("muffleWarning")
[09:31:37.735]                     }
[09:31:37.735]                     else if (inherits(cond, "condition")) {
[09:31:37.735]                       if (!is.null(pattern)) {
[09:31:37.735]                         computeRestarts <- base::computeRestarts
[09:31:37.735]                         grepl <- base::grepl
[09:31:37.735]                         restarts <- computeRestarts(cond)
[09:31:37.735]                         for (restart in restarts) {
[09:31:37.735]                           name <- restart$name
[09:31:37.735]                           if (is.null(name)) 
[09:31:37.735]                             next
[09:31:37.735]                           if (!grepl(pattern, name)) 
[09:31:37.735]                             next
[09:31:37.735]                           invokeRestart(restart)
[09:31:37.735]                           muffled <- TRUE
[09:31:37.735]                           break
[09:31:37.735]                         }
[09:31:37.735]                       }
[09:31:37.735]                     }
[09:31:37.735]                     invisible(muffled)
[09:31:37.735]                   }
[09:31:37.735]                   muffleCondition(cond)
[09:31:37.735]                 })
[09:31:37.735]             }))
[09:31:37.735]             future::FutureResult(value = ...future.value$value, 
[09:31:37.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.735]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.735]                     ...future.globalenv.names))
[09:31:37.735]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.735]         }, condition = base::local({
[09:31:37.735]             c <- base::c
[09:31:37.735]             inherits <- base::inherits
[09:31:37.735]             invokeRestart <- base::invokeRestart
[09:31:37.735]             length <- base::length
[09:31:37.735]             list <- base::list
[09:31:37.735]             seq.int <- base::seq.int
[09:31:37.735]             signalCondition <- base::signalCondition
[09:31:37.735]             sys.calls <- base::sys.calls
[09:31:37.735]             `[[` <- base::`[[`
[09:31:37.735]             `+` <- base::`+`
[09:31:37.735]             `<<-` <- base::`<<-`
[09:31:37.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.735]                   3L)]
[09:31:37.735]             }
[09:31:37.735]             function(cond) {
[09:31:37.735]                 is_error <- inherits(cond, "error")
[09:31:37.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.735]                   NULL)
[09:31:37.735]                 if (is_error) {
[09:31:37.735]                   sessionInformation <- function() {
[09:31:37.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.735]                       search = base::search(), system = base::Sys.info())
[09:31:37.735]                   }
[09:31:37.735]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.735]                     cond$call), session = sessionInformation(), 
[09:31:37.735]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.735]                   signalCondition(cond)
[09:31:37.735]                 }
[09:31:37.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.735]                 "immediateCondition"))) {
[09:31:37.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.735]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.735]                   if (TRUE && !signal) {
[09:31:37.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.735]                     {
[09:31:37.735]                       inherits <- base::inherits
[09:31:37.735]                       invokeRestart <- base::invokeRestart
[09:31:37.735]                       is.null <- base::is.null
[09:31:37.735]                       muffled <- FALSE
[09:31:37.735]                       if (inherits(cond, "message")) {
[09:31:37.735]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.735]                         if (muffled) 
[09:31:37.735]                           invokeRestart("muffleMessage")
[09:31:37.735]                       }
[09:31:37.735]                       else if (inherits(cond, "warning")) {
[09:31:37.735]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.735]                         if (muffled) 
[09:31:37.735]                           invokeRestart("muffleWarning")
[09:31:37.735]                       }
[09:31:37.735]                       else if (inherits(cond, "condition")) {
[09:31:37.735]                         if (!is.null(pattern)) {
[09:31:37.735]                           computeRestarts <- base::computeRestarts
[09:31:37.735]                           grepl <- base::grepl
[09:31:37.735]                           restarts <- computeRestarts(cond)
[09:31:37.735]                           for (restart in restarts) {
[09:31:37.735]                             name <- restart$name
[09:31:37.735]                             if (is.null(name)) 
[09:31:37.735]                               next
[09:31:37.735]                             if (!grepl(pattern, name)) 
[09:31:37.735]                               next
[09:31:37.735]                             invokeRestart(restart)
[09:31:37.735]                             muffled <- TRUE
[09:31:37.735]                             break
[09:31:37.735]                           }
[09:31:37.735]                         }
[09:31:37.735]                       }
[09:31:37.735]                       invisible(muffled)
[09:31:37.735]                     }
[09:31:37.735]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.735]                   }
[09:31:37.735]                 }
[09:31:37.735]                 else {
[09:31:37.735]                   if (TRUE) {
[09:31:37.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.735]                     {
[09:31:37.735]                       inherits <- base::inherits
[09:31:37.735]                       invokeRestart <- base::invokeRestart
[09:31:37.735]                       is.null <- base::is.null
[09:31:37.735]                       muffled <- FALSE
[09:31:37.735]                       if (inherits(cond, "message")) {
[09:31:37.735]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.735]                         if (muffled) 
[09:31:37.735]                           invokeRestart("muffleMessage")
[09:31:37.735]                       }
[09:31:37.735]                       else if (inherits(cond, "warning")) {
[09:31:37.735]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.735]                         if (muffled) 
[09:31:37.735]                           invokeRestart("muffleWarning")
[09:31:37.735]                       }
[09:31:37.735]                       else if (inherits(cond, "condition")) {
[09:31:37.735]                         if (!is.null(pattern)) {
[09:31:37.735]                           computeRestarts <- base::computeRestarts
[09:31:37.735]                           grepl <- base::grepl
[09:31:37.735]                           restarts <- computeRestarts(cond)
[09:31:37.735]                           for (restart in restarts) {
[09:31:37.735]                             name <- restart$name
[09:31:37.735]                             if (is.null(name)) 
[09:31:37.735]                               next
[09:31:37.735]                             if (!grepl(pattern, name)) 
[09:31:37.735]                               next
[09:31:37.735]                             invokeRestart(restart)
[09:31:37.735]                             muffled <- TRUE
[09:31:37.735]                             break
[09:31:37.735]                           }
[09:31:37.735]                         }
[09:31:37.735]                       }
[09:31:37.735]                       invisible(muffled)
[09:31:37.735]                     }
[09:31:37.735]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.735]                   }
[09:31:37.735]                 }
[09:31:37.735]             }
[09:31:37.735]         }))
[09:31:37.735]     }, error = function(ex) {
[09:31:37.735]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.735]                 ...future.rng), started = ...future.startTime, 
[09:31:37.735]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.735]             version = "1.8"), class = "FutureResult")
[09:31:37.735]     }, finally = {
[09:31:37.735]         if (!identical(...future.workdir, getwd())) 
[09:31:37.735]             setwd(...future.workdir)
[09:31:37.735]         {
[09:31:37.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.735]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.735]             }
[09:31:37.735]             base::options(...future.oldOptions)
[09:31:37.735]             if (.Platform$OS.type == "windows") {
[09:31:37.735]                 old_names <- names(...future.oldEnvVars)
[09:31:37.735]                 envs <- base::Sys.getenv()
[09:31:37.735]                 names <- names(envs)
[09:31:37.735]                 common <- intersect(names, old_names)
[09:31:37.735]                 added <- setdiff(names, old_names)
[09:31:37.735]                 removed <- setdiff(old_names, names)
[09:31:37.735]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.735]                   envs[common]]
[09:31:37.735]                 NAMES <- toupper(changed)
[09:31:37.735]                 args <- list()
[09:31:37.735]                 for (kk in seq_along(NAMES)) {
[09:31:37.735]                   name <- changed[[kk]]
[09:31:37.735]                   NAME <- NAMES[[kk]]
[09:31:37.735]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.735]                     next
[09:31:37.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.735]                 }
[09:31:37.735]                 NAMES <- toupper(added)
[09:31:37.735]                 for (kk in seq_along(NAMES)) {
[09:31:37.735]                   name <- added[[kk]]
[09:31:37.735]                   NAME <- NAMES[[kk]]
[09:31:37.735]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.735]                     next
[09:31:37.735]                   args[[name]] <- ""
[09:31:37.735]                 }
[09:31:37.735]                 NAMES <- toupper(removed)
[09:31:37.735]                 for (kk in seq_along(NAMES)) {
[09:31:37.735]                   name <- removed[[kk]]
[09:31:37.735]                   NAME <- NAMES[[kk]]
[09:31:37.735]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.735]                     next
[09:31:37.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.735]                 }
[09:31:37.735]                 if (length(args) > 0) 
[09:31:37.735]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.735]             }
[09:31:37.735]             else {
[09:31:37.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.735]             }
[09:31:37.735]             {
[09:31:37.735]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.735]                   0L) {
[09:31:37.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.735]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.735]                   base::options(opts)
[09:31:37.735]                 }
[09:31:37.735]                 {
[09:31:37.735]                   {
[09:31:37.735]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.735]                     NULL
[09:31:37.735]                   }
[09:31:37.735]                   options(future.plan = NULL)
[09:31:37.735]                   if (is.na(NA_character_)) 
[09:31:37.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.735]                     .init = FALSE)
[09:31:37.735]                 }
[09:31:37.735]             }
[09:31:37.735]         }
[09:31:37.735]     })
[09:31:37.735]     if (TRUE) {
[09:31:37.735]         base::sink(type = "output", split = FALSE)
[09:31:37.735]         if (TRUE) {
[09:31:37.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.735]         }
[09:31:37.735]         else {
[09:31:37.735]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.735]         }
[09:31:37.735]         base::close(...future.stdout)
[09:31:37.735]         ...future.stdout <- NULL
[09:31:37.735]     }
[09:31:37.735]     ...future.result$conditions <- ...future.conditions
[09:31:37.735]     ...future.result$finished <- base::Sys.time()
[09:31:37.735]     ...future.result
[09:31:37.735] }
[09:31:37.738] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:31:37.738] Exporting ‘x’ (56 bytes) to cluster node #1 ...
[09:31:37.738] Exporting ‘x’ (56 bytes) to cluster node #1 ... DONE
[09:31:37.738] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:31:37.739] MultisessionFuture started
[09:31:37.739] - Launch lazy future ... done
[09:31:37.739] run() for ‘MultisessionFuture’ ... done
[09:31:37.739] result() for ClusterFuture ...
[09:31:37.739] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.739] - Validating connection of MultisessionFuture
[09:31:37.781] - received message: FutureResult
[09:31:37.781] - Received FutureResult
[09:31:37.782] - Erased future from FutureRegistry
[09:31:37.782] result() for ClusterFuture ...
[09:31:37.782] - result already collected: FutureResult
[09:31:37.782] result() for ClusterFuture ... done
[09:31:37.782] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.782] result() for ClusterFuture ... done
[09:31:37.782] result() for ClusterFuture ...
[09:31:37.782] - result already collected: FutureResult
[09:31:37.782] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[09:31:37.783] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[09:31:37.783] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[09:31:37.785] - globals found: [3] ‘{’, ‘<-’, ‘x’
[09:31:37.785] Searching for globals ... DONE
[09:31:37.785] Resolving globals: TRUE
[09:31:37.785] Resolving any globals that are futures ...
[09:31:37.785] - globals: [3] ‘{’, ‘<-’, ‘x’
[09:31:37.785] Resolving any globals that are futures ... DONE
[09:31:37.785] Resolving futures part of globals (recursively) ...
[09:31:37.786] resolve() on list ...
[09:31:37.786]  recursive: 99
[09:31:37.786]  length: 1
[09:31:37.786]  elements: ‘x’
[09:31:37.786]  length: 0 (resolved future 1)
[09:31:37.786] resolve() on list ... DONE
[09:31:37.786] - globals: [1] ‘x’
[09:31:37.786] Resolving futures part of globals (recursively) ... DONE
[09:31:37.786] The total size of the 1 globals is 1.01 KiB (1032 bytes)
[09:31:37.787] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 1.01 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (1.01 KiB of class ‘function’)
[09:31:37.787] - globals: [1] ‘x’
[09:31:37.787] 
[09:31:37.787] getGlobalsAndPackages() ... DONE
[09:31:37.787] run() for ‘Future’ ...
[09:31:37.787] - state: ‘created’
[09:31:37.787] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:31:37.801] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:31:37.801] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:31:37.801]   - Field: ‘node’
[09:31:37.801]   - Field: ‘label’
[09:31:37.801]   - Field: ‘local’
[09:31:37.801]   - Field: ‘owner’
[09:31:37.801]   - Field: ‘envir’
[09:31:37.801]   - Field: ‘workers’
[09:31:37.801]   - Field: ‘packages’
[09:31:37.801]   - Field: ‘gc’
[09:31:37.802]   - Field: ‘conditions’
[09:31:37.802]   - Field: ‘persistent’
[09:31:37.802]   - Field: ‘expr’
[09:31:37.802]   - Field: ‘uuid’
[09:31:37.802]   - Field: ‘seed’
[09:31:37.802]   - Field: ‘version’
[09:31:37.802]   - Field: ‘result’
[09:31:37.802]   - Field: ‘asynchronous’
[09:31:37.802]   - Field: ‘calls’
[09:31:37.802]   - Field: ‘globals’
[09:31:37.802]   - Field: ‘stdout’
[09:31:37.802]   - Field: ‘earlySignal’
[09:31:37.803]   - Field: ‘lazy’
[09:31:37.803]   - Field: ‘state’
[09:31:37.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:31:37.803] - Launch lazy future ...
[09:31:37.803] Packages needed by the future expression (n = 0): <none>
[09:31:37.803] Packages needed by future strategies (n = 0): <none>
[09:31:37.804] {
[09:31:37.804]     {
[09:31:37.804]         {
[09:31:37.804]             ...future.startTime <- base::Sys.time()
[09:31:37.804]             {
[09:31:37.804]                 {
[09:31:37.804]                   {
[09:31:37.804]                     {
[09:31:37.804]                       base::local({
[09:31:37.804]                         has_future <- base::requireNamespace("future", 
[09:31:37.804]                           quietly = TRUE)
[09:31:37.804]                         if (has_future) {
[09:31:37.804]                           ns <- base::getNamespace("future")
[09:31:37.804]                           version <- ns[[".package"]][["version"]]
[09:31:37.804]                           if (is.null(version)) 
[09:31:37.804]                             version <- utils::packageVersion("future")
[09:31:37.804]                         }
[09:31:37.804]                         else {
[09:31:37.804]                           version <- NULL
[09:31:37.804]                         }
[09:31:37.804]                         if (!has_future || version < "1.8.0") {
[09:31:37.804]                           info <- base::c(r_version = base::gsub("R version ", 
[09:31:37.804]                             "", base::R.version$version.string), 
[09:31:37.804]                             platform = base::sprintf("%s (%s-bit)", 
[09:31:37.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:37.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:37.804]                               "release", "version")], collapse = " "), 
[09:31:37.804]                             hostname = base::Sys.info()[["nodename"]])
[09:31:37.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:31:37.804]                             info)
[09:31:37.804]                           info <- base::paste(info, collapse = "; ")
[09:31:37.804]                           if (!has_future) {
[09:31:37.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:37.804]                               info)
[09:31:37.804]                           }
[09:31:37.804]                           else {
[09:31:37.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:37.804]                               info, version)
[09:31:37.804]                           }
[09:31:37.804]                           base::stop(msg)
[09:31:37.804]                         }
[09:31:37.804]                       })
[09:31:37.804]                     }
[09:31:37.804]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:31:37.804]                     base::options(mc.cores = 1L)
[09:31:37.804]                   }
[09:31:37.804]                   ...future.strategy.old <- future::plan("list")
[09:31:37.804]                   options(future.plan = NULL)
[09:31:37.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:37.804]                 }
[09:31:37.804]                 ...future.workdir <- getwd()
[09:31:37.804]             }
[09:31:37.804]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:37.804]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:37.804]         }
[09:31:37.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[09:31:37.804]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[09:31:37.804]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[09:31:37.804]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[09:31:37.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:37.804]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:37.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:37.804]             base::names(...future.oldOptions))
[09:31:37.804]     }
[09:31:37.804]     if (FALSE) {
[09:31:37.804]     }
[09:31:37.804]     else {
[09:31:37.804]         if (TRUE) {
[09:31:37.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:37.804]                 open = "w")
[09:31:37.804]         }
[09:31:37.804]         else {
[09:31:37.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:37.804]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:37.804]         }
[09:31:37.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:37.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:37.804]             base::sink(type = "output", split = FALSE)
[09:31:37.804]             base::close(...future.stdout)
[09:31:37.804]         }, add = TRUE)
[09:31:37.804]     }
[09:31:37.804]     ...future.frame <- base::sys.nframe()
[09:31:37.804]     ...future.conditions <- base::list()
[09:31:37.804]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:37.804]     if (FALSE) {
[09:31:37.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:37.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:37.804]     }
[09:31:37.804]     ...future.result <- base::tryCatch({
[09:31:37.804]         base::withCallingHandlers({
[09:31:37.804]             ...future.value <- base::withVisible(base::local({
[09:31:37.804]                 ...future.makeSendCondition <- base::local({
[09:31:37.804]                   sendCondition <- NULL
[09:31:37.804]                   function(frame = 1L) {
[09:31:37.804]                     if (is.function(sendCondition)) 
[09:31:37.804]                       return(sendCondition)
[09:31:37.804]                     ns <- getNamespace("parallel")
[09:31:37.804]                     if (exists("sendData", mode = "function", 
[09:31:37.804]                       envir = ns)) {
[09:31:37.804]                       parallel_sendData <- get("sendData", mode = "function", 
[09:31:37.804]                         envir = ns)
[09:31:37.804]                       envir <- sys.frame(frame)
[09:31:37.804]                       master <- NULL
[09:31:37.804]                       while (!identical(envir, .GlobalEnv) && 
[09:31:37.804]                         !identical(envir, emptyenv())) {
[09:31:37.804]                         if (exists("master", mode = "list", envir = envir, 
[09:31:37.804]                           inherits = FALSE)) {
[09:31:37.804]                           master <- get("master", mode = "list", 
[09:31:37.804]                             envir = envir, inherits = FALSE)
[09:31:37.804]                           if (inherits(master, c("SOCKnode", 
[09:31:37.804]                             "SOCK0node"))) {
[09:31:37.804]                             sendCondition <<- function(cond) {
[09:31:37.804]                               data <- list(type = "VALUE", value = cond, 
[09:31:37.804]                                 success = TRUE)
[09:31:37.804]                               parallel_sendData(master, data)
[09:31:37.804]                             }
[09:31:37.804]                             return(sendCondition)
[09:31:37.804]                           }
[09:31:37.804]                         }
[09:31:37.804]                         frame <- frame + 1L
[09:31:37.804]                         envir <- sys.frame(frame)
[09:31:37.804]                       }
[09:31:37.804]                     }
[09:31:37.804]                     sendCondition <<- function(cond) NULL
[09:31:37.804]                   }
[09:31:37.804]                 })
[09:31:37.804]                 withCallingHandlers({
[09:31:37.804]                   {
[09:31:37.804]                     x <- x()
[09:31:37.804]                     x
[09:31:37.804]                   }
[09:31:37.804]                 }, immediateCondition = function(cond) {
[09:31:37.804]                   sendCondition <- ...future.makeSendCondition()
[09:31:37.804]                   sendCondition(cond)
[09:31:37.804]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.804]                   {
[09:31:37.804]                     inherits <- base::inherits
[09:31:37.804]                     invokeRestart <- base::invokeRestart
[09:31:37.804]                     is.null <- base::is.null
[09:31:37.804]                     muffled <- FALSE
[09:31:37.804]                     if (inherits(cond, "message")) {
[09:31:37.804]                       muffled <- grepl(pattern, "muffleMessage")
[09:31:37.804]                       if (muffled) 
[09:31:37.804]                         invokeRestart("muffleMessage")
[09:31:37.804]                     }
[09:31:37.804]                     else if (inherits(cond, "warning")) {
[09:31:37.804]                       muffled <- grepl(pattern, "muffleWarning")
[09:31:37.804]                       if (muffled) 
[09:31:37.804]                         invokeRestart("muffleWarning")
[09:31:37.804]                     }
[09:31:37.804]                     else if (inherits(cond, "condition")) {
[09:31:37.804]                       if (!is.null(pattern)) {
[09:31:37.804]                         computeRestarts <- base::computeRestarts
[09:31:37.804]                         grepl <- base::grepl
[09:31:37.804]                         restarts <- computeRestarts(cond)
[09:31:37.804]                         for (restart in restarts) {
[09:31:37.804]                           name <- restart$name
[09:31:37.804]                           if (is.null(name)) 
[09:31:37.804]                             next
[09:31:37.804]                           if (!grepl(pattern, name)) 
[09:31:37.804]                             next
[09:31:37.804]                           invokeRestart(restart)
[09:31:37.804]                           muffled <- TRUE
[09:31:37.804]                           break
[09:31:37.804]                         }
[09:31:37.804]                       }
[09:31:37.804]                     }
[09:31:37.804]                     invisible(muffled)
[09:31:37.804]                   }
[09:31:37.804]                   muffleCondition(cond)
[09:31:37.804]                 })
[09:31:37.804]             }))
[09:31:37.804]             future::FutureResult(value = ...future.value$value, 
[09:31:37.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.804]                   ...future.rng), globalenv = if (FALSE) 
[09:31:37.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:37.804]                     ...future.globalenv.names))
[09:31:37.804]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:37.804]         }, condition = base::local({
[09:31:37.804]             c <- base::c
[09:31:37.804]             inherits <- base::inherits
[09:31:37.804]             invokeRestart <- base::invokeRestart
[09:31:37.804]             length <- base::length
[09:31:37.804]             list <- base::list
[09:31:37.804]             seq.int <- base::seq.int
[09:31:37.804]             signalCondition <- base::signalCondition
[09:31:37.804]             sys.calls <- base::sys.calls
[09:31:37.804]             `[[` <- base::`[[`
[09:31:37.804]             `+` <- base::`+`
[09:31:37.804]             `<<-` <- base::`<<-`
[09:31:37.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:37.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:37.804]                   3L)]
[09:31:37.804]             }
[09:31:37.804]             function(cond) {
[09:31:37.804]                 is_error <- inherits(cond, "error")
[09:31:37.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:37.804]                   NULL)
[09:31:37.804]                 if (is_error) {
[09:31:37.804]                   sessionInformation <- function() {
[09:31:37.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:37.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:37.804]                       search = base::search(), system = base::Sys.info())
[09:31:37.804]                   }
[09:31:37.804]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:37.804]                     cond$call), session = sessionInformation(), 
[09:31:37.804]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:37.804]                   signalCondition(cond)
[09:31:37.804]                 }
[09:31:37.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:37.804]                 "immediateCondition"))) {
[09:31:37.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:37.804]                   ...future.conditions[[length(...future.conditions) + 
[09:31:37.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:37.804]                   if (TRUE && !signal) {
[09:31:37.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.804]                     {
[09:31:37.804]                       inherits <- base::inherits
[09:31:37.804]                       invokeRestart <- base::invokeRestart
[09:31:37.804]                       is.null <- base::is.null
[09:31:37.804]                       muffled <- FALSE
[09:31:37.804]                       if (inherits(cond, "message")) {
[09:31:37.804]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.804]                         if (muffled) 
[09:31:37.804]                           invokeRestart("muffleMessage")
[09:31:37.804]                       }
[09:31:37.804]                       else if (inherits(cond, "warning")) {
[09:31:37.804]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.804]                         if (muffled) 
[09:31:37.804]                           invokeRestart("muffleWarning")
[09:31:37.804]                       }
[09:31:37.804]                       else if (inherits(cond, "condition")) {
[09:31:37.804]                         if (!is.null(pattern)) {
[09:31:37.804]                           computeRestarts <- base::computeRestarts
[09:31:37.804]                           grepl <- base::grepl
[09:31:37.804]                           restarts <- computeRestarts(cond)
[09:31:37.804]                           for (restart in restarts) {
[09:31:37.804]                             name <- restart$name
[09:31:37.804]                             if (is.null(name)) 
[09:31:37.804]                               next
[09:31:37.804]                             if (!grepl(pattern, name)) 
[09:31:37.804]                               next
[09:31:37.804]                             invokeRestart(restart)
[09:31:37.804]                             muffled <- TRUE
[09:31:37.804]                             break
[09:31:37.804]                           }
[09:31:37.804]                         }
[09:31:37.804]                       }
[09:31:37.804]                       invisible(muffled)
[09:31:37.804]                     }
[09:31:37.804]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.804]                   }
[09:31:37.804]                 }
[09:31:37.804]                 else {
[09:31:37.804]                   if (TRUE) {
[09:31:37.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:37.804]                     {
[09:31:37.804]                       inherits <- base::inherits
[09:31:37.804]                       invokeRestart <- base::invokeRestart
[09:31:37.804]                       is.null <- base::is.null
[09:31:37.804]                       muffled <- FALSE
[09:31:37.804]                       if (inherits(cond, "message")) {
[09:31:37.804]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:37.804]                         if (muffled) 
[09:31:37.804]                           invokeRestart("muffleMessage")
[09:31:37.804]                       }
[09:31:37.804]                       else if (inherits(cond, "warning")) {
[09:31:37.804]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:37.804]                         if (muffled) 
[09:31:37.804]                           invokeRestart("muffleWarning")
[09:31:37.804]                       }
[09:31:37.804]                       else if (inherits(cond, "condition")) {
[09:31:37.804]                         if (!is.null(pattern)) {
[09:31:37.804]                           computeRestarts <- base::computeRestarts
[09:31:37.804]                           grepl <- base::grepl
[09:31:37.804]                           restarts <- computeRestarts(cond)
[09:31:37.804]                           for (restart in restarts) {
[09:31:37.804]                             name <- restart$name
[09:31:37.804]                             if (is.null(name)) 
[09:31:37.804]                               next
[09:31:37.804]                             if (!grepl(pattern, name)) 
[09:31:37.804]                               next
[09:31:37.804]                             invokeRestart(restart)
[09:31:37.804]                             muffled <- TRUE
[09:31:37.804]                             break
[09:31:37.804]                           }
[09:31:37.804]                         }
[09:31:37.804]                       }
[09:31:37.804]                       invisible(muffled)
[09:31:37.804]                     }
[09:31:37.804]                     muffleCondition(cond, pattern = "^muffle")
[09:31:37.804]                   }
[09:31:37.804]                 }
[09:31:37.804]             }
[09:31:37.804]         }))
[09:31:37.804]     }, error = function(ex) {
[09:31:37.804]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:37.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:37.804]                 ...future.rng), started = ...future.startTime, 
[09:31:37.804]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:37.804]             version = "1.8"), class = "FutureResult")
[09:31:37.804]     }, finally = {
[09:31:37.804]         if (!identical(...future.workdir, getwd())) 
[09:31:37.804]             setwd(...future.workdir)
[09:31:37.804]         {
[09:31:37.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:37.804]                 ...future.oldOptions$nwarnings <- NULL
[09:31:37.804]             }
[09:31:37.804]             base::options(...future.oldOptions)
[09:31:37.804]             if (.Platform$OS.type == "windows") {
[09:31:37.804]                 old_names <- names(...future.oldEnvVars)
[09:31:37.804]                 envs <- base::Sys.getenv()
[09:31:37.804]                 names <- names(envs)
[09:31:37.804]                 common <- intersect(names, old_names)
[09:31:37.804]                 added <- setdiff(names, old_names)
[09:31:37.804]                 removed <- setdiff(old_names, names)
[09:31:37.804]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:37.804]                   envs[common]]
[09:31:37.804]                 NAMES <- toupper(changed)
[09:31:37.804]                 args <- list()
[09:31:37.804]                 for (kk in seq_along(NAMES)) {
[09:31:37.804]                   name <- changed[[kk]]
[09:31:37.804]                   NAME <- NAMES[[kk]]
[09:31:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.804]                     next
[09:31:37.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.804]                 }
[09:31:37.804]                 NAMES <- toupper(added)
[09:31:37.804]                 for (kk in seq_along(NAMES)) {
[09:31:37.804]                   name <- added[[kk]]
[09:31:37.804]                   NAME <- NAMES[[kk]]
[09:31:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.804]                     next
[09:31:37.804]                   args[[name]] <- ""
[09:31:37.804]                 }
[09:31:37.804]                 NAMES <- toupper(removed)
[09:31:37.804]                 for (kk in seq_along(NAMES)) {
[09:31:37.804]                   name <- removed[[kk]]
[09:31:37.804]                   NAME <- NAMES[[kk]]
[09:31:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:37.804]                     next
[09:31:37.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:37.804]                 }
[09:31:37.804]                 if (length(args) > 0) 
[09:31:37.804]                   base::do.call(base::Sys.setenv, args = args)
[09:31:37.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:37.804]             }
[09:31:37.804]             else {
[09:31:37.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:37.804]             }
[09:31:37.804]             {
[09:31:37.804]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:37.804]                   0L) {
[09:31:37.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:37.804]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:37.804]                   base::options(opts)
[09:31:37.804]                 }
[09:31:37.804]                 {
[09:31:37.804]                   {
[09:31:37.804]                     base::options(mc.cores = ...future.mc.cores.old)
[09:31:37.804]                     NULL
[09:31:37.804]                   }
[09:31:37.804]                   options(future.plan = NULL)
[09:31:37.804]                   if (is.na(NA_character_)) 
[09:31:37.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:37.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:37.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:37.804]                     .init = FALSE)
[09:31:37.804]                 }
[09:31:37.804]             }
[09:31:37.804]         }
[09:31:37.804]     })
[09:31:37.804]     if (TRUE) {
[09:31:37.804]         base::sink(type = "output", split = FALSE)
[09:31:37.804]         if (TRUE) {
[09:31:37.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:37.804]         }
[09:31:37.804]         else {
[09:31:37.804]             ...future.result["stdout"] <- base::list(NULL)
[09:31:37.804]         }
[09:31:37.804]         base::close(...future.stdout)
[09:31:37.804]         ...future.stdout <- NULL
[09:31:37.804]     }
[09:31:37.804]     ...future.result$conditions <- ...future.conditions
[09:31:37.804]     ...future.result$finished <- base::Sys.time()
[09:31:37.804]     ...future.result
[09:31:37.804] }
[09:31:37.806] Exporting 1 global objects (1.01 KiB) to cluster node #1 ...
[09:31:37.806] Exporting ‘x’ (1.01 KiB) to cluster node #1 ...
[09:31:37.807] Exporting ‘x’ (1.01 KiB) to cluster node #1 ... DONE
[09:31:37.807] Exporting 1 global objects (1.01 KiB) to cluster node #1 ... DONE
[09:31:37.807] MultisessionFuture started
[09:31:37.807] - Launch lazy future ... done
[09:31:37.807] run() for ‘MultisessionFuture’ ... done
[09:31:37.807] result() for ClusterFuture ...
[09:31:37.808] receiveMessageFromWorker() for ClusterFuture ...
[09:31:37.808] - Validating connection of MultisessionFuture
[09:31:37.849] - received message: FutureResult
[09:31:37.850] - Received FutureResult
[09:31:37.850] - Erased future from FutureRegistry
[09:31:37.850] result() for ClusterFuture ...
[09:31:37.850] - result already collected: FutureResult
[09:31:37.850] result() for ClusterFuture ... done
[09:31:37.850] receiveMessageFromWorker() for ClusterFuture ... done
[09:31:37.850] result() for ClusterFuture ... done
[09:31:37.850] result() for ClusterFuture ...
[09:31:37.850] - result already collected: FutureResult
[09:31:37.850] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[09:31:37.851] plan(): Setting new future strategy stack:
[09:31:37.851] List of future strategies:
[09:31:37.851] 1. FutureStrategy:
[09:31:37.851]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:37.851]    - tweaked: FALSE
[09:31:37.851]    - call: future::plan(oplan)
[09:31:37.852] plan(): nbrOfWorkers() = 1
> 
