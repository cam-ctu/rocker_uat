
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:31:11.019] plan(): Setting new future strategy stack:
[09:31:11.020] List of future strategies:
[09:31:11.020] 1. sequential:
[09:31:11.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.020]    - tweaked: FALSE
[09:31:11.020]    - call: future::plan("sequential")
[09:31:11.030] plan(): nbrOfWorkers() = 1
> 
> message("*** FutureRegistry() ...")
*** FutureRegistry() ...
> 
> for (where in c(sprintf("multicore-%s", future:::session_uuid()), "rscript")) {
+   message(sprintf("*** FutureRegistry('%s', 'list') ...", where))
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) == 0L)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'add') ...", where))
+   f <- future({ 1 })
+   print(f)
+   FutureRegistry(where, action = "add", future = f)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'list') ...", where))
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) == 1L)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'remove') ...", where))
+   FutureRegistry(where, action = "remove", future = f)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'list') ...", where))
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) == 0L)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'add') ...", where))
+   f <- future({ 2 })
+   print(f)
+   FutureRegistry(where, action = "add", future = f)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'list') ...", where))
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) == 1L)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'collect-first') ...", where))
+   FutureRegistry(where, action = "collect-first")
+ 
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) < 1L)
+ 
+   message(sprintf("*** FutureRegistry('%s', 'add') ...", where))
+   f <- future({ 2 })
+   print(f)
+   FutureRegistry(where, action = "add", future = f)
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'reset') ...", where))
+   FutureRegistry(where, action = "reset")
+ 
+ 
+   message(sprintf("*** FutureRegistry('%s', 'list') ...", where))
+   futures <- FutureRegistry(where, action = "list")
+   print(futures)
+   stopifnot(length(futures) == 0L)
+ }
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'list') ...
list()
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'add') ...
[09:31:11.065] getGlobalsAndPackages() ...
[09:31:11.065] Searching for globals...
[09:31:11.070] - globals found: [1] ‘{’
[09:31:11.070] Searching for globals ... DONE
[09:31:11.070] Resolving globals: FALSE
[09:31:11.070] 
[09:31:11.070] 
[09:31:11.071] getGlobalsAndPackages() ... DONE
[09:31:11.071] run() for ‘Future’ ...
[09:31:11.071] - state: ‘created’
[09:31:11.071] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.072]   - Field: ‘label’
[09:31:11.072]   - Field: ‘local’
[09:31:11.072]   - Field: ‘owner’
[09:31:11.072]   - Field: ‘envir’
[09:31:11.072]   - Field: ‘packages’
[09:31:11.072]   - Field: ‘gc’
[09:31:11.073]   - Field: ‘conditions’
[09:31:11.073]   - Field: ‘expr’
[09:31:11.073]   - Field: ‘uuid’
[09:31:11.073]   - Field: ‘seed’
[09:31:11.073]   - Field: ‘version’
[09:31:11.073]   - Field: ‘result’
[09:31:11.073]   - Field: ‘asynchronous’
[09:31:11.073]   - Field: ‘calls’
[09:31:11.073]   - Field: ‘globals’
[09:31:11.073]   - Field: ‘stdout’
[09:31:11.073]   - Field: ‘earlySignal’
[09:31:11.074]   - Field: ‘lazy’
[09:31:11.074]   - Field: ‘state’
[09:31:11.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.074] - Launch lazy future ...
[09:31:11.074] Packages needed by the future expression (n = 0): <none>
[09:31:11.075] Packages needed by future strategies (n = 0): <none>
[09:31:11.075] {
[09:31:11.075]     {
[09:31:11.075]         {
[09:31:11.075]             ...future.startTime <- base::Sys.time()
[09:31:11.075]             {
[09:31:11.075]                 {
[09:31:11.075]                   {
[09:31:11.075]                     base::local({
[09:31:11.075]                       has_future <- base::requireNamespace("future", 
[09:31:11.075]                         quietly = TRUE)
[09:31:11.075]                       if (has_future) {
[09:31:11.075]                         ns <- base::getNamespace("future")
[09:31:11.075]                         version <- ns[[".package"]][["version"]]
[09:31:11.075]                         if (is.null(version)) 
[09:31:11.075]                           version <- utils::packageVersion("future")
[09:31:11.075]                       }
[09:31:11.075]                       else {
[09:31:11.075]                         version <- NULL
[09:31:11.075]                       }
[09:31:11.075]                       if (!has_future || version < "1.8.0") {
[09:31:11.075]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.075]                           "", base::R.version$version.string), 
[09:31:11.075]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.075]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.075]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.075]                             "release", "version")], collapse = " "), 
[09:31:11.075]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.075]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.075]                           info)
[09:31:11.075]                         info <- base::paste(info, collapse = "; ")
[09:31:11.075]                         if (!has_future) {
[09:31:11.075]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.075]                             info)
[09:31:11.075]                         }
[09:31:11.075]                         else {
[09:31:11.075]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.075]                             info, version)
[09:31:11.075]                         }
[09:31:11.075]                         base::stop(msg)
[09:31:11.075]                       }
[09:31:11.075]                     })
[09:31:11.075]                   }
[09:31:11.075]                   ...future.strategy.old <- future::plan("list")
[09:31:11.075]                   options(future.plan = NULL)
[09:31:11.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.075]                 }
[09:31:11.075]                 ...future.workdir <- getwd()
[09:31:11.075]             }
[09:31:11.075]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.075]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.075]         }
[09:31:11.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.075]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.075]             base::names(...future.oldOptions))
[09:31:11.075]     }
[09:31:11.075]     if (FALSE) {
[09:31:11.075]     }
[09:31:11.075]     else {
[09:31:11.075]         if (TRUE) {
[09:31:11.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.075]                 open = "w")
[09:31:11.075]         }
[09:31:11.075]         else {
[09:31:11.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.075]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.075]         }
[09:31:11.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.075]             base::sink(type = "output", split = FALSE)
[09:31:11.075]             base::close(...future.stdout)
[09:31:11.075]         }, add = TRUE)
[09:31:11.075]     }
[09:31:11.075]     ...future.frame <- base::sys.nframe()
[09:31:11.075]     ...future.conditions <- base::list()
[09:31:11.075]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.075]     if (FALSE) {
[09:31:11.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.075]     }
[09:31:11.075]     ...future.result <- base::tryCatch({
[09:31:11.075]         base::withCallingHandlers({
[09:31:11.075]             ...future.value <- base::withVisible(base::local({
[09:31:11.075]                 1
[09:31:11.075]             }))
[09:31:11.075]             future::FutureResult(value = ...future.value$value, 
[09:31:11.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.075]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.075]                     ...future.globalenv.names))
[09:31:11.075]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.075]         }, condition = base::local({
[09:31:11.075]             c <- base::c
[09:31:11.075]             inherits <- base::inherits
[09:31:11.075]             invokeRestart <- base::invokeRestart
[09:31:11.075]             length <- base::length
[09:31:11.075]             list <- base::list
[09:31:11.075]             seq.int <- base::seq.int
[09:31:11.075]             signalCondition <- base::signalCondition
[09:31:11.075]             sys.calls <- base::sys.calls
[09:31:11.075]             `[[` <- base::`[[`
[09:31:11.075]             `+` <- base::`+`
[09:31:11.075]             `<<-` <- base::`<<-`
[09:31:11.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.075]                   3L)]
[09:31:11.075]             }
[09:31:11.075]             function(cond) {
[09:31:11.075]                 is_error <- inherits(cond, "error")
[09:31:11.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.075]                   NULL)
[09:31:11.075]                 if (is_error) {
[09:31:11.075]                   sessionInformation <- function() {
[09:31:11.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.075]                       search = base::search(), system = base::Sys.info())
[09:31:11.075]                   }
[09:31:11.075]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.075]                     cond$call), session = sessionInformation(), 
[09:31:11.075]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.075]                   signalCondition(cond)
[09:31:11.075]                 }
[09:31:11.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.075]                 "immediateCondition"))) {
[09:31:11.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.075]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.075]                   if (TRUE && !signal) {
[09:31:11.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.075]                     {
[09:31:11.075]                       inherits <- base::inherits
[09:31:11.075]                       invokeRestart <- base::invokeRestart
[09:31:11.075]                       is.null <- base::is.null
[09:31:11.075]                       muffled <- FALSE
[09:31:11.075]                       if (inherits(cond, "message")) {
[09:31:11.075]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.075]                         if (muffled) 
[09:31:11.075]                           invokeRestart("muffleMessage")
[09:31:11.075]                       }
[09:31:11.075]                       else if (inherits(cond, "warning")) {
[09:31:11.075]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.075]                         if (muffled) 
[09:31:11.075]                           invokeRestart("muffleWarning")
[09:31:11.075]                       }
[09:31:11.075]                       else if (inherits(cond, "condition")) {
[09:31:11.075]                         if (!is.null(pattern)) {
[09:31:11.075]                           computeRestarts <- base::computeRestarts
[09:31:11.075]                           grepl <- base::grepl
[09:31:11.075]                           restarts <- computeRestarts(cond)
[09:31:11.075]                           for (restart in restarts) {
[09:31:11.075]                             name <- restart$name
[09:31:11.075]                             if (is.null(name)) 
[09:31:11.075]                               next
[09:31:11.075]                             if (!grepl(pattern, name)) 
[09:31:11.075]                               next
[09:31:11.075]                             invokeRestart(restart)
[09:31:11.075]                             muffled <- TRUE
[09:31:11.075]                             break
[09:31:11.075]                           }
[09:31:11.075]                         }
[09:31:11.075]                       }
[09:31:11.075]                       invisible(muffled)
[09:31:11.075]                     }
[09:31:11.075]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.075]                   }
[09:31:11.075]                 }
[09:31:11.075]                 else {
[09:31:11.075]                   if (TRUE) {
[09:31:11.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.075]                     {
[09:31:11.075]                       inherits <- base::inherits
[09:31:11.075]                       invokeRestart <- base::invokeRestart
[09:31:11.075]                       is.null <- base::is.null
[09:31:11.075]                       muffled <- FALSE
[09:31:11.075]                       if (inherits(cond, "message")) {
[09:31:11.075]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.075]                         if (muffled) 
[09:31:11.075]                           invokeRestart("muffleMessage")
[09:31:11.075]                       }
[09:31:11.075]                       else if (inherits(cond, "warning")) {
[09:31:11.075]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.075]                         if (muffled) 
[09:31:11.075]                           invokeRestart("muffleWarning")
[09:31:11.075]                       }
[09:31:11.075]                       else if (inherits(cond, "condition")) {
[09:31:11.075]                         if (!is.null(pattern)) {
[09:31:11.075]                           computeRestarts <- base::computeRestarts
[09:31:11.075]                           grepl <- base::grepl
[09:31:11.075]                           restarts <- computeRestarts(cond)
[09:31:11.075]                           for (restart in restarts) {
[09:31:11.075]                             name <- restart$name
[09:31:11.075]                             if (is.null(name)) 
[09:31:11.075]                               next
[09:31:11.075]                             if (!grepl(pattern, name)) 
[09:31:11.075]                               next
[09:31:11.075]                             invokeRestart(restart)
[09:31:11.075]                             muffled <- TRUE
[09:31:11.075]                             break
[09:31:11.075]                           }
[09:31:11.075]                         }
[09:31:11.075]                       }
[09:31:11.075]                       invisible(muffled)
[09:31:11.075]                     }
[09:31:11.075]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.075]                   }
[09:31:11.075]                 }
[09:31:11.075]             }
[09:31:11.075]         }))
[09:31:11.075]     }, error = function(ex) {
[09:31:11.075]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.075]                 ...future.rng), started = ...future.startTime, 
[09:31:11.075]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.075]             version = "1.8"), class = "FutureResult")
[09:31:11.075]     }, finally = {
[09:31:11.075]         if (!identical(...future.workdir, getwd())) 
[09:31:11.075]             setwd(...future.workdir)
[09:31:11.075]         {
[09:31:11.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.075]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.075]             }
[09:31:11.075]             base::options(...future.oldOptions)
[09:31:11.075]             if (.Platform$OS.type == "windows") {
[09:31:11.075]                 old_names <- names(...future.oldEnvVars)
[09:31:11.075]                 envs <- base::Sys.getenv()
[09:31:11.075]                 names <- names(envs)
[09:31:11.075]                 common <- intersect(names, old_names)
[09:31:11.075]                 added <- setdiff(names, old_names)
[09:31:11.075]                 removed <- setdiff(old_names, names)
[09:31:11.075]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.075]                   envs[common]]
[09:31:11.075]                 NAMES <- toupper(changed)
[09:31:11.075]                 args <- list()
[09:31:11.075]                 for (kk in seq_along(NAMES)) {
[09:31:11.075]                   name <- changed[[kk]]
[09:31:11.075]                   NAME <- NAMES[[kk]]
[09:31:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.075]                     next
[09:31:11.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.075]                 }
[09:31:11.075]                 NAMES <- toupper(added)
[09:31:11.075]                 for (kk in seq_along(NAMES)) {
[09:31:11.075]                   name <- added[[kk]]
[09:31:11.075]                   NAME <- NAMES[[kk]]
[09:31:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.075]                     next
[09:31:11.075]                   args[[name]] <- ""
[09:31:11.075]                 }
[09:31:11.075]                 NAMES <- toupper(removed)
[09:31:11.075]                 for (kk in seq_along(NAMES)) {
[09:31:11.075]                   name <- removed[[kk]]
[09:31:11.075]                   NAME <- NAMES[[kk]]
[09:31:11.075]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.075]                     next
[09:31:11.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.075]                 }
[09:31:11.075]                 if (length(args) > 0) 
[09:31:11.075]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.075]             }
[09:31:11.075]             else {
[09:31:11.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.075]             }
[09:31:11.075]             {
[09:31:11.075]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.075]                   0L) {
[09:31:11.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.075]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.075]                   base::options(opts)
[09:31:11.075]                 }
[09:31:11.075]                 {
[09:31:11.075]                   {
[09:31:11.075]                     NULL
[09:31:11.075]                     RNGkind("Mersenne-Twister")
[09:31:11.075]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.075]                       inherits = FALSE)
[09:31:11.075]                   }
[09:31:11.075]                   options(future.plan = NULL)
[09:31:11.075]                   if (is.na(NA_character_)) 
[09:31:11.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.075]                     .init = FALSE)
[09:31:11.075]                 }
[09:31:11.075]             }
[09:31:11.075]         }
[09:31:11.075]     })
[09:31:11.075]     if (TRUE) {
[09:31:11.075]         base::sink(type = "output", split = FALSE)
[09:31:11.075]         if (TRUE) {
[09:31:11.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.075]         }
[09:31:11.075]         else {
[09:31:11.075]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.075]         }
[09:31:11.075]         base::close(...future.stdout)
[09:31:11.075]         ...future.stdout <- NULL
[09:31:11.075]     }
[09:31:11.075]     ...future.result$conditions <- ...future.conditions
[09:31:11.075]     ...future.result$finished <- base::Sys.time()
[09:31:11.075]     ...future.result
[09:31:11.075] }
[09:31:11.077] plan(): Setting new future strategy stack:
[09:31:11.077] List of future strategies:
[09:31:11.077] 1. sequential:
[09:31:11.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.077]    - tweaked: FALSE
[09:31:11.077]    - call: NULL
[09:31:11.078] plan(): nbrOfWorkers() = 1
[09:31:11.079] plan(): Setting new future strategy stack:
[09:31:11.079] List of future strategies:
[09:31:11.079] 1. sequential:
[09:31:11.079]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.079]    - tweaked: FALSE
[09:31:11.079]    - call: future::plan("sequential")
[09:31:11.079] plan(): nbrOfWorkers() = 1
[09:31:11.079] SequentialFuture started (and completed)
[09:31:11.080] - Launch lazy future ... done
[09:31:11.080] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'list') ...
[[1]]
SequentialFuture:
Label: ‘<none>’
Expression:
{
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’

*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'remove') ...
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'list') ...
list()
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'add') ...
[09:31:11.084] getGlobalsAndPackages() ...
[09:31:11.084] Searching for globals...
[09:31:11.084] - globals found: [1] ‘{’
[09:31:11.084] Searching for globals ... DONE
[09:31:11.084] Resolving globals: FALSE
[09:31:11.085] 
[09:31:11.085] 
[09:31:11.085] getGlobalsAndPackages() ... DONE
[09:31:11.085] run() for ‘Future’ ...
[09:31:11.085] - state: ‘created’
[09:31:11.085] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.086] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.086] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.086]   - Field: ‘label’
[09:31:11.086]   - Field: ‘local’
[09:31:11.086]   - Field: ‘owner’
[09:31:11.086]   - Field: ‘envir’
[09:31:11.086]   - Field: ‘packages’
[09:31:11.086]   - Field: ‘gc’
[09:31:11.086]   - Field: ‘conditions’
[09:31:11.086]   - Field: ‘expr’
[09:31:11.086]   - Field: ‘uuid’
[09:31:11.086]   - Field: ‘seed’
[09:31:11.087]   - Field: ‘version’
[09:31:11.087]   - Field: ‘result’
[09:31:11.087]   - Field: ‘asynchronous’
[09:31:11.087]   - Field: ‘calls’
[09:31:11.087]   - Field: ‘globals’
[09:31:11.087]   - Field: ‘stdout’
[09:31:11.087]   - Field: ‘earlySignal’
[09:31:11.087]   - Field: ‘lazy’
[09:31:11.087]   - Field: ‘state’
[09:31:11.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.087] - Launch lazy future ...
[09:31:11.088] Packages needed by the future expression (n = 0): <none>
[09:31:11.088] Packages needed by future strategies (n = 0): <none>
[09:31:11.088] {
[09:31:11.088]     {
[09:31:11.088]         {
[09:31:11.088]             ...future.startTime <- base::Sys.time()
[09:31:11.088]             {
[09:31:11.088]                 {
[09:31:11.088]                   {
[09:31:11.088]                     base::local({
[09:31:11.088]                       has_future <- base::requireNamespace("future", 
[09:31:11.088]                         quietly = TRUE)
[09:31:11.088]                       if (has_future) {
[09:31:11.088]                         ns <- base::getNamespace("future")
[09:31:11.088]                         version <- ns[[".package"]][["version"]]
[09:31:11.088]                         if (is.null(version)) 
[09:31:11.088]                           version <- utils::packageVersion("future")
[09:31:11.088]                       }
[09:31:11.088]                       else {
[09:31:11.088]                         version <- NULL
[09:31:11.088]                       }
[09:31:11.088]                       if (!has_future || version < "1.8.0") {
[09:31:11.088]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.088]                           "", base::R.version$version.string), 
[09:31:11.088]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.088]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.088]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.088]                             "release", "version")], collapse = " "), 
[09:31:11.088]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.088]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.088]                           info)
[09:31:11.088]                         info <- base::paste(info, collapse = "; ")
[09:31:11.088]                         if (!has_future) {
[09:31:11.088]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.088]                             info)
[09:31:11.088]                         }
[09:31:11.088]                         else {
[09:31:11.088]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.088]                             info, version)
[09:31:11.088]                         }
[09:31:11.088]                         base::stop(msg)
[09:31:11.088]                       }
[09:31:11.088]                     })
[09:31:11.088]                   }
[09:31:11.088]                   ...future.strategy.old <- future::plan("list")
[09:31:11.088]                   options(future.plan = NULL)
[09:31:11.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.088]                 }
[09:31:11.088]                 ...future.workdir <- getwd()
[09:31:11.088]             }
[09:31:11.088]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.088]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.088]         }
[09:31:11.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.088]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.088]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.088]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.088]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.088]             base::names(...future.oldOptions))
[09:31:11.088]     }
[09:31:11.088]     if (FALSE) {
[09:31:11.088]     }
[09:31:11.088]     else {
[09:31:11.088]         if (TRUE) {
[09:31:11.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.088]                 open = "w")
[09:31:11.088]         }
[09:31:11.088]         else {
[09:31:11.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.088]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.088]         }
[09:31:11.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.088]             base::sink(type = "output", split = FALSE)
[09:31:11.088]             base::close(...future.stdout)
[09:31:11.088]         }, add = TRUE)
[09:31:11.088]     }
[09:31:11.088]     ...future.frame <- base::sys.nframe()
[09:31:11.088]     ...future.conditions <- base::list()
[09:31:11.088]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.088]     if (FALSE) {
[09:31:11.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.088]     }
[09:31:11.088]     ...future.result <- base::tryCatch({
[09:31:11.088]         base::withCallingHandlers({
[09:31:11.088]             ...future.value <- base::withVisible(base::local({
[09:31:11.088]                 2
[09:31:11.088]             }))
[09:31:11.088]             future::FutureResult(value = ...future.value$value, 
[09:31:11.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.088]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.088]                     ...future.globalenv.names))
[09:31:11.088]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.088]         }, condition = base::local({
[09:31:11.088]             c <- base::c
[09:31:11.088]             inherits <- base::inherits
[09:31:11.088]             invokeRestart <- base::invokeRestart
[09:31:11.088]             length <- base::length
[09:31:11.088]             list <- base::list
[09:31:11.088]             seq.int <- base::seq.int
[09:31:11.088]             signalCondition <- base::signalCondition
[09:31:11.088]             sys.calls <- base::sys.calls
[09:31:11.088]             `[[` <- base::`[[`
[09:31:11.088]             `+` <- base::`+`
[09:31:11.088]             `<<-` <- base::`<<-`
[09:31:11.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.088]                   3L)]
[09:31:11.088]             }
[09:31:11.088]             function(cond) {
[09:31:11.088]                 is_error <- inherits(cond, "error")
[09:31:11.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.088]                   NULL)
[09:31:11.088]                 if (is_error) {
[09:31:11.088]                   sessionInformation <- function() {
[09:31:11.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.088]                       search = base::search(), system = base::Sys.info())
[09:31:11.088]                   }
[09:31:11.088]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.088]                     cond$call), session = sessionInformation(), 
[09:31:11.088]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.088]                   signalCondition(cond)
[09:31:11.088]                 }
[09:31:11.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.088]                 "immediateCondition"))) {
[09:31:11.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.088]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.088]                   if (TRUE && !signal) {
[09:31:11.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.088]                     {
[09:31:11.088]                       inherits <- base::inherits
[09:31:11.088]                       invokeRestart <- base::invokeRestart
[09:31:11.088]                       is.null <- base::is.null
[09:31:11.088]                       muffled <- FALSE
[09:31:11.088]                       if (inherits(cond, "message")) {
[09:31:11.088]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.088]                         if (muffled) 
[09:31:11.088]                           invokeRestart("muffleMessage")
[09:31:11.088]                       }
[09:31:11.088]                       else if (inherits(cond, "warning")) {
[09:31:11.088]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.088]                         if (muffled) 
[09:31:11.088]                           invokeRestart("muffleWarning")
[09:31:11.088]                       }
[09:31:11.088]                       else if (inherits(cond, "condition")) {
[09:31:11.088]                         if (!is.null(pattern)) {
[09:31:11.088]                           computeRestarts <- base::computeRestarts
[09:31:11.088]                           grepl <- base::grepl
[09:31:11.088]                           restarts <- computeRestarts(cond)
[09:31:11.088]                           for (restart in restarts) {
[09:31:11.088]                             name <- restart$name
[09:31:11.088]                             if (is.null(name)) 
[09:31:11.088]                               next
[09:31:11.088]                             if (!grepl(pattern, name)) 
[09:31:11.088]                               next
[09:31:11.088]                             invokeRestart(restart)
[09:31:11.088]                             muffled <- TRUE
[09:31:11.088]                             break
[09:31:11.088]                           }
[09:31:11.088]                         }
[09:31:11.088]                       }
[09:31:11.088]                       invisible(muffled)
[09:31:11.088]                     }
[09:31:11.088]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.088]                   }
[09:31:11.088]                 }
[09:31:11.088]                 else {
[09:31:11.088]                   if (TRUE) {
[09:31:11.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.088]                     {
[09:31:11.088]                       inherits <- base::inherits
[09:31:11.088]                       invokeRestart <- base::invokeRestart
[09:31:11.088]                       is.null <- base::is.null
[09:31:11.088]                       muffled <- FALSE
[09:31:11.088]                       if (inherits(cond, "message")) {
[09:31:11.088]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.088]                         if (muffled) 
[09:31:11.088]                           invokeRestart("muffleMessage")
[09:31:11.088]                       }
[09:31:11.088]                       else if (inherits(cond, "warning")) {
[09:31:11.088]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.088]                         if (muffled) 
[09:31:11.088]                           invokeRestart("muffleWarning")
[09:31:11.088]                       }
[09:31:11.088]                       else if (inherits(cond, "condition")) {
[09:31:11.088]                         if (!is.null(pattern)) {
[09:31:11.088]                           computeRestarts <- base::computeRestarts
[09:31:11.088]                           grepl <- base::grepl
[09:31:11.088]                           restarts <- computeRestarts(cond)
[09:31:11.088]                           for (restart in restarts) {
[09:31:11.088]                             name <- restart$name
[09:31:11.088]                             if (is.null(name)) 
[09:31:11.088]                               next
[09:31:11.088]                             if (!grepl(pattern, name)) 
[09:31:11.088]                               next
[09:31:11.088]                             invokeRestart(restart)
[09:31:11.088]                             muffled <- TRUE
[09:31:11.088]                             break
[09:31:11.088]                           }
[09:31:11.088]                         }
[09:31:11.088]                       }
[09:31:11.088]                       invisible(muffled)
[09:31:11.088]                     }
[09:31:11.088]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.088]                   }
[09:31:11.088]                 }
[09:31:11.088]             }
[09:31:11.088]         }))
[09:31:11.088]     }, error = function(ex) {
[09:31:11.088]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.088]                 ...future.rng), started = ...future.startTime, 
[09:31:11.088]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.088]             version = "1.8"), class = "FutureResult")
[09:31:11.088]     }, finally = {
[09:31:11.088]         if (!identical(...future.workdir, getwd())) 
[09:31:11.088]             setwd(...future.workdir)
[09:31:11.088]         {
[09:31:11.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.088]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.088]             }
[09:31:11.088]             base::options(...future.oldOptions)
[09:31:11.088]             if (.Platform$OS.type == "windows") {
[09:31:11.088]                 old_names <- names(...future.oldEnvVars)
[09:31:11.088]                 envs <- base::Sys.getenv()
[09:31:11.088]                 names <- names(envs)
[09:31:11.088]                 common <- intersect(names, old_names)
[09:31:11.088]                 added <- setdiff(names, old_names)
[09:31:11.088]                 removed <- setdiff(old_names, names)
[09:31:11.088]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.088]                   envs[common]]
[09:31:11.088]                 NAMES <- toupper(changed)
[09:31:11.088]                 args <- list()
[09:31:11.088]                 for (kk in seq_along(NAMES)) {
[09:31:11.088]                   name <- changed[[kk]]
[09:31:11.088]                   NAME <- NAMES[[kk]]
[09:31:11.088]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.088]                     next
[09:31:11.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.088]                 }
[09:31:11.088]                 NAMES <- toupper(added)
[09:31:11.088]                 for (kk in seq_along(NAMES)) {
[09:31:11.088]                   name <- added[[kk]]
[09:31:11.088]                   NAME <- NAMES[[kk]]
[09:31:11.088]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.088]                     next
[09:31:11.088]                   args[[name]] <- ""
[09:31:11.088]                 }
[09:31:11.088]                 NAMES <- toupper(removed)
[09:31:11.088]                 for (kk in seq_along(NAMES)) {
[09:31:11.088]                   name <- removed[[kk]]
[09:31:11.088]                   NAME <- NAMES[[kk]]
[09:31:11.088]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.088]                     next
[09:31:11.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.088]                 }
[09:31:11.088]                 if (length(args) > 0) 
[09:31:11.088]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.088]             }
[09:31:11.088]             else {
[09:31:11.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.088]             }
[09:31:11.088]             {
[09:31:11.088]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.088]                   0L) {
[09:31:11.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.088]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.088]                   base::options(opts)
[09:31:11.088]                 }
[09:31:11.088]                 {
[09:31:11.088]                   {
[09:31:11.088]                     NULL
[09:31:11.088]                     RNGkind("Mersenne-Twister")
[09:31:11.088]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.088]                       inherits = FALSE)
[09:31:11.088]                   }
[09:31:11.088]                   options(future.plan = NULL)
[09:31:11.088]                   if (is.na(NA_character_)) 
[09:31:11.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.088]                     .init = FALSE)
[09:31:11.088]                 }
[09:31:11.088]             }
[09:31:11.088]         }
[09:31:11.088]     })
[09:31:11.088]     if (TRUE) {
[09:31:11.088]         base::sink(type = "output", split = FALSE)
[09:31:11.088]         if (TRUE) {
[09:31:11.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.088]         }
[09:31:11.088]         else {
[09:31:11.088]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.088]         }
[09:31:11.088]         base::close(...future.stdout)
[09:31:11.088]         ...future.stdout <- NULL
[09:31:11.088]     }
[09:31:11.088]     ...future.result$conditions <- ...future.conditions
[09:31:11.088]     ...future.result$finished <- base::Sys.time()
[09:31:11.088]     ...future.result
[09:31:11.088] }
[09:31:11.090] plan(): Setting new future strategy stack:
[09:31:11.090] List of future strategies:
[09:31:11.090] 1. sequential:
[09:31:11.090]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.090]    - tweaked: FALSE
[09:31:11.090]    - call: NULL
[09:31:11.090] plan(): nbrOfWorkers() = 1
[09:31:11.091] plan(): Setting new future strategy stack:
[09:31:11.091] List of future strategies:
[09:31:11.091] 1. sequential:
[09:31:11.091]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.091]    - tweaked: FALSE
[09:31:11.091]    - call: future::plan("sequential")
[09:31:11.091] plan(): nbrOfWorkers() = 1
[09:31:11.092] SequentialFuture started (and completed)
[09:31:11.092] - Launch lazy future ... done
[09:31:11.092] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'list') ...
[[1]]
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’

*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'collect-first') ...
[09:31:11.093] resolved() for ‘SequentialFuture’ ...
[09:31:11.093] - state: ‘finished’
[09:31:11.093] - run: FALSE
[09:31:11.093] - result: ‘FutureResult’
[09:31:11.093] resolved() for ‘SequentialFuture’ ... done
list()
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'add') ...
[09:31:11.094] getGlobalsAndPackages() ...
[09:31:11.094] Searching for globals...
[09:31:11.094] - globals found: [1] ‘{’
[09:31:11.094] Searching for globals ... DONE
[09:31:11.095] Resolving globals: FALSE
[09:31:11.095] 
[09:31:11.095] 
[09:31:11.095] getGlobalsAndPackages() ... DONE
[09:31:11.095] run() for ‘Future’ ...
[09:31:11.095] - state: ‘created’
[09:31:11.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.096] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.096] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.096]   - Field: ‘label’
[09:31:11.096]   - Field: ‘local’
[09:31:11.096]   - Field: ‘owner’
[09:31:11.096]   - Field: ‘envir’
[09:31:11.096]   - Field: ‘packages’
[09:31:11.096]   - Field: ‘gc’
[09:31:11.096]   - Field: ‘conditions’
[09:31:11.096]   - Field: ‘expr’
[09:31:11.097]   - Field: ‘uuid’
[09:31:11.097]   - Field: ‘seed’
[09:31:11.097]   - Field: ‘version’
[09:31:11.097]   - Field: ‘result’
[09:31:11.097]   - Field: ‘asynchronous’
[09:31:11.097]   - Field: ‘calls’
[09:31:11.097]   - Field: ‘globals’
[09:31:11.097]   - Field: ‘stdout’
[09:31:11.097]   - Field: ‘earlySignal’
[09:31:11.097]   - Field: ‘lazy’
[09:31:11.097]   - Field: ‘state’
[09:31:11.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.098] - Launch lazy future ...
[09:31:11.098] Packages needed by the future expression (n = 0): <none>
[09:31:11.098] Packages needed by future strategies (n = 0): <none>
[09:31:11.098] {
[09:31:11.098]     {
[09:31:11.098]         {
[09:31:11.098]             ...future.startTime <- base::Sys.time()
[09:31:11.098]             {
[09:31:11.098]                 {
[09:31:11.098]                   {
[09:31:11.098]                     base::local({
[09:31:11.098]                       has_future <- base::requireNamespace("future", 
[09:31:11.098]                         quietly = TRUE)
[09:31:11.098]                       if (has_future) {
[09:31:11.098]                         ns <- base::getNamespace("future")
[09:31:11.098]                         version <- ns[[".package"]][["version"]]
[09:31:11.098]                         if (is.null(version)) 
[09:31:11.098]                           version <- utils::packageVersion("future")
[09:31:11.098]                       }
[09:31:11.098]                       else {
[09:31:11.098]                         version <- NULL
[09:31:11.098]                       }
[09:31:11.098]                       if (!has_future || version < "1.8.0") {
[09:31:11.098]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.098]                           "", base::R.version$version.string), 
[09:31:11.098]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.098]                             "release", "version")], collapse = " "), 
[09:31:11.098]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.098]                           info)
[09:31:11.098]                         info <- base::paste(info, collapse = "; ")
[09:31:11.098]                         if (!has_future) {
[09:31:11.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.098]                             info)
[09:31:11.098]                         }
[09:31:11.098]                         else {
[09:31:11.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.098]                             info, version)
[09:31:11.098]                         }
[09:31:11.098]                         base::stop(msg)
[09:31:11.098]                       }
[09:31:11.098]                     })
[09:31:11.098]                   }
[09:31:11.098]                   ...future.strategy.old <- future::plan("list")
[09:31:11.098]                   options(future.plan = NULL)
[09:31:11.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.098]                 }
[09:31:11.098]                 ...future.workdir <- getwd()
[09:31:11.098]             }
[09:31:11.098]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.098]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.098]         }
[09:31:11.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.098]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.098]             base::names(...future.oldOptions))
[09:31:11.098]     }
[09:31:11.098]     if (FALSE) {
[09:31:11.098]     }
[09:31:11.098]     else {
[09:31:11.098]         if (TRUE) {
[09:31:11.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.098]                 open = "w")
[09:31:11.098]         }
[09:31:11.098]         else {
[09:31:11.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.098]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.098]         }
[09:31:11.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.098]             base::sink(type = "output", split = FALSE)
[09:31:11.098]             base::close(...future.stdout)
[09:31:11.098]         }, add = TRUE)
[09:31:11.098]     }
[09:31:11.098]     ...future.frame <- base::sys.nframe()
[09:31:11.098]     ...future.conditions <- base::list()
[09:31:11.098]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.098]     if (FALSE) {
[09:31:11.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.098]     }
[09:31:11.098]     ...future.result <- base::tryCatch({
[09:31:11.098]         base::withCallingHandlers({
[09:31:11.098]             ...future.value <- base::withVisible(base::local({
[09:31:11.098]                 2
[09:31:11.098]             }))
[09:31:11.098]             future::FutureResult(value = ...future.value$value, 
[09:31:11.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.098]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.098]                     ...future.globalenv.names))
[09:31:11.098]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.098]         }, condition = base::local({
[09:31:11.098]             c <- base::c
[09:31:11.098]             inherits <- base::inherits
[09:31:11.098]             invokeRestart <- base::invokeRestart
[09:31:11.098]             length <- base::length
[09:31:11.098]             list <- base::list
[09:31:11.098]             seq.int <- base::seq.int
[09:31:11.098]             signalCondition <- base::signalCondition
[09:31:11.098]             sys.calls <- base::sys.calls
[09:31:11.098]             `[[` <- base::`[[`
[09:31:11.098]             `+` <- base::`+`
[09:31:11.098]             `<<-` <- base::`<<-`
[09:31:11.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.098]                   3L)]
[09:31:11.098]             }
[09:31:11.098]             function(cond) {
[09:31:11.098]                 is_error <- inherits(cond, "error")
[09:31:11.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.098]                   NULL)
[09:31:11.098]                 if (is_error) {
[09:31:11.098]                   sessionInformation <- function() {
[09:31:11.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.098]                       search = base::search(), system = base::Sys.info())
[09:31:11.098]                   }
[09:31:11.098]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.098]                     cond$call), session = sessionInformation(), 
[09:31:11.098]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.098]                   signalCondition(cond)
[09:31:11.098]                 }
[09:31:11.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.098]                 "immediateCondition"))) {
[09:31:11.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.098]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.098]                   if (TRUE && !signal) {
[09:31:11.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.098]                     {
[09:31:11.098]                       inherits <- base::inherits
[09:31:11.098]                       invokeRestart <- base::invokeRestart
[09:31:11.098]                       is.null <- base::is.null
[09:31:11.098]                       muffled <- FALSE
[09:31:11.098]                       if (inherits(cond, "message")) {
[09:31:11.098]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.098]                         if (muffled) 
[09:31:11.098]                           invokeRestart("muffleMessage")
[09:31:11.098]                       }
[09:31:11.098]                       else if (inherits(cond, "warning")) {
[09:31:11.098]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.098]                         if (muffled) 
[09:31:11.098]                           invokeRestart("muffleWarning")
[09:31:11.098]                       }
[09:31:11.098]                       else if (inherits(cond, "condition")) {
[09:31:11.098]                         if (!is.null(pattern)) {
[09:31:11.098]                           computeRestarts <- base::computeRestarts
[09:31:11.098]                           grepl <- base::grepl
[09:31:11.098]                           restarts <- computeRestarts(cond)
[09:31:11.098]                           for (restart in restarts) {
[09:31:11.098]                             name <- restart$name
[09:31:11.098]                             if (is.null(name)) 
[09:31:11.098]                               next
[09:31:11.098]                             if (!grepl(pattern, name)) 
[09:31:11.098]                               next
[09:31:11.098]                             invokeRestart(restart)
[09:31:11.098]                             muffled <- TRUE
[09:31:11.098]                             break
[09:31:11.098]                           }
[09:31:11.098]                         }
[09:31:11.098]                       }
[09:31:11.098]                       invisible(muffled)
[09:31:11.098]                     }
[09:31:11.098]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.098]                   }
[09:31:11.098]                 }
[09:31:11.098]                 else {
[09:31:11.098]                   if (TRUE) {
[09:31:11.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.098]                     {
[09:31:11.098]                       inherits <- base::inherits
[09:31:11.098]                       invokeRestart <- base::invokeRestart
[09:31:11.098]                       is.null <- base::is.null
[09:31:11.098]                       muffled <- FALSE
[09:31:11.098]                       if (inherits(cond, "message")) {
[09:31:11.098]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.098]                         if (muffled) 
[09:31:11.098]                           invokeRestart("muffleMessage")
[09:31:11.098]                       }
[09:31:11.098]                       else if (inherits(cond, "warning")) {
[09:31:11.098]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.098]                         if (muffled) 
[09:31:11.098]                           invokeRestart("muffleWarning")
[09:31:11.098]                       }
[09:31:11.098]                       else if (inherits(cond, "condition")) {
[09:31:11.098]                         if (!is.null(pattern)) {
[09:31:11.098]                           computeRestarts <- base::computeRestarts
[09:31:11.098]                           grepl <- base::grepl
[09:31:11.098]                           restarts <- computeRestarts(cond)
[09:31:11.098]                           for (restart in restarts) {
[09:31:11.098]                             name <- restart$name
[09:31:11.098]                             if (is.null(name)) 
[09:31:11.098]                               next
[09:31:11.098]                             if (!grepl(pattern, name)) 
[09:31:11.098]                               next
[09:31:11.098]                             invokeRestart(restart)
[09:31:11.098]                             muffled <- TRUE
[09:31:11.098]                             break
[09:31:11.098]                           }
[09:31:11.098]                         }
[09:31:11.098]                       }
[09:31:11.098]                       invisible(muffled)
[09:31:11.098]                     }
[09:31:11.098]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.098]                   }
[09:31:11.098]                 }
[09:31:11.098]             }
[09:31:11.098]         }))
[09:31:11.098]     }, error = function(ex) {
[09:31:11.098]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.098]                 ...future.rng), started = ...future.startTime, 
[09:31:11.098]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.098]             version = "1.8"), class = "FutureResult")
[09:31:11.098]     }, finally = {
[09:31:11.098]         if (!identical(...future.workdir, getwd())) 
[09:31:11.098]             setwd(...future.workdir)
[09:31:11.098]         {
[09:31:11.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.098]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.098]             }
[09:31:11.098]             base::options(...future.oldOptions)
[09:31:11.098]             if (.Platform$OS.type == "windows") {
[09:31:11.098]                 old_names <- names(...future.oldEnvVars)
[09:31:11.098]                 envs <- base::Sys.getenv()
[09:31:11.098]                 names <- names(envs)
[09:31:11.098]                 common <- intersect(names, old_names)
[09:31:11.098]                 added <- setdiff(names, old_names)
[09:31:11.098]                 removed <- setdiff(old_names, names)
[09:31:11.098]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.098]                   envs[common]]
[09:31:11.098]                 NAMES <- toupper(changed)
[09:31:11.098]                 args <- list()
[09:31:11.098]                 for (kk in seq_along(NAMES)) {
[09:31:11.098]                   name <- changed[[kk]]
[09:31:11.098]                   NAME <- NAMES[[kk]]
[09:31:11.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.098]                     next
[09:31:11.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.098]                 }
[09:31:11.098]                 NAMES <- toupper(added)
[09:31:11.098]                 for (kk in seq_along(NAMES)) {
[09:31:11.098]                   name <- added[[kk]]
[09:31:11.098]                   NAME <- NAMES[[kk]]
[09:31:11.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.098]                     next
[09:31:11.098]                   args[[name]] <- ""
[09:31:11.098]                 }
[09:31:11.098]                 NAMES <- toupper(removed)
[09:31:11.098]                 for (kk in seq_along(NAMES)) {
[09:31:11.098]                   name <- removed[[kk]]
[09:31:11.098]                   NAME <- NAMES[[kk]]
[09:31:11.098]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.098]                     next
[09:31:11.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.098]                 }
[09:31:11.098]                 if (length(args) > 0) 
[09:31:11.098]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.098]             }
[09:31:11.098]             else {
[09:31:11.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.098]             }
[09:31:11.098]             {
[09:31:11.098]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.098]                   0L) {
[09:31:11.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.098]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.098]                   base::options(opts)
[09:31:11.098]                 }
[09:31:11.098]                 {
[09:31:11.098]                   {
[09:31:11.098]                     NULL
[09:31:11.098]                     RNGkind("Mersenne-Twister")
[09:31:11.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.098]                       inherits = FALSE)
[09:31:11.098]                   }
[09:31:11.098]                   options(future.plan = NULL)
[09:31:11.098]                   if (is.na(NA_character_)) 
[09:31:11.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.098]                     .init = FALSE)
[09:31:11.098]                 }
[09:31:11.098]             }
[09:31:11.098]         }
[09:31:11.098]     })
[09:31:11.098]     if (TRUE) {
[09:31:11.098]         base::sink(type = "output", split = FALSE)
[09:31:11.098]         if (TRUE) {
[09:31:11.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.098]         }
[09:31:11.098]         else {
[09:31:11.098]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.098]         }
[09:31:11.098]         base::close(...future.stdout)
[09:31:11.098]         ...future.stdout <- NULL
[09:31:11.098]     }
[09:31:11.098]     ...future.result$conditions <- ...future.conditions
[09:31:11.098]     ...future.result$finished <- base::Sys.time()
[09:31:11.098]     ...future.result
[09:31:11.098] }
[09:31:11.100] plan(): Setting new future strategy stack:
[09:31:11.100] List of future strategies:
[09:31:11.100] 1. sequential:
[09:31:11.100]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.100]    - tweaked: FALSE
[09:31:11.100]    - call: NULL
[09:31:11.100] plan(): nbrOfWorkers() = 1
[09:31:11.101] plan(): Setting new future strategy stack:
[09:31:11.101] List of future strategies:
[09:31:11.101] 1. sequential:
[09:31:11.101]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.101]    - tweaked: FALSE
[09:31:11.101]    - call: future::plan("sequential")
[09:31:11.102] plan(): nbrOfWorkers() = 1
[09:31:11.102] SequentialFuture started (and completed)
[09:31:11.102] - Launch lazy future ... done
[09:31:11.102] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'reset') ...
*** FutureRegistry('multicore-25dfa052-6d78-16c0-16b8-994b6e71bac9', 'list') ...
list()
*** FutureRegistry('rscript', 'list') ...
list()
*** FutureRegistry('rscript', 'add') ...
[09:31:11.103] getGlobalsAndPackages() ...
[09:31:11.103] Searching for globals...
[09:31:11.103] - globals found: [1] ‘{’
[09:31:11.103] Searching for globals ... DONE
[09:31:11.104] Resolving globals: FALSE
[09:31:11.104] 
[09:31:11.104] 
[09:31:11.104] getGlobalsAndPackages() ... DONE
[09:31:11.104] run() for ‘Future’ ...
[09:31:11.104] - state: ‘created’
[09:31:11.104] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.106]   - Field: ‘label’
[09:31:11.106]   - Field: ‘local’
[09:31:11.106]   - Field: ‘owner’
[09:31:11.106]   - Field: ‘envir’
[09:31:11.107]   - Field: ‘packages’
[09:31:11.107]   - Field: ‘gc’
[09:31:11.107]   - Field: ‘conditions’
[09:31:11.107]   - Field: ‘expr’
[09:31:11.107]   - Field: ‘uuid’
[09:31:11.107]   - Field: ‘seed’
[09:31:11.107]   - Field: ‘version’
[09:31:11.107]   - Field: ‘result’
[09:31:11.107]   - Field: ‘asynchronous’
[09:31:11.107]   - Field: ‘calls’
[09:31:11.107]   - Field: ‘globals’
[09:31:11.108]   - Field: ‘stdout’
[09:31:11.108]   - Field: ‘earlySignal’
[09:31:11.108]   - Field: ‘lazy’
[09:31:11.108]   - Field: ‘state’
[09:31:11.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.108] - Launch lazy future ...
[09:31:11.108] Packages needed by the future expression (n = 0): <none>
[09:31:11.108] Packages needed by future strategies (n = 0): <none>
[09:31:11.109] {
[09:31:11.109]     {
[09:31:11.109]         {
[09:31:11.109]             ...future.startTime <- base::Sys.time()
[09:31:11.109]             {
[09:31:11.109]                 {
[09:31:11.109]                   {
[09:31:11.109]                     base::local({
[09:31:11.109]                       has_future <- base::requireNamespace("future", 
[09:31:11.109]                         quietly = TRUE)
[09:31:11.109]                       if (has_future) {
[09:31:11.109]                         ns <- base::getNamespace("future")
[09:31:11.109]                         version <- ns[[".package"]][["version"]]
[09:31:11.109]                         if (is.null(version)) 
[09:31:11.109]                           version <- utils::packageVersion("future")
[09:31:11.109]                       }
[09:31:11.109]                       else {
[09:31:11.109]                         version <- NULL
[09:31:11.109]                       }
[09:31:11.109]                       if (!has_future || version < "1.8.0") {
[09:31:11.109]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.109]                           "", base::R.version$version.string), 
[09:31:11.109]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.109]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.109]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.109]                             "release", "version")], collapse = " "), 
[09:31:11.109]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.109]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.109]                           info)
[09:31:11.109]                         info <- base::paste(info, collapse = "; ")
[09:31:11.109]                         if (!has_future) {
[09:31:11.109]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.109]                             info)
[09:31:11.109]                         }
[09:31:11.109]                         else {
[09:31:11.109]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.109]                             info, version)
[09:31:11.109]                         }
[09:31:11.109]                         base::stop(msg)
[09:31:11.109]                       }
[09:31:11.109]                     })
[09:31:11.109]                   }
[09:31:11.109]                   ...future.strategy.old <- future::plan("list")
[09:31:11.109]                   options(future.plan = NULL)
[09:31:11.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.109]                 }
[09:31:11.109]                 ...future.workdir <- getwd()
[09:31:11.109]             }
[09:31:11.109]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.109]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.109]         }
[09:31:11.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.109]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.109]             base::names(...future.oldOptions))
[09:31:11.109]     }
[09:31:11.109]     if (FALSE) {
[09:31:11.109]     }
[09:31:11.109]     else {
[09:31:11.109]         if (TRUE) {
[09:31:11.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.109]                 open = "w")
[09:31:11.109]         }
[09:31:11.109]         else {
[09:31:11.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.109]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.109]         }
[09:31:11.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.109]             base::sink(type = "output", split = FALSE)
[09:31:11.109]             base::close(...future.stdout)
[09:31:11.109]         }, add = TRUE)
[09:31:11.109]     }
[09:31:11.109]     ...future.frame <- base::sys.nframe()
[09:31:11.109]     ...future.conditions <- base::list()
[09:31:11.109]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.109]     if (FALSE) {
[09:31:11.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.109]     }
[09:31:11.109]     ...future.result <- base::tryCatch({
[09:31:11.109]         base::withCallingHandlers({
[09:31:11.109]             ...future.value <- base::withVisible(base::local({
[09:31:11.109]                 1
[09:31:11.109]             }))
[09:31:11.109]             future::FutureResult(value = ...future.value$value, 
[09:31:11.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.109]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.109]                     ...future.globalenv.names))
[09:31:11.109]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.109]         }, condition = base::local({
[09:31:11.109]             c <- base::c
[09:31:11.109]             inherits <- base::inherits
[09:31:11.109]             invokeRestart <- base::invokeRestart
[09:31:11.109]             length <- base::length
[09:31:11.109]             list <- base::list
[09:31:11.109]             seq.int <- base::seq.int
[09:31:11.109]             signalCondition <- base::signalCondition
[09:31:11.109]             sys.calls <- base::sys.calls
[09:31:11.109]             `[[` <- base::`[[`
[09:31:11.109]             `+` <- base::`+`
[09:31:11.109]             `<<-` <- base::`<<-`
[09:31:11.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.109]                   3L)]
[09:31:11.109]             }
[09:31:11.109]             function(cond) {
[09:31:11.109]                 is_error <- inherits(cond, "error")
[09:31:11.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.109]                   NULL)
[09:31:11.109]                 if (is_error) {
[09:31:11.109]                   sessionInformation <- function() {
[09:31:11.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.109]                       search = base::search(), system = base::Sys.info())
[09:31:11.109]                   }
[09:31:11.109]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.109]                     cond$call), session = sessionInformation(), 
[09:31:11.109]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.109]                   signalCondition(cond)
[09:31:11.109]                 }
[09:31:11.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.109]                 "immediateCondition"))) {
[09:31:11.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.109]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.109]                   if (TRUE && !signal) {
[09:31:11.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.109]                     {
[09:31:11.109]                       inherits <- base::inherits
[09:31:11.109]                       invokeRestart <- base::invokeRestart
[09:31:11.109]                       is.null <- base::is.null
[09:31:11.109]                       muffled <- FALSE
[09:31:11.109]                       if (inherits(cond, "message")) {
[09:31:11.109]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.109]                         if (muffled) 
[09:31:11.109]                           invokeRestart("muffleMessage")
[09:31:11.109]                       }
[09:31:11.109]                       else if (inherits(cond, "warning")) {
[09:31:11.109]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.109]                         if (muffled) 
[09:31:11.109]                           invokeRestart("muffleWarning")
[09:31:11.109]                       }
[09:31:11.109]                       else if (inherits(cond, "condition")) {
[09:31:11.109]                         if (!is.null(pattern)) {
[09:31:11.109]                           computeRestarts <- base::computeRestarts
[09:31:11.109]                           grepl <- base::grepl
[09:31:11.109]                           restarts <- computeRestarts(cond)
[09:31:11.109]                           for (restart in restarts) {
[09:31:11.109]                             name <- restart$name
[09:31:11.109]                             if (is.null(name)) 
[09:31:11.109]                               next
[09:31:11.109]                             if (!grepl(pattern, name)) 
[09:31:11.109]                               next
[09:31:11.109]                             invokeRestart(restart)
[09:31:11.109]                             muffled <- TRUE
[09:31:11.109]                             break
[09:31:11.109]                           }
[09:31:11.109]                         }
[09:31:11.109]                       }
[09:31:11.109]                       invisible(muffled)
[09:31:11.109]                     }
[09:31:11.109]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.109]                   }
[09:31:11.109]                 }
[09:31:11.109]                 else {
[09:31:11.109]                   if (TRUE) {
[09:31:11.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.109]                     {
[09:31:11.109]                       inherits <- base::inherits
[09:31:11.109]                       invokeRestart <- base::invokeRestart
[09:31:11.109]                       is.null <- base::is.null
[09:31:11.109]                       muffled <- FALSE
[09:31:11.109]                       if (inherits(cond, "message")) {
[09:31:11.109]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.109]                         if (muffled) 
[09:31:11.109]                           invokeRestart("muffleMessage")
[09:31:11.109]                       }
[09:31:11.109]                       else if (inherits(cond, "warning")) {
[09:31:11.109]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.109]                         if (muffled) 
[09:31:11.109]                           invokeRestart("muffleWarning")
[09:31:11.109]                       }
[09:31:11.109]                       else if (inherits(cond, "condition")) {
[09:31:11.109]                         if (!is.null(pattern)) {
[09:31:11.109]                           computeRestarts <- base::computeRestarts
[09:31:11.109]                           grepl <- base::grepl
[09:31:11.109]                           restarts <- computeRestarts(cond)
[09:31:11.109]                           for (restart in restarts) {
[09:31:11.109]                             name <- restart$name
[09:31:11.109]                             if (is.null(name)) 
[09:31:11.109]                               next
[09:31:11.109]                             if (!grepl(pattern, name)) 
[09:31:11.109]                               next
[09:31:11.109]                             invokeRestart(restart)
[09:31:11.109]                             muffled <- TRUE
[09:31:11.109]                             break
[09:31:11.109]                           }
[09:31:11.109]                         }
[09:31:11.109]                       }
[09:31:11.109]                       invisible(muffled)
[09:31:11.109]                     }
[09:31:11.109]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.109]                   }
[09:31:11.109]                 }
[09:31:11.109]             }
[09:31:11.109]         }))
[09:31:11.109]     }, error = function(ex) {
[09:31:11.109]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.109]                 ...future.rng), started = ...future.startTime, 
[09:31:11.109]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.109]             version = "1.8"), class = "FutureResult")
[09:31:11.109]     }, finally = {
[09:31:11.109]         if (!identical(...future.workdir, getwd())) 
[09:31:11.109]             setwd(...future.workdir)
[09:31:11.109]         {
[09:31:11.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.109]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.109]             }
[09:31:11.109]             base::options(...future.oldOptions)
[09:31:11.109]             if (.Platform$OS.type == "windows") {
[09:31:11.109]                 old_names <- names(...future.oldEnvVars)
[09:31:11.109]                 envs <- base::Sys.getenv()
[09:31:11.109]                 names <- names(envs)
[09:31:11.109]                 common <- intersect(names, old_names)
[09:31:11.109]                 added <- setdiff(names, old_names)
[09:31:11.109]                 removed <- setdiff(old_names, names)
[09:31:11.109]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.109]                   envs[common]]
[09:31:11.109]                 NAMES <- toupper(changed)
[09:31:11.109]                 args <- list()
[09:31:11.109]                 for (kk in seq_along(NAMES)) {
[09:31:11.109]                   name <- changed[[kk]]
[09:31:11.109]                   NAME <- NAMES[[kk]]
[09:31:11.109]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.109]                     next
[09:31:11.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.109]                 }
[09:31:11.109]                 NAMES <- toupper(added)
[09:31:11.109]                 for (kk in seq_along(NAMES)) {
[09:31:11.109]                   name <- added[[kk]]
[09:31:11.109]                   NAME <- NAMES[[kk]]
[09:31:11.109]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.109]                     next
[09:31:11.109]                   args[[name]] <- ""
[09:31:11.109]                 }
[09:31:11.109]                 NAMES <- toupper(removed)
[09:31:11.109]                 for (kk in seq_along(NAMES)) {
[09:31:11.109]                   name <- removed[[kk]]
[09:31:11.109]                   NAME <- NAMES[[kk]]
[09:31:11.109]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.109]                     next
[09:31:11.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.109]                 }
[09:31:11.109]                 if (length(args) > 0) 
[09:31:11.109]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.109]             }
[09:31:11.109]             else {
[09:31:11.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.109]             }
[09:31:11.109]             {
[09:31:11.109]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.109]                   0L) {
[09:31:11.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.109]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.109]                   base::options(opts)
[09:31:11.109]                 }
[09:31:11.109]                 {
[09:31:11.109]                   {
[09:31:11.109]                     NULL
[09:31:11.109]                     RNGkind("Mersenne-Twister")
[09:31:11.109]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.109]                       inherits = FALSE)
[09:31:11.109]                   }
[09:31:11.109]                   options(future.plan = NULL)
[09:31:11.109]                   if (is.na(NA_character_)) 
[09:31:11.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.109]                     .init = FALSE)
[09:31:11.109]                 }
[09:31:11.109]             }
[09:31:11.109]         }
[09:31:11.109]     })
[09:31:11.109]     if (TRUE) {
[09:31:11.109]         base::sink(type = "output", split = FALSE)
[09:31:11.109]         if (TRUE) {
[09:31:11.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.109]         }
[09:31:11.109]         else {
[09:31:11.109]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.109]         }
[09:31:11.109]         base::close(...future.stdout)
[09:31:11.109]         ...future.stdout <- NULL
[09:31:11.109]     }
[09:31:11.109]     ...future.result$conditions <- ...future.conditions
[09:31:11.109]     ...future.result$finished <- base::Sys.time()
[09:31:11.109]     ...future.result
[09:31:11.109] }
[09:31:11.110] plan(): Setting new future strategy stack:
[09:31:11.110] List of future strategies:
[09:31:11.110] 1. sequential:
[09:31:11.110]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.110]    - tweaked: FALSE
[09:31:11.110]    - call: NULL
[09:31:11.111] plan(): nbrOfWorkers() = 1
[09:31:11.111] plan(): Setting new future strategy stack:
[09:31:11.111] List of future strategies:
[09:31:11.111] 1. sequential:
[09:31:11.111]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.111]    - tweaked: FALSE
[09:31:11.111]    - call: future::plan("sequential")
[09:31:11.112] plan(): nbrOfWorkers() = 1
[09:31:11.112] SequentialFuture started (and completed)
[09:31:11.112] - Launch lazy future ... done
[09:31:11.112] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('rscript', 'list') ...
[[1]]
SequentialFuture:
Label: ‘<none>’
Expression:
{
    1
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’

*** FutureRegistry('rscript', 'remove') ...
*** FutureRegistry('rscript', 'list') ...
list()
*** FutureRegistry('rscript', 'add') ...
[09:31:11.113] getGlobalsAndPackages() ...
[09:31:11.114] Searching for globals...
[09:31:11.114] - globals found: [1] ‘{’
[09:31:11.114] Searching for globals ... DONE
[09:31:11.114] Resolving globals: FALSE
[09:31:11.114] 
[09:31:11.115] 
[09:31:11.115] getGlobalsAndPackages() ... DONE
[09:31:11.115] run() for ‘Future’ ...
[09:31:11.115] - state: ‘created’
[09:31:11.115] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.115] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.115]   - Field: ‘label’
[09:31:11.116]   - Field: ‘local’
[09:31:11.116]   - Field: ‘owner’
[09:31:11.116]   - Field: ‘envir’
[09:31:11.116]   - Field: ‘packages’
[09:31:11.116]   - Field: ‘gc’
[09:31:11.116]   - Field: ‘conditions’
[09:31:11.116]   - Field: ‘expr’
[09:31:11.116]   - Field: ‘uuid’
[09:31:11.116]   - Field: ‘seed’
[09:31:11.116]   - Field: ‘version’
[09:31:11.116]   - Field: ‘result’
[09:31:11.116]   - Field: ‘asynchronous’
[09:31:11.117]   - Field: ‘calls’
[09:31:11.117]   - Field: ‘globals’
[09:31:11.117]   - Field: ‘stdout’
[09:31:11.117]   - Field: ‘earlySignal’
[09:31:11.117]   - Field: ‘lazy’
[09:31:11.117]   - Field: ‘state’
[09:31:11.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.117] - Launch lazy future ...
[09:31:11.117] Packages needed by the future expression (n = 0): <none>
[09:31:11.117] Packages needed by future strategies (n = 0): <none>
[09:31:11.118] {
[09:31:11.118]     {
[09:31:11.118]         {
[09:31:11.118]             ...future.startTime <- base::Sys.time()
[09:31:11.118]             {
[09:31:11.118]                 {
[09:31:11.118]                   {
[09:31:11.118]                     base::local({
[09:31:11.118]                       has_future <- base::requireNamespace("future", 
[09:31:11.118]                         quietly = TRUE)
[09:31:11.118]                       if (has_future) {
[09:31:11.118]                         ns <- base::getNamespace("future")
[09:31:11.118]                         version <- ns[[".package"]][["version"]]
[09:31:11.118]                         if (is.null(version)) 
[09:31:11.118]                           version <- utils::packageVersion("future")
[09:31:11.118]                       }
[09:31:11.118]                       else {
[09:31:11.118]                         version <- NULL
[09:31:11.118]                       }
[09:31:11.118]                       if (!has_future || version < "1.8.0") {
[09:31:11.118]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.118]                           "", base::R.version$version.string), 
[09:31:11.118]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.118]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.118]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.118]                             "release", "version")], collapse = " "), 
[09:31:11.118]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.118]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.118]                           info)
[09:31:11.118]                         info <- base::paste(info, collapse = "; ")
[09:31:11.118]                         if (!has_future) {
[09:31:11.118]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.118]                             info)
[09:31:11.118]                         }
[09:31:11.118]                         else {
[09:31:11.118]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.118]                             info, version)
[09:31:11.118]                         }
[09:31:11.118]                         base::stop(msg)
[09:31:11.118]                       }
[09:31:11.118]                     })
[09:31:11.118]                   }
[09:31:11.118]                   ...future.strategy.old <- future::plan("list")
[09:31:11.118]                   options(future.plan = NULL)
[09:31:11.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.118]                 }
[09:31:11.118]                 ...future.workdir <- getwd()
[09:31:11.118]             }
[09:31:11.118]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.118]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.118]         }
[09:31:11.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.118]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.118]             base::names(...future.oldOptions))
[09:31:11.118]     }
[09:31:11.118]     if (FALSE) {
[09:31:11.118]     }
[09:31:11.118]     else {
[09:31:11.118]         if (TRUE) {
[09:31:11.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.118]                 open = "w")
[09:31:11.118]         }
[09:31:11.118]         else {
[09:31:11.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.118]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.118]         }
[09:31:11.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.118]             base::sink(type = "output", split = FALSE)
[09:31:11.118]             base::close(...future.stdout)
[09:31:11.118]         }, add = TRUE)
[09:31:11.118]     }
[09:31:11.118]     ...future.frame <- base::sys.nframe()
[09:31:11.118]     ...future.conditions <- base::list()
[09:31:11.118]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.118]     if (FALSE) {
[09:31:11.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.118]     }
[09:31:11.118]     ...future.result <- base::tryCatch({
[09:31:11.118]         base::withCallingHandlers({
[09:31:11.118]             ...future.value <- base::withVisible(base::local({
[09:31:11.118]                 2
[09:31:11.118]             }))
[09:31:11.118]             future::FutureResult(value = ...future.value$value, 
[09:31:11.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.118]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.118]                     ...future.globalenv.names))
[09:31:11.118]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.118]         }, condition = base::local({
[09:31:11.118]             c <- base::c
[09:31:11.118]             inherits <- base::inherits
[09:31:11.118]             invokeRestart <- base::invokeRestart
[09:31:11.118]             length <- base::length
[09:31:11.118]             list <- base::list
[09:31:11.118]             seq.int <- base::seq.int
[09:31:11.118]             signalCondition <- base::signalCondition
[09:31:11.118]             sys.calls <- base::sys.calls
[09:31:11.118]             `[[` <- base::`[[`
[09:31:11.118]             `+` <- base::`+`
[09:31:11.118]             `<<-` <- base::`<<-`
[09:31:11.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.118]                   3L)]
[09:31:11.118]             }
[09:31:11.118]             function(cond) {
[09:31:11.118]                 is_error <- inherits(cond, "error")
[09:31:11.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.118]                   NULL)
[09:31:11.118]                 if (is_error) {
[09:31:11.118]                   sessionInformation <- function() {
[09:31:11.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.118]                       search = base::search(), system = base::Sys.info())
[09:31:11.118]                   }
[09:31:11.118]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.118]                     cond$call), session = sessionInformation(), 
[09:31:11.118]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.118]                   signalCondition(cond)
[09:31:11.118]                 }
[09:31:11.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.118]                 "immediateCondition"))) {
[09:31:11.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.118]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.118]                   if (TRUE && !signal) {
[09:31:11.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.118]                     {
[09:31:11.118]                       inherits <- base::inherits
[09:31:11.118]                       invokeRestart <- base::invokeRestart
[09:31:11.118]                       is.null <- base::is.null
[09:31:11.118]                       muffled <- FALSE
[09:31:11.118]                       if (inherits(cond, "message")) {
[09:31:11.118]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.118]                         if (muffled) 
[09:31:11.118]                           invokeRestart("muffleMessage")
[09:31:11.118]                       }
[09:31:11.118]                       else if (inherits(cond, "warning")) {
[09:31:11.118]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.118]                         if (muffled) 
[09:31:11.118]                           invokeRestart("muffleWarning")
[09:31:11.118]                       }
[09:31:11.118]                       else if (inherits(cond, "condition")) {
[09:31:11.118]                         if (!is.null(pattern)) {
[09:31:11.118]                           computeRestarts <- base::computeRestarts
[09:31:11.118]                           grepl <- base::grepl
[09:31:11.118]                           restarts <- computeRestarts(cond)
[09:31:11.118]                           for (restart in restarts) {
[09:31:11.118]                             name <- restart$name
[09:31:11.118]                             if (is.null(name)) 
[09:31:11.118]                               next
[09:31:11.118]                             if (!grepl(pattern, name)) 
[09:31:11.118]                               next
[09:31:11.118]                             invokeRestart(restart)
[09:31:11.118]                             muffled <- TRUE
[09:31:11.118]                             break
[09:31:11.118]                           }
[09:31:11.118]                         }
[09:31:11.118]                       }
[09:31:11.118]                       invisible(muffled)
[09:31:11.118]                     }
[09:31:11.118]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.118]                   }
[09:31:11.118]                 }
[09:31:11.118]                 else {
[09:31:11.118]                   if (TRUE) {
[09:31:11.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.118]                     {
[09:31:11.118]                       inherits <- base::inherits
[09:31:11.118]                       invokeRestart <- base::invokeRestart
[09:31:11.118]                       is.null <- base::is.null
[09:31:11.118]                       muffled <- FALSE
[09:31:11.118]                       if (inherits(cond, "message")) {
[09:31:11.118]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.118]                         if (muffled) 
[09:31:11.118]                           invokeRestart("muffleMessage")
[09:31:11.118]                       }
[09:31:11.118]                       else if (inherits(cond, "warning")) {
[09:31:11.118]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.118]                         if (muffled) 
[09:31:11.118]                           invokeRestart("muffleWarning")
[09:31:11.118]                       }
[09:31:11.118]                       else if (inherits(cond, "condition")) {
[09:31:11.118]                         if (!is.null(pattern)) {
[09:31:11.118]                           computeRestarts <- base::computeRestarts
[09:31:11.118]                           grepl <- base::grepl
[09:31:11.118]                           restarts <- computeRestarts(cond)
[09:31:11.118]                           for (restart in restarts) {
[09:31:11.118]                             name <- restart$name
[09:31:11.118]                             if (is.null(name)) 
[09:31:11.118]                               next
[09:31:11.118]                             if (!grepl(pattern, name)) 
[09:31:11.118]                               next
[09:31:11.118]                             invokeRestart(restart)
[09:31:11.118]                             muffled <- TRUE
[09:31:11.118]                             break
[09:31:11.118]                           }
[09:31:11.118]                         }
[09:31:11.118]                       }
[09:31:11.118]                       invisible(muffled)
[09:31:11.118]                     }
[09:31:11.118]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.118]                   }
[09:31:11.118]                 }
[09:31:11.118]             }
[09:31:11.118]         }))
[09:31:11.118]     }, error = function(ex) {
[09:31:11.118]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.118]                 ...future.rng), started = ...future.startTime, 
[09:31:11.118]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.118]             version = "1.8"), class = "FutureResult")
[09:31:11.118]     }, finally = {
[09:31:11.118]         if (!identical(...future.workdir, getwd())) 
[09:31:11.118]             setwd(...future.workdir)
[09:31:11.118]         {
[09:31:11.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.118]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.118]             }
[09:31:11.118]             base::options(...future.oldOptions)
[09:31:11.118]             if (.Platform$OS.type == "windows") {
[09:31:11.118]                 old_names <- names(...future.oldEnvVars)
[09:31:11.118]                 envs <- base::Sys.getenv()
[09:31:11.118]                 names <- names(envs)
[09:31:11.118]                 common <- intersect(names, old_names)
[09:31:11.118]                 added <- setdiff(names, old_names)
[09:31:11.118]                 removed <- setdiff(old_names, names)
[09:31:11.118]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.118]                   envs[common]]
[09:31:11.118]                 NAMES <- toupper(changed)
[09:31:11.118]                 args <- list()
[09:31:11.118]                 for (kk in seq_along(NAMES)) {
[09:31:11.118]                   name <- changed[[kk]]
[09:31:11.118]                   NAME <- NAMES[[kk]]
[09:31:11.118]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.118]                     next
[09:31:11.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.118]                 }
[09:31:11.118]                 NAMES <- toupper(added)
[09:31:11.118]                 for (kk in seq_along(NAMES)) {
[09:31:11.118]                   name <- added[[kk]]
[09:31:11.118]                   NAME <- NAMES[[kk]]
[09:31:11.118]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.118]                     next
[09:31:11.118]                   args[[name]] <- ""
[09:31:11.118]                 }
[09:31:11.118]                 NAMES <- toupper(removed)
[09:31:11.118]                 for (kk in seq_along(NAMES)) {
[09:31:11.118]                   name <- removed[[kk]]
[09:31:11.118]                   NAME <- NAMES[[kk]]
[09:31:11.118]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.118]                     next
[09:31:11.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.118]                 }
[09:31:11.118]                 if (length(args) > 0) 
[09:31:11.118]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.118]             }
[09:31:11.118]             else {
[09:31:11.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.118]             }
[09:31:11.118]             {
[09:31:11.118]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.118]                   0L) {
[09:31:11.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.118]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.118]                   base::options(opts)
[09:31:11.118]                 }
[09:31:11.118]                 {
[09:31:11.118]                   {
[09:31:11.118]                     NULL
[09:31:11.118]                     RNGkind("Mersenne-Twister")
[09:31:11.118]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.118]                       inherits = FALSE)
[09:31:11.118]                   }
[09:31:11.118]                   options(future.plan = NULL)
[09:31:11.118]                   if (is.na(NA_character_)) 
[09:31:11.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.118]                     .init = FALSE)
[09:31:11.118]                 }
[09:31:11.118]             }
[09:31:11.118]         }
[09:31:11.118]     })
[09:31:11.118]     if (TRUE) {
[09:31:11.118]         base::sink(type = "output", split = FALSE)
[09:31:11.118]         if (TRUE) {
[09:31:11.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.118]         }
[09:31:11.118]         else {
[09:31:11.118]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.118]         }
[09:31:11.118]         base::close(...future.stdout)
[09:31:11.118]         ...future.stdout <- NULL
[09:31:11.118]     }
[09:31:11.118]     ...future.result$conditions <- ...future.conditions
[09:31:11.118]     ...future.result$finished <- base::Sys.time()
[09:31:11.118]     ...future.result
[09:31:11.118] }
[09:31:11.119] plan(): Setting new future strategy stack:
[09:31:11.120] List of future strategies:
[09:31:11.120] 1. sequential:
[09:31:11.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.120]    - tweaked: FALSE
[09:31:11.120]    - call: NULL
[09:31:11.120] plan(): nbrOfWorkers() = 1
[09:31:11.121] plan(): Setting new future strategy stack:
[09:31:11.121] List of future strategies:
[09:31:11.121] 1. sequential:
[09:31:11.121]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.121]    - tweaked: FALSE
[09:31:11.121]    - call: future::plan("sequential")
[09:31:11.121] plan(): nbrOfWorkers() = 1
[09:31:11.121] SequentialFuture started (and completed)
[09:31:11.121] - Launch lazy future ... done
[09:31:11.121] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('rscript', 'list') ...
[[1]]
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’

*** FutureRegistry('rscript', 'collect-first') ...
[09:31:11.130] resolved() for ‘SequentialFuture’ ...
[09:31:11.130] - state: ‘finished’
[09:31:11.130] - run: FALSE
[09:31:11.130] - result: ‘FutureResult’
[09:31:11.130] resolved() for ‘SequentialFuture’ ... done
list()
*** FutureRegistry('rscript', 'add') ...
[09:31:11.131] getGlobalsAndPackages() ...
[09:31:11.131] Searching for globals...
[09:31:11.131] - globals found: [1] ‘{’
[09:31:11.131] Searching for globals ... DONE
[09:31:11.131] Resolving globals: FALSE
[09:31:11.132] 
[09:31:11.132] 
[09:31:11.132] getGlobalsAndPackages() ... DONE
[09:31:11.132] run() for ‘Future’ ...
[09:31:11.132] - state: ‘created’
[09:31:11.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.133]   - Field: ‘label’
[09:31:11.133]   - Field: ‘local’
[09:31:11.133]   - Field: ‘owner’
[09:31:11.133]   - Field: ‘envir’
[09:31:11.133]   - Field: ‘packages’
[09:31:11.133]   - Field: ‘gc’
[09:31:11.133]   - Field: ‘conditions’
[09:31:11.133]   - Field: ‘expr’
[09:31:11.133]   - Field: ‘uuid’
[09:31:11.134]   - Field: ‘seed’
[09:31:11.134]   - Field: ‘version’
[09:31:11.134]   - Field: ‘result’
[09:31:11.134]   - Field: ‘asynchronous’
[09:31:11.134]   - Field: ‘calls’
[09:31:11.134]   - Field: ‘globals’
[09:31:11.134]   - Field: ‘stdout’
[09:31:11.134]   - Field: ‘earlySignal’
[09:31:11.135]   - Field: ‘lazy’
[09:31:11.135]   - Field: ‘state’
[09:31:11.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.135] - Launch lazy future ...
[09:31:11.136] Packages needed by the future expression (n = 0): <none>
[09:31:11.136] Packages needed by future strategies (n = 0): <none>
[09:31:11.136] {
[09:31:11.136]     {
[09:31:11.136]         {
[09:31:11.136]             ...future.startTime <- base::Sys.time()
[09:31:11.136]             {
[09:31:11.136]                 {
[09:31:11.136]                   {
[09:31:11.136]                     base::local({
[09:31:11.136]                       has_future <- base::requireNamespace("future", 
[09:31:11.136]                         quietly = TRUE)
[09:31:11.136]                       if (has_future) {
[09:31:11.136]                         ns <- base::getNamespace("future")
[09:31:11.136]                         version <- ns[[".package"]][["version"]]
[09:31:11.136]                         if (is.null(version)) 
[09:31:11.136]                           version <- utils::packageVersion("future")
[09:31:11.136]                       }
[09:31:11.136]                       else {
[09:31:11.136]                         version <- NULL
[09:31:11.136]                       }
[09:31:11.136]                       if (!has_future || version < "1.8.0") {
[09:31:11.136]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.136]                           "", base::R.version$version.string), 
[09:31:11.136]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.136]                             "release", "version")], collapse = " "), 
[09:31:11.136]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.136]                           info)
[09:31:11.136]                         info <- base::paste(info, collapse = "; ")
[09:31:11.136]                         if (!has_future) {
[09:31:11.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.136]                             info)
[09:31:11.136]                         }
[09:31:11.136]                         else {
[09:31:11.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.136]                             info, version)
[09:31:11.136]                         }
[09:31:11.136]                         base::stop(msg)
[09:31:11.136]                       }
[09:31:11.136]                     })
[09:31:11.136]                   }
[09:31:11.136]                   ...future.strategy.old <- future::plan("list")
[09:31:11.136]                   options(future.plan = NULL)
[09:31:11.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.136]                 }
[09:31:11.136]                 ...future.workdir <- getwd()
[09:31:11.136]             }
[09:31:11.136]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.136]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.136]         }
[09:31:11.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.136]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.136]             base::names(...future.oldOptions))
[09:31:11.136]     }
[09:31:11.136]     if (FALSE) {
[09:31:11.136]     }
[09:31:11.136]     else {
[09:31:11.136]         if (TRUE) {
[09:31:11.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.136]                 open = "w")
[09:31:11.136]         }
[09:31:11.136]         else {
[09:31:11.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.136]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.136]         }
[09:31:11.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.136]             base::sink(type = "output", split = FALSE)
[09:31:11.136]             base::close(...future.stdout)
[09:31:11.136]         }, add = TRUE)
[09:31:11.136]     }
[09:31:11.136]     ...future.frame <- base::sys.nframe()
[09:31:11.136]     ...future.conditions <- base::list()
[09:31:11.136]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.136]     if (FALSE) {
[09:31:11.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.136]     }
[09:31:11.136]     ...future.result <- base::tryCatch({
[09:31:11.136]         base::withCallingHandlers({
[09:31:11.136]             ...future.value <- base::withVisible(base::local({
[09:31:11.136]                 2
[09:31:11.136]             }))
[09:31:11.136]             future::FutureResult(value = ...future.value$value, 
[09:31:11.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.136]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.136]                     ...future.globalenv.names))
[09:31:11.136]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.136]         }, condition = base::local({
[09:31:11.136]             c <- base::c
[09:31:11.136]             inherits <- base::inherits
[09:31:11.136]             invokeRestart <- base::invokeRestart
[09:31:11.136]             length <- base::length
[09:31:11.136]             list <- base::list
[09:31:11.136]             seq.int <- base::seq.int
[09:31:11.136]             signalCondition <- base::signalCondition
[09:31:11.136]             sys.calls <- base::sys.calls
[09:31:11.136]             `[[` <- base::`[[`
[09:31:11.136]             `+` <- base::`+`
[09:31:11.136]             `<<-` <- base::`<<-`
[09:31:11.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.136]                   3L)]
[09:31:11.136]             }
[09:31:11.136]             function(cond) {
[09:31:11.136]                 is_error <- inherits(cond, "error")
[09:31:11.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.136]                   NULL)
[09:31:11.136]                 if (is_error) {
[09:31:11.136]                   sessionInformation <- function() {
[09:31:11.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.136]                       search = base::search(), system = base::Sys.info())
[09:31:11.136]                   }
[09:31:11.136]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.136]                     cond$call), session = sessionInformation(), 
[09:31:11.136]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.136]                   signalCondition(cond)
[09:31:11.136]                 }
[09:31:11.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.136]                 "immediateCondition"))) {
[09:31:11.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.136]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.136]                   if (TRUE && !signal) {
[09:31:11.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.136]                     {
[09:31:11.136]                       inherits <- base::inherits
[09:31:11.136]                       invokeRestart <- base::invokeRestart
[09:31:11.136]                       is.null <- base::is.null
[09:31:11.136]                       muffled <- FALSE
[09:31:11.136]                       if (inherits(cond, "message")) {
[09:31:11.136]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.136]                         if (muffled) 
[09:31:11.136]                           invokeRestart("muffleMessage")
[09:31:11.136]                       }
[09:31:11.136]                       else if (inherits(cond, "warning")) {
[09:31:11.136]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.136]                         if (muffled) 
[09:31:11.136]                           invokeRestart("muffleWarning")
[09:31:11.136]                       }
[09:31:11.136]                       else if (inherits(cond, "condition")) {
[09:31:11.136]                         if (!is.null(pattern)) {
[09:31:11.136]                           computeRestarts <- base::computeRestarts
[09:31:11.136]                           grepl <- base::grepl
[09:31:11.136]                           restarts <- computeRestarts(cond)
[09:31:11.136]                           for (restart in restarts) {
[09:31:11.136]                             name <- restart$name
[09:31:11.136]                             if (is.null(name)) 
[09:31:11.136]                               next
[09:31:11.136]                             if (!grepl(pattern, name)) 
[09:31:11.136]                               next
[09:31:11.136]                             invokeRestart(restart)
[09:31:11.136]                             muffled <- TRUE
[09:31:11.136]                             break
[09:31:11.136]                           }
[09:31:11.136]                         }
[09:31:11.136]                       }
[09:31:11.136]                       invisible(muffled)
[09:31:11.136]                     }
[09:31:11.136]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.136]                   }
[09:31:11.136]                 }
[09:31:11.136]                 else {
[09:31:11.136]                   if (TRUE) {
[09:31:11.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.136]                     {
[09:31:11.136]                       inherits <- base::inherits
[09:31:11.136]                       invokeRestart <- base::invokeRestart
[09:31:11.136]                       is.null <- base::is.null
[09:31:11.136]                       muffled <- FALSE
[09:31:11.136]                       if (inherits(cond, "message")) {
[09:31:11.136]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.136]                         if (muffled) 
[09:31:11.136]                           invokeRestart("muffleMessage")
[09:31:11.136]                       }
[09:31:11.136]                       else if (inherits(cond, "warning")) {
[09:31:11.136]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.136]                         if (muffled) 
[09:31:11.136]                           invokeRestart("muffleWarning")
[09:31:11.136]                       }
[09:31:11.136]                       else if (inherits(cond, "condition")) {
[09:31:11.136]                         if (!is.null(pattern)) {
[09:31:11.136]                           computeRestarts <- base::computeRestarts
[09:31:11.136]                           grepl <- base::grepl
[09:31:11.136]                           restarts <- computeRestarts(cond)
[09:31:11.136]                           for (restart in restarts) {
[09:31:11.136]                             name <- restart$name
[09:31:11.136]                             if (is.null(name)) 
[09:31:11.136]                               next
[09:31:11.136]                             if (!grepl(pattern, name)) 
[09:31:11.136]                               next
[09:31:11.136]                             invokeRestart(restart)
[09:31:11.136]                             muffled <- TRUE
[09:31:11.136]                             break
[09:31:11.136]                           }
[09:31:11.136]                         }
[09:31:11.136]                       }
[09:31:11.136]                       invisible(muffled)
[09:31:11.136]                     }
[09:31:11.136]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.136]                   }
[09:31:11.136]                 }
[09:31:11.136]             }
[09:31:11.136]         }))
[09:31:11.136]     }, error = function(ex) {
[09:31:11.136]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.136]                 ...future.rng), started = ...future.startTime, 
[09:31:11.136]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.136]             version = "1.8"), class = "FutureResult")
[09:31:11.136]     }, finally = {
[09:31:11.136]         if (!identical(...future.workdir, getwd())) 
[09:31:11.136]             setwd(...future.workdir)
[09:31:11.136]         {
[09:31:11.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.136]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.136]             }
[09:31:11.136]             base::options(...future.oldOptions)
[09:31:11.136]             if (.Platform$OS.type == "windows") {
[09:31:11.136]                 old_names <- names(...future.oldEnvVars)
[09:31:11.136]                 envs <- base::Sys.getenv()
[09:31:11.136]                 names <- names(envs)
[09:31:11.136]                 common <- intersect(names, old_names)
[09:31:11.136]                 added <- setdiff(names, old_names)
[09:31:11.136]                 removed <- setdiff(old_names, names)
[09:31:11.136]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.136]                   envs[common]]
[09:31:11.136]                 NAMES <- toupper(changed)
[09:31:11.136]                 args <- list()
[09:31:11.136]                 for (kk in seq_along(NAMES)) {
[09:31:11.136]                   name <- changed[[kk]]
[09:31:11.136]                   NAME <- NAMES[[kk]]
[09:31:11.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.136]                     next
[09:31:11.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.136]                 }
[09:31:11.136]                 NAMES <- toupper(added)
[09:31:11.136]                 for (kk in seq_along(NAMES)) {
[09:31:11.136]                   name <- added[[kk]]
[09:31:11.136]                   NAME <- NAMES[[kk]]
[09:31:11.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.136]                     next
[09:31:11.136]                   args[[name]] <- ""
[09:31:11.136]                 }
[09:31:11.136]                 NAMES <- toupper(removed)
[09:31:11.136]                 for (kk in seq_along(NAMES)) {
[09:31:11.136]                   name <- removed[[kk]]
[09:31:11.136]                   NAME <- NAMES[[kk]]
[09:31:11.136]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.136]                     next
[09:31:11.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.136]                 }
[09:31:11.136]                 if (length(args) > 0) 
[09:31:11.136]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.136]             }
[09:31:11.136]             else {
[09:31:11.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.136]             }
[09:31:11.136]             {
[09:31:11.136]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.136]                   0L) {
[09:31:11.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.136]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.136]                   base::options(opts)
[09:31:11.136]                 }
[09:31:11.136]                 {
[09:31:11.136]                   {
[09:31:11.136]                     NULL
[09:31:11.136]                     RNGkind("Mersenne-Twister")
[09:31:11.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.136]                       inherits = FALSE)
[09:31:11.136]                   }
[09:31:11.136]                   options(future.plan = NULL)
[09:31:11.136]                   if (is.na(NA_character_)) 
[09:31:11.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.136]                     .init = FALSE)
[09:31:11.136]                 }
[09:31:11.136]             }
[09:31:11.136]         }
[09:31:11.136]     })
[09:31:11.136]     if (TRUE) {
[09:31:11.136]         base::sink(type = "output", split = FALSE)
[09:31:11.136]         if (TRUE) {
[09:31:11.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.136]         }
[09:31:11.136]         else {
[09:31:11.136]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.136]         }
[09:31:11.136]         base::close(...future.stdout)
[09:31:11.136]         ...future.stdout <- NULL
[09:31:11.136]     }
[09:31:11.136]     ...future.result$conditions <- ...future.conditions
[09:31:11.136]     ...future.result$finished <- base::Sys.time()
[09:31:11.136]     ...future.result
[09:31:11.136] }
[09:31:11.138] plan(): Setting new future strategy stack:
[09:31:11.138] List of future strategies:
[09:31:11.138] 1. sequential:
[09:31:11.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.138]    - tweaked: FALSE
[09:31:11.138]    - call: NULL
[09:31:11.138] plan(): nbrOfWorkers() = 1
[09:31:11.139] plan(): Setting new future strategy stack:
[09:31:11.139] List of future strategies:
[09:31:11.139] 1. sequential:
[09:31:11.139]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.139]    - tweaked: FALSE
[09:31:11.139]    - call: future::plan("sequential")
[09:31:11.139] plan(): nbrOfWorkers() = 1
[09:31:11.140] SequentialFuture started (and completed)
[09:31:11.140] - Launch lazy future ... done
[09:31:11.140] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    2
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
*** FutureRegistry('rscript', 'reset') ...
*** FutureRegistry('rscript', 'list') ...
list()
> 
> 
> message("*** FutureRegistry() - exceptions ...")
*** FutureRegistry() - exceptions ...
> 
> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 0)
> 
> f <- future(1)
[09:31:11.141] getGlobalsAndPackages() ...
[09:31:11.141] Searching for globals...
[09:31:11.141] 
[09:31:11.141] Searching for globals ... DONE
[09:31:11.141] - globals: [0] <none>
[09:31:11.141] getGlobalsAndPackages() ... DONE
[09:31:11.141] run() for ‘Future’ ...
[09:31:11.142] - state: ‘created’
[09:31:11.142] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:31:11.142] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:31:11.142] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:31:11.142]   - Field: ‘label’
[09:31:11.142]   - Field: ‘local’
[09:31:11.142]   - Field: ‘owner’
[09:31:11.142]   - Field: ‘envir’
[09:31:11.142]   - Field: ‘packages’
[09:31:11.143]   - Field: ‘gc’
[09:31:11.143]   - Field: ‘conditions’
[09:31:11.143]   - Field: ‘expr’
[09:31:11.143]   - Field: ‘uuid’
[09:31:11.143]   - Field: ‘seed’
[09:31:11.143]   - Field: ‘version’
[09:31:11.143]   - Field: ‘result’
[09:31:11.143]   - Field: ‘asynchronous’
[09:31:11.143]   - Field: ‘calls’
[09:31:11.143]   - Field: ‘globals’
[09:31:11.143]   - Field: ‘stdout’
[09:31:11.144]   - Field: ‘earlySignal’
[09:31:11.144]   - Field: ‘lazy’
[09:31:11.144]   - Field: ‘state’
[09:31:11.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:31:11.144] - Launch lazy future ...
[09:31:11.144] Packages needed by the future expression (n = 0): <none>
[09:31:11.144] Packages needed by future strategies (n = 0): <none>
[09:31:11.145] {
[09:31:11.145]     {
[09:31:11.145]         {
[09:31:11.145]             ...future.startTime <- base::Sys.time()
[09:31:11.145]             {
[09:31:11.145]                 {
[09:31:11.145]                   {
[09:31:11.145]                     base::local({
[09:31:11.145]                       has_future <- base::requireNamespace("future", 
[09:31:11.145]                         quietly = TRUE)
[09:31:11.145]                       if (has_future) {
[09:31:11.145]                         ns <- base::getNamespace("future")
[09:31:11.145]                         version <- ns[[".package"]][["version"]]
[09:31:11.145]                         if (is.null(version)) 
[09:31:11.145]                           version <- utils::packageVersion("future")
[09:31:11.145]                       }
[09:31:11.145]                       else {
[09:31:11.145]                         version <- NULL
[09:31:11.145]                       }
[09:31:11.145]                       if (!has_future || version < "1.8.0") {
[09:31:11.145]                         info <- base::c(r_version = base::gsub("R version ", 
[09:31:11.145]                           "", base::R.version$version.string), 
[09:31:11.145]                           platform = base::sprintf("%s (%s-bit)", 
[09:31:11.145]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:31:11.145]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:31:11.145]                             "release", "version")], collapse = " "), 
[09:31:11.145]                           hostname = base::Sys.info()[["nodename"]])
[09:31:11.145]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:31:11.145]                           info)
[09:31:11.145]                         info <- base::paste(info, collapse = "; ")
[09:31:11.145]                         if (!has_future) {
[09:31:11.145]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:31:11.145]                             info)
[09:31:11.145]                         }
[09:31:11.145]                         else {
[09:31:11.145]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:31:11.145]                             info, version)
[09:31:11.145]                         }
[09:31:11.145]                         base::stop(msg)
[09:31:11.145]                       }
[09:31:11.145]                     })
[09:31:11.145]                   }
[09:31:11.145]                   ...future.strategy.old <- future::plan("list")
[09:31:11.145]                   options(future.plan = NULL)
[09:31:11.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:31:11.145]                 }
[09:31:11.145]                 ...future.workdir <- getwd()
[09:31:11.145]             }
[09:31:11.145]             ...future.oldOptions <- base::as.list(base::.Options)
[09:31:11.145]             ...future.oldEnvVars <- base::Sys.getenv()
[09:31:11.145]         }
[09:31:11.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:31:11.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:31:11.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:31:11.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:31:11.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:31:11.145]             future.stdout.windows.reencode = NULL, width = 80L)
[09:31:11.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:31:11.145]             base::names(...future.oldOptions))
[09:31:11.145]     }
[09:31:11.145]     if (FALSE) {
[09:31:11.145]     }
[09:31:11.145]     else {
[09:31:11.145]         if (TRUE) {
[09:31:11.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:31:11.145]                 open = "w")
[09:31:11.145]         }
[09:31:11.145]         else {
[09:31:11.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:31:11.145]                 windows = "NUL", "/dev/null"), open = "w")
[09:31:11.145]         }
[09:31:11.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:31:11.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:31:11.145]             base::sink(type = "output", split = FALSE)
[09:31:11.145]             base::close(...future.stdout)
[09:31:11.145]         }, add = TRUE)
[09:31:11.145]     }
[09:31:11.145]     ...future.frame <- base::sys.nframe()
[09:31:11.145]     ...future.conditions <- base::list()
[09:31:11.145]     ...future.rng <- base::globalenv()$.Random.seed
[09:31:11.145]     if (FALSE) {
[09:31:11.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:31:11.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:31:11.145]     }
[09:31:11.145]     ...future.result <- base::tryCatch({
[09:31:11.145]         base::withCallingHandlers({
[09:31:11.145]             ...future.value <- base::withVisible(base::local(1))
[09:31:11.145]             future::FutureResult(value = ...future.value$value, 
[09:31:11.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.145]                   ...future.rng), globalenv = if (FALSE) 
[09:31:11.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:31:11.145]                     ...future.globalenv.names))
[09:31:11.145]                 else NULL, started = ...future.startTime, version = "1.8")
[09:31:11.145]         }, condition = base::local({
[09:31:11.145]             c <- base::c
[09:31:11.145]             inherits <- base::inherits
[09:31:11.145]             invokeRestart <- base::invokeRestart
[09:31:11.145]             length <- base::length
[09:31:11.145]             list <- base::list
[09:31:11.145]             seq.int <- base::seq.int
[09:31:11.145]             signalCondition <- base::signalCondition
[09:31:11.145]             sys.calls <- base::sys.calls
[09:31:11.145]             `[[` <- base::`[[`
[09:31:11.145]             `+` <- base::`+`
[09:31:11.145]             `<<-` <- base::`<<-`
[09:31:11.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:31:11.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:31:11.145]                   3L)]
[09:31:11.145]             }
[09:31:11.145]             function(cond) {
[09:31:11.145]                 is_error <- inherits(cond, "error")
[09:31:11.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:31:11.145]                   NULL)
[09:31:11.145]                 if (is_error) {
[09:31:11.145]                   sessionInformation <- function() {
[09:31:11.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:31:11.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:31:11.145]                       search = base::search(), system = base::Sys.info())
[09:31:11.145]                   }
[09:31:11.145]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:31:11.145]                     cond$call), session = sessionInformation(), 
[09:31:11.145]                     timestamp = base::Sys.time(), signaled = 0L)
[09:31:11.145]                   signalCondition(cond)
[09:31:11.145]                 }
[09:31:11.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:31:11.145]                 "immediateCondition"))) {
[09:31:11.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:31:11.145]                   ...future.conditions[[length(...future.conditions) + 
[09:31:11.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:31:11.145]                   if (TRUE && !signal) {
[09:31:11.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.145]                     {
[09:31:11.145]                       inherits <- base::inherits
[09:31:11.145]                       invokeRestart <- base::invokeRestart
[09:31:11.145]                       is.null <- base::is.null
[09:31:11.145]                       muffled <- FALSE
[09:31:11.145]                       if (inherits(cond, "message")) {
[09:31:11.145]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.145]                         if (muffled) 
[09:31:11.145]                           invokeRestart("muffleMessage")
[09:31:11.145]                       }
[09:31:11.145]                       else if (inherits(cond, "warning")) {
[09:31:11.145]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.145]                         if (muffled) 
[09:31:11.145]                           invokeRestart("muffleWarning")
[09:31:11.145]                       }
[09:31:11.145]                       else if (inherits(cond, "condition")) {
[09:31:11.145]                         if (!is.null(pattern)) {
[09:31:11.145]                           computeRestarts <- base::computeRestarts
[09:31:11.145]                           grepl <- base::grepl
[09:31:11.145]                           restarts <- computeRestarts(cond)
[09:31:11.145]                           for (restart in restarts) {
[09:31:11.145]                             name <- restart$name
[09:31:11.145]                             if (is.null(name)) 
[09:31:11.145]                               next
[09:31:11.145]                             if (!grepl(pattern, name)) 
[09:31:11.145]                               next
[09:31:11.145]                             invokeRestart(restart)
[09:31:11.145]                             muffled <- TRUE
[09:31:11.145]                             break
[09:31:11.145]                           }
[09:31:11.145]                         }
[09:31:11.145]                       }
[09:31:11.145]                       invisible(muffled)
[09:31:11.145]                     }
[09:31:11.145]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.145]                   }
[09:31:11.145]                 }
[09:31:11.145]                 else {
[09:31:11.145]                   if (TRUE) {
[09:31:11.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:31:11.145]                     {
[09:31:11.145]                       inherits <- base::inherits
[09:31:11.145]                       invokeRestart <- base::invokeRestart
[09:31:11.145]                       is.null <- base::is.null
[09:31:11.145]                       muffled <- FALSE
[09:31:11.145]                       if (inherits(cond, "message")) {
[09:31:11.145]                         muffled <- grepl(pattern, "muffleMessage")
[09:31:11.145]                         if (muffled) 
[09:31:11.145]                           invokeRestart("muffleMessage")
[09:31:11.145]                       }
[09:31:11.145]                       else if (inherits(cond, "warning")) {
[09:31:11.145]                         muffled <- grepl(pattern, "muffleWarning")
[09:31:11.145]                         if (muffled) 
[09:31:11.145]                           invokeRestart("muffleWarning")
[09:31:11.145]                       }
[09:31:11.145]                       else if (inherits(cond, "condition")) {
[09:31:11.145]                         if (!is.null(pattern)) {
[09:31:11.145]                           computeRestarts <- base::computeRestarts
[09:31:11.145]                           grepl <- base::grepl
[09:31:11.145]                           restarts <- computeRestarts(cond)
[09:31:11.145]                           for (restart in restarts) {
[09:31:11.145]                             name <- restart$name
[09:31:11.145]                             if (is.null(name)) 
[09:31:11.145]                               next
[09:31:11.145]                             if (!grepl(pattern, name)) 
[09:31:11.145]                               next
[09:31:11.145]                             invokeRestart(restart)
[09:31:11.145]                             muffled <- TRUE
[09:31:11.145]                             break
[09:31:11.145]                           }
[09:31:11.145]                         }
[09:31:11.145]                       }
[09:31:11.145]                       invisible(muffled)
[09:31:11.145]                     }
[09:31:11.145]                     muffleCondition(cond, pattern = "^muffle")
[09:31:11.145]                   }
[09:31:11.145]                 }
[09:31:11.145]             }
[09:31:11.145]         }))
[09:31:11.145]     }, error = function(ex) {
[09:31:11.145]         base::structure(base::list(value = NULL, visible = NULL, 
[09:31:11.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:31:11.145]                 ...future.rng), started = ...future.startTime, 
[09:31:11.145]             finished = Sys.time(), session_uuid = NA_character_, 
[09:31:11.145]             version = "1.8"), class = "FutureResult")
[09:31:11.145]     }, finally = {
[09:31:11.145]         if (!identical(...future.workdir, getwd())) 
[09:31:11.145]             setwd(...future.workdir)
[09:31:11.145]         {
[09:31:11.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:31:11.145]                 ...future.oldOptions$nwarnings <- NULL
[09:31:11.145]             }
[09:31:11.145]             base::options(...future.oldOptions)
[09:31:11.145]             if (.Platform$OS.type == "windows") {
[09:31:11.145]                 old_names <- names(...future.oldEnvVars)
[09:31:11.145]                 envs <- base::Sys.getenv()
[09:31:11.145]                 names <- names(envs)
[09:31:11.145]                 common <- intersect(names, old_names)
[09:31:11.145]                 added <- setdiff(names, old_names)
[09:31:11.145]                 removed <- setdiff(old_names, names)
[09:31:11.145]                 changed <- common[...future.oldEnvVars[common] != 
[09:31:11.145]                   envs[common]]
[09:31:11.145]                 NAMES <- toupper(changed)
[09:31:11.145]                 args <- list()
[09:31:11.145]                 for (kk in seq_along(NAMES)) {
[09:31:11.145]                   name <- changed[[kk]]
[09:31:11.145]                   NAME <- NAMES[[kk]]
[09:31:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.145]                     next
[09:31:11.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.145]                 }
[09:31:11.145]                 NAMES <- toupper(added)
[09:31:11.145]                 for (kk in seq_along(NAMES)) {
[09:31:11.145]                   name <- added[[kk]]
[09:31:11.145]                   NAME <- NAMES[[kk]]
[09:31:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.145]                     next
[09:31:11.145]                   args[[name]] <- ""
[09:31:11.145]                 }
[09:31:11.145]                 NAMES <- toupper(removed)
[09:31:11.145]                 for (kk in seq_along(NAMES)) {
[09:31:11.145]                   name <- removed[[kk]]
[09:31:11.145]                   NAME <- NAMES[[kk]]
[09:31:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[09:31:11.145]                     next
[09:31:11.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:31:11.145]                 }
[09:31:11.145]                 if (length(args) > 0) 
[09:31:11.145]                   base::do.call(base::Sys.setenv, args = args)
[09:31:11.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:31:11.145]             }
[09:31:11.145]             else {
[09:31:11.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:31:11.145]             }
[09:31:11.145]             {
[09:31:11.145]                 if (base::length(...future.futureOptionsAdded) > 
[09:31:11.145]                   0L) {
[09:31:11.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:31:11.145]                   base::names(opts) <- ...future.futureOptionsAdded
[09:31:11.145]                   base::options(opts)
[09:31:11.145]                 }
[09:31:11.145]                 {
[09:31:11.145]                   {
[09:31:11.145]                     NULL
[09:31:11.145]                     RNGkind("Mersenne-Twister")
[09:31:11.145]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:31:11.145]                       inherits = FALSE)
[09:31:11.145]                   }
[09:31:11.145]                   options(future.plan = NULL)
[09:31:11.145]                   if (is.na(NA_character_)) 
[09:31:11.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:31:11.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:31:11.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:31:11.145]                     .init = FALSE)
[09:31:11.145]                 }
[09:31:11.145]             }
[09:31:11.145]         }
[09:31:11.145]     })
[09:31:11.145]     if (TRUE) {
[09:31:11.145]         base::sink(type = "output", split = FALSE)
[09:31:11.145]         if (TRUE) {
[09:31:11.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:31:11.145]         }
[09:31:11.145]         else {
[09:31:11.145]             ...future.result["stdout"] <- base::list(NULL)
[09:31:11.145]         }
[09:31:11.145]         base::close(...future.stdout)
[09:31:11.145]         ...future.stdout <- NULL
[09:31:11.145]     }
[09:31:11.145]     ...future.result$conditions <- ...future.conditions
[09:31:11.145]     ...future.result$finished <- base::Sys.time()
[09:31:11.145]     ...future.result
[09:31:11.145] }
[09:31:11.146] plan(): Setting new future strategy stack:
[09:31:11.146] List of future strategies:
[09:31:11.146] 1. sequential:
[09:31:11.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.146]    - tweaked: FALSE
[09:31:11.146]    - call: NULL
[09:31:11.147] plan(): nbrOfWorkers() = 1
[09:31:11.147] plan(): Setting new future strategy stack:
[09:31:11.147] List of future strategies:
[09:31:11.147] 1. sequential:
[09:31:11.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.147]    - tweaked: FALSE
[09:31:11.147]    - call: future::plan("sequential")
[09:31:11.148] plan(): nbrOfWorkers() = 1
[09:31:11.148] SequentialFuture started (and completed)
[09:31:11.148] - Launch lazy future ... done
[09:31:11.148] run() for ‘SequentialFuture’ ... done
> FutureRegistry(where = "test", action = "add", future = f)
[[1]]
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 1
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 56 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 25dfa052-6d78-16c0-16b8-994b6e71bac9
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’

> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 1)
> 
> res <- tryCatch(FutureRegistry(where = "test", action = "add", future = f), error = identity)
[09:31:11.149] ERROR: Cannot add to ‘test’ registry. SequentialFuture is already registered.
> stopifnot(inherits(res, "error"))
> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 1)
> 
> 
> FutureRegistry(where = "test", action = "remove", future = f)
list()
> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 0)
> 
> res <- tryCatch(FutureRegistry(where = "test", action = "remove", future = f), error = identity)
[09:31:11.149] ERROR: Cannot remove from ‘test’ registry. SequentialFuture not registered.
> stopifnot(inherits(res, "error"))
> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 0)
> 
> FutureRegistry(where = "test", action = "reset")
list()
> futures <- FutureRegistry(where = "test", action = "list")
> stopifnot(length(futures) == 0)
> 
> res <- tryCatch(FutureRegistry(where = "test", action = "<unknown>"), error = identity)
[09:31:11.150] INTERNAL ERROR: Unknown action to ‘test’ registry: <unknown>
> stopifnot(inherits(res, "error"))
> 
> message("*** FutureRegistry() - exceptions ... DONE")
*** FutureRegistry() - exceptions ... DONE
> 
> 
> message("*** FutureRegistry() ... DONE")
*** FutureRegistry() ... DONE
> 
> source("incl/end.R")
[09:31:11.150] plan(): Setting new future strategy stack:
[09:31:11.151] List of future strategies:
[09:31:11.151] 1. FutureStrategy:
[09:31:11.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:31:11.151]    - tweaked: FALSE
[09:31:11.151]    - call: future::plan(oplan)
[09:31:11.161] plan(): nbrOfWorkers() = 1
> 
