
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[17:40:40.437] plan(): Setting new future strategy stack:
[17:40:40.438] List of future strategies:
[17:40:40.438] 1. sequential:
[17:40:40.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.438]    - tweaked: FALSE
[17:40:40.438]    - call: future::plan("sequential")
[17:40:40.448] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[17:40:40.636] plan(): Setting new future strategy stack:
[17:40:40.636] List of future strategies:
[17:40:40.636] 1. sequential:
[17:40:40.636]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.636]    - tweaked: FALSE
[17:40:40.636]    - call: plan(strategy)
[17:40:40.646] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[17:40:40.647] resolve() on list ...
[17:40:40.647]  recursive: 0
[17:40:40.647]  length: 2
[17:40:40.647]  elements: ‘a’, ‘b’
[17:40:40.649]  length: 1 (resolved future 1)
[17:40:40.649]  length: 0 (resolved future 2)
[17:40:40.649] resolve() on list ... DONE
[17:40:40.649] getGlobalsAndPackages() ...
[17:40:40.650] Searching for globals...
[17:40:40.652] 
[17:40:40.652] Searching for globals ... DONE
[17:40:40.652] - globals: [0] <none>
[17:40:40.652] getGlobalsAndPackages() ... DONE
[17:40:40.653] run() for ‘Future’ ...
[17:40:40.653] - state: ‘created’
[17:40:40.653] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.653] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.653]   - Field: ‘label’
[17:40:40.653]   - Field: ‘local’
[17:40:40.654]   - Field: ‘owner’
[17:40:40.654]   - Field: ‘envir’
[17:40:40.654]   - Field: ‘packages’
[17:40:40.654]   - Field: ‘gc’
[17:40:40.654]   - Field: ‘conditions’
[17:40:40.654]   - Field: ‘expr’
[17:40:40.654]   - Field: ‘uuid’
[17:40:40.654]   - Field: ‘seed’
[17:40:40.654]   - Field: ‘version’
[17:40:40.654]   - Field: ‘result’
[17:40:40.654]   - Field: ‘asynchronous’
[17:40:40.655]   - Field: ‘calls’
[17:40:40.655]   - Field: ‘globals’
[17:40:40.655]   - Field: ‘stdout’
[17:40:40.655]   - Field: ‘earlySignal’
[17:40:40.655]   - Field: ‘lazy’
[17:40:40.655]   - Field: ‘state’
[17:40:40.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.655] - Launch lazy future ...
[17:40:40.656] Packages needed by the future expression (n = 0): <none>
[17:40:40.656] Packages needed by future strategies (n = 0): <none>
[17:40:40.657] {
[17:40:40.657]     {
[17:40:40.657]         {
[17:40:40.657]             ...future.startTime <- base::Sys.time()
[17:40:40.657]             {
[17:40:40.657]                 {
[17:40:40.657]                   {
[17:40:40.657]                     base::local({
[17:40:40.657]                       has_future <- base::requireNamespace("future", 
[17:40:40.657]                         quietly = TRUE)
[17:40:40.657]                       if (has_future) {
[17:40:40.657]                         ns <- base::getNamespace("future")
[17:40:40.657]                         version <- ns[[".package"]][["version"]]
[17:40:40.657]                         if (is.null(version)) 
[17:40:40.657]                           version <- utils::packageVersion("future")
[17:40:40.657]                       }
[17:40:40.657]                       else {
[17:40:40.657]                         version <- NULL
[17:40:40.657]                       }
[17:40:40.657]                       if (!has_future || version < "1.8.0") {
[17:40:40.657]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.657]                           "", base::R.version$version.string), 
[17:40:40.657]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.657]                             "release", "version")], collapse = " "), 
[17:40:40.657]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.657]                           info)
[17:40:40.657]                         info <- base::paste(info, collapse = "; ")
[17:40:40.657]                         if (!has_future) {
[17:40:40.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.657]                             info)
[17:40:40.657]                         }
[17:40:40.657]                         else {
[17:40:40.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.657]                             info, version)
[17:40:40.657]                         }
[17:40:40.657]                         base::stop(msg)
[17:40:40.657]                       }
[17:40:40.657]                     })
[17:40:40.657]                   }
[17:40:40.657]                   ...future.strategy.old <- future::plan("list")
[17:40:40.657]                   options(future.plan = NULL)
[17:40:40.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.657]                 }
[17:40:40.657]                 ...future.workdir <- getwd()
[17:40:40.657]             }
[17:40:40.657]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.657]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.657]         }
[17:40:40.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.657]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.657]             base::names(...future.oldOptions))
[17:40:40.657]     }
[17:40:40.657]     if (FALSE) {
[17:40:40.657]     }
[17:40:40.657]     else {
[17:40:40.657]         if (TRUE) {
[17:40:40.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.657]                 open = "w")
[17:40:40.657]         }
[17:40:40.657]         else {
[17:40:40.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.657]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.657]         }
[17:40:40.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.657]             base::sink(type = "output", split = FALSE)
[17:40:40.657]             base::close(...future.stdout)
[17:40:40.657]         }, add = TRUE)
[17:40:40.657]     }
[17:40:40.657]     ...future.frame <- base::sys.nframe()
[17:40:40.657]     ...future.conditions <- base::list()
[17:40:40.657]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.657]     if (FALSE) {
[17:40:40.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.657]     }
[17:40:40.657]     ...future.result <- base::tryCatch({
[17:40:40.657]         base::withCallingHandlers({
[17:40:40.657]             ...future.value <- base::withVisible(base::local(1))
[17:40:40.657]             future::FutureResult(value = ...future.value$value, 
[17:40:40.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.657]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.657]                     ...future.globalenv.names))
[17:40:40.657]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.657]         }, condition = base::local({
[17:40:40.657]             c <- base::c
[17:40:40.657]             inherits <- base::inherits
[17:40:40.657]             invokeRestart <- base::invokeRestart
[17:40:40.657]             length <- base::length
[17:40:40.657]             list <- base::list
[17:40:40.657]             seq.int <- base::seq.int
[17:40:40.657]             signalCondition <- base::signalCondition
[17:40:40.657]             sys.calls <- base::sys.calls
[17:40:40.657]             `[[` <- base::`[[`
[17:40:40.657]             `+` <- base::`+`
[17:40:40.657]             `<<-` <- base::`<<-`
[17:40:40.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.657]                   3L)]
[17:40:40.657]             }
[17:40:40.657]             function(cond) {
[17:40:40.657]                 is_error <- inherits(cond, "error")
[17:40:40.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.657]                   NULL)
[17:40:40.657]                 if (is_error) {
[17:40:40.657]                   sessionInformation <- function() {
[17:40:40.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.657]                       search = base::search(), system = base::Sys.info())
[17:40:40.657]                   }
[17:40:40.657]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.657]                     cond$call), session = sessionInformation(), 
[17:40:40.657]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.657]                   signalCondition(cond)
[17:40:40.657]                 }
[17:40:40.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.657]                 "immediateCondition"))) {
[17:40:40.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.657]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.657]                   if (TRUE && !signal) {
[17:40:40.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.657]                     {
[17:40:40.657]                       inherits <- base::inherits
[17:40:40.657]                       invokeRestart <- base::invokeRestart
[17:40:40.657]                       is.null <- base::is.null
[17:40:40.657]                       muffled <- FALSE
[17:40:40.657]                       if (inherits(cond, "message")) {
[17:40:40.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.657]                         if (muffled) 
[17:40:40.657]                           invokeRestart("muffleMessage")
[17:40:40.657]                       }
[17:40:40.657]                       else if (inherits(cond, "warning")) {
[17:40:40.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.657]                         if (muffled) 
[17:40:40.657]                           invokeRestart("muffleWarning")
[17:40:40.657]                       }
[17:40:40.657]                       else if (inherits(cond, "condition")) {
[17:40:40.657]                         if (!is.null(pattern)) {
[17:40:40.657]                           computeRestarts <- base::computeRestarts
[17:40:40.657]                           grepl <- base::grepl
[17:40:40.657]                           restarts <- computeRestarts(cond)
[17:40:40.657]                           for (restart in restarts) {
[17:40:40.657]                             name <- restart$name
[17:40:40.657]                             if (is.null(name)) 
[17:40:40.657]                               next
[17:40:40.657]                             if (!grepl(pattern, name)) 
[17:40:40.657]                               next
[17:40:40.657]                             invokeRestart(restart)
[17:40:40.657]                             muffled <- TRUE
[17:40:40.657]                             break
[17:40:40.657]                           }
[17:40:40.657]                         }
[17:40:40.657]                       }
[17:40:40.657]                       invisible(muffled)
[17:40:40.657]                     }
[17:40:40.657]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.657]                   }
[17:40:40.657]                 }
[17:40:40.657]                 else {
[17:40:40.657]                   if (TRUE) {
[17:40:40.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.657]                     {
[17:40:40.657]                       inherits <- base::inherits
[17:40:40.657]                       invokeRestart <- base::invokeRestart
[17:40:40.657]                       is.null <- base::is.null
[17:40:40.657]                       muffled <- FALSE
[17:40:40.657]                       if (inherits(cond, "message")) {
[17:40:40.657]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.657]                         if (muffled) 
[17:40:40.657]                           invokeRestart("muffleMessage")
[17:40:40.657]                       }
[17:40:40.657]                       else if (inherits(cond, "warning")) {
[17:40:40.657]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.657]                         if (muffled) 
[17:40:40.657]                           invokeRestart("muffleWarning")
[17:40:40.657]                       }
[17:40:40.657]                       else if (inherits(cond, "condition")) {
[17:40:40.657]                         if (!is.null(pattern)) {
[17:40:40.657]                           computeRestarts <- base::computeRestarts
[17:40:40.657]                           grepl <- base::grepl
[17:40:40.657]                           restarts <- computeRestarts(cond)
[17:40:40.657]                           for (restart in restarts) {
[17:40:40.657]                             name <- restart$name
[17:40:40.657]                             if (is.null(name)) 
[17:40:40.657]                               next
[17:40:40.657]                             if (!grepl(pattern, name)) 
[17:40:40.657]                               next
[17:40:40.657]                             invokeRestart(restart)
[17:40:40.657]                             muffled <- TRUE
[17:40:40.657]                             break
[17:40:40.657]                           }
[17:40:40.657]                         }
[17:40:40.657]                       }
[17:40:40.657]                       invisible(muffled)
[17:40:40.657]                     }
[17:40:40.657]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.657]                   }
[17:40:40.657]                 }
[17:40:40.657]             }
[17:40:40.657]         }))
[17:40:40.657]     }, error = function(ex) {
[17:40:40.657]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.657]                 ...future.rng), started = ...future.startTime, 
[17:40:40.657]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.657]             version = "1.8"), class = "FutureResult")
[17:40:40.657]     }, finally = {
[17:40:40.657]         if (!identical(...future.workdir, getwd())) 
[17:40:40.657]             setwd(...future.workdir)
[17:40:40.657]         {
[17:40:40.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.657]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.657]             }
[17:40:40.657]             base::options(...future.oldOptions)
[17:40:40.657]             if (.Platform$OS.type == "windows") {
[17:40:40.657]                 old_names <- names(...future.oldEnvVars)
[17:40:40.657]                 envs <- base::Sys.getenv()
[17:40:40.657]                 names <- names(envs)
[17:40:40.657]                 common <- intersect(names, old_names)
[17:40:40.657]                 added <- setdiff(names, old_names)
[17:40:40.657]                 removed <- setdiff(old_names, names)
[17:40:40.657]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.657]                   envs[common]]
[17:40:40.657]                 NAMES <- toupper(changed)
[17:40:40.657]                 args <- list()
[17:40:40.657]                 for (kk in seq_along(NAMES)) {
[17:40:40.657]                   name <- changed[[kk]]
[17:40:40.657]                   NAME <- NAMES[[kk]]
[17:40:40.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.657]                     next
[17:40:40.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.657]                 }
[17:40:40.657]                 NAMES <- toupper(added)
[17:40:40.657]                 for (kk in seq_along(NAMES)) {
[17:40:40.657]                   name <- added[[kk]]
[17:40:40.657]                   NAME <- NAMES[[kk]]
[17:40:40.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.657]                     next
[17:40:40.657]                   args[[name]] <- ""
[17:40:40.657]                 }
[17:40:40.657]                 NAMES <- toupper(removed)
[17:40:40.657]                 for (kk in seq_along(NAMES)) {
[17:40:40.657]                   name <- removed[[kk]]
[17:40:40.657]                   NAME <- NAMES[[kk]]
[17:40:40.657]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.657]                     next
[17:40:40.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.657]                 }
[17:40:40.657]                 if (length(args) > 0) 
[17:40:40.657]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.657]             }
[17:40:40.657]             else {
[17:40:40.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.657]             }
[17:40:40.657]             {
[17:40:40.657]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.657]                   0L) {
[17:40:40.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.657]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.657]                   base::options(opts)
[17:40:40.657]                 }
[17:40:40.657]                 {
[17:40:40.657]                   {
[17:40:40.657]                     NULL
[17:40:40.657]                     RNGkind("Mersenne-Twister")
[17:40:40.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.657]                       inherits = FALSE)
[17:40:40.657]                   }
[17:40:40.657]                   options(future.plan = NULL)
[17:40:40.657]                   if (is.na(NA_character_)) 
[17:40:40.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.657]                     .init = FALSE)
[17:40:40.657]                 }
[17:40:40.657]             }
[17:40:40.657]         }
[17:40:40.657]     })
[17:40:40.657]     if (TRUE) {
[17:40:40.657]         base::sink(type = "output", split = FALSE)
[17:40:40.657]         if (TRUE) {
[17:40:40.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.657]         }
[17:40:40.657]         else {
[17:40:40.657]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.657]         }
[17:40:40.657]         base::close(...future.stdout)
[17:40:40.657]         ...future.stdout <- NULL
[17:40:40.657]     }
[17:40:40.657]     ...future.result$conditions <- ...future.conditions
[17:40:40.657]     ...future.result$finished <- base::Sys.time()
[17:40:40.657]     ...future.result
[17:40:40.657] }
[17:40:40.659] plan(): Setting new future strategy stack:
[17:40:40.659] List of future strategies:
[17:40:40.659] 1. sequential:
[17:40:40.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.659]    - tweaked: FALSE
[17:40:40.659]    - call: NULL
[17:40:40.659] plan(): nbrOfWorkers() = 1
[17:40:40.660] plan(): Setting new future strategy stack:
[17:40:40.660] List of future strategies:
[17:40:40.660] 1. sequential:
[17:40:40.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.660]    - tweaked: FALSE
[17:40:40.660]    - call: plan(strategy)
[17:40:40.661] plan(): nbrOfWorkers() = 1
[17:40:40.661] SequentialFuture started (and completed)
[17:40:40.661] - Launch lazy future ... done
[17:40:40.661] run() for ‘SequentialFuture’ ... done
[17:40:40.662] getGlobalsAndPackages() ...
[17:40:40.662] Searching for globals...
[17:40:40.662] 
[17:40:40.662] Searching for globals ... DONE
[17:40:40.662] - globals: [0] <none>
[17:40:40.662] getGlobalsAndPackages() ... DONE
[17:40:40.662] run() for ‘Future’ ...
[17:40:40.662] - state: ‘created’
[17:40:40.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.663]   - Field: ‘label’
[17:40:40.663]   - Field: ‘local’
[17:40:40.663]   - Field: ‘owner’
[17:40:40.663]   - Field: ‘envir’
[17:40:40.663]   - Field: ‘packages’
[17:40:40.663]   - Field: ‘gc’
[17:40:40.664]   - Field: ‘conditions’
[17:40:40.664]   - Field: ‘expr’
[17:40:40.664]   - Field: ‘uuid’
[17:40:40.664]   - Field: ‘seed’
[17:40:40.664]   - Field: ‘version’
[17:40:40.664]   - Field: ‘result’
[17:40:40.664]   - Field: ‘asynchronous’
[17:40:40.664]   - Field: ‘calls’
[17:40:40.664]   - Field: ‘globals’
[17:40:40.664]   - Field: ‘stdout’
[17:40:40.664]   - Field: ‘earlySignal’
[17:40:40.664]   - Field: ‘lazy’
[17:40:40.665]   - Field: ‘state’
[17:40:40.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.665] - Launch lazy future ...
[17:40:40.665] Packages needed by the future expression (n = 0): <none>
[17:40:40.665] Packages needed by future strategies (n = 0): <none>
[17:40:40.665] {
[17:40:40.665]     {
[17:40:40.665]         {
[17:40:40.665]             ...future.startTime <- base::Sys.time()
[17:40:40.665]             {
[17:40:40.665]                 {
[17:40:40.665]                   {
[17:40:40.665]                     base::local({
[17:40:40.665]                       has_future <- base::requireNamespace("future", 
[17:40:40.665]                         quietly = TRUE)
[17:40:40.665]                       if (has_future) {
[17:40:40.665]                         ns <- base::getNamespace("future")
[17:40:40.665]                         version <- ns[[".package"]][["version"]]
[17:40:40.665]                         if (is.null(version)) 
[17:40:40.665]                           version <- utils::packageVersion("future")
[17:40:40.665]                       }
[17:40:40.665]                       else {
[17:40:40.665]                         version <- NULL
[17:40:40.665]                       }
[17:40:40.665]                       if (!has_future || version < "1.8.0") {
[17:40:40.665]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.665]                           "", base::R.version$version.string), 
[17:40:40.665]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.665]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.665]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.665]                             "release", "version")], collapse = " "), 
[17:40:40.665]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.665]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.665]                           info)
[17:40:40.665]                         info <- base::paste(info, collapse = "; ")
[17:40:40.665]                         if (!has_future) {
[17:40:40.665]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.665]                             info)
[17:40:40.665]                         }
[17:40:40.665]                         else {
[17:40:40.665]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.665]                             info, version)
[17:40:40.665]                         }
[17:40:40.665]                         base::stop(msg)
[17:40:40.665]                       }
[17:40:40.665]                     })
[17:40:40.665]                   }
[17:40:40.665]                   ...future.strategy.old <- future::plan("list")
[17:40:40.665]                   options(future.plan = NULL)
[17:40:40.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.665]                 }
[17:40:40.665]                 ...future.workdir <- getwd()
[17:40:40.665]             }
[17:40:40.665]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.665]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.665]         }
[17:40:40.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.665]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.665]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.665]             base::names(...future.oldOptions))
[17:40:40.665]     }
[17:40:40.665]     if (FALSE) {
[17:40:40.665]     }
[17:40:40.665]     else {
[17:40:40.665]         if (TRUE) {
[17:40:40.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.665]                 open = "w")
[17:40:40.665]         }
[17:40:40.665]         else {
[17:40:40.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.665]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.665]         }
[17:40:40.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.665]             base::sink(type = "output", split = FALSE)
[17:40:40.665]             base::close(...future.stdout)
[17:40:40.665]         }, add = TRUE)
[17:40:40.665]     }
[17:40:40.665]     ...future.frame <- base::sys.nframe()
[17:40:40.665]     ...future.conditions <- base::list()
[17:40:40.665]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.665]     if (FALSE) {
[17:40:40.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.665]     }
[17:40:40.665]     ...future.result <- base::tryCatch({
[17:40:40.665]         base::withCallingHandlers({
[17:40:40.665]             ...future.value <- base::withVisible(base::local(2))
[17:40:40.665]             future::FutureResult(value = ...future.value$value, 
[17:40:40.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.665]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.665]                     ...future.globalenv.names))
[17:40:40.665]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.665]         }, condition = base::local({
[17:40:40.665]             c <- base::c
[17:40:40.665]             inherits <- base::inherits
[17:40:40.665]             invokeRestart <- base::invokeRestart
[17:40:40.665]             length <- base::length
[17:40:40.665]             list <- base::list
[17:40:40.665]             seq.int <- base::seq.int
[17:40:40.665]             signalCondition <- base::signalCondition
[17:40:40.665]             sys.calls <- base::sys.calls
[17:40:40.665]             `[[` <- base::`[[`
[17:40:40.665]             `+` <- base::`+`
[17:40:40.665]             `<<-` <- base::`<<-`
[17:40:40.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.665]                   3L)]
[17:40:40.665]             }
[17:40:40.665]             function(cond) {
[17:40:40.665]                 is_error <- inherits(cond, "error")
[17:40:40.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.665]                   NULL)
[17:40:40.665]                 if (is_error) {
[17:40:40.665]                   sessionInformation <- function() {
[17:40:40.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.665]                       search = base::search(), system = base::Sys.info())
[17:40:40.665]                   }
[17:40:40.665]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.665]                     cond$call), session = sessionInformation(), 
[17:40:40.665]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.665]                   signalCondition(cond)
[17:40:40.665]                 }
[17:40:40.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.665]                 "immediateCondition"))) {
[17:40:40.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.665]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.665]                   if (TRUE && !signal) {
[17:40:40.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.665]                     {
[17:40:40.665]                       inherits <- base::inherits
[17:40:40.665]                       invokeRestart <- base::invokeRestart
[17:40:40.665]                       is.null <- base::is.null
[17:40:40.665]                       muffled <- FALSE
[17:40:40.665]                       if (inherits(cond, "message")) {
[17:40:40.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.665]                         if (muffled) 
[17:40:40.665]                           invokeRestart("muffleMessage")
[17:40:40.665]                       }
[17:40:40.665]                       else if (inherits(cond, "warning")) {
[17:40:40.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.665]                         if (muffled) 
[17:40:40.665]                           invokeRestart("muffleWarning")
[17:40:40.665]                       }
[17:40:40.665]                       else if (inherits(cond, "condition")) {
[17:40:40.665]                         if (!is.null(pattern)) {
[17:40:40.665]                           computeRestarts <- base::computeRestarts
[17:40:40.665]                           grepl <- base::grepl
[17:40:40.665]                           restarts <- computeRestarts(cond)
[17:40:40.665]                           for (restart in restarts) {
[17:40:40.665]                             name <- restart$name
[17:40:40.665]                             if (is.null(name)) 
[17:40:40.665]                               next
[17:40:40.665]                             if (!grepl(pattern, name)) 
[17:40:40.665]                               next
[17:40:40.665]                             invokeRestart(restart)
[17:40:40.665]                             muffled <- TRUE
[17:40:40.665]                             break
[17:40:40.665]                           }
[17:40:40.665]                         }
[17:40:40.665]                       }
[17:40:40.665]                       invisible(muffled)
[17:40:40.665]                     }
[17:40:40.665]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.665]                   }
[17:40:40.665]                 }
[17:40:40.665]                 else {
[17:40:40.665]                   if (TRUE) {
[17:40:40.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.665]                     {
[17:40:40.665]                       inherits <- base::inherits
[17:40:40.665]                       invokeRestart <- base::invokeRestart
[17:40:40.665]                       is.null <- base::is.null
[17:40:40.665]                       muffled <- FALSE
[17:40:40.665]                       if (inherits(cond, "message")) {
[17:40:40.665]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.665]                         if (muffled) 
[17:40:40.665]                           invokeRestart("muffleMessage")
[17:40:40.665]                       }
[17:40:40.665]                       else if (inherits(cond, "warning")) {
[17:40:40.665]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.665]                         if (muffled) 
[17:40:40.665]                           invokeRestart("muffleWarning")
[17:40:40.665]                       }
[17:40:40.665]                       else if (inherits(cond, "condition")) {
[17:40:40.665]                         if (!is.null(pattern)) {
[17:40:40.665]                           computeRestarts <- base::computeRestarts
[17:40:40.665]                           grepl <- base::grepl
[17:40:40.665]                           restarts <- computeRestarts(cond)
[17:40:40.665]                           for (restart in restarts) {
[17:40:40.665]                             name <- restart$name
[17:40:40.665]                             if (is.null(name)) 
[17:40:40.665]                               next
[17:40:40.665]                             if (!grepl(pattern, name)) 
[17:40:40.665]                               next
[17:40:40.665]                             invokeRestart(restart)
[17:40:40.665]                             muffled <- TRUE
[17:40:40.665]                             break
[17:40:40.665]                           }
[17:40:40.665]                         }
[17:40:40.665]                       }
[17:40:40.665]                       invisible(muffled)
[17:40:40.665]                     }
[17:40:40.665]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.665]                   }
[17:40:40.665]                 }
[17:40:40.665]             }
[17:40:40.665]         }))
[17:40:40.665]     }, error = function(ex) {
[17:40:40.665]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.665]                 ...future.rng), started = ...future.startTime, 
[17:40:40.665]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.665]             version = "1.8"), class = "FutureResult")
[17:40:40.665]     }, finally = {
[17:40:40.665]         if (!identical(...future.workdir, getwd())) 
[17:40:40.665]             setwd(...future.workdir)
[17:40:40.665]         {
[17:40:40.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.665]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.665]             }
[17:40:40.665]             base::options(...future.oldOptions)
[17:40:40.665]             if (.Platform$OS.type == "windows") {
[17:40:40.665]                 old_names <- names(...future.oldEnvVars)
[17:40:40.665]                 envs <- base::Sys.getenv()
[17:40:40.665]                 names <- names(envs)
[17:40:40.665]                 common <- intersect(names, old_names)
[17:40:40.665]                 added <- setdiff(names, old_names)
[17:40:40.665]                 removed <- setdiff(old_names, names)
[17:40:40.665]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.665]                   envs[common]]
[17:40:40.665]                 NAMES <- toupper(changed)
[17:40:40.665]                 args <- list()
[17:40:40.665]                 for (kk in seq_along(NAMES)) {
[17:40:40.665]                   name <- changed[[kk]]
[17:40:40.665]                   NAME <- NAMES[[kk]]
[17:40:40.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.665]                     next
[17:40:40.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.665]                 }
[17:40:40.665]                 NAMES <- toupper(added)
[17:40:40.665]                 for (kk in seq_along(NAMES)) {
[17:40:40.665]                   name <- added[[kk]]
[17:40:40.665]                   NAME <- NAMES[[kk]]
[17:40:40.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.665]                     next
[17:40:40.665]                   args[[name]] <- ""
[17:40:40.665]                 }
[17:40:40.665]                 NAMES <- toupper(removed)
[17:40:40.665]                 for (kk in seq_along(NAMES)) {
[17:40:40.665]                   name <- removed[[kk]]
[17:40:40.665]                   NAME <- NAMES[[kk]]
[17:40:40.665]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.665]                     next
[17:40:40.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.665]                 }
[17:40:40.665]                 if (length(args) > 0) 
[17:40:40.665]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.665]             }
[17:40:40.665]             else {
[17:40:40.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.665]             }
[17:40:40.665]             {
[17:40:40.665]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.665]                   0L) {
[17:40:40.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.665]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.665]                   base::options(opts)
[17:40:40.665]                 }
[17:40:40.665]                 {
[17:40:40.665]                   {
[17:40:40.665]                     NULL
[17:40:40.665]                     RNGkind("Mersenne-Twister")
[17:40:40.665]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.665]                       inherits = FALSE)
[17:40:40.665]                   }
[17:40:40.665]                   options(future.plan = NULL)
[17:40:40.665]                   if (is.na(NA_character_)) 
[17:40:40.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.665]                     .init = FALSE)
[17:40:40.665]                 }
[17:40:40.665]             }
[17:40:40.665]         }
[17:40:40.665]     })
[17:40:40.665]     if (TRUE) {
[17:40:40.665]         base::sink(type = "output", split = FALSE)
[17:40:40.665]         if (TRUE) {
[17:40:40.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.665]         }
[17:40:40.665]         else {
[17:40:40.665]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.665]         }
[17:40:40.665]         base::close(...future.stdout)
[17:40:40.665]         ...future.stdout <- NULL
[17:40:40.665]     }
[17:40:40.665]     ...future.result$conditions <- ...future.conditions
[17:40:40.665]     ...future.result$finished <- base::Sys.time()
[17:40:40.665]     ...future.result
[17:40:40.665] }
[17:40:40.667] plan(): Setting new future strategy stack:
[17:40:40.667] List of future strategies:
[17:40:40.667] 1. sequential:
[17:40:40.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.667]    - tweaked: FALSE
[17:40:40.667]    - call: NULL
[17:40:40.668] plan(): nbrOfWorkers() = 1
[17:40:40.668] plan(): Setting new future strategy stack:
[17:40:40.668] List of future strategies:
[17:40:40.668] 1. sequential:
[17:40:40.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.668]    - tweaked: FALSE
[17:40:40.668]    - call: plan(strategy)
[17:40:40.669] plan(): nbrOfWorkers() = 1
[17:40:40.669] SequentialFuture started (and completed)
[17:40:40.669] - Launch lazy future ... done
[17:40:40.669] run() for ‘SequentialFuture’ ... done
[17:40:40.669] resolve() on list ...
[17:40:40.669]  recursive: 0
[17:40:40.670]  length: 3
[17:40:40.670]  elements: ‘a’, ‘b’, ‘’
[17:40:40.670] resolved() for ‘SequentialFuture’ ...
[17:40:40.670] - state: ‘finished’
[17:40:40.670] - run: TRUE
[17:40:40.670] - result: ‘FutureResult’
[17:40:40.670] resolved() for ‘SequentialFuture’ ... done
[17:40:40.670] Future #1
[17:40:40.670]  length: 2 (resolved future 1)
[17:40:40.671] resolved() for ‘SequentialFuture’ ...
[17:40:40.671] - state: ‘finished’
[17:40:40.671] - run: TRUE
[17:40:40.671] - result: ‘FutureResult’
[17:40:40.671] resolved() for ‘SequentialFuture’ ... done
[17:40:40.671] Future #2
[17:40:40.671]  length: 1 (resolved future 2)
[17:40:40.671]  length: 0 (resolved future 3)
[17:40:40.671] resolve() on list ... DONE
[17:40:40.671] resolved() for ‘SequentialFuture’ ...
[17:40:40.672] - state: ‘finished’
[17:40:40.672] - run: TRUE
[17:40:40.672] - result: ‘FutureResult’
[17:40:40.672] resolved() for ‘SequentialFuture’ ... done
[17:40:40.672] resolved() for ‘SequentialFuture’ ...
[17:40:40.672] - state: ‘finished’
[17:40:40.672] - run: TRUE
[17:40:40.672] - result: ‘FutureResult’
[17:40:40.672] resolved() for ‘SequentialFuture’ ... done
[17:40:40.672] getGlobalsAndPackages() ...
[17:40:40.672] Searching for globals...
[17:40:40.673] 
[17:40:40.673] Searching for globals ... DONE
[17:40:40.673] - globals: [0] <none>
[17:40:40.673] getGlobalsAndPackages() ... DONE
[17:40:40.673] getGlobalsAndPackages() ...
[17:40:40.673] Searching for globals...
[17:40:40.674] 
[17:40:40.674] Searching for globals ... DONE
[17:40:40.674] - globals: [0] <none>
[17:40:40.674] getGlobalsAndPackages() ... DONE
[17:40:40.674] run() for ‘Future’ ...
[17:40:40.674] - state: ‘created’
[17:40:40.674] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.675]   - Field: ‘label’
[17:40:40.675]   - Field: ‘local’
[17:40:40.675]   - Field: ‘owner’
[17:40:40.675]   - Field: ‘envir’
[17:40:40.675]   - Field: ‘packages’
[17:40:40.675]   - Field: ‘gc’
[17:40:40.675]   - Field: ‘conditions’
[17:40:40.675]   - Field: ‘expr’
[17:40:40.675]   - Field: ‘uuid’
[17:40:40.675]   - Field: ‘seed’
[17:40:40.676]   - Field: ‘version’
[17:40:40.676]   - Field: ‘result’
[17:40:40.676]   - Field: ‘asynchronous’
[17:40:40.676]   - Field: ‘calls’
[17:40:40.676]   - Field: ‘globals’
[17:40:40.676]   - Field: ‘stdout’
[17:40:40.676]   - Field: ‘earlySignal’
[17:40:40.676]   - Field: ‘lazy’
[17:40:40.676]   - Field: ‘state’
[17:40:40.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.676] - Launch lazy future ...
[17:40:40.677] Packages needed by the future expression (n = 0): <none>
[17:40:40.677] Packages needed by future strategies (n = 0): <none>
[17:40:40.677] {
[17:40:40.677]     {
[17:40:40.677]         {
[17:40:40.677]             ...future.startTime <- base::Sys.time()
[17:40:40.677]             {
[17:40:40.677]                 {
[17:40:40.677]                   {
[17:40:40.677]                     base::local({
[17:40:40.677]                       has_future <- base::requireNamespace("future", 
[17:40:40.677]                         quietly = TRUE)
[17:40:40.677]                       if (has_future) {
[17:40:40.677]                         ns <- base::getNamespace("future")
[17:40:40.677]                         version <- ns[[".package"]][["version"]]
[17:40:40.677]                         if (is.null(version)) 
[17:40:40.677]                           version <- utils::packageVersion("future")
[17:40:40.677]                       }
[17:40:40.677]                       else {
[17:40:40.677]                         version <- NULL
[17:40:40.677]                       }
[17:40:40.677]                       if (!has_future || version < "1.8.0") {
[17:40:40.677]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.677]                           "", base::R.version$version.string), 
[17:40:40.677]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.677]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.677]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.677]                             "release", "version")], collapse = " "), 
[17:40:40.677]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.677]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.677]                           info)
[17:40:40.677]                         info <- base::paste(info, collapse = "; ")
[17:40:40.677]                         if (!has_future) {
[17:40:40.677]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.677]                             info)
[17:40:40.677]                         }
[17:40:40.677]                         else {
[17:40:40.677]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.677]                             info, version)
[17:40:40.677]                         }
[17:40:40.677]                         base::stop(msg)
[17:40:40.677]                       }
[17:40:40.677]                     })
[17:40:40.677]                   }
[17:40:40.677]                   ...future.strategy.old <- future::plan("list")
[17:40:40.677]                   options(future.plan = NULL)
[17:40:40.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.677]                 }
[17:40:40.677]                 ...future.workdir <- getwd()
[17:40:40.677]             }
[17:40:40.677]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.677]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.677]         }
[17:40:40.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.677]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.677]             base::names(...future.oldOptions))
[17:40:40.677]     }
[17:40:40.677]     if (FALSE) {
[17:40:40.677]     }
[17:40:40.677]     else {
[17:40:40.677]         if (TRUE) {
[17:40:40.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.677]                 open = "w")
[17:40:40.677]         }
[17:40:40.677]         else {
[17:40:40.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.677]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.677]         }
[17:40:40.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.677]             base::sink(type = "output", split = FALSE)
[17:40:40.677]             base::close(...future.stdout)
[17:40:40.677]         }, add = TRUE)
[17:40:40.677]     }
[17:40:40.677]     ...future.frame <- base::sys.nframe()
[17:40:40.677]     ...future.conditions <- base::list()
[17:40:40.677]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.677]     if (FALSE) {
[17:40:40.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.677]     }
[17:40:40.677]     ...future.result <- base::tryCatch({
[17:40:40.677]         base::withCallingHandlers({
[17:40:40.677]             ...future.value <- base::withVisible(base::local(2))
[17:40:40.677]             future::FutureResult(value = ...future.value$value, 
[17:40:40.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.677]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.677]                     ...future.globalenv.names))
[17:40:40.677]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.677]         }, condition = base::local({
[17:40:40.677]             c <- base::c
[17:40:40.677]             inherits <- base::inherits
[17:40:40.677]             invokeRestart <- base::invokeRestart
[17:40:40.677]             length <- base::length
[17:40:40.677]             list <- base::list
[17:40:40.677]             seq.int <- base::seq.int
[17:40:40.677]             signalCondition <- base::signalCondition
[17:40:40.677]             sys.calls <- base::sys.calls
[17:40:40.677]             `[[` <- base::`[[`
[17:40:40.677]             `+` <- base::`+`
[17:40:40.677]             `<<-` <- base::`<<-`
[17:40:40.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.677]                   3L)]
[17:40:40.677]             }
[17:40:40.677]             function(cond) {
[17:40:40.677]                 is_error <- inherits(cond, "error")
[17:40:40.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.677]                   NULL)
[17:40:40.677]                 if (is_error) {
[17:40:40.677]                   sessionInformation <- function() {
[17:40:40.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.677]                       search = base::search(), system = base::Sys.info())
[17:40:40.677]                   }
[17:40:40.677]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.677]                     cond$call), session = sessionInformation(), 
[17:40:40.677]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.677]                   signalCondition(cond)
[17:40:40.677]                 }
[17:40:40.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.677]                 "immediateCondition"))) {
[17:40:40.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.677]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.677]                   if (TRUE && !signal) {
[17:40:40.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.677]                     {
[17:40:40.677]                       inherits <- base::inherits
[17:40:40.677]                       invokeRestart <- base::invokeRestart
[17:40:40.677]                       is.null <- base::is.null
[17:40:40.677]                       muffled <- FALSE
[17:40:40.677]                       if (inherits(cond, "message")) {
[17:40:40.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.677]                         if (muffled) 
[17:40:40.677]                           invokeRestart("muffleMessage")
[17:40:40.677]                       }
[17:40:40.677]                       else if (inherits(cond, "warning")) {
[17:40:40.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.677]                         if (muffled) 
[17:40:40.677]                           invokeRestart("muffleWarning")
[17:40:40.677]                       }
[17:40:40.677]                       else if (inherits(cond, "condition")) {
[17:40:40.677]                         if (!is.null(pattern)) {
[17:40:40.677]                           computeRestarts <- base::computeRestarts
[17:40:40.677]                           grepl <- base::grepl
[17:40:40.677]                           restarts <- computeRestarts(cond)
[17:40:40.677]                           for (restart in restarts) {
[17:40:40.677]                             name <- restart$name
[17:40:40.677]                             if (is.null(name)) 
[17:40:40.677]                               next
[17:40:40.677]                             if (!grepl(pattern, name)) 
[17:40:40.677]                               next
[17:40:40.677]                             invokeRestart(restart)
[17:40:40.677]                             muffled <- TRUE
[17:40:40.677]                             break
[17:40:40.677]                           }
[17:40:40.677]                         }
[17:40:40.677]                       }
[17:40:40.677]                       invisible(muffled)
[17:40:40.677]                     }
[17:40:40.677]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.677]                   }
[17:40:40.677]                 }
[17:40:40.677]                 else {
[17:40:40.677]                   if (TRUE) {
[17:40:40.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.677]                     {
[17:40:40.677]                       inherits <- base::inherits
[17:40:40.677]                       invokeRestart <- base::invokeRestart
[17:40:40.677]                       is.null <- base::is.null
[17:40:40.677]                       muffled <- FALSE
[17:40:40.677]                       if (inherits(cond, "message")) {
[17:40:40.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.677]                         if (muffled) 
[17:40:40.677]                           invokeRestart("muffleMessage")
[17:40:40.677]                       }
[17:40:40.677]                       else if (inherits(cond, "warning")) {
[17:40:40.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.677]                         if (muffled) 
[17:40:40.677]                           invokeRestart("muffleWarning")
[17:40:40.677]                       }
[17:40:40.677]                       else if (inherits(cond, "condition")) {
[17:40:40.677]                         if (!is.null(pattern)) {
[17:40:40.677]                           computeRestarts <- base::computeRestarts
[17:40:40.677]                           grepl <- base::grepl
[17:40:40.677]                           restarts <- computeRestarts(cond)
[17:40:40.677]                           for (restart in restarts) {
[17:40:40.677]                             name <- restart$name
[17:40:40.677]                             if (is.null(name)) 
[17:40:40.677]                               next
[17:40:40.677]                             if (!grepl(pattern, name)) 
[17:40:40.677]                               next
[17:40:40.677]                             invokeRestart(restart)
[17:40:40.677]                             muffled <- TRUE
[17:40:40.677]                             break
[17:40:40.677]                           }
[17:40:40.677]                         }
[17:40:40.677]                       }
[17:40:40.677]                       invisible(muffled)
[17:40:40.677]                     }
[17:40:40.677]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.677]                   }
[17:40:40.677]                 }
[17:40:40.677]             }
[17:40:40.677]         }))
[17:40:40.677]     }, error = function(ex) {
[17:40:40.677]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.677]                 ...future.rng), started = ...future.startTime, 
[17:40:40.677]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.677]             version = "1.8"), class = "FutureResult")
[17:40:40.677]     }, finally = {
[17:40:40.677]         if (!identical(...future.workdir, getwd())) 
[17:40:40.677]             setwd(...future.workdir)
[17:40:40.677]         {
[17:40:40.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.677]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.677]             }
[17:40:40.677]             base::options(...future.oldOptions)
[17:40:40.677]             if (.Platform$OS.type == "windows") {
[17:40:40.677]                 old_names <- names(...future.oldEnvVars)
[17:40:40.677]                 envs <- base::Sys.getenv()
[17:40:40.677]                 names <- names(envs)
[17:40:40.677]                 common <- intersect(names, old_names)
[17:40:40.677]                 added <- setdiff(names, old_names)
[17:40:40.677]                 removed <- setdiff(old_names, names)
[17:40:40.677]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.677]                   envs[common]]
[17:40:40.677]                 NAMES <- toupper(changed)
[17:40:40.677]                 args <- list()
[17:40:40.677]                 for (kk in seq_along(NAMES)) {
[17:40:40.677]                   name <- changed[[kk]]
[17:40:40.677]                   NAME <- NAMES[[kk]]
[17:40:40.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.677]                     next
[17:40:40.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.677]                 }
[17:40:40.677]                 NAMES <- toupper(added)
[17:40:40.677]                 for (kk in seq_along(NAMES)) {
[17:40:40.677]                   name <- added[[kk]]
[17:40:40.677]                   NAME <- NAMES[[kk]]
[17:40:40.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.677]                     next
[17:40:40.677]                   args[[name]] <- ""
[17:40:40.677]                 }
[17:40:40.677]                 NAMES <- toupper(removed)
[17:40:40.677]                 for (kk in seq_along(NAMES)) {
[17:40:40.677]                   name <- removed[[kk]]
[17:40:40.677]                   NAME <- NAMES[[kk]]
[17:40:40.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.677]                     next
[17:40:40.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.677]                 }
[17:40:40.677]                 if (length(args) > 0) 
[17:40:40.677]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.677]             }
[17:40:40.677]             else {
[17:40:40.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.677]             }
[17:40:40.677]             {
[17:40:40.677]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.677]                   0L) {
[17:40:40.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.677]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.677]                   base::options(opts)
[17:40:40.677]                 }
[17:40:40.677]                 {
[17:40:40.677]                   {
[17:40:40.677]                     NULL
[17:40:40.677]                     RNGkind("Mersenne-Twister")
[17:40:40.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.677]                       inherits = FALSE)
[17:40:40.677]                   }
[17:40:40.677]                   options(future.plan = NULL)
[17:40:40.677]                   if (is.na(NA_character_)) 
[17:40:40.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.677]                     .init = FALSE)
[17:40:40.677]                 }
[17:40:40.677]             }
[17:40:40.677]         }
[17:40:40.677]     })
[17:40:40.677]     if (TRUE) {
[17:40:40.677]         base::sink(type = "output", split = FALSE)
[17:40:40.677]         if (TRUE) {
[17:40:40.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.677]         }
[17:40:40.677]         else {
[17:40:40.677]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.677]         }
[17:40:40.677]         base::close(...future.stdout)
[17:40:40.677]         ...future.stdout <- NULL
[17:40:40.677]     }
[17:40:40.677]     ...future.result$conditions <- ...future.conditions
[17:40:40.677]     ...future.result$finished <- base::Sys.time()
[17:40:40.677]     ...future.result
[17:40:40.677] }
[17:40:40.679] plan(): Setting new future strategy stack:
[17:40:40.679] List of future strategies:
[17:40:40.679] 1. sequential:
[17:40:40.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.679]    - tweaked: FALSE
[17:40:40.679]    - call: NULL
[17:40:40.679] plan(): nbrOfWorkers() = 1
[17:40:40.680] plan(): Setting new future strategy stack:
[17:40:40.680] List of future strategies:
[17:40:40.680] 1. sequential:
[17:40:40.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.680]    - tweaked: FALSE
[17:40:40.680]    - call: plan(strategy)
[17:40:40.681] plan(): nbrOfWorkers() = 1
[17:40:40.681] SequentialFuture started (and completed)
[17:40:40.681] - Launch lazy future ... done
[17:40:40.681] run() for ‘SequentialFuture’ ... done
[17:40:40.681] resolve() on list ...
[17:40:40.681]  recursive: 0
[17:40:40.681]  length: 3
[17:40:40.681]  elements: ‘a’, ‘b’, ‘’
[17:40:40.681] run() for ‘Future’ ...
[17:40:40.681] - state: ‘created’
[17:40:40.682] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.682] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.682]   - Field: ‘label’
[17:40:40.682]   - Field: ‘local’
[17:40:40.682]   - Field: ‘owner’
[17:40:40.682]   - Field: ‘envir’
[17:40:40.682]   - Field: ‘packages’
[17:40:40.682]   - Field: ‘gc’
[17:40:40.683]   - Field: ‘conditions’
[17:40:40.683]   - Field: ‘expr’
[17:40:40.683]   - Field: ‘uuid’
[17:40:40.683]   - Field: ‘seed’
[17:40:40.683]   - Field: ‘version’
[17:40:40.683]   - Field: ‘result’
[17:40:40.683]   - Field: ‘asynchronous’
[17:40:40.683]   - Field: ‘calls’
[17:40:40.683]   - Field: ‘globals’
[17:40:40.683]   - Field: ‘stdout’
[17:40:40.683]   - Field: ‘earlySignal’
[17:40:40.684]   - Field: ‘lazy’
[17:40:40.684]   - Field: ‘state’
[17:40:40.684] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.684] - Launch lazy future ...
[17:40:40.684] Packages needed by the future expression (n = 0): <none>
[17:40:40.684] Packages needed by future strategies (n = 0): <none>
[17:40:40.684] {
[17:40:40.684]     {
[17:40:40.684]         {
[17:40:40.684]             ...future.startTime <- base::Sys.time()
[17:40:40.684]             {
[17:40:40.684]                 {
[17:40:40.684]                   {
[17:40:40.684]                     base::local({
[17:40:40.684]                       has_future <- base::requireNamespace("future", 
[17:40:40.684]                         quietly = TRUE)
[17:40:40.684]                       if (has_future) {
[17:40:40.684]                         ns <- base::getNamespace("future")
[17:40:40.684]                         version <- ns[[".package"]][["version"]]
[17:40:40.684]                         if (is.null(version)) 
[17:40:40.684]                           version <- utils::packageVersion("future")
[17:40:40.684]                       }
[17:40:40.684]                       else {
[17:40:40.684]                         version <- NULL
[17:40:40.684]                       }
[17:40:40.684]                       if (!has_future || version < "1.8.0") {
[17:40:40.684]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.684]                           "", base::R.version$version.string), 
[17:40:40.684]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.684]                             "release", "version")], collapse = " "), 
[17:40:40.684]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.684]                           info)
[17:40:40.684]                         info <- base::paste(info, collapse = "; ")
[17:40:40.684]                         if (!has_future) {
[17:40:40.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.684]                             info)
[17:40:40.684]                         }
[17:40:40.684]                         else {
[17:40:40.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.684]                             info, version)
[17:40:40.684]                         }
[17:40:40.684]                         base::stop(msg)
[17:40:40.684]                       }
[17:40:40.684]                     })
[17:40:40.684]                   }
[17:40:40.684]                   ...future.strategy.old <- future::plan("list")
[17:40:40.684]                   options(future.plan = NULL)
[17:40:40.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.684]                 }
[17:40:40.684]                 ...future.workdir <- getwd()
[17:40:40.684]             }
[17:40:40.684]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.684]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.684]         }
[17:40:40.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.684]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.684]             base::names(...future.oldOptions))
[17:40:40.684]     }
[17:40:40.684]     if (FALSE) {
[17:40:40.684]     }
[17:40:40.684]     else {
[17:40:40.684]         if (TRUE) {
[17:40:40.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.684]                 open = "w")
[17:40:40.684]         }
[17:40:40.684]         else {
[17:40:40.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.684]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.684]         }
[17:40:40.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.684]             base::sink(type = "output", split = FALSE)
[17:40:40.684]             base::close(...future.stdout)
[17:40:40.684]         }, add = TRUE)
[17:40:40.684]     }
[17:40:40.684]     ...future.frame <- base::sys.nframe()
[17:40:40.684]     ...future.conditions <- base::list()
[17:40:40.684]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.684]     if (FALSE) {
[17:40:40.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.684]     }
[17:40:40.684]     ...future.result <- base::tryCatch({
[17:40:40.684]         base::withCallingHandlers({
[17:40:40.684]             ...future.value <- base::withVisible(base::local(1))
[17:40:40.684]             future::FutureResult(value = ...future.value$value, 
[17:40:40.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.684]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.684]                     ...future.globalenv.names))
[17:40:40.684]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.684]         }, condition = base::local({
[17:40:40.684]             c <- base::c
[17:40:40.684]             inherits <- base::inherits
[17:40:40.684]             invokeRestart <- base::invokeRestart
[17:40:40.684]             length <- base::length
[17:40:40.684]             list <- base::list
[17:40:40.684]             seq.int <- base::seq.int
[17:40:40.684]             signalCondition <- base::signalCondition
[17:40:40.684]             sys.calls <- base::sys.calls
[17:40:40.684]             `[[` <- base::`[[`
[17:40:40.684]             `+` <- base::`+`
[17:40:40.684]             `<<-` <- base::`<<-`
[17:40:40.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.684]                   3L)]
[17:40:40.684]             }
[17:40:40.684]             function(cond) {
[17:40:40.684]                 is_error <- inherits(cond, "error")
[17:40:40.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.684]                   NULL)
[17:40:40.684]                 if (is_error) {
[17:40:40.684]                   sessionInformation <- function() {
[17:40:40.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.684]                       search = base::search(), system = base::Sys.info())
[17:40:40.684]                   }
[17:40:40.684]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.684]                     cond$call), session = sessionInformation(), 
[17:40:40.684]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.684]                   signalCondition(cond)
[17:40:40.684]                 }
[17:40:40.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.684]                 "immediateCondition"))) {
[17:40:40.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.684]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.684]                   if (TRUE && !signal) {
[17:40:40.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.684]                     {
[17:40:40.684]                       inherits <- base::inherits
[17:40:40.684]                       invokeRestart <- base::invokeRestart
[17:40:40.684]                       is.null <- base::is.null
[17:40:40.684]                       muffled <- FALSE
[17:40:40.684]                       if (inherits(cond, "message")) {
[17:40:40.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.684]                         if (muffled) 
[17:40:40.684]                           invokeRestart("muffleMessage")
[17:40:40.684]                       }
[17:40:40.684]                       else if (inherits(cond, "warning")) {
[17:40:40.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.684]                         if (muffled) 
[17:40:40.684]                           invokeRestart("muffleWarning")
[17:40:40.684]                       }
[17:40:40.684]                       else if (inherits(cond, "condition")) {
[17:40:40.684]                         if (!is.null(pattern)) {
[17:40:40.684]                           computeRestarts <- base::computeRestarts
[17:40:40.684]                           grepl <- base::grepl
[17:40:40.684]                           restarts <- computeRestarts(cond)
[17:40:40.684]                           for (restart in restarts) {
[17:40:40.684]                             name <- restart$name
[17:40:40.684]                             if (is.null(name)) 
[17:40:40.684]                               next
[17:40:40.684]                             if (!grepl(pattern, name)) 
[17:40:40.684]                               next
[17:40:40.684]                             invokeRestart(restart)
[17:40:40.684]                             muffled <- TRUE
[17:40:40.684]                             break
[17:40:40.684]                           }
[17:40:40.684]                         }
[17:40:40.684]                       }
[17:40:40.684]                       invisible(muffled)
[17:40:40.684]                     }
[17:40:40.684]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.684]                   }
[17:40:40.684]                 }
[17:40:40.684]                 else {
[17:40:40.684]                   if (TRUE) {
[17:40:40.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.684]                     {
[17:40:40.684]                       inherits <- base::inherits
[17:40:40.684]                       invokeRestart <- base::invokeRestart
[17:40:40.684]                       is.null <- base::is.null
[17:40:40.684]                       muffled <- FALSE
[17:40:40.684]                       if (inherits(cond, "message")) {
[17:40:40.684]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.684]                         if (muffled) 
[17:40:40.684]                           invokeRestart("muffleMessage")
[17:40:40.684]                       }
[17:40:40.684]                       else if (inherits(cond, "warning")) {
[17:40:40.684]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.684]                         if (muffled) 
[17:40:40.684]                           invokeRestart("muffleWarning")
[17:40:40.684]                       }
[17:40:40.684]                       else if (inherits(cond, "condition")) {
[17:40:40.684]                         if (!is.null(pattern)) {
[17:40:40.684]                           computeRestarts <- base::computeRestarts
[17:40:40.684]                           grepl <- base::grepl
[17:40:40.684]                           restarts <- computeRestarts(cond)
[17:40:40.684]                           for (restart in restarts) {
[17:40:40.684]                             name <- restart$name
[17:40:40.684]                             if (is.null(name)) 
[17:40:40.684]                               next
[17:40:40.684]                             if (!grepl(pattern, name)) 
[17:40:40.684]                               next
[17:40:40.684]                             invokeRestart(restart)
[17:40:40.684]                             muffled <- TRUE
[17:40:40.684]                             break
[17:40:40.684]                           }
[17:40:40.684]                         }
[17:40:40.684]                       }
[17:40:40.684]                       invisible(muffled)
[17:40:40.684]                     }
[17:40:40.684]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.684]                   }
[17:40:40.684]                 }
[17:40:40.684]             }
[17:40:40.684]         }))
[17:40:40.684]     }, error = function(ex) {
[17:40:40.684]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.684]                 ...future.rng), started = ...future.startTime, 
[17:40:40.684]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.684]             version = "1.8"), class = "FutureResult")
[17:40:40.684]     }, finally = {
[17:40:40.684]         if (!identical(...future.workdir, getwd())) 
[17:40:40.684]             setwd(...future.workdir)
[17:40:40.684]         {
[17:40:40.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.684]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.684]             }
[17:40:40.684]             base::options(...future.oldOptions)
[17:40:40.684]             if (.Platform$OS.type == "windows") {
[17:40:40.684]                 old_names <- names(...future.oldEnvVars)
[17:40:40.684]                 envs <- base::Sys.getenv()
[17:40:40.684]                 names <- names(envs)
[17:40:40.684]                 common <- intersect(names, old_names)
[17:40:40.684]                 added <- setdiff(names, old_names)
[17:40:40.684]                 removed <- setdiff(old_names, names)
[17:40:40.684]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.684]                   envs[common]]
[17:40:40.684]                 NAMES <- toupper(changed)
[17:40:40.684]                 args <- list()
[17:40:40.684]                 for (kk in seq_along(NAMES)) {
[17:40:40.684]                   name <- changed[[kk]]
[17:40:40.684]                   NAME <- NAMES[[kk]]
[17:40:40.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.684]                     next
[17:40:40.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.684]                 }
[17:40:40.684]                 NAMES <- toupper(added)
[17:40:40.684]                 for (kk in seq_along(NAMES)) {
[17:40:40.684]                   name <- added[[kk]]
[17:40:40.684]                   NAME <- NAMES[[kk]]
[17:40:40.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.684]                     next
[17:40:40.684]                   args[[name]] <- ""
[17:40:40.684]                 }
[17:40:40.684]                 NAMES <- toupper(removed)
[17:40:40.684]                 for (kk in seq_along(NAMES)) {
[17:40:40.684]                   name <- removed[[kk]]
[17:40:40.684]                   NAME <- NAMES[[kk]]
[17:40:40.684]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.684]                     next
[17:40:40.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.684]                 }
[17:40:40.684]                 if (length(args) > 0) 
[17:40:40.684]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.684]             }
[17:40:40.684]             else {
[17:40:40.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.684]             }
[17:40:40.684]             {
[17:40:40.684]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.684]                   0L) {
[17:40:40.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.684]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.684]                   base::options(opts)
[17:40:40.684]                 }
[17:40:40.684]                 {
[17:40:40.684]                   {
[17:40:40.684]                     NULL
[17:40:40.684]                     RNGkind("Mersenne-Twister")
[17:40:40.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.684]                       inherits = FALSE)
[17:40:40.684]                   }
[17:40:40.684]                   options(future.plan = NULL)
[17:40:40.684]                   if (is.na(NA_character_)) 
[17:40:40.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.684]                     .init = FALSE)
[17:40:40.684]                 }
[17:40:40.684]             }
[17:40:40.684]         }
[17:40:40.684]     })
[17:40:40.684]     if (TRUE) {
[17:40:40.684]         base::sink(type = "output", split = FALSE)
[17:40:40.684]         if (TRUE) {
[17:40:40.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.684]         }
[17:40:40.684]         else {
[17:40:40.684]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.684]         }
[17:40:40.684]         base::close(...future.stdout)
[17:40:40.684]         ...future.stdout <- NULL
[17:40:40.684]     }
[17:40:40.684]     ...future.result$conditions <- ...future.conditions
[17:40:40.684]     ...future.result$finished <- base::Sys.time()
[17:40:40.684]     ...future.result
[17:40:40.684] }
[17:40:40.686] plan(): Setting new future strategy stack:
[17:40:40.686] List of future strategies:
[17:40:40.686] 1. sequential:
[17:40:40.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.686]    - tweaked: FALSE
[17:40:40.686]    - call: NULL
[17:40:40.689] plan(): nbrOfWorkers() = 1
[17:40:40.689] plan(): Setting new future strategy stack:
[17:40:40.689] List of future strategies:
[17:40:40.689] 1. sequential:
[17:40:40.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.689]    - tweaked: FALSE
[17:40:40.689]    - call: plan(strategy)
[17:40:40.690] plan(): nbrOfWorkers() = 1
[17:40:40.690] SequentialFuture started (and completed)
[17:40:40.690] - Launch lazy future ... done
[17:40:40.690] run() for ‘SequentialFuture’ ... done
[17:40:40.690] resolved() for ‘SequentialFuture’ ...
[17:40:40.690] - state: ‘finished’
[17:40:40.691] - run: TRUE
[17:40:40.691] - result: ‘FutureResult’
[17:40:40.691] resolved() for ‘SequentialFuture’ ... done
[17:40:40.691] Future #1
[17:40:40.691]  length: 2 (resolved future 1)
[17:40:40.691] resolved() for ‘SequentialFuture’ ...
[17:40:40.691] - state: ‘finished’
[17:40:40.691] - run: TRUE
[17:40:40.691] - result: ‘FutureResult’
[17:40:40.691] resolved() for ‘SequentialFuture’ ... done
[17:40:40.692] Future #2
[17:40:40.692]  length: 1 (resolved future 2)
[17:40:40.692]  length: 0 (resolved future 3)
[17:40:40.692] resolve() on list ... DONE
[17:40:40.692] resolved() for ‘SequentialFuture’ ...
[17:40:40.692] - state: ‘finished’
[17:40:40.692] - run: TRUE
[17:40:40.692] - result: ‘FutureResult’
[17:40:40.692] resolved() for ‘SequentialFuture’ ... done
[17:40:40.692] resolved() for ‘SequentialFuture’ ...
[17:40:40.692] - state: ‘finished’
[17:40:40.693] - run: TRUE
[17:40:40.693] - result: ‘FutureResult’
[17:40:40.693] resolved() for ‘SequentialFuture’ ... done
[17:40:40.693] getGlobalsAndPackages() ...
[17:40:40.693] Searching for globals...
[17:40:40.693] 
[17:40:40.693] Searching for globals ... DONE
[17:40:40.693] - globals: [0] <none>
[17:40:40.693] getGlobalsAndPackages() ... DONE
[17:40:40.694] getGlobalsAndPackages() ...
[17:40:40.694] Searching for globals...
[17:40:40.694] 
[17:40:40.694] Searching for globals ... DONE
[17:40:40.694] - globals: [0] <none>
[17:40:40.694] getGlobalsAndPackages() ... DONE
[17:40:40.694] resolve() on list ...
[17:40:40.695]  recursive: 0
[17:40:40.695]  length: 3
[17:40:40.695]  elements: ‘a’, ‘b’, ‘’
[17:40:40.695] run() for ‘Future’ ...
[17:40:40.695] - state: ‘created’
[17:40:40.695] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.695] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.695] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.695]   - Field: ‘label’
[17:40:40.696]   - Field: ‘local’
[17:40:40.696]   - Field: ‘owner’
[17:40:40.696]   - Field: ‘envir’
[17:40:40.696]   - Field: ‘packages’
[17:40:40.696]   - Field: ‘gc’
[17:40:40.696]   - Field: ‘conditions’
[17:40:40.696]   - Field: ‘expr’
[17:40:40.696]   - Field: ‘uuid’
[17:40:40.696]   - Field: ‘seed’
[17:40:40.696]   - Field: ‘version’
[17:40:40.697]   - Field: ‘result’
[17:40:40.697]   - Field: ‘asynchronous’
[17:40:40.697]   - Field: ‘calls’
[17:40:40.697]   - Field: ‘globals’
[17:40:40.697]   - Field: ‘stdout’
[17:40:40.697]   - Field: ‘earlySignal’
[17:40:40.697]   - Field: ‘lazy’
[17:40:40.697]   - Field: ‘state’
[17:40:40.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.697] - Launch lazy future ...
[17:40:40.697] Packages needed by the future expression (n = 0): <none>
[17:40:40.698] Packages needed by future strategies (n = 0): <none>
[17:40:40.698] {
[17:40:40.698]     {
[17:40:40.698]         {
[17:40:40.698]             ...future.startTime <- base::Sys.time()
[17:40:40.698]             {
[17:40:40.698]                 {
[17:40:40.698]                   {
[17:40:40.698]                     base::local({
[17:40:40.698]                       has_future <- base::requireNamespace("future", 
[17:40:40.698]                         quietly = TRUE)
[17:40:40.698]                       if (has_future) {
[17:40:40.698]                         ns <- base::getNamespace("future")
[17:40:40.698]                         version <- ns[[".package"]][["version"]]
[17:40:40.698]                         if (is.null(version)) 
[17:40:40.698]                           version <- utils::packageVersion("future")
[17:40:40.698]                       }
[17:40:40.698]                       else {
[17:40:40.698]                         version <- NULL
[17:40:40.698]                       }
[17:40:40.698]                       if (!has_future || version < "1.8.0") {
[17:40:40.698]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.698]                           "", base::R.version$version.string), 
[17:40:40.698]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.698]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.698]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.698]                             "release", "version")], collapse = " "), 
[17:40:40.698]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.698]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.698]                           info)
[17:40:40.698]                         info <- base::paste(info, collapse = "; ")
[17:40:40.698]                         if (!has_future) {
[17:40:40.698]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.698]                             info)
[17:40:40.698]                         }
[17:40:40.698]                         else {
[17:40:40.698]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.698]                             info, version)
[17:40:40.698]                         }
[17:40:40.698]                         base::stop(msg)
[17:40:40.698]                       }
[17:40:40.698]                     })
[17:40:40.698]                   }
[17:40:40.698]                   ...future.strategy.old <- future::plan("list")
[17:40:40.698]                   options(future.plan = NULL)
[17:40:40.698]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.698]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.698]                 }
[17:40:40.698]                 ...future.workdir <- getwd()
[17:40:40.698]             }
[17:40:40.698]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.698]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.698]         }
[17:40:40.698]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.698]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.698]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.698]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.698]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.698]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.698]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.698]             base::names(...future.oldOptions))
[17:40:40.698]     }
[17:40:40.698]     if (FALSE) {
[17:40:40.698]     }
[17:40:40.698]     else {
[17:40:40.698]         if (TRUE) {
[17:40:40.698]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.698]                 open = "w")
[17:40:40.698]         }
[17:40:40.698]         else {
[17:40:40.698]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.698]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.698]         }
[17:40:40.698]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.698]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.698]             base::sink(type = "output", split = FALSE)
[17:40:40.698]             base::close(...future.stdout)
[17:40:40.698]         }, add = TRUE)
[17:40:40.698]     }
[17:40:40.698]     ...future.frame <- base::sys.nframe()
[17:40:40.698]     ...future.conditions <- base::list()
[17:40:40.698]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.698]     if (FALSE) {
[17:40:40.698]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.698]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.698]     }
[17:40:40.698]     ...future.result <- base::tryCatch({
[17:40:40.698]         base::withCallingHandlers({
[17:40:40.698]             ...future.value <- base::withVisible(base::local(1))
[17:40:40.698]             future::FutureResult(value = ...future.value$value, 
[17:40:40.698]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.698]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.698]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.698]                     ...future.globalenv.names))
[17:40:40.698]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.698]         }, condition = base::local({
[17:40:40.698]             c <- base::c
[17:40:40.698]             inherits <- base::inherits
[17:40:40.698]             invokeRestart <- base::invokeRestart
[17:40:40.698]             length <- base::length
[17:40:40.698]             list <- base::list
[17:40:40.698]             seq.int <- base::seq.int
[17:40:40.698]             signalCondition <- base::signalCondition
[17:40:40.698]             sys.calls <- base::sys.calls
[17:40:40.698]             `[[` <- base::`[[`
[17:40:40.698]             `+` <- base::`+`
[17:40:40.698]             `<<-` <- base::`<<-`
[17:40:40.698]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.698]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.698]                   3L)]
[17:40:40.698]             }
[17:40:40.698]             function(cond) {
[17:40:40.698]                 is_error <- inherits(cond, "error")
[17:40:40.698]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.698]                   NULL)
[17:40:40.698]                 if (is_error) {
[17:40:40.698]                   sessionInformation <- function() {
[17:40:40.698]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.698]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.698]                       search = base::search(), system = base::Sys.info())
[17:40:40.698]                   }
[17:40:40.698]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.698]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.698]                     cond$call), session = sessionInformation(), 
[17:40:40.698]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.698]                   signalCondition(cond)
[17:40:40.698]                 }
[17:40:40.698]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.698]                 "immediateCondition"))) {
[17:40:40.698]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.698]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.698]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.698]                   if (TRUE && !signal) {
[17:40:40.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.698]                     {
[17:40:40.698]                       inherits <- base::inherits
[17:40:40.698]                       invokeRestart <- base::invokeRestart
[17:40:40.698]                       is.null <- base::is.null
[17:40:40.698]                       muffled <- FALSE
[17:40:40.698]                       if (inherits(cond, "message")) {
[17:40:40.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.698]                         if (muffled) 
[17:40:40.698]                           invokeRestart("muffleMessage")
[17:40:40.698]                       }
[17:40:40.698]                       else if (inherits(cond, "warning")) {
[17:40:40.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.698]                         if (muffled) 
[17:40:40.698]                           invokeRestart("muffleWarning")
[17:40:40.698]                       }
[17:40:40.698]                       else if (inherits(cond, "condition")) {
[17:40:40.698]                         if (!is.null(pattern)) {
[17:40:40.698]                           computeRestarts <- base::computeRestarts
[17:40:40.698]                           grepl <- base::grepl
[17:40:40.698]                           restarts <- computeRestarts(cond)
[17:40:40.698]                           for (restart in restarts) {
[17:40:40.698]                             name <- restart$name
[17:40:40.698]                             if (is.null(name)) 
[17:40:40.698]                               next
[17:40:40.698]                             if (!grepl(pattern, name)) 
[17:40:40.698]                               next
[17:40:40.698]                             invokeRestart(restart)
[17:40:40.698]                             muffled <- TRUE
[17:40:40.698]                             break
[17:40:40.698]                           }
[17:40:40.698]                         }
[17:40:40.698]                       }
[17:40:40.698]                       invisible(muffled)
[17:40:40.698]                     }
[17:40:40.698]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.698]                   }
[17:40:40.698]                 }
[17:40:40.698]                 else {
[17:40:40.698]                   if (TRUE) {
[17:40:40.698]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.698]                     {
[17:40:40.698]                       inherits <- base::inherits
[17:40:40.698]                       invokeRestart <- base::invokeRestart
[17:40:40.698]                       is.null <- base::is.null
[17:40:40.698]                       muffled <- FALSE
[17:40:40.698]                       if (inherits(cond, "message")) {
[17:40:40.698]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.698]                         if (muffled) 
[17:40:40.698]                           invokeRestart("muffleMessage")
[17:40:40.698]                       }
[17:40:40.698]                       else if (inherits(cond, "warning")) {
[17:40:40.698]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.698]                         if (muffled) 
[17:40:40.698]                           invokeRestart("muffleWarning")
[17:40:40.698]                       }
[17:40:40.698]                       else if (inherits(cond, "condition")) {
[17:40:40.698]                         if (!is.null(pattern)) {
[17:40:40.698]                           computeRestarts <- base::computeRestarts
[17:40:40.698]                           grepl <- base::grepl
[17:40:40.698]                           restarts <- computeRestarts(cond)
[17:40:40.698]                           for (restart in restarts) {
[17:40:40.698]                             name <- restart$name
[17:40:40.698]                             if (is.null(name)) 
[17:40:40.698]                               next
[17:40:40.698]                             if (!grepl(pattern, name)) 
[17:40:40.698]                               next
[17:40:40.698]                             invokeRestart(restart)
[17:40:40.698]                             muffled <- TRUE
[17:40:40.698]                             break
[17:40:40.698]                           }
[17:40:40.698]                         }
[17:40:40.698]                       }
[17:40:40.698]                       invisible(muffled)
[17:40:40.698]                     }
[17:40:40.698]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.698]                   }
[17:40:40.698]                 }
[17:40:40.698]             }
[17:40:40.698]         }))
[17:40:40.698]     }, error = function(ex) {
[17:40:40.698]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.698]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.698]                 ...future.rng), started = ...future.startTime, 
[17:40:40.698]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.698]             version = "1.8"), class = "FutureResult")
[17:40:40.698]     }, finally = {
[17:40:40.698]         if (!identical(...future.workdir, getwd())) 
[17:40:40.698]             setwd(...future.workdir)
[17:40:40.698]         {
[17:40:40.698]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.698]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.698]             }
[17:40:40.698]             base::options(...future.oldOptions)
[17:40:40.698]             if (.Platform$OS.type == "windows") {
[17:40:40.698]                 old_names <- names(...future.oldEnvVars)
[17:40:40.698]                 envs <- base::Sys.getenv()
[17:40:40.698]                 names <- names(envs)
[17:40:40.698]                 common <- intersect(names, old_names)
[17:40:40.698]                 added <- setdiff(names, old_names)
[17:40:40.698]                 removed <- setdiff(old_names, names)
[17:40:40.698]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.698]                   envs[common]]
[17:40:40.698]                 NAMES <- toupper(changed)
[17:40:40.698]                 args <- list()
[17:40:40.698]                 for (kk in seq_along(NAMES)) {
[17:40:40.698]                   name <- changed[[kk]]
[17:40:40.698]                   NAME <- NAMES[[kk]]
[17:40:40.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.698]                     next
[17:40:40.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.698]                 }
[17:40:40.698]                 NAMES <- toupper(added)
[17:40:40.698]                 for (kk in seq_along(NAMES)) {
[17:40:40.698]                   name <- added[[kk]]
[17:40:40.698]                   NAME <- NAMES[[kk]]
[17:40:40.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.698]                     next
[17:40:40.698]                   args[[name]] <- ""
[17:40:40.698]                 }
[17:40:40.698]                 NAMES <- toupper(removed)
[17:40:40.698]                 for (kk in seq_along(NAMES)) {
[17:40:40.698]                   name <- removed[[kk]]
[17:40:40.698]                   NAME <- NAMES[[kk]]
[17:40:40.698]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.698]                     next
[17:40:40.698]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.698]                 }
[17:40:40.698]                 if (length(args) > 0) 
[17:40:40.698]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.698]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.698]             }
[17:40:40.698]             else {
[17:40:40.698]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.698]             }
[17:40:40.698]             {
[17:40:40.698]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.698]                   0L) {
[17:40:40.698]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.698]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.698]                   base::options(opts)
[17:40:40.698]                 }
[17:40:40.698]                 {
[17:40:40.698]                   {
[17:40:40.698]                     NULL
[17:40:40.698]                     RNGkind("Mersenne-Twister")
[17:40:40.698]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.698]                       inherits = FALSE)
[17:40:40.698]                   }
[17:40:40.698]                   options(future.plan = NULL)
[17:40:40.698]                   if (is.na(NA_character_)) 
[17:40:40.698]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.698]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.698]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.698]                     .init = FALSE)
[17:40:40.698]                 }
[17:40:40.698]             }
[17:40:40.698]         }
[17:40:40.698]     })
[17:40:40.698]     if (TRUE) {
[17:40:40.698]         base::sink(type = "output", split = FALSE)
[17:40:40.698]         if (TRUE) {
[17:40:40.698]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.698]         }
[17:40:40.698]         else {
[17:40:40.698]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.698]         }
[17:40:40.698]         base::close(...future.stdout)
[17:40:40.698]         ...future.stdout <- NULL
[17:40:40.698]     }
[17:40:40.698]     ...future.result$conditions <- ...future.conditions
[17:40:40.698]     ...future.result$finished <- base::Sys.time()
[17:40:40.698]     ...future.result
[17:40:40.698] }
[17:40:40.700] plan(): Setting new future strategy stack:
[17:40:40.700] List of future strategies:
[17:40:40.700] 1. sequential:
[17:40:40.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.700]    - tweaked: FALSE
[17:40:40.700]    - call: NULL
[17:40:40.700] plan(): nbrOfWorkers() = 1
[17:40:40.701] plan(): Setting new future strategy stack:
[17:40:40.701] List of future strategies:
[17:40:40.701] 1. sequential:
[17:40:40.701]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.701]    - tweaked: FALSE
[17:40:40.701]    - call: plan(strategy)
[17:40:40.701] plan(): nbrOfWorkers() = 1
[17:40:40.701] SequentialFuture started (and completed)
[17:40:40.702] - Launch lazy future ... done
[17:40:40.702] run() for ‘SequentialFuture’ ... done
[17:40:40.702] resolved() for ‘SequentialFuture’ ...
[17:40:40.702] - state: ‘finished’
[17:40:40.702] - run: TRUE
[17:40:40.702] - result: ‘FutureResult’
[17:40:40.702] resolved() for ‘SequentialFuture’ ... done
[17:40:40.702] Future #1
[17:40:40.702]  length: 2 (resolved future 1)
[17:40:40.702] run() for ‘Future’ ...
[17:40:40.703] - state: ‘created’
[17:40:40.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.703]   - Field: ‘label’
[17:40:40.703]   - Field: ‘local’
[17:40:40.703]   - Field: ‘owner’
[17:40:40.703]   - Field: ‘envir’
[17:40:40.703]   - Field: ‘packages’
[17:40:40.704]   - Field: ‘gc’
[17:40:40.704]   - Field: ‘conditions’
[17:40:40.704]   - Field: ‘expr’
[17:40:40.704]   - Field: ‘uuid’
[17:40:40.704]   - Field: ‘seed’
[17:40:40.704]   - Field: ‘version’
[17:40:40.704]   - Field: ‘result’
[17:40:40.704]   - Field: ‘asynchronous’
[17:40:40.704]   - Field: ‘calls’
[17:40:40.704]   - Field: ‘globals’
[17:40:40.704]   - Field: ‘stdout’
[17:40:40.705]   - Field: ‘earlySignal’
[17:40:40.705]   - Field: ‘lazy’
[17:40:40.705]   - Field: ‘state’
[17:40:40.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.705] - Launch lazy future ...
[17:40:40.705] Packages needed by the future expression (n = 0): <none>
[17:40:40.705] Packages needed by future strategies (n = 0): <none>
[17:40:40.706] {
[17:40:40.706]     {
[17:40:40.706]         {
[17:40:40.706]             ...future.startTime <- base::Sys.time()
[17:40:40.706]             {
[17:40:40.706]                 {
[17:40:40.706]                   {
[17:40:40.706]                     base::local({
[17:40:40.706]                       has_future <- base::requireNamespace("future", 
[17:40:40.706]                         quietly = TRUE)
[17:40:40.706]                       if (has_future) {
[17:40:40.706]                         ns <- base::getNamespace("future")
[17:40:40.706]                         version <- ns[[".package"]][["version"]]
[17:40:40.706]                         if (is.null(version)) 
[17:40:40.706]                           version <- utils::packageVersion("future")
[17:40:40.706]                       }
[17:40:40.706]                       else {
[17:40:40.706]                         version <- NULL
[17:40:40.706]                       }
[17:40:40.706]                       if (!has_future || version < "1.8.0") {
[17:40:40.706]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.706]                           "", base::R.version$version.string), 
[17:40:40.706]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.706]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.706]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.706]                             "release", "version")], collapse = " "), 
[17:40:40.706]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.706]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.706]                           info)
[17:40:40.706]                         info <- base::paste(info, collapse = "; ")
[17:40:40.706]                         if (!has_future) {
[17:40:40.706]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.706]                             info)
[17:40:40.706]                         }
[17:40:40.706]                         else {
[17:40:40.706]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.706]                             info, version)
[17:40:40.706]                         }
[17:40:40.706]                         base::stop(msg)
[17:40:40.706]                       }
[17:40:40.706]                     })
[17:40:40.706]                   }
[17:40:40.706]                   ...future.strategy.old <- future::plan("list")
[17:40:40.706]                   options(future.plan = NULL)
[17:40:40.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.706]                 }
[17:40:40.706]                 ...future.workdir <- getwd()
[17:40:40.706]             }
[17:40:40.706]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.706]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.706]         }
[17:40:40.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.706]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.706]             base::names(...future.oldOptions))
[17:40:40.706]     }
[17:40:40.706]     if (FALSE) {
[17:40:40.706]     }
[17:40:40.706]     else {
[17:40:40.706]         if (TRUE) {
[17:40:40.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.706]                 open = "w")
[17:40:40.706]         }
[17:40:40.706]         else {
[17:40:40.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.706]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.706]         }
[17:40:40.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.706]             base::sink(type = "output", split = FALSE)
[17:40:40.706]             base::close(...future.stdout)
[17:40:40.706]         }, add = TRUE)
[17:40:40.706]     }
[17:40:40.706]     ...future.frame <- base::sys.nframe()
[17:40:40.706]     ...future.conditions <- base::list()
[17:40:40.706]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.706]     if (FALSE) {
[17:40:40.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.706]     }
[17:40:40.706]     ...future.result <- base::tryCatch({
[17:40:40.706]         base::withCallingHandlers({
[17:40:40.706]             ...future.value <- base::withVisible(base::local(2))
[17:40:40.706]             future::FutureResult(value = ...future.value$value, 
[17:40:40.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.706]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.706]                     ...future.globalenv.names))
[17:40:40.706]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.706]         }, condition = base::local({
[17:40:40.706]             c <- base::c
[17:40:40.706]             inherits <- base::inherits
[17:40:40.706]             invokeRestart <- base::invokeRestart
[17:40:40.706]             length <- base::length
[17:40:40.706]             list <- base::list
[17:40:40.706]             seq.int <- base::seq.int
[17:40:40.706]             signalCondition <- base::signalCondition
[17:40:40.706]             sys.calls <- base::sys.calls
[17:40:40.706]             `[[` <- base::`[[`
[17:40:40.706]             `+` <- base::`+`
[17:40:40.706]             `<<-` <- base::`<<-`
[17:40:40.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.706]                   3L)]
[17:40:40.706]             }
[17:40:40.706]             function(cond) {
[17:40:40.706]                 is_error <- inherits(cond, "error")
[17:40:40.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.706]                   NULL)
[17:40:40.706]                 if (is_error) {
[17:40:40.706]                   sessionInformation <- function() {
[17:40:40.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.706]                       search = base::search(), system = base::Sys.info())
[17:40:40.706]                   }
[17:40:40.706]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.706]                     cond$call), session = sessionInformation(), 
[17:40:40.706]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.706]                   signalCondition(cond)
[17:40:40.706]                 }
[17:40:40.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.706]                 "immediateCondition"))) {
[17:40:40.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.706]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.706]                   if (TRUE && !signal) {
[17:40:40.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.706]                     {
[17:40:40.706]                       inherits <- base::inherits
[17:40:40.706]                       invokeRestart <- base::invokeRestart
[17:40:40.706]                       is.null <- base::is.null
[17:40:40.706]                       muffled <- FALSE
[17:40:40.706]                       if (inherits(cond, "message")) {
[17:40:40.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.706]                         if (muffled) 
[17:40:40.706]                           invokeRestart("muffleMessage")
[17:40:40.706]                       }
[17:40:40.706]                       else if (inherits(cond, "warning")) {
[17:40:40.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.706]                         if (muffled) 
[17:40:40.706]                           invokeRestart("muffleWarning")
[17:40:40.706]                       }
[17:40:40.706]                       else if (inherits(cond, "condition")) {
[17:40:40.706]                         if (!is.null(pattern)) {
[17:40:40.706]                           computeRestarts <- base::computeRestarts
[17:40:40.706]                           grepl <- base::grepl
[17:40:40.706]                           restarts <- computeRestarts(cond)
[17:40:40.706]                           for (restart in restarts) {
[17:40:40.706]                             name <- restart$name
[17:40:40.706]                             if (is.null(name)) 
[17:40:40.706]                               next
[17:40:40.706]                             if (!grepl(pattern, name)) 
[17:40:40.706]                               next
[17:40:40.706]                             invokeRestart(restart)
[17:40:40.706]                             muffled <- TRUE
[17:40:40.706]                             break
[17:40:40.706]                           }
[17:40:40.706]                         }
[17:40:40.706]                       }
[17:40:40.706]                       invisible(muffled)
[17:40:40.706]                     }
[17:40:40.706]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.706]                   }
[17:40:40.706]                 }
[17:40:40.706]                 else {
[17:40:40.706]                   if (TRUE) {
[17:40:40.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.706]                     {
[17:40:40.706]                       inherits <- base::inherits
[17:40:40.706]                       invokeRestart <- base::invokeRestart
[17:40:40.706]                       is.null <- base::is.null
[17:40:40.706]                       muffled <- FALSE
[17:40:40.706]                       if (inherits(cond, "message")) {
[17:40:40.706]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.706]                         if (muffled) 
[17:40:40.706]                           invokeRestart("muffleMessage")
[17:40:40.706]                       }
[17:40:40.706]                       else if (inherits(cond, "warning")) {
[17:40:40.706]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.706]                         if (muffled) 
[17:40:40.706]                           invokeRestart("muffleWarning")
[17:40:40.706]                       }
[17:40:40.706]                       else if (inherits(cond, "condition")) {
[17:40:40.706]                         if (!is.null(pattern)) {
[17:40:40.706]                           computeRestarts <- base::computeRestarts
[17:40:40.706]                           grepl <- base::grepl
[17:40:40.706]                           restarts <- computeRestarts(cond)
[17:40:40.706]                           for (restart in restarts) {
[17:40:40.706]                             name <- restart$name
[17:40:40.706]                             if (is.null(name)) 
[17:40:40.706]                               next
[17:40:40.706]                             if (!grepl(pattern, name)) 
[17:40:40.706]                               next
[17:40:40.706]                             invokeRestart(restart)
[17:40:40.706]                             muffled <- TRUE
[17:40:40.706]                             break
[17:40:40.706]                           }
[17:40:40.706]                         }
[17:40:40.706]                       }
[17:40:40.706]                       invisible(muffled)
[17:40:40.706]                     }
[17:40:40.706]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.706]                   }
[17:40:40.706]                 }
[17:40:40.706]             }
[17:40:40.706]         }))
[17:40:40.706]     }, error = function(ex) {
[17:40:40.706]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.706]                 ...future.rng), started = ...future.startTime, 
[17:40:40.706]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.706]             version = "1.8"), class = "FutureResult")
[17:40:40.706]     }, finally = {
[17:40:40.706]         if (!identical(...future.workdir, getwd())) 
[17:40:40.706]             setwd(...future.workdir)
[17:40:40.706]         {
[17:40:40.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.706]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.706]             }
[17:40:40.706]             base::options(...future.oldOptions)
[17:40:40.706]             if (.Platform$OS.type == "windows") {
[17:40:40.706]                 old_names <- names(...future.oldEnvVars)
[17:40:40.706]                 envs <- base::Sys.getenv()
[17:40:40.706]                 names <- names(envs)
[17:40:40.706]                 common <- intersect(names, old_names)
[17:40:40.706]                 added <- setdiff(names, old_names)
[17:40:40.706]                 removed <- setdiff(old_names, names)
[17:40:40.706]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.706]                   envs[common]]
[17:40:40.706]                 NAMES <- toupper(changed)
[17:40:40.706]                 args <- list()
[17:40:40.706]                 for (kk in seq_along(NAMES)) {
[17:40:40.706]                   name <- changed[[kk]]
[17:40:40.706]                   NAME <- NAMES[[kk]]
[17:40:40.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.706]                     next
[17:40:40.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.706]                 }
[17:40:40.706]                 NAMES <- toupper(added)
[17:40:40.706]                 for (kk in seq_along(NAMES)) {
[17:40:40.706]                   name <- added[[kk]]
[17:40:40.706]                   NAME <- NAMES[[kk]]
[17:40:40.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.706]                     next
[17:40:40.706]                   args[[name]] <- ""
[17:40:40.706]                 }
[17:40:40.706]                 NAMES <- toupper(removed)
[17:40:40.706]                 for (kk in seq_along(NAMES)) {
[17:40:40.706]                   name <- removed[[kk]]
[17:40:40.706]                   NAME <- NAMES[[kk]]
[17:40:40.706]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.706]                     next
[17:40:40.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.706]                 }
[17:40:40.706]                 if (length(args) > 0) 
[17:40:40.706]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.706]             }
[17:40:40.706]             else {
[17:40:40.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.706]             }
[17:40:40.706]             {
[17:40:40.706]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.706]                   0L) {
[17:40:40.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.706]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.706]                   base::options(opts)
[17:40:40.706]                 }
[17:40:40.706]                 {
[17:40:40.706]                   {
[17:40:40.706]                     NULL
[17:40:40.706]                     RNGkind("Mersenne-Twister")
[17:40:40.706]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.706]                       inherits = FALSE)
[17:40:40.706]                   }
[17:40:40.706]                   options(future.plan = NULL)
[17:40:40.706]                   if (is.na(NA_character_)) 
[17:40:40.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.706]                     .init = FALSE)
[17:40:40.706]                 }
[17:40:40.706]             }
[17:40:40.706]         }
[17:40:40.706]     })
[17:40:40.706]     if (TRUE) {
[17:40:40.706]         base::sink(type = "output", split = FALSE)
[17:40:40.706]         if (TRUE) {
[17:40:40.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.706]         }
[17:40:40.706]         else {
[17:40:40.706]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.706]         }
[17:40:40.706]         base::close(...future.stdout)
[17:40:40.706]         ...future.stdout <- NULL
[17:40:40.706]     }
[17:40:40.706]     ...future.result$conditions <- ...future.conditions
[17:40:40.706]     ...future.result$finished <- base::Sys.time()
[17:40:40.706]     ...future.result
[17:40:40.706] }
[17:40:40.707] plan(): Setting new future strategy stack:
[17:40:40.707] List of future strategies:
[17:40:40.707] 1. sequential:
[17:40:40.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.707]    - tweaked: FALSE
[17:40:40.707]    - call: NULL
[17:40:40.708] plan(): nbrOfWorkers() = 1
[17:40:40.708] plan(): Setting new future strategy stack:
[17:40:40.709] List of future strategies:
[17:40:40.709] 1. sequential:
[17:40:40.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.709]    - tweaked: FALSE
[17:40:40.709]    - call: plan(strategy)
[17:40:40.709] plan(): nbrOfWorkers() = 1
[17:40:40.709] SequentialFuture started (and completed)
[17:40:40.709] - Launch lazy future ... done
[17:40:40.709] run() for ‘SequentialFuture’ ... done
[17:40:40.709] resolved() for ‘SequentialFuture’ ...
[17:40:40.710] - state: ‘finished’
[17:40:40.710] - run: TRUE
[17:40:40.710] - result: ‘FutureResult’
[17:40:40.710] resolved() for ‘SequentialFuture’ ... done
[17:40:40.710] Future #2
[17:40:40.710]  length: 1 (resolved future 2)
[17:40:40.710]  length: 0 (resolved future 3)
[17:40:40.710] resolve() on list ... DONE
[17:40:40.710] resolved() for ‘SequentialFuture’ ...
[17:40:40.710] - state: ‘finished’
[17:40:40.710] - run: TRUE
[17:40:40.711] - result: ‘FutureResult’
[17:40:40.711] resolved() for ‘SequentialFuture’ ... done
[17:40:40.711] resolved() for ‘SequentialFuture’ ...
[17:40:40.711] - state: ‘finished’
[17:40:40.711] - run: TRUE
[17:40:40.711] - result: ‘FutureResult’
[17:40:40.711] resolved() for ‘SequentialFuture’ ... done
[17:40:40.711] getGlobalsAndPackages() ...
[17:40:40.711] Searching for globals...
[17:40:40.712] 
[17:40:40.712] Searching for globals ... DONE
[17:40:40.712] - globals: [0] <none>
[17:40:40.712] getGlobalsAndPackages() ... DONE
[17:40:40.712] run() for ‘Future’ ...
[17:40:40.712] - state: ‘created’
[17:40:40.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.713] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.713]   - Field: ‘label’
[17:40:40.713]   - Field: ‘local’
[17:40:40.713]   - Field: ‘owner’
[17:40:40.713]   - Field: ‘envir’
[17:40:40.713]   - Field: ‘packages’
[17:40:40.713]   - Field: ‘gc’
[17:40:40.713]   - Field: ‘conditions’
[17:40:40.713]   - Field: ‘expr’
[17:40:40.713]   - Field: ‘uuid’
[17:40:40.714]   - Field: ‘seed’
[17:40:40.714]   - Field: ‘version’
[17:40:40.714]   - Field: ‘result’
[17:40:40.714]   - Field: ‘asynchronous’
[17:40:40.714]   - Field: ‘calls’
[17:40:40.714]   - Field: ‘globals’
[17:40:40.714]   - Field: ‘stdout’
[17:40:40.714]   - Field: ‘earlySignal’
[17:40:40.714]   - Field: ‘lazy’
[17:40:40.714]   - Field: ‘state’
[17:40:40.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.714] - Launch lazy future ...
[17:40:40.715] Packages needed by the future expression (n = 0): <none>
[17:40:40.715] Packages needed by future strategies (n = 0): <none>
[17:40:40.715] {
[17:40:40.715]     {
[17:40:40.715]         {
[17:40:40.715]             ...future.startTime <- base::Sys.time()
[17:40:40.715]             {
[17:40:40.715]                 {
[17:40:40.715]                   {
[17:40:40.715]                     base::local({
[17:40:40.715]                       has_future <- base::requireNamespace("future", 
[17:40:40.715]                         quietly = TRUE)
[17:40:40.715]                       if (has_future) {
[17:40:40.715]                         ns <- base::getNamespace("future")
[17:40:40.715]                         version <- ns[[".package"]][["version"]]
[17:40:40.715]                         if (is.null(version)) 
[17:40:40.715]                           version <- utils::packageVersion("future")
[17:40:40.715]                       }
[17:40:40.715]                       else {
[17:40:40.715]                         version <- NULL
[17:40:40.715]                       }
[17:40:40.715]                       if (!has_future || version < "1.8.0") {
[17:40:40.715]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.715]                           "", base::R.version$version.string), 
[17:40:40.715]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.715]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.715]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.715]                             "release", "version")], collapse = " "), 
[17:40:40.715]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.715]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.715]                           info)
[17:40:40.715]                         info <- base::paste(info, collapse = "; ")
[17:40:40.715]                         if (!has_future) {
[17:40:40.715]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.715]                             info)
[17:40:40.715]                         }
[17:40:40.715]                         else {
[17:40:40.715]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.715]                             info, version)
[17:40:40.715]                         }
[17:40:40.715]                         base::stop(msg)
[17:40:40.715]                       }
[17:40:40.715]                     })
[17:40:40.715]                   }
[17:40:40.715]                   ...future.strategy.old <- future::plan("list")
[17:40:40.715]                   options(future.plan = NULL)
[17:40:40.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.715]                 }
[17:40:40.715]                 ...future.workdir <- getwd()
[17:40:40.715]             }
[17:40:40.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.715]         }
[17:40:40.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.715]             base::names(...future.oldOptions))
[17:40:40.715]     }
[17:40:40.715]     if (FALSE) {
[17:40:40.715]     }
[17:40:40.715]     else {
[17:40:40.715]         if (TRUE) {
[17:40:40.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.715]                 open = "w")
[17:40:40.715]         }
[17:40:40.715]         else {
[17:40:40.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.715]         }
[17:40:40.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.715]             base::sink(type = "output", split = FALSE)
[17:40:40.715]             base::close(...future.stdout)
[17:40:40.715]         }, add = TRUE)
[17:40:40.715]     }
[17:40:40.715]     ...future.frame <- base::sys.nframe()
[17:40:40.715]     ...future.conditions <- base::list()
[17:40:40.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.715]     if (FALSE) {
[17:40:40.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.715]     }
[17:40:40.715]     ...future.result <- base::tryCatch({
[17:40:40.715]         base::withCallingHandlers({
[17:40:40.715]             ...future.value <- base::withVisible(base::local(1))
[17:40:40.715]             future::FutureResult(value = ...future.value$value, 
[17:40:40.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.715]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.715]                     ...future.globalenv.names))
[17:40:40.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.715]         }, condition = base::local({
[17:40:40.715]             c <- base::c
[17:40:40.715]             inherits <- base::inherits
[17:40:40.715]             invokeRestart <- base::invokeRestart
[17:40:40.715]             length <- base::length
[17:40:40.715]             list <- base::list
[17:40:40.715]             seq.int <- base::seq.int
[17:40:40.715]             signalCondition <- base::signalCondition
[17:40:40.715]             sys.calls <- base::sys.calls
[17:40:40.715]             `[[` <- base::`[[`
[17:40:40.715]             `+` <- base::`+`
[17:40:40.715]             `<<-` <- base::`<<-`
[17:40:40.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.715]                   3L)]
[17:40:40.715]             }
[17:40:40.715]             function(cond) {
[17:40:40.715]                 is_error <- inherits(cond, "error")
[17:40:40.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.715]                   NULL)
[17:40:40.715]                 if (is_error) {
[17:40:40.715]                   sessionInformation <- function() {
[17:40:40.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.715]                       search = base::search(), system = base::Sys.info())
[17:40:40.715]                   }
[17:40:40.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.715]                     cond$call), session = sessionInformation(), 
[17:40:40.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.715]                   signalCondition(cond)
[17:40:40.715]                 }
[17:40:40.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.715]                 "immediateCondition"))) {
[17:40:40.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.715]                   if (TRUE && !signal) {
[17:40:40.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.715]                     {
[17:40:40.715]                       inherits <- base::inherits
[17:40:40.715]                       invokeRestart <- base::invokeRestart
[17:40:40.715]                       is.null <- base::is.null
[17:40:40.715]                       muffled <- FALSE
[17:40:40.715]                       if (inherits(cond, "message")) {
[17:40:40.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.715]                         if (muffled) 
[17:40:40.715]                           invokeRestart("muffleMessage")
[17:40:40.715]                       }
[17:40:40.715]                       else if (inherits(cond, "warning")) {
[17:40:40.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.715]                         if (muffled) 
[17:40:40.715]                           invokeRestart("muffleWarning")
[17:40:40.715]                       }
[17:40:40.715]                       else if (inherits(cond, "condition")) {
[17:40:40.715]                         if (!is.null(pattern)) {
[17:40:40.715]                           computeRestarts <- base::computeRestarts
[17:40:40.715]                           grepl <- base::grepl
[17:40:40.715]                           restarts <- computeRestarts(cond)
[17:40:40.715]                           for (restart in restarts) {
[17:40:40.715]                             name <- restart$name
[17:40:40.715]                             if (is.null(name)) 
[17:40:40.715]                               next
[17:40:40.715]                             if (!grepl(pattern, name)) 
[17:40:40.715]                               next
[17:40:40.715]                             invokeRestart(restart)
[17:40:40.715]                             muffled <- TRUE
[17:40:40.715]                             break
[17:40:40.715]                           }
[17:40:40.715]                         }
[17:40:40.715]                       }
[17:40:40.715]                       invisible(muffled)
[17:40:40.715]                     }
[17:40:40.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.715]                   }
[17:40:40.715]                 }
[17:40:40.715]                 else {
[17:40:40.715]                   if (TRUE) {
[17:40:40.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.715]                     {
[17:40:40.715]                       inherits <- base::inherits
[17:40:40.715]                       invokeRestart <- base::invokeRestart
[17:40:40.715]                       is.null <- base::is.null
[17:40:40.715]                       muffled <- FALSE
[17:40:40.715]                       if (inherits(cond, "message")) {
[17:40:40.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.715]                         if (muffled) 
[17:40:40.715]                           invokeRestart("muffleMessage")
[17:40:40.715]                       }
[17:40:40.715]                       else if (inherits(cond, "warning")) {
[17:40:40.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.715]                         if (muffled) 
[17:40:40.715]                           invokeRestart("muffleWarning")
[17:40:40.715]                       }
[17:40:40.715]                       else if (inherits(cond, "condition")) {
[17:40:40.715]                         if (!is.null(pattern)) {
[17:40:40.715]                           computeRestarts <- base::computeRestarts
[17:40:40.715]                           grepl <- base::grepl
[17:40:40.715]                           restarts <- computeRestarts(cond)
[17:40:40.715]                           for (restart in restarts) {
[17:40:40.715]                             name <- restart$name
[17:40:40.715]                             if (is.null(name)) 
[17:40:40.715]                               next
[17:40:40.715]                             if (!grepl(pattern, name)) 
[17:40:40.715]                               next
[17:40:40.715]                             invokeRestart(restart)
[17:40:40.715]                             muffled <- TRUE
[17:40:40.715]                             break
[17:40:40.715]                           }
[17:40:40.715]                         }
[17:40:40.715]                       }
[17:40:40.715]                       invisible(muffled)
[17:40:40.715]                     }
[17:40:40.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.715]                   }
[17:40:40.715]                 }
[17:40:40.715]             }
[17:40:40.715]         }))
[17:40:40.715]     }, error = function(ex) {
[17:40:40.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.715]                 ...future.rng), started = ...future.startTime, 
[17:40:40.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.715]             version = "1.8"), class = "FutureResult")
[17:40:40.715]     }, finally = {
[17:40:40.715]         if (!identical(...future.workdir, getwd())) 
[17:40:40.715]             setwd(...future.workdir)
[17:40:40.715]         {
[17:40:40.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.715]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.715]             }
[17:40:40.715]             base::options(...future.oldOptions)
[17:40:40.715]             if (.Platform$OS.type == "windows") {
[17:40:40.715]                 old_names <- names(...future.oldEnvVars)
[17:40:40.715]                 envs <- base::Sys.getenv()
[17:40:40.715]                 names <- names(envs)
[17:40:40.715]                 common <- intersect(names, old_names)
[17:40:40.715]                 added <- setdiff(names, old_names)
[17:40:40.715]                 removed <- setdiff(old_names, names)
[17:40:40.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.715]                   envs[common]]
[17:40:40.715]                 NAMES <- toupper(changed)
[17:40:40.715]                 args <- list()
[17:40:40.715]                 for (kk in seq_along(NAMES)) {
[17:40:40.715]                   name <- changed[[kk]]
[17:40:40.715]                   NAME <- NAMES[[kk]]
[17:40:40.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.715]                     next
[17:40:40.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.715]                 }
[17:40:40.715]                 NAMES <- toupper(added)
[17:40:40.715]                 for (kk in seq_along(NAMES)) {
[17:40:40.715]                   name <- added[[kk]]
[17:40:40.715]                   NAME <- NAMES[[kk]]
[17:40:40.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.715]                     next
[17:40:40.715]                   args[[name]] <- ""
[17:40:40.715]                 }
[17:40:40.715]                 NAMES <- toupper(removed)
[17:40:40.715]                 for (kk in seq_along(NAMES)) {
[17:40:40.715]                   name <- removed[[kk]]
[17:40:40.715]                   NAME <- NAMES[[kk]]
[17:40:40.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.715]                     next
[17:40:40.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.715]                 }
[17:40:40.715]                 if (length(args) > 0) 
[17:40:40.715]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.715]             }
[17:40:40.715]             else {
[17:40:40.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.715]             }
[17:40:40.715]             {
[17:40:40.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.715]                   0L) {
[17:40:40.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.715]                   base::options(opts)
[17:40:40.715]                 }
[17:40:40.715]                 {
[17:40:40.715]                   {
[17:40:40.715]                     NULL
[17:40:40.715]                     RNGkind("Mersenne-Twister")
[17:40:40.715]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.715]                       inherits = FALSE)
[17:40:40.715]                   }
[17:40:40.715]                   options(future.plan = NULL)
[17:40:40.715]                   if (is.na(NA_character_)) 
[17:40:40.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.715]                     .init = FALSE)
[17:40:40.715]                 }
[17:40:40.715]             }
[17:40:40.715]         }
[17:40:40.715]     })
[17:40:40.715]     if (TRUE) {
[17:40:40.715]         base::sink(type = "output", split = FALSE)
[17:40:40.715]         if (TRUE) {
[17:40:40.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.715]         }
[17:40:40.715]         else {
[17:40:40.715]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.715]         }
[17:40:40.715]         base::close(...future.stdout)
[17:40:40.715]         ...future.stdout <- NULL
[17:40:40.715]     }
[17:40:40.715]     ...future.result$conditions <- ...future.conditions
[17:40:40.715]     ...future.result$finished <- base::Sys.time()
[17:40:40.715]     ...future.result
[17:40:40.715] }
[17:40:40.717] plan(): Setting new future strategy stack:
[17:40:40.717] List of future strategies:
[17:40:40.717] 1. sequential:
[17:40:40.717]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.717]    - tweaked: FALSE
[17:40:40.717]    - call: NULL
[17:40:40.717] plan(): nbrOfWorkers() = 1
[17:40:40.718] plan(): Setting new future strategy stack:
[17:40:40.718] List of future strategies:
[17:40:40.718] 1. sequential:
[17:40:40.718]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.718]    - tweaked: FALSE
[17:40:40.718]    - call: plan(strategy)
[17:40:40.719] plan(): nbrOfWorkers() = 1
[17:40:40.719] SequentialFuture started (and completed)
[17:40:40.719] - Launch lazy future ... done
[17:40:40.719] run() for ‘SequentialFuture’ ... done
[17:40:40.719] getGlobalsAndPackages() ...
[17:40:40.719] Searching for globals...
[17:40:40.725] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:40:40.726] Searching for globals ... DONE
[17:40:40.726] Resolving globals: FALSE
[17:40:40.726] 
[17:40:40.726] 
[17:40:40.726] getGlobalsAndPackages() ... DONE
[17:40:40.727] run() for ‘Future’ ...
[17:40:40.727] - state: ‘created’
[17:40:40.727] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:40.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:40.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:40.727]   - Field: ‘label’
[17:40:40.727]   - Field: ‘local’
[17:40:40.727]   - Field: ‘owner’
[17:40:40.728]   - Field: ‘envir’
[17:40:40.728]   - Field: ‘packages’
[17:40:40.728]   - Field: ‘gc’
[17:40:40.728]   - Field: ‘conditions’
[17:40:40.728]   - Field: ‘expr’
[17:40:40.728]   - Field: ‘uuid’
[17:40:40.728]   - Field: ‘seed’
[17:40:40.728]   - Field: ‘version’
[17:40:40.728]   - Field: ‘result’
[17:40:40.728]   - Field: ‘asynchronous’
[17:40:40.728]   - Field: ‘calls’
[17:40:40.729]   - Field: ‘globals’
[17:40:40.729]   - Field: ‘stdout’
[17:40:40.729]   - Field: ‘earlySignal’
[17:40:40.729]   - Field: ‘lazy’
[17:40:40.729]   - Field: ‘state’
[17:40:40.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:40.729] - Launch lazy future ...
[17:40:40.729] Packages needed by the future expression (n = 0): <none>
[17:40:40.729] Packages needed by future strategies (n = 0): <none>
[17:40:40.730] {
[17:40:40.730]     {
[17:40:40.730]         {
[17:40:40.730]             ...future.startTime <- base::Sys.time()
[17:40:40.730]             {
[17:40:40.730]                 {
[17:40:40.730]                   {
[17:40:40.730]                     base::local({
[17:40:40.730]                       has_future <- base::requireNamespace("future", 
[17:40:40.730]                         quietly = TRUE)
[17:40:40.730]                       if (has_future) {
[17:40:40.730]                         ns <- base::getNamespace("future")
[17:40:40.730]                         version <- ns[[".package"]][["version"]]
[17:40:40.730]                         if (is.null(version)) 
[17:40:40.730]                           version <- utils::packageVersion("future")
[17:40:40.730]                       }
[17:40:40.730]                       else {
[17:40:40.730]                         version <- NULL
[17:40:40.730]                       }
[17:40:40.730]                       if (!has_future || version < "1.8.0") {
[17:40:40.730]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:40.730]                           "", base::R.version$version.string), 
[17:40:40.730]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:40.730]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:40.730]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:40.730]                             "release", "version")], collapse = " "), 
[17:40:40.730]                           hostname = base::Sys.info()[["nodename"]])
[17:40:40.730]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:40.730]                           info)
[17:40:40.730]                         info <- base::paste(info, collapse = "; ")
[17:40:40.730]                         if (!has_future) {
[17:40:40.730]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:40.730]                             info)
[17:40:40.730]                         }
[17:40:40.730]                         else {
[17:40:40.730]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:40.730]                             info, version)
[17:40:40.730]                         }
[17:40:40.730]                         base::stop(msg)
[17:40:40.730]                       }
[17:40:40.730]                     })
[17:40:40.730]                   }
[17:40:40.730]                   ...future.strategy.old <- future::plan("list")
[17:40:40.730]                   options(future.plan = NULL)
[17:40:40.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:40.730]                 }
[17:40:40.730]                 ...future.workdir <- getwd()
[17:40:40.730]             }
[17:40:40.730]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:40.730]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:40.730]         }
[17:40:40.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:40.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:40.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:40.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:40.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:40.730]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:40.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:40.730]             base::names(...future.oldOptions))
[17:40:40.730]     }
[17:40:40.730]     if (FALSE) {
[17:40:40.730]     }
[17:40:40.730]     else {
[17:40:40.730]         if (TRUE) {
[17:40:40.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:40.730]                 open = "w")
[17:40:40.730]         }
[17:40:40.730]         else {
[17:40:40.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:40.730]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:40.730]         }
[17:40:40.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:40.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:40.730]             base::sink(type = "output", split = FALSE)
[17:40:40.730]             base::close(...future.stdout)
[17:40:40.730]         }, add = TRUE)
[17:40:40.730]     }
[17:40:40.730]     ...future.frame <- base::sys.nframe()
[17:40:40.730]     ...future.conditions <- base::list()
[17:40:40.730]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:40.730]     if (FALSE) {
[17:40:40.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:40.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:40.730]     }
[17:40:40.730]     ...future.result <- base::tryCatch({
[17:40:40.730]         base::withCallingHandlers({
[17:40:40.730]             ...future.value <- base::withVisible(base::local({
[17:40:40.730]                 Sys.sleep(0.5)
[17:40:40.730]                 2
[17:40:40.730]             }))
[17:40:40.730]             future::FutureResult(value = ...future.value$value, 
[17:40:40.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.730]                   ...future.rng), globalenv = if (FALSE) 
[17:40:40.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:40.730]                     ...future.globalenv.names))
[17:40:40.730]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:40.730]         }, condition = base::local({
[17:40:40.730]             c <- base::c
[17:40:40.730]             inherits <- base::inherits
[17:40:40.730]             invokeRestart <- base::invokeRestart
[17:40:40.730]             length <- base::length
[17:40:40.730]             list <- base::list
[17:40:40.730]             seq.int <- base::seq.int
[17:40:40.730]             signalCondition <- base::signalCondition
[17:40:40.730]             sys.calls <- base::sys.calls
[17:40:40.730]             `[[` <- base::`[[`
[17:40:40.730]             `+` <- base::`+`
[17:40:40.730]             `<<-` <- base::`<<-`
[17:40:40.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:40.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:40.730]                   3L)]
[17:40:40.730]             }
[17:40:40.730]             function(cond) {
[17:40:40.730]                 is_error <- inherits(cond, "error")
[17:40:40.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:40.730]                   NULL)
[17:40:40.730]                 if (is_error) {
[17:40:40.730]                   sessionInformation <- function() {
[17:40:40.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:40.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:40.730]                       search = base::search(), system = base::Sys.info())
[17:40:40.730]                   }
[17:40:40.730]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:40.730]                     cond$call), session = sessionInformation(), 
[17:40:40.730]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:40.730]                   signalCondition(cond)
[17:40:40.730]                 }
[17:40:40.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:40.730]                 "immediateCondition"))) {
[17:40:40.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:40.730]                   ...future.conditions[[length(...future.conditions) + 
[17:40:40.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:40.730]                   if (TRUE && !signal) {
[17:40:40.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.730]                     {
[17:40:40.730]                       inherits <- base::inherits
[17:40:40.730]                       invokeRestart <- base::invokeRestart
[17:40:40.730]                       is.null <- base::is.null
[17:40:40.730]                       muffled <- FALSE
[17:40:40.730]                       if (inherits(cond, "message")) {
[17:40:40.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.730]                         if (muffled) 
[17:40:40.730]                           invokeRestart("muffleMessage")
[17:40:40.730]                       }
[17:40:40.730]                       else if (inherits(cond, "warning")) {
[17:40:40.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.730]                         if (muffled) 
[17:40:40.730]                           invokeRestart("muffleWarning")
[17:40:40.730]                       }
[17:40:40.730]                       else if (inherits(cond, "condition")) {
[17:40:40.730]                         if (!is.null(pattern)) {
[17:40:40.730]                           computeRestarts <- base::computeRestarts
[17:40:40.730]                           grepl <- base::grepl
[17:40:40.730]                           restarts <- computeRestarts(cond)
[17:40:40.730]                           for (restart in restarts) {
[17:40:40.730]                             name <- restart$name
[17:40:40.730]                             if (is.null(name)) 
[17:40:40.730]                               next
[17:40:40.730]                             if (!grepl(pattern, name)) 
[17:40:40.730]                               next
[17:40:40.730]                             invokeRestart(restart)
[17:40:40.730]                             muffled <- TRUE
[17:40:40.730]                             break
[17:40:40.730]                           }
[17:40:40.730]                         }
[17:40:40.730]                       }
[17:40:40.730]                       invisible(muffled)
[17:40:40.730]                     }
[17:40:40.730]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.730]                   }
[17:40:40.730]                 }
[17:40:40.730]                 else {
[17:40:40.730]                   if (TRUE) {
[17:40:40.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:40.730]                     {
[17:40:40.730]                       inherits <- base::inherits
[17:40:40.730]                       invokeRestart <- base::invokeRestart
[17:40:40.730]                       is.null <- base::is.null
[17:40:40.730]                       muffled <- FALSE
[17:40:40.730]                       if (inherits(cond, "message")) {
[17:40:40.730]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:40.730]                         if (muffled) 
[17:40:40.730]                           invokeRestart("muffleMessage")
[17:40:40.730]                       }
[17:40:40.730]                       else if (inherits(cond, "warning")) {
[17:40:40.730]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:40.730]                         if (muffled) 
[17:40:40.730]                           invokeRestart("muffleWarning")
[17:40:40.730]                       }
[17:40:40.730]                       else if (inherits(cond, "condition")) {
[17:40:40.730]                         if (!is.null(pattern)) {
[17:40:40.730]                           computeRestarts <- base::computeRestarts
[17:40:40.730]                           grepl <- base::grepl
[17:40:40.730]                           restarts <- computeRestarts(cond)
[17:40:40.730]                           for (restart in restarts) {
[17:40:40.730]                             name <- restart$name
[17:40:40.730]                             if (is.null(name)) 
[17:40:40.730]                               next
[17:40:40.730]                             if (!grepl(pattern, name)) 
[17:40:40.730]                               next
[17:40:40.730]                             invokeRestart(restart)
[17:40:40.730]                             muffled <- TRUE
[17:40:40.730]                             break
[17:40:40.730]                           }
[17:40:40.730]                         }
[17:40:40.730]                       }
[17:40:40.730]                       invisible(muffled)
[17:40:40.730]                     }
[17:40:40.730]                     muffleCondition(cond, pattern = "^muffle")
[17:40:40.730]                   }
[17:40:40.730]                 }
[17:40:40.730]             }
[17:40:40.730]         }))
[17:40:40.730]     }, error = function(ex) {
[17:40:40.730]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:40.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:40.730]                 ...future.rng), started = ...future.startTime, 
[17:40:40.730]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:40.730]             version = "1.8"), class = "FutureResult")
[17:40:40.730]     }, finally = {
[17:40:40.730]         if (!identical(...future.workdir, getwd())) 
[17:40:40.730]             setwd(...future.workdir)
[17:40:40.730]         {
[17:40:40.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:40.730]                 ...future.oldOptions$nwarnings <- NULL
[17:40:40.730]             }
[17:40:40.730]             base::options(...future.oldOptions)
[17:40:40.730]             if (.Platform$OS.type == "windows") {
[17:40:40.730]                 old_names <- names(...future.oldEnvVars)
[17:40:40.730]                 envs <- base::Sys.getenv()
[17:40:40.730]                 names <- names(envs)
[17:40:40.730]                 common <- intersect(names, old_names)
[17:40:40.730]                 added <- setdiff(names, old_names)
[17:40:40.730]                 removed <- setdiff(old_names, names)
[17:40:40.730]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:40.730]                   envs[common]]
[17:40:40.730]                 NAMES <- toupper(changed)
[17:40:40.730]                 args <- list()
[17:40:40.730]                 for (kk in seq_along(NAMES)) {
[17:40:40.730]                   name <- changed[[kk]]
[17:40:40.730]                   NAME <- NAMES[[kk]]
[17:40:40.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.730]                     next
[17:40:40.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.730]                 }
[17:40:40.730]                 NAMES <- toupper(added)
[17:40:40.730]                 for (kk in seq_along(NAMES)) {
[17:40:40.730]                   name <- added[[kk]]
[17:40:40.730]                   NAME <- NAMES[[kk]]
[17:40:40.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.730]                     next
[17:40:40.730]                   args[[name]] <- ""
[17:40:40.730]                 }
[17:40:40.730]                 NAMES <- toupper(removed)
[17:40:40.730]                 for (kk in seq_along(NAMES)) {
[17:40:40.730]                   name <- removed[[kk]]
[17:40:40.730]                   NAME <- NAMES[[kk]]
[17:40:40.730]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:40.730]                     next
[17:40:40.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:40.730]                 }
[17:40:40.730]                 if (length(args) > 0) 
[17:40:40.730]                   base::do.call(base::Sys.setenv, args = args)
[17:40:40.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:40.730]             }
[17:40:40.730]             else {
[17:40:40.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:40.730]             }
[17:40:40.730]             {
[17:40:40.730]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:40.730]                   0L) {
[17:40:40.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:40.730]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:40.730]                   base::options(opts)
[17:40:40.730]                 }
[17:40:40.730]                 {
[17:40:40.730]                   {
[17:40:40.730]                     NULL
[17:40:40.730]                     RNGkind("Mersenne-Twister")
[17:40:40.730]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:40.730]                       inherits = FALSE)
[17:40:40.730]                   }
[17:40:40.730]                   options(future.plan = NULL)
[17:40:40.730]                   if (is.na(NA_character_)) 
[17:40:40.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:40.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:40.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:40.730]                     .init = FALSE)
[17:40:40.730]                 }
[17:40:40.730]             }
[17:40:40.730]         }
[17:40:40.730]     })
[17:40:40.730]     if (TRUE) {
[17:40:40.730]         base::sink(type = "output", split = FALSE)
[17:40:40.730]         if (TRUE) {
[17:40:40.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:40.730]         }
[17:40:40.730]         else {
[17:40:40.730]             ...future.result["stdout"] <- base::list(NULL)
[17:40:40.730]         }
[17:40:40.730]         base::close(...future.stdout)
[17:40:40.730]         ...future.stdout <- NULL
[17:40:40.730]     }
[17:40:40.730]     ...future.result$conditions <- ...future.conditions
[17:40:40.730]     ...future.result$finished <- base::Sys.time()
[17:40:40.730]     ...future.result
[17:40:40.730] }
[17:40:40.731] plan(): Setting new future strategy stack:
[17:40:40.732] List of future strategies:
[17:40:40.732] 1. sequential:
[17:40:40.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:40.732]    - tweaked: FALSE
[17:40:40.732]    - call: NULL
[17:40:40.732] plan(): nbrOfWorkers() = 1
[17:40:41.234] plan(): Setting new future strategy stack:
[17:40:41.234] List of future strategies:
[17:40:41.234] 1. sequential:
[17:40:41.234]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.234]    - tweaked: FALSE
[17:40:41.234]    - call: plan(strategy)
[17:40:41.234] plan(): nbrOfWorkers() = 1
[17:40:41.235] SequentialFuture started (and completed)
[17:40:41.235] - Launch lazy future ... done
[17:40:41.235] run() for ‘SequentialFuture’ ... done
[17:40:41.235] resolve() on list ...
[17:40:41.235]  recursive: 0
[17:40:41.235]  length: 1
[17:40:41.236] 
[17:40:41.236] resolved() for ‘SequentialFuture’ ...
[17:40:41.236] - state: ‘finished’
[17:40:41.236] - run: TRUE
[17:40:41.236] - result: ‘FutureResult’
[17:40:41.236] resolved() for ‘SequentialFuture’ ... done
[17:40:41.236] Future #1
[17:40:41.236]  length: 0 (resolved future 1)
[17:40:41.236] resolve() on list ... DONE
[17:40:41.236] resolved() for ‘SequentialFuture’ ...
[17:40:41.237] - state: ‘finished’
[17:40:41.237] - run: TRUE
[17:40:41.237] - result: ‘FutureResult’
[17:40:41.237] resolved() for ‘SequentialFuture’ ... done
[17:40:41.237] resolve() on list ...
[17:40:41.237]  recursive: 0
[17:40:41.237]  length: 1
[17:40:41.237] 
[17:40:41.237] resolved() for ‘SequentialFuture’ ...
[17:40:41.237] - state: ‘finished’
[17:40:41.238] - run: TRUE
[17:40:41.238] - result: ‘FutureResult’
[17:40:41.238] resolved() for ‘SequentialFuture’ ... done
[17:40:41.238] Future #1
[17:40:41.238]  length: 0 (resolved future 1)
[17:40:41.238] resolve() on list ... DONE
[17:40:41.238] resolved() for ‘SequentialFuture’ ...
[17:40:41.238] - state: ‘finished’
[17:40:41.238] - run: TRUE
[17:40:41.238] - result: ‘FutureResult’
[17:40:41.238] resolved() for ‘SequentialFuture’ ... done
[17:40:41.239] resolve() on list ...
[17:40:41.239]  recursive: 0
[17:40:41.239]  length: 1
[17:40:41.239] 
[17:40:41.239]  length: 0 (resolved future 1)
[17:40:41.239] resolve() on list ... DONE
[17:40:41.239] resolve() on list ...
[17:40:41.239]  recursive: 0
[17:40:41.239]  length: 4
[17:40:41.239] 
[17:40:41.240] resolved() for ‘SequentialFuture’ ...
[17:40:41.240] - state: ‘finished’
[17:40:41.240] - run: TRUE
[17:40:41.240] - result: ‘FutureResult’
[17:40:41.240] resolved() for ‘SequentialFuture’ ... done
[17:40:41.240] Future #1
[17:40:41.240]  length: 3 (resolved future 1)
[17:40:41.240] resolved() for ‘SequentialFuture’ ...
[17:40:41.240] - state: ‘finished’
[17:40:41.240] - run: TRUE
[17:40:41.240] - result: ‘FutureResult’
[17:40:41.241] resolved() for ‘SequentialFuture’ ... done
[17:40:41.241] Future #2
[17:40:41.241]  length: 2 (resolved future 2)
[17:40:41.241]  length: 1 (resolved future 3)
[17:40:41.241]  length: 0 (resolved future 4)
[17:40:41.241] resolve() on list ... DONE
[17:40:41.241] resolve() on list ...
[17:40:41.241]  recursive: 0
[17:40:41.241]  length: 4
[17:40:41.241] 
[17:40:41.242] resolved() for ‘SequentialFuture’ ...
[17:40:41.242] - state: ‘finished’
[17:40:41.242] - run: TRUE
[17:40:41.242] - result: ‘FutureResult’
[17:40:41.242] resolved() for ‘SequentialFuture’ ... done
[17:40:41.242] Future #1
[17:40:41.242]  length: 3 (resolved future 1)
[17:40:41.242] resolved() for ‘SequentialFuture’ ...
[17:40:41.242] - state: ‘finished’
[17:40:41.242] - run: TRUE
[17:40:41.242] - result: ‘FutureResult’
[17:40:41.243] resolved() for ‘SequentialFuture’ ... done
[17:40:41.243] Future #2
[17:40:41.243]  length: 2 (resolved future 2)
[17:40:41.243]  length: 1 (resolved future 3)
[17:40:41.243]  length: 0 (resolved future 4)
[17:40:41.243] resolve() on list ... DONE
[17:40:41.243] resolve() on list ...
[17:40:41.243]  recursive: 0
[17:40:41.243]  length: 1
[17:40:41.244] 
[17:40:41.244]  length: 0 (resolved future 1)
[17:40:41.244] resolve() on list ... DONE
[17:40:41.244] getGlobalsAndPackages() ...
[17:40:41.244] Searching for globals...
[17:40:41.245] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.245] Searching for globals ... DONE
[17:40:41.245] Resolving globals: FALSE
[17:40:41.246] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.246] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.247] - globals: [1] ‘kk’
[17:40:41.247] 
[17:40:41.247] getGlobalsAndPackages() ... DONE
[17:40:41.247] run() for ‘Future’ ...
[17:40:41.247] - state: ‘created’
[17:40:41.247] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.247] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.248]   - Field: ‘label’
[17:40:41.248]   - Field: ‘local’
[17:40:41.248]   - Field: ‘owner’
[17:40:41.248]   - Field: ‘envir’
[17:40:41.248]   - Field: ‘packages’
[17:40:41.248]   - Field: ‘gc’
[17:40:41.248]   - Field: ‘conditions’
[17:40:41.248]   - Field: ‘expr’
[17:40:41.248]   - Field: ‘uuid’
[17:40:41.249]   - Field: ‘seed’
[17:40:41.249]   - Field: ‘version’
[17:40:41.249]   - Field: ‘result’
[17:40:41.249]   - Field: ‘asynchronous’
[17:40:41.249]   - Field: ‘calls’
[17:40:41.249]   - Field: ‘globals’
[17:40:41.249]   - Field: ‘stdout’
[17:40:41.249]   - Field: ‘earlySignal’
[17:40:41.249]   - Field: ‘lazy’
[17:40:41.249]   - Field: ‘state’
[17:40:41.249] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.249] - Launch lazy future ...
[17:40:41.250] Packages needed by the future expression (n = 0): <none>
[17:40:41.250] Packages needed by future strategies (n = 0): <none>
[17:40:41.250] {
[17:40:41.250]     {
[17:40:41.250]         {
[17:40:41.250]             ...future.startTime <- base::Sys.time()
[17:40:41.250]             {
[17:40:41.250]                 {
[17:40:41.250]                   {
[17:40:41.250]                     base::local({
[17:40:41.250]                       has_future <- base::requireNamespace("future", 
[17:40:41.250]                         quietly = TRUE)
[17:40:41.250]                       if (has_future) {
[17:40:41.250]                         ns <- base::getNamespace("future")
[17:40:41.250]                         version <- ns[[".package"]][["version"]]
[17:40:41.250]                         if (is.null(version)) 
[17:40:41.250]                           version <- utils::packageVersion("future")
[17:40:41.250]                       }
[17:40:41.250]                       else {
[17:40:41.250]                         version <- NULL
[17:40:41.250]                       }
[17:40:41.250]                       if (!has_future || version < "1.8.0") {
[17:40:41.250]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.250]                           "", base::R.version$version.string), 
[17:40:41.250]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.250]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.250]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.250]                             "release", "version")], collapse = " "), 
[17:40:41.250]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.250]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.250]                           info)
[17:40:41.250]                         info <- base::paste(info, collapse = "; ")
[17:40:41.250]                         if (!has_future) {
[17:40:41.250]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.250]                             info)
[17:40:41.250]                         }
[17:40:41.250]                         else {
[17:40:41.250]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.250]                             info, version)
[17:40:41.250]                         }
[17:40:41.250]                         base::stop(msg)
[17:40:41.250]                       }
[17:40:41.250]                     })
[17:40:41.250]                   }
[17:40:41.250]                   ...future.strategy.old <- future::plan("list")
[17:40:41.250]                   options(future.plan = NULL)
[17:40:41.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.250]                 }
[17:40:41.250]                 ...future.workdir <- getwd()
[17:40:41.250]             }
[17:40:41.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.250]         }
[17:40:41.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.250]             base::names(...future.oldOptions))
[17:40:41.250]     }
[17:40:41.250]     if (FALSE) {
[17:40:41.250]     }
[17:40:41.250]     else {
[17:40:41.250]         if (TRUE) {
[17:40:41.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.250]                 open = "w")
[17:40:41.250]         }
[17:40:41.250]         else {
[17:40:41.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.250]         }
[17:40:41.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.250]             base::sink(type = "output", split = FALSE)
[17:40:41.250]             base::close(...future.stdout)
[17:40:41.250]         }, add = TRUE)
[17:40:41.250]     }
[17:40:41.250]     ...future.frame <- base::sys.nframe()
[17:40:41.250]     ...future.conditions <- base::list()
[17:40:41.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.250]     if (FALSE) {
[17:40:41.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.250]     }
[17:40:41.250]     ...future.result <- base::tryCatch({
[17:40:41.250]         base::withCallingHandlers({
[17:40:41.250]             ...future.value <- base::withVisible(base::local({
[17:40:41.250]                 Sys.sleep(0.1)
[17:40:41.250]                 kk
[17:40:41.250]             }))
[17:40:41.250]             future::FutureResult(value = ...future.value$value, 
[17:40:41.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.250]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.250]                     ...future.globalenv.names))
[17:40:41.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.250]         }, condition = base::local({
[17:40:41.250]             c <- base::c
[17:40:41.250]             inherits <- base::inherits
[17:40:41.250]             invokeRestart <- base::invokeRestart
[17:40:41.250]             length <- base::length
[17:40:41.250]             list <- base::list
[17:40:41.250]             seq.int <- base::seq.int
[17:40:41.250]             signalCondition <- base::signalCondition
[17:40:41.250]             sys.calls <- base::sys.calls
[17:40:41.250]             `[[` <- base::`[[`
[17:40:41.250]             `+` <- base::`+`
[17:40:41.250]             `<<-` <- base::`<<-`
[17:40:41.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.250]                   3L)]
[17:40:41.250]             }
[17:40:41.250]             function(cond) {
[17:40:41.250]                 is_error <- inherits(cond, "error")
[17:40:41.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.250]                   NULL)
[17:40:41.250]                 if (is_error) {
[17:40:41.250]                   sessionInformation <- function() {
[17:40:41.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.250]                       search = base::search(), system = base::Sys.info())
[17:40:41.250]                   }
[17:40:41.250]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.250]                     cond$call), session = sessionInformation(), 
[17:40:41.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.250]                   signalCondition(cond)
[17:40:41.250]                 }
[17:40:41.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.250]                 "immediateCondition"))) {
[17:40:41.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.250]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.250]                   if (TRUE && !signal) {
[17:40:41.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.250]                     {
[17:40:41.250]                       inherits <- base::inherits
[17:40:41.250]                       invokeRestart <- base::invokeRestart
[17:40:41.250]                       is.null <- base::is.null
[17:40:41.250]                       muffled <- FALSE
[17:40:41.250]                       if (inherits(cond, "message")) {
[17:40:41.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.250]                         if (muffled) 
[17:40:41.250]                           invokeRestart("muffleMessage")
[17:40:41.250]                       }
[17:40:41.250]                       else if (inherits(cond, "warning")) {
[17:40:41.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.250]                         if (muffled) 
[17:40:41.250]                           invokeRestart("muffleWarning")
[17:40:41.250]                       }
[17:40:41.250]                       else if (inherits(cond, "condition")) {
[17:40:41.250]                         if (!is.null(pattern)) {
[17:40:41.250]                           computeRestarts <- base::computeRestarts
[17:40:41.250]                           grepl <- base::grepl
[17:40:41.250]                           restarts <- computeRestarts(cond)
[17:40:41.250]                           for (restart in restarts) {
[17:40:41.250]                             name <- restart$name
[17:40:41.250]                             if (is.null(name)) 
[17:40:41.250]                               next
[17:40:41.250]                             if (!grepl(pattern, name)) 
[17:40:41.250]                               next
[17:40:41.250]                             invokeRestart(restart)
[17:40:41.250]                             muffled <- TRUE
[17:40:41.250]                             break
[17:40:41.250]                           }
[17:40:41.250]                         }
[17:40:41.250]                       }
[17:40:41.250]                       invisible(muffled)
[17:40:41.250]                     }
[17:40:41.250]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.250]                   }
[17:40:41.250]                 }
[17:40:41.250]                 else {
[17:40:41.250]                   if (TRUE) {
[17:40:41.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.250]                     {
[17:40:41.250]                       inherits <- base::inherits
[17:40:41.250]                       invokeRestart <- base::invokeRestart
[17:40:41.250]                       is.null <- base::is.null
[17:40:41.250]                       muffled <- FALSE
[17:40:41.250]                       if (inherits(cond, "message")) {
[17:40:41.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.250]                         if (muffled) 
[17:40:41.250]                           invokeRestart("muffleMessage")
[17:40:41.250]                       }
[17:40:41.250]                       else if (inherits(cond, "warning")) {
[17:40:41.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.250]                         if (muffled) 
[17:40:41.250]                           invokeRestart("muffleWarning")
[17:40:41.250]                       }
[17:40:41.250]                       else if (inherits(cond, "condition")) {
[17:40:41.250]                         if (!is.null(pattern)) {
[17:40:41.250]                           computeRestarts <- base::computeRestarts
[17:40:41.250]                           grepl <- base::grepl
[17:40:41.250]                           restarts <- computeRestarts(cond)
[17:40:41.250]                           for (restart in restarts) {
[17:40:41.250]                             name <- restart$name
[17:40:41.250]                             if (is.null(name)) 
[17:40:41.250]                               next
[17:40:41.250]                             if (!grepl(pattern, name)) 
[17:40:41.250]                               next
[17:40:41.250]                             invokeRestart(restart)
[17:40:41.250]                             muffled <- TRUE
[17:40:41.250]                             break
[17:40:41.250]                           }
[17:40:41.250]                         }
[17:40:41.250]                       }
[17:40:41.250]                       invisible(muffled)
[17:40:41.250]                     }
[17:40:41.250]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.250]                   }
[17:40:41.250]                 }
[17:40:41.250]             }
[17:40:41.250]         }))
[17:40:41.250]     }, error = function(ex) {
[17:40:41.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.250]                 ...future.rng), started = ...future.startTime, 
[17:40:41.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.250]             version = "1.8"), class = "FutureResult")
[17:40:41.250]     }, finally = {
[17:40:41.250]         if (!identical(...future.workdir, getwd())) 
[17:40:41.250]             setwd(...future.workdir)
[17:40:41.250]         {
[17:40:41.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.250]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.250]             }
[17:40:41.250]             base::options(...future.oldOptions)
[17:40:41.250]             if (.Platform$OS.type == "windows") {
[17:40:41.250]                 old_names <- names(...future.oldEnvVars)
[17:40:41.250]                 envs <- base::Sys.getenv()
[17:40:41.250]                 names <- names(envs)
[17:40:41.250]                 common <- intersect(names, old_names)
[17:40:41.250]                 added <- setdiff(names, old_names)
[17:40:41.250]                 removed <- setdiff(old_names, names)
[17:40:41.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.250]                   envs[common]]
[17:40:41.250]                 NAMES <- toupper(changed)
[17:40:41.250]                 args <- list()
[17:40:41.250]                 for (kk in seq_along(NAMES)) {
[17:40:41.250]                   name <- changed[[kk]]
[17:40:41.250]                   NAME <- NAMES[[kk]]
[17:40:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.250]                     next
[17:40:41.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.250]                 }
[17:40:41.250]                 NAMES <- toupper(added)
[17:40:41.250]                 for (kk in seq_along(NAMES)) {
[17:40:41.250]                   name <- added[[kk]]
[17:40:41.250]                   NAME <- NAMES[[kk]]
[17:40:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.250]                     next
[17:40:41.250]                   args[[name]] <- ""
[17:40:41.250]                 }
[17:40:41.250]                 NAMES <- toupper(removed)
[17:40:41.250]                 for (kk in seq_along(NAMES)) {
[17:40:41.250]                   name <- removed[[kk]]
[17:40:41.250]                   NAME <- NAMES[[kk]]
[17:40:41.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.250]                     next
[17:40:41.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.250]                 }
[17:40:41.250]                 if (length(args) > 0) 
[17:40:41.250]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.250]             }
[17:40:41.250]             else {
[17:40:41.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.250]             }
[17:40:41.250]             {
[17:40:41.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.250]                   0L) {
[17:40:41.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.250]                   base::options(opts)
[17:40:41.250]                 }
[17:40:41.250]                 {
[17:40:41.250]                   {
[17:40:41.250]                     NULL
[17:40:41.250]                     RNGkind("Mersenne-Twister")
[17:40:41.250]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.250]                       inherits = FALSE)
[17:40:41.250]                   }
[17:40:41.250]                   options(future.plan = NULL)
[17:40:41.250]                   if (is.na(NA_character_)) 
[17:40:41.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.250]                     .init = FALSE)
[17:40:41.250]                 }
[17:40:41.250]             }
[17:40:41.250]         }
[17:40:41.250]     })
[17:40:41.250]     if (TRUE) {
[17:40:41.250]         base::sink(type = "output", split = FALSE)
[17:40:41.250]         if (TRUE) {
[17:40:41.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.250]         }
[17:40:41.250]         else {
[17:40:41.250]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.250]         }
[17:40:41.250]         base::close(...future.stdout)
[17:40:41.250]         ...future.stdout <- NULL
[17:40:41.250]     }
[17:40:41.250]     ...future.result$conditions <- ...future.conditions
[17:40:41.250]     ...future.result$finished <- base::Sys.time()
[17:40:41.250]     ...future.result
[17:40:41.250] }
[17:40:41.252] assign_globals() ...
[17:40:41.252] List of 1
[17:40:41.252]  $ kk: int 1
[17:40:41.252]  - attr(*, "where")=List of 1
[17:40:41.252]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.252]  - attr(*, "resolved")= logi FALSE
[17:40:41.252]  - attr(*, "total_size")= num 56
[17:40:41.252]  - attr(*, "already-done")= logi TRUE
[17:40:41.258] - copied ‘kk’ to environment
[17:40:41.259] assign_globals() ... done
[17:40:41.259] plan(): Setting new future strategy stack:
[17:40:41.259] List of future strategies:
[17:40:41.259] 1. sequential:
[17:40:41.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.259]    - tweaked: FALSE
[17:40:41.259]    - call: NULL
[17:40:41.259] plan(): nbrOfWorkers() = 1
[17:40:41.361] plan(): Setting new future strategy stack:
[17:40:41.361] List of future strategies:
[17:40:41.361] 1. sequential:
[17:40:41.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.361]    - tweaked: FALSE
[17:40:41.361]    - call: plan(strategy)
[17:40:41.361] plan(): nbrOfWorkers() = 1
[17:40:41.361] SequentialFuture started (and completed)
[17:40:41.362] - Launch lazy future ... done
[17:40:41.362] run() for ‘SequentialFuture’ ... done
[17:40:41.362] getGlobalsAndPackages() ...
[17:40:41.362] Searching for globals...
[17:40:41.363] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.363] Searching for globals ... DONE
[17:40:41.363] Resolving globals: FALSE
[17:40:41.364] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.364] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.364] - globals: [1] ‘kk’
[17:40:41.364] 
[17:40:41.364] getGlobalsAndPackages() ... DONE
[17:40:41.364] run() for ‘Future’ ...
[17:40:41.365] - state: ‘created’
[17:40:41.365] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.365] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.365]   - Field: ‘label’
[17:40:41.365]   - Field: ‘local’
[17:40:41.365]   - Field: ‘owner’
[17:40:41.365]   - Field: ‘envir’
[17:40:41.366]   - Field: ‘packages’
[17:40:41.366]   - Field: ‘gc’
[17:40:41.366]   - Field: ‘conditions’
[17:40:41.366]   - Field: ‘expr’
[17:40:41.366]   - Field: ‘uuid’
[17:40:41.366]   - Field: ‘seed’
[17:40:41.366]   - Field: ‘version’
[17:40:41.366]   - Field: ‘result’
[17:40:41.366]   - Field: ‘asynchronous’
[17:40:41.366]   - Field: ‘calls’
[17:40:41.366]   - Field: ‘globals’
[17:40:41.367]   - Field: ‘stdout’
[17:40:41.367]   - Field: ‘earlySignal’
[17:40:41.367]   - Field: ‘lazy’
[17:40:41.367]   - Field: ‘state’
[17:40:41.367] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.367] - Launch lazy future ...
[17:40:41.367] Packages needed by the future expression (n = 0): <none>
[17:40:41.367] Packages needed by future strategies (n = 0): <none>
[17:40:41.368] {
[17:40:41.368]     {
[17:40:41.368]         {
[17:40:41.368]             ...future.startTime <- base::Sys.time()
[17:40:41.368]             {
[17:40:41.368]                 {
[17:40:41.368]                   {
[17:40:41.368]                     base::local({
[17:40:41.368]                       has_future <- base::requireNamespace("future", 
[17:40:41.368]                         quietly = TRUE)
[17:40:41.368]                       if (has_future) {
[17:40:41.368]                         ns <- base::getNamespace("future")
[17:40:41.368]                         version <- ns[[".package"]][["version"]]
[17:40:41.368]                         if (is.null(version)) 
[17:40:41.368]                           version <- utils::packageVersion("future")
[17:40:41.368]                       }
[17:40:41.368]                       else {
[17:40:41.368]                         version <- NULL
[17:40:41.368]                       }
[17:40:41.368]                       if (!has_future || version < "1.8.0") {
[17:40:41.368]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.368]                           "", base::R.version$version.string), 
[17:40:41.368]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.368]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.368]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.368]                             "release", "version")], collapse = " "), 
[17:40:41.368]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.368]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.368]                           info)
[17:40:41.368]                         info <- base::paste(info, collapse = "; ")
[17:40:41.368]                         if (!has_future) {
[17:40:41.368]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.368]                             info)
[17:40:41.368]                         }
[17:40:41.368]                         else {
[17:40:41.368]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.368]                             info, version)
[17:40:41.368]                         }
[17:40:41.368]                         base::stop(msg)
[17:40:41.368]                       }
[17:40:41.368]                     })
[17:40:41.368]                   }
[17:40:41.368]                   ...future.strategy.old <- future::plan("list")
[17:40:41.368]                   options(future.plan = NULL)
[17:40:41.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.368]                 }
[17:40:41.368]                 ...future.workdir <- getwd()
[17:40:41.368]             }
[17:40:41.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.368]         }
[17:40:41.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.368]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.368]             base::names(...future.oldOptions))
[17:40:41.368]     }
[17:40:41.368]     if (FALSE) {
[17:40:41.368]     }
[17:40:41.368]     else {
[17:40:41.368]         if (TRUE) {
[17:40:41.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.368]                 open = "w")
[17:40:41.368]         }
[17:40:41.368]         else {
[17:40:41.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.368]         }
[17:40:41.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.368]             base::sink(type = "output", split = FALSE)
[17:40:41.368]             base::close(...future.stdout)
[17:40:41.368]         }, add = TRUE)
[17:40:41.368]     }
[17:40:41.368]     ...future.frame <- base::sys.nframe()
[17:40:41.368]     ...future.conditions <- base::list()
[17:40:41.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.368]     if (FALSE) {
[17:40:41.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.368]     }
[17:40:41.368]     ...future.result <- base::tryCatch({
[17:40:41.368]         base::withCallingHandlers({
[17:40:41.368]             ...future.value <- base::withVisible(base::local({
[17:40:41.368]                 Sys.sleep(0.1)
[17:40:41.368]                 kk
[17:40:41.368]             }))
[17:40:41.368]             future::FutureResult(value = ...future.value$value, 
[17:40:41.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.368]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.368]                     ...future.globalenv.names))
[17:40:41.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.368]         }, condition = base::local({
[17:40:41.368]             c <- base::c
[17:40:41.368]             inherits <- base::inherits
[17:40:41.368]             invokeRestart <- base::invokeRestart
[17:40:41.368]             length <- base::length
[17:40:41.368]             list <- base::list
[17:40:41.368]             seq.int <- base::seq.int
[17:40:41.368]             signalCondition <- base::signalCondition
[17:40:41.368]             sys.calls <- base::sys.calls
[17:40:41.368]             `[[` <- base::`[[`
[17:40:41.368]             `+` <- base::`+`
[17:40:41.368]             `<<-` <- base::`<<-`
[17:40:41.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.368]                   3L)]
[17:40:41.368]             }
[17:40:41.368]             function(cond) {
[17:40:41.368]                 is_error <- inherits(cond, "error")
[17:40:41.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.368]                   NULL)
[17:40:41.368]                 if (is_error) {
[17:40:41.368]                   sessionInformation <- function() {
[17:40:41.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.368]                       search = base::search(), system = base::Sys.info())
[17:40:41.368]                   }
[17:40:41.368]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.368]                     cond$call), session = sessionInformation(), 
[17:40:41.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.368]                   signalCondition(cond)
[17:40:41.368]                 }
[17:40:41.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.368]                 "immediateCondition"))) {
[17:40:41.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.368]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.368]                   if (TRUE && !signal) {
[17:40:41.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.368]                     {
[17:40:41.368]                       inherits <- base::inherits
[17:40:41.368]                       invokeRestart <- base::invokeRestart
[17:40:41.368]                       is.null <- base::is.null
[17:40:41.368]                       muffled <- FALSE
[17:40:41.368]                       if (inherits(cond, "message")) {
[17:40:41.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.368]                         if (muffled) 
[17:40:41.368]                           invokeRestart("muffleMessage")
[17:40:41.368]                       }
[17:40:41.368]                       else if (inherits(cond, "warning")) {
[17:40:41.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.368]                         if (muffled) 
[17:40:41.368]                           invokeRestart("muffleWarning")
[17:40:41.368]                       }
[17:40:41.368]                       else if (inherits(cond, "condition")) {
[17:40:41.368]                         if (!is.null(pattern)) {
[17:40:41.368]                           computeRestarts <- base::computeRestarts
[17:40:41.368]                           grepl <- base::grepl
[17:40:41.368]                           restarts <- computeRestarts(cond)
[17:40:41.368]                           for (restart in restarts) {
[17:40:41.368]                             name <- restart$name
[17:40:41.368]                             if (is.null(name)) 
[17:40:41.368]                               next
[17:40:41.368]                             if (!grepl(pattern, name)) 
[17:40:41.368]                               next
[17:40:41.368]                             invokeRestart(restart)
[17:40:41.368]                             muffled <- TRUE
[17:40:41.368]                             break
[17:40:41.368]                           }
[17:40:41.368]                         }
[17:40:41.368]                       }
[17:40:41.368]                       invisible(muffled)
[17:40:41.368]                     }
[17:40:41.368]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.368]                   }
[17:40:41.368]                 }
[17:40:41.368]                 else {
[17:40:41.368]                   if (TRUE) {
[17:40:41.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.368]                     {
[17:40:41.368]                       inherits <- base::inherits
[17:40:41.368]                       invokeRestart <- base::invokeRestart
[17:40:41.368]                       is.null <- base::is.null
[17:40:41.368]                       muffled <- FALSE
[17:40:41.368]                       if (inherits(cond, "message")) {
[17:40:41.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.368]                         if (muffled) 
[17:40:41.368]                           invokeRestart("muffleMessage")
[17:40:41.368]                       }
[17:40:41.368]                       else if (inherits(cond, "warning")) {
[17:40:41.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.368]                         if (muffled) 
[17:40:41.368]                           invokeRestart("muffleWarning")
[17:40:41.368]                       }
[17:40:41.368]                       else if (inherits(cond, "condition")) {
[17:40:41.368]                         if (!is.null(pattern)) {
[17:40:41.368]                           computeRestarts <- base::computeRestarts
[17:40:41.368]                           grepl <- base::grepl
[17:40:41.368]                           restarts <- computeRestarts(cond)
[17:40:41.368]                           for (restart in restarts) {
[17:40:41.368]                             name <- restart$name
[17:40:41.368]                             if (is.null(name)) 
[17:40:41.368]                               next
[17:40:41.368]                             if (!grepl(pattern, name)) 
[17:40:41.368]                               next
[17:40:41.368]                             invokeRestart(restart)
[17:40:41.368]                             muffled <- TRUE
[17:40:41.368]                             break
[17:40:41.368]                           }
[17:40:41.368]                         }
[17:40:41.368]                       }
[17:40:41.368]                       invisible(muffled)
[17:40:41.368]                     }
[17:40:41.368]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.368]                   }
[17:40:41.368]                 }
[17:40:41.368]             }
[17:40:41.368]         }))
[17:40:41.368]     }, error = function(ex) {
[17:40:41.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.368]                 ...future.rng), started = ...future.startTime, 
[17:40:41.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.368]             version = "1.8"), class = "FutureResult")
[17:40:41.368]     }, finally = {
[17:40:41.368]         if (!identical(...future.workdir, getwd())) 
[17:40:41.368]             setwd(...future.workdir)
[17:40:41.368]         {
[17:40:41.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.368]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.368]             }
[17:40:41.368]             base::options(...future.oldOptions)
[17:40:41.368]             if (.Platform$OS.type == "windows") {
[17:40:41.368]                 old_names <- names(...future.oldEnvVars)
[17:40:41.368]                 envs <- base::Sys.getenv()
[17:40:41.368]                 names <- names(envs)
[17:40:41.368]                 common <- intersect(names, old_names)
[17:40:41.368]                 added <- setdiff(names, old_names)
[17:40:41.368]                 removed <- setdiff(old_names, names)
[17:40:41.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.368]                   envs[common]]
[17:40:41.368]                 NAMES <- toupper(changed)
[17:40:41.368]                 args <- list()
[17:40:41.368]                 for (kk in seq_along(NAMES)) {
[17:40:41.368]                   name <- changed[[kk]]
[17:40:41.368]                   NAME <- NAMES[[kk]]
[17:40:41.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.368]                     next
[17:40:41.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.368]                 }
[17:40:41.368]                 NAMES <- toupper(added)
[17:40:41.368]                 for (kk in seq_along(NAMES)) {
[17:40:41.368]                   name <- added[[kk]]
[17:40:41.368]                   NAME <- NAMES[[kk]]
[17:40:41.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.368]                     next
[17:40:41.368]                   args[[name]] <- ""
[17:40:41.368]                 }
[17:40:41.368]                 NAMES <- toupper(removed)
[17:40:41.368]                 for (kk in seq_along(NAMES)) {
[17:40:41.368]                   name <- removed[[kk]]
[17:40:41.368]                   NAME <- NAMES[[kk]]
[17:40:41.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.368]                     next
[17:40:41.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.368]                 }
[17:40:41.368]                 if (length(args) > 0) 
[17:40:41.368]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.368]             }
[17:40:41.368]             else {
[17:40:41.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.368]             }
[17:40:41.368]             {
[17:40:41.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.368]                   0L) {
[17:40:41.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.368]                   base::options(opts)
[17:40:41.368]                 }
[17:40:41.368]                 {
[17:40:41.368]                   {
[17:40:41.368]                     NULL
[17:40:41.368]                     RNGkind("Mersenne-Twister")
[17:40:41.368]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.368]                       inherits = FALSE)
[17:40:41.368]                   }
[17:40:41.368]                   options(future.plan = NULL)
[17:40:41.368]                   if (is.na(NA_character_)) 
[17:40:41.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.368]                     .init = FALSE)
[17:40:41.368]                 }
[17:40:41.368]             }
[17:40:41.368]         }
[17:40:41.368]     })
[17:40:41.368]     if (TRUE) {
[17:40:41.368]         base::sink(type = "output", split = FALSE)
[17:40:41.368]         if (TRUE) {
[17:40:41.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.368]         }
[17:40:41.368]         else {
[17:40:41.368]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.368]         }
[17:40:41.368]         base::close(...future.stdout)
[17:40:41.368]         ...future.stdout <- NULL
[17:40:41.368]     }
[17:40:41.368]     ...future.result$conditions <- ...future.conditions
[17:40:41.368]     ...future.result$finished <- base::Sys.time()
[17:40:41.368]     ...future.result
[17:40:41.368] }
[17:40:41.369] assign_globals() ...
[17:40:41.369] List of 1
[17:40:41.369]  $ kk: int 2
[17:40:41.369]  - attr(*, "where")=List of 1
[17:40:41.369]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.369]  - attr(*, "resolved")= logi FALSE
[17:40:41.369]  - attr(*, "total_size")= num 56
[17:40:41.369]  - attr(*, "already-done")= logi TRUE
[17:40:41.372] - copied ‘kk’ to environment
[17:40:41.372] assign_globals() ... done
[17:40:41.372] plan(): Setting new future strategy stack:
[17:40:41.372] List of future strategies:
[17:40:41.372] 1. sequential:
[17:40:41.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.372]    - tweaked: FALSE
[17:40:41.372]    - call: NULL
[17:40:41.373] plan(): nbrOfWorkers() = 1
[17:40:41.474] plan(): Setting new future strategy stack:
[17:40:41.474] List of future strategies:
[17:40:41.474] 1. sequential:
[17:40:41.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.474]    - tweaked: FALSE
[17:40:41.474]    - call: plan(strategy)
[17:40:41.475] plan(): nbrOfWorkers() = 1
[17:40:41.475] SequentialFuture started (and completed)
[17:40:41.475] - Launch lazy future ... done
[17:40:41.475] run() for ‘SequentialFuture’ ... done
[17:40:41.475] getGlobalsAndPackages() ...
[17:40:41.475] Searching for globals...
[17:40:41.476] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.476] Searching for globals ... DONE
[17:40:41.476] Resolving globals: FALSE
[17:40:41.477] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.477] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.477] - globals: [1] ‘kk’
[17:40:41.477] 
[17:40:41.478] getGlobalsAndPackages() ... DONE
[17:40:41.478] run() for ‘Future’ ...
[17:40:41.478] - state: ‘created’
[17:40:41.478] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.478] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.478]   - Field: ‘label’
[17:40:41.479]   - Field: ‘local’
[17:40:41.479]   - Field: ‘owner’
[17:40:41.479]   - Field: ‘envir’
[17:40:41.479]   - Field: ‘packages’
[17:40:41.479]   - Field: ‘gc’
[17:40:41.479]   - Field: ‘conditions’
[17:40:41.479]   - Field: ‘expr’
[17:40:41.479]   - Field: ‘uuid’
[17:40:41.479]   - Field: ‘seed’
[17:40:41.479]   - Field: ‘version’
[17:40:41.479]   - Field: ‘result’
[17:40:41.480]   - Field: ‘asynchronous’
[17:40:41.480]   - Field: ‘calls’
[17:40:41.480]   - Field: ‘globals’
[17:40:41.480]   - Field: ‘stdout’
[17:40:41.480]   - Field: ‘earlySignal’
[17:40:41.480]   - Field: ‘lazy’
[17:40:41.480]   - Field: ‘state’
[17:40:41.480] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.480] - Launch lazy future ...
[17:40:41.481] Packages needed by the future expression (n = 0): <none>
[17:40:41.481] Packages needed by future strategies (n = 0): <none>
[17:40:41.481] {
[17:40:41.481]     {
[17:40:41.481]         {
[17:40:41.481]             ...future.startTime <- base::Sys.time()
[17:40:41.481]             {
[17:40:41.481]                 {
[17:40:41.481]                   {
[17:40:41.481]                     base::local({
[17:40:41.481]                       has_future <- base::requireNamespace("future", 
[17:40:41.481]                         quietly = TRUE)
[17:40:41.481]                       if (has_future) {
[17:40:41.481]                         ns <- base::getNamespace("future")
[17:40:41.481]                         version <- ns[[".package"]][["version"]]
[17:40:41.481]                         if (is.null(version)) 
[17:40:41.481]                           version <- utils::packageVersion("future")
[17:40:41.481]                       }
[17:40:41.481]                       else {
[17:40:41.481]                         version <- NULL
[17:40:41.481]                       }
[17:40:41.481]                       if (!has_future || version < "1.8.0") {
[17:40:41.481]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.481]                           "", base::R.version$version.string), 
[17:40:41.481]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.481]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.481]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.481]                             "release", "version")], collapse = " "), 
[17:40:41.481]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.481]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.481]                           info)
[17:40:41.481]                         info <- base::paste(info, collapse = "; ")
[17:40:41.481]                         if (!has_future) {
[17:40:41.481]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.481]                             info)
[17:40:41.481]                         }
[17:40:41.481]                         else {
[17:40:41.481]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.481]                             info, version)
[17:40:41.481]                         }
[17:40:41.481]                         base::stop(msg)
[17:40:41.481]                       }
[17:40:41.481]                     })
[17:40:41.481]                   }
[17:40:41.481]                   ...future.strategy.old <- future::plan("list")
[17:40:41.481]                   options(future.plan = NULL)
[17:40:41.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.481]                 }
[17:40:41.481]                 ...future.workdir <- getwd()
[17:40:41.481]             }
[17:40:41.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.481]         }
[17:40:41.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.481]             base::names(...future.oldOptions))
[17:40:41.481]     }
[17:40:41.481]     if (FALSE) {
[17:40:41.481]     }
[17:40:41.481]     else {
[17:40:41.481]         if (TRUE) {
[17:40:41.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.481]                 open = "w")
[17:40:41.481]         }
[17:40:41.481]         else {
[17:40:41.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.481]         }
[17:40:41.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.481]             base::sink(type = "output", split = FALSE)
[17:40:41.481]             base::close(...future.stdout)
[17:40:41.481]         }, add = TRUE)
[17:40:41.481]     }
[17:40:41.481]     ...future.frame <- base::sys.nframe()
[17:40:41.481]     ...future.conditions <- base::list()
[17:40:41.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.481]     if (FALSE) {
[17:40:41.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.481]     }
[17:40:41.481]     ...future.result <- base::tryCatch({
[17:40:41.481]         base::withCallingHandlers({
[17:40:41.481]             ...future.value <- base::withVisible(base::local({
[17:40:41.481]                 Sys.sleep(0.1)
[17:40:41.481]                 kk
[17:40:41.481]             }))
[17:40:41.481]             future::FutureResult(value = ...future.value$value, 
[17:40:41.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.481]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.481]                     ...future.globalenv.names))
[17:40:41.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.481]         }, condition = base::local({
[17:40:41.481]             c <- base::c
[17:40:41.481]             inherits <- base::inherits
[17:40:41.481]             invokeRestart <- base::invokeRestart
[17:40:41.481]             length <- base::length
[17:40:41.481]             list <- base::list
[17:40:41.481]             seq.int <- base::seq.int
[17:40:41.481]             signalCondition <- base::signalCondition
[17:40:41.481]             sys.calls <- base::sys.calls
[17:40:41.481]             `[[` <- base::`[[`
[17:40:41.481]             `+` <- base::`+`
[17:40:41.481]             `<<-` <- base::`<<-`
[17:40:41.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.481]                   3L)]
[17:40:41.481]             }
[17:40:41.481]             function(cond) {
[17:40:41.481]                 is_error <- inherits(cond, "error")
[17:40:41.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.481]                   NULL)
[17:40:41.481]                 if (is_error) {
[17:40:41.481]                   sessionInformation <- function() {
[17:40:41.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.481]                       search = base::search(), system = base::Sys.info())
[17:40:41.481]                   }
[17:40:41.481]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.481]                     cond$call), session = sessionInformation(), 
[17:40:41.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.481]                   signalCondition(cond)
[17:40:41.481]                 }
[17:40:41.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.481]                 "immediateCondition"))) {
[17:40:41.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.481]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.481]                   if (TRUE && !signal) {
[17:40:41.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.481]                     {
[17:40:41.481]                       inherits <- base::inherits
[17:40:41.481]                       invokeRestart <- base::invokeRestart
[17:40:41.481]                       is.null <- base::is.null
[17:40:41.481]                       muffled <- FALSE
[17:40:41.481]                       if (inherits(cond, "message")) {
[17:40:41.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.481]                         if (muffled) 
[17:40:41.481]                           invokeRestart("muffleMessage")
[17:40:41.481]                       }
[17:40:41.481]                       else if (inherits(cond, "warning")) {
[17:40:41.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.481]                         if (muffled) 
[17:40:41.481]                           invokeRestart("muffleWarning")
[17:40:41.481]                       }
[17:40:41.481]                       else if (inherits(cond, "condition")) {
[17:40:41.481]                         if (!is.null(pattern)) {
[17:40:41.481]                           computeRestarts <- base::computeRestarts
[17:40:41.481]                           grepl <- base::grepl
[17:40:41.481]                           restarts <- computeRestarts(cond)
[17:40:41.481]                           for (restart in restarts) {
[17:40:41.481]                             name <- restart$name
[17:40:41.481]                             if (is.null(name)) 
[17:40:41.481]                               next
[17:40:41.481]                             if (!grepl(pattern, name)) 
[17:40:41.481]                               next
[17:40:41.481]                             invokeRestart(restart)
[17:40:41.481]                             muffled <- TRUE
[17:40:41.481]                             break
[17:40:41.481]                           }
[17:40:41.481]                         }
[17:40:41.481]                       }
[17:40:41.481]                       invisible(muffled)
[17:40:41.481]                     }
[17:40:41.481]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.481]                   }
[17:40:41.481]                 }
[17:40:41.481]                 else {
[17:40:41.481]                   if (TRUE) {
[17:40:41.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.481]                     {
[17:40:41.481]                       inherits <- base::inherits
[17:40:41.481]                       invokeRestart <- base::invokeRestart
[17:40:41.481]                       is.null <- base::is.null
[17:40:41.481]                       muffled <- FALSE
[17:40:41.481]                       if (inherits(cond, "message")) {
[17:40:41.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.481]                         if (muffled) 
[17:40:41.481]                           invokeRestart("muffleMessage")
[17:40:41.481]                       }
[17:40:41.481]                       else if (inherits(cond, "warning")) {
[17:40:41.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.481]                         if (muffled) 
[17:40:41.481]                           invokeRestart("muffleWarning")
[17:40:41.481]                       }
[17:40:41.481]                       else if (inherits(cond, "condition")) {
[17:40:41.481]                         if (!is.null(pattern)) {
[17:40:41.481]                           computeRestarts <- base::computeRestarts
[17:40:41.481]                           grepl <- base::grepl
[17:40:41.481]                           restarts <- computeRestarts(cond)
[17:40:41.481]                           for (restart in restarts) {
[17:40:41.481]                             name <- restart$name
[17:40:41.481]                             if (is.null(name)) 
[17:40:41.481]                               next
[17:40:41.481]                             if (!grepl(pattern, name)) 
[17:40:41.481]                               next
[17:40:41.481]                             invokeRestart(restart)
[17:40:41.481]                             muffled <- TRUE
[17:40:41.481]                             break
[17:40:41.481]                           }
[17:40:41.481]                         }
[17:40:41.481]                       }
[17:40:41.481]                       invisible(muffled)
[17:40:41.481]                     }
[17:40:41.481]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.481]                   }
[17:40:41.481]                 }
[17:40:41.481]             }
[17:40:41.481]         }))
[17:40:41.481]     }, error = function(ex) {
[17:40:41.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.481]                 ...future.rng), started = ...future.startTime, 
[17:40:41.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.481]             version = "1.8"), class = "FutureResult")
[17:40:41.481]     }, finally = {
[17:40:41.481]         if (!identical(...future.workdir, getwd())) 
[17:40:41.481]             setwd(...future.workdir)
[17:40:41.481]         {
[17:40:41.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.481]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.481]             }
[17:40:41.481]             base::options(...future.oldOptions)
[17:40:41.481]             if (.Platform$OS.type == "windows") {
[17:40:41.481]                 old_names <- names(...future.oldEnvVars)
[17:40:41.481]                 envs <- base::Sys.getenv()
[17:40:41.481]                 names <- names(envs)
[17:40:41.481]                 common <- intersect(names, old_names)
[17:40:41.481]                 added <- setdiff(names, old_names)
[17:40:41.481]                 removed <- setdiff(old_names, names)
[17:40:41.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.481]                   envs[common]]
[17:40:41.481]                 NAMES <- toupper(changed)
[17:40:41.481]                 args <- list()
[17:40:41.481]                 for (kk in seq_along(NAMES)) {
[17:40:41.481]                   name <- changed[[kk]]
[17:40:41.481]                   NAME <- NAMES[[kk]]
[17:40:41.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.481]                     next
[17:40:41.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.481]                 }
[17:40:41.481]                 NAMES <- toupper(added)
[17:40:41.481]                 for (kk in seq_along(NAMES)) {
[17:40:41.481]                   name <- added[[kk]]
[17:40:41.481]                   NAME <- NAMES[[kk]]
[17:40:41.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.481]                     next
[17:40:41.481]                   args[[name]] <- ""
[17:40:41.481]                 }
[17:40:41.481]                 NAMES <- toupper(removed)
[17:40:41.481]                 for (kk in seq_along(NAMES)) {
[17:40:41.481]                   name <- removed[[kk]]
[17:40:41.481]                   NAME <- NAMES[[kk]]
[17:40:41.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.481]                     next
[17:40:41.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.481]                 }
[17:40:41.481]                 if (length(args) > 0) 
[17:40:41.481]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.481]             }
[17:40:41.481]             else {
[17:40:41.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.481]             }
[17:40:41.481]             {
[17:40:41.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.481]                   0L) {
[17:40:41.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.481]                   base::options(opts)
[17:40:41.481]                 }
[17:40:41.481]                 {
[17:40:41.481]                   {
[17:40:41.481]                     NULL
[17:40:41.481]                     RNGkind("Mersenne-Twister")
[17:40:41.481]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.481]                       inherits = FALSE)
[17:40:41.481]                   }
[17:40:41.481]                   options(future.plan = NULL)
[17:40:41.481]                   if (is.na(NA_character_)) 
[17:40:41.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.481]                     .init = FALSE)
[17:40:41.481]                 }
[17:40:41.481]             }
[17:40:41.481]         }
[17:40:41.481]     })
[17:40:41.481]     if (TRUE) {
[17:40:41.481]         base::sink(type = "output", split = FALSE)
[17:40:41.481]         if (TRUE) {
[17:40:41.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.481]         }
[17:40:41.481]         else {
[17:40:41.481]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.481]         }
[17:40:41.481]         base::close(...future.stdout)
[17:40:41.481]         ...future.stdout <- NULL
[17:40:41.481]     }
[17:40:41.481]     ...future.result$conditions <- ...future.conditions
[17:40:41.481]     ...future.result$finished <- base::Sys.time()
[17:40:41.481]     ...future.result
[17:40:41.481] }
[17:40:41.483] assign_globals() ...
[17:40:41.483] List of 1
[17:40:41.483]  $ kk: int 3
[17:40:41.483]  - attr(*, "where")=List of 1
[17:40:41.483]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.483]  - attr(*, "resolved")= logi FALSE
[17:40:41.483]  - attr(*, "total_size")= num 56
[17:40:41.483]  - attr(*, "already-done")= logi TRUE
[17:40:41.485] - copied ‘kk’ to environment
[17:40:41.485] assign_globals() ... done
[17:40:41.486] plan(): Setting new future strategy stack:
[17:40:41.486] List of future strategies:
[17:40:41.486] 1. sequential:
[17:40:41.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.486]    - tweaked: FALSE
[17:40:41.486]    - call: NULL
[17:40:41.486] plan(): nbrOfWorkers() = 1
[17:40:41.589] plan(): Setting new future strategy stack:
[17:40:41.589] List of future strategies:
[17:40:41.589] 1. sequential:
[17:40:41.589]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.589]    - tweaked: FALSE
[17:40:41.589]    - call: plan(strategy)
[17:40:41.590] plan(): nbrOfWorkers() = 1
[17:40:41.590] SequentialFuture started (and completed)
[17:40:41.590] - Launch lazy future ... done
[17:40:41.590] run() for ‘SequentialFuture’ ... done
[17:40:41.590] resolve() on list ...
[17:40:41.590]  recursive: 0
[17:40:41.590]  length: 3
[17:40:41.590] 
[17:40:41.591] resolved() for ‘SequentialFuture’ ...
[17:40:41.591] - state: ‘finished’
[17:40:41.591] - run: TRUE
[17:40:41.591] - result: ‘FutureResult’
[17:40:41.591] resolved() for ‘SequentialFuture’ ... done
[17:40:41.591] Future #1
[17:40:41.591]  length: 2 (resolved future 1)
[17:40:41.591] resolved() for ‘SequentialFuture’ ...
[17:40:41.591] - state: ‘finished’
[17:40:41.591] - run: TRUE
[17:40:41.591] - result: ‘FutureResult’
[17:40:41.592] resolved() for ‘SequentialFuture’ ... done
[17:40:41.592] Future #2
[17:40:41.592]  length: 1 (resolved future 2)
[17:40:41.592] resolved() for ‘SequentialFuture’ ...
[17:40:41.592] - state: ‘finished’
[17:40:41.592] - run: TRUE
[17:40:41.592] - result: ‘FutureResult’
[17:40:41.592] resolved() for ‘SequentialFuture’ ... done
[17:40:41.592] Future #3
[17:40:41.592]  length: 0 (resolved future 3)
[17:40:41.592] resolve() on list ... DONE
[17:40:41.593] getGlobalsAndPackages() ...
[17:40:41.593] Searching for globals...
[17:40:41.594] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.594] Searching for globals ... DONE
[17:40:41.594] Resolving globals: FALSE
[17:40:41.594] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.595] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.595] - globals: [1] ‘kk’
[17:40:41.595] 
[17:40:41.595] getGlobalsAndPackages() ... DONE
[17:40:41.595] getGlobalsAndPackages() ...
[17:40:41.595] Searching for globals...
[17:40:41.596] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.596] Searching for globals ... DONE
[17:40:41.596] Resolving globals: FALSE
[17:40:41.597] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.597] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.597] - globals: [1] ‘kk’
[17:40:41.597] 
[17:40:41.597] getGlobalsAndPackages() ... DONE
[17:40:41.597] getGlobalsAndPackages() ...
[17:40:41.597] Searching for globals...
[17:40:41.598] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:41.598] Searching for globals ... DONE
[17:40:41.599] Resolving globals: FALSE
[17:40:41.599] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:41.599] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:41.599] - globals: [1] ‘kk’
[17:40:41.599] 
[17:40:41.599] getGlobalsAndPackages() ... DONE
[17:40:41.600] resolve() on list ...
[17:40:41.600]  recursive: 0
[17:40:41.600]  length: 3
[17:40:41.600] 
[17:40:41.600] run() for ‘Future’ ...
[17:40:41.600] - state: ‘created’
[17:40:41.600] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.601] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.601]   - Field: ‘label’
[17:40:41.601]   - Field: ‘local’
[17:40:41.601]   - Field: ‘owner’
[17:40:41.601]   - Field: ‘envir’
[17:40:41.601]   - Field: ‘packages’
[17:40:41.601]   - Field: ‘gc’
[17:40:41.601]   - Field: ‘conditions’
[17:40:41.601]   - Field: ‘expr’
[17:40:41.601]   - Field: ‘uuid’
[17:40:41.602]   - Field: ‘seed’
[17:40:41.602]   - Field: ‘version’
[17:40:41.602]   - Field: ‘result’
[17:40:41.602]   - Field: ‘asynchronous’
[17:40:41.602]   - Field: ‘calls’
[17:40:41.602]   - Field: ‘globals’
[17:40:41.602]   - Field: ‘stdout’
[17:40:41.602]   - Field: ‘earlySignal’
[17:40:41.602]   - Field: ‘lazy’
[17:40:41.602]   - Field: ‘state’
[17:40:41.602] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.603] - Launch lazy future ...
[17:40:41.603] Packages needed by the future expression (n = 0): <none>
[17:40:41.603] Packages needed by future strategies (n = 0): <none>
[17:40:41.603] {
[17:40:41.603]     {
[17:40:41.603]         {
[17:40:41.603]             ...future.startTime <- base::Sys.time()
[17:40:41.603]             {
[17:40:41.603]                 {
[17:40:41.603]                   {
[17:40:41.603]                     base::local({
[17:40:41.603]                       has_future <- base::requireNamespace("future", 
[17:40:41.603]                         quietly = TRUE)
[17:40:41.603]                       if (has_future) {
[17:40:41.603]                         ns <- base::getNamespace("future")
[17:40:41.603]                         version <- ns[[".package"]][["version"]]
[17:40:41.603]                         if (is.null(version)) 
[17:40:41.603]                           version <- utils::packageVersion("future")
[17:40:41.603]                       }
[17:40:41.603]                       else {
[17:40:41.603]                         version <- NULL
[17:40:41.603]                       }
[17:40:41.603]                       if (!has_future || version < "1.8.0") {
[17:40:41.603]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.603]                           "", base::R.version$version.string), 
[17:40:41.603]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.603]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.603]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.603]                             "release", "version")], collapse = " "), 
[17:40:41.603]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.603]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.603]                           info)
[17:40:41.603]                         info <- base::paste(info, collapse = "; ")
[17:40:41.603]                         if (!has_future) {
[17:40:41.603]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.603]                             info)
[17:40:41.603]                         }
[17:40:41.603]                         else {
[17:40:41.603]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.603]                             info, version)
[17:40:41.603]                         }
[17:40:41.603]                         base::stop(msg)
[17:40:41.603]                       }
[17:40:41.603]                     })
[17:40:41.603]                   }
[17:40:41.603]                   ...future.strategy.old <- future::plan("list")
[17:40:41.603]                   options(future.plan = NULL)
[17:40:41.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.603]                 }
[17:40:41.603]                 ...future.workdir <- getwd()
[17:40:41.603]             }
[17:40:41.603]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.603]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.603]         }
[17:40:41.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.603]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.603]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.603]             base::names(...future.oldOptions))
[17:40:41.603]     }
[17:40:41.603]     if (FALSE) {
[17:40:41.603]     }
[17:40:41.603]     else {
[17:40:41.603]         if (TRUE) {
[17:40:41.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.603]                 open = "w")
[17:40:41.603]         }
[17:40:41.603]         else {
[17:40:41.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.603]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.603]         }
[17:40:41.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.603]             base::sink(type = "output", split = FALSE)
[17:40:41.603]             base::close(...future.stdout)
[17:40:41.603]         }, add = TRUE)
[17:40:41.603]     }
[17:40:41.603]     ...future.frame <- base::sys.nframe()
[17:40:41.603]     ...future.conditions <- base::list()
[17:40:41.603]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.603]     if (FALSE) {
[17:40:41.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.603]     }
[17:40:41.603]     ...future.result <- base::tryCatch({
[17:40:41.603]         base::withCallingHandlers({
[17:40:41.603]             ...future.value <- base::withVisible(base::local({
[17:40:41.603]                 Sys.sleep(0.1)
[17:40:41.603]                 kk
[17:40:41.603]             }))
[17:40:41.603]             future::FutureResult(value = ...future.value$value, 
[17:40:41.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.603]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.603]                     ...future.globalenv.names))
[17:40:41.603]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.603]         }, condition = base::local({
[17:40:41.603]             c <- base::c
[17:40:41.603]             inherits <- base::inherits
[17:40:41.603]             invokeRestart <- base::invokeRestart
[17:40:41.603]             length <- base::length
[17:40:41.603]             list <- base::list
[17:40:41.603]             seq.int <- base::seq.int
[17:40:41.603]             signalCondition <- base::signalCondition
[17:40:41.603]             sys.calls <- base::sys.calls
[17:40:41.603]             `[[` <- base::`[[`
[17:40:41.603]             `+` <- base::`+`
[17:40:41.603]             `<<-` <- base::`<<-`
[17:40:41.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.603]                   3L)]
[17:40:41.603]             }
[17:40:41.603]             function(cond) {
[17:40:41.603]                 is_error <- inherits(cond, "error")
[17:40:41.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.603]                   NULL)
[17:40:41.603]                 if (is_error) {
[17:40:41.603]                   sessionInformation <- function() {
[17:40:41.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.603]                       search = base::search(), system = base::Sys.info())
[17:40:41.603]                   }
[17:40:41.603]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.603]                     cond$call), session = sessionInformation(), 
[17:40:41.603]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.603]                   signalCondition(cond)
[17:40:41.603]                 }
[17:40:41.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.603]                 "immediateCondition"))) {
[17:40:41.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.603]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.603]                   if (TRUE && !signal) {
[17:40:41.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.603]                     {
[17:40:41.603]                       inherits <- base::inherits
[17:40:41.603]                       invokeRestart <- base::invokeRestart
[17:40:41.603]                       is.null <- base::is.null
[17:40:41.603]                       muffled <- FALSE
[17:40:41.603]                       if (inherits(cond, "message")) {
[17:40:41.603]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.603]                         if (muffled) 
[17:40:41.603]                           invokeRestart("muffleMessage")
[17:40:41.603]                       }
[17:40:41.603]                       else if (inherits(cond, "warning")) {
[17:40:41.603]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.603]                         if (muffled) 
[17:40:41.603]                           invokeRestart("muffleWarning")
[17:40:41.603]                       }
[17:40:41.603]                       else if (inherits(cond, "condition")) {
[17:40:41.603]                         if (!is.null(pattern)) {
[17:40:41.603]                           computeRestarts <- base::computeRestarts
[17:40:41.603]                           grepl <- base::grepl
[17:40:41.603]                           restarts <- computeRestarts(cond)
[17:40:41.603]                           for (restart in restarts) {
[17:40:41.603]                             name <- restart$name
[17:40:41.603]                             if (is.null(name)) 
[17:40:41.603]                               next
[17:40:41.603]                             if (!grepl(pattern, name)) 
[17:40:41.603]                               next
[17:40:41.603]                             invokeRestart(restart)
[17:40:41.603]                             muffled <- TRUE
[17:40:41.603]                             break
[17:40:41.603]                           }
[17:40:41.603]                         }
[17:40:41.603]                       }
[17:40:41.603]                       invisible(muffled)
[17:40:41.603]                     }
[17:40:41.603]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.603]                   }
[17:40:41.603]                 }
[17:40:41.603]                 else {
[17:40:41.603]                   if (TRUE) {
[17:40:41.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.603]                     {
[17:40:41.603]                       inherits <- base::inherits
[17:40:41.603]                       invokeRestart <- base::invokeRestart
[17:40:41.603]                       is.null <- base::is.null
[17:40:41.603]                       muffled <- FALSE
[17:40:41.603]                       if (inherits(cond, "message")) {
[17:40:41.603]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.603]                         if (muffled) 
[17:40:41.603]                           invokeRestart("muffleMessage")
[17:40:41.603]                       }
[17:40:41.603]                       else if (inherits(cond, "warning")) {
[17:40:41.603]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.603]                         if (muffled) 
[17:40:41.603]                           invokeRestart("muffleWarning")
[17:40:41.603]                       }
[17:40:41.603]                       else if (inherits(cond, "condition")) {
[17:40:41.603]                         if (!is.null(pattern)) {
[17:40:41.603]                           computeRestarts <- base::computeRestarts
[17:40:41.603]                           grepl <- base::grepl
[17:40:41.603]                           restarts <- computeRestarts(cond)
[17:40:41.603]                           for (restart in restarts) {
[17:40:41.603]                             name <- restart$name
[17:40:41.603]                             if (is.null(name)) 
[17:40:41.603]                               next
[17:40:41.603]                             if (!grepl(pattern, name)) 
[17:40:41.603]                               next
[17:40:41.603]                             invokeRestart(restart)
[17:40:41.603]                             muffled <- TRUE
[17:40:41.603]                             break
[17:40:41.603]                           }
[17:40:41.603]                         }
[17:40:41.603]                       }
[17:40:41.603]                       invisible(muffled)
[17:40:41.603]                     }
[17:40:41.603]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.603]                   }
[17:40:41.603]                 }
[17:40:41.603]             }
[17:40:41.603]         }))
[17:40:41.603]     }, error = function(ex) {
[17:40:41.603]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.603]                 ...future.rng), started = ...future.startTime, 
[17:40:41.603]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.603]             version = "1.8"), class = "FutureResult")
[17:40:41.603]     }, finally = {
[17:40:41.603]         if (!identical(...future.workdir, getwd())) 
[17:40:41.603]             setwd(...future.workdir)
[17:40:41.603]         {
[17:40:41.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.603]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.603]             }
[17:40:41.603]             base::options(...future.oldOptions)
[17:40:41.603]             if (.Platform$OS.type == "windows") {
[17:40:41.603]                 old_names <- names(...future.oldEnvVars)
[17:40:41.603]                 envs <- base::Sys.getenv()
[17:40:41.603]                 names <- names(envs)
[17:40:41.603]                 common <- intersect(names, old_names)
[17:40:41.603]                 added <- setdiff(names, old_names)
[17:40:41.603]                 removed <- setdiff(old_names, names)
[17:40:41.603]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.603]                   envs[common]]
[17:40:41.603]                 NAMES <- toupper(changed)
[17:40:41.603]                 args <- list()
[17:40:41.603]                 for (kk in seq_along(NAMES)) {
[17:40:41.603]                   name <- changed[[kk]]
[17:40:41.603]                   NAME <- NAMES[[kk]]
[17:40:41.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.603]                     next
[17:40:41.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.603]                 }
[17:40:41.603]                 NAMES <- toupper(added)
[17:40:41.603]                 for (kk in seq_along(NAMES)) {
[17:40:41.603]                   name <- added[[kk]]
[17:40:41.603]                   NAME <- NAMES[[kk]]
[17:40:41.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.603]                     next
[17:40:41.603]                   args[[name]] <- ""
[17:40:41.603]                 }
[17:40:41.603]                 NAMES <- toupper(removed)
[17:40:41.603]                 for (kk in seq_along(NAMES)) {
[17:40:41.603]                   name <- removed[[kk]]
[17:40:41.603]                   NAME <- NAMES[[kk]]
[17:40:41.603]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.603]                     next
[17:40:41.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.603]                 }
[17:40:41.603]                 if (length(args) > 0) 
[17:40:41.603]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.603]             }
[17:40:41.603]             else {
[17:40:41.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.603]             }
[17:40:41.603]             {
[17:40:41.603]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.603]                   0L) {
[17:40:41.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.603]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.603]                   base::options(opts)
[17:40:41.603]                 }
[17:40:41.603]                 {
[17:40:41.603]                   {
[17:40:41.603]                     NULL
[17:40:41.603]                     RNGkind("Mersenne-Twister")
[17:40:41.603]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.603]                       inherits = FALSE)
[17:40:41.603]                   }
[17:40:41.603]                   options(future.plan = NULL)
[17:40:41.603]                   if (is.na(NA_character_)) 
[17:40:41.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.603]                     .init = FALSE)
[17:40:41.603]                 }
[17:40:41.603]             }
[17:40:41.603]         }
[17:40:41.603]     })
[17:40:41.603]     if (TRUE) {
[17:40:41.603]         base::sink(type = "output", split = FALSE)
[17:40:41.603]         if (TRUE) {
[17:40:41.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.603]         }
[17:40:41.603]         else {
[17:40:41.603]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.603]         }
[17:40:41.603]         base::close(...future.stdout)
[17:40:41.603]         ...future.stdout <- NULL
[17:40:41.603]     }
[17:40:41.603]     ...future.result$conditions <- ...future.conditions
[17:40:41.603]     ...future.result$finished <- base::Sys.time()
[17:40:41.603]     ...future.result
[17:40:41.603] }
[17:40:41.605] assign_globals() ...
[17:40:41.605] List of 1
[17:40:41.605]  $ kk: int 1
[17:40:41.605]  - attr(*, "where")=List of 1
[17:40:41.605]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.605]  - attr(*, "resolved")= logi FALSE
[17:40:41.605]  - attr(*, "total_size")= num 56
[17:40:41.605]  - attr(*, "already-done")= logi TRUE
[17:40:41.607] - copied ‘kk’ to environment
[17:40:41.607] assign_globals() ... done
[17:40:41.608] plan(): Setting new future strategy stack:
[17:40:41.608] List of future strategies:
[17:40:41.608] 1. sequential:
[17:40:41.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.608]    - tweaked: FALSE
[17:40:41.608]    - call: NULL
[17:40:41.608] plan(): nbrOfWorkers() = 1
[17:40:41.709] plan(): Setting new future strategy stack:
[17:40:41.710] List of future strategies:
[17:40:41.710] 1. sequential:
[17:40:41.710]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.710]    - tweaked: FALSE
[17:40:41.710]    - call: plan(strategy)
[17:40:41.710] plan(): nbrOfWorkers() = 1
[17:40:41.710] SequentialFuture started (and completed)
[17:40:41.710] - Launch lazy future ... done
[17:40:41.711] run() for ‘SequentialFuture’ ... done
[17:40:41.711] resolved() for ‘SequentialFuture’ ...
[17:40:41.711] - state: ‘finished’
[17:40:41.711] - run: TRUE
[17:40:41.711] - result: ‘FutureResult’
[17:40:41.711] resolved() for ‘SequentialFuture’ ... done
[17:40:41.711] Future #1
[17:40:41.711]  length: 2 (resolved future 1)
[17:40:41.711] run() for ‘Future’ ...
[17:40:41.711] - state: ‘created’
[17:40:41.712] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.712] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.712]   - Field: ‘label’
[17:40:41.712]   - Field: ‘local’
[17:40:41.712]   - Field: ‘owner’
[17:40:41.713]   - Field: ‘envir’
[17:40:41.713]   - Field: ‘packages’
[17:40:41.713]   - Field: ‘gc’
[17:40:41.713]   - Field: ‘conditions’
[17:40:41.713]   - Field: ‘expr’
[17:40:41.713]   - Field: ‘uuid’
[17:40:41.713]   - Field: ‘seed’
[17:40:41.713]   - Field: ‘version’
[17:40:41.713]   - Field: ‘result’
[17:40:41.713]   - Field: ‘asynchronous’
[17:40:41.713]   - Field: ‘calls’
[17:40:41.713]   - Field: ‘globals’
[17:40:41.714]   - Field: ‘stdout’
[17:40:41.714]   - Field: ‘earlySignal’
[17:40:41.714]   - Field: ‘lazy’
[17:40:41.714]   - Field: ‘state’
[17:40:41.714] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.714] - Launch lazy future ...
[17:40:41.714] Packages needed by the future expression (n = 0): <none>
[17:40:41.714] Packages needed by future strategies (n = 0): <none>
[17:40:41.715] {
[17:40:41.715]     {
[17:40:41.715]         {
[17:40:41.715]             ...future.startTime <- base::Sys.time()
[17:40:41.715]             {
[17:40:41.715]                 {
[17:40:41.715]                   {
[17:40:41.715]                     base::local({
[17:40:41.715]                       has_future <- base::requireNamespace("future", 
[17:40:41.715]                         quietly = TRUE)
[17:40:41.715]                       if (has_future) {
[17:40:41.715]                         ns <- base::getNamespace("future")
[17:40:41.715]                         version <- ns[[".package"]][["version"]]
[17:40:41.715]                         if (is.null(version)) 
[17:40:41.715]                           version <- utils::packageVersion("future")
[17:40:41.715]                       }
[17:40:41.715]                       else {
[17:40:41.715]                         version <- NULL
[17:40:41.715]                       }
[17:40:41.715]                       if (!has_future || version < "1.8.0") {
[17:40:41.715]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.715]                           "", base::R.version$version.string), 
[17:40:41.715]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.715]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.715]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.715]                             "release", "version")], collapse = " "), 
[17:40:41.715]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.715]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.715]                           info)
[17:40:41.715]                         info <- base::paste(info, collapse = "; ")
[17:40:41.715]                         if (!has_future) {
[17:40:41.715]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.715]                             info)
[17:40:41.715]                         }
[17:40:41.715]                         else {
[17:40:41.715]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.715]                             info, version)
[17:40:41.715]                         }
[17:40:41.715]                         base::stop(msg)
[17:40:41.715]                       }
[17:40:41.715]                     })
[17:40:41.715]                   }
[17:40:41.715]                   ...future.strategy.old <- future::plan("list")
[17:40:41.715]                   options(future.plan = NULL)
[17:40:41.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.715]                 }
[17:40:41.715]                 ...future.workdir <- getwd()
[17:40:41.715]             }
[17:40:41.715]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.715]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.715]         }
[17:40:41.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.715]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.715]             base::names(...future.oldOptions))
[17:40:41.715]     }
[17:40:41.715]     if (FALSE) {
[17:40:41.715]     }
[17:40:41.715]     else {
[17:40:41.715]         if (TRUE) {
[17:40:41.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.715]                 open = "w")
[17:40:41.715]         }
[17:40:41.715]         else {
[17:40:41.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.715]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.715]         }
[17:40:41.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.715]             base::sink(type = "output", split = FALSE)
[17:40:41.715]             base::close(...future.stdout)
[17:40:41.715]         }, add = TRUE)
[17:40:41.715]     }
[17:40:41.715]     ...future.frame <- base::sys.nframe()
[17:40:41.715]     ...future.conditions <- base::list()
[17:40:41.715]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.715]     if (FALSE) {
[17:40:41.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.715]     }
[17:40:41.715]     ...future.result <- base::tryCatch({
[17:40:41.715]         base::withCallingHandlers({
[17:40:41.715]             ...future.value <- base::withVisible(base::local({
[17:40:41.715]                 Sys.sleep(0.1)
[17:40:41.715]                 kk
[17:40:41.715]             }))
[17:40:41.715]             future::FutureResult(value = ...future.value$value, 
[17:40:41.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.715]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.715]                     ...future.globalenv.names))
[17:40:41.715]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.715]         }, condition = base::local({
[17:40:41.715]             c <- base::c
[17:40:41.715]             inherits <- base::inherits
[17:40:41.715]             invokeRestart <- base::invokeRestart
[17:40:41.715]             length <- base::length
[17:40:41.715]             list <- base::list
[17:40:41.715]             seq.int <- base::seq.int
[17:40:41.715]             signalCondition <- base::signalCondition
[17:40:41.715]             sys.calls <- base::sys.calls
[17:40:41.715]             `[[` <- base::`[[`
[17:40:41.715]             `+` <- base::`+`
[17:40:41.715]             `<<-` <- base::`<<-`
[17:40:41.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.715]                   3L)]
[17:40:41.715]             }
[17:40:41.715]             function(cond) {
[17:40:41.715]                 is_error <- inherits(cond, "error")
[17:40:41.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.715]                   NULL)
[17:40:41.715]                 if (is_error) {
[17:40:41.715]                   sessionInformation <- function() {
[17:40:41.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.715]                       search = base::search(), system = base::Sys.info())
[17:40:41.715]                   }
[17:40:41.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.715]                     cond$call), session = sessionInformation(), 
[17:40:41.715]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.715]                   signalCondition(cond)
[17:40:41.715]                 }
[17:40:41.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.715]                 "immediateCondition"))) {
[17:40:41.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.715]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.715]                   if (TRUE && !signal) {
[17:40:41.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.715]                     {
[17:40:41.715]                       inherits <- base::inherits
[17:40:41.715]                       invokeRestart <- base::invokeRestart
[17:40:41.715]                       is.null <- base::is.null
[17:40:41.715]                       muffled <- FALSE
[17:40:41.715]                       if (inherits(cond, "message")) {
[17:40:41.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.715]                         if (muffled) 
[17:40:41.715]                           invokeRestart("muffleMessage")
[17:40:41.715]                       }
[17:40:41.715]                       else if (inherits(cond, "warning")) {
[17:40:41.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.715]                         if (muffled) 
[17:40:41.715]                           invokeRestart("muffleWarning")
[17:40:41.715]                       }
[17:40:41.715]                       else if (inherits(cond, "condition")) {
[17:40:41.715]                         if (!is.null(pattern)) {
[17:40:41.715]                           computeRestarts <- base::computeRestarts
[17:40:41.715]                           grepl <- base::grepl
[17:40:41.715]                           restarts <- computeRestarts(cond)
[17:40:41.715]                           for (restart in restarts) {
[17:40:41.715]                             name <- restart$name
[17:40:41.715]                             if (is.null(name)) 
[17:40:41.715]                               next
[17:40:41.715]                             if (!grepl(pattern, name)) 
[17:40:41.715]                               next
[17:40:41.715]                             invokeRestart(restart)
[17:40:41.715]                             muffled <- TRUE
[17:40:41.715]                             break
[17:40:41.715]                           }
[17:40:41.715]                         }
[17:40:41.715]                       }
[17:40:41.715]                       invisible(muffled)
[17:40:41.715]                     }
[17:40:41.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.715]                   }
[17:40:41.715]                 }
[17:40:41.715]                 else {
[17:40:41.715]                   if (TRUE) {
[17:40:41.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.715]                     {
[17:40:41.715]                       inherits <- base::inherits
[17:40:41.715]                       invokeRestart <- base::invokeRestart
[17:40:41.715]                       is.null <- base::is.null
[17:40:41.715]                       muffled <- FALSE
[17:40:41.715]                       if (inherits(cond, "message")) {
[17:40:41.715]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.715]                         if (muffled) 
[17:40:41.715]                           invokeRestart("muffleMessage")
[17:40:41.715]                       }
[17:40:41.715]                       else if (inherits(cond, "warning")) {
[17:40:41.715]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.715]                         if (muffled) 
[17:40:41.715]                           invokeRestart("muffleWarning")
[17:40:41.715]                       }
[17:40:41.715]                       else if (inherits(cond, "condition")) {
[17:40:41.715]                         if (!is.null(pattern)) {
[17:40:41.715]                           computeRestarts <- base::computeRestarts
[17:40:41.715]                           grepl <- base::grepl
[17:40:41.715]                           restarts <- computeRestarts(cond)
[17:40:41.715]                           for (restart in restarts) {
[17:40:41.715]                             name <- restart$name
[17:40:41.715]                             if (is.null(name)) 
[17:40:41.715]                               next
[17:40:41.715]                             if (!grepl(pattern, name)) 
[17:40:41.715]                               next
[17:40:41.715]                             invokeRestart(restart)
[17:40:41.715]                             muffled <- TRUE
[17:40:41.715]                             break
[17:40:41.715]                           }
[17:40:41.715]                         }
[17:40:41.715]                       }
[17:40:41.715]                       invisible(muffled)
[17:40:41.715]                     }
[17:40:41.715]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.715]                   }
[17:40:41.715]                 }
[17:40:41.715]             }
[17:40:41.715]         }))
[17:40:41.715]     }, error = function(ex) {
[17:40:41.715]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.715]                 ...future.rng), started = ...future.startTime, 
[17:40:41.715]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.715]             version = "1.8"), class = "FutureResult")
[17:40:41.715]     }, finally = {
[17:40:41.715]         if (!identical(...future.workdir, getwd())) 
[17:40:41.715]             setwd(...future.workdir)
[17:40:41.715]         {
[17:40:41.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.715]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.715]             }
[17:40:41.715]             base::options(...future.oldOptions)
[17:40:41.715]             if (.Platform$OS.type == "windows") {
[17:40:41.715]                 old_names <- names(...future.oldEnvVars)
[17:40:41.715]                 envs <- base::Sys.getenv()
[17:40:41.715]                 names <- names(envs)
[17:40:41.715]                 common <- intersect(names, old_names)
[17:40:41.715]                 added <- setdiff(names, old_names)
[17:40:41.715]                 removed <- setdiff(old_names, names)
[17:40:41.715]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.715]                   envs[common]]
[17:40:41.715]                 NAMES <- toupper(changed)
[17:40:41.715]                 args <- list()
[17:40:41.715]                 for (kk in seq_along(NAMES)) {
[17:40:41.715]                   name <- changed[[kk]]
[17:40:41.715]                   NAME <- NAMES[[kk]]
[17:40:41.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.715]                     next
[17:40:41.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.715]                 }
[17:40:41.715]                 NAMES <- toupper(added)
[17:40:41.715]                 for (kk in seq_along(NAMES)) {
[17:40:41.715]                   name <- added[[kk]]
[17:40:41.715]                   NAME <- NAMES[[kk]]
[17:40:41.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.715]                     next
[17:40:41.715]                   args[[name]] <- ""
[17:40:41.715]                 }
[17:40:41.715]                 NAMES <- toupper(removed)
[17:40:41.715]                 for (kk in seq_along(NAMES)) {
[17:40:41.715]                   name <- removed[[kk]]
[17:40:41.715]                   NAME <- NAMES[[kk]]
[17:40:41.715]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.715]                     next
[17:40:41.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.715]                 }
[17:40:41.715]                 if (length(args) > 0) 
[17:40:41.715]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.715]             }
[17:40:41.715]             else {
[17:40:41.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.715]             }
[17:40:41.715]             {
[17:40:41.715]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.715]                   0L) {
[17:40:41.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.715]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.715]                   base::options(opts)
[17:40:41.715]                 }
[17:40:41.715]                 {
[17:40:41.715]                   {
[17:40:41.715]                     NULL
[17:40:41.715]                     RNGkind("Mersenne-Twister")
[17:40:41.715]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.715]                       inherits = FALSE)
[17:40:41.715]                   }
[17:40:41.715]                   options(future.plan = NULL)
[17:40:41.715]                   if (is.na(NA_character_)) 
[17:40:41.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.715]                     .init = FALSE)
[17:40:41.715]                 }
[17:40:41.715]             }
[17:40:41.715]         }
[17:40:41.715]     })
[17:40:41.715]     if (TRUE) {
[17:40:41.715]         base::sink(type = "output", split = FALSE)
[17:40:41.715]         if (TRUE) {
[17:40:41.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.715]         }
[17:40:41.715]         else {
[17:40:41.715]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.715]         }
[17:40:41.715]         base::close(...future.stdout)
[17:40:41.715]         ...future.stdout <- NULL
[17:40:41.715]     }
[17:40:41.715]     ...future.result$conditions <- ...future.conditions
[17:40:41.715]     ...future.result$finished <- base::Sys.time()
[17:40:41.715]     ...future.result
[17:40:41.715] }
[17:40:41.716] assign_globals() ...
[17:40:41.717] List of 1
[17:40:41.717]  $ kk: int 2
[17:40:41.717]  - attr(*, "where")=List of 1
[17:40:41.717]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.717]  - attr(*, "resolved")= logi FALSE
[17:40:41.717]  - attr(*, "total_size")= num 56
[17:40:41.717]  - attr(*, "already-done")= logi TRUE
[17:40:41.721] - copied ‘kk’ to environment
[17:40:41.721] assign_globals() ... done
[17:40:41.721] plan(): Setting new future strategy stack:
[17:40:41.721] List of future strategies:
[17:40:41.721] 1. sequential:
[17:40:41.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.721]    - tweaked: FALSE
[17:40:41.721]    - call: NULL
[17:40:41.722] plan(): nbrOfWorkers() = 1
[17:40:41.823] plan(): Setting new future strategy stack:
[17:40:41.823] List of future strategies:
[17:40:41.823] 1. sequential:
[17:40:41.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.823]    - tweaked: FALSE
[17:40:41.823]    - call: plan(strategy)
[17:40:41.824] plan(): nbrOfWorkers() = 1
[17:40:41.824] SequentialFuture started (and completed)
[17:40:41.824] - Launch lazy future ... done
[17:40:41.824] run() for ‘SequentialFuture’ ... done
[17:40:41.824] resolved() for ‘SequentialFuture’ ...
[17:40:41.824] - state: ‘finished’
[17:40:41.824] - run: TRUE
[17:40:41.825] - result: ‘FutureResult’
[17:40:41.825] resolved() for ‘SequentialFuture’ ... done
[17:40:41.825] Future #2
[17:40:41.825]  length: 1 (resolved future 2)
[17:40:41.825] run() for ‘Future’ ...
[17:40:41.825] - state: ‘created’
[17:40:41.825] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.825] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.826]   - Field: ‘label’
[17:40:41.826]   - Field: ‘local’
[17:40:41.826]   - Field: ‘owner’
[17:40:41.826]   - Field: ‘envir’
[17:40:41.826]   - Field: ‘packages’
[17:40:41.826]   - Field: ‘gc’
[17:40:41.826]   - Field: ‘conditions’
[17:40:41.826]   - Field: ‘expr’
[17:40:41.826]   - Field: ‘uuid’
[17:40:41.827]   - Field: ‘seed’
[17:40:41.827]   - Field: ‘version’
[17:40:41.827]   - Field: ‘result’
[17:40:41.827]   - Field: ‘asynchronous’
[17:40:41.827]   - Field: ‘calls’
[17:40:41.827]   - Field: ‘globals’
[17:40:41.827]   - Field: ‘stdout’
[17:40:41.827]   - Field: ‘earlySignal’
[17:40:41.827]   - Field: ‘lazy’
[17:40:41.827]   - Field: ‘state’
[17:40:41.827] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.828] - Launch lazy future ...
[17:40:41.828] Packages needed by the future expression (n = 0): <none>
[17:40:41.828] Packages needed by future strategies (n = 0): <none>
[17:40:41.828] {
[17:40:41.828]     {
[17:40:41.828]         {
[17:40:41.828]             ...future.startTime <- base::Sys.time()
[17:40:41.828]             {
[17:40:41.828]                 {
[17:40:41.828]                   {
[17:40:41.828]                     base::local({
[17:40:41.828]                       has_future <- base::requireNamespace("future", 
[17:40:41.828]                         quietly = TRUE)
[17:40:41.828]                       if (has_future) {
[17:40:41.828]                         ns <- base::getNamespace("future")
[17:40:41.828]                         version <- ns[[".package"]][["version"]]
[17:40:41.828]                         if (is.null(version)) 
[17:40:41.828]                           version <- utils::packageVersion("future")
[17:40:41.828]                       }
[17:40:41.828]                       else {
[17:40:41.828]                         version <- NULL
[17:40:41.828]                       }
[17:40:41.828]                       if (!has_future || version < "1.8.0") {
[17:40:41.828]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.828]                           "", base::R.version$version.string), 
[17:40:41.828]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.828]                             "release", "version")], collapse = " "), 
[17:40:41.828]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.828]                           info)
[17:40:41.828]                         info <- base::paste(info, collapse = "; ")
[17:40:41.828]                         if (!has_future) {
[17:40:41.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.828]                             info)
[17:40:41.828]                         }
[17:40:41.828]                         else {
[17:40:41.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.828]                             info, version)
[17:40:41.828]                         }
[17:40:41.828]                         base::stop(msg)
[17:40:41.828]                       }
[17:40:41.828]                     })
[17:40:41.828]                   }
[17:40:41.828]                   ...future.strategy.old <- future::plan("list")
[17:40:41.828]                   options(future.plan = NULL)
[17:40:41.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.828]                 }
[17:40:41.828]                 ...future.workdir <- getwd()
[17:40:41.828]             }
[17:40:41.828]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.828]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.828]         }
[17:40:41.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.828]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.828]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.828]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.828]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.828]             base::names(...future.oldOptions))
[17:40:41.828]     }
[17:40:41.828]     if (FALSE) {
[17:40:41.828]     }
[17:40:41.828]     else {
[17:40:41.828]         if (TRUE) {
[17:40:41.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.828]                 open = "w")
[17:40:41.828]         }
[17:40:41.828]         else {
[17:40:41.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.828]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.828]         }
[17:40:41.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.828]             base::sink(type = "output", split = FALSE)
[17:40:41.828]             base::close(...future.stdout)
[17:40:41.828]         }, add = TRUE)
[17:40:41.828]     }
[17:40:41.828]     ...future.frame <- base::sys.nframe()
[17:40:41.828]     ...future.conditions <- base::list()
[17:40:41.828]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.828]     if (FALSE) {
[17:40:41.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.828]     }
[17:40:41.828]     ...future.result <- base::tryCatch({
[17:40:41.828]         base::withCallingHandlers({
[17:40:41.828]             ...future.value <- base::withVisible(base::local({
[17:40:41.828]                 Sys.sleep(0.1)
[17:40:41.828]                 kk
[17:40:41.828]             }))
[17:40:41.828]             future::FutureResult(value = ...future.value$value, 
[17:40:41.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.828]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.828]                     ...future.globalenv.names))
[17:40:41.828]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.828]         }, condition = base::local({
[17:40:41.828]             c <- base::c
[17:40:41.828]             inherits <- base::inherits
[17:40:41.828]             invokeRestart <- base::invokeRestart
[17:40:41.828]             length <- base::length
[17:40:41.828]             list <- base::list
[17:40:41.828]             seq.int <- base::seq.int
[17:40:41.828]             signalCondition <- base::signalCondition
[17:40:41.828]             sys.calls <- base::sys.calls
[17:40:41.828]             `[[` <- base::`[[`
[17:40:41.828]             `+` <- base::`+`
[17:40:41.828]             `<<-` <- base::`<<-`
[17:40:41.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.828]                   3L)]
[17:40:41.828]             }
[17:40:41.828]             function(cond) {
[17:40:41.828]                 is_error <- inherits(cond, "error")
[17:40:41.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.828]                   NULL)
[17:40:41.828]                 if (is_error) {
[17:40:41.828]                   sessionInformation <- function() {
[17:40:41.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.828]                       search = base::search(), system = base::Sys.info())
[17:40:41.828]                   }
[17:40:41.828]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.828]                     cond$call), session = sessionInformation(), 
[17:40:41.828]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.828]                   signalCondition(cond)
[17:40:41.828]                 }
[17:40:41.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.828]                 "immediateCondition"))) {
[17:40:41.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.828]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.828]                   if (TRUE && !signal) {
[17:40:41.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.828]                     {
[17:40:41.828]                       inherits <- base::inherits
[17:40:41.828]                       invokeRestart <- base::invokeRestart
[17:40:41.828]                       is.null <- base::is.null
[17:40:41.828]                       muffled <- FALSE
[17:40:41.828]                       if (inherits(cond, "message")) {
[17:40:41.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.828]                         if (muffled) 
[17:40:41.828]                           invokeRestart("muffleMessage")
[17:40:41.828]                       }
[17:40:41.828]                       else if (inherits(cond, "warning")) {
[17:40:41.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.828]                         if (muffled) 
[17:40:41.828]                           invokeRestart("muffleWarning")
[17:40:41.828]                       }
[17:40:41.828]                       else if (inherits(cond, "condition")) {
[17:40:41.828]                         if (!is.null(pattern)) {
[17:40:41.828]                           computeRestarts <- base::computeRestarts
[17:40:41.828]                           grepl <- base::grepl
[17:40:41.828]                           restarts <- computeRestarts(cond)
[17:40:41.828]                           for (restart in restarts) {
[17:40:41.828]                             name <- restart$name
[17:40:41.828]                             if (is.null(name)) 
[17:40:41.828]                               next
[17:40:41.828]                             if (!grepl(pattern, name)) 
[17:40:41.828]                               next
[17:40:41.828]                             invokeRestart(restart)
[17:40:41.828]                             muffled <- TRUE
[17:40:41.828]                             break
[17:40:41.828]                           }
[17:40:41.828]                         }
[17:40:41.828]                       }
[17:40:41.828]                       invisible(muffled)
[17:40:41.828]                     }
[17:40:41.828]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.828]                   }
[17:40:41.828]                 }
[17:40:41.828]                 else {
[17:40:41.828]                   if (TRUE) {
[17:40:41.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.828]                     {
[17:40:41.828]                       inherits <- base::inherits
[17:40:41.828]                       invokeRestart <- base::invokeRestart
[17:40:41.828]                       is.null <- base::is.null
[17:40:41.828]                       muffled <- FALSE
[17:40:41.828]                       if (inherits(cond, "message")) {
[17:40:41.828]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.828]                         if (muffled) 
[17:40:41.828]                           invokeRestart("muffleMessage")
[17:40:41.828]                       }
[17:40:41.828]                       else if (inherits(cond, "warning")) {
[17:40:41.828]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.828]                         if (muffled) 
[17:40:41.828]                           invokeRestart("muffleWarning")
[17:40:41.828]                       }
[17:40:41.828]                       else if (inherits(cond, "condition")) {
[17:40:41.828]                         if (!is.null(pattern)) {
[17:40:41.828]                           computeRestarts <- base::computeRestarts
[17:40:41.828]                           grepl <- base::grepl
[17:40:41.828]                           restarts <- computeRestarts(cond)
[17:40:41.828]                           for (restart in restarts) {
[17:40:41.828]                             name <- restart$name
[17:40:41.828]                             if (is.null(name)) 
[17:40:41.828]                               next
[17:40:41.828]                             if (!grepl(pattern, name)) 
[17:40:41.828]                               next
[17:40:41.828]                             invokeRestart(restart)
[17:40:41.828]                             muffled <- TRUE
[17:40:41.828]                             break
[17:40:41.828]                           }
[17:40:41.828]                         }
[17:40:41.828]                       }
[17:40:41.828]                       invisible(muffled)
[17:40:41.828]                     }
[17:40:41.828]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.828]                   }
[17:40:41.828]                 }
[17:40:41.828]             }
[17:40:41.828]         }))
[17:40:41.828]     }, error = function(ex) {
[17:40:41.828]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.828]                 ...future.rng), started = ...future.startTime, 
[17:40:41.828]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.828]             version = "1.8"), class = "FutureResult")
[17:40:41.828]     }, finally = {
[17:40:41.828]         if (!identical(...future.workdir, getwd())) 
[17:40:41.828]             setwd(...future.workdir)
[17:40:41.828]         {
[17:40:41.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.828]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.828]             }
[17:40:41.828]             base::options(...future.oldOptions)
[17:40:41.828]             if (.Platform$OS.type == "windows") {
[17:40:41.828]                 old_names <- names(...future.oldEnvVars)
[17:40:41.828]                 envs <- base::Sys.getenv()
[17:40:41.828]                 names <- names(envs)
[17:40:41.828]                 common <- intersect(names, old_names)
[17:40:41.828]                 added <- setdiff(names, old_names)
[17:40:41.828]                 removed <- setdiff(old_names, names)
[17:40:41.828]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.828]                   envs[common]]
[17:40:41.828]                 NAMES <- toupper(changed)
[17:40:41.828]                 args <- list()
[17:40:41.828]                 for (kk in seq_along(NAMES)) {
[17:40:41.828]                   name <- changed[[kk]]
[17:40:41.828]                   NAME <- NAMES[[kk]]
[17:40:41.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.828]                     next
[17:40:41.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.828]                 }
[17:40:41.828]                 NAMES <- toupper(added)
[17:40:41.828]                 for (kk in seq_along(NAMES)) {
[17:40:41.828]                   name <- added[[kk]]
[17:40:41.828]                   NAME <- NAMES[[kk]]
[17:40:41.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.828]                     next
[17:40:41.828]                   args[[name]] <- ""
[17:40:41.828]                 }
[17:40:41.828]                 NAMES <- toupper(removed)
[17:40:41.828]                 for (kk in seq_along(NAMES)) {
[17:40:41.828]                   name <- removed[[kk]]
[17:40:41.828]                   NAME <- NAMES[[kk]]
[17:40:41.828]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.828]                     next
[17:40:41.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.828]                 }
[17:40:41.828]                 if (length(args) > 0) 
[17:40:41.828]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.828]             }
[17:40:41.828]             else {
[17:40:41.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.828]             }
[17:40:41.828]             {
[17:40:41.828]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.828]                   0L) {
[17:40:41.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.828]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.828]                   base::options(opts)
[17:40:41.828]                 }
[17:40:41.828]                 {
[17:40:41.828]                   {
[17:40:41.828]                     NULL
[17:40:41.828]                     RNGkind("Mersenne-Twister")
[17:40:41.828]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.828]                       inherits = FALSE)
[17:40:41.828]                   }
[17:40:41.828]                   options(future.plan = NULL)
[17:40:41.828]                   if (is.na(NA_character_)) 
[17:40:41.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.828]                     .init = FALSE)
[17:40:41.828]                 }
[17:40:41.828]             }
[17:40:41.828]         }
[17:40:41.828]     })
[17:40:41.828]     if (TRUE) {
[17:40:41.828]         base::sink(type = "output", split = FALSE)
[17:40:41.828]         if (TRUE) {
[17:40:41.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.828]         }
[17:40:41.828]         else {
[17:40:41.828]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.828]         }
[17:40:41.828]         base::close(...future.stdout)
[17:40:41.828]         ...future.stdout <- NULL
[17:40:41.828]     }
[17:40:41.828]     ...future.result$conditions <- ...future.conditions
[17:40:41.828]     ...future.result$finished <- base::Sys.time()
[17:40:41.828]     ...future.result
[17:40:41.828] }
[17:40:41.830] assign_globals() ...
[17:40:41.830] List of 1
[17:40:41.830]  $ kk: int 3
[17:40:41.830]  - attr(*, "where")=List of 1
[17:40:41.830]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:41.830]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:41.830]  - attr(*, "resolved")= logi FALSE
[17:40:41.830]  - attr(*, "total_size")= num 56
[17:40:41.830]  - attr(*, "already-done")= logi TRUE
[17:40:41.832] - copied ‘kk’ to environment
[17:40:41.833] assign_globals() ... done
[17:40:41.833] plan(): Setting new future strategy stack:
[17:40:41.833] List of future strategies:
[17:40:41.833] 1. sequential:
[17:40:41.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.833]    - tweaked: FALSE
[17:40:41.833]    - call: NULL
[17:40:41.833] plan(): nbrOfWorkers() = 1
[17:40:41.934] plan(): Setting new future strategy stack:
[17:40:41.935] List of future strategies:
[17:40:41.935] 1. sequential:
[17:40:41.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.935]    - tweaked: FALSE
[17:40:41.935]    - call: plan(strategy)
[17:40:41.935] plan(): nbrOfWorkers() = 1
[17:40:41.935] SequentialFuture started (and completed)
[17:40:41.935] - Launch lazy future ... done
[17:40:41.936] run() for ‘SequentialFuture’ ... done
[17:40:41.936] resolved() for ‘SequentialFuture’ ...
[17:40:41.936] - state: ‘finished’
[17:40:41.936] - run: TRUE
[17:40:41.936] - result: ‘FutureResult’
[17:40:41.936] resolved() for ‘SequentialFuture’ ... done
[17:40:41.936] Future #3
[17:40:41.936]  length: 0 (resolved future 3)
[17:40:41.936] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:40:41.937] resolve() on environment ...
[17:40:41.937]  recursive: 0
[17:40:41.938]  elements: [2] ‘a’, ‘b’
[17:40:41.939]  length: 1 (resolved future 1)
[17:40:41.939]  length: 0 (resolved future 2)
[17:40:41.939] resolve() on environment ... DONE
[17:40:41.939] getGlobalsAndPackages() ...
[17:40:41.939] Searching for globals...
[17:40:41.940] 
[17:40:41.940] Searching for globals ... DONE
[17:40:41.940] - globals: [0] <none>
[17:40:41.940] getGlobalsAndPackages() ... DONE
[17:40:41.940] run() for ‘Future’ ...
[17:40:41.940] - state: ‘created’
[17:40:41.940] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.941] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.941] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.941]   - Field: ‘label’
[17:40:41.941]   - Field: ‘local’
[17:40:41.941]   - Field: ‘owner’
[17:40:41.941]   - Field: ‘envir’
[17:40:41.941]   - Field: ‘packages’
[17:40:41.941]   - Field: ‘gc’
[17:40:41.941]   - Field: ‘conditions’
[17:40:41.941]   - Field: ‘expr’
[17:40:41.942]   - Field: ‘uuid’
[17:40:41.942]   - Field: ‘seed’
[17:40:41.942]   - Field: ‘version’
[17:40:41.942]   - Field: ‘result’
[17:40:41.942]   - Field: ‘asynchronous’
[17:40:41.942]   - Field: ‘calls’
[17:40:41.942]   - Field: ‘globals’
[17:40:41.942]   - Field: ‘stdout’
[17:40:41.942]   - Field: ‘earlySignal’
[17:40:41.942]   - Field: ‘lazy’
[17:40:41.942]   - Field: ‘state’
[17:40:41.943] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.943] - Launch lazy future ...
[17:40:41.943] Packages needed by the future expression (n = 0): <none>
[17:40:41.943] Packages needed by future strategies (n = 0): <none>
[17:40:41.943] {
[17:40:41.943]     {
[17:40:41.943]         {
[17:40:41.943]             ...future.startTime <- base::Sys.time()
[17:40:41.943]             {
[17:40:41.943]                 {
[17:40:41.943]                   {
[17:40:41.943]                     base::local({
[17:40:41.943]                       has_future <- base::requireNamespace("future", 
[17:40:41.943]                         quietly = TRUE)
[17:40:41.943]                       if (has_future) {
[17:40:41.943]                         ns <- base::getNamespace("future")
[17:40:41.943]                         version <- ns[[".package"]][["version"]]
[17:40:41.943]                         if (is.null(version)) 
[17:40:41.943]                           version <- utils::packageVersion("future")
[17:40:41.943]                       }
[17:40:41.943]                       else {
[17:40:41.943]                         version <- NULL
[17:40:41.943]                       }
[17:40:41.943]                       if (!has_future || version < "1.8.0") {
[17:40:41.943]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.943]                           "", base::R.version$version.string), 
[17:40:41.943]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.943]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.943]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.943]                             "release", "version")], collapse = " "), 
[17:40:41.943]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.943]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.943]                           info)
[17:40:41.943]                         info <- base::paste(info, collapse = "; ")
[17:40:41.943]                         if (!has_future) {
[17:40:41.943]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.943]                             info)
[17:40:41.943]                         }
[17:40:41.943]                         else {
[17:40:41.943]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.943]                             info, version)
[17:40:41.943]                         }
[17:40:41.943]                         base::stop(msg)
[17:40:41.943]                       }
[17:40:41.943]                     })
[17:40:41.943]                   }
[17:40:41.943]                   ...future.strategy.old <- future::plan("list")
[17:40:41.943]                   options(future.plan = NULL)
[17:40:41.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.943]                 }
[17:40:41.943]                 ...future.workdir <- getwd()
[17:40:41.943]             }
[17:40:41.943]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.943]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.943]         }
[17:40:41.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.943]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.943]             base::names(...future.oldOptions))
[17:40:41.943]     }
[17:40:41.943]     if (FALSE) {
[17:40:41.943]     }
[17:40:41.943]     else {
[17:40:41.943]         if (TRUE) {
[17:40:41.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.943]                 open = "w")
[17:40:41.943]         }
[17:40:41.943]         else {
[17:40:41.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.943]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.943]         }
[17:40:41.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.943]             base::sink(type = "output", split = FALSE)
[17:40:41.943]             base::close(...future.stdout)
[17:40:41.943]         }, add = TRUE)
[17:40:41.943]     }
[17:40:41.943]     ...future.frame <- base::sys.nframe()
[17:40:41.943]     ...future.conditions <- base::list()
[17:40:41.943]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.943]     if (FALSE) {
[17:40:41.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.943]     }
[17:40:41.943]     ...future.result <- base::tryCatch({
[17:40:41.943]         base::withCallingHandlers({
[17:40:41.943]             ...future.value <- base::withVisible(base::local(1))
[17:40:41.943]             future::FutureResult(value = ...future.value$value, 
[17:40:41.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.943]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.943]                     ...future.globalenv.names))
[17:40:41.943]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.943]         }, condition = base::local({
[17:40:41.943]             c <- base::c
[17:40:41.943]             inherits <- base::inherits
[17:40:41.943]             invokeRestart <- base::invokeRestart
[17:40:41.943]             length <- base::length
[17:40:41.943]             list <- base::list
[17:40:41.943]             seq.int <- base::seq.int
[17:40:41.943]             signalCondition <- base::signalCondition
[17:40:41.943]             sys.calls <- base::sys.calls
[17:40:41.943]             `[[` <- base::`[[`
[17:40:41.943]             `+` <- base::`+`
[17:40:41.943]             `<<-` <- base::`<<-`
[17:40:41.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.943]                   3L)]
[17:40:41.943]             }
[17:40:41.943]             function(cond) {
[17:40:41.943]                 is_error <- inherits(cond, "error")
[17:40:41.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.943]                   NULL)
[17:40:41.943]                 if (is_error) {
[17:40:41.943]                   sessionInformation <- function() {
[17:40:41.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.943]                       search = base::search(), system = base::Sys.info())
[17:40:41.943]                   }
[17:40:41.943]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.943]                     cond$call), session = sessionInformation(), 
[17:40:41.943]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.943]                   signalCondition(cond)
[17:40:41.943]                 }
[17:40:41.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.943]                 "immediateCondition"))) {
[17:40:41.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.943]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.943]                   if (TRUE && !signal) {
[17:40:41.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.943]                     {
[17:40:41.943]                       inherits <- base::inherits
[17:40:41.943]                       invokeRestart <- base::invokeRestart
[17:40:41.943]                       is.null <- base::is.null
[17:40:41.943]                       muffled <- FALSE
[17:40:41.943]                       if (inherits(cond, "message")) {
[17:40:41.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.943]                         if (muffled) 
[17:40:41.943]                           invokeRestart("muffleMessage")
[17:40:41.943]                       }
[17:40:41.943]                       else if (inherits(cond, "warning")) {
[17:40:41.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.943]                         if (muffled) 
[17:40:41.943]                           invokeRestart("muffleWarning")
[17:40:41.943]                       }
[17:40:41.943]                       else if (inherits(cond, "condition")) {
[17:40:41.943]                         if (!is.null(pattern)) {
[17:40:41.943]                           computeRestarts <- base::computeRestarts
[17:40:41.943]                           grepl <- base::grepl
[17:40:41.943]                           restarts <- computeRestarts(cond)
[17:40:41.943]                           for (restart in restarts) {
[17:40:41.943]                             name <- restart$name
[17:40:41.943]                             if (is.null(name)) 
[17:40:41.943]                               next
[17:40:41.943]                             if (!grepl(pattern, name)) 
[17:40:41.943]                               next
[17:40:41.943]                             invokeRestart(restart)
[17:40:41.943]                             muffled <- TRUE
[17:40:41.943]                             break
[17:40:41.943]                           }
[17:40:41.943]                         }
[17:40:41.943]                       }
[17:40:41.943]                       invisible(muffled)
[17:40:41.943]                     }
[17:40:41.943]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.943]                   }
[17:40:41.943]                 }
[17:40:41.943]                 else {
[17:40:41.943]                   if (TRUE) {
[17:40:41.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.943]                     {
[17:40:41.943]                       inherits <- base::inherits
[17:40:41.943]                       invokeRestart <- base::invokeRestart
[17:40:41.943]                       is.null <- base::is.null
[17:40:41.943]                       muffled <- FALSE
[17:40:41.943]                       if (inherits(cond, "message")) {
[17:40:41.943]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.943]                         if (muffled) 
[17:40:41.943]                           invokeRestart("muffleMessage")
[17:40:41.943]                       }
[17:40:41.943]                       else if (inherits(cond, "warning")) {
[17:40:41.943]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.943]                         if (muffled) 
[17:40:41.943]                           invokeRestart("muffleWarning")
[17:40:41.943]                       }
[17:40:41.943]                       else if (inherits(cond, "condition")) {
[17:40:41.943]                         if (!is.null(pattern)) {
[17:40:41.943]                           computeRestarts <- base::computeRestarts
[17:40:41.943]                           grepl <- base::grepl
[17:40:41.943]                           restarts <- computeRestarts(cond)
[17:40:41.943]                           for (restart in restarts) {
[17:40:41.943]                             name <- restart$name
[17:40:41.943]                             if (is.null(name)) 
[17:40:41.943]                               next
[17:40:41.943]                             if (!grepl(pattern, name)) 
[17:40:41.943]                               next
[17:40:41.943]                             invokeRestart(restart)
[17:40:41.943]                             muffled <- TRUE
[17:40:41.943]                             break
[17:40:41.943]                           }
[17:40:41.943]                         }
[17:40:41.943]                       }
[17:40:41.943]                       invisible(muffled)
[17:40:41.943]                     }
[17:40:41.943]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.943]                   }
[17:40:41.943]                 }
[17:40:41.943]             }
[17:40:41.943]         }))
[17:40:41.943]     }, error = function(ex) {
[17:40:41.943]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.943]                 ...future.rng), started = ...future.startTime, 
[17:40:41.943]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.943]             version = "1.8"), class = "FutureResult")
[17:40:41.943]     }, finally = {
[17:40:41.943]         if (!identical(...future.workdir, getwd())) 
[17:40:41.943]             setwd(...future.workdir)
[17:40:41.943]         {
[17:40:41.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.943]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.943]             }
[17:40:41.943]             base::options(...future.oldOptions)
[17:40:41.943]             if (.Platform$OS.type == "windows") {
[17:40:41.943]                 old_names <- names(...future.oldEnvVars)
[17:40:41.943]                 envs <- base::Sys.getenv()
[17:40:41.943]                 names <- names(envs)
[17:40:41.943]                 common <- intersect(names, old_names)
[17:40:41.943]                 added <- setdiff(names, old_names)
[17:40:41.943]                 removed <- setdiff(old_names, names)
[17:40:41.943]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.943]                   envs[common]]
[17:40:41.943]                 NAMES <- toupper(changed)
[17:40:41.943]                 args <- list()
[17:40:41.943]                 for (kk in seq_along(NAMES)) {
[17:40:41.943]                   name <- changed[[kk]]
[17:40:41.943]                   NAME <- NAMES[[kk]]
[17:40:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.943]                     next
[17:40:41.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.943]                 }
[17:40:41.943]                 NAMES <- toupper(added)
[17:40:41.943]                 for (kk in seq_along(NAMES)) {
[17:40:41.943]                   name <- added[[kk]]
[17:40:41.943]                   NAME <- NAMES[[kk]]
[17:40:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.943]                     next
[17:40:41.943]                   args[[name]] <- ""
[17:40:41.943]                 }
[17:40:41.943]                 NAMES <- toupper(removed)
[17:40:41.943]                 for (kk in seq_along(NAMES)) {
[17:40:41.943]                   name <- removed[[kk]]
[17:40:41.943]                   NAME <- NAMES[[kk]]
[17:40:41.943]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.943]                     next
[17:40:41.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.943]                 }
[17:40:41.943]                 if (length(args) > 0) 
[17:40:41.943]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.943]             }
[17:40:41.943]             else {
[17:40:41.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.943]             }
[17:40:41.943]             {
[17:40:41.943]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.943]                   0L) {
[17:40:41.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.943]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.943]                   base::options(opts)
[17:40:41.943]                 }
[17:40:41.943]                 {
[17:40:41.943]                   {
[17:40:41.943]                     NULL
[17:40:41.943]                     RNGkind("Mersenne-Twister")
[17:40:41.943]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.943]                       inherits = FALSE)
[17:40:41.943]                   }
[17:40:41.943]                   options(future.plan = NULL)
[17:40:41.943]                   if (is.na(NA_character_)) 
[17:40:41.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.943]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.943]                     .init = FALSE)
[17:40:41.943]                 }
[17:40:41.943]             }
[17:40:41.943]         }
[17:40:41.943]     })
[17:40:41.943]     if (TRUE) {
[17:40:41.943]         base::sink(type = "output", split = FALSE)
[17:40:41.943]         if (TRUE) {
[17:40:41.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.943]         }
[17:40:41.943]         else {
[17:40:41.943]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.943]         }
[17:40:41.943]         base::close(...future.stdout)
[17:40:41.943]         ...future.stdout <- NULL
[17:40:41.943]     }
[17:40:41.943]     ...future.result$conditions <- ...future.conditions
[17:40:41.943]     ...future.result$finished <- base::Sys.time()
[17:40:41.943]     ...future.result
[17:40:41.943] }
[17:40:41.945] plan(): Setting new future strategy stack:
[17:40:41.945] List of future strategies:
[17:40:41.945] 1. sequential:
[17:40:41.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.945]    - tweaked: FALSE
[17:40:41.945]    - call: NULL
[17:40:41.946] plan(): nbrOfWorkers() = 1
[17:40:41.946] plan(): Setting new future strategy stack:
[17:40:41.947] List of future strategies:
[17:40:41.947] 1. sequential:
[17:40:41.947]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.947]    - tweaked: FALSE
[17:40:41.947]    - call: plan(strategy)
[17:40:41.947] plan(): nbrOfWorkers() = 1
[17:40:41.947] SequentialFuture started (and completed)
[17:40:41.947] - Launch lazy future ... done
[17:40:41.947] run() for ‘SequentialFuture’ ... done
[17:40:41.947] getGlobalsAndPackages() ...
[17:40:41.948] Searching for globals...
[17:40:41.948] 
[17:40:41.948] Searching for globals ... DONE
[17:40:41.948] - globals: [0] <none>
[17:40:41.948] getGlobalsAndPackages() ... DONE
[17:40:41.948] run() for ‘Future’ ...
[17:40:41.948] - state: ‘created’
[17:40:41.949] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.949] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.949] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.949]   - Field: ‘label’
[17:40:41.949]   - Field: ‘local’
[17:40:41.951]   - Field: ‘owner’
[17:40:41.951]   - Field: ‘envir’
[17:40:41.951]   - Field: ‘packages’
[17:40:41.951]   - Field: ‘gc’
[17:40:41.952]   - Field: ‘conditions’
[17:40:41.952]   - Field: ‘expr’
[17:40:41.952]   - Field: ‘uuid’
[17:40:41.952]   - Field: ‘seed’
[17:40:41.952]   - Field: ‘version’
[17:40:41.952]   - Field: ‘result’
[17:40:41.952]   - Field: ‘asynchronous’
[17:40:41.952]   - Field: ‘calls’
[17:40:41.952]   - Field: ‘globals’
[17:40:41.952]   - Field: ‘stdout’
[17:40:41.952]   - Field: ‘earlySignal’
[17:40:41.953]   - Field: ‘lazy’
[17:40:41.953]   - Field: ‘state’
[17:40:41.953] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.953] - Launch lazy future ...
[17:40:41.953] Packages needed by the future expression (n = 0): <none>
[17:40:41.953] Packages needed by future strategies (n = 0): <none>
[17:40:41.954] {
[17:40:41.954]     {
[17:40:41.954]         {
[17:40:41.954]             ...future.startTime <- base::Sys.time()
[17:40:41.954]             {
[17:40:41.954]                 {
[17:40:41.954]                   {
[17:40:41.954]                     base::local({
[17:40:41.954]                       has_future <- base::requireNamespace("future", 
[17:40:41.954]                         quietly = TRUE)
[17:40:41.954]                       if (has_future) {
[17:40:41.954]                         ns <- base::getNamespace("future")
[17:40:41.954]                         version <- ns[[".package"]][["version"]]
[17:40:41.954]                         if (is.null(version)) 
[17:40:41.954]                           version <- utils::packageVersion("future")
[17:40:41.954]                       }
[17:40:41.954]                       else {
[17:40:41.954]                         version <- NULL
[17:40:41.954]                       }
[17:40:41.954]                       if (!has_future || version < "1.8.0") {
[17:40:41.954]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.954]                           "", base::R.version$version.string), 
[17:40:41.954]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.954]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.954]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.954]                             "release", "version")], collapse = " "), 
[17:40:41.954]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.954]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.954]                           info)
[17:40:41.954]                         info <- base::paste(info, collapse = "; ")
[17:40:41.954]                         if (!has_future) {
[17:40:41.954]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.954]                             info)
[17:40:41.954]                         }
[17:40:41.954]                         else {
[17:40:41.954]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.954]                             info, version)
[17:40:41.954]                         }
[17:40:41.954]                         base::stop(msg)
[17:40:41.954]                       }
[17:40:41.954]                     })
[17:40:41.954]                   }
[17:40:41.954]                   ...future.strategy.old <- future::plan("list")
[17:40:41.954]                   options(future.plan = NULL)
[17:40:41.954]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.954]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.954]                 }
[17:40:41.954]                 ...future.workdir <- getwd()
[17:40:41.954]             }
[17:40:41.954]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.954]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.954]         }
[17:40:41.954]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.954]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.954]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.954]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.954]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.954]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.954]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.954]             base::names(...future.oldOptions))
[17:40:41.954]     }
[17:40:41.954]     if (FALSE) {
[17:40:41.954]     }
[17:40:41.954]     else {
[17:40:41.954]         if (TRUE) {
[17:40:41.954]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.954]                 open = "w")
[17:40:41.954]         }
[17:40:41.954]         else {
[17:40:41.954]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.954]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.954]         }
[17:40:41.954]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.954]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.954]             base::sink(type = "output", split = FALSE)
[17:40:41.954]             base::close(...future.stdout)
[17:40:41.954]         }, add = TRUE)
[17:40:41.954]     }
[17:40:41.954]     ...future.frame <- base::sys.nframe()
[17:40:41.954]     ...future.conditions <- base::list()
[17:40:41.954]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.954]     if (FALSE) {
[17:40:41.954]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.954]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.954]     }
[17:40:41.954]     ...future.result <- base::tryCatch({
[17:40:41.954]         base::withCallingHandlers({
[17:40:41.954]             ...future.value <- base::withVisible(base::local(2))
[17:40:41.954]             future::FutureResult(value = ...future.value$value, 
[17:40:41.954]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.954]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.954]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.954]                     ...future.globalenv.names))
[17:40:41.954]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.954]         }, condition = base::local({
[17:40:41.954]             c <- base::c
[17:40:41.954]             inherits <- base::inherits
[17:40:41.954]             invokeRestart <- base::invokeRestart
[17:40:41.954]             length <- base::length
[17:40:41.954]             list <- base::list
[17:40:41.954]             seq.int <- base::seq.int
[17:40:41.954]             signalCondition <- base::signalCondition
[17:40:41.954]             sys.calls <- base::sys.calls
[17:40:41.954]             `[[` <- base::`[[`
[17:40:41.954]             `+` <- base::`+`
[17:40:41.954]             `<<-` <- base::`<<-`
[17:40:41.954]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.954]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.954]                   3L)]
[17:40:41.954]             }
[17:40:41.954]             function(cond) {
[17:40:41.954]                 is_error <- inherits(cond, "error")
[17:40:41.954]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.954]                   NULL)
[17:40:41.954]                 if (is_error) {
[17:40:41.954]                   sessionInformation <- function() {
[17:40:41.954]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.954]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.954]                       search = base::search(), system = base::Sys.info())
[17:40:41.954]                   }
[17:40:41.954]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.954]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.954]                     cond$call), session = sessionInformation(), 
[17:40:41.954]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.954]                   signalCondition(cond)
[17:40:41.954]                 }
[17:40:41.954]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.954]                 "immediateCondition"))) {
[17:40:41.954]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.954]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.954]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.954]                   if (TRUE && !signal) {
[17:40:41.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.954]                     {
[17:40:41.954]                       inherits <- base::inherits
[17:40:41.954]                       invokeRestart <- base::invokeRestart
[17:40:41.954]                       is.null <- base::is.null
[17:40:41.954]                       muffled <- FALSE
[17:40:41.954]                       if (inherits(cond, "message")) {
[17:40:41.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.954]                         if (muffled) 
[17:40:41.954]                           invokeRestart("muffleMessage")
[17:40:41.954]                       }
[17:40:41.954]                       else if (inherits(cond, "warning")) {
[17:40:41.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.954]                         if (muffled) 
[17:40:41.954]                           invokeRestart("muffleWarning")
[17:40:41.954]                       }
[17:40:41.954]                       else if (inherits(cond, "condition")) {
[17:40:41.954]                         if (!is.null(pattern)) {
[17:40:41.954]                           computeRestarts <- base::computeRestarts
[17:40:41.954]                           grepl <- base::grepl
[17:40:41.954]                           restarts <- computeRestarts(cond)
[17:40:41.954]                           for (restart in restarts) {
[17:40:41.954]                             name <- restart$name
[17:40:41.954]                             if (is.null(name)) 
[17:40:41.954]                               next
[17:40:41.954]                             if (!grepl(pattern, name)) 
[17:40:41.954]                               next
[17:40:41.954]                             invokeRestart(restart)
[17:40:41.954]                             muffled <- TRUE
[17:40:41.954]                             break
[17:40:41.954]                           }
[17:40:41.954]                         }
[17:40:41.954]                       }
[17:40:41.954]                       invisible(muffled)
[17:40:41.954]                     }
[17:40:41.954]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.954]                   }
[17:40:41.954]                 }
[17:40:41.954]                 else {
[17:40:41.954]                   if (TRUE) {
[17:40:41.954]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.954]                     {
[17:40:41.954]                       inherits <- base::inherits
[17:40:41.954]                       invokeRestart <- base::invokeRestart
[17:40:41.954]                       is.null <- base::is.null
[17:40:41.954]                       muffled <- FALSE
[17:40:41.954]                       if (inherits(cond, "message")) {
[17:40:41.954]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.954]                         if (muffled) 
[17:40:41.954]                           invokeRestart("muffleMessage")
[17:40:41.954]                       }
[17:40:41.954]                       else if (inherits(cond, "warning")) {
[17:40:41.954]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.954]                         if (muffled) 
[17:40:41.954]                           invokeRestart("muffleWarning")
[17:40:41.954]                       }
[17:40:41.954]                       else if (inherits(cond, "condition")) {
[17:40:41.954]                         if (!is.null(pattern)) {
[17:40:41.954]                           computeRestarts <- base::computeRestarts
[17:40:41.954]                           grepl <- base::grepl
[17:40:41.954]                           restarts <- computeRestarts(cond)
[17:40:41.954]                           for (restart in restarts) {
[17:40:41.954]                             name <- restart$name
[17:40:41.954]                             if (is.null(name)) 
[17:40:41.954]                               next
[17:40:41.954]                             if (!grepl(pattern, name)) 
[17:40:41.954]                               next
[17:40:41.954]                             invokeRestart(restart)
[17:40:41.954]                             muffled <- TRUE
[17:40:41.954]                             break
[17:40:41.954]                           }
[17:40:41.954]                         }
[17:40:41.954]                       }
[17:40:41.954]                       invisible(muffled)
[17:40:41.954]                     }
[17:40:41.954]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.954]                   }
[17:40:41.954]                 }
[17:40:41.954]             }
[17:40:41.954]         }))
[17:40:41.954]     }, error = function(ex) {
[17:40:41.954]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.954]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.954]                 ...future.rng), started = ...future.startTime, 
[17:40:41.954]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.954]             version = "1.8"), class = "FutureResult")
[17:40:41.954]     }, finally = {
[17:40:41.954]         if (!identical(...future.workdir, getwd())) 
[17:40:41.954]             setwd(...future.workdir)
[17:40:41.954]         {
[17:40:41.954]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.954]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.954]             }
[17:40:41.954]             base::options(...future.oldOptions)
[17:40:41.954]             if (.Platform$OS.type == "windows") {
[17:40:41.954]                 old_names <- names(...future.oldEnvVars)
[17:40:41.954]                 envs <- base::Sys.getenv()
[17:40:41.954]                 names <- names(envs)
[17:40:41.954]                 common <- intersect(names, old_names)
[17:40:41.954]                 added <- setdiff(names, old_names)
[17:40:41.954]                 removed <- setdiff(old_names, names)
[17:40:41.954]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.954]                   envs[common]]
[17:40:41.954]                 NAMES <- toupper(changed)
[17:40:41.954]                 args <- list()
[17:40:41.954]                 for (kk in seq_along(NAMES)) {
[17:40:41.954]                   name <- changed[[kk]]
[17:40:41.954]                   NAME <- NAMES[[kk]]
[17:40:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.954]                     next
[17:40:41.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.954]                 }
[17:40:41.954]                 NAMES <- toupper(added)
[17:40:41.954]                 for (kk in seq_along(NAMES)) {
[17:40:41.954]                   name <- added[[kk]]
[17:40:41.954]                   NAME <- NAMES[[kk]]
[17:40:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.954]                     next
[17:40:41.954]                   args[[name]] <- ""
[17:40:41.954]                 }
[17:40:41.954]                 NAMES <- toupper(removed)
[17:40:41.954]                 for (kk in seq_along(NAMES)) {
[17:40:41.954]                   name <- removed[[kk]]
[17:40:41.954]                   NAME <- NAMES[[kk]]
[17:40:41.954]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.954]                     next
[17:40:41.954]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.954]                 }
[17:40:41.954]                 if (length(args) > 0) 
[17:40:41.954]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.954]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.954]             }
[17:40:41.954]             else {
[17:40:41.954]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.954]             }
[17:40:41.954]             {
[17:40:41.954]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.954]                   0L) {
[17:40:41.954]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.954]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.954]                   base::options(opts)
[17:40:41.954]                 }
[17:40:41.954]                 {
[17:40:41.954]                   {
[17:40:41.954]                     NULL
[17:40:41.954]                     RNGkind("Mersenne-Twister")
[17:40:41.954]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.954]                       inherits = FALSE)
[17:40:41.954]                   }
[17:40:41.954]                   options(future.plan = NULL)
[17:40:41.954]                   if (is.na(NA_character_)) 
[17:40:41.954]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.954]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.954]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.954]                     .init = FALSE)
[17:40:41.954]                 }
[17:40:41.954]             }
[17:40:41.954]         }
[17:40:41.954]     })
[17:40:41.954]     if (TRUE) {
[17:40:41.954]         base::sink(type = "output", split = FALSE)
[17:40:41.954]         if (TRUE) {
[17:40:41.954]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.954]         }
[17:40:41.954]         else {
[17:40:41.954]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.954]         }
[17:40:41.954]         base::close(...future.stdout)
[17:40:41.954]         ...future.stdout <- NULL
[17:40:41.954]     }
[17:40:41.954]     ...future.result$conditions <- ...future.conditions
[17:40:41.954]     ...future.result$finished <- base::Sys.time()
[17:40:41.954]     ...future.result
[17:40:41.954] }
[17:40:41.955] plan(): Setting new future strategy stack:
[17:40:41.955] List of future strategies:
[17:40:41.955] 1. sequential:
[17:40:41.955]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.955]    - tweaked: FALSE
[17:40:41.955]    - call: NULL
[17:40:41.956] plan(): nbrOfWorkers() = 1
[17:40:41.957] plan(): Setting new future strategy stack:
[17:40:41.957] List of future strategies:
[17:40:41.957] 1. sequential:
[17:40:41.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.957]    - tweaked: FALSE
[17:40:41.957]    - call: plan(strategy)
[17:40:41.957] plan(): nbrOfWorkers() = 1
[17:40:41.957] SequentialFuture started (and completed)
[17:40:41.957] - Launch lazy future ... done
[17:40:41.957] run() for ‘SequentialFuture’ ... done
[17:40:41.958] resolve() on environment ...
[17:40:41.958]  recursive: 0
[17:40:41.958]  elements: [3] ‘a’, ‘b’, ‘c’
[17:40:41.959] resolved() for ‘SequentialFuture’ ...
[17:40:41.959] - state: ‘finished’
[17:40:41.959] - run: TRUE
[17:40:41.959] - result: ‘FutureResult’
[17:40:41.959] resolved() for ‘SequentialFuture’ ... done
[17:40:41.959] Future #1
[17:40:41.959]  length: 2 (resolved future 1)
[17:40:41.959] resolved() for ‘SequentialFuture’ ...
[17:40:41.959] - state: ‘finished’
[17:40:41.959] - run: TRUE
[17:40:41.960] - result: ‘FutureResult’
[17:40:41.960] resolved() for ‘SequentialFuture’ ... done
[17:40:41.960] Future #2
[17:40:41.960]  length: 1 (resolved future 2)
[17:40:41.960]  length: 0 (resolved future 3)
[17:40:41.960] resolve() on environment ... DONE
[17:40:41.960] resolved() for ‘SequentialFuture’ ...
[17:40:41.960] - state: ‘finished’
[17:40:41.960] - run: TRUE
[17:40:41.960] - result: ‘FutureResult’
[17:40:41.960] resolved() for ‘SequentialFuture’ ... done
[17:40:41.961] resolved() for ‘SequentialFuture’ ...
[17:40:41.961] - state: ‘finished’
[17:40:41.961] - run: TRUE
[17:40:41.961] - result: ‘FutureResult’
[17:40:41.961] resolved() for ‘SequentialFuture’ ... done
[17:40:41.962] getGlobalsAndPackages() ...
[17:40:41.962] Searching for globals...
[17:40:41.962] - globals found: [1] ‘{’
[17:40:41.963] Searching for globals ... DONE
[17:40:41.963] Resolving globals: FALSE
[17:40:41.963] 
[17:40:41.963] 
[17:40:41.963] getGlobalsAndPackages() ... DONE
[17:40:41.963] run() for ‘Future’ ...
[17:40:41.963] - state: ‘created’
[17:40:41.964] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.964] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.964]   - Field: ‘label’
[17:40:41.964]   - Field: ‘local’
[17:40:41.964]   - Field: ‘owner’
[17:40:41.964]   - Field: ‘envir’
[17:40:41.964]   - Field: ‘packages’
[17:40:41.965]   - Field: ‘gc’
[17:40:41.965]   - Field: ‘conditions’
[17:40:41.965]   - Field: ‘expr’
[17:40:41.965]   - Field: ‘uuid’
[17:40:41.965]   - Field: ‘seed’
[17:40:41.965]   - Field: ‘version’
[17:40:41.965]   - Field: ‘result’
[17:40:41.965]   - Field: ‘asynchronous’
[17:40:41.966]   - Field: ‘calls’
[17:40:41.966]   - Field: ‘globals’
[17:40:41.966]   - Field: ‘stdout’
[17:40:41.966]   - Field: ‘earlySignal’
[17:40:41.966]   - Field: ‘lazy’
[17:40:41.966]   - Field: ‘state’
[17:40:41.966] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.966] - Launch lazy future ...
[17:40:41.966] Packages needed by the future expression (n = 0): <none>
[17:40:41.967] Packages needed by future strategies (n = 0): <none>
[17:40:41.967] {
[17:40:41.967]     {
[17:40:41.967]         {
[17:40:41.967]             ...future.startTime <- base::Sys.time()
[17:40:41.967]             {
[17:40:41.967]                 {
[17:40:41.967]                   {
[17:40:41.967]                     base::local({
[17:40:41.967]                       has_future <- base::requireNamespace("future", 
[17:40:41.967]                         quietly = TRUE)
[17:40:41.967]                       if (has_future) {
[17:40:41.967]                         ns <- base::getNamespace("future")
[17:40:41.967]                         version <- ns[[".package"]][["version"]]
[17:40:41.967]                         if (is.null(version)) 
[17:40:41.967]                           version <- utils::packageVersion("future")
[17:40:41.967]                       }
[17:40:41.967]                       else {
[17:40:41.967]                         version <- NULL
[17:40:41.967]                       }
[17:40:41.967]                       if (!has_future || version < "1.8.0") {
[17:40:41.967]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.967]                           "", base::R.version$version.string), 
[17:40:41.967]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.967]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.967]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.967]                             "release", "version")], collapse = " "), 
[17:40:41.967]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.967]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.967]                           info)
[17:40:41.967]                         info <- base::paste(info, collapse = "; ")
[17:40:41.967]                         if (!has_future) {
[17:40:41.967]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.967]                             info)
[17:40:41.967]                         }
[17:40:41.967]                         else {
[17:40:41.967]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.967]                             info, version)
[17:40:41.967]                         }
[17:40:41.967]                         base::stop(msg)
[17:40:41.967]                       }
[17:40:41.967]                     })
[17:40:41.967]                   }
[17:40:41.967]                   ...future.strategy.old <- future::plan("list")
[17:40:41.967]                   options(future.plan = NULL)
[17:40:41.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.967]                 }
[17:40:41.967]                 ...future.workdir <- getwd()
[17:40:41.967]             }
[17:40:41.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.967]         }
[17:40:41.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.967]             base::names(...future.oldOptions))
[17:40:41.967]     }
[17:40:41.967]     if (FALSE) {
[17:40:41.967]     }
[17:40:41.967]     else {
[17:40:41.967]         if (TRUE) {
[17:40:41.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.967]                 open = "w")
[17:40:41.967]         }
[17:40:41.967]         else {
[17:40:41.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.967]         }
[17:40:41.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.967]             base::sink(type = "output", split = FALSE)
[17:40:41.967]             base::close(...future.stdout)
[17:40:41.967]         }, add = TRUE)
[17:40:41.967]     }
[17:40:41.967]     ...future.frame <- base::sys.nframe()
[17:40:41.967]     ...future.conditions <- base::list()
[17:40:41.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.967]     if (FALSE) {
[17:40:41.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.967]     }
[17:40:41.967]     ...future.result <- base::tryCatch({
[17:40:41.967]         base::withCallingHandlers({
[17:40:41.967]             ...future.value <- base::withVisible(base::local({
[17:40:41.967]                 1
[17:40:41.967]             }))
[17:40:41.967]             future::FutureResult(value = ...future.value$value, 
[17:40:41.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.967]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.967]                     ...future.globalenv.names))
[17:40:41.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.967]         }, condition = base::local({
[17:40:41.967]             c <- base::c
[17:40:41.967]             inherits <- base::inherits
[17:40:41.967]             invokeRestart <- base::invokeRestart
[17:40:41.967]             length <- base::length
[17:40:41.967]             list <- base::list
[17:40:41.967]             seq.int <- base::seq.int
[17:40:41.967]             signalCondition <- base::signalCondition
[17:40:41.967]             sys.calls <- base::sys.calls
[17:40:41.967]             `[[` <- base::`[[`
[17:40:41.967]             `+` <- base::`+`
[17:40:41.967]             `<<-` <- base::`<<-`
[17:40:41.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.967]                   3L)]
[17:40:41.967]             }
[17:40:41.967]             function(cond) {
[17:40:41.967]                 is_error <- inherits(cond, "error")
[17:40:41.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.967]                   NULL)
[17:40:41.967]                 if (is_error) {
[17:40:41.967]                   sessionInformation <- function() {
[17:40:41.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.967]                       search = base::search(), system = base::Sys.info())
[17:40:41.967]                   }
[17:40:41.967]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.967]                     cond$call), session = sessionInformation(), 
[17:40:41.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.967]                   signalCondition(cond)
[17:40:41.967]                 }
[17:40:41.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.967]                 "immediateCondition"))) {
[17:40:41.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.967]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.967]                   if (TRUE && !signal) {
[17:40:41.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.967]                     {
[17:40:41.967]                       inherits <- base::inherits
[17:40:41.967]                       invokeRestart <- base::invokeRestart
[17:40:41.967]                       is.null <- base::is.null
[17:40:41.967]                       muffled <- FALSE
[17:40:41.967]                       if (inherits(cond, "message")) {
[17:40:41.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.967]                         if (muffled) 
[17:40:41.967]                           invokeRestart("muffleMessage")
[17:40:41.967]                       }
[17:40:41.967]                       else if (inherits(cond, "warning")) {
[17:40:41.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.967]                         if (muffled) 
[17:40:41.967]                           invokeRestart("muffleWarning")
[17:40:41.967]                       }
[17:40:41.967]                       else if (inherits(cond, "condition")) {
[17:40:41.967]                         if (!is.null(pattern)) {
[17:40:41.967]                           computeRestarts <- base::computeRestarts
[17:40:41.967]                           grepl <- base::grepl
[17:40:41.967]                           restarts <- computeRestarts(cond)
[17:40:41.967]                           for (restart in restarts) {
[17:40:41.967]                             name <- restart$name
[17:40:41.967]                             if (is.null(name)) 
[17:40:41.967]                               next
[17:40:41.967]                             if (!grepl(pattern, name)) 
[17:40:41.967]                               next
[17:40:41.967]                             invokeRestart(restart)
[17:40:41.967]                             muffled <- TRUE
[17:40:41.967]                             break
[17:40:41.967]                           }
[17:40:41.967]                         }
[17:40:41.967]                       }
[17:40:41.967]                       invisible(muffled)
[17:40:41.967]                     }
[17:40:41.967]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.967]                   }
[17:40:41.967]                 }
[17:40:41.967]                 else {
[17:40:41.967]                   if (TRUE) {
[17:40:41.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.967]                     {
[17:40:41.967]                       inherits <- base::inherits
[17:40:41.967]                       invokeRestart <- base::invokeRestart
[17:40:41.967]                       is.null <- base::is.null
[17:40:41.967]                       muffled <- FALSE
[17:40:41.967]                       if (inherits(cond, "message")) {
[17:40:41.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.967]                         if (muffled) 
[17:40:41.967]                           invokeRestart("muffleMessage")
[17:40:41.967]                       }
[17:40:41.967]                       else if (inherits(cond, "warning")) {
[17:40:41.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.967]                         if (muffled) 
[17:40:41.967]                           invokeRestart("muffleWarning")
[17:40:41.967]                       }
[17:40:41.967]                       else if (inherits(cond, "condition")) {
[17:40:41.967]                         if (!is.null(pattern)) {
[17:40:41.967]                           computeRestarts <- base::computeRestarts
[17:40:41.967]                           grepl <- base::grepl
[17:40:41.967]                           restarts <- computeRestarts(cond)
[17:40:41.967]                           for (restart in restarts) {
[17:40:41.967]                             name <- restart$name
[17:40:41.967]                             if (is.null(name)) 
[17:40:41.967]                               next
[17:40:41.967]                             if (!grepl(pattern, name)) 
[17:40:41.967]                               next
[17:40:41.967]                             invokeRestart(restart)
[17:40:41.967]                             muffled <- TRUE
[17:40:41.967]                             break
[17:40:41.967]                           }
[17:40:41.967]                         }
[17:40:41.967]                       }
[17:40:41.967]                       invisible(muffled)
[17:40:41.967]                     }
[17:40:41.967]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.967]                   }
[17:40:41.967]                 }
[17:40:41.967]             }
[17:40:41.967]         }))
[17:40:41.967]     }, error = function(ex) {
[17:40:41.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.967]                 ...future.rng), started = ...future.startTime, 
[17:40:41.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.967]             version = "1.8"), class = "FutureResult")
[17:40:41.967]     }, finally = {
[17:40:41.967]         if (!identical(...future.workdir, getwd())) 
[17:40:41.967]             setwd(...future.workdir)
[17:40:41.967]         {
[17:40:41.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.967]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.967]             }
[17:40:41.967]             base::options(...future.oldOptions)
[17:40:41.967]             if (.Platform$OS.type == "windows") {
[17:40:41.967]                 old_names <- names(...future.oldEnvVars)
[17:40:41.967]                 envs <- base::Sys.getenv()
[17:40:41.967]                 names <- names(envs)
[17:40:41.967]                 common <- intersect(names, old_names)
[17:40:41.967]                 added <- setdiff(names, old_names)
[17:40:41.967]                 removed <- setdiff(old_names, names)
[17:40:41.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.967]                   envs[common]]
[17:40:41.967]                 NAMES <- toupper(changed)
[17:40:41.967]                 args <- list()
[17:40:41.967]                 for (kk in seq_along(NAMES)) {
[17:40:41.967]                   name <- changed[[kk]]
[17:40:41.967]                   NAME <- NAMES[[kk]]
[17:40:41.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.967]                     next
[17:40:41.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.967]                 }
[17:40:41.967]                 NAMES <- toupper(added)
[17:40:41.967]                 for (kk in seq_along(NAMES)) {
[17:40:41.967]                   name <- added[[kk]]
[17:40:41.967]                   NAME <- NAMES[[kk]]
[17:40:41.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.967]                     next
[17:40:41.967]                   args[[name]] <- ""
[17:40:41.967]                 }
[17:40:41.967]                 NAMES <- toupper(removed)
[17:40:41.967]                 for (kk in seq_along(NAMES)) {
[17:40:41.967]                   name <- removed[[kk]]
[17:40:41.967]                   NAME <- NAMES[[kk]]
[17:40:41.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.967]                     next
[17:40:41.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.967]                 }
[17:40:41.967]                 if (length(args) > 0) 
[17:40:41.967]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.967]             }
[17:40:41.967]             else {
[17:40:41.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.967]             }
[17:40:41.967]             {
[17:40:41.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.967]                   0L) {
[17:40:41.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.967]                   base::options(opts)
[17:40:41.967]                 }
[17:40:41.967]                 {
[17:40:41.967]                   {
[17:40:41.967]                     NULL
[17:40:41.967]                     RNGkind("Mersenne-Twister")
[17:40:41.967]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.967]                       inherits = FALSE)
[17:40:41.967]                   }
[17:40:41.967]                   options(future.plan = NULL)
[17:40:41.967]                   if (is.na(NA_character_)) 
[17:40:41.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.967]                     .init = FALSE)
[17:40:41.967]                 }
[17:40:41.967]             }
[17:40:41.967]         }
[17:40:41.967]     })
[17:40:41.967]     if (TRUE) {
[17:40:41.967]         base::sink(type = "output", split = FALSE)
[17:40:41.967]         if (TRUE) {
[17:40:41.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.967]         }
[17:40:41.967]         else {
[17:40:41.967]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.967]         }
[17:40:41.967]         base::close(...future.stdout)
[17:40:41.967]         ...future.stdout <- NULL
[17:40:41.967]     }
[17:40:41.967]     ...future.result$conditions <- ...future.conditions
[17:40:41.967]     ...future.result$finished <- base::Sys.time()
[17:40:41.967]     ...future.result
[17:40:41.967] }
[17:40:41.969] plan(): Setting new future strategy stack:
[17:40:41.969] List of future strategies:
[17:40:41.969] 1. sequential:
[17:40:41.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.969]    - tweaked: FALSE
[17:40:41.969]    - call: NULL
[17:40:41.970] plan(): nbrOfWorkers() = 1
[17:40:41.970] plan(): Setting new future strategy stack:
[17:40:41.971] List of future strategies:
[17:40:41.971] 1. sequential:
[17:40:41.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.971]    - tweaked: FALSE
[17:40:41.971]    - call: plan(strategy)
[17:40:41.971] plan(): nbrOfWorkers() = 1
[17:40:41.971] SequentialFuture started (and completed)
[17:40:41.971] - Launch lazy future ... done
[17:40:41.971] run() for ‘SequentialFuture’ ... done
[17:40:41.972] getGlobalsAndPackages() ...
[17:40:41.972] Searching for globals...
[17:40:41.973] - globals found: [1] ‘{’
[17:40:41.973] Searching for globals ... DONE
[17:40:41.973] Resolving globals: FALSE
[17:40:41.973] 
[17:40:41.974] 
[17:40:41.974] getGlobalsAndPackages() ... DONE
[17:40:41.974] run() for ‘Future’ ...
[17:40:41.974] - state: ‘created’
[17:40:41.974] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.975] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.975] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.975]   - Field: ‘label’
[17:40:41.975]   - Field: ‘local’
[17:40:41.975]   - Field: ‘owner’
[17:40:41.975]   - Field: ‘envir’
[17:40:41.975]   - Field: ‘packages’
[17:40:41.976]   - Field: ‘gc’
[17:40:41.976]   - Field: ‘conditions’
[17:40:41.976]   - Field: ‘expr’
[17:40:41.976]   - Field: ‘uuid’
[17:40:41.976]   - Field: ‘seed’
[17:40:41.976]   - Field: ‘version’
[17:40:41.976]   - Field: ‘result’
[17:40:41.976]   - Field: ‘asynchronous’
[17:40:41.976]   - Field: ‘calls’
[17:40:41.976]   - Field: ‘globals’
[17:40:41.977]   - Field: ‘stdout’
[17:40:41.977]   - Field: ‘earlySignal’
[17:40:41.977]   - Field: ‘lazy’
[17:40:41.977]   - Field: ‘state’
[17:40:41.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.977] - Launch lazy future ...
[17:40:41.977] Packages needed by the future expression (n = 0): <none>
[17:40:41.977] Packages needed by future strategies (n = 0): <none>
[17:40:41.978] {
[17:40:41.978]     {
[17:40:41.978]         {
[17:40:41.978]             ...future.startTime <- base::Sys.time()
[17:40:41.978]             {
[17:40:41.978]                 {
[17:40:41.978]                   {
[17:40:41.978]                     base::local({
[17:40:41.978]                       has_future <- base::requireNamespace("future", 
[17:40:41.978]                         quietly = TRUE)
[17:40:41.978]                       if (has_future) {
[17:40:41.978]                         ns <- base::getNamespace("future")
[17:40:41.978]                         version <- ns[[".package"]][["version"]]
[17:40:41.978]                         if (is.null(version)) 
[17:40:41.978]                           version <- utils::packageVersion("future")
[17:40:41.978]                       }
[17:40:41.978]                       else {
[17:40:41.978]                         version <- NULL
[17:40:41.978]                       }
[17:40:41.978]                       if (!has_future || version < "1.8.0") {
[17:40:41.978]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.978]                           "", base::R.version$version.string), 
[17:40:41.978]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.978]                             "release", "version")], collapse = " "), 
[17:40:41.978]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.978]                           info)
[17:40:41.978]                         info <- base::paste(info, collapse = "; ")
[17:40:41.978]                         if (!has_future) {
[17:40:41.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.978]                             info)
[17:40:41.978]                         }
[17:40:41.978]                         else {
[17:40:41.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.978]                             info, version)
[17:40:41.978]                         }
[17:40:41.978]                         base::stop(msg)
[17:40:41.978]                       }
[17:40:41.978]                     })
[17:40:41.978]                   }
[17:40:41.978]                   ...future.strategy.old <- future::plan("list")
[17:40:41.978]                   options(future.plan = NULL)
[17:40:41.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.978]                 }
[17:40:41.978]                 ...future.workdir <- getwd()
[17:40:41.978]             }
[17:40:41.978]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.978]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.978]         }
[17:40:41.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.978]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.978]             base::names(...future.oldOptions))
[17:40:41.978]     }
[17:40:41.978]     if (FALSE) {
[17:40:41.978]     }
[17:40:41.978]     else {
[17:40:41.978]         if (TRUE) {
[17:40:41.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.978]                 open = "w")
[17:40:41.978]         }
[17:40:41.978]         else {
[17:40:41.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.978]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.978]         }
[17:40:41.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.978]             base::sink(type = "output", split = FALSE)
[17:40:41.978]             base::close(...future.stdout)
[17:40:41.978]         }, add = TRUE)
[17:40:41.978]     }
[17:40:41.978]     ...future.frame <- base::sys.nframe()
[17:40:41.978]     ...future.conditions <- base::list()
[17:40:41.978]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.978]     if (FALSE) {
[17:40:41.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.978]     }
[17:40:41.978]     ...future.result <- base::tryCatch({
[17:40:41.978]         base::withCallingHandlers({
[17:40:41.978]             ...future.value <- base::withVisible(base::local({
[17:40:41.978]                 2
[17:40:41.978]             }))
[17:40:41.978]             future::FutureResult(value = ...future.value$value, 
[17:40:41.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.978]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.978]                     ...future.globalenv.names))
[17:40:41.978]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.978]         }, condition = base::local({
[17:40:41.978]             c <- base::c
[17:40:41.978]             inherits <- base::inherits
[17:40:41.978]             invokeRestart <- base::invokeRestart
[17:40:41.978]             length <- base::length
[17:40:41.978]             list <- base::list
[17:40:41.978]             seq.int <- base::seq.int
[17:40:41.978]             signalCondition <- base::signalCondition
[17:40:41.978]             sys.calls <- base::sys.calls
[17:40:41.978]             `[[` <- base::`[[`
[17:40:41.978]             `+` <- base::`+`
[17:40:41.978]             `<<-` <- base::`<<-`
[17:40:41.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.978]                   3L)]
[17:40:41.978]             }
[17:40:41.978]             function(cond) {
[17:40:41.978]                 is_error <- inherits(cond, "error")
[17:40:41.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.978]                   NULL)
[17:40:41.978]                 if (is_error) {
[17:40:41.978]                   sessionInformation <- function() {
[17:40:41.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.978]                       search = base::search(), system = base::Sys.info())
[17:40:41.978]                   }
[17:40:41.978]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.978]                     cond$call), session = sessionInformation(), 
[17:40:41.978]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.978]                   signalCondition(cond)
[17:40:41.978]                 }
[17:40:41.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.978]                 "immediateCondition"))) {
[17:40:41.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.978]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.978]                   if (TRUE && !signal) {
[17:40:41.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.978]                     {
[17:40:41.978]                       inherits <- base::inherits
[17:40:41.978]                       invokeRestart <- base::invokeRestart
[17:40:41.978]                       is.null <- base::is.null
[17:40:41.978]                       muffled <- FALSE
[17:40:41.978]                       if (inherits(cond, "message")) {
[17:40:41.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.978]                         if (muffled) 
[17:40:41.978]                           invokeRestart("muffleMessage")
[17:40:41.978]                       }
[17:40:41.978]                       else if (inherits(cond, "warning")) {
[17:40:41.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.978]                         if (muffled) 
[17:40:41.978]                           invokeRestart("muffleWarning")
[17:40:41.978]                       }
[17:40:41.978]                       else if (inherits(cond, "condition")) {
[17:40:41.978]                         if (!is.null(pattern)) {
[17:40:41.978]                           computeRestarts <- base::computeRestarts
[17:40:41.978]                           grepl <- base::grepl
[17:40:41.978]                           restarts <- computeRestarts(cond)
[17:40:41.978]                           for (restart in restarts) {
[17:40:41.978]                             name <- restart$name
[17:40:41.978]                             if (is.null(name)) 
[17:40:41.978]                               next
[17:40:41.978]                             if (!grepl(pattern, name)) 
[17:40:41.978]                               next
[17:40:41.978]                             invokeRestart(restart)
[17:40:41.978]                             muffled <- TRUE
[17:40:41.978]                             break
[17:40:41.978]                           }
[17:40:41.978]                         }
[17:40:41.978]                       }
[17:40:41.978]                       invisible(muffled)
[17:40:41.978]                     }
[17:40:41.978]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.978]                   }
[17:40:41.978]                 }
[17:40:41.978]                 else {
[17:40:41.978]                   if (TRUE) {
[17:40:41.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.978]                     {
[17:40:41.978]                       inherits <- base::inherits
[17:40:41.978]                       invokeRestart <- base::invokeRestart
[17:40:41.978]                       is.null <- base::is.null
[17:40:41.978]                       muffled <- FALSE
[17:40:41.978]                       if (inherits(cond, "message")) {
[17:40:41.978]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.978]                         if (muffled) 
[17:40:41.978]                           invokeRestart("muffleMessage")
[17:40:41.978]                       }
[17:40:41.978]                       else if (inherits(cond, "warning")) {
[17:40:41.978]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.978]                         if (muffled) 
[17:40:41.978]                           invokeRestart("muffleWarning")
[17:40:41.978]                       }
[17:40:41.978]                       else if (inherits(cond, "condition")) {
[17:40:41.978]                         if (!is.null(pattern)) {
[17:40:41.978]                           computeRestarts <- base::computeRestarts
[17:40:41.978]                           grepl <- base::grepl
[17:40:41.978]                           restarts <- computeRestarts(cond)
[17:40:41.978]                           for (restart in restarts) {
[17:40:41.978]                             name <- restart$name
[17:40:41.978]                             if (is.null(name)) 
[17:40:41.978]                               next
[17:40:41.978]                             if (!grepl(pattern, name)) 
[17:40:41.978]                               next
[17:40:41.978]                             invokeRestart(restart)
[17:40:41.978]                             muffled <- TRUE
[17:40:41.978]                             break
[17:40:41.978]                           }
[17:40:41.978]                         }
[17:40:41.978]                       }
[17:40:41.978]                       invisible(muffled)
[17:40:41.978]                     }
[17:40:41.978]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.978]                   }
[17:40:41.978]                 }
[17:40:41.978]             }
[17:40:41.978]         }))
[17:40:41.978]     }, error = function(ex) {
[17:40:41.978]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.978]                 ...future.rng), started = ...future.startTime, 
[17:40:41.978]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.978]             version = "1.8"), class = "FutureResult")
[17:40:41.978]     }, finally = {
[17:40:41.978]         if (!identical(...future.workdir, getwd())) 
[17:40:41.978]             setwd(...future.workdir)
[17:40:41.978]         {
[17:40:41.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.978]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.978]             }
[17:40:41.978]             base::options(...future.oldOptions)
[17:40:41.978]             if (.Platform$OS.type == "windows") {
[17:40:41.978]                 old_names <- names(...future.oldEnvVars)
[17:40:41.978]                 envs <- base::Sys.getenv()
[17:40:41.978]                 names <- names(envs)
[17:40:41.978]                 common <- intersect(names, old_names)
[17:40:41.978]                 added <- setdiff(names, old_names)
[17:40:41.978]                 removed <- setdiff(old_names, names)
[17:40:41.978]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.978]                   envs[common]]
[17:40:41.978]                 NAMES <- toupper(changed)
[17:40:41.978]                 args <- list()
[17:40:41.978]                 for (kk in seq_along(NAMES)) {
[17:40:41.978]                   name <- changed[[kk]]
[17:40:41.978]                   NAME <- NAMES[[kk]]
[17:40:41.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.978]                     next
[17:40:41.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.978]                 }
[17:40:41.978]                 NAMES <- toupper(added)
[17:40:41.978]                 for (kk in seq_along(NAMES)) {
[17:40:41.978]                   name <- added[[kk]]
[17:40:41.978]                   NAME <- NAMES[[kk]]
[17:40:41.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.978]                     next
[17:40:41.978]                   args[[name]] <- ""
[17:40:41.978]                 }
[17:40:41.978]                 NAMES <- toupper(removed)
[17:40:41.978]                 for (kk in seq_along(NAMES)) {
[17:40:41.978]                   name <- removed[[kk]]
[17:40:41.978]                   NAME <- NAMES[[kk]]
[17:40:41.978]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.978]                     next
[17:40:41.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.978]                 }
[17:40:41.978]                 if (length(args) > 0) 
[17:40:41.978]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.978]             }
[17:40:41.978]             else {
[17:40:41.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.978]             }
[17:40:41.978]             {
[17:40:41.978]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.978]                   0L) {
[17:40:41.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.978]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.978]                   base::options(opts)
[17:40:41.978]                 }
[17:40:41.978]                 {
[17:40:41.978]                   {
[17:40:41.978]                     NULL
[17:40:41.978]                     RNGkind("Mersenne-Twister")
[17:40:41.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.978]                       inherits = FALSE)
[17:40:41.978]                   }
[17:40:41.978]                   options(future.plan = NULL)
[17:40:41.978]                   if (is.na(NA_character_)) 
[17:40:41.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.978]                     .init = FALSE)
[17:40:41.978]                 }
[17:40:41.978]             }
[17:40:41.978]         }
[17:40:41.978]     })
[17:40:41.978]     if (TRUE) {
[17:40:41.978]         base::sink(type = "output", split = FALSE)
[17:40:41.978]         if (TRUE) {
[17:40:41.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.978]         }
[17:40:41.978]         else {
[17:40:41.978]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.978]         }
[17:40:41.978]         base::close(...future.stdout)
[17:40:41.978]         ...future.stdout <- NULL
[17:40:41.978]     }
[17:40:41.978]     ...future.result$conditions <- ...future.conditions
[17:40:41.978]     ...future.result$finished <- base::Sys.time()
[17:40:41.978]     ...future.result
[17:40:41.978] }
[17:40:41.979] plan(): Setting new future strategy stack:
[17:40:41.979] List of future strategies:
[17:40:41.979] 1. sequential:
[17:40:41.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.979]    - tweaked: FALSE
[17:40:41.979]    - call: NULL
[17:40:41.980] plan(): nbrOfWorkers() = 1
[17:40:41.981] plan(): Setting new future strategy stack:
[17:40:41.981] List of future strategies:
[17:40:41.981] 1. sequential:
[17:40:41.981]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.981]    - tweaked: FALSE
[17:40:41.981]    - call: plan(strategy)
[17:40:41.981] plan(): nbrOfWorkers() = 1
[17:40:41.981] SequentialFuture started (and completed)
[17:40:41.981] - Launch lazy future ... done
[17:40:41.982] run() for ‘SequentialFuture’ ... done
[17:40:41.984] resolve() on environment ...
[17:40:41.984]  recursive: 0
[17:40:41.984]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:40:41.985] resolved() for ‘SequentialFuture’ ...
[17:40:41.985] - state: ‘finished’
[17:40:41.985] - run: TRUE
[17:40:41.985] - result: ‘FutureResult’
[17:40:41.985] resolved() for ‘SequentialFuture’ ... done
[17:40:41.985] Future #1
[17:40:41.985]  length: 2 (resolved future 1)
[17:40:41.985] resolved() for ‘SequentialFuture’ ...
[17:40:41.985] - state: ‘finished’
[17:40:41.985] - run: TRUE
[17:40:41.986] - result: ‘FutureResult’
[17:40:41.986] resolved() for ‘SequentialFuture’ ... done
[17:40:41.986] Future #2
[17:40:41.986]  length: 1 (resolved future 2)
[17:40:41.986]  length: 0 (resolved future 3)
[17:40:41.986] resolve() on environment ... DONE
[17:40:41.986] getGlobalsAndPackages() ...
[17:40:41.987] Searching for globals...
[17:40:41.987] - globals found: [1] ‘{’
[17:40:41.987] Searching for globals ... DONE
[17:40:41.987] Resolving globals: FALSE
[17:40:41.988] 
[17:40:41.988] 
[17:40:41.988] getGlobalsAndPackages() ... DONE
[17:40:41.988] run() for ‘Future’ ...
[17:40:41.988] - state: ‘created’
[17:40:41.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.989]   - Field: ‘label’
[17:40:41.989]   - Field: ‘local’
[17:40:41.989]   - Field: ‘owner’
[17:40:41.989]   - Field: ‘envir’
[17:40:41.989]   - Field: ‘packages’
[17:40:41.989]   - Field: ‘gc’
[17:40:41.989]   - Field: ‘conditions’
[17:40:41.989]   - Field: ‘expr’
[17:40:41.989]   - Field: ‘uuid’
[17:40:41.990]   - Field: ‘seed’
[17:40:41.990]   - Field: ‘version’
[17:40:41.990]   - Field: ‘result’
[17:40:41.990]   - Field: ‘asynchronous’
[17:40:41.990]   - Field: ‘calls’
[17:40:41.990]   - Field: ‘globals’
[17:40:41.990]   - Field: ‘stdout’
[17:40:41.990]   - Field: ‘earlySignal’
[17:40:41.990]   - Field: ‘lazy’
[17:40:41.990]   - Field: ‘state’
[17:40:41.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.991] - Launch lazy future ...
[17:40:41.991] Packages needed by the future expression (n = 0): <none>
[17:40:41.991] Packages needed by future strategies (n = 0): <none>
[17:40:41.991] {
[17:40:41.991]     {
[17:40:41.991]         {
[17:40:41.991]             ...future.startTime <- base::Sys.time()
[17:40:41.991]             {
[17:40:41.991]                 {
[17:40:41.991]                   {
[17:40:41.991]                     base::local({
[17:40:41.991]                       has_future <- base::requireNamespace("future", 
[17:40:41.991]                         quietly = TRUE)
[17:40:41.991]                       if (has_future) {
[17:40:41.991]                         ns <- base::getNamespace("future")
[17:40:41.991]                         version <- ns[[".package"]][["version"]]
[17:40:41.991]                         if (is.null(version)) 
[17:40:41.991]                           version <- utils::packageVersion("future")
[17:40:41.991]                       }
[17:40:41.991]                       else {
[17:40:41.991]                         version <- NULL
[17:40:41.991]                       }
[17:40:41.991]                       if (!has_future || version < "1.8.0") {
[17:40:41.991]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:41.991]                           "", base::R.version$version.string), 
[17:40:41.991]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:41.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:41.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:41.991]                             "release", "version")], collapse = " "), 
[17:40:41.991]                           hostname = base::Sys.info()[["nodename"]])
[17:40:41.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:41.991]                           info)
[17:40:41.991]                         info <- base::paste(info, collapse = "; ")
[17:40:41.991]                         if (!has_future) {
[17:40:41.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:41.991]                             info)
[17:40:41.991]                         }
[17:40:41.991]                         else {
[17:40:41.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:41.991]                             info, version)
[17:40:41.991]                         }
[17:40:41.991]                         base::stop(msg)
[17:40:41.991]                       }
[17:40:41.991]                     })
[17:40:41.991]                   }
[17:40:41.991]                   ...future.strategy.old <- future::plan("list")
[17:40:41.991]                   options(future.plan = NULL)
[17:40:41.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:41.991]                 }
[17:40:41.991]                 ...future.workdir <- getwd()
[17:40:41.991]             }
[17:40:41.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:41.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:41.991]         }
[17:40:41.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:41.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:41.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:41.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:41.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:41.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:41.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:41.991]             base::names(...future.oldOptions))
[17:40:41.991]     }
[17:40:41.991]     if (FALSE) {
[17:40:41.991]     }
[17:40:41.991]     else {
[17:40:41.991]         if (TRUE) {
[17:40:41.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:41.991]                 open = "w")
[17:40:41.991]         }
[17:40:41.991]         else {
[17:40:41.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:41.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:41.991]         }
[17:40:41.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:41.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:41.991]             base::sink(type = "output", split = FALSE)
[17:40:41.991]             base::close(...future.stdout)
[17:40:41.991]         }, add = TRUE)
[17:40:41.991]     }
[17:40:41.991]     ...future.frame <- base::sys.nframe()
[17:40:41.991]     ...future.conditions <- base::list()
[17:40:41.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:41.991]     if (FALSE) {
[17:40:41.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:41.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:41.991]     }
[17:40:41.991]     ...future.result <- base::tryCatch({
[17:40:41.991]         base::withCallingHandlers({
[17:40:41.991]             ...future.value <- base::withVisible(base::local({
[17:40:41.991]                 1
[17:40:41.991]             }))
[17:40:41.991]             future::FutureResult(value = ...future.value$value, 
[17:40:41.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.991]                   ...future.rng), globalenv = if (FALSE) 
[17:40:41.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:41.991]                     ...future.globalenv.names))
[17:40:41.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:41.991]         }, condition = base::local({
[17:40:41.991]             c <- base::c
[17:40:41.991]             inherits <- base::inherits
[17:40:41.991]             invokeRestart <- base::invokeRestart
[17:40:41.991]             length <- base::length
[17:40:41.991]             list <- base::list
[17:40:41.991]             seq.int <- base::seq.int
[17:40:41.991]             signalCondition <- base::signalCondition
[17:40:41.991]             sys.calls <- base::sys.calls
[17:40:41.991]             `[[` <- base::`[[`
[17:40:41.991]             `+` <- base::`+`
[17:40:41.991]             `<<-` <- base::`<<-`
[17:40:41.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:41.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:41.991]                   3L)]
[17:40:41.991]             }
[17:40:41.991]             function(cond) {
[17:40:41.991]                 is_error <- inherits(cond, "error")
[17:40:41.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:41.991]                   NULL)
[17:40:41.991]                 if (is_error) {
[17:40:41.991]                   sessionInformation <- function() {
[17:40:41.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:41.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:41.991]                       search = base::search(), system = base::Sys.info())
[17:40:41.991]                   }
[17:40:41.991]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:41.991]                     cond$call), session = sessionInformation(), 
[17:40:41.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:41.991]                   signalCondition(cond)
[17:40:41.991]                 }
[17:40:41.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:41.991]                 "immediateCondition"))) {
[17:40:41.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:41.991]                   ...future.conditions[[length(...future.conditions) + 
[17:40:41.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:41.991]                   if (TRUE && !signal) {
[17:40:41.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.991]                     {
[17:40:41.991]                       inherits <- base::inherits
[17:40:41.991]                       invokeRestart <- base::invokeRestart
[17:40:41.991]                       is.null <- base::is.null
[17:40:41.991]                       muffled <- FALSE
[17:40:41.991]                       if (inherits(cond, "message")) {
[17:40:41.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.991]                         if (muffled) 
[17:40:41.991]                           invokeRestart("muffleMessage")
[17:40:41.991]                       }
[17:40:41.991]                       else if (inherits(cond, "warning")) {
[17:40:41.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.991]                         if (muffled) 
[17:40:41.991]                           invokeRestart("muffleWarning")
[17:40:41.991]                       }
[17:40:41.991]                       else if (inherits(cond, "condition")) {
[17:40:41.991]                         if (!is.null(pattern)) {
[17:40:41.991]                           computeRestarts <- base::computeRestarts
[17:40:41.991]                           grepl <- base::grepl
[17:40:41.991]                           restarts <- computeRestarts(cond)
[17:40:41.991]                           for (restart in restarts) {
[17:40:41.991]                             name <- restart$name
[17:40:41.991]                             if (is.null(name)) 
[17:40:41.991]                               next
[17:40:41.991]                             if (!grepl(pattern, name)) 
[17:40:41.991]                               next
[17:40:41.991]                             invokeRestart(restart)
[17:40:41.991]                             muffled <- TRUE
[17:40:41.991]                             break
[17:40:41.991]                           }
[17:40:41.991]                         }
[17:40:41.991]                       }
[17:40:41.991]                       invisible(muffled)
[17:40:41.991]                     }
[17:40:41.991]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.991]                   }
[17:40:41.991]                 }
[17:40:41.991]                 else {
[17:40:41.991]                   if (TRUE) {
[17:40:41.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:41.991]                     {
[17:40:41.991]                       inherits <- base::inherits
[17:40:41.991]                       invokeRestart <- base::invokeRestart
[17:40:41.991]                       is.null <- base::is.null
[17:40:41.991]                       muffled <- FALSE
[17:40:41.991]                       if (inherits(cond, "message")) {
[17:40:41.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:41.991]                         if (muffled) 
[17:40:41.991]                           invokeRestart("muffleMessage")
[17:40:41.991]                       }
[17:40:41.991]                       else if (inherits(cond, "warning")) {
[17:40:41.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:41.991]                         if (muffled) 
[17:40:41.991]                           invokeRestart("muffleWarning")
[17:40:41.991]                       }
[17:40:41.991]                       else if (inherits(cond, "condition")) {
[17:40:41.991]                         if (!is.null(pattern)) {
[17:40:41.991]                           computeRestarts <- base::computeRestarts
[17:40:41.991]                           grepl <- base::grepl
[17:40:41.991]                           restarts <- computeRestarts(cond)
[17:40:41.991]                           for (restart in restarts) {
[17:40:41.991]                             name <- restart$name
[17:40:41.991]                             if (is.null(name)) 
[17:40:41.991]                               next
[17:40:41.991]                             if (!grepl(pattern, name)) 
[17:40:41.991]                               next
[17:40:41.991]                             invokeRestart(restart)
[17:40:41.991]                             muffled <- TRUE
[17:40:41.991]                             break
[17:40:41.991]                           }
[17:40:41.991]                         }
[17:40:41.991]                       }
[17:40:41.991]                       invisible(muffled)
[17:40:41.991]                     }
[17:40:41.991]                     muffleCondition(cond, pattern = "^muffle")
[17:40:41.991]                   }
[17:40:41.991]                 }
[17:40:41.991]             }
[17:40:41.991]         }))
[17:40:41.991]     }, error = function(ex) {
[17:40:41.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:41.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:41.991]                 ...future.rng), started = ...future.startTime, 
[17:40:41.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:41.991]             version = "1.8"), class = "FutureResult")
[17:40:41.991]     }, finally = {
[17:40:41.991]         if (!identical(...future.workdir, getwd())) 
[17:40:41.991]             setwd(...future.workdir)
[17:40:41.991]         {
[17:40:41.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:41.991]                 ...future.oldOptions$nwarnings <- NULL
[17:40:41.991]             }
[17:40:41.991]             base::options(...future.oldOptions)
[17:40:41.991]             if (.Platform$OS.type == "windows") {
[17:40:41.991]                 old_names <- names(...future.oldEnvVars)
[17:40:41.991]                 envs <- base::Sys.getenv()
[17:40:41.991]                 names <- names(envs)
[17:40:41.991]                 common <- intersect(names, old_names)
[17:40:41.991]                 added <- setdiff(names, old_names)
[17:40:41.991]                 removed <- setdiff(old_names, names)
[17:40:41.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:41.991]                   envs[common]]
[17:40:41.991]                 NAMES <- toupper(changed)
[17:40:41.991]                 args <- list()
[17:40:41.991]                 for (kk in seq_along(NAMES)) {
[17:40:41.991]                   name <- changed[[kk]]
[17:40:41.991]                   NAME <- NAMES[[kk]]
[17:40:41.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.991]                     next
[17:40:41.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.991]                 }
[17:40:41.991]                 NAMES <- toupper(added)
[17:40:41.991]                 for (kk in seq_along(NAMES)) {
[17:40:41.991]                   name <- added[[kk]]
[17:40:41.991]                   NAME <- NAMES[[kk]]
[17:40:41.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.991]                     next
[17:40:41.991]                   args[[name]] <- ""
[17:40:41.991]                 }
[17:40:41.991]                 NAMES <- toupper(removed)
[17:40:41.991]                 for (kk in seq_along(NAMES)) {
[17:40:41.991]                   name <- removed[[kk]]
[17:40:41.991]                   NAME <- NAMES[[kk]]
[17:40:41.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:41.991]                     next
[17:40:41.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:41.991]                 }
[17:40:41.991]                 if (length(args) > 0) 
[17:40:41.991]                   base::do.call(base::Sys.setenv, args = args)
[17:40:41.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:41.991]             }
[17:40:41.991]             else {
[17:40:41.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:41.991]             }
[17:40:41.991]             {
[17:40:41.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:41.991]                   0L) {
[17:40:41.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:41.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:41.991]                   base::options(opts)
[17:40:41.991]                 }
[17:40:41.991]                 {
[17:40:41.991]                   {
[17:40:41.991]                     NULL
[17:40:41.991]                     RNGkind("Mersenne-Twister")
[17:40:41.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:41.991]                       inherits = FALSE)
[17:40:41.991]                   }
[17:40:41.991]                   options(future.plan = NULL)
[17:40:41.991]                   if (is.na(NA_character_)) 
[17:40:41.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:41.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:41.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:41.991]                     .init = FALSE)
[17:40:41.991]                 }
[17:40:41.991]             }
[17:40:41.991]         }
[17:40:41.991]     })
[17:40:41.991]     if (TRUE) {
[17:40:41.991]         base::sink(type = "output", split = FALSE)
[17:40:41.991]         if (TRUE) {
[17:40:41.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:41.991]         }
[17:40:41.991]         else {
[17:40:41.991]             ...future.result["stdout"] <- base::list(NULL)
[17:40:41.991]         }
[17:40:41.991]         base::close(...future.stdout)
[17:40:41.991]         ...future.stdout <- NULL
[17:40:41.991]     }
[17:40:41.991]     ...future.result$conditions <- ...future.conditions
[17:40:41.991]     ...future.result$finished <- base::Sys.time()
[17:40:41.991]     ...future.result
[17:40:41.991] }
[17:40:41.993] plan(): Setting new future strategy stack:
[17:40:41.993] List of future strategies:
[17:40:41.993] 1. sequential:
[17:40:41.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.993]    - tweaked: FALSE
[17:40:41.993]    - call: NULL
[17:40:41.994] plan(): nbrOfWorkers() = 1
[17:40:41.994] plan(): Setting new future strategy stack:
[17:40:41.994] List of future strategies:
[17:40:41.994] 1. sequential:
[17:40:41.994]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:41.994]    - tweaked: FALSE
[17:40:41.994]    - call: plan(strategy)
[17:40:41.995] plan(): nbrOfWorkers() = 1
[17:40:41.995] SequentialFuture started (and completed)
[17:40:41.995] - Launch lazy future ... done
[17:40:41.995] run() for ‘SequentialFuture’ ... done
[17:40:41.995] getGlobalsAndPackages() ...
[17:40:41.996] Searching for globals...
[17:40:41.996] - globals found: [1] ‘{’
[17:40:41.996] Searching for globals ... DONE
[17:40:41.996] Resolving globals: FALSE
[17:40:41.997] 
[17:40:41.997] 
[17:40:41.997] getGlobalsAndPackages() ... DONE
[17:40:41.997] run() for ‘Future’ ...
[17:40:41.997] - state: ‘created’
[17:40:41.997] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:41.997] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:41.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:41.998]   - Field: ‘label’
[17:40:41.998]   - Field: ‘local’
[17:40:41.998]   - Field: ‘owner’
[17:40:41.998]   - Field: ‘envir’
[17:40:41.998]   - Field: ‘packages’
[17:40:41.998]   - Field: ‘gc’
[17:40:41.998]   - Field: ‘conditions’
[17:40:41.998]   - Field: ‘expr’
[17:40:41.998]   - Field: ‘uuid’
[17:40:41.998]   - Field: ‘seed’
[17:40:41.999]   - Field: ‘version’
[17:40:41.999]   - Field: ‘result’
[17:40:41.999]   - Field: ‘asynchronous’
[17:40:41.999]   - Field: ‘calls’
[17:40:41.999]   - Field: ‘globals’
[17:40:41.999]   - Field: ‘stdout’
[17:40:41.999]   - Field: ‘earlySignal’
[17:40:41.999]   - Field: ‘lazy’
[17:40:41.999]   - Field: ‘state’
[17:40:41.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:41.999] - Launch lazy future ...
[17:40:42.000] Packages needed by the future expression (n = 0): <none>
[17:40:42.000] Packages needed by future strategies (n = 0): <none>
[17:40:42.000] {
[17:40:42.000]     {
[17:40:42.000]         {
[17:40:42.000]             ...future.startTime <- base::Sys.time()
[17:40:42.000]             {
[17:40:42.000]                 {
[17:40:42.000]                   {
[17:40:42.000]                     base::local({
[17:40:42.000]                       has_future <- base::requireNamespace("future", 
[17:40:42.000]                         quietly = TRUE)
[17:40:42.000]                       if (has_future) {
[17:40:42.000]                         ns <- base::getNamespace("future")
[17:40:42.000]                         version <- ns[[".package"]][["version"]]
[17:40:42.000]                         if (is.null(version)) 
[17:40:42.000]                           version <- utils::packageVersion("future")
[17:40:42.000]                       }
[17:40:42.000]                       else {
[17:40:42.000]                         version <- NULL
[17:40:42.000]                       }
[17:40:42.000]                       if (!has_future || version < "1.8.0") {
[17:40:42.000]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.000]                           "", base::R.version$version.string), 
[17:40:42.000]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.000]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.000]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.000]                             "release", "version")], collapse = " "), 
[17:40:42.000]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.000]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.000]                           info)
[17:40:42.000]                         info <- base::paste(info, collapse = "; ")
[17:40:42.000]                         if (!has_future) {
[17:40:42.000]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.000]                             info)
[17:40:42.000]                         }
[17:40:42.000]                         else {
[17:40:42.000]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.000]                             info, version)
[17:40:42.000]                         }
[17:40:42.000]                         base::stop(msg)
[17:40:42.000]                       }
[17:40:42.000]                     })
[17:40:42.000]                   }
[17:40:42.000]                   ...future.strategy.old <- future::plan("list")
[17:40:42.000]                   options(future.plan = NULL)
[17:40:42.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.000]                 }
[17:40:42.000]                 ...future.workdir <- getwd()
[17:40:42.000]             }
[17:40:42.000]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.000]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.000]         }
[17:40:42.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.000]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.000]             base::names(...future.oldOptions))
[17:40:42.000]     }
[17:40:42.000]     if (FALSE) {
[17:40:42.000]     }
[17:40:42.000]     else {
[17:40:42.000]         if (TRUE) {
[17:40:42.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.000]                 open = "w")
[17:40:42.000]         }
[17:40:42.000]         else {
[17:40:42.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.000]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.000]         }
[17:40:42.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.000]             base::sink(type = "output", split = FALSE)
[17:40:42.000]             base::close(...future.stdout)
[17:40:42.000]         }, add = TRUE)
[17:40:42.000]     }
[17:40:42.000]     ...future.frame <- base::sys.nframe()
[17:40:42.000]     ...future.conditions <- base::list()
[17:40:42.000]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.000]     if (FALSE) {
[17:40:42.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.000]     }
[17:40:42.000]     ...future.result <- base::tryCatch({
[17:40:42.000]         base::withCallingHandlers({
[17:40:42.000]             ...future.value <- base::withVisible(base::local({
[17:40:42.000]                 2
[17:40:42.000]             }))
[17:40:42.000]             future::FutureResult(value = ...future.value$value, 
[17:40:42.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.000]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.000]                     ...future.globalenv.names))
[17:40:42.000]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.000]         }, condition = base::local({
[17:40:42.000]             c <- base::c
[17:40:42.000]             inherits <- base::inherits
[17:40:42.000]             invokeRestart <- base::invokeRestart
[17:40:42.000]             length <- base::length
[17:40:42.000]             list <- base::list
[17:40:42.000]             seq.int <- base::seq.int
[17:40:42.000]             signalCondition <- base::signalCondition
[17:40:42.000]             sys.calls <- base::sys.calls
[17:40:42.000]             `[[` <- base::`[[`
[17:40:42.000]             `+` <- base::`+`
[17:40:42.000]             `<<-` <- base::`<<-`
[17:40:42.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.000]                   3L)]
[17:40:42.000]             }
[17:40:42.000]             function(cond) {
[17:40:42.000]                 is_error <- inherits(cond, "error")
[17:40:42.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.000]                   NULL)
[17:40:42.000]                 if (is_error) {
[17:40:42.000]                   sessionInformation <- function() {
[17:40:42.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.000]                       search = base::search(), system = base::Sys.info())
[17:40:42.000]                   }
[17:40:42.000]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.000]                     cond$call), session = sessionInformation(), 
[17:40:42.000]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.000]                   signalCondition(cond)
[17:40:42.000]                 }
[17:40:42.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.000]                 "immediateCondition"))) {
[17:40:42.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.000]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.000]                   if (TRUE && !signal) {
[17:40:42.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.000]                     {
[17:40:42.000]                       inherits <- base::inherits
[17:40:42.000]                       invokeRestart <- base::invokeRestart
[17:40:42.000]                       is.null <- base::is.null
[17:40:42.000]                       muffled <- FALSE
[17:40:42.000]                       if (inherits(cond, "message")) {
[17:40:42.000]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.000]                         if (muffled) 
[17:40:42.000]                           invokeRestart("muffleMessage")
[17:40:42.000]                       }
[17:40:42.000]                       else if (inherits(cond, "warning")) {
[17:40:42.000]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.000]                         if (muffled) 
[17:40:42.000]                           invokeRestart("muffleWarning")
[17:40:42.000]                       }
[17:40:42.000]                       else if (inherits(cond, "condition")) {
[17:40:42.000]                         if (!is.null(pattern)) {
[17:40:42.000]                           computeRestarts <- base::computeRestarts
[17:40:42.000]                           grepl <- base::grepl
[17:40:42.000]                           restarts <- computeRestarts(cond)
[17:40:42.000]                           for (restart in restarts) {
[17:40:42.000]                             name <- restart$name
[17:40:42.000]                             if (is.null(name)) 
[17:40:42.000]                               next
[17:40:42.000]                             if (!grepl(pattern, name)) 
[17:40:42.000]                               next
[17:40:42.000]                             invokeRestart(restart)
[17:40:42.000]                             muffled <- TRUE
[17:40:42.000]                             break
[17:40:42.000]                           }
[17:40:42.000]                         }
[17:40:42.000]                       }
[17:40:42.000]                       invisible(muffled)
[17:40:42.000]                     }
[17:40:42.000]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.000]                   }
[17:40:42.000]                 }
[17:40:42.000]                 else {
[17:40:42.000]                   if (TRUE) {
[17:40:42.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.000]                     {
[17:40:42.000]                       inherits <- base::inherits
[17:40:42.000]                       invokeRestart <- base::invokeRestart
[17:40:42.000]                       is.null <- base::is.null
[17:40:42.000]                       muffled <- FALSE
[17:40:42.000]                       if (inherits(cond, "message")) {
[17:40:42.000]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.000]                         if (muffled) 
[17:40:42.000]                           invokeRestart("muffleMessage")
[17:40:42.000]                       }
[17:40:42.000]                       else if (inherits(cond, "warning")) {
[17:40:42.000]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.000]                         if (muffled) 
[17:40:42.000]                           invokeRestart("muffleWarning")
[17:40:42.000]                       }
[17:40:42.000]                       else if (inherits(cond, "condition")) {
[17:40:42.000]                         if (!is.null(pattern)) {
[17:40:42.000]                           computeRestarts <- base::computeRestarts
[17:40:42.000]                           grepl <- base::grepl
[17:40:42.000]                           restarts <- computeRestarts(cond)
[17:40:42.000]                           for (restart in restarts) {
[17:40:42.000]                             name <- restart$name
[17:40:42.000]                             if (is.null(name)) 
[17:40:42.000]                               next
[17:40:42.000]                             if (!grepl(pattern, name)) 
[17:40:42.000]                               next
[17:40:42.000]                             invokeRestart(restart)
[17:40:42.000]                             muffled <- TRUE
[17:40:42.000]                             break
[17:40:42.000]                           }
[17:40:42.000]                         }
[17:40:42.000]                       }
[17:40:42.000]                       invisible(muffled)
[17:40:42.000]                     }
[17:40:42.000]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.000]                   }
[17:40:42.000]                 }
[17:40:42.000]             }
[17:40:42.000]         }))
[17:40:42.000]     }, error = function(ex) {
[17:40:42.000]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.000]                 ...future.rng), started = ...future.startTime, 
[17:40:42.000]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.000]             version = "1.8"), class = "FutureResult")
[17:40:42.000]     }, finally = {
[17:40:42.000]         if (!identical(...future.workdir, getwd())) 
[17:40:42.000]             setwd(...future.workdir)
[17:40:42.000]         {
[17:40:42.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.000]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.000]             }
[17:40:42.000]             base::options(...future.oldOptions)
[17:40:42.000]             if (.Platform$OS.type == "windows") {
[17:40:42.000]                 old_names <- names(...future.oldEnvVars)
[17:40:42.000]                 envs <- base::Sys.getenv()
[17:40:42.000]                 names <- names(envs)
[17:40:42.000]                 common <- intersect(names, old_names)
[17:40:42.000]                 added <- setdiff(names, old_names)
[17:40:42.000]                 removed <- setdiff(old_names, names)
[17:40:42.000]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.000]                   envs[common]]
[17:40:42.000]                 NAMES <- toupper(changed)
[17:40:42.000]                 args <- list()
[17:40:42.000]                 for (kk in seq_along(NAMES)) {
[17:40:42.000]                   name <- changed[[kk]]
[17:40:42.000]                   NAME <- NAMES[[kk]]
[17:40:42.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.000]                     next
[17:40:42.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.000]                 }
[17:40:42.000]                 NAMES <- toupper(added)
[17:40:42.000]                 for (kk in seq_along(NAMES)) {
[17:40:42.000]                   name <- added[[kk]]
[17:40:42.000]                   NAME <- NAMES[[kk]]
[17:40:42.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.000]                     next
[17:40:42.000]                   args[[name]] <- ""
[17:40:42.000]                 }
[17:40:42.000]                 NAMES <- toupper(removed)
[17:40:42.000]                 for (kk in seq_along(NAMES)) {
[17:40:42.000]                   name <- removed[[kk]]
[17:40:42.000]                   NAME <- NAMES[[kk]]
[17:40:42.000]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.000]                     next
[17:40:42.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.000]                 }
[17:40:42.000]                 if (length(args) > 0) 
[17:40:42.000]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.000]             }
[17:40:42.000]             else {
[17:40:42.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.000]             }
[17:40:42.000]             {
[17:40:42.000]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.000]                   0L) {
[17:40:42.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.000]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.000]                   base::options(opts)
[17:40:42.000]                 }
[17:40:42.000]                 {
[17:40:42.000]                   {
[17:40:42.000]                     NULL
[17:40:42.000]                     RNGkind("Mersenne-Twister")
[17:40:42.000]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.000]                       inherits = FALSE)
[17:40:42.000]                   }
[17:40:42.000]                   options(future.plan = NULL)
[17:40:42.000]                   if (is.na(NA_character_)) 
[17:40:42.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.000]                     .init = FALSE)
[17:40:42.000]                 }
[17:40:42.000]             }
[17:40:42.000]         }
[17:40:42.000]     })
[17:40:42.000]     if (TRUE) {
[17:40:42.000]         base::sink(type = "output", split = FALSE)
[17:40:42.000]         if (TRUE) {
[17:40:42.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.000]         }
[17:40:42.000]         else {
[17:40:42.000]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.000]         }
[17:40:42.000]         base::close(...future.stdout)
[17:40:42.000]         ...future.stdout <- NULL
[17:40:42.000]     }
[17:40:42.000]     ...future.result$conditions <- ...future.conditions
[17:40:42.000]     ...future.result$finished <- base::Sys.time()
[17:40:42.000]     ...future.result
[17:40:42.000] }
[17:40:42.002] plan(): Setting new future strategy stack:
[17:40:42.002] List of future strategies:
[17:40:42.002] 1. sequential:
[17:40:42.002]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.002]    - tweaked: FALSE
[17:40:42.002]    - call: NULL
[17:40:42.002] plan(): nbrOfWorkers() = 1
[17:40:42.003] plan(): Setting new future strategy stack:
[17:40:42.003] List of future strategies:
[17:40:42.003] 1. sequential:
[17:40:42.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.003]    - tweaked: FALSE
[17:40:42.003]    - call: plan(strategy)
[17:40:42.004] plan(): nbrOfWorkers() = 1
[17:40:42.004] SequentialFuture started (and completed)
[17:40:42.004] - Launch lazy future ... done
[17:40:42.004] run() for ‘SequentialFuture’ ... done
[17:40:42.005] resolve() on environment ...
[17:40:42.005]  recursive: 0
[17:40:42.005]  elements: [3] ‘a’
[17:40:42.005] resolved() for ‘SequentialFuture’ ...
[17:40:42.005] - state: ‘finished’
[17:40:42.005] - run: TRUE
[17:40:42.005] - result: ‘FutureResult’
[17:40:42.006] resolved() for ‘SequentialFuture’ ... done
[17:40:42.006] Future #1
[17:40:42.006]  length: 2 (resolved future 1)
[17:40:42.006] resolved() for ‘SequentialFuture’ ...
[17:40:42.006] - state: ‘finished’
[17:40:42.006] - run: TRUE
[17:40:42.006] - result: ‘FutureResult’
[17:40:42.006] resolved() for ‘SequentialFuture’ ... done
[17:40:42.006] Future #2
[17:40:42.006]  length: 1 (resolved future 2)
[17:40:42.007]  length: 0 (resolved future 3)
[17:40:42.007] resolve() on environment ... DONE
[17:40:42.007] resolved() for ‘SequentialFuture’ ...
[17:40:42.007] - state: ‘finished’
[17:40:42.007] - run: TRUE
[17:40:42.007] - result: ‘FutureResult’
[17:40:42.007] resolved() for ‘SequentialFuture’ ... done
[17:40:42.008] resolve() on environment ...
[17:40:42.008]  recursive: 0
[17:40:42.008]  elements: [3] ‘b’
[17:40:42.008] resolved() for ‘SequentialFuture’ ...
[17:40:42.008] - state: ‘finished’
[17:40:42.008] - run: TRUE
[17:40:42.008] - result: ‘FutureResult’
[17:40:42.009] resolved() for ‘SequentialFuture’ ... done
[17:40:42.009] Future #1
[17:40:42.009]  length: 2 (resolved future 1)
[17:40:42.009] resolved() for ‘SequentialFuture’ ...
[17:40:42.009] - state: ‘finished’
[17:40:42.009] - run: TRUE
[17:40:42.009] - result: ‘FutureResult’
[17:40:42.009] resolved() for ‘SequentialFuture’ ... done
[17:40:42.009] Future #2
[17:40:42.009]  length: 1 (resolved future 2)
[17:40:42.009]  length: 0 (resolved future 3)
[17:40:42.010] resolve() on environment ... DONE
[17:40:42.012] resolve() on environment ...
[17:40:42.012]  recursive: 0
[17:40:42.012]  elements: [3] ‘c’
[17:40:42.013] resolved() for ‘SequentialFuture’ ...
[17:40:42.013] - state: ‘finished’
[17:40:42.013] - run: TRUE
[17:40:42.013] - result: ‘FutureResult’
[17:40:42.013] resolved() for ‘SequentialFuture’ ... done
[17:40:42.013] Future #1
[17:40:42.013]  length: 2 (resolved future 1)
[17:40:42.013] resolved() for ‘SequentialFuture’ ...
[17:40:42.013] - state: ‘finished’
[17:40:42.013] - run: TRUE
[17:40:42.013] - result: ‘FutureResult’
[17:40:42.014] resolved() for ‘SequentialFuture’ ... done
[17:40:42.014] Future #2
[17:40:42.014]  length: 1 (resolved future 2)
[17:40:42.014]  length: 0 (resolved future 3)
[17:40:42.014] resolve() on environment ... DONE
[17:40:42.014] resolve() on environment ...
[17:40:42.014]  recursive: 0
[17:40:42.015]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:40:42.015] resolved() for ‘SequentialFuture’ ...
[17:40:42.015] - state: ‘finished’
[17:40:42.015] - run: TRUE
[17:40:42.015] - result: ‘FutureResult’
[17:40:42.015] resolved() for ‘SequentialFuture’ ... done
[17:40:42.015] Future #1
[17:40:42.016]  length: 2 (resolved future 1)
[17:40:42.016] resolved() for ‘SequentialFuture’ ...
[17:40:42.016] - state: ‘finished’
[17:40:42.016] - run: TRUE
[17:40:42.016] - result: ‘FutureResult’
[17:40:42.016] resolved() for ‘SequentialFuture’ ... done
[17:40:42.016] Future #2
[17:40:42.017]  length: 1 (resolved future 2)
[17:40:42.017]  length: 0 (resolved future 3)
[17:40:42.017] resolve() on environment ... DONE
[17:40:42.017] resolve() on environment ...
[17:40:42.017]  recursive: 99
[17:40:42.018]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:40:42.018] resolved() for ‘SequentialFuture’ ...
[17:40:42.018] - state: ‘finished’
[17:40:42.018] - run: TRUE
[17:40:42.018] - result: ‘FutureResult’
[17:40:42.018] resolved() for ‘SequentialFuture’ ... done
[17:40:42.018] Future #1
[17:40:42.019] resolved() for ‘SequentialFuture’ ...
[17:40:42.019] - state: ‘finished’
[17:40:42.019] - run: TRUE
[17:40:42.019] - result: ‘FutureResult’
[17:40:42.019] resolved() for ‘SequentialFuture’ ... done
[17:40:42.019] A SequentialFuture was resolved
[17:40:42.019]  length: 2 (resolved future 1)
[17:40:42.019] resolved() for ‘SequentialFuture’ ...
[17:40:42.019] - state: ‘finished’
[17:40:42.019] - run: TRUE
[17:40:42.019] - result: ‘FutureResult’
[17:40:42.020] resolved() for ‘SequentialFuture’ ... done
[17:40:42.020] Future #2
[17:40:42.020] resolved() for ‘SequentialFuture’ ...
[17:40:42.020] - state: ‘finished’
[17:40:42.020] - run: TRUE
[17:40:42.020] - result: ‘FutureResult’
[17:40:42.020] resolved() for ‘SequentialFuture’ ... done
[17:40:42.020] A SequentialFuture was resolved
[17:40:42.020]  length: 1 (resolved future 2)
[17:40:42.020]  length: 0 (resolved future 3)
[17:40:42.021] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:40:42.022] resolve() on list environment ...
[17:40:42.022]  recursive: 0
[17:40:42.023]  length: 2
[17:40:42.023]  elements: ‘a’, ‘b’
[17:40:42.023]  length: 1 (resolved future 1)
[17:40:42.023]  length: 0 (resolved future 2)
[17:40:42.023] resolve() on list environment ... DONE
[17:40:42.023] getGlobalsAndPackages() ...
[17:40:42.023] Searching for globals...
[17:40:42.024] 
[17:40:42.024] Searching for globals ... DONE
[17:40:42.024] - globals: [0] <none>
[17:40:42.024] getGlobalsAndPackages() ... DONE
[17:40:42.024] run() for ‘Future’ ...
[17:40:42.024] - state: ‘created’
[17:40:42.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.025]   - Field: ‘label’
[17:40:42.025]   - Field: ‘local’
[17:40:42.025]   - Field: ‘owner’
[17:40:42.025]   - Field: ‘envir’
[17:40:42.025]   - Field: ‘packages’
[17:40:42.025]   - Field: ‘gc’
[17:40:42.025]   - Field: ‘conditions’
[17:40:42.025]   - Field: ‘expr’
[17:40:42.026]   - Field: ‘uuid’
[17:40:42.026]   - Field: ‘seed’
[17:40:42.026]   - Field: ‘version’
[17:40:42.026]   - Field: ‘result’
[17:40:42.026]   - Field: ‘asynchronous’
[17:40:42.026]   - Field: ‘calls’
[17:40:42.026]   - Field: ‘globals’
[17:40:42.026]   - Field: ‘stdout’
[17:40:42.026]   - Field: ‘earlySignal’
[17:40:42.026]   - Field: ‘lazy’
[17:40:42.026]   - Field: ‘state’
[17:40:42.026] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.027] - Launch lazy future ...
[17:40:42.027] Packages needed by the future expression (n = 0): <none>
[17:40:42.027] Packages needed by future strategies (n = 0): <none>
[17:40:42.027] {
[17:40:42.027]     {
[17:40:42.027]         {
[17:40:42.027]             ...future.startTime <- base::Sys.time()
[17:40:42.027]             {
[17:40:42.027]                 {
[17:40:42.027]                   {
[17:40:42.027]                     base::local({
[17:40:42.027]                       has_future <- base::requireNamespace("future", 
[17:40:42.027]                         quietly = TRUE)
[17:40:42.027]                       if (has_future) {
[17:40:42.027]                         ns <- base::getNamespace("future")
[17:40:42.027]                         version <- ns[[".package"]][["version"]]
[17:40:42.027]                         if (is.null(version)) 
[17:40:42.027]                           version <- utils::packageVersion("future")
[17:40:42.027]                       }
[17:40:42.027]                       else {
[17:40:42.027]                         version <- NULL
[17:40:42.027]                       }
[17:40:42.027]                       if (!has_future || version < "1.8.0") {
[17:40:42.027]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.027]                           "", base::R.version$version.string), 
[17:40:42.027]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.027]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.027]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.027]                             "release", "version")], collapse = " "), 
[17:40:42.027]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.027]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.027]                           info)
[17:40:42.027]                         info <- base::paste(info, collapse = "; ")
[17:40:42.027]                         if (!has_future) {
[17:40:42.027]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.027]                             info)
[17:40:42.027]                         }
[17:40:42.027]                         else {
[17:40:42.027]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.027]                             info, version)
[17:40:42.027]                         }
[17:40:42.027]                         base::stop(msg)
[17:40:42.027]                       }
[17:40:42.027]                     })
[17:40:42.027]                   }
[17:40:42.027]                   ...future.strategy.old <- future::plan("list")
[17:40:42.027]                   options(future.plan = NULL)
[17:40:42.027]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.027]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.027]                 }
[17:40:42.027]                 ...future.workdir <- getwd()
[17:40:42.027]             }
[17:40:42.027]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.027]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.027]         }
[17:40:42.027]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.027]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.027]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.027]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.027]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.027]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.027]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.027]             base::names(...future.oldOptions))
[17:40:42.027]     }
[17:40:42.027]     if (FALSE) {
[17:40:42.027]     }
[17:40:42.027]     else {
[17:40:42.027]         if (TRUE) {
[17:40:42.027]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.027]                 open = "w")
[17:40:42.027]         }
[17:40:42.027]         else {
[17:40:42.027]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.027]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.027]         }
[17:40:42.027]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.027]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.027]             base::sink(type = "output", split = FALSE)
[17:40:42.027]             base::close(...future.stdout)
[17:40:42.027]         }, add = TRUE)
[17:40:42.027]     }
[17:40:42.027]     ...future.frame <- base::sys.nframe()
[17:40:42.027]     ...future.conditions <- base::list()
[17:40:42.027]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.027]     if (FALSE) {
[17:40:42.027]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.027]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.027]     }
[17:40:42.027]     ...future.result <- base::tryCatch({
[17:40:42.027]         base::withCallingHandlers({
[17:40:42.027]             ...future.value <- base::withVisible(base::local(1))
[17:40:42.027]             future::FutureResult(value = ...future.value$value, 
[17:40:42.027]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.027]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.027]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.027]                     ...future.globalenv.names))
[17:40:42.027]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.027]         }, condition = base::local({
[17:40:42.027]             c <- base::c
[17:40:42.027]             inherits <- base::inherits
[17:40:42.027]             invokeRestart <- base::invokeRestart
[17:40:42.027]             length <- base::length
[17:40:42.027]             list <- base::list
[17:40:42.027]             seq.int <- base::seq.int
[17:40:42.027]             signalCondition <- base::signalCondition
[17:40:42.027]             sys.calls <- base::sys.calls
[17:40:42.027]             `[[` <- base::`[[`
[17:40:42.027]             `+` <- base::`+`
[17:40:42.027]             `<<-` <- base::`<<-`
[17:40:42.027]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.027]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.027]                   3L)]
[17:40:42.027]             }
[17:40:42.027]             function(cond) {
[17:40:42.027]                 is_error <- inherits(cond, "error")
[17:40:42.027]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.027]                   NULL)
[17:40:42.027]                 if (is_error) {
[17:40:42.027]                   sessionInformation <- function() {
[17:40:42.027]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.027]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.027]                       search = base::search(), system = base::Sys.info())
[17:40:42.027]                   }
[17:40:42.027]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.027]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.027]                     cond$call), session = sessionInformation(), 
[17:40:42.027]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.027]                   signalCondition(cond)
[17:40:42.027]                 }
[17:40:42.027]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.027]                 "immediateCondition"))) {
[17:40:42.027]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.027]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.027]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.027]                   if (TRUE && !signal) {
[17:40:42.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.027]                     {
[17:40:42.027]                       inherits <- base::inherits
[17:40:42.027]                       invokeRestart <- base::invokeRestart
[17:40:42.027]                       is.null <- base::is.null
[17:40:42.027]                       muffled <- FALSE
[17:40:42.027]                       if (inherits(cond, "message")) {
[17:40:42.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.027]                         if (muffled) 
[17:40:42.027]                           invokeRestart("muffleMessage")
[17:40:42.027]                       }
[17:40:42.027]                       else if (inherits(cond, "warning")) {
[17:40:42.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.027]                         if (muffled) 
[17:40:42.027]                           invokeRestart("muffleWarning")
[17:40:42.027]                       }
[17:40:42.027]                       else if (inherits(cond, "condition")) {
[17:40:42.027]                         if (!is.null(pattern)) {
[17:40:42.027]                           computeRestarts <- base::computeRestarts
[17:40:42.027]                           grepl <- base::grepl
[17:40:42.027]                           restarts <- computeRestarts(cond)
[17:40:42.027]                           for (restart in restarts) {
[17:40:42.027]                             name <- restart$name
[17:40:42.027]                             if (is.null(name)) 
[17:40:42.027]                               next
[17:40:42.027]                             if (!grepl(pattern, name)) 
[17:40:42.027]                               next
[17:40:42.027]                             invokeRestart(restart)
[17:40:42.027]                             muffled <- TRUE
[17:40:42.027]                             break
[17:40:42.027]                           }
[17:40:42.027]                         }
[17:40:42.027]                       }
[17:40:42.027]                       invisible(muffled)
[17:40:42.027]                     }
[17:40:42.027]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.027]                   }
[17:40:42.027]                 }
[17:40:42.027]                 else {
[17:40:42.027]                   if (TRUE) {
[17:40:42.027]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.027]                     {
[17:40:42.027]                       inherits <- base::inherits
[17:40:42.027]                       invokeRestart <- base::invokeRestart
[17:40:42.027]                       is.null <- base::is.null
[17:40:42.027]                       muffled <- FALSE
[17:40:42.027]                       if (inherits(cond, "message")) {
[17:40:42.027]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.027]                         if (muffled) 
[17:40:42.027]                           invokeRestart("muffleMessage")
[17:40:42.027]                       }
[17:40:42.027]                       else if (inherits(cond, "warning")) {
[17:40:42.027]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.027]                         if (muffled) 
[17:40:42.027]                           invokeRestart("muffleWarning")
[17:40:42.027]                       }
[17:40:42.027]                       else if (inherits(cond, "condition")) {
[17:40:42.027]                         if (!is.null(pattern)) {
[17:40:42.027]                           computeRestarts <- base::computeRestarts
[17:40:42.027]                           grepl <- base::grepl
[17:40:42.027]                           restarts <- computeRestarts(cond)
[17:40:42.027]                           for (restart in restarts) {
[17:40:42.027]                             name <- restart$name
[17:40:42.027]                             if (is.null(name)) 
[17:40:42.027]                               next
[17:40:42.027]                             if (!grepl(pattern, name)) 
[17:40:42.027]                               next
[17:40:42.027]                             invokeRestart(restart)
[17:40:42.027]                             muffled <- TRUE
[17:40:42.027]                             break
[17:40:42.027]                           }
[17:40:42.027]                         }
[17:40:42.027]                       }
[17:40:42.027]                       invisible(muffled)
[17:40:42.027]                     }
[17:40:42.027]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.027]                   }
[17:40:42.027]                 }
[17:40:42.027]             }
[17:40:42.027]         }))
[17:40:42.027]     }, error = function(ex) {
[17:40:42.027]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.027]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.027]                 ...future.rng), started = ...future.startTime, 
[17:40:42.027]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.027]             version = "1.8"), class = "FutureResult")
[17:40:42.027]     }, finally = {
[17:40:42.027]         if (!identical(...future.workdir, getwd())) 
[17:40:42.027]             setwd(...future.workdir)
[17:40:42.027]         {
[17:40:42.027]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.027]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.027]             }
[17:40:42.027]             base::options(...future.oldOptions)
[17:40:42.027]             if (.Platform$OS.type == "windows") {
[17:40:42.027]                 old_names <- names(...future.oldEnvVars)
[17:40:42.027]                 envs <- base::Sys.getenv()
[17:40:42.027]                 names <- names(envs)
[17:40:42.027]                 common <- intersect(names, old_names)
[17:40:42.027]                 added <- setdiff(names, old_names)
[17:40:42.027]                 removed <- setdiff(old_names, names)
[17:40:42.027]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.027]                   envs[common]]
[17:40:42.027]                 NAMES <- toupper(changed)
[17:40:42.027]                 args <- list()
[17:40:42.027]                 for (kk in seq_along(NAMES)) {
[17:40:42.027]                   name <- changed[[kk]]
[17:40:42.027]                   NAME <- NAMES[[kk]]
[17:40:42.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.027]                     next
[17:40:42.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.027]                 }
[17:40:42.027]                 NAMES <- toupper(added)
[17:40:42.027]                 for (kk in seq_along(NAMES)) {
[17:40:42.027]                   name <- added[[kk]]
[17:40:42.027]                   NAME <- NAMES[[kk]]
[17:40:42.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.027]                     next
[17:40:42.027]                   args[[name]] <- ""
[17:40:42.027]                 }
[17:40:42.027]                 NAMES <- toupper(removed)
[17:40:42.027]                 for (kk in seq_along(NAMES)) {
[17:40:42.027]                   name <- removed[[kk]]
[17:40:42.027]                   NAME <- NAMES[[kk]]
[17:40:42.027]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.027]                     next
[17:40:42.027]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.027]                 }
[17:40:42.027]                 if (length(args) > 0) 
[17:40:42.027]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.027]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.027]             }
[17:40:42.027]             else {
[17:40:42.027]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.027]             }
[17:40:42.027]             {
[17:40:42.027]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.027]                   0L) {
[17:40:42.027]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.027]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.027]                   base::options(opts)
[17:40:42.027]                 }
[17:40:42.027]                 {
[17:40:42.027]                   {
[17:40:42.027]                     NULL
[17:40:42.027]                     RNGkind("Mersenne-Twister")
[17:40:42.027]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.027]                       inherits = FALSE)
[17:40:42.027]                   }
[17:40:42.027]                   options(future.plan = NULL)
[17:40:42.027]                   if (is.na(NA_character_)) 
[17:40:42.027]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.027]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.027]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.027]                     .init = FALSE)
[17:40:42.027]                 }
[17:40:42.027]             }
[17:40:42.027]         }
[17:40:42.027]     })
[17:40:42.027]     if (TRUE) {
[17:40:42.027]         base::sink(type = "output", split = FALSE)
[17:40:42.027]         if (TRUE) {
[17:40:42.027]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.027]         }
[17:40:42.027]         else {
[17:40:42.027]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.027]         }
[17:40:42.027]         base::close(...future.stdout)
[17:40:42.027]         ...future.stdout <- NULL
[17:40:42.027]     }
[17:40:42.027]     ...future.result$conditions <- ...future.conditions
[17:40:42.027]     ...future.result$finished <- base::Sys.time()
[17:40:42.027]     ...future.result
[17:40:42.027] }
[17:40:42.029] plan(): Setting new future strategy stack:
[17:40:42.029] List of future strategies:
[17:40:42.029] 1. sequential:
[17:40:42.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.029]    - tweaked: FALSE
[17:40:42.029]    - call: NULL
[17:40:42.030] plan(): nbrOfWorkers() = 1
[17:40:42.030] plan(): Setting new future strategy stack:
[17:40:42.030] List of future strategies:
[17:40:42.030] 1. sequential:
[17:40:42.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.030]    - tweaked: FALSE
[17:40:42.030]    - call: plan(strategy)
[17:40:42.031] plan(): nbrOfWorkers() = 1
[17:40:42.031] SequentialFuture started (and completed)
[17:40:42.031] - Launch lazy future ... done
[17:40:42.031] run() for ‘SequentialFuture’ ... done
[17:40:42.031] getGlobalsAndPackages() ...
[17:40:42.031] Searching for globals...
[17:40:42.032] 
[17:40:42.032] Searching for globals ... DONE
[17:40:42.032] - globals: [0] <none>
[17:40:42.032] getGlobalsAndPackages() ... DONE
[17:40:42.032] run() for ‘Future’ ...
[17:40:42.032] - state: ‘created’
[17:40:42.033] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.033] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.033]   - Field: ‘label’
[17:40:42.033]   - Field: ‘local’
[17:40:42.033]   - Field: ‘owner’
[17:40:42.033]   - Field: ‘envir’
[17:40:42.033]   - Field: ‘packages’
[17:40:42.033]   - Field: ‘gc’
[17:40:42.034]   - Field: ‘conditions’
[17:40:42.034]   - Field: ‘expr’
[17:40:42.034]   - Field: ‘uuid’
[17:40:42.034]   - Field: ‘seed’
[17:40:42.034]   - Field: ‘version’
[17:40:42.034]   - Field: ‘result’
[17:40:42.034]   - Field: ‘asynchronous’
[17:40:42.034]   - Field: ‘calls’
[17:40:42.034]   - Field: ‘globals’
[17:40:42.034]   - Field: ‘stdout’
[17:40:42.034]   - Field: ‘earlySignal’
[17:40:42.035]   - Field: ‘lazy’
[17:40:42.035]   - Field: ‘state’
[17:40:42.035] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.035] - Launch lazy future ...
[17:40:42.035] Packages needed by the future expression (n = 0): <none>
[17:40:42.035] Packages needed by future strategies (n = 0): <none>
[17:40:42.036] {
[17:40:42.036]     {
[17:40:42.036]         {
[17:40:42.036]             ...future.startTime <- base::Sys.time()
[17:40:42.036]             {
[17:40:42.036]                 {
[17:40:42.036]                   {
[17:40:42.036]                     base::local({
[17:40:42.036]                       has_future <- base::requireNamespace("future", 
[17:40:42.036]                         quietly = TRUE)
[17:40:42.036]                       if (has_future) {
[17:40:42.036]                         ns <- base::getNamespace("future")
[17:40:42.036]                         version <- ns[[".package"]][["version"]]
[17:40:42.036]                         if (is.null(version)) 
[17:40:42.036]                           version <- utils::packageVersion("future")
[17:40:42.036]                       }
[17:40:42.036]                       else {
[17:40:42.036]                         version <- NULL
[17:40:42.036]                       }
[17:40:42.036]                       if (!has_future || version < "1.8.0") {
[17:40:42.036]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.036]                           "", base::R.version$version.string), 
[17:40:42.036]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.036]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.036]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.036]                             "release", "version")], collapse = " "), 
[17:40:42.036]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.036]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.036]                           info)
[17:40:42.036]                         info <- base::paste(info, collapse = "; ")
[17:40:42.036]                         if (!has_future) {
[17:40:42.036]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.036]                             info)
[17:40:42.036]                         }
[17:40:42.036]                         else {
[17:40:42.036]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.036]                             info, version)
[17:40:42.036]                         }
[17:40:42.036]                         base::stop(msg)
[17:40:42.036]                       }
[17:40:42.036]                     })
[17:40:42.036]                   }
[17:40:42.036]                   ...future.strategy.old <- future::plan("list")
[17:40:42.036]                   options(future.plan = NULL)
[17:40:42.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.036]                 }
[17:40:42.036]                 ...future.workdir <- getwd()
[17:40:42.036]             }
[17:40:42.036]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.036]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.036]         }
[17:40:42.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.036]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.036]             base::names(...future.oldOptions))
[17:40:42.036]     }
[17:40:42.036]     if (FALSE) {
[17:40:42.036]     }
[17:40:42.036]     else {
[17:40:42.036]         if (TRUE) {
[17:40:42.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.036]                 open = "w")
[17:40:42.036]         }
[17:40:42.036]         else {
[17:40:42.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.036]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.036]         }
[17:40:42.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.036]             base::sink(type = "output", split = FALSE)
[17:40:42.036]             base::close(...future.stdout)
[17:40:42.036]         }, add = TRUE)
[17:40:42.036]     }
[17:40:42.036]     ...future.frame <- base::sys.nframe()
[17:40:42.036]     ...future.conditions <- base::list()
[17:40:42.036]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.036]     if (FALSE) {
[17:40:42.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.036]     }
[17:40:42.036]     ...future.result <- base::tryCatch({
[17:40:42.036]         base::withCallingHandlers({
[17:40:42.036]             ...future.value <- base::withVisible(base::local(2))
[17:40:42.036]             future::FutureResult(value = ...future.value$value, 
[17:40:42.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.036]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.036]                     ...future.globalenv.names))
[17:40:42.036]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.036]         }, condition = base::local({
[17:40:42.036]             c <- base::c
[17:40:42.036]             inherits <- base::inherits
[17:40:42.036]             invokeRestart <- base::invokeRestart
[17:40:42.036]             length <- base::length
[17:40:42.036]             list <- base::list
[17:40:42.036]             seq.int <- base::seq.int
[17:40:42.036]             signalCondition <- base::signalCondition
[17:40:42.036]             sys.calls <- base::sys.calls
[17:40:42.036]             `[[` <- base::`[[`
[17:40:42.036]             `+` <- base::`+`
[17:40:42.036]             `<<-` <- base::`<<-`
[17:40:42.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.036]                   3L)]
[17:40:42.036]             }
[17:40:42.036]             function(cond) {
[17:40:42.036]                 is_error <- inherits(cond, "error")
[17:40:42.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.036]                   NULL)
[17:40:42.036]                 if (is_error) {
[17:40:42.036]                   sessionInformation <- function() {
[17:40:42.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.036]                       search = base::search(), system = base::Sys.info())
[17:40:42.036]                   }
[17:40:42.036]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.036]                     cond$call), session = sessionInformation(), 
[17:40:42.036]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.036]                   signalCondition(cond)
[17:40:42.036]                 }
[17:40:42.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.036]                 "immediateCondition"))) {
[17:40:42.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.036]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.036]                   if (TRUE && !signal) {
[17:40:42.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.036]                     {
[17:40:42.036]                       inherits <- base::inherits
[17:40:42.036]                       invokeRestart <- base::invokeRestart
[17:40:42.036]                       is.null <- base::is.null
[17:40:42.036]                       muffled <- FALSE
[17:40:42.036]                       if (inherits(cond, "message")) {
[17:40:42.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.036]                         if (muffled) 
[17:40:42.036]                           invokeRestart("muffleMessage")
[17:40:42.036]                       }
[17:40:42.036]                       else if (inherits(cond, "warning")) {
[17:40:42.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.036]                         if (muffled) 
[17:40:42.036]                           invokeRestart("muffleWarning")
[17:40:42.036]                       }
[17:40:42.036]                       else if (inherits(cond, "condition")) {
[17:40:42.036]                         if (!is.null(pattern)) {
[17:40:42.036]                           computeRestarts <- base::computeRestarts
[17:40:42.036]                           grepl <- base::grepl
[17:40:42.036]                           restarts <- computeRestarts(cond)
[17:40:42.036]                           for (restart in restarts) {
[17:40:42.036]                             name <- restart$name
[17:40:42.036]                             if (is.null(name)) 
[17:40:42.036]                               next
[17:40:42.036]                             if (!grepl(pattern, name)) 
[17:40:42.036]                               next
[17:40:42.036]                             invokeRestart(restart)
[17:40:42.036]                             muffled <- TRUE
[17:40:42.036]                             break
[17:40:42.036]                           }
[17:40:42.036]                         }
[17:40:42.036]                       }
[17:40:42.036]                       invisible(muffled)
[17:40:42.036]                     }
[17:40:42.036]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.036]                   }
[17:40:42.036]                 }
[17:40:42.036]                 else {
[17:40:42.036]                   if (TRUE) {
[17:40:42.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.036]                     {
[17:40:42.036]                       inherits <- base::inherits
[17:40:42.036]                       invokeRestart <- base::invokeRestart
[17:40:42.036]                       is.null <- base::is.null
[17:40:42.036]                       muffled <- FALSE
[17:40:42.036]                       if (inherits(cond, "message")) {
[17:40:42.036]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.036]                         if (muffled) 
[17:40:42.036]                           invokeRestart("muffleMessage")
[17:40:42.036]                       }
[17:40:42.036]                       else if (inherits(cond, "warning")) {
[17:40:42.036]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.036]                         if (muffled) 
[17:40:42.036]                           invokeRestart("muffleWarning")
[17:40:42.036]                       }
[17:40:42.036]                       else if (inherits(cond, "condition")) {
[17:40:42.036]                         if (!is.null(pattern)) {
[17:40:42.036]                           computeRestarts <- base::computeRestarts
[17:40:42.036]                           grepl <- base::grepl
[17:40:42.036]                           restarts <- computeRestarts(cond)
[17:40:42.036]                           for (restart in restarts) {
[17:40:42.036]                             name <- restart$name
[17:40:42.036]                             if (is.null(name)) 
[17:40:42.036]                               next
[17:40:42.036]                             if (!grepl(pattern, name)) 
[17:40:42.036]                               next
[17:40:42.036]                             invokeRestart(restart)
[17:40:42.036]                             muffled <- TRUE
[17:40:42.036]                             break
[17:40:42.036]                           }
[17:40:42.036]                         }
[17:40:42.036]                       }
[17:40:42.036]                       invisible(muffled)
[17:40:42.036]                     }
[17:40:42.036]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.036]                   }
[17:40:42.036]                 }
[17:40:42.036]             }
[17:40:42.036]         }))
[17:40:42.036]     }, error = function(ex) {
[17:40:42.036]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.036]                 ...future.rng), started = ...future.startTime, 
[17:40:42.036]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.036]             version = "1.8"), class = "FutureResult")
[17:40:42.036]     }, finally = {
[17:40:42.036]         if (!identical(...future.workdir, getwd())) 
[17:40:42.036]             setwd(...future.workdir)
[17:40:42.036]         {
[17:40:42.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.036]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.036]             }
[17:40:42.036]             base::options(...future.oldOptions)
[17:40:42.036]             if (.Platform$OS.type == "windows") {
[17:40:42.036]                 old_names <- names(...future.oldEnvVars)
[17:40:42.036]                 envs <- base::Sys.getenv()
[17:40:42.036]                 names <- names(envs)
[17:40:42.036]                 common <- intersect(names, old_names)
[17:40:42.036]                 added <- setdiff(names, old_names)
[17:40:42.036]                 removed <- setdiff(old_names, names)
[17:40:42.036]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.036]                   envs[common]]
[17:40:42.036]                 NAMES <- toupper(changed)
[17:40:42.036]                 args <- list()
[17:40:42.036]                 for (kk in seq_along(NAMES)) {
[17:40:42.036]                   name <- changed[[kk]]
[17:40:42.036]                   NAME <- NAMES[[kk]]
[17:40:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.036]                     next
[17:40:42.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.036]                 }
[17:40:42.036]                 NAMES <- toupper(added)
[17:40:42.036]                 for (kk in seq_along(NAMES)) {
[17:40:42.036]                   name <- added[[kk]]
[17:40:42.036]                   NAME <- NAMES[[kk]]
[17:40:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.036]                     next
[17:40:42.036]                   args[[name]] <- ""
[17:40:42.036]                 }
[17:40:42.036]                 NAMES <- toupper(removed)
[17:40:42.036]                 for (kk in seq_along(NAMES)) {
[17:40:42.036]                   name <- removed[[kk]]
[17:40:42.036]                   NAME <- NAMES[[kk]]
[17:40:42.036]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.036]                     next
[17:40:42.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.036]                 }
[17:40:42.036]                 if (length(args) > 0) 
[17:40:42.036]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.036]             }
[17:40:42.036]             else {
[17:40:42.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.036]             }
[17:40:42.036]             {
[17:40:42.036]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.036]                   0L) {
[17:40:42.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.036]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.036]                   base::options(opts)
[17:40:42.036]                 }
[17:40:42.036]                 {
[17:40:42.036]                   {
[17:40:42.036]                     NULL
[17:40:42.036]                     RNGkind("Mersenne-Twister")
[17:40:42.036]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.036]                       inherits = FALSE)
[17:40:42.036]                   }
[17:40:42.036]                   options(future.plan = NULL)
[17:40:42.036]                   if (is.na(NA_character_)) 
[17:40:42.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.036]                     .init = FALSE)
[17:40:42.036]                 }
[17:40:42.036]             }
[17:40:42.036]         }
[17:40:42.036]     })
[17:40:42.036]     if (TRUE) {
[17:40:42.036]         base::sink(type = "output", split = FALSE)
[17:40:42.036]         if (TRUE) {
[17:40:42.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.036]         }
[17:40:42.036]         else {
[17:40:42.036]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.036]         }
[17:40:42.036]         base::close(...future.stdout)
[17:40:42.036]         ...future.stdout <- NULL
[17:40:42.036]     }
[17:40:42.036]     ...future.result$conditions <- ...future.conditions
[17:40:42.036]     ...future.result$finished <- base::Sys.time()
[17:40:42.036]     ...future.result
[17:40:42.036] }
[17:40:42.037] plan(): Setting new future strategy stack:
[17:40:42.037] List of future strategies:
[17:40:42.037] 1. sequential:
[17:40:42.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.037]    - tweaked: FALSE
[17:40:42.037]    - call: NULL
[17:40:42.038] plan(): nbrOfWorkers() = 1
[17:40:42.040] plan(): Setting new future strategy stack:
[17:40:42.040] List of future strategies:
[17:40:42.040] 1. sequential:
[17:40:42.040]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.040]    - tweaked: FALSE
[17:40:42.040]    - call: plan(strategy)
[17:40:42.041] plan(): nbrOfWorkers() = 1
[17:40:42.041] SequentialFuture started (and completed)
[17:40:42.041] - Launch lazy future ... done
[17:40:42.041] run() for ‘SequentialFuture’ ... done
[17:40:42.042] resolve() on list environment ...
[17:40:42.042]  recursive: 0
[17:40:42.043]  length: 3
[17:40:42.043]  elements: ‘a’, ‘b’, ‘c’
[17:40:42.043] resolved() for ‘SequentialFuture’ ...
[17:40:42.043] - state: ‘finished’
[17:40:42.043] - run: TRUE
[17:40:42.043] - result: ‘FutureResult’
[17:40:42.043] resolved() for ‘SequentialFuture’ ... done
[17:40:42.043] Future #1
[17:40:42.043]  length: 2 (resolved future 1)
[17:40:42.044] resolved() for ‘SequentialFuture’ ...
[17:40:42.044] - state: ‘finished’
[17:40:42.044] - run: TRUE
[17:40:42.044] - result: ‘FutureResult’
[17:40:42.044] resolved() for ‘SequentialFuture’ ... done
[17:40:42.044] Future #2
[17:40:42.044]  length: 1 (resolved future 2)
[17:40:42.044]  length: 0 (resolved future 3)
[17:40:42.044] resolve() on list environment ... DONE
[17:40:42.045] getGlobalsAndPackages() ...
[17:40:42.045] Searching for globals...
[17:40:42.046] - globals found: [1] ‘{’
[17:40:42.046] Searching for globals ... DONE
[17:40:42.046] Resolving globals: FALSE
[17:40:42.046] 
[17:40:42.046] 
[17:40:42.046] getGlobalsAndPackages() ... DONE
[17:40:42.047] run() for ‘Future’ ...
[17:40:42.047] - state: ‘created’
[17:40:42.047] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.047] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.047]   - Field: ‘label’
[17:40:42.047]   - Field: ‘local’
[17:40:42.047]   - Field: ‘owner’
[17:40:42.048]   - Field: ‘envir’
[17:40:42.048]   - Field: ‘packages’
[17:40:42.048]   - Field: ‘gc’
[17:40:42.048]   - Field: ‘conditions’
[17:40:42.048]   - Field: ‘expr’
[17:40:42.048]   - Field: ‘uuid’
[17:40:42.048]   - Field: ‘seed’
[17:40:42.048]   - Field: ‘version’
[17:40:42.048]   - Field: ‘result’
[17:40:42.048]   - Field: ‘asynchronous’
[17:40:42.049]   - Field: ‘calls’
[17:40:42.049]   - Field: ‘globals’
[17:40:42.049]   - Field: ‘stdout’
[17:40:42.049]   - Field: ‘earlySignal’
[17:40:42.049]   - Field: ‘lazy’
[17:40:42.049]   - Field: ‘state’
[17:40:42.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.049] - Launch lazy future ...
[17:40:42.049] Packages needed by the future expression (n = 0): <none>
[17:40:42.049] Packages needed by future strategies (n = 0): <none>
[17:40:42.050] {
[17:40:42.050]     {
[17:40:42.050]         {
[17:40:42.050]             ...future.startTime <- base::Sys.time()
[17:40:42.050]             {
[17:40:42.050]                 {
[17:40:42.050]                   {
[17:40:42.050]                     base::local({
[17:40:42.050]                       has_future <- base::requireNamespace("future", 
[17:40:42.050]                         quietly = TRUE)
[17:40:42.050]                       if (has_future) {
[17:40:42.050]                         ns <- base::getNamespace("future")
[17:40:42.050]                         version <- ns[[".package"]][["version"]]
[17:40:42.050]                         if (is.null(version)) 
[17:40:42.050]                           version <- utils::packageVersion("future")
[17:40:42.050]                       }
[17:40:42.050]                       else {
[17:40:42.050]                         version <- NULL
[17:40:42.050]                       }
[17:40:42.050]                       if (!has_future || version < "1.8.0") {
[17:40:42.050]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.050]                           "", base::R.version$version.string), 
[17:40:42.050]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.050]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.050]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.050]                             "release", "version")], collapse = " "), 
[17:40:42.050]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.050]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.050]                           info)
[17:40:42.050]                         info <- base::paste(info, collapse = "; ")
[17:40:42.050]                         if (!has_future) {
[17:40:42.050]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.050]                             info)
[17:40:42.050]                         }
[17:40:42.050]                         else {
[17:40:42.050]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.050]                             info, version)
[17:40:42.050]                         }
[17:40:42.050]                         base::stop(msg)
[17:40:42.050]                       }
[17:40:42.050]                     })
[17:40:42.050]                   }
[17:40:42.050]                   ...future.strategy.old <- future::plan("list")
[17:40:42.050]                   options(future.plan = NULL)
[17:40:42.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.050]                 }
[17:40:42.050]                 ...future.workdir <- getwd()
[17:40:42.050]             }
[17:40:42.050]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.050]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.050]         }
[17:40:42.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.050]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.050]             base::names(...future.oldOptions))
[17:40:42.050]     }
[17:40:42.050]     if (FALSE) {
[17:40:42.050]     }
[17:40:42.050]     else {
[17:40:42.050]         if (TRUE) {
[17:40:42.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.050]                 open = "w")
[17:40:42.050]         }
[17:40:42.050]         else {
[17:40:42.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.050]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.050]         }
[17:40:42.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.050]             base::sink(type = "output", split = FALSE)
[17:40:42.050]             base::close(...future.stdout)
[17:40:42.050]         }, add = TRUE)
[17:40:42.050]     }
[17:40:42.050]     ...future.frame <- base::sys.nframe()
[17:40:42.050]     ...future.conditions <- base::list()
[17:40:42.050]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.050]     if (FALSE) {
[17:40:42.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.050]     }
[17:40:42.050]     ...future.result <- base::tryCatch({
[17:40:42.050]         base::withCallingHandlers({
[17:40:42.050]             ...future.value <- base::withVisible(base::local({
[17:40:42.050]                 1
[17:40:42.050]             }))
[17:40:42.050]             future::FutureResult(value = ...future.value$value, 
[17:40:42.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.050]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.050]                     ...future.globalenv.names))
[17:40:42.050]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.050]         }, condition = base::local({
[17:40:42.050]             c <- base::c
[17:40:42.050]             inherits <- base::inherits
[17:40:42.050]             invokeRestart <- base::invokeRestart
[17:40:42.050]             length <- base::length
[17:40:42.050]             list <- base::list
[17:40:42.050]             seq.int <- base::seq.int
[17:40:42.050]             signalCondition <- base::signalCondition
[17:40:42.050]             sys.calls <- base::sys.calls
[17:40:42.050]             `[[` <- base::`[[`
[17:40:42.050]             `+` <- base::`+`
[17:40:42.050]             `<<-` <- base::`<<-`
[17:40:42.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.050]                   3L)]
[17:40:42.050]             }
[17:40:42.050]             function(cond) {
[17:40:42.050]                 is_error <- inherits(cond, "error")
[17:40:42.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.050]                   NULL)
[17:40:42.050]                 if (is_error) {
[17:40:42.050]                   sessionInformation <- function() {
[17:40:42.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.050]                       search = base::search(), system = base::Sys.info())
[17:40:42.050]                   }
[17:40:42.050]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.050]                     cond$call), session = sessionInformation(), 
[17:40:42.050]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.050]                   signalCondition(cond)
[17:40:42.050]                 }
[17:40:42.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.050]                 "immediateCondition"))) {
[17:40:42.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.050]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.050]                   if (TRUE && !signal) {
[17:40:42.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.050]                     {
[17:40:42.050]                       inherits <- base::inherits
[17:40:42.050]                       invokeRestart <- base::invokeRestart
[17:40:42.050]                       is.null <- base::is.null
[17:40:42.050]                       muffled <- FALSE
[17:40:42.050]                       if (inherits(cond, "message")) {
[17:40:42.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.050]                         if (muffled) 
[17:40:42.050]                           invokeRestart("muffleMessage")
[17:40:42.050]                       }
[17:40:42.050]                       else if (inherits(cond, "warning")) {
[17:40:42.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.050]                         if (muffled) 
[17:40:42.050]                           invokeRestart("muffleWarning")
[17:40:42.050]                       }
[17:40:42.050]                       else if (inherits(cond, "condition")) {
[17:40:42.050]                         if (!is.null(pattern)) {
[17:40:42.050]                           computeRestarts <- base::computeRestarts
[17:40:42.050]                           grepl <- base::grepl
[17:40:42.050]                           restarts <- computeRestarts(cond)
[17:40:42.050]                           for (restart in restarts) {
[17:40:42.050]                             name <- restart$name
[17:40:42.050]                             if (is.null(name)) 
[17:40:42.050]                               next
[17:40:42.050]                             if (!grepl(pattern, name)) 
[17:40:42.050]                               next
[17:40:42.050]                             invokeRestart(restart)
[17:40:42.050]                             muffled <- TRUE
[17:40:42.050]                             break
[17:40:42.050]                           }
[17:40:42.050]                         }
[17:40:42.050]                       }
[17:40:42.050]                       invisible(muffled)
[17:40:42.050]                     }
[17:40:42.050]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.050]                   }
[17:40:42.050]                 }
[17:40:42.050]                 else {
[17:40:42.050]                   if (TRUE) {
[17:40:42.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.050]                     {
[17:40:42.050]                       inherits <- base::inherits
[17:40:42.050]                       invokeRestart <- base::invokeRestart
[17:40:42.050]                       is.null <- base::is.null
[17:40:42.050]                       muffled <- FALSE
[17:40:42.050]                       if (inherits(cond, "message")) {
[17:40:42.050]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.050]                         if (muffled) 
[17:40:42.050]                           invokeRestart("muffleMessage")
[17:40:42.050]                       }
[17:40:42.050]                       else if (inherits(cond, "warning")) {
[17:40:42.050]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.050]                         if (muffled) 
[17:40:42.050]                           invokeRestart("muffleWarning")
[17:40:42.050]                       }
[17:40:42.050]                       else if (inherits(cond, "condition")) {
[17:40:42.050]                         if (!is.null(pattern)) {
[17:40:42.050]                           computeRestarts <- base::computeRestarts
[17:40:42.050]                           grepl <- base::grepl
[17:40:42.050]                           restarts <- computeRestarts(cond)
[17:40:42.050]                           for (restart in restarts) {
[17:40:42.050]                             name <- restart$name
[17:40:42.050]                             if (is.null(name)) 
[17:40:42.050]                               next
[17:40:42.050]                             if (!grepl(pattern, name)) 
[17:40:42.050]                               next
[17:40:42.050]                             invokeRestart(restart)
[17:40:42.050]                             muffled <- TRUE
[17:40:42.050]                             break
[17:40:42.050]                           }
[17:40:42.050]                         }
[17:40:42.050]                       }
[17:40:42.050]                       invisible(muffled)
[17:40:42.050]                     }
[17:40:42.050]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.050]                   }
[17:40:42.050]                 }
[17:40:42.050]             }
[17:40:42.050]         }))
[17:40:42.050]     }, error = function(ex) {
[17:40:42.050]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.050]                 ...future.rng), started = ...future.startTime, 
[17:40:42.050]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.050]             version = "1.8"), class = "FutureResult")
[17:40:42.050]     }, finally = {
[17:40:42.050]         if (!identical(...future.workdir, getwd())) 
[17:40:42.050]             setwd(...future.workdir)
[17:40:42.050]         {
[17:40:42.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.050]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.050]             }
[17:40:42.050]             base::options(...future.oldOptions)
[17:40:42.050]             if (.Platform$OS.type == "windows") {
[17:40:42.050]                 old_names <- names(...future.oldEnvVars)
[17:40:42.050]                 envs <- base::Sys.getenv()
[17:40:42.050]                 names <- names(envs)
[17:40:42.050]                 common <- intersect(names, old_names)
[17:40:42.050]                 added <- setdiff(names, old_names)
[17:40:42.050]                 removed <- setdiff(old_names, names)
[17:40:42.050]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.050]                   envs[common]]
[17:40:42.050]                 NAMES <- toupper(changed)
[17:40:42.050]                 args <- list()
[17:40:42.050]                 for (kk in seq_along(NAMES)) {
[17:40:42.050]                   name <- changed[[kk]]
[17:40:42.050]                   NAME <- NAMES[[kk]]
[17:40:42.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.050]                     next
[17:40:42.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.050]                 }
[17:40:42.050]                 NAMES <- toupper(added)
[17:40:42.050]                 for (kk in seq_along(NAMES)) {
[17:40:42.050]                   name <- added[[kk]]
[17:40:42.050]                   NAME <- NAMES[[kk]]
[17:40:42.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.050]                     next
[17:40:42.050]                   args[[name]] <- ""
[17:40:42.050]                 }
[17:40:42.050]                 NAMES <- toupper(removed)
[17:40:42.050]                 for (kk in seq_along(NAMES)) {
[17:40:42.050]                   name <- removed[[kk]]
[17:40:42.050]                   NAME <- NAMES[[kk]]
[17:40:42.050]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.050]                     next
[17:40:42.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.050]                 }
[17:40:42.050]                 if (length(args) > 0) 
[17:40:42.050]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.050]             }
[17:40:42.050]             else {
[17:40:42.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.050]             }
[17:40:42.050]             {
[17:40:42.050]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.050]                   0L) {
[17:40:42.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.050]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.050]                   base::options(opts)
[17:40:42.050]                 }
[17:40:42.050]                 {
[17:40:42.050]                   {
[17:40:42.050]                     NULL
[17:40:42.050]                     RNGkind("Mersenne-Twister")
[17:40:42.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.050]                       inherits = FALSE)
[17:40:42.050]                   }
[17:40:42.050]                   options(future.plan = NULL)
[17:40:42.050]                   if (is.na(NA_character_)) 
[17:40:42.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.050]                     .init = FALSE)
[17:40:42.050]                 }
[17:40:42.050]             }
[17:40:42.050]         }
[17:40:42.050]     })
[17:40:42.050]     if (TRUE) {
[17:40:42.050]         base::sink(type = "output", split = FALSE)
[17:40:42.050]         if (TRUE) {
[17:40:42.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.050]         }
[17:40:42.050]         else {
[17:40:42.050]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.050]         }
[17:40:42.050]         base::close(...future.stdout)
[17:40:42.050]         ...future.stdout <- NULL
[17:40:42.050]     }
[17:40:42.050]     ...future.result$conditions <- ...future.conditions
[17:40:42.050]     ...future.result$finished <- base::Sys.time()
[17:40:42.050]     ...future.result
[17:40:42.050] }
[17:40:42.052] plan(): Setting new future strategy stack:
[17:40:42.052] List of future strategies:
[17:40:42.052] 1. sequential:
[17:40:42.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.052]    - tweaked: FALSE
[17:40:42.052]    - call: NULL
[17:40:42.052] plan(): nbrOfWorkers() = 1
[17:40:42.053] plan(): Setting new future strategy stack:
[17:40:42.053] List of future strategies:
[17:40:42.053] 1. sequential:
[17:40:42.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.053]    - tweaked: FALSE
[17:40:42.053]    - call: plan(strategy)
[17:40:42.053] plan(): nbrOfWorkers() = 1
[17:40:42.053] SequentialFuture started (and completed)
[17:40:42.054] - Launch lazy future ... done
[17:40:42.054] run() for ‘SequentialFuture’ ... done
[17:40:42.054] getGlobalsAndPackages() ...
[17:40:42.054] Searching for globals...
[17:40:42.055] - globals found: [1] ‘{’
[17:40:42.055] Searching for globals ... DONE
[17:40:42.055] Resolving globals: FALSE
[17:40:42.055] 
[17:40:42.055] 
[17:40:42.055] getGlobalsAndPackages() ... DONE
[17:40:42.056] run() for ‘Future’ ...
[17:40:42.056] - state: ‘created’
[17:40:42.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.056]   - Field: ‘label’
[17:40:42.056]   - Field: ‘local’
[17:40:42.056]   - Field: ‘owner’
[17:40:42.057]   - Field: ‘envir’
[17:40:42.057]   - Field: ‘packages’
[17:40:42.057]   - Field: ‘gc’
[17:40:42.057]   - Field: ‘conditions’
[17:40:42.057]   - Field: ‘expr’
[17:40:42.057]   - Field: ‘uuid’
[17:40:42.057]   - Field: ‘seed’
[17:40:42.057]   - Field: ‘version’
[17:40:42.057]   - Field: ‘result’
[17:40:42.057]   - Field: ‘asynchronous’
[17:40:42.057]   - Field: ‘calls’
[17:40:42.058]   - Field: ‘globals’
[17:40:42.058]   - Field: ‘stdout’
[17:40:42.058]   - Field: ‘earlySignal’
[17:40:42.058]   - Field: ‘lazy’
[17:40:42.058]   - Field: ‘state’
[17:40:42.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.058] - Launch lazy future ...
[17:40:42.058] Packages needed by the future expression (n = 0): <none>
[17:40:42.058] Packages needed by future strategies (n = 0): <none>
[17:40:42.059] {
[17:40:42.059]     {
[17:40:42.059]         {
[17:40:42.059]             ...future.startTime <- base::Sys.time()
[17:40:42.059]             {
[17:40:42.059]                 {
[17:40:42.059]                   {
[17:40:42.059]                     base::local({
[17:40:42.059]                       has_future <- base::requireNamespace("future", 
[17:40:42.059]                         quietly = TRUE)
[17:40:42.059]                       if (has_future) {
[17:40:42.059]                         ns <- base::getNamespace("future")
[17:40:42.059]                         version <- ns[[".package"]][["version"]]
[17:40:42.059]                         if (is.null(version)) 
[17:40:42.059]                           version <- utils::packageVersion("future")
[17:40:42.059]                       }
[17:40:42.059]                       else {
[17:40:42.059]                         version <- NULL
[17:40:42.059]                       }
[17:40:42.059]                       if (!has_future || version < "1.8.0") {
[17:40:42.059]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.059]                           "", base::R.version$version.string), 
[17:40:42.059]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.059]                             "release", "version")], collapse = " "), 
[17:40:42.059]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.059]                           info)
[17:40:42.059]                         info <- base::paste(info, collapse = "; ")
[17:40:42.059]                         if (!has_future) {
[17:40:42.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.059]                             info)
[17:40:42.059]                         }
[17:40:42.059]                         else {
[17:40:42.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.059]                             info, version)
[17:40:42.059]                         }
[17:40:42.059]                         base::stop(msg)
[17:40:42.059]                       }
[17:40:42.059]                     })
[17:40:42.059]                   }
[17:40:42.059]                   ...future.strategy.old <- future::plan("list")
[17:40:42.059]                   options(future.plan = NULL)
[17:40:42.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.059]                 }
[17:40:42.059]                 ...future.workdir <- getwd()
[17:40:42.059]             }
[17:40:42.059]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.059]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.059]         }
[17:40:42.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.059]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.059]             base::names(...future.oldOptions))
[17:40:42.059]     }
[17:40:42.059]     if (FALSE) {
[17:40:42.059]     }
[17:40:42.059]     else {
[17:40:42.059]         if (TRUE) {
[17:40:42.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.059]                 open = "w")
[17:40:42.059]         }
[17:40:42.059]         else {
[17:40:42.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.059]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.059]         }
[17:40:42.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.059]             base::sink(type = "output", split = FALSE)
[17:40:42.059]             base::close(...future.stdout)
[17:40:42.059]         }, add = TRUE)
[17:40:42.059]     }
[17:40:42.059]     ...future.frame <- base::sys.nframe()
[17:40:42.059]     ...future.conditions <- base::list()
[17:40:42.059]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.059]     if (FALSE) {
[17:40:42.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.059]     }
[17:40:42.059]     ...future.result <- base::tryCatch({
[17:40:42.059]         base::withCallingHandlers({
[17:40:42.059]             ...future.value <- base::withVisible(base::local({
[17:40:42.059]                 2
[17:40:42.059]             }))
[17:40:42.059]             future::FutureResult(value = ...future.value$value, 
[17:40:42.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.059]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.059]                     ...future.globalenv.names))
[17:40:42.059]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.059]         }, condition = base::local({
[17:40:42.059]             c <- base::c
[17:40:42.059]             inherits <- base::inherits
[17:40:42.059]             invokeRestart <- base::invokeRestart
[17:40:42.059]             length <- base::length
[17:40:42.059]             list <- base::list
[17:40:42.059]             seq.int <- base::seq.int
[17:40:42.059]             signalCondition <- base::signalCondition
[17:40:42.059]             sys.calls <- base::sys.calls
[17:40:42.059]             `[[` <- base::`[[`
[17:40:42.059]             `+` <- base::`+`
[17:40:42.059]             `<<-` <- base::`<<-`
[17:40:42.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.059]                   3L)]
[17:40:42.059]             }
[17:40:42.059]             function(cond) {
[17:40:42.059]                 is_error <- inherits(cond, "error")
[17:40:42.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.059]                   NULL)
[17:40:42.059]                 if (is_error) {
[17:40:42.059]                   sessionInformation <- function() {
[17:40:42.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.059]                       search = base::search(), system = base::Sys.info())
[17:40:42.059]                   }
[17:40:42.059]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.059]                     cond$call), session = sessionInformation(), 
[17:40:42.059]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.059]                   signalCondition(cond)
[17:40:42.059]                 }
[17:40:42.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.059]                 "immediateCondition"))) {
[17:40:42.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.059]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.059]                   if (TRUE && !signal) {
[17:40:42.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.059]                     {
[17:40:42.059]                       inherits <- base::inherits
[17:40:42.059]                       invokeRestart <- base::invokeRestart
[17:40:42.059]                       is.null <- base::is.null
[17:40:42.059]                       muffled <- FALSE
[17:40:42.059]                       if (inherits(cond, "message")) {
[17:40:42.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.059]                         if (muffled) 
[17:40:42.059]                           invokeRestart("muffleMessage")
[17:40:42.059]                       }
[17:40:42.059]                       else if (inherits(cond, "warning")) {
[17:40:42.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.059]                         if (muffled) 
[17:40:42.059]                           invokeRestart("muffleWarning")
[17:40:42.059]                       }
[17:40:42.059]                       else if (inherits(cond, "condition")) {
[17:40:42.059]                         if (!is.null(pattern)) {
[17:40:42.059]                           computeRestarts <- base::computeRestarts
[17:40:42.059]                           grepl <- base::grepl
[17:40:42.059]                           restarts <- computeRestarts(cond)
[17:40:42.059]                           for (restart in restarts) {
[17:40:42.059]                             name <- restart$name
[17:40:42.059]                             if (is.null(name)) 
[17:40:42.059]                               next
[17:40:42.059]                             if (!grepl(pattern, name)) 
[17:40:42.059]                               next
[17:40:42.059]                             invokeRestart(restart)
[17:40:42.059]                             muffled <- TRUE
[17:40:42.059]                             break
[17:40:42.059]                           }
[17:40:42.059]                         }
[17:40:42.059]                       }
[17:40:42.059]                       invisible(muffled)
[17:40:42.059]                     }
[17:40:42.059]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.059]                   }
[17:40:42.059]                 }
[17:40:42.059]                 else {
[17:40:42.059]                   if (TRUE) {
[17:40:42.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.059]                     {
[17:40:42.059]                       inherits <- base::inherits
[17:40:42.059]                       invokeRestart <- base::invokeRestart
[17:40:42.059]                       is.null <- base::is.null
[17:40:42.059]                       muffled <- FALSE
[17:40:42.059]                       if (inherits(cond, "message")) {
[17:40:42.059]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.059]                         if (muffled) 
[17:40:42.059]                           invokeRestart("muffleMessage")
[17:40:42.059]                       }
[17:40:42.059]                       else if (inherits(cond, "warning")) {
[17:40:42.059]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.059]                         if (muffled) 
[17:40:42.059]                           invokeRestart("muffleWarning")
[17:40:42.059]                       }
[17:40:42.059]                       else if (inherits(cond, "condition")) {
[17:40:42.059]                         if (!is.null(pattern)) {
[17:40:42.059]                           computeRestarts <- base::computeRestarts
[17:40:42.059]                           grepl <- base::grepl
[17:40:42.059]                           restarts <- computeRestarts(cond)
[17:40:42.059]                           for (restart in restarts) {
[17:40:42.059]                             name <- restart$name
[17:40:42.059]                             if (is.null(name)) 
[17:40:42.059]                               next
[17:40:42.059]                             if (!grepl(pattern, name)) 
[17:40:42.059]                               next
[17:40:42.059]                             invokeRestart(restart)
[17:40:42.059]                             muffled <- TRUE
[17:40:42.059]                             break
[17:40:42.059]                           }
[17:40:42.059]                         }
[17:40:42.059]                       }
[17:40:42.059]                       invisible(muffled)
[17:40:42.059]                     }
[17:40:42.059]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.059]                   }
[17:40:42.059]                 }
[17:40:42.059]             }
[17:40:42.059]         }))
[17:40:42.059]     }, error = function(ex) {
[17:40:42.059]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.059]                 ...future.rng), started = ...future.startTime, 
[17:40:42.059]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.059]             version = "1.8"), class = "FutureResult")
[17:40:42.059]     }, finally = {
[17:40:42.059]         if (!identical(...future.workdir, getwd())) 
[17:40:42.059]             setwd(...future.workdir)
[17:40:42.059]         {
[17:40:42.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.059]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.059]             }
[17:40:42.059]             base::options(...future.oldOptions)
[17:40:42.059]             if (.Platform$OS.type == "windows") {
[17:40:42.059]                 old_names <- names(...future.oldEnvVars)
[17:40:42.059]                 envs <- base::Sys.getenv()
[17:40:42.059]                 names <- names(envs)
[17:40:42.059]                 common <- intersect(names, old_names)
[17:40:42.059]                 added <- setdiff(names, old_names)
[17:40:42.059]                 removed <- setdiff(old_names, names)
[17:40:42.059]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.059]                   envs[common]]
[17:40:42.059]                 NAMES <- toupper(changed)
[17:40:42.059]                 args <- list()
[17:40:42.059]                 for (kk in seq_along(NAMES)) {
[17:40:42.059]                   name <- changed[[kk]]
[17:40:42.059]                   NAME <- NAMES[[kk]]
[17:40:42.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.059]                     next
[17:40:42.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.059]                 }
[17:40:42.059]                 NAMES <- toupper(added)
[17:40:42.059]                 for (kk in seq_along(NAMES)) {
[17:40:42.059]                   name <- added[[kk]]
[17:40:42.059]                   NAME <- NAMES[[kk]]
[17:40:42.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.059]                     next
[17:40:42.059]                   args[[name]] <- ""
[17:40:42.059]                 }
[17:40:42.059]                 NAMES <- toupper(removed)
[17:40:42.059]                 for (kk in seq_along(NAMES)) {
[17:40:42.059]                   name <- removed[[kk]]
[17:40:42.059]                   NAME <- NAMES[[kk]]
[17:40:42.059]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.059]                     next
[17:40:42.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.059]                 }
[17:40:42.059]                 if (length(args) > 0) 
[17:40:42.059]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.059]             }
[17:40:42.059]             else {
[17:40:42.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.059]             }
[17:40:42.059]             {
[17:40:42.059]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.059]                   0L) {
[17:40:42.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.059]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.059]                   base::options(opts)
[17:40:42.059]                 }
[17:40:42.059]                 {
[17:40:42.059]                   {
[17:40:42.059]                     NULL
[17:40:42.059]                     RNGkind("Mersenne-Twister")
[17:40:42.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.059]                       inherits = FALSE)
[17:40:42.059]                   }
[17:40:42.059]                   options(future.plan = NULL)
[17:40:42.059]                   if (is.na(NA_character_)) 
[17:40:42.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.059]                     .init = FALSE)
[17:40:42.059]                 }
[17:40:42.059]             }
[17:40:42.059]         }
[17:40:42.059]     })
[17:40:42.059]     if (TRUE) {
[17:40:42.059]         base::sink(type = "output", split = FALSE)
[17:40:42.059]         if (TRUE) {
[17:40:42.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.059]         }
[17:40:42.059]         else {
[17:40:42.059]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.059]         }
[17:40:42.059]         base::close(...future.stdout)
[17:40:42.059]         ...future.stdout <- NULL
[17:40:42.059]     }
[17:40:42.059]     ...future.result$conditions <- ...future.conditions
[17:40:42.059]     ...future.result$finished <- base::Sys.time()
[17:40:42.059]     ...future.result
[17:40:42.059] }
[17:40:42.060] plan(): Setting new future strategy stack:
[17:40:42.061] List of future strategies:
[17:40:42.061] 1. sequential:
[17:40:42.061]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.061]    - tweaked: FALSE
[17:40:42.061]    - call: NULL
[17:40:42.061] plan(): nbrOfWorkers() = 1
[17:40:42.062] plan(): Setting new future strategy stack:
[17:40:42.062] List of future strategies:
[17:40:42.062] 1. sequential:
[17:40:42.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.062]    - tweaked: FALSE
[17:40:42.062]    - call: plan(strategy)
[17:40:42.062] plan(): nbrOfWorkers() = 1
[17:40:42.062] SequentialFuture started (and completed)
[17:40:42.062] - Launch lazy future ... done
[17:40:42.063] run() for ‘SequentialFuture’ ... done
[17:40:42.063] resolve() on list environment ...
[17:40:42.063]  recursive: 0
[17:40:42.064]  length: 3
[17:40:42.064]  elements: ‘a’, ‘b’, ‘c’
[17:40:42.064] resolved() for ‘SequentialFuture’ ...
[17:40:42.064] - state: ‘finished’
[17:40:42.064] - run: TRUE
[17:40:42.064] - result: ‘FutureResult’
[17:40:42.064] resolved() for ‘SequentialFuture’ ... done
[17:40:42.064] Future #1
[17:40:42.065]  length: 2 (resolved future 1)
[17:40:42.065] resolved() for ‘SequentialFuture’ ...
[17:40:42.065] - state: ‘finished’
[17:40:42.065] - run: TRUE
[17:40:42.065] - result: ‘FutureResult’
[17:40:42.065] resolved() for ‘SequentialFuture’ ... done
[17:40:42.065] Future #2
[17:40:42.065]  length: 1 (resolved future 2)
[17:40:42.065]  length: 0 (resolved future 3)
[17:40:42.065] resolve() on list environment ... DONE
[17:40:42.068] getGlobalsAndPackages() ...
[17:40:42.068] Searching for globals...
[17:40:42.068] - globals found: [1] ‘{’
[17:40:42.068] Searching for globals ... DONE
[17:40:42.069] Resolving globals: FALSE
[17:40:42.069] 
[17:40:42.069] 
[17:40:42.069] getGlobalsAndPackages() ... DONE
[17:40:42.069] run() for ‘Future’ ...
[17:40:42.069] - state: ‘created’
[17:40:42.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.070] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.070]   - Field: ‘label’
[17:40:42.070]   - Field: ‘local’
[17:40:42.070]   - Field: ‘owner’
[17:40:42.070]   - Field: ‘envir’
[17:40:42.070]   - Field: ‘packages’
[17:40:42.070]   - Field: ‘gc’
[17:40:42.070]   - Field: ‘conditions’
[17:40:42.071]   - Field: ‘expr’
[17:40:42.071]   - Field: ‘uuid’
[17:40:42.071]   - Field: ‘seed’
[17:40:42.071]   - Field: ‘version’
[17:40:42.071]   - Field: ‘result’
[17:40:42.071]   - Field: ‘asynchronous’
[17:40:42.071]   - Field: ‘calls’
[17:40:42.071]   - Field: ‘globals’
[17:40:42.071]   - Field: ‘stdout’
[17:40:42.071]   - Field: ‘earlySignal’
[17:40:42.071]   - Field: ‘lazy’
[17:40:42.072]   - Field: ‘state’
[17:40:42.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.072] - Launch lazy future ...
[17:40:42.072] Packages needed by the future expression (n = 0): <none>
[17:40:42.072] Packages needed by future strategies (n = 0): <none>
[17:40:42.072] {
[17:40:42.072]     {
[17:40:42.072]         {
[17:40:42.072]             ...future.startTime <- base::Sys.time()
[17:40:42.072]             {
[17:40:42.072]                 {
[17:40:42.072]                   {
[17:40:42.072]                     base::local({
[17:40:42.072]                       has_future <- base::requireNamespace("future", 
[17:40:42.072]                         quietly = TRUE)
[17:40:42.072]                       if (has_future) {
[17:40:42.072]                         ns <- base::getNamespace("future")
[17:40:42.072]                         version <- ns[[".package"]][["version"]]
[17:40:42.072]                         if (is.null(version)) 
[17:40:42.072]                           version <- utils::packageVersion("future")
[17:40:42.072]                       }
[17:40:42.072]                       else {
[17:40:42.072]                         version <- NULL
[17:40:42.072]                       }
[17:40:42.072]                       if (!has_future || version < "1.8.0") {
[17:40:42.072]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.072]                           "", base::R.version$version.string), 
[17:40:42.072]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.072]                             "release", "version")], collapse = " "), 
[17:40:42.072]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.072]                           info)
[17:40:42.072]                         info <- base::paste(info, collapse = "; ")
[17:40:42.072]                         if (!has_future) {
[17:40:42.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.072]                             info)
[17:40:42.072]                         }
[17:40:42.072]                         else {
[17:40:42.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.072]                             info, version)
[17:40:42.072]                         }
[17:40:42.072]                         base::stop(msg)
[17:40:42.072]                       }
[17:40:42.072]                     })
[17:40:42.072]                   }
[17:40:42.072]                   ...future.strategy.old <- future::plan("list")
[17:40:42.072]                   options(future.plan = NULL)
[17:40:42.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.072]                 }
[17:40:42.072]                 ...future.workdir <- getwd()
[17:40:42.072]             }
[17:40:42.072]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.072]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.072]         }
[17:40:42.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.072]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.072]             base::names(...future.oldOptions))
[17:40:42.072]     }
[17:40:42.072]     if (FALSE) {
[17:40:42.072]     }
[17:40:42.072]     else {
[17:40:42.072]         if (TRUE) {
[17:40:42.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.072]                 open = "w")
[17:40:42.072]         }
[17:40:42.072]         else {
[17:40:42.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.072]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.072]         }
[17:40:42.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.072]             base::sink(type = "output", split = FALSE)
[17:40:42.072]             base::close(...future.stdout)
[17:40:42.072]         }, add = TRUE)
[17:40:42.072]     }
[17:40:42.072]     ...future.frame <- base::sys.nframe()
[17:40:42.072]     ...future.conditions <- base::list()
[17:40:42.072]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.072]     if (FALSE) {
[17:40:42.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.072]     }
[17:40:42.072]     ...future.result <- base::tryCatch({
[17:40:42.072]         base::withCallingHandlers({
[17:40:42.072]             ...future.value <- base::withVisible(base::local({
[17:40:42.072]                 1
[17:40:42.072]             }))
[17:40:42.072]             future::FutureResult(value = ...future.value$value, 
[17:40:42.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.072]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.072]                     ...future.globalenv.names))
[17:40:42.072]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.072]         }, condition = base::local({
[17:40:42.072]             c <- base::c
[17:40:42.072]             inherits <- base::inherits
[17:40:42.072]             invokeRestart <- base::invokeRestart
[17:40:42.072]             length <- base::length
[17:40:42.072]             list <- base::list
[17:40:42.072]             seq.int <- base::seq.int
[17:40:42.072]             signalCondition <- base::signalCondition
[17:40:42.072]             sys.calls <- base::sys.calls
[17:40:42.072]             `[[` <- base::`[[`
[17:40:42.072]             `+` <- base::`+`
[17:40:42.072]             `<<-` <- base::`<<-`
[17:40:42.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.072]                   3L)]
[17:40:42.072]             }
[17:40:42.072]             function(cond) {
[17:40:42.072]                 is_error <- inherits(cond, "error")
[17:40:42.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.072]                   NULL)
[17:40:42.072]                 if (is_error) {
[17:40:42.072]                   sessionInformation <- function() {
[17:40:42.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.072]                       search = base::search(), system = base::Sys.info())
[17:40:42.072]                   }
[17:40:42.072]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.072]                     cond$call), session = sessionInformation(), 
[17:40:42.072]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.072]                   signalCondition(cond)
[17:40:42.072]                 }
[17:40:42.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.072]                 "immediateCondition"))) {
[17:40:42.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.072]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.072]                   if (TRUE && !signal) {
[17:40:42.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.072]                     {
[17:40:42.072]                       inherits <- base::inherits
[17:40:42.072]                       invokeRestart <- base::invokeRestart
[17:40:42.072]                       is.null <- base::is.null
[17:40:42.072]                       muffled <- FALSE
[17:40:42.072]                       if (inherits(cond, "message")) {
[17:40:42.072]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.072]                         if (muffled) 
[17:40:42.072]                           invokeRestart("muffleMessage")
[17:40:42.072]                       }
[17:40:42.072]                       else if (inherits(cond, "warning")) {
[17:40:42.072]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.072]                         if (muffled) 
[17:40:42.072]                           invokeRestart("muffleWarning")
[17:40:42.072]                       }
[17:40:42.072]                       else if (inherits(cond, "condition")) {
[17:40:42.072]                         if (!is.null(pattern)) {
[17:40:42.072]                           computeRestarts <- base::computeRestarts
[17:40:42.072]                           grepl <- base::grepl
[17:40:42.072]                           restarts <- computeRestarts(cond)
[17:40:42.072]                           for (restart in restarts) {
[17:40:42.072]                             name <- restart$name
[17:40:42.072]                             if (is.null(name)) 
[17:40:42.072]                               next
[17:40:42.072]                             if (!grepl(pattern, name)) 
[17:40:42.072]                               next
[17:40:42.072]                             invokeRestart(restart)
[17:40:42.072]                             muffled <- TRUE
[17:40:42.072]                             break
[17:40:42.072]                           }
[17:40:42.072]                         }
[17:40:42.072]                       }
[17:40:42.072]                       invisible(muffled)
[17:40:42.072]                     }
[17:40:42.072]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.072]                   }
[17:40:42.072]                 }
[17:40:42.072]                 else {
[17:40:42.072]                   if (TRUE) {
[17:40:42.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.072]                     {
[17:40:42.072]                       inherits <- base::inherits
[17:40:42.072]                       invokeRestart <- base::invokeRestart
[17:40:42.072]                       is.null <- base::is.null
[17:40:42.072]                       muffled <- FALSE
[17:40:42.072]                       if (inherits(cond, "message")) {
[17:40:42.072]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.072]                         if (muffled) 
[17:40:42.072]                           invokeRestart("muffleMessage")
[17:40:42.072]                       }
[17:40:42.072]                       else if (inherits(cond, "warning")) {
[17:40:42.072]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.072]                         if (muffled) 
[17:40:42.072]                           invokeRestart("muffleWarning")
[17:40:42.072]                       }
[17:40:42.072]                       else if (inherits(cond, "condition")) {
[17:40:42.072]                         if (!is.null(pattern)) {
[17:40:42.072]                           computeRestarts <- base::computeRestarts
[17:40:42.072]                           grepl <- base::grepl
[17:40:42.072]                           restarts <- computeRestarts(cond)
[17:40:42.072]                           for (restart in restarts) {
[17:40:42.072]                             name <- restart$name
[17:40:42.072]                             if (is.null(name)) 
[17:40:42.072]                               next
[17:40:42.072]                             if (!grepl(pattern, name)) 
[17:40:42.072]                               next
[17:40:42.072]                             invokeRestart(restart)
[17:40:42.072]                             muffled <- TRUE
[17:40:42.072]                             break
[17:40:42.072]                           }
[17:40:42.072]                         }
[17:40:42.072]                       }
[17:40:42.072]                       invisible(muffled)
[17:40:42.072]                     }
[17:40:42.072]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.072]                   }
[17:40:42.072]                 }
[17:40:42.072]             }
[17:40:42.072]         }))
[17:40:42.072]     }, error = function(ex) {
[17:40:42.072]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.072]                 ...future.rng), started = ...future.startTime, 
[17:40:42.072]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.072]             version = "1.8"), class = "FutureResult")
[17:40:42.072]     }, finally = {
[17:40:42.072]         if (!identical(...future.workdir, getwd())) 
[17:40:42.072]             setwd(...future.workdir)
[17:40:42.072]         {
[17:40:42.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.072]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.072]             }
[17:40:42.072]             base::options(...future.oldOptions)
[17:40:42.072]             if (.Platform$OS.type == "windows") {
[17:40:42.072]                 old_names <- names(...future.oldEnvVars)
[17:40:42.072]                 envs <- base::Sys.getenv()
[17:40:42.072]                 names <- names(envs)
[17:40:42.072]                 common <- intersect(names, old_names)
[17:40:42.072]                 added <- setdiff(names, old_names)
[17:40:42.072]                 removed <- setdiff(old_names, names)
[17:40:42.072]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.072]                   envs[common]]
[17:40:42.072]                 NAMES <- toupper(changed)
[17:40:42.072]                 args <- list()
[17:40:42.072]                 for (kk in seq_along(NAMES)) {
[17:40:42.072]                   name <- changed[[kk]]
[17:40:42.072]                   NAME <- NAMES[[kk]]
[17:40:42.072]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.072]                     next
[17:40:42.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.072]                 }
[17:40:42.072]                 NAMES <- toupper(added)
[17:40:42.072]                 for (kk in seq_along(NAMES)) {
[17:40:42.072]                   name <- added[[kk]]
[17:40:42.072]                   NAME <- NAMES[[kk]]
[17:40:42.072]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.072]                     next
[17:40:42.072]                   args[[name]] <- ""
[17:40:42.072]                 }
[17:40:42.072]                 NAMES <- toupper(removed)
[17:40:42.072]                 for (kk in seq_along(NAMES)) {
[17:40:42.072]                   name <- removed[[kk]]
[17:40:42.072]                   NAME <- NAMES[[kk]]
[17:40:42.072]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.072]                     next
[17:40:42.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.072]                 }
[17:40:42.072]                 if (length(args) > 0) 
[17:40:42.072]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.072]             }
[17:40:42.072]             else {
[17:40:42.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.072]             }
[17:40:42.072]             {
[17:40:42.072]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.072]                   0L) {
[17:40:42.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.072]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.072]                   base::options(opts)
[17:40:42.072]                 }
[17:40:42.072]                 {
[17:40:42.072]                   {
[17:40:42.072]                     NULL
[17:40:42.072]                     RNGkind("Mersenne-Twister")
[17:40:42.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.072]                       inherits = FALSE)
[17:40:42.072]                   }
[17:40:42.072]                   options(future.plan = NULL)
[17:40:42.072]                   if (is.na(NA_character_)) 
[17:40:42.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.072]                     .init = FALSE)
[17:40:42.072]                 }
[17:40:42.072]             }
[17:40:42.072]         }
[17:40:42.072]     })
[17:40:42.072]     if (TRUE) {
[17:40:42.072]         base::sink(type = "output", split = FALSE)
[17:40:42.072]         if (TRUE) {
[17:40:42.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.072]         }
[17:40:42.072]         else {
[17:40:42.072]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.072]         }
[17:40:42.072]         base::close(...future.stdout)
[17:40:42.072]         ...future.stdout <- NULL
[17:40:42.072]     }
[17:40:42.072]     ...future.result$conditions <- ...future.conditions
[17:40:42.072]     ...future.result$finished <- base::Sys.time()
[17:40:42.072]     ...future.result
[17:40:42.072] }
[17:40:42.074] plan(): Setting new future strategy stack:
[17:40:42.074] List of future strategies:
[17:40:42.074] 1. sequential:
[17:40:42.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.074]    - tweaked: FALSE
[17:40:42.074]    - call: NULL
[17:40:42.075] plan(): nbrOfWorkers() = 1
[17:40:42.075] plan(): Setting new future strategy stack:
[17:40:42.075] List of future strategies:
[17:40:42.075] 1. sequential:
[17:40:42.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.075]    - tweaked: FALSE
[17:40:42.075]    - call: plan(strategy)
[17:40:42.076] plan(): nbrOfWorkers() = 1
[17:40:42.076] SequentialFuture started (and completed)
[17:40:42.076] - Launch lazy future ... done
[17:40:42.076] run() for ‘SequentialFuture’ ... done
[17:40:42.077] getGlobalsAndPackages() ...
[17:40:42.077] Searching for globals...
[17:40:42.078] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:40:42.078] Searching for globals ... DONE
[17:40:42.078] Resolving globals: FALSE
[17:40:42.078] 
[17:40:42.078] 
[17:40:42.078] getGlobalsAndPackages() ... DONE
[17:40:42.079] run() for ‘Future’ ...
[17:40:42.079] - state: ‘created’
[17:40:42.079] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.079] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.079] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.079]   - Field: ‘label’
[17:40:42.079]   - Field: ‘local’
[17:40:42.079]   - Field: ‘owner’
[17:40:42.080]   - Field: ‘envir’
[17:40:42.080]   - Field: ‘packages’
[17:40:42.080]   - Field: ‘gc’
[17:40:42.080]   - Field: ‘conditions’
[17:40:42.080]   - Field: ‘expr’
[17:40:42.080]   - Field: ‘uuid’
[17:40:42.080]   - Field: ‘seed’
[17:40:42.080]   - Field: ‘version’
[17:40:42.080]   - Field: ‘result’
[17:40:42.080]   - Field: ‘asynchronous’
[17:40:42.080]   - Field: ‘calls’
[17:40:42.081]   - Field: ‘globals’
[17:40:42.081]   - Field: ‘stdout’
[17:40:42.081]   - Field: ‘earlySignal’
[17:40:42.081]   - Field: ‘lazy’
[17:40:42.081]   - Field: ‘state’
[17:40:42.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.081] - Launch lazy future ...
[17:40:42.081] Packages needed by the future expression (n = 0): <none>
[17:40:42.081] Packages needed by future strategies (n = 0): <none>
[17:40:42.082] {
[17:40:42.082]     {
[17:40:42.082]         {
[17:40:42.082]             ...future.startTime <- base::Sys.time()
[17:40:42.082]             {
[17:40:42.082]                 {
[17:40:42.082]                   {
[17:40:42.082]                     base::local({
[17:40:42.082]                       has_future <- base::requireNamespace("future", 
[17:40:42.082]                         quietly = TRUE)
[17:40:42.082]                       if (has_future) {
[17:40:42.082]                         ns <- base::getNamespace("future")
[17:40:42.082]                         version <- ns[[".package"]][["version"]]
[17:40:42.082]                         if (is.null(version)) 
[17:40:42.082]                           version <- utils::packageVersion("future")
[17:40:42.082]                       }
[17:40:42.082]                       else {
[17:40:42.082]                         version <- NULL
[17:40:42.082]                       }
[17:40:42.082]                       if (!has_future || version < "1.8.0") {
[17:40:42.082]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.082]                           "", base::R.version$version.string), 
[17:40:42.082]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.082]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.082]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.082]                             "release", "version")], collapse = " "), 
[17:40:42.082]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.082]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.082]                           info)
[17:40:42.082]                         info <- base::paste(info, collapse = "; ")
[17:40:42.082]                         if (!has_future) {
[17:40:42.082]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.082]                             info)
[17:40:42.082]                         }
[17:40:42.082]                         else {
[17:40:42.082]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.082]                             info, version)
[17:40:42.082]                         }
[17:40:42.082]                         base::stop(msg)
[17:40:42.082]                       }
[17:40:42.082]                     })
[17:40:42.082]                   }
[17:40:42.082]                   ...future.strategy.old <- future::plan("list")
[17:40:42.082]                   options(future.plan = NULL)
[17:40:42.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.082]                 }
[17:40:42.082]                 ...future.workdir <- getwd()
[17:40:42.082]             }
[17:40:42.082]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.082]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.082]         }
[17:40:42.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.082]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.082]             base::names(...future.oldOptions))
[17:40:42.082]     }
[17:40:42.082]     if (FALSE) {
[17:40:42.082]     }
[17:40:42.082]     else {
[17:40:42.082]         if (TRUE) {
[17:40:42.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.082]                 open = "w")
[17:40:42.082]         }
[17:40:42.082]         else {
[17:40:42.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.082]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.082]         }
[17:40:42.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.082]             base::sink(type = "output", split = FALSE)
[17:40:42.082]             base::close(...future.stdout)
[17:40:42.082]         }, add = TRUE)
[17:40:42.082]     }
[17:40:42.082]     ...future.frame <- base::sys.nframe()
[17:40:42.082]     ...future.conditions <- base::list()
[17:40:42.082]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.082]     if (FALSE) {
[17:40:42.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.082]     }
[17:40:42.082]     ...future.result <- base::tryCatch({
[17:40:42.082]         base::withCallingHandlers({
[17:40:42.082]             ...future.value <- base::withVisible(base::local({
[17:40:42.082]                 Sys.sleep(0.5)
[17:40:42.082]                 2
[17:40:42.082]             }))
[17:40:42.082]             future::FutureResult(value = ...future.value$value, 
[17:40:42.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.082]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.082]                     ...future.globalenv.names))
[17:40:42.082]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.082]         }, condition = base::local({
[17:40:42.082]             c <- base::c
[17:40:42.082]             inherits <- base::inherits
[17:40:42.082]             invokeRestart <- base::invokeRestart
[17:40:42.082]             length <- base::length
[17:40:42.082]             list <- base::list
[17:40:42.082]             seq.int <- base::seq.int
[17:40:42.082]             signalCondition <- base::signalCondition
[17:40:42.082]             sys.calls <- base::sys.calls
[17:40:42.082]             `[[` <- base::`[[`
[17:40:42.082]             `+` <- base::`+`
[17:40:42.082]             `<<-` <- base::`<<-`
[17:40:42.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.082]                   3L)]
[17:40:42.082]             }
[17:40:42.082]             function(cond) {
[17:40:42.082]                 is_error <- inherits(cond, "error")
[17:40:42.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.082]                   NULL)
[17:40:42.082]                 if (is_error) {
[17:40:42.082]                   sessionInformation <- function() {
[17:40:42.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.082]                       search = base::search(), system = base::Sys.info())
[17:40:42.082]                   }
[17:40:42.082]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.082]                     cond$call), session = sessionInformation(), 
[17:40:42.082]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.082]                   signalCondition(cond)
[17:40:42.082]                 }
[17:40:42.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.082]                 "immediateCondition"))) {
[17:40:42.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.082]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.082]                   if (TRUE && !signal) {
[17:40:42.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.082]                     {
[17:40:42.082]                       inherits <- base::inherits
[17:40:42.082]                       invokeRestart <- base::invokeRestart
[17:40:42.082]                       is.null <- base::is.null
[17:40:42.082]                       muffled <- FALSE
[17:40:42.082]                       if (inherits(cond, "message")) {
[17:40:42.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.082]                         if (muffled) 
[17:40:42.082]                           invokeRestart("muffleMessage")
[17:40:42.082]                       }
[17:40:42.082]                       else if (inherits(cond, "warning")) {
[17:40:42.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.082]                         if (muffled) 
[17:40:42.082]                           invokeRestart("muffleWarning")
[17:40:42.082]                       }
[17:40:42.082]                       else if (inherits(cond, "condition")) {
[17:40:42.082]                         if (!is.null(pattern)) {
[17:40:42.082]                           computeRestarts <- base::computeRestarts
[17:40:42.082]                           grepl <- base::grepl
[17:40:42.082]                           restarts <- computeRestarts(cond)
[17:40:42.082]                           for (restart in restarts) {
[17:40:42.082]                             name <- restart$name
[17:40:42.082]                             if (is.null(name)) 
[17:40:42.082]                               next
[17:40:42.082]                             if (!grepl(pattern, name)) 
[17:40:42.082]                               next
[17:40:42.082]                             invokeRestart(restart)
[17:40:42.082]                             muffled <- TRUE
[17:40:42.082]                             break
[17:40:42.082]                           }
[17:40:42.082]                         }
[17:40:42.082]                       }
[17:40:42.082]                       invisible(muffled)
[17:40:42.082]                     }
[17:40:42.082]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.082]                   }
[17:40:42.082]                 }
[17:40:42.082]                 else {
[17:40:42.082]                   if (TRUE) {
[17:40:42.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.082]                     {
[17:40:42.082]                       inherits <- base::inherits
[17:40:42.082]                       invokeRestart <- base::invokeRestart
[17:40:42.082]                       is.null <- base::is.null
[17:40:42.082]                       muffled <- FALSE
[17:40:42.082]                       if (inherits(cond, "message")) {
[17:40:42.082]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.082]                         if (muffled) 
[17:40:42.082]                           invokeRestart("muffleMessage")
[17:40:42.082]                       }
[17:40:42.082]                       else if (inherits(cond, "warning")) {
[17:40:42.082]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.082]                         if (muffled) 
[17:40:42.082]                           invokeRestart("muffleWarning")
[17:40:42.082]                       }
[17:40:42.082]                       else if (inherits(cond, "condition")) {
[17:40:42.082]                         if (!is.null(pattern)) {
[17:40:42.082]                           computeRestarts <- base::computeRestarts
[17:40:42.082]                           grepl <- base::grepl
[17:40:42.082]                           restarts <- computeRestarts(cond)
[17:40:42.082]                           for (restart in restarts) {
[17:40:42.082]                             name <- restart$name
[17:40:42.082]                             if (is.null(name)) 
[17:40:42.082]                               next
[17:40:42.082]                             if (!grepl(pattern, name)) 
[17:40:42.082]                               next
[17:40:42.082]                             invokeRestart(restart)
[17:40:42.082]                             muffled <- TRUE
[17:40:42.082]                             break
[17:40:42.082]                           }
[17:40:42.082]                         }
[17:40:42.082]                       }
[17:40:42.082]                       invisible(muffled)
[17:40:42.082]                     }
[17:40:42.082]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.082]                   }
[17:40:42.082]                 }
[17:40:42.082]             }
[17:40:42.082]         }))
[17:40:42.082]     }, error = function(ex) {
[17:40:42.082]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.082]                 ...future.rng), started = ...future.startTime, 
[17:40:42.082]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.082]             version = "1.8"), class = "FutureResult")
[17:40:42.082]     }, finally = {
[17:40:42.082]         if (!identical(...future.workdir, getwd())) 
[17:40:42.082]             setwd(...future.workdir)
[17:40:42.082]         {
[17:40:42.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.082]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.082]             }
[17:40:42.082]             base::options(...future.oldOptions)
[17:40:42.082]             if (.Platform$OS.type == "windows") {
[17:40:42.082]                 old_names <- names(...future.oldEnvVars)
[17:40:42.082]                 envs <- base::Sys.getenv()
[17:40:42.082]                 names <- names(envs)
[17:40:42.082]                 common <- intersect(names, old_names)
[17:40:42.082]                 added <- setdiff(names, old_names)
[17:40:42.082]                 removed <- setdiff(old_names, names)
[17:40:42.082]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.082]                   envs[common]]
[17:40:42.082]                 NAMES <- toupper(changed)
[17:40:42.082]                 args <- list()
[17:40:42.082]                 for (kk in seq_along(NAMES)) {
[17:40:42.082]                   name <- changed[[kk]]
[17:40:42.082]                   NAME <- NAMES[[kk]]
[17:40:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.082]                     next
[17:40:42.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.082]                 }
[17:40:42.082]                 NAMES <- toupper(added)
[17:40:42.082]                 for (kk in seq_along(NAMES)) {
[17:40:42.082]                   name <- added[[kk]]
[17:40:42.082]                   NAME <- NAMES[[kk]]
[17:40:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.082]                     next
[17:40:42.082]                   args[[name]] <- ""
[17:40:42.082]                 }
[17:40:42.082]                 NAMES <- toupper(removed)
[17:40:42.082]                 for (kk in seq_along(NAMES)) {
[17:40:42.082]                   name <- removed[[kk]]
[17:40:42.082]                   NAME <- NAMES[[kk]]
[17:40:42.082]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.082]                     next
[17:40:42.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.082]                 }
[17:40:42.082]                 if (length(args) > 0) 
[17:40:42.082]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.082]             }
[17:40:42.082]             else {
[17:40:42.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.082]             }
[17:40:42.082]             {
[17:40:42.082]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.082]                   0L) {
[17:40:42.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.082]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.082]                   base::options(opts)
[17:40:42.082]                 }
[17:40:42.082]                 {
[17:40:42.082]                   {
[17:40:42.082]                     NULL
[17:40:42.082]                     RNGkind("Mersenne-Twister")
[17:40:42.082]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.082]                       inherits = FALSE)
[17:40:42.082]                   }
[17:40:42.082]                   options(future.plan = NULL)
[17:40:42.082]                   if (is.na(NA_character_)) 
[17:40:42.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.082]                     .init = FALSE)
[17:40:42.082]                 }
[17:40:42.082]             }
[17:40:42.082]         }
[17:40:42.082]     })
[17:40:42.082]     if (TRUE) {
[17:40:42.082]         base::sink(type = "output", split = FALSE)
[17:40:42.082]         if (TRUE) {
[17:40:42.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.082]         }
[17:40:42.082]         else {
[17:40:42.082]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.082]         }
[17:40:42.082]         base::close(...future.stdout)
[17:40:42.082]         ...future.stdout <- NULL
[17:40:42.082]     }
[17:40:42.082]     ...future.result$conditions <- ...future.conditions
[17:40:42.082]     ...future.result$finished <- base::Sys.time()
[17:40:42.082]     ...future.result
[17:40:42.082] }
[17:40:42.083] plan(): Setting new future strategy stack:
[17:40:42.084] List of future strategies:
[17:40:42.084] 1. sequential:
[17:40:42.084]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.084]    - tweaked: FALSE
[17:40:42.084]    - call: NULL
[17:40:42.084] plan(): nbrOfWorkers() = 1
[17:40:42.586] plan(): Setting new future strategy stack:
[17:40:42.586] List of future strategies:
[17:40:42.586] 1. sequential:
[17:40:42.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.586]    - tweaked: FALSE
[17:40:42.586]    - call: plan(strategy)
[17:40:42.586] plan(): nbrOfWorkers() = 1
[17:40:42.587] SequentialFuture started (and completed)
[17:40:42.587] - Launch lazy future ... done
[17:40:42.587] run() for ‘SequentialFuture’ ... done
[17:40:42.587] getGlobalsAndPackages() ...
[17:40:42.587] Searching for globals...
[17:40:42.588] - globals found: [1] ‘{’
[17:40:42.588] Searching for globals ... DONE
[17:40:42.588] Resolving globals: FALSE
[17:40:42.588] 
[17:40:42.589] 
[17:40:42.589] getGlobalsAndPackages() ... DONE
[17:40:42.589] run() for ‘Future’ ...
[17:40:42.589] - state: ‘created’
[17:40:42.589] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:40:42.589] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:40:42.589] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:40:42.590]   - Field: ‘label’
[17:40:42.590]   - Field: ‘local’
[17:40:42.590]   - Field: ‘owner’
[17:40:42.590]   - Field: ‘envir’
[17:40:42.590]   - Field: ‘packages’
[17:40:42.590]   - Field: ‘gc’
[17:40:42.590]   - Field: ‘conditions’
[17:40:42.590]   - Field: ‘expr’
[17:40:42.590]   - Field: ‘uuid’
[17:40:42.590]   - Field: ‘seed’
[17:40:42.591]   - Field: ‘version’
[17:40:42.591]   - Field: ‘result’
[17:40:42.591]   - Field: ‘asynchronous’
[17:40:42.591]   - Field: ‘calls’
[17:40:42.591]   - Field: ‘globals’
[17:40:42.591]   - Field: ‘stdout’
[17:40:42.591]   - Field: ‘earlySignal’
[17:40:42.591]   - Field: ‘lazy’
[17:40:42.591]   - Field: ‘state’
[17:40:42.591] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:40:42.591] - Launch lazy future ...
[17:40:42.592] Packages needed by the future expression (n = 0): <none>
[17:40:42.592] Packages needed by future strategies (n = 0): <none>
[17:40:42.592] {
[17:40:42.592]     {
[17:40:42.592]         {
[17:40:42.592]             ...future.startTime <- base::Sys.time()
[17:40:42.592]             {
[17:40:42.592]                 {
[17:40:42.592]                   {
[17:40:42.592]                     base::local({
[17:40:42.592]                       has_future <- base::requireNamespace("future", 
[17:40:42.592]                         quietly = TRUE)
[17:40:42.592]                       if (has_future) {
[17:40:42.592]                         ns <- base::getNamespace("future")
[17:40:42.592]                         version <- ns[[".package"]][["version"]]
[17:40:42.592]                         if (is.null(version)) 
[17:40:42.592]                           version <- utils::packageVersion("future")
[17:40:42.592]                       }
[17:40:42.592]                       else {
[17:40:42.592]                         version <- NULL
[17:40:42.592]                       }
[17:40:42.592]                       if (!has_future || version < "1.8.0") {
[17:40:42.592]                         info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.592]                           "", base::R.version$version.string), 
[17:40:42.592]                           platform = base::sprintf("%s (%s-bit)", 
[17:40:42.592]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.592]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.592]                             "release", "version")], collapse = " "), 
[17:40:42.592]                           hostname = base::Sys.info()[["nodename"]])
[17:40:42.592]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.592]                           info)
[17:40:42.592]                         info <- base::paste(info, collapse = "; ")
[17:40:42.592]                         if (!has_future) {
[17:40:42.592]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.592]                             info)
[17:40:42.592]                         }
[17:40:42.592]                         else {
[17:40:42.592]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.592]                             info, version)
[17:40:42.592]                         }
[17:40:42.592]                         base::stop(msg)
[17:40:42.592]                       }
[17:40:42.592]                     })
[17:40:42.592]                   }
[17:40:42.592]                   ...future.strategy.old <- future::plan("list")
[17:40:42.592]                   options(future.plan = NULL)
[17:40:42.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.592]                 }
[17:40:42.592]                 ...future.workdir <- getwd()
[17:40:42.592]             }
[17:40:42.592]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.592]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.592]         }
[17:40:42.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.592]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.592]             base::names(...future.oldOptions))
[17:40:42.592]     }
[17:40:42.592]     if (FALSE) {
[17:40:42.592]     }
[17:40:42.592]     else {
[17:40:42.592]         if (TRUE) {
[17:40:42.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.592]                 open = "w")
[17:40:42.592]         }
[17:40:42.592]         else {
[17:40:42.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.592]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.592]         }
[17:40:42.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.592]             base::sink(type = "output", split = FALSE)
[17:40:42.592]             base::close(...future.stdout)
[17:40:42.592]         }, add = TRUE)
[17:40:42.592]     }
[17:40:42.592]     ...future.frame <- base::sys.nframe()
[17:40:42.592]     ...future.conditions <- base::list()
[17:40:42.592]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.592]     if (FALSE) {
[17:40:42.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.592]     }
[17:40:42.592]     ...future.result <- base::tryCatch({
[17:40:42.592]         base::withCallingHandlers({
[17:40:42.592]             ...future.value <- base::withVisible(base::local({
[17:40:42.592]                 3
[17:40:42.592]             }))
[17:40:42.592]             future::FutureResult(value = ...future.value$value, 
[17:40:42.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.592]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.592]                     ...future.globalenv.names))
[17:40:42.592]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.592]         }, condition = base::local({
[17:40:42.592]             c <- base::c
[17:40:42.592]             inherits <- base::inherits
[17:40:42.592]             invokeRestart <- base::invokeRestart
[17:40:42.592]             length <- base::length
[17:40:42.592]             list <- base::list
[17:40:42.592]             seq.int <- base::seq.int
[17:40:42.592]             signalCondition <- base::signalCondition
[17:40:42.592]             sys.calls <- base::sys.calls
[17:40:42.592]             `[[` <- base::`[[`
[17:40:42.592]             `+` <- base::`+`
[17:40:42.592]             `<<-` <- base::`<<-`
[17:40:42.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.592]                   3L)]
[17:40:42.592]             }
[17:40:42.592]             function(cond) {
[17:40:42.592]                 is_error <- inherits(cond, "error")
[17:40:42.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.592]                   NULL)
[17:40:42.592]                 if (is_error) {
[17:40:42.592]                   sessionInformation <- function() {
[17:40:42.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.592]                       search = base::search(), system = base::Sys.info())
[17:40:42.592]                   }
[17:40:42.592]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.592]                     cond$call), session = sessionInformation(), 
[17:40:42.592]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.592]                   signalCondition(cond)
[17:40:42.592]                 }
[17:40:42.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.592]                 "immediateCondition"))) {
[17:40:42.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.592]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.592]                   if (TRUE && !signal) {
[17:40:42.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.592]                     {
[17:40:42.592]                       inherits <- base::inherits
[17:40:42.592]                       invokeRestart <- base::invokeRestart
[17:40:42.592]                       is.null <- base::is.null
[17:40:42.592]                       muffled <- FALSE
[17:40:42.592]                       if (inherits(cond, "message")) {
[17:40:42.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.592]                         if (muffled) 
[17:40:42.592]                           invokeRestart("muffleMessage")
[17:40:42.592]                       }
[17:40:42.592]                       else if (inherits(cond, "warning")) {
[17:40:42.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.592]                         if (muffled) 
[17:40:42.592]                           invokeRestart("muffleWarning")
[17:40:42.592]                       }
[17:40:42.592]                       else if (inherits(cond, "condition")) {
[17:40:42.592]                         if (!is.null(pattern)) {
[17:40:42.592]                           computeRestarts <- base::computeRestarts
[17:40:42.592]                           grepl <- base::grepl
[17:40:42.592]                           restarts <- computeRestarts(cond)
[17:40:42.592]                           for (restart in restarts) {
[17:40:42.592]                             name <- restart$name
[17:40:42.592]                             if (is.null(name)) 
[17:40:42.592]                               next
[17:40:42.592]                             if (!grepl(pattern, name)) 
[17:40:42.592]                               next
[17:40:42.592]                             invokeRestart(restart)
[17:40:42.592]                             muffled <- TRUE
[17:40:42.592]                             break
[17:40:42.592]                           }
[17:40:42.592]                         }
[17:40:42.592]                       }
[17:40:42.592]                       invisible(muffled)
[17:40:42.592]                     }
[17:40:42.592]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.592]                   }
[17:40:42.592]                 }
[17:40:42.592]                 else {
[17:40:42.592]                   if (TRUE) {
[17:40:42.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.592]                     {
[17:40:42.592]                       inherits <- base::inherits
[17:40:42.592]                       invokeRestart <- base::invokeRestart
[17:40:42.592]                       is.null <- base::is.null
[17:40:42.592]                       muffled <- FALSE
[17:40:42.592]                       if (inherits(cond, "message")) {
[17:40:42.592]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.592]                         if (muffled) 
[17:40:42.592]                           invokeRestart("muffleMessage")
[17:40:42.592]                       }
[17:40:42.592]                       else if (inherits(cond, "warning")) {
[17:40:42.592]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.592]                         if (muffled) 
[17:40:42.592]                           invokeRestart("muffleWarning")
[17:40:42.592]                       }
[17:40:42.592]                       else if (inherits(cond, "condition")) {
[17:40:42.592]                         if (!is.null(pattern)) {
[17:40:42.592]                           computeRestarts <- base::computeRestarts
[17:40:42.592]                           grepl <- base::grepl
[17:40:42.592]                           restarts <- computeRestarts(cond)
[17:40:42.592]                           for (restart in restarts) {
[17:40:42.592]                             name <- restart$name
[17:40:42.592]                             if (is.null(name)) 
[17:40:42.592]                               next
[17:40:42.592]                             if (!grepl(pattern, name)) 
[17:40:42.592]                               next
[17:40:42.592]                             invokeRestart(restart)
[17:40:42.592]                             muffled <- TRUE
[17:40:42.592]                             break
[17:40:42.592]                           }
[17:40:42.592]                         }
[17:40:42.592]                       }
[17:40:42.592]                       invisible(muffled)
[17:40:42.592]                     }
[17:40:42.592]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.592]                   }
[17:40:42.592]                 }
[17:40:42.592]             }
[17:40:42.592]         }))
[17:40:42.592]     }, error = function(ex) {
[17:40:42.592]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.592]                 ...future.rng), started = ...future.startTime, 
[17:40:42.592]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.592]             version = "1.8"), class = "FutureResult")
[17:40:42.592]     }, finally = {
[17:40:42.592]         if (!identical(...future.workdir, getwd())) 
[17:40:42.592]             setwd(...future.workdir)
[17:40:42.592]         {
[17:40:42.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.592]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.592]             }
[17:40:42.592]             base::options(...future.oldOptions)
[17:40:42.592]             if (.Platform$OS.type == "windows") {
[17:40:42.592]                 old_names <- names(...future.oldEnvVars)
[17:40:42.592]                 envs <- base::Sys.getenv()
[17:40:42.592]                 names <- names(envs)
[17:40:42.592]                 common <- intersect(names, old_names)
[17:40:42.592]                 added <- setdiff(names, old_names)
[17:40:42.592]                 removed <- setdiff(old_names, names)
[17:40:42.592]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.592]                   envs[common]]
[17:40:42.592]                 NAMES <- toupper(changed)
[17:40:42.592]                 args <- list()
[17:40:42.592]                 for (kk in seq_along(NAMES)) {
[17:40:42.592]                   name <- changed[[kk]]
[17:40:42.592]                   NAME <- NAMES[[kk]]
[17:40:42.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.592]                     next
[17:40:42.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.592]                 }
[17:40:42.592]                 NAMES <- toupper(added)
[17:40:42.592]                 for (kk in seq_along(NAMES)) {
[17:40:42.592]                   name <- added[[kk]]
[17:40:42.592]                   NAME <- NAMES[[kk]]
[17:40:42.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.592]                     next
[17:40:42.592]                   args[[name]] <- ""
[17:40:42.592]                 }
[17:40:42.592]                 NAMES <- toupper(removed)
[17:40:42.592]                 for (kk in seq_along(NAMES)) {
[17:40:42.592]                   name <- removed[[kk]]
[17:40:42.592]                   NAME <- NAMES[[kk]]
[17:40:42.592]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.592]                     next
[17:40:42.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.592]                 }
[17:40:42.592]                 if (length(args) > 0) 
[17:40:42.592]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.592]             }
[17:40:42.592]             else {
[17:40:42.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.592]             }
[17:40:42.592]             {
[17:40:42.592]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.592]                   0L) {
[17:40:42.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.592]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.592]                   base::options(opts)
[17:40:42.592]                 }
[17:40:42.592]                 {
[17:40:42.592]                   {
[17:40:42.592]                     NULL
[17:40:42.592]                     RNGkind("Mersenne-Twister")
[17:40:42.592]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:40:42.592]                       inherits = FALSE)
[17:40:42.592]                   }
[17:40:42.592]                   options(future.plan = NULL)
[17:40:42.592]                   if (is.na(NA_character_)) 
[17:40:42.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.592]                     .init = FALSE)
[17:40:42.592]                 }
[17:40:42.592]             }
[17:40:42.592]         }
[17:40:42.592]     })
[17:40:42.592]     if (TRUE) {
[17:40:42.592]         base::sink(type = "output", split = FALSE)
[17:40:42.592]         if (TRUE) {
[17:40:42.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.592]         }
[17:40:42.592]         else {
[17:40:42.592]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.592]         }
[17:40:42.592]         base::close(...future.stdout)
[17:40:42.592]         ...future.stdout <- NULL
[17:40:42.592]     }
[17:40:42.592]     ...future.result$conditions <- ...future.conditions
[17:40:42.592]     ...future.result$finished <- base::Sys.time()
[17:40:42.592]     ...future.result
[17:40:42.592] }
[17:40:42.594] plan(): Setting new future strategy stack:
[17:40:42.594] List of future strategies:
[17:40:42.594] 1. sequential:
[17:40:42.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.594]    - tweaked: FALSE
[17:40:42.594]    - call: NULL
[17:40:42.595] plan(): nbrOfWorkers() = 1
[17:40:42.595] plan(): Setting new future strategy stack:
[17:40:42.595] List of future strategies:
[17:40:42.595] 1. sequential:
[17:40:42.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.595]    - tweaked: FALSE
[17:40:42.595]    - call: plan(strategy)
[17:40:42.596] plan(): nbrOfWorkers() = 1
[17:40:42.596] SequentialFuture started (and completed)
[17:40:42.596] - Launch lazy future ... done
[17:40:42.598] run() for ‘SequentialFuture’ ... done
[17:40:42.599] resolve() on list environment ...
[17:40:42.599]  recursive: 0
[17:40:42.600]  length: 4
[17:40:42.600]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.600] resolved() for ‘SequentialFuture’ ...
[17:40:42.600] - state: ‘finished’
[17:40:42.600] - run: TRUE
[17:40:42.600] - result: ‘FutureResult’
[17:40:42.600] resolved() for ‘SequentialFuture’ ... done
[17:40:42.600] Future #1
[17:40:42.600]  length: 3 (resolved future 1)
[17:40:42.601] resolved() for ‘SequentialFuture’ ...
[17:40:42.601] - state: ‘finished’
[17:40:42.601] - run: TRUE
[17:40:42.601] - result: ‘FutureResult’
[17:40:42.601] resolved() for ‘SequentialFuture’ ... done
[17:40:42.601] Future #2
[17:40:42.601]  length: 2 (resolved future 2)
[17:40:42.601] resolved() for ‘SequentialFuture’ ...
[17:40:42.601] - state: ‘finished’
[17:40:42.601] - run: TRUE
[17:40:42.602] - result: ‘FutureResult’
[17:40:42.602] resolved() for ‘SequentialFuture’ ... done
[17:40:42.602] Future #3
[17:40:42.602]  length: 1 (resolved future 3)
[17:40:42.602]  length: 0 (resolved future 4)
[17:40:42.602] resolve() on list environment ... DONE
[17:40:42.602] resolved() for ‘SequentialFuture’ ...
[17:40:42.602] - state: ‘finished’
[17:40:42.603] - run: TRUE
[17:40:42.603] - result: ‘FutureResult’
[17:40:42.603] resolved() for ‘SequentialFuture’ ... done
[17:40:42.603] resolve() on list environment ...
[17:40:42.603]  recursive: 0
[17:40:42.604]  length: 4
[17:40:42.604]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.604] resolved() for ‘SequentialFuture’ ...
[17:40:42.604] - state: ‘finished’
[17:40:42.604] - run: TRUE
[17:40:42.604] - result: ‘FutureResult’
[17:40:42.604] resolved() for ‘SequentialFuture’ ... done
[17:40:42.604] Future #1
[17:40:42.604]  length: 3 (resolved future 1)
[17:40:42.604] resolved() for ‘SequentialFuture’ ...
[17:40:42.605] - state: ‘finished’
[17:40:42.605] - run: TRUE
[17:40:42.605] - result: ‘FutureResult’
[17:40:42.605] resolved() for ‘SequentialFuture’ ... done
[17:40:42.605] Future #2
[17:40:42.605]  length: 2 (resolved future 2)
[17:40:42.605] resolved() for ‘SequentialFuture’ ...
[17:40:42.605] - state: ‘finished’
[17:40:42.605] - run: TRUE
[17:40:42.605] - result: ‘FutureResult’
[17:40:42.605] resolved() for ‘SequentialFuture’ ... done
[17:40:42.606] Future #3
[17:40:42.606]  length: 1 (resolved future 3)
[17:40:42.606]  length: 0 (resolved future 4)
[17:40:42.606] resolve() on list environment ... DONE
[17:40:42.606] resolve() on list environment ...
[17:40:42.606]  recursive: 0
[17:40:42.607]  length: 4
[17:40:42.607]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.607] resolved() for ‘SequentialFuture’ ...
[17:40:42.607] - state: ‘finished’
[17:40:42.607] - run: TRUE
[17:40:42.608] - result: ‘FutureResult’
[17:40:42.608] resolved() for ‘SequentialFuture’ ... done
[17:40:42.608] Future #1
[17:40:42.608]  length: 3 (resolved future 1)
[17:40:42.608] resolved() for ‘SequentialFuture’ ...
[17:40:42.608] - state: ‘finished’
[17:40:42.608] - run: TRUE
[17:40:42.608] - result: ‘FutureResult’
[17:40:42.608] resolved() for ‘SequentialFuture’ ... done
[17:40:42.608] Future #2
[17:40:42.608]  length: 2 (resolved future 2)
[17:40:42.609] resolved() for ‘SequentialFuture’ ...
[17:40:42.609] - state: ‘finished’
[17:40:42.609] - run: TRUE
[17:40:42.609] - result: ‘FutureResult’
[17:40:42.609] resolved() for ‘SequentialFuture’ ... done
[17:40:42.609] Future #3
[17:40:42.609]  length: 1 (resolved future 3)
[17:40:42.609]  length: 0 (resolved future 4)
[17:40:42.609] resolve() on list environment ... DONE
[17:40:42.610] resolve() on list environment ...
[17:40:42.610]  recursive: 0
[17:40:42.610]  length: 4
[17:40:42.611]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.611] resolved() for ‘SequentialFuture’ ...
[17:40:42.611] - state: ‘finished’
[17:40:42.611] - run: TRUE
[17:40:42.611] - result: ‘FutureResult’
[17:40:42.611] resolved() for ‘SequentialFuture’ ... done
[17:40:42.611] Future #1
[17:40:42.611]  length: 3 (resolved future 1)
[17:40:42.611] resolved() for ‘SequentialFuture’ ...
[17:40:42.611] - state: ‘finished’
[17:40:42.612] - run: TRUE
[17:40:42.612] - result: ‘FutureResult’
[17:40:42.612] resolved() for ‘SequentialFuture’ ... done
[17:40:42.612] Future #2
[17:40:42.612]  length: 2 (resolved future 2)
[17:40:42.612] resolved() for ‘SequentialFuture’ ...
[17:40:42.612] - state: ‘finished’
[17:40:42.612] - run: TRUE
[17:40:42.612] - result: ‘FutureResult’
[17:40:42.612] resolved() for ‘SequentialFuture’ ... done
[17:40:42.612] Future #3
[17:40:42.613]  length: 1 (resolved future 3)
[17:40:42.613]  length: 0 (resolved future 4)
[17:40:42.613] resolve() on list environment ... DONE
[17:40:42.613] resolve() on list environment ...
[17:40:42.613]  recursive: 0
[17:40:42.614]  length: 4
[17:40:42.614]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.614] resolved() for ‘SequentialFuture’ ...
[17:40:42.614] - state: ‘finished’
[17:40:42.614] - run: TRUE
[17:40:42.614] - result: ‘FutureResult’
[17:40:42.614] resolved() for ‘SequentialFuture’ ... done
[17:40:42.615] Future #1
[17:40:42.615]  length: 3 (resolved future 1)
[17:40:42.615] resolved() for ‘SequentialFuture’ ...
[17:40:42.615] - state: ‘finished’
[17:40:42.615] - run: TRUE
[17:40:42.615] - result: ‘FutureResult’
[17:40:42.615] resolved() for ‘SequentialFuture’ ... done
[17:40:42.615] Future #2
[17:40:42.615]  length: 2 (resolved future 2)
[17:40:42.616] resolved() for ‘SequentialFuture’ ...
[17:40:42.616] - state: ‘finished’
[17:40:42.616] - run: TRUE
[17:40:42.616] - result: ‘FutureResult’
[17:40:42.616] resolved() for ‘SequentialFuture’ ... done
[17:40:42.616] Future #3
[17:40:42.616]  length: 1 (resolved future 3)
[17:40:42.616]  length: 0 (resolved future 4)
[17:40:42.616] resolve() on list environment ... DONE
[17:40:42.617] resolve() on list environment ...
[17:40:42.617]  recursive: 99
[17:40:42.617]  length: 4
[17:40:42.618]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:42.618] resolved() for ‘SequentialFuture’ ...
[17:40:42.618] - state: ‘finished’
[17:40:42.618] - run: TRUE
[17:40:42.618] - result: ‘FutureResult’
[17:40:42.618] resolved() for ‘SequentialFuture’ ... done
[17:40:42.618] Future #1
[17:40:42.618] resolved() for ‘SequentialFuture’ ...
[17:40:42.620] - state: ‘finished’
[17:40:42.620] - run: TRUE
[17:40:42.620] - result: ‘FutureResult’
[17:40:42.620] resolved() for ‘SequentialFuture’ ... done
[17:40:42.620] A SequentialFuture was resolved
[17:40:42.620]  length: 3 (resolved future 1)
[17:40:42.620] resolved() for ‘SequentialFuture’ ...
[17:40:42.621] - state: ‘finished’
[17:40:42.621] - run: TRUE
[17:40:42.621] - result: ‘FutureResult’
[17:40:42.621] resolved() for ‘SequentialFuture’ ... done
[17:40:42.621] Future #2
[17:40:42.621] resolved() for ‘SequentialFuture’ ...
[17:40:42.621] - state: ‘finished’
[17:40:42.621] - run: TRUE
[17:40:42.621] - result: ‘FutureResult’
[17:40:42.621] resolved() for ‘SequentialFuture’ ... done
[17:40:42.622] A SequentialFuture was resolved
[17:40:42.622]  length: 2 (resolved future 2)
[17:40:42.622] resolved() for ‘SequentialFuture’ ...
[17:40:42.622] - state: ‘finished’
[17:40:42.622] - run: TRUE
[17:40:42.622] - result: ‘FutureResult’
[17:40:42.622] resolved() for ‘SequentialFuture’ ... done
[17:40:42.622] Future #3
[17:40:42.622] resolved() for ‘SequentialFuture’ ...
[17:40:42.622] - state: ‘finished’
[17:40:42.622] - run: TRUE
[17:40:42.623] - result: ‘FutureResult’
[17:40:42.623] resolved() for ‘SequentialFuture’ ... done
[17:40:42.623] A SequentialFuture was resolved
[17:40:42.623]  length: 1 (resolved future 3)
[17:40:42.623]  length: 0 (resolved future 4)
[17:40:42.623] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[17:40:42.624] plan(): Setting new future strategy stack:
[17:40:42.624] List of future strategies:
[17:40:42.624] 1. multicore:
[17:40:42.624]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.624]    - tweaked: FALSE
[17:40:42.624]    - call: plan(strategy)
[17:40:42.628] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[17:40:42.628] resolve() on list ...
[17:40:42.628]  recursive: 0
[17:40:42.628]  length: 2
[17:40:42.628]  elements: ‘a’, ‘b’
[17:40:42.628]  length: 1 (resolved future 1)
[17:40:42.628]  length: 0 (resolved future 2)
[17:40:42.628] resolve() on list ... DONE
[17:40:42.628] getGlobalsAndPackages() ...
[17:40:42.629] Searching for globals...
[17:40:42.629] 
[17:40:42.629] Searching for globals ... DONE
[17:40:42.629] - globals: [0] <none>
[17:40:42.629] getGlobalsAndPackages() ... DONE
[17:40:42.629] run() for ‘Future’ ...
[17:40:42.629] - state: ‘created’
[17:40:42.630] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.633] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.633]   - Field: ‘label’
[17:40:42.633]   - Field: ‘local’
[17:40:42.633]   - Field: ‘owner’
[17:40:42.634]   - Field: ‘envir’
[17:40:42.634]   - Field: ‘workers’
[17:40:42.634]   - Field: ‘packages’
[17:40:42.634]   - Field: ‘gc’
[17:40:42.634]   - Field: ‘job’
[17:40:42.634]   - Field: ‘conditions’
[17:40:42.634]   - Field: ‘expr’
[17:40:42.634]   - Field: ‘uuid’
[17:40:42.634]   - Field: ‘seed’
[17:40:42.634]   - Field: ‘version’
[17:40:42.634]   - Field: ‘result’
[17:40:42.634]   - Field: ‘asynchronous’
[17:40:42.635]   - Field: ‘calls’
[17:40:42.635]   - Field: ‘globals’
[17:40:42.635]   - Field: ‘stdout’
[17:40:42.635]   - Field: ‘earlySignal’
[17:40:42.635]   - Field: ‘lazy’
[17:40:42.635]   - Field: ‘state’
[17:40:42.635] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.635] - Launch lazy future ...
[17:40:42.636] Packages needed by the future expression (n = 0): <none>
[17:40:42.636] Packages needed by future strategies (n = 0): <none>
[17:40:42.637] {
[17:40:42.637]     {
[17:40:42.637]         {
[17:40:42.637]             ...future.startTime <- base::Sys.time()
[17:40:42.637]             {
[17:40:42.637]                 {
[17:40:42.637]                   {
[17:40:42.637]                     {
[17:40:42.637]                       base::local({
[17:40:42.637]                         has_future <- base::requireNamespace("future", 
[17:40:42.637]                           quietly = TRUE)
[17:40:42.637]                         if (has_future) {
[17:40:42.637]                           ns <- base::getNamespace("future")
[17:40:42.637]                           version <- ns[[".package"]][["version"]]
[17:40:42.637]                           if (is.null(version)) 
[17:40:42.637]                             version <- utils::packageVersion("future")
[17:40:42.637]                         }
[17:40:42.637]                         else {
[17:40:42.637]                           version <- NULL
[17:40:42.637]                         }
[17:40:42.637]                         if (!has_future || version < "1.8.0") {
[17:40:42.637]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.637]                             "", base::R.version$version.string), 
[17:40:42.637]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.637]                               "release", "version")], collapse = " "), 
[17:40:42.637]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.637]                             info)
[17:40:42.637]                           info <- base::paste(info, collapse = "; ")
[17:40:42.637]                           if (!has_future) {
[17:40:42.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.637]                               info)
[17:40:42.637]                           }
[17:40:42.637]                           else {
[17:40:42.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.637]                               info, version)
[17:40:42.637]                           }
[17:40:42.637]                           base::stop(msg)
[17:40:42.637]                         }
[17:40:42.637]                       })
[17:40:42.637]                     }
[17:40:42.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.637]                     base::options(mc.cores = 1L)
[17:40:42.637]                   }
[17:40:42.637]                   ...future.strategy.old <- future::plan("list")
[17:40:42.637]                   options(future.plan = NULL)
[17:40:42.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.637]                 }
[17:40:42.637]                 ...future.workdir <- getwd()
[17:40:42.637]             }
[17:40:42.637]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.637]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.637]         }
[17:40:42.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.637]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.637]             base::names(...future.oldOptions))
[17:40:42.637]     }
[17:40:42.637]     if (FALSE) {
[17:40:42.637]     }
[17:40:42.637]     else {
[17:40:42.637]         if (TRUE) {
[17:40:42.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.637]                 open = "w")
[17:40:42.637]         }
[17:40:42.637]         else {
[17:40:42.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.637]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.637]         }
[17:40:42.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.637]             base::sink(type = "output", split = FALSE)
[17:40:42.637]             base::close(...future.stdout)
[17:40:42.637]         }, add = TRUE)
[17:40:42.637]     }
[17:40:42.637]     ...future.frame <- base::sys.nframe()
[17:40:42.637]     ...future.conditions <- base::list()
[17:40:42.637]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.637]     if (FALSE) {
[17:40:42.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.637]     }
[17:40:42.637]     ...future.result <- base::tryCatch({
[17:40:42.637]         base::withCallingHandlers({
[17:40:42.637]             ...future.value <- base::withVisible(base::local({
[17:40:42.637]                 withCallingHandlers({
[17:40:42.637]                   1
[17:40:42.637]                 }, immediateCondition = function(cond) {
[17:40:42.637]                   save_rds <- function (object, pathname, ...) 
[17:40:42.637]                   {
[17:40:42.637]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.637]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.637]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.637]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.637]                         fi_tmp[["mtime"]])
[17:40:42.637]                     }
[17:40:42.637]                     tryCatch({
[17:40:42.637]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.637]                     }, error = function(ex) {
[17:40:42.637]                       msg <- conditionMessage(ex)
[17:40:42.637]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.637]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.637]                         fi_tmp[["mtime"]], msg)
[17:40:42.637]                       ex$message <- msg
[17:40:42.637]                       stop(ex)
[17:40:42.637]                     })
[17:40:42.637]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.637]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.637]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.637]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.637]                       fi <- file.info(pathname)
[17:40:42.637]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.637]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.637]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.637]                         fi[["size"]], fi[["mtime"]])
[17:40:42.637]                       stop(msg)
[17:40:42.637]                     }
[17:40:42.637]                     invisible(pathname)
[17:40:42.637]                   }
[17:40:42.637]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.637]                     rootPath = tempdir()) 
[17:40:42.637]                   {
[17:40:42.637]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.637]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.637]                       tmpdir = path, fileext = ".rds")
[17:40:42.637]                     save_rds(obj, file)
[17:40:42.637]                   }
[17:40:42.637]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.637]                   {
[17:40:42.637]                     inherits <- base::inherits
[17:40:42.637]                     invokeRestart <- base::invokeRestart
[17:40:42.637]                     is.null <- base::is.null
[17:40:42.637]                     muffled <- FALSE
[17:40:42.637]                     if (inherits(cond, "message")) {
[17:40:42.637]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.637]                       if (muffled) 
[17:40:42.637]                         invokeRestart("muffleMessage")
[17:40:42.637]                     }
[17:40:42.637]                     else if (inherits(cond, "warning")) {
[17:40:42.637]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.637]                       if (muffled) 
[17:40:42.637]                         invokeRestart("muffleWarning")
[17:40:42.637]                     }
[17:40:42.637]                     else if (inherits(cond, "condition")) {
[17:40:42.637]                       if (!is.null(pattern)) {
[17:40:42.637]                         computeRestarts <- base::computeRestarts
[17:40:42.637]                         grepl <- base::grepl
[17:40:42.637]                         restarts <- computeRestarts(cond)
[17:40:42.637]                         for (restart in restarts) {
[17:40:42.637]                           name <- restart$name
[17:40:42.637]                           if (is.null(name)) 
[17:40:42.637]                             next
[17:40:42.637]                           if (!grepl(pattern, name)) 
[17:40:42.637]                             next
[17:40:42.637]                           invokeRestart(restart)
[17:40:42.637]                           muffled <- TRUE
[17:40:42.637]                           break
[17:40:42.637]                         }
[17:40:42.637]                       }
[17:40:42.637]                     }
[17:40:42.637]                     invisible(muffled)
[17:40:42.637]                   }
[17:40:42.637]                   muffleCondition(cond)
[17:40:42.637]                 })
[17:40:42.637]             }))
[17:40:42.637]             future::FutureResult(value = ...future.value$value, 
[17:40:42.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.637]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.637]                     ...future.globalenv.names))
[17:40:42.637]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.637]         }, condition = base::local({
[17:40:42.637]             c <- base::c
[17:40:42.637]             inherits <- base::inherits
[17:40:42.637]             invokeRestart <- base::invokeRestart
[17:40:42.637]             length <- base::length
[17:40:42.637]             list <- base::list
[17:40:42.637]             seq.int <- base::seq.int
[17:40:42.637]             signalCondition <- base::signalCondition
[17:40:42.637]             sys.calls <- base::sys.calls
[17:40:42.637]             `[[` <- base::`[[`
[17:40:42.637]             `+` <- base::`+`
[17:40:42.637]             `<<-` <- base::`<<-`
[17:40:42.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.637]                   3L)]
[17:40:42.637]             }
[17:40:42.637]             function(cond) {
[17:40:42.637]                 is_error <- inherits(cond, "error")
[17:40:42.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.637]                   NULL)
[17:40:42.637]                 if (is_error) {
[17:40:42.637]                   sessionInformation <- function() {
[17:40:42.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.637]                       search = base::search(), system = base::Sys.info())
[17:40:42.637]                   }
[17:40:42.637]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.637]                     cond$call), session = sessionInformation(), 
[17:40:42.637]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.637]                   signalCondition(cond)
[17:40:42.637]                 }
[17:40:42.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.637]                 "immediateCondition"))) {
[17:40:42.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.637]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.637]                   if (TRUE && !signal) {
[17:40:42.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.637]                     {
[17:40:42.637]                       inherits <- base::inherits
[17:40:42.637]                       invokeRestart <- base::invokeRestart
[17:40:42.637]                       is.null <- base::is.null
[17:40:42.637]                       muffled <- FALSE
[17:40:42.637]                       if (inherits(cond, "message")) {
[17:40:42.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.637]                         if (muffled) 
[17:40:42.637]                           invokeRestart("muffleMessage")
[17:40:42.637]                       }
[17:40:42.637]                       else if (inherits(cond, "warning")) {
[17:40:42.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.637]                         if (muffled) 
[17:40:42.637]                           invokeRestart("muffleWarning")
[17:40:42.637]                       }
[17:40:42.637]                       else if (inherits(cond, "condition")) {
[17:40:42.637]                         if (!is.null(pattern)) {
[17:40:42.637]                           computeRestarts <- base::computeRestarts
[17:40:42.637]                           grepl <- base::grepl
[17:40:42.637]                           restarts <- computeRestarts(cond)
[17:40:42.637]                           for (restart in restarts) {
[17:40:42.637]                             name <- restart$name
[17:40:42.637]                             if (is.null(name)) 
[17:40:42.637]                               next
[17:40:42.637]                             if (!grepl(pattern, name)) 
[17:40:42.637]                               next
[17:40:42.637]                             invokeRestart(restart)
[17:40:42.637]                             muffled <- TRUE
[17:40:42.637]                             break
[17:40:42.637]                           }
[17:40:42.637]                         }
[17:40:42.637]                       }
[17:40:42.637]                       invisible(muffled)
[17:40:42.637]                     }
[17:40:42.637]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.637]                   }
[17:40:42.637]                 }
[17:40:42.637]                 else {
[17:40:42.637]                   if (TRUE) {
[17:40:42.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.637]                     {
[17:40:42.637]                       inherits <- base::inherits
[17:40:42.637]                       invokeRestart <- base::invokeRestart
[17:40:42.637]                       is.null <- base::is.null
[17:40:42.637]                       muffled <- FALSE
[17:40:42.637]                       if (inherits(cond, "message")) {
[17:40:42.637]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.637]                         if (muffled) 
[17:40:42.637]                           invokeRestart("muffleMessage")
[17:40:42.637]                       }
[17:40:42.637]                       else if (inherits(cond, "warning")) {
[17:40:42.637]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.637]                         if (muffled) 
[17:40:42.637]                           invokeRestart("muffleWarning")
[17:40:42.637]                       }
[17:40:42.637]                       else if (inherits(cond, "condition")) {
[17:40:42.637]                         if (!is.null(pattern)) {
[17:40:42.637]                           computeRestarts <- base::computeRestarts
[17:40:42.637]                           grepl <- base::grepl
[17:40:42.637]                           restarts <- computeRestarts(cond)
[17:40:42.637]                           for (restart in restarts) {
[17:40:42.637]                             name <- restart$name
[17:40:42.637]                             if (is.null(name)) 
[17:40:42.637]                               next
[17:40:42.637]                             if (!grepl(pattern, name)) 
[17:40:42.637]                               next
[17:40:42.637]                             invokeRestart(restart)
[17:40:42.637]                             muffled <- TRUE
[17:40:42.637]                             break
[17:40:42.637]                           }
[17:40:42.637]                         }
[17:40:42.637]                       }
[17:40:42.637]                       invisible(muffled)
[17:40:42.637]                     }
[17:40:42.637]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.637]                   }
[17:40:42.637]                 }
[17:40:42.637]             }
[17:40:42.637]         }))
[17:40:42.637]     }, error = function(ex) {
[17:40:42.637]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.637]                 ...future.rng), started = ...future.startTime, 
[17:40:42.637]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.637]             version = "1.8"), class = "FutureResult")
[17:40:42.637]     }, finally = {
[17:40:42.637]         if (!identical(...future.workdir, getwd())) 
[17:40:42.637]             setwd(...future.workdir)
[17:40:42.637]         {
[17:40:42.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.637]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.637]             }
[17:40:42.637]             base::options(...future.oldOptions)
[17:40:42.637]             if (.Platform$OS.type == "windows") {
[17:40:42.637]                 old_names <- names(...future.oldEnvVars)
[17:40:42.637]                 envs <- base::Sys.getenv()
[17:40:42.637]                 names <- names(envs)
[17:40:42.637]                 common <- intersect(names, old_names)
[17:40:42.637]                 added <- setdiff(names, old_names)
[17:40:42.637]                 removed <- setdiff(old_names, names)
[17:40:42.637]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.637]                   envs[common]]
[17:40:42.637]                 NAMES <- toupper(changed)
[17:40:42.637]                 args <- list()
[17:40:42.637]                 for (kk in seq_along(NAMES)) {
[17:40:42.637]                   name <- changed[[kk]]
[17:40:42.637]                   NAME <- NAMES[[kk]]
[17:40:42.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.637]                     next
[17:40:42.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.637]                 }
[17:40:42.637]                 NAMES <- toupper(added)
[17:40:42.637]                 for (kk in seq_along(NAMES)) {
[17:40:42.637]                   name <- added[[kk]]
[17:40:42.637]                   NAME <- NAMES[[kk]]
[17:40:42.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.637]                     next
[17:40:42.637]                   args[[name]] <- ""
[17:40:42.637]                 }
[17:40:42.637]                 NAMES <- toupper(removed)
[17:40:42.637]                 for (kk in seq_along(NAMES)) {
[17:40:42.637]                   name <- removed[[kk]]
[17:40:42.637]                   NAME <- NAMES[[kk]]
[17:40:42.637]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.637]                     next
[17:40:42.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.637]                 }
[17:40:42.637]                 if (length(args) > 0) 
[17:40:42.637]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.637]             }
[17:40:42.637]             else {
[17:40:42.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.637]             }
[17:40:42.637]             {
[17:40:42.637]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.637]                   0L) {
[17:40:42.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.637]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.637]                   base::options(opts)
[17:40:42.637]                 }
[17:40:42.637]                 {
[17:40:42.637]                   {
[17:40:42.637]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.637]                     NULL
[17:40:42.637]                   }
[17:40:42.637]                   options(future.plan = NULL)
[17:40:42.637]                   if (is.na(NA_character_)) 
[17:40:42.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.637]                     .init = FALSE)
[17:40:42.637]                 }
[17:40:42.637]             }
[17:40:42.637]         }
[17:40:42.637]     })
[17:40:42.637]     if (TRUE) {
[17:40:42.637]         base::sink(type = "output", split = FALSE)
[17:40:42.637]         if (TRUE) {
[17:40:42.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.637]         }
[17:40:42.637]         else {
[17:40:42.637]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.637]         }
[17:40:42.637]         base::close(...future.stdout)
[17:40:42.637]         ...future.stdout <- NULL
[17:40:42.637]     }
[17:40:42.637]     ...future.result$conditions <- ...future.conditions
[17:40:42.637]     ...future.result$finished <- base::Sys.time()
[17:40:42.637]     ...future.result
[17:40:42.637] }
[17:40:42.639] requestCore(): workers = 2
[17:40:42.642] MulticoreFuture started
[17:40:42.642] - Launch lazy future ... done
[17:40:42.642] plan(): Setting new future strategy stack:
[17:40:42.642] run() for ‘MulticoreFuture’ ... done
[17:40:42.643] getGlobalsAndPackages() ...
[17:40:42.643] Searching for globals...
[17:40:42.643] List of future strategies:
[17:40:42.643] 1. sequential:
[17:40:42.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.643]    - tweaked: FALSE
[17:40:42.643]    - call: NULL
[17:40:42.644] plan(): nbrOfWorkers() = 1
[17:40:42.644] 
[17:40:42.644] Searching for globals ... DONE
[17:40:42.644] - globals: [0] <none>
[17:40:42.645] getGlobalsAndPackages() ... DONE
[17:40:42.645] run() for ‘Future’ ...
[17:40:42.645] - state: ‘created’
[17:40:42.645] plan(): Setting new future strategy stack:
[17:40:42.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.646] List of future strategies:
[17:40:42.646] 1. multicore:
[17:40:42.646]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.646]    - tweaked: FALSE
[17:40:42.646]    - call: plan(strategy)
[17:40:42.650] plan(): nbrOfWorkers() = 2
[17:40:42.650] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.651]   - Field: ‘label’
[17:40:42.651]   - Field: ‘local’
[17:40:42.651]   - Field: ‘owner’
[17:40:42.651]   - Field: ‘envir’
[17:40:42.651]   - Field: ‘workers’
[17:40:42.651]   - Field: ‘packages’
[17:40:42.652]   - Field: ‘gc’
[17:40:42.652]   - Field: ‘job’
[17:40:42.652]   - Field: ‘conditions’
[17:40:42.652]   - Field: ‘expr’
[17:40:42.652]   - Field: ‘uuid’
[17:40:42.652]   - Field: ‘seed’
[17:40:42.652]   - Field: ‘version’
[17:40:42.653]   - Field: ‘result’
[17:40:42.653]   - Field: ‘asynchronous’
[17:40:42.653]   - Field: ‘calls’
[17:40:42.653]   - Field: ‘globals’
[17:40:42.653]   - Field: ‘stdout’
[17:40:42.653]   - Field: ‘earlySignal’
[17:40:42.653]   - Field: ‘lazy’
[17:40:42.654]   - Field: ‘state’
[17:40:42.654] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.654] - Launch lazy future ...
[17:40:42.654] Packages needed by the future expression (n = 0): <none>
[17:40:42.654] Packages needed by future strategies (n = 0): <none>
[17:40:42.655] {
[17:40:42.655]     {
[17:40:42.655]         {
[17:40:42.655]             ...future.startTime <- base::Sys.time()
[17:40:42.655]             {
[17:40:42.655]                 {
[17:40:42.655]                   {
[17:40:42.655]                     {
[17:40:42.655]                       base::local({
[17:40:42.655]                         has_future <- base::requireNamespace("future", 
[17:40:42.655]                           quietly = TRUE)
[17:40:42.655]                         if (has_future) {
[17:40:42.655]                           ns <- base::getNamespace("future")
[17:40:42.655]                           version <- ns[[".package"]][["version"]]
[17:40:42.655]                           if (is.null(version)) 
[17:40:42.655]                             version <- utils::packageVersion("future")
[17:40:42.655]                         }
[17:40:42.655]                         else {
[17:40:42.655]                           version <- NULL
[17:40:42.655]                         }
[17:40:42.655]                         if (!has_future || version < "1.8.0") {
[17:40:42.655]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.655]                             "", base::R.version$version.string), 
[17:40:42.655]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.655]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.655]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.655]                               "release", "version")], collapse = " "), 
[17:40:42.655]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.655]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.655]                             info)
[17:40:42.655]                           info <- base::paste(info, collapse = "; ")
[17:40:42.655]                           if (!has_future) {
[17:40:42.655]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.655]                               info)
[17:40:42.655]                           }
[17:40:42.655]                           else {
[17:40:42.655]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.655]                               info, version)
[17:40:42.655]                           }
[17:40:42.655]                           base::stop(msg)
[17:40:42.655]                         }
[17:40:42.655]                       })
[17:40:42.655]                     }
[17:40:42.655]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.655]                     base::options(mc.cores = 1L)
[17:40:42.655]                   }
[17:40:42.655]                   ...future.strategy.old <- future::plan("list")
[17:40:42.655]                   options(future.plan = NULL)
[17:40:42.655]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.655]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.655]                 }
[17:40:42.655]                 ...future.workdir <- getwd()
[17:40:42.655]             }
[17:40:42.655]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.655]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.655]         }
[17:40:42.655]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.655]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.655]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.655]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.655]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.655]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.655]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.655]             base::names(...future.oldOptions))
[17:40:42.655]     }
[17:40:42.655]     if (FALSE) {
[17:40:42.655]     }
[17:40:42.655]     else {
[17:40:42.655]         if (TRUE) {
[17:40:42.655]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.655]                 open = "w")
[17:40:42.655]         }
[17:40:42.655]         else {
[17:40:42.655]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.655]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.655]         }
[17:40:42.655]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.655]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.655]             base::sink(type = "output", split = FALSE)
[17:40:42.655]             base::close(...future.stdout)
[17:40:42.655]         }, add = TRUE)
[17:40:42.655]     }
[17:40:42.655]     ...future.frame <- base::sys.nframe()
[17:40:42.655]     ...future.conditions <- base::list()
[17:40:42.655]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.655]     if (FALSE) {
[17:40:42.655]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.655]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.655]     }
[17:40:42.655]     ...future.result <- base::tryCatch({
[17:40:42.655]         base::withCallingHandlers({
[17:40:42.655]             ...future.value <- base::withVisible(base::local({
[17:40:42.655]                 withCallingHandlers({
[17:40:42.655]                   2
[17:40:42.655]                 }, immediateCondition = function(cond) {
[17:40:42.655]                   save_rds <- function (object, pathname, ...) 
[17:40:42.655]                   {
[17:40:42.655]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.655]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.655]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.655]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.655]                         fi_tmp[["mtime"]])
[17:40:42.655]                     }
[17:40:42.655]                     tryCatch({
[17:40:42.655]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.655]                     }, error = function(ex) {
[17:40:42.655]                       msg <- conditionMessage(ex)
[17:40:42.655]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.655]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.655]                         fi_tmp[["mtime"]], msg)
[17:40:42.655]                       ex$message <- msg
[17:40:42.655]                       stop(ex)
[17:40:42.655]                     })
[17:40:42.655]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.655]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.655]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.655]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.655]                       fi <- file.info(pathname)
[17:40:42.655]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.655]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.655]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.655]                         fi[["size"]], fi[["mtime"]])
[17:40:42.655]                       stop(msg)
[17:40:42.655]                     }
[17:40:42.655]                     invisible(pathname)
[17:40:42.655]                   }
[17:40:42.655]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.655]                     rootPath = tempdir()) 
[17:40:42.655]                   {
[17:40:42.655]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.655]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.655]                       tmpdir = path, fileext = ".rds")
[17:40:42.655]                     save_rds(obj, file)
[17:40:42.655]                   }
[17:40:42.655]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.655]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.655]                   {
[17:40:42.655]                     inherits <- base::inherits
[17:40:42.655]                     invokeRestart <- base::invokeRestart
[17:40:42.655]                     is.null <- base::is.null
[17:40:42.655]                     muffled <- FALSE
[17:40:42.655]                     if (inherits(cond, "message")) {
[17:40:42.655]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.655]                       if (muffled) 
[17:40:42.655]                         invokeRestart("muffleMessage")
[17:40:42.655]                     }
[17:40:42.655]                     else if (inherits(cond, "warning")) {
[17:40:42.655]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.655]                       if (muffled) 
[17:40:42.655]                         invokeRestart("muffleWarning")
[17:40:42.655]                     }
[17:40:42.655]                     else if (inherits(cond, "condition")) {
[17:40:42.655]                       if (!is.null(pattern)) {
[17:40:42.655]                         computeRestarts <- base::computeRestarts
[17:40:42.655]                         grepl <- base::grepl
[17:40:42.655]                         restarts <- computeRestarts(cond)
[17:40:42.655]                         for (restart in restarts) {
[17:40:42.655]                           name <- restart$name
[17:40:42.655]                           if (is.null(name)) 
[17:40:42.655]                             next
[17:40:42.655]                           if (!grepl(pattern, name)) 
[17:40:42.655]                             next
[17:40:42.655]                           invokeRestart(restart)
[17:40:42.655]                           muffled <- TRUE
[17:40:42.655]                           break
[17:40:42.655]                         }
[17:40:42.655]                       }
[17:40:42.655]                     }
[17:40:42.655]                     invisible(muffled)
[17:40:42.655]                   }
[17:40:42.655]                   muffleCondition(cond)
[17:40:42.655]                 })
[17:40:42.655]             }))
[17:40:42.655]             future::FutureResult(value = ...future.value$value, 
[17:40:42.655]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.655]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.655]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.655]                     ...future.globalenv.names))
[17:40:42.655]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.655]         }, condition = base::local({
[17:40:42.655]             c <- base::c
[17:40:42.655]             inherits <- base::inherits
[17:40:42.655]             invokeRestart <- base::invokeRestart
[17:40:42.655]             length <- base::length
[17:40:42.655]             list <- base::list
[17:40:42.655]             seq.int <- base::seq.int
[17:40:42.655]             signalCondition <- base::signalCondition
[17:40:42.655]             sys.calls <- base::sys.calls
[17:40:42.655]             `[[` <- base::`[[`
[17:40:42.655]             `+` <- base::`+`
[17:40:42.655]             `<<-` <- base::`<<-`
[17:40:42.655]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.655]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.655]                   3L)]
[17:40:42.655]             }
[17:40:42.655]             function(cond) {
[17:40:42.655]                 is_error <- inherits(cond, "error")
[17:40:42.655]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.655]                   NULL)
[17:40:42.655]                 if (is_error) {
[17:40:42.655]                   sessionInformation <- function() {
[17:40:42.655]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.655]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.655]                       search = base::search(), system = base::Sys.info())
[17:40:42.655]                   }
[17:40:42.655]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.655]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.655]                     cond$call), session = sessionInformation(), 
[17:40:42.655]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.655]                   signalCondition(cond)
[17:40:42.655]                 }
[17:40:42.655]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.655]                 "immediateCondition"))) {
[17:40:42.655]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.655]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.655]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.655]                   if (TRUE && !signal) {
[17:40:42.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.655]                     {
[17:40:42.655]                       inherits <- base::inherits
[17:40:42.655]                       invokeRestart <- base::invokeRestart
[17:40:42.655]                       is.null <- base::is.null
[17:40:42.655]                       muffled <- FALSE
[17:40:42.655]                       if (inherits(cond, "message")) {
[17:40:42.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.655]                         if (muffled) 
[17:40:42.655]                           invokeRestart("muffleMessage")
[17:40:42.655]                       }
[17:40:42.655]                       else if (inherits(cond, "warning")) {
[17:40:42.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.655]                         if (muffled) 
[17:40:42.655]                           invokeRestart("muffleWarning")
[17:40:42.655]                       }
[17:40:42.655]                       else if (inherits(cond, "condition")) {
[17:40:42.655]                         if (!is.null(pattern)) {
[17:40:42.655]                           computeRestarts <- base::computeRestarts
[17:40:42.655]                           grepl <- base::grepl
[17:40:42.655]                           restarts <- computeRestarts(cond)
[17:40:42.655]                           for (restart in restarts) {
[17:40:42.655]                             name <- restart$name
[17:40:42.655]                             if (is.null(name)) 
[17:40:42.655]                               next
[17:40:42.655]                             if (!grepl(pattern, name)) 
[17:40:42.655]                               next
[17:40:42.655]                             invokeRestart(restart)
[17:40:42.655]                             muffled <- TRUE
[17:40:42.655]                             break
[17:40:42.655]                           }
[17:40:42.655]                         }
[17:40:42.655]                       }
[17:40:42.655]                       invisible(muffled)
[17:40:42.655]                     }
[17:40:42.655]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.655]                   }
[17:40:42.655]                 }
[17:40:42.655]                 else {
[17:40:42.655]                   if (TRUE) {
[17:40:42.655]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.655]                     {
[17:40:42.655]                       inherits <- base::inherits
[17:40:42.655]                       invokeRestart <- base::invokeRestart
[17:40:42.655]                       is.null <- base::is.null
[17:40:42.655]                       muffled <- FALSE
[17:40:42.655]                       if (inherits(cond, "message")) {
[17:40:42.655]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.655]                         if (muffled) 
[17:40:42.655]                           invokeRestart("muffleMessage")
[17:40:42.655]                       }
[17:40:42.655]                       else if (inherits(cond, "warning")) {
[17:40:42.655]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.655]                         if (muffled) 
[17:40:42.655]                           invokeRestart("muffleWarning")
[17:40:42.655]                       }
[17:40:42.655]                       else if (inherits(cond, "condition")) {
[17:40:42.655]                         if (!is.null(pattern)) {
[17:40:42.655]                           computeRestarts <- base::computeRestarts
[17:40:42.655]                           grepl <- base::grepl
[17:40:42.655]                           restarts <- computeRestarts(cond)
[17:40:42.655]                           for (restart in restarts) {
[17:40:42.655]                             name <- restart$name
[17:40:42.655]                             if (is.null(name)) 
[17:40:42.655]                               next
[17:40:42.655]                             if (!grepl(pattern, name)) 
[17:40:42.655]                               next
[17:40:42.655]                             invokeRestart(restart)
[17:40:42.655]                             muffled <- TRUE
[17:40:42.655]                             break
[17:40:42.655]                           }
[17:40:42.655]                         }
[17:40:42.655]                       }
[17:40:42.655]                       invisible(muffled)
[17:40:42.655]                     }
[17:40:42.655]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.655]                   }
[17:40:42.655]                 }
[17:40:42.655]             }
[17:40:42.655]         }))
[17:40:42.655]     }, error = function(ex) {
[17:40:42.655]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.655]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.655]                 ...future.rng), started = ...future.startTime, 
[17:40:42.655]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.655]             version = "1.8"), class = "FutureResult")
[17:40:42.655]     }, finally = {
[17:40:42.655]         if (!identical(...future.workdir, getwd())) 
[17:40:42.655]             setwd(...future.workdir)
[17:40:42.655]         {
[17:40:42.655]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.655]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.655]             }
[17:40:42.655]             base::options(...future.oldOptions)
[17:40:42.655]             if (.Platform$OS.type == "windows") {
[17:40:42.655]                 old_names <- names(...future.oldEnvVars)
[17:40:42.655]                 envs <- base::Sys.getenv()
[17:40:42.655]                 names <- names(envs)
[17:40:42.655]                 common <- intersect(names, old_names)
[17:40:42.655]                 added <- setdiff(names, old_names)
[17:40:42.655]                 removed <- setdiff(old_names, names)
[17:40:42.655]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.655]                   envs[common]]
[17:40:42.655]                 NAMES <- toupper(changed)
[17:40:42.655]                 args <- list()
[17:40:42.655]                 for (kk in seq_along(NAMES)) {
[17:40:42.655]                   name <- changed[[kk]]
[17:40:42.655]                   NAME <- NAMES[[kk]]
[17:40:42.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.655]                     next
[17:40:42.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.655]                 }
[17:40:42.655]                 NAMES <- toupper(added)
[17:40:42.655]                 for (kk in seq_along(NAMES)) {
[17:40:42.655]                   name <- added[[kk]]
[17:40:42.655]                   NAME <- NAMES[[kk]]
[17:40:42.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.655]                     next
[17:40:42.655]                   args[[name]] <- ""
[17:40:42.655]                 }
[17:40:42.655]                 NAMES <- toupper(removed)
[17:40:42.655]                 for (kk in seq_along(NAMES)) {
[17:40:42.655]                   name <- removed[[kk]]
[17:40:42.655]                   NAME <- NAMES[[kk]]
[17:40:42.655]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.655]                     next
[17:40:42.655]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.655]                 }
[17:40:42.655]                 if (length(args) > 0) 
[17:40:42.655]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.655]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.655]             }
[17:40:42.655]             else {
[17:40:42.655]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.655]             }
[17:40:42.655]             {
[17:40:42.655]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.655]                   0L) {
[17:40:42.655]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.655]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.655]                   base::options(opts)
[17:40:42.655]                 }
[17:40:42.655]                 {
[17:40:42.655]                   {
[17:40:42.655]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.655]                     NULL
[17:40:42.655]                   }
[17:40:42.655]                   options(future.plan = NULL)
[17:40:42.655]                   if (is.na(NA_character_)) 
[17:40:42.655]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.655]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.655]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.655]                     .init = FALSE)
[17:40:42.655]                 }
[17:40:42.655]             }
[17:40:42.655]         }
[17:40:42.655]     })
[17:40:42.655]     if (TRUE) {
[17:40:42.655]         base::sink(type = "output", split = FALSE)
[17:40:42.655]         if (TRUE) {
[17:40:42.655]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.655]         }
[17:40:42.655]         else {
[17:40:42.655]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.655]         }
[17:40:42.655]         base::close(...future.stdout)
[17:40:42.655]         ...future.stdout <- NULL
[17:40:42.655]     }
[17:40:42.655]     ...future.result$conditions <- ...future.conditions
[17:40:42.655]     ...future.result$finished <- base::Sys.time()
[17:40:42.655]     ...future.result
[17:40:42.655] }
[17:40:42.658] requestCore(): workers = 2
[17:40:42.664] MulticoreFuture started
[17:40:42.665] - Launch lazy future ... done
[17:40:42.665] run() for ‘MulticoreFuture’ ... done
[17:40:42.665] resolve() on list ...
[17:40:42.665]  recursive: 0
[17:40:42.665]  length: 3
[17:40:42.665] plan(): Setting new future strategy stack:
[17:40:42.666]  elements: ‘a’, ‘b’, ‘’
[17:40:42.666] List of future strategies:
[17:40:42.666] 1. sequential:
[17:40:42.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.666]    - tweaked: FALSE
[17:40:42.666]    - call: NULL
[17:40:42.667] plan(): nbrOfWorkers() = 1
[17:40:42.714] Future #1
[17:40:42.714]  length: 2 (resolved future 1)
[17:40:42.714] plan(): Setting new future strategy stack:
[17:40:42.715] List of future strategies:
[17:40:42.715] 1. multicore:
[17:40:42.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.715]    - tweaked: FALSE
[17:40:42.715]    - call: plan(strategy)
[17:40:42.719] plan(): nbrOfWorkers() = 2
[17:40:42.719] Future #2
[17:40:42.719]  length: 1 (resolved future 2)
[17:40:42.720]  length: 0 (resolved future 3)
[17:40:42.720] resolve() on list ... DONE
[17:40:42.720] getGlobalsAndPackages() ...
[17:40:42.720] Searching for globals...
[17:40:42.721] 
[17:40:42.721] Searching for globals ... DONE
[17:40:42.721] - globals: [0] <none>
[17:40:42.721] getGlobalsAndPackages() ... DONE
[17:40:42.721] getGlobalsAndPackages() ...
[17:40:42.721] Searching for globals...
[17:40:42.722] 
[17:40:42.722] Searching for globals ... DONE
[17:40:42.722] - globals: [0] <none>
[17:40:42.722] getGlobalsAndPackages() ... DONE
[17:40:42.722] run() for ‘Future’ ...
[17:40:42.722] - state: ‘created’
[17:40:42.722] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.726] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.726] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.726]   - Field: ‘label’
[17:40:42.726]   - Field: ‘local’
[17:40:42.726]   - Field: ‘owner’
[17:40:42.726]   - Field: ‘envir’
[17:40:42.726]   - Field: ‘workers’
[17:40:42.727]   - Field: ‘packages’
[17:40:42.727]   - Field: ‘gc’
[17:40:42.727]   - Field: ‘job’
[17:40:42.727]   - Field: ‘conditions’
[17:40:42.727]   - Field: ‘expr’
[17:40:42.727]   - Field: ‘uuid’
[17:40:42.727]   - Field: ‘seed’
[17:40:42.727]   - Field: ‘version’
[17:40:42.727]   - Field: ‘result’
[17:40:42.727]   - Field: ‘asynchronous’
[17:40:42.728]   - Field: ‘calls’
[17:40:42.728]   - Field: ‘globals’
[17:40:42.728]   - Field: ‘stdout’
[17:40:42.728]   - Field: ‘earlySignal’
[17:40:42.728]   - Field: ‘lazy’
[17:40:42.728]   - Field: ‘state’
[17:40:42.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.728] - Launch lazy future ...
[17:40:42.729] Packages needed by the future expression (n = 0): <none>
[17:40:42.729] Packages needed by future strategies (n = 0): <none>
[17:40:42.729] {
[17:40:42.729]     {
[17:40:42.729]         {
[17:40:42.729]             ...future.startTime <- base::Sys.time()
[17:40:42.729]             {
[17:40:42.729]                 {
[17:40:42.729]                   {
[17:40:42.729]                     {
[17:40:42.729]                       base::local({
[17:40:42.729]                         has_future <- base::requireNamespace("future", 
[17:40:42.729]                           quietly = TRUE)
[17:40:42.729]                         if (has_future) {
[17:40:42.729]                           ns <- base::getNamespace("future")
[17:40:42.729]                           version <- ns[[".package"]][["version"]]
[17:40:42.729]                           if (is.null(version)) 
[17:40:42.729]                             version <- utils::packageVersion("future")
[17:40:42.729]                         }
[17:40:42.729]                         else {
[17:40:42.729]                           version <- NULL
[17:40:42.729]                         }
[17:40:42.729]                         if (!has_future || version < "1.8.0") {
[17:40:42.729]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.729]                             "", base::R.version$version.string), 
[17:40:42.729]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.729]                               "release", "version")], collapse = " "), 
[17:40:42.729]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.729]                             info)
[17:40:42.729]                           info <- base::paste(info, collapse = "; ")
[17:40:42.729]                           if (!has_future) {
[17:40:42.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.729]                               info)
[17:40:42.729]                           }
[17:40:42.729]                           else {
[17:40:42.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.729]                               info, version)
[17:40:42.729]                           }
[17:40:42.729]                           base::stop(msg)
[17:40:42.729]                         }
[17:40:42.729]                       })
[17:40:42.729]                     }
[17:40:42.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.729]                     base::options(mc.cores = 1L)
[17:40:42.729]                   }
[17:40:42.729]                   ...future.strategy.old <- future::plan("list")
[17:40:42.729]                   options(future.plan = NULL)
[17:40:42.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.729]                 }
[17:40:42.729]                 ...future.workdir <- getwd()
[17:40:42.729]             }
[17:40:42.729]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.729]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.729]         }
[17:40:42.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.729]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.729]             base::names(...future.oldOptions))
[17:40:42.729]     }
[17:40:42.729]     if (FALSE) {
[17:40:42.729]     }
[17:40:42.729]     else {
[17:40:42.729]         if (TRUE) {
[17:40:42.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.729]                 open = "w")
[17:40:42.729]         }
[17:40:42.729]         else {
[17:40:42.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.729]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.729]         }
[17:40:42.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.729]             base::sink(type = "output", split = FALSE)
[17:40:42.729]             base::close(...future.stdout)
[17:40:42.729]         }, add = TRUE)
[17:40:42.729]     }
[17:40:42.729]     ...future.frame <- base::sys.nframe()
[17:40:42.729]     ...future.conditions <- base::list()
[17:40:42.729]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.729]     if (FALSE) {
[17:40:42.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.729]     }
[17:40:42.729]     ...future.result <- base::tryCatch({
[17:40:42.729]         base::withCallingHandlers({
[17:40:42.729]             ...future.value <- base::withVisible(base::local({
[17:40:42.729]                 withCallingHandlers({
[17:40:42.729]                   2
[17:40:42.729]                 }, immediateCondition = function(cond) {
[17:40:42.729]                   save_rds <- function (object, pathname, ...) 
[17:40:42.729]                   {
[17:40:42.729]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.729]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.729]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.729]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.729]                         fi_tmp[["mtime"]])
[17:40:42.729]                     }
[17:40:42.729]                     tryCatch({
[17:40:42.729]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.729]                     }, error = function(ex) {
[17:40:42.729]                       msg <- conditionMessage(ex)
[17:40:42.729]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.729]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.729]                         fi_tmp[["mtime"]], msg)
[17:40:42.729]                       ex$message <- msg
[17:40:42.729]                       stop(ex)
[17:40:42.729]                     })
[17:40:42.729]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.729]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.729]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.729]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.729]                       fi <- file.info(pathname)
[17:40:42.729]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.729]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.729]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.729]                         fi[["size"]], fi[["mtime"]])
[17:40:42.729]                       stop(msg)
[17:40:42.729]                     }
[17:40:42.729]                     invisible(pathname)
[17:40:42.729]                   }
[17:40:42.729]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.729]                     rootPath = tempdir()) 
[17:40:42.729]                   {
[17:40:42.729]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.729]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.729]                       tmpdir = path, fileext = ".rds")
[17:40:42.729]                     save_rds(obj, file)
[17:40:42.729]                   }
[17:40:42.729]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.729]                   {
[17:40:42.729]                     inherits <- base::inherits
[17:40:42.729]                     invokeRestart <- base::invokeRestart
[17:40:42.729]                     is.null <- base::is.null
[17:40:42.729]                     muffled <- FALSE
[17:40:42.729]                     if (inherits(cond, "message")) {
[17:40:42.729]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.729]                       if (muffled) 
[17:40:42.729]                         invokeRestart("muffleMessage")
[17:40:42.729]                     }
[17:40:42.729]                     else if (inherits(cond, "warning")) {
[17:40:42.729]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.729]                       if (muffled) 
[17:40:42.729]                         invokeRestart("muffleWarning")
[17:40:42.729]                     }
[17:40:42.729]                     else if (inherits(cond, "condition")) {
[17:40:42.729]                       if (!is.null(pattern)) {
[17:40:42.729]                         computeRestarts <- base::computeRestarts
[17:40:42.729]                         grepl <- base::grepl
[17:40:42.729]                         restarts <- computeRestarts(cond)
[17:40:42.729]                         for (restart in restarts) {
[17:40:42.729]                           name <- restart$name
[17:40:42.729]                           if (is.null(name)) 
[17:40:42.729]                             next
[17:40:42.729]                           if (!grepl(pattern, name)) 
[17:40:42.729]                             next
[17:40:42.729]                           invokeRestart(restart)
[17:40:42.729]                           muffled <- TRUE
[17:40:42.729]                           break
[17:40:42.729]                         }
[17:40:42.729]                       }
[17:40:42.729]                     }
[17:40:42.729]                     invisible(muffled)
[17:40:42.729]                   }
[17:40:42.729]                   muffleCondition(cond)
[17:40:42.729]                 })
[17:40:42.729]             }))
[17:40:42.729]             future::FutureResult(value = ...future.value$value, 
[17:40:42.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.729]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.729]                     ...future.globalenv.names))
[17:40:42.729]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.729]         }, condition = base::local({
[17:40:42.729]             c <- base::c
[17:40:42.729]             inherits <- base::inherits
[17:40:42.729]             invokeRestart <- base::invokeRestart
[17:40:42.729]             length <- base::length
[17:40:42.729]             list <- base::list
[17:40:42.729]             seq.int <- base::seq.int
[17:40:42.729]             signalCondition <- base::signalCondition
[17:40:42.729]             sys.calls <- base::sys.calls
[17:40:42.729]             `[[` <- base::`[[`
[17:40:42.729]             `+` <- base::`+`
[17:40:42.729]             `<<-` <- base::`<<-`
[17:40:42.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.729]                   3L)]
[17:40:42.729]             }
[17:40:42.729]             function(cond) {
[17:40:42.729]                 is_error <- inherits(cond, "error")
[17:40:42.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.729]                   NULL)
[17:40:42.729]                 if (is_error) {
[17:40:42.729]                   sessionInformation <- function() {
[17:40:42.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.729]                       search = base::search(), system = base::Sys.info())
[17:40:42.729]                   }
[17:40:42.729]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.729]                     cond$call), session = sessionInformation(), 
[17:40:42.729]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.729]                   signalCondition(cond)
[17:40:42.729]                 }
[17:40:42.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.729]                 "immediateCondition"))) {
[17:40:42.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.729]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.729]                   if (TRUE && !signal) {
[17:40:42.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.729]                     {
[17:40:42.729]                       inherits <- base::inherits
[17:40:42.729]                       invokeRestart <- base::invokeRestart
[17:40:42.729]                       is.null <- base::is.null
[17:40:42.729]                       muffled <- FALSE
[17:40:42.729]                       if (inherits(cond, "message")) {
[17:40:42.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.729]                         if (muffled) 
[17:40:42.729]                           invokeRestart("muffleMessage")
[17:40:42.729]                       }
[17:40:42.729]                       else if (inherits(cond, "warning")) {
[17:40:42.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.729]                         if (muffled) 
[17:40:42.729]                           invokeRestart("muffleWarning")
[17:40:42.729]                       }
[17:40:42.729]                       else if (inherits(cond, "condition")) {
[17:40:42.729]                         if (!is.null(pattern)) {
[17:40:42.729]                           computeRestarts <- base::computeRestarts
[17:40:42.729]                           grepl <- base::grepl
[17:40:42.729]                           restarts <- computeRestarts(cond)
[17:40:42.729]                           for (restart in restarts) {
[17:40:42.729]                             name <- restart$name
[17:40:42.729]                             if (is.null(name)) 
[17:40:42.729]                               next
[17:40:42.729]                             if (!grepl(pattern, name)) 
[17:40:42.729]                               next
[17:40:42.729]                             invokeRestart(restart)
[17:40:42.729]                             muffled <- TRUE
[17:40:42.729]                             break
[17:40:42.729]                           }
[17:40:42.729]                         }
[17:40:42.729]                       }
[17:40:42.729]                       invisible(muffled)
[17:40:42.729]                     }
[17:40:42.729]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.729]                   }
[17:40:42.729]                 }
[17:40:42.729]                 else {
[17:40:42.729]                   if (TRUE) {
[17:40:42.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.729]                     {
[17:40:42.729]                       inherits <- base::inherits
[17:40:42.729]                       invokeRestart <- base::invokeRestart
[17:40:42.729]                       is.null <- base::is.null
[17:40:42.729]                       muffled <- FALSE
[17:40:42.729]                       if (inherits(cond, "message")) {
[17:40:42.729]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.729]                         if (muffled) 
[17:40:42.729]                           invokeRestart("muffleMessage")
[17:40:42.729]                       }
[17:40:42.729]                       else if (inherits(cond, "warning")) {
[17:40:42.729]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.729]                         if (muffled) 
[17:40:42.729]                           invokeRestart("muffleWarning")
[17:40:42.729]                       }
[17:40:42.729]                       else if (inherits(cond, "condition")) {
[17:40:42.729]                         if (!is.null(pattern)) {
[17:40:42.729]                           computeRestarts <- base::computeRestarts
[17:40:42.729]                           grepl <- base::grepl
[17:40:42.729]                           restarts <- computeRestarts(cond)
[17:40:42.729]                           for (restart in restarts) {
[17:40:42.729]                             name <- restart$name
[17:40:42.729]                             if (is.null(name)) 
[17:40:42.729]                               next
[17:40:42.729]                             if (!grepl(pattern, name)) 
[17:40:42.729]                               next
[17:40:42.729]                             invokeRestart(restart)
[17:40:42.729]                             muffled <- TRUE
[17:40:42.729]                             break
[17:40:42.729]                           }
[17:40:42.729]                         }
[17:40:42.729]                       }
[17:40:42.729]                       invisible(muffled)
[17:40:42.729]                     }
[17:40:42.729]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.729]                   }
[17:40:42.729]                 }
[17:40:42.729]             }
[17:40:42.729]         }))
[17:40:42.729]     }, error = function(ex) {
[17:40:42.729]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.729]                 ...future.rng), started = ...future.startTime, 
[17:40:42.729]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.729]             version = "1.8"), class = "FutureResult")
[17:40:42.729]     }, finally = {
[17:40:42.729]         if (!identical(...future.workdir, getwd())) 
[17:40:42.729]             setwd(...future.workdir)
[17:40:42.729]         {
[17:40:42.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.729]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.729]             }
[17:40:42.729]             base::options(...future.oldOptions)
[17:40:42.729]             if (.Platform$OS.type == "windows") {
[17:40:42.729]                 old_names <- names(...future.oldEnvVars)
[17:40:42.729]                 envs <- base::Sys.getenv()
[17:40:42.729]                 names <- names(envs)
[17:40:42.729]                 common <- intersect(names, old_names)
[17:40:42.729]                 added <- setdiff(names, old_names)
[17:40:42.729]                 removed <- setdiff(old_names, names)
[17:40:42.729]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.729]                   envs[common]]
[17:40:42.729]                 NAMES <- toupper(changed)
[17:40:42.729]                 args <- list()
[17:40:42.729]                 for (kk in seq_along(NAMES)) {
[17:40:42.729]                   name <- changed[[kk]]
[17:40:42.729]                   NAME <- NAMES[[kk]]
[17:40:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.729]                     next
[17:40:42.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.729]                 }
[17:40:42.729]                 NAMES <- toupper(added)
[17:40:42.729]                 for (kk in seq_along(NAMES)) {
[17:40:42.729]                   name <- added[[kk]]
[17:40:42.729]                   NAME <- NAMES[[kk]]
[17:40:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.729]                     next
[17:40:42.729]                   args[[name]] <- ""
[17:40:42.729]                 }
[17:40:42.729]                 NAMES <- toupper(removed)
[17:40:42.729]                 for (kk in seq_along(NAMES)) {
[17:40:42.729]                   name <- removed[[kk]]
[17:40:42.729]                   NAME <- NAMES[[kk]]
[17:40:42.729]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.729]                     next
[17:40:42.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.729]                 }
[17:40:42.729]                 if (length(args) > 0) 
[17:40:42.729]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.729]             }
[17:40:42.729]             else {
[17:40:42.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.729]             }
[17:40:42.729]             {
[17:40:42.729]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.729]                   0L) {
[17:40:42.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.729]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.729]                   base::options(opts)
[17:40:42.729]                 }
[17:40:42.729]                 {
[17:40:42.729]                   {
[17:40:42.729]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.729]                     NULL
[17:40:42.729]                   }
[17:40:42.729]                   options(future.plan = NULL)
[17:40:42.729]                   if (is.na(NA_character_)) 
[17:40:42.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.729]                     .init = FALSE)
[17:40:42.729]                 }
[17:40:42.729]             }
[17:40:42.729]         }
[17:40:42.729]     })
[17:40:42.729]     if (TRUE) {
[17:40:42.729]         base::sink(type = "output", split = FALSE)
[17:40:42.729]         if (TRUE) {
[17:40:42.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.729]         }
[17:40:42.729]         else {
[17:40:42.729]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.729]         }
[17:40:42.729]         base::close(...future.stdout)
[17:40:42.729]         ...future.stdout <- NULL
[17:40:42.729]     }
[17:40:42.729]     ...future.result$conditions <- ...future.conditions
[17:40:42.729]     ...future.result$finished <- base::Sys.time()
[17:40:42.729]     ...future.result
[17:40:42.729] }
[17:40:42.731] requestCore(): workers = 2
[17:40:42.732] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.742] result() for MulticoreFuture ...
[17:40:42.744] result() for MulticoreFuture ...
[17:40:42.744] result() for MulticoreFuture ... done
[17:40:42.744] result() for MulticoreFuture ... done
[17:40:42.744] result() for MulticoreFuture ...
[17:40:42.744] result() for MulticoreFuture ... done
[17:40:42.748] MulticoreFuture started
[17:40:42.748] - Launch lazy future ... done
[17:40:42.749] run() for ‘MulticoreFuture’ ... done
[17:40:42.749] plan(): Setting new future strategy stack:
[17:40:42.749] resolve() on list ...
[17:40:42.749]  recursive: 0
[17:40:42.749]  length: 3
[17:40:42.750]  elements: ‘a’, ‘b’, ‘’
[17:40:42.750] run() for ‘Future’ ...
[17:40:42.750] - state: ‘created’
[17:40:42.749] List of future strategies:
[17:40:42.749] 1. sequential:
[17:40:42.749]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.749]    - tweaked: FALSE
[17:40:42.749]    - call: NULL
[17:40:42.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.750] plan(): nbrOfWorkers() = 1
[17:40:42.752] plan(): Setting new future strategy stack:
[17:40:42.753] List of future strategies:
[17:40:42.753] 1. multicore:
[17:40:42.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.753]    - tweaked: FALSE
[17:40:42.753]    - call: plan(strategy)
[17:40:42.756] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.757] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.757]   - Field: ‘label’
[17:40:42.757]   - Field: ‘local’
[17:40:42.757]   - Field: ‘owner’
[17:40:42.758] plan(): nbrOfWorkers() = 2
[17:40:42.757]   - Field: ‘envir’
[17:40:42.758]   - Field: ‘workers’
[17:40:42.758]   - Field: ‘packages’
[17:40:42.758]   - Field: ‘gc’
[17:40:42.758]   - Field: ‘job’
[17:40:42.758]   - Field: ‘conditions’
[17:40:42.759]   - Field: ‘expr’
[17:40:42.759]   - Field: ‘uuid’
[17:40:42.759]   - Field: ‘seed’
[17:40:42.759]   - Field: ‘version’
[17:40:42.759]   - Field: ‘result’
[17:40:42.760]   - Field: ‘asynchronous’
[17:40:42.760]   - Field: ‘calls’
[17:40:42.760]   - Field: ‘globals’
[17:40:42.760]   - Field: ‘stdout’
[17:40:42.760]   - Field: ‘earlySignal’
[17:40:42.761]   - Field: ‘lazy’
[17:40:42.761]   - Field: ‘state’
[17:40:42.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.761] - Launch lazy future ...
[17:40:42.762] Packages needed by the future expression (n = 0): <none>
[17:40:42.762] Packages needed by future strategies (n = 0): <none>
[17:40:42.763] {
[17:40:42.763]     {
[17:40:42.763]         {
[17:40:42.763]             ...future.startTime <- base::Sys.time()
[17:40:42.763]             {
[17:40:42.763]                 {
[17:40:42.763]                   {
[17:40:42.763]                     {
[17:40:42.763]                       base::local({
[17:40:42.763]                         has_future <- base::requireNamespace("future", 
[17:40:42.763]                           quietly = TRUE)
[17:40:42.763]                         if (has_future) {
[17:40:42.763]                           ns <- base::getNamespace("future")
[17:40:42.763]                           version <- ns[[".package"]][["version"]]
[17:40:42.763]                           if (is.null(version)) 
[17:40:42.763]                             version <- utils::packageVersion("future")
[17:40:42.763]                         }
[17:40:42.763]                         else {
[17:40:42.763]                           version <- NULL
[17:40:42.763]                         }
[17:40:42.763]                         if (!has_future || version < "1.8.0") {
[17:40:42.763]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.763]                             "", base::R.version$version.string), 
[17:40:42.763]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.763]                               "release", "version")], collapse = " "), 
[17:40:42.763]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.763]                             info)
[17:40:42.763]                           info <- base::paste(info, collapse = "; ")
[17:40:42.763]                           if (!has_future) {
[17:40:42.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.763]                               info)
[17:40:42.763]                           }
[17:40:42.763]                           else {
[17:40:42.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.763]                               info, version)
[17:40:42.763]                           }
[17:40:42.763]                           base::stop(msg)
[17:40:42.763]                         }
[17:40:42.763]                       })
[17:40:42.763]                     }
[17:40:42.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.763]                     base::options(mc.cores = 1L)
[17:40:42.763]                   }
[17:40:42.763]                   ...future.strategy.old <- future::plan("list")
[17:40:42.763]                   options(future.plan = NULL)
[17:40:42.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.763]                 }
[17:40:42.763]                 ...future.workdir <- getwd()
[17:40:42.763]             }
[17:40:42.763]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.763]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.763]         }
[17:40:42.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.763]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.763]             base::names(...future.oldOptions))
[17:40:42.763]     }
[17:40:42.763]     if (FALSE) {
[17:40:42.763]     }
[17:40:42.763]     else {
[17:40:42.763]         if (TRUE) {
[17:40:42.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.763]                 open = "w")
[17:40:42.763]         }
[17:40:42.763]         else {
[17:40:42.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.763]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.763]         }
[17:40:42.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.763]             base::sink(type = "output", split = FALSE)
[17:40:42.763]             base::close(...future.stdout)
[17:40:42.763]         }, add = TRUE)
[17:40:42.763]     }
[17:40:42.763]     ...future.frame <- base::sys.nframe()
[17:40:42.763]     ...future.conditions <- base::list()
[17:40:42.763]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.763]     if (FALSE) {
[17:40:42.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.763]     }
[17:40:42.763]     ...future.result <- base::tryCatch({
[17:40:42.763]         base::withCallingHandlers({
[17:40:42.763]             ...future.value <- base::withVisible(base::local({
[17:40:42.763]                 withCallingHandlers({
[17:40:42.763]                   1
[17:40:42.763]                 }, immediateCondition = function(cond) {
[17:40:42.763]                   save_rds <- function (object, pathname, ...) 
[17:40:42.763]                   {
[17:40:42.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.763]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.763]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.763]                         fi_tmp[["mtime"]])
[17:40:42.763]                     }
[17:40:42.763]                     tryCatch({
[17:40:42.763]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.763]                     }, error = function(ex) {
[17:40:42.763]                       msg <- conditionMessage(ex)
[17:40:42.763]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.763]                         fi_tmp[["mtime"]], msg)
[17:40:42.763]                       ex$message <- msg
[17:40:42.763]                       stop(ex)
[17:40:42.763]                     })
[17:40:42.763]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.763]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.763]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.763]                       fi <- file.info(pathname)
[17:40:42.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.763]                         fi[["size"]], fi[["mtime"]])
[17:40:42.763]                       stop(msg)
[17:40:42.763]                     }
[17:40:42.763]                     invisible(pathname)
[17:40:42.763]                   }
[17:40:42.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.763]                     rootPath = tempdir()) 
[17:40:42.763]                   {
[17:40:42.763]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.763]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.763]                       tmpdir = path, fileext = ".rds")
[17:40:42.763]                     save_rds(obj, file)
[17:40:42.763]                   }
[17:40:42.763]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.763]                   {
[17:40:42.763]                     inherits <- base::inherits
[17:40:42.763]                     invokeRestart <- base::invokeRestart
[17:40:42.763]                     is.null <- base::is.null
[17:40:42.763]                     muffled <- FALSE
[17:40:42.763]                     if (inherits(cond, "message")) {
[17:40:42.763]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.763]                       if (muffled) 
[17:40:42.763]                         invokeRestart("muffleMessage")
[17:40:42.763]                     }
[17:40:42.763]                     else if (inherits(cond, "warning")) {
[17:40:42.763]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.763]                       if (muffled) 
[17:40:42.763]                         invokeRestart("muffleWarning")
[17:40:42.763]                     }
[17:40:42.763]                     else if (inherits(cond, "condition")) {
[17:40:42.763]                       if (!is.null(pattern)) {
[17:40:42.763]                         computeRestarts <- base::computeRestarts
[17:40:42.763]                         grepl <- base::grepl
[17:40:42.763]                         restarts <- computeRestarts(cond)
[17:40:42.763]                         for (restart in restarts) {
[17:40:42.763]                           name <- restart$name
[17:40:42.763]                           if (is.null(name)) 
[17:40:42.763]                             next
[17:40:42.763]                           if (!grepl(pattern, name)) 
[17:40:42.763]                             next
[17:40:42.763]                           invokeRestart(restart)
[17:40:42.763]                           muffled <- TRUE
[17:40:42.763]                           break
[17:40:42.763]                         }
[17:40:42.763]                       }
[17:40:42.763]                     }
[17:40:42.763]                     invisible(muffled)
[17:40:42.763]                   }
[17:40:42.763]                   muffleCondition(cond)
[17:40:42.763]                 })
[17:40:42.763]             }))
[17:40:42.763]             future::FutureResult(value = ...future.value$value, 
[17:40:42.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.763]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.763]                     ...future.globalenv.names))
[17:40:42.763]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.763]         }, condition = base::local({
[17:40:42.763]             c <- base::c
[17:40:42.763]             inherits <- base::inherits
[17:40:42.763]             invokeRestart <- base::invokeRestart
[17:40:42.763]             length <- base::length
[17:40:42.763]             list <- base::list
[17:40:42.763]             seq.int <- base::seq.int
[17:40:42.763]             signalCondition <- base::signalCondition
[17:40:42.763]             sys.calls <- base::sys.calls
[17:40:42.763]             `[[` <- base::`[[`
[17:40:42.763]             `+` <- base::`+`
[17:40:42.763]             `<<-` <- base::`<<-`
[17:40:42.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.763]                   3L)]
[17:40:42.763]             }
[17:40:42.763]             function(cond) {
[17:40:42.763]                 is_error <- inherits(cond, "error")
[17:40:42.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.763]                   NULL)
[17:40:42.763]                 if (is_error) {
[17:40:42.763]                   sessionInformation <- function() {
[17:40:42.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.763]                       search = base::search(), system = base::Sys.info())
[17:40:42.763]                   }
[17:40:42.763]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.763]                     cond$call), session = sessionInformation(), 
[17:40:42.763]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.763]                   signalCondition(cond)
[17:40:42.763]                 }
[17:40:42.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.763]                 "immediateCondition"))) {
[17:40:42.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.763]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.763]                   if (TRUE && !signal) {
[17:40:42.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.763]                     {
[17:40:42.763]                       inherits <- base::inherits
[17:40:42.763]                       invokeRestart <- base::invokeRestart
[17:40:42.763]                       is.null <- base::is.null
[17:40:42.763]                       muffled <- FALSE
[17:40:42.763]                       if (inherits(cond, "message")) {
[17:40:42.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.763]                         if (muffled) 
[17:40:42.763]                           invokeRestart("muffleMessage")
[17:40:42.763]                       }
[17:40:42.763]                       else if (inherits(cond, "warning")) {
[17:40:42.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.763]                         if (muffled) 
[17:40:42.763]                           invokeRestart("muffleWarning")
[17:40:42.763]                       }
[17:40:42.763]                       else if (inherits(cond, "condition")) {
[17:40:42.763]                         if (!is.null(pattern)) {
[17:40:42.763]                           computeRestarts <- base::computeRestarts
[17:40:42.763]                           grepl <- base::grepl
[17:40:42.763]                           restarts <- computeRestarts(cond)
[17:40:42.763]                           for (restart in restarts) {
[17:40:42.763]                             name <- restart$name
[17:40:42.763]                             if (is.null(name)) 
[17:40:42.763]                               next
[17:40:42.763]                             if (!grepl(pattern, name)) 
[17:40:42.763]                               next
[17:40:42.763]                             invokeRestart(restart)
[17:40:42.763]                             muffled <- TRUE
[17:40:42.763]                             break
[17:40:42.763]                           }
[17:40:42.763]                         }
[17:40:42.763]                       }
[17:40:42.763]                       invisible(muffled)
[17:40:42.763]                     }
[17:40:42.763]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.763]                   }
[17:40:42.763]                 }
[17:40:42.763]                 else {
[17:40:42.763]                   if (TRUE) {
[17:40:42.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.763]                     {
[17:40:42.763]                       inherits <- base::inherits
[17:40:42.763]                       invokeRestart <- base::invokeRestart
[17:40:42.763]                       is.null <- base::is.null
[17:40:42.763]                       muffled <- FALSE
[17:40:42.763]                       if (inherits(cond, "message")) {
[17:40:42.763]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.763]                         if (muffled) 
[17:40:42.763]                           invokeRestart("muffleMessage")
[17:40:42.763]                       }
[17:40:42.763]                       else if (inherits(cond, "warning")) {
[17:40:42.763]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.763]                         if (muffled) 
[17:40:42.763]                           invokeRestart("muffleWarning")
[17:40:42.763]                       }
[17:40:42.763]                       else if (inherits(cond, "condition")) {
[17:40:42.763]                         if (!is.null(pattern)) {
[17:40:42.763]                           computeRestarts <- base::computeRestarts
[17:40:42.763]                           grepl <- base::grepl
[17:40:42.763]                           restarts <- computeRestarts(cond)
[17:40:42.763]                           for (restart in restarts) {
[17:40:42.763]                             name <- restart$name
[17:40:42.763]                             if (is.null(name)) 
[17:40:42.763]                               next
[17:40:42.763]                             if (!grepl(pattern, name)) 
[17:40:42.763]                               next
[17:40:42.763]                             invokeRestart(restart)
[17:40:42.763]                             muffled <- TRUE
[17:40:42.763]                             break
[17:40:42.763]                           }
[17:40:42.763]                         }
[17:40:42.763]                       }
[17:40:42.763]                       invisible(muffled)
[17:40:42.763]                     }
[17:40:42.763]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.763]                   }
[17:40:42.763]                 }
[17:40:42.763]             }
[17:40:42.763]         }))
[17:40:42.763]     }, error = function(ex) {
[17:40:42.763]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.763]                 ...future.rng), started = ...future.startTime, 
[17:40:42.763]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.763]             version = "1.8"), class = "FutureResult")
[17:40:42.763]     }, finally = {
[17:40:42.763]         if (!identical(...future.workdir, getwd())) 
[17:40:42.763]             setwd(...future.workdir)
[17:40:42.763]         {
[17:40:42.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.763]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.763]             }
[17:40:42.763]             base::options(...future.oldOptions)
[17:40:42.763]             if (.Platform$OS.type == "windows") {
[17:40:42.763]                 old_names <- names(...future.oldEnvVars)
[17:40:42.763]                 envs <- base::Sys.getenv()
[17:40:42.763]                 names <- names(envs)
[17:40:42.763]                 common <- intersect(names, old_names)
[17:40:42.763]                 added <- setdiff(names, old_names)
[17:40:42.763]                 removed <- setdiff(old_names, names)
[17:40:42.763]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.763]                   envs[common]]
[17:40:42.763]                 NAMES <- toupper(changed)
[17:40:42.763]                 args <- list()
[17:40:42.763]                 for (kk in seq_along(NAMES)) {
[17:40:42.763]                   name <- changed[[kk]]
[17:40:42.763]                   NAME <- NAMES[[kk]]
[17:40:42.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.763]                     next
[17:40:42.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.763]                 }
[17:40:42.763]                 NAMES <- toupper(added)
[17:40:42.763]                 for (kk in seq_along(NAMES)) {
[17:40:42.763]                   name <- added[[kk]]
[17:40:42.763]                   NAME <- NAMES[[kk]]
[17:40:42.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.763]                     next
[17:40:42.763]                   args[[name]] <- ""
[17:40:42.763]                 }
[17:40:42.763]                 NAMES <- toupper(removed)
[17:40:42.763]                 for (kk in seq_along(NAMES)) {
[17:40:42.763]                   name <- removed[[kk]]
[17:40:42.763]                   NAME <- NAMES[[kk]]
[17:40:42.763]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.763]                     next
[17:40:42.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.763]                 }
[17:40:42.763]                 if (length(args) > 0) 
[17:40:42.763]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.763]             }
[17:40:42.763]             else {
[17:40:42.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.763]             }
[17:40:42.763]             {
[17:40:42.763]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.763]                   0L) {
[17:40:42.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.763]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.763]                   base::options(opts)
[17:40:42.763]                 }
[17:40:42.763]                 {
[17:40:42.763]                   {
[17:40:42.763]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.763]                     NULL
[17:40:42.763]                   }
[17:40:42.763]                   options(future.plan = NULL)
[17:40:42.763]                   if (is.na(NA_character_)) 
[17:40:42.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.763]                     .init = FALSE)
[17:40:42.763]                 }
[17:40:42.763]             }
[17:40:42.763]         }
[17:40:42.763]     })
[17:40:42.763]     if (TRUE) {
[17:40:42.763]         base::sink(type = "output", split = FALSE)
[17:40:42.763]         if (TRUE) {
[17:40:42.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.763]         }
[17:40:42.763]         else {
[17:40:42.763]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.763]         }
[17:40:42.763]         base::close(...future.stdout)
[17:40:42.763]         ...future.stdout <- NULL
[17:40:42.763]     }
[17:40:42.763]     ...future.result$conditions <- ...future.conditions
[17:40:42.763]     ...future.result$finished <- base::Sys.time()
[17:40:42.763]     ...future.result
[17:40:42.763] }
[17:40:42.767] requestCore(): workers = 2
[17:40:42.767] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.795] result() for MulticoreFuture ...
[17:40:42.795] result() for MulticoreFuture ...
[17:40:42.796] result() for MulticoreFuture ... done
[17:40:42.796] result() for MulticoreFuture ... done
[17:40:42.796] result() for MulticoreFuture ...
[17:40:42.796] result() for MulticoreFuture ... done
[17:40:42.799] MulticoreFuture started
[17:40:42.800] - Launch lazy future ... done
[17:40:42.800] run() for ‘MulticoreFuture’ ... done
[17:40:42.800] plan(): Setting new future strategy stack:
[17:40:42.801] List of future strategies:
[17:40:42.801] 1. sequential:
[17:40:42.801]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.801]    - tweaked: FALSE
[17:40:42.801]    - call: NULL
[17:40:42.803] plan(): nbrOfWorkers() = 1
[17:40:42.805] plan(): Setting new future strategy stack:
[17:40:42.805] List of future strategies:
[17:40:42.805] 1. multicore:
[17:40:42.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.805]    - tweaked: FALSE
[17:40:42.805]    - call: plan(strategy)
[17:40:42.811] plan(): nbrOfWorkers() = 2
[17:40:42.811] Future #2
[17:40:42.812]  length: 2 (resolved future 2)
[17:40:42.812]  length: 1 (resolved future 3)
[17:40:42.823] Future #1
[17:40:42.823]  length: 0 (resolved future 1)
[17:40:42.823] resolve() on list ... DONE
[17:40:42.824] getGlobalsAndPackages() ...
[17:40:42.824] Searching for globals...
[17:40:42.825] 
[17:40:42.825] Searching for globals ... DONE
[17:40:42.825] - globals: [0] <none>
[17:40:42.825] getGlobalsAndPackages() ... DONE
[17:40:42.826] getGlobalsAndPackages() ...
[17:40:42.826] Searching for globals...
[17:40:42.826] 
[17:40:42.827] Searching for globals ... DONE
[17:40:42.827] - globals: [0] <none>
[17:40:42.827] getGlobalsAndPackages() ... DONE
[17:40:42.827] resolve() on list ...
[17:40:42.827]  recursive: 0
[17:40:42.828]  length: 3
[17:40:42.828]  elements: ‘a’, ‘b’, ‘’
[17:40:42.828] run() for ‘Future’ ...
[17:40:42.828] - state: ‘created’
[17:40:42.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.833] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.834]   - Field: ‘label’
[17:40:42.834]   - Field: ‘local’
[17:40:42.834]   - Field: ‘owner’
[17:40:42.834]   - Field: ‘envir’
[17:40:42.834]   - Field: ‘workers’
[17:40:42.834]   - Field: ‘packages’
[17:40:42.834]   - Field: ‘gc’
[17:40:42.835]   - Field: ‘job’
[17:40:42.835]   - Field: ‘conditions’
[17:40:42.835]   - Field: ‘expr’
[17:40:42.835]   - Field: ‘uuid’
[17:40:42.835]   - Field: ‘seed’
[17:40:42.835]   - Field: ‘version’
[17:40:42.835]   - Field: ‘result’
[17:40:42.836]   - Field: ‘asynchronous’
[17:40:42.836]   - Field: ‘calls’
[17:40:42.836]   - Field: ‘globals’
[17:40:42.836]   - Field: ‘stdout’
[17:40:42.836]   - Field: ‘earlySignal’
[17:40:42.836]   - Field: ‘lazy’
[17:40:42.836]   - Field: ‘state’
[17:40:42.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.837] - Launch lazy future ...
[17:40:42.837] Packages needed by the future expression (n = 0): <none>
[17:40:42.837] Packages needed by future strategies (n = 0): <none>
[17:40:42.838] {
[17:40:42.838]     {
[17:40:42.838]         {
[17:40:42.838]             ...future.startTime <- base::Sys.time()
[17:40:42.838]             {
[17:40:42.838]                 {
[17:40:42.838]                   {
[17:40:42.838]                     {
[17:40:42.838]                       base::local({
[17:40:42.838]                         has_future <- base::requireNamespace("future", 
[17:40:42.838]                           quietly = TRUE)
[17:40:42.838]                         if (has_future) {
[17:40:42.838]                           ns <- base::getNamespace("future")
[17:40:42.838]                           version <- ns[[".package"]][["version"]]
[17:40:42.838]                           if (is.null(version)) 
[17:40:42.838]                             version <- utils::packageVersion("future")
[17:40:42.838]                         }
[17:40:42.838]                         else {
[17:40:42.838]                           version <- NULL
[17:40:42.838]                         }
[17:40:42.838]                         if (!has_future || version < "1.8.0") {
[17:40:42.838]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.838]                             "", base::R.version$version.string), 
[17:40:42.838]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.838]                               "release", "version")], collapse = " "), 
[17:40:42.838]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.838]                             info)
[17:40:42.838]                           info <- base::paste(info, collapse = "; ")
[17:40:42.838]                           if (!has_future) {
[17:40:42.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.838]                               info)
[17:40:42.838]                           }
[17:40:42.838]                           else {
[17:40:42.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.838]                               info, version)
[17:40:42.838]                           }
[17:40:42.838]                           base::stop(msg)
[17:40:42.838]                         }
[17:40:42.838]                       })
[17:40:42.838]                     }
[17:40:42.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.838]                     base::options(mc.cores = 1L)
[17:40:42.838]                   }
[17:40:42.838]                   ...future.strategy.old <- future::plan("list")
[17:40:42.838]                   options(future.plan = NULL)
[17:40:42.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.838]                 }
[17:40:42.838]                 ...future.workdir <- getwd()
[17:40:42.838]             }
[17:40:42.838]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.838]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.838]         }
[17:40:42.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.838]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.838]             base::names(...future.oldOptions))
[17:40:42.838]     }
[17:40:42.838]     if (FALSE) {
[17:40:42.838]     }
[17:40:42.838]     else {
[17:40:42.838]         if (TRUE) {
[17:40:42.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.838]                 open = "w")
[17:40:42.838]         }
[17:40:42.838]         else {
[17:40:42.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.838]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.838]         }
[17:40:42.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.838]             base::sink(type = "output", split = FALSE)
[17:40:42.838]             base::close(...future.stdout)
[17:40:42.838]         }, add = TRUE)
[17:40:42.838]     }
[17:40:42.838]     ...future.frame <- base::sys.nframe()
[17:40:42.838]     ...future.conditions <- base::list()
[17:40:42.838]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.838]     if (FALSE) {
[17:40:42.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.838]     }
[17:40:42.838]     ...future.result <- base::tryCatch({
[17:40:42.838]         base::withCallingHandlers({
[17:40:42.838]             ...future.value <- base::withVisible(base::local({
[17:40:42.838]                 withCallingHandlers({
[17:40:42.838]                   1
[17:40:42.838]                 }, immediateCondition = function(cond) {
[17:40:42.838]                   save_rds <- function (object, pathname, ...) 
[17:40:42.838]                   {
[17:40:42.838]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.838]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.838]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.838]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.838]                         fi_tmp[["mtime"]])
[17:40:42.838]                     }
[17:40:42.838]                     tryCatch({
[17:40:42.838]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.838]                     }, error = function(ex) {
[17:40:42.838]                       msg <- conditionMessage(ex)
[17:40:42.838]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.838]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.838]                         fi_tmp[["mtime"]], msg)
[17:40:42.838]                       ex$message <- msg
[17:40:42.838]                       stop(ex)
[17:40:42.838]                     })
[17:40:42.838]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.838]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.838]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.838]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.838]                       fi <- file.info(pathname)
[17:40:42.838]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.838]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.838]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.838]                         fi[["size"]], fi[["mtime"]])
[17:40:42.838]                       stop(msg)
[17:40:42.838]                     }
[17:40:42.838]                     invisible(pathname)
[17:40:42.838]                   }
[17:40:42.838]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.838]                     rootPath = tempdir()) 
[17:40:42.838]                   {
[17:40:42.838]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.838]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.838]                       tmpdir = path, fileext = ".rds")
[17:40:42.838]                     save_rds(obj, file)
[17:40:42.838]                   }
[17:40:42.838]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.838]                   {
[17:40:42.838]                     inherits <- base::inherits
[17:40:42.838]                     invokeRestart <- base::invokeRestart
[17:40:42.838]                     is.null <- base::is.null
[17:40:42.838]                     muffled <- FALSE
[17:40:42.838]                     if (inherits(cond, "message")) {
[17:40:42.838]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.838]                       if (muffled) 
[17:40:42.838]                         invokeRestart("muffleMessage")
[17:40:42.838]                     }
[17:40:42.838]                     else if (inherits(cond, "warning")) {
[17:40:42.838]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.838]                       if (muffled) 
[17:40:42.838]                         invokeRestart("muffleWarning")
[17:40:42.838]                     }
[17:40:42.838]                     else if (inherits(cond, "condition")) {
[17:40:42.838]                       if (!is.null(pattern)) {
[17:40:42.838]                         computeRestarts <- base::computeRestarts
[17:40:42.838]                         grepl <- base::grepl
[17:40:42.838]                         restarts <- computeRestarts(cond)
[17:40:42.838]                         for (restart in restarts) {
[17:40:42.838]                           name <- restart$name
[17:40:42.838]                           if (is.null(name)) 
[17:40:42.838]                             next
[17:40:42.838]                           if (!grepl(pattern, name)) 
[17:40:42.838]                             next
[17:40:42.838]                           invokeRestart(restart)
[17:40:42.838]                           muffled <- TRUE
[17:40:42.838]                           break
[17:40:42.838]                         }
[17:40:42.838]                       }
[17:40:42.838]                     }
[17:40:42.838]                     invisible(muffled)
[17:40:42.838]                   }
[17:40:42.838]                   muffleCondition(cond)
[17:40:42.838]                 })
[17:40:42.838]             }))
[17:40:42.838]             future::FutureResult(value = ...future.value$value, 
[17:40:42.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.838]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.838]                     ...future.globalenv.names))
[17:40:42.838]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.838]         }, condition = base::local({
[17:40:42.838]             c <- base::c
[17:40:42.838]             inherits <- base::inherits
[17:40:42.838]             invokeRestart <- base::invokeRestart
[17:40:42.838]             length <- base::length
[17:40:42.838]             list <- base::list
[17:40:42.838]             seq.int <- base::seq.int
[17:40:42.838]             signalCondition <- base::signalCondition
[17:40:42.838]             sys.calls <- base::sys.calls
[17:40:42.838]             `[[` <- base::`[[`
[17:40:42.838]             `+` <- base::`+`
[17:40:42.838]             `<<-` <- base::`<<-`
[17:40:42.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.838]                   3L)]
[17:40:42.838]             }
[17:40:42.838]             function(cond) {
[17:40:42.838]                 is_error <- inherits(cond, "error")
[17:40:42.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.838]                   NULL)
[17:40:42.838]                 if (is_error) {
[17:40:42.838]                   sessionInformation <- function() {
[17:40:42.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.838]                       search = base::search(), system = base::Sys.info())
[17:40:42.838]                   }
[17:40:42.838]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.838]                     cond$call), session = sessionInformation(), 
[17:40:42.838]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.838]                   signalCondition(cond)
[17:40:42.838]                 }
[17:40:42.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.838]                 "immediateCondition"))) {
[17:40:42.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.838]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.838]                   if (TRUE && !signal) {
[17:40:42.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.838]                     {
[17:40:42.838]                       inherits <- base::inherits
[17:40:42.838]                       invokeRestart <- base::invokeRestart
[17:40:42.838]                       is.null <- base::is.null
[17:40:42.838]                       muffled <- FALSE
[17:40:42.838]                       if (inherits(cond, "message")) {
[17:40:42.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.838]                         if (muffled) 
[17:40:42.838]                           invokeRestart("muffleMessage")
[17:40:42.838]                       }
[17:40:42.838]                       else if (inherits(cond, "warning")) {
[17:40:42.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.838]                         if (muffled) 
[17:40:42.838]                           invokeRestart("muffleWarning")
[17:40:42.838]                       }
[17:40:42.838]                       else if (inherits(cond, "condition")) {
[17:40:42.838]                         if (!is.null(pattern)) {
[17:40:42.838]                           computeRestarts <- base::computeRestarts
[17:40:42.838]                           grepl <- base::grepl
[17:40:42.838]                           restarts <- computeRestarts(cond)
[17:40:42.838]                           for (restart in restarts) {
[17:40:42.838]                             name <- restart$name
[17:40:42.838]                             if (is.null(name)) 
[17:40:42.838]                               next
[17:40:42.838]                             if (!grepl(pattern, name)) 
[17:40:42.838]                               next
[17:40:42.838]                             invokeRestart(restart)
[17:40:42.838]                             muffled <- TRUE
[17:40:42.838]                             break
[17:40:42.838]                           }
[17:40:42.838]                         }
[17:40:42.838]                       }
[17:40:42.838]                       invisible(muffled)
[17:40:42.838]                     }
[17:40:42.838]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.838]                   }
[17:40:42.838]                 }
[17:40:42.838]                 else {
[17:40:42.838]                   if (TRUE) {
[17:40:42.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.838]                     {
[17:40:42.838]                       inherits <- base::inherits
[17:40:42.838]                       invokeRestart <- base::invokeRestart
[17:40:42.838]                       is.null <- base::is.null
[17:40:42.838]                       muffled <- FALSE
[17:40:42.838]                       if (inherits(cond, "message")) {
[17:40:42.838]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.838]                         if (muffled) 
[17:40:42.838]                           invokeRestart("muffleMessage")
[17:40:42.838]                       }
[17:40:42.838]                       else if (inherits(cond, "warning")) {
[17:40:42.838]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.838]                         if (muffled) 
[17:40:42.838]                           invokeRestart("muffleWarning")
[17:40:42.838]                       }
[17:40:42.838]                       else if (inherits(cond, "condition")) {
[17:40:42.838]                         if (!is.null(pattern)) {
[17:40:42.838]                           computeRestarts <- base::computeRestarts
[17:40:42.838]                           grepl <- base::grepl
[17:40:42.838]                           restarts <- computeRestarts(cond)
[17:40:42.838]                           for (restart in restarts) {
[17:40:42.838]                             name <- restart$name
[17:40:42.838]                             if (is.null(name)) 
[17:40:42.838]                               next
[17:40:42.838]                             if (!grepl(pattern, name)) 
[17:40:42.838]                               next
[17:40:42.838]                             invokeRestart(restart)
[17:40:42.838]                             muffled <- TRUE
[17:40:42.838]                             break
[17:40:42.838]                           }
[17:40:42.838]                         }
[17:40:42.838]                       }
[17:40:42.838]                       invisible(muffled)
[17:40:42.838]                     }
[17:40:42.838]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.838]                   }
[17:40:42.838]                 }
[17:40:42.838]             }
[17:40:42.838]         }))
[17:40:42.838]     }, error = function(ex) {
[17:40:42.838]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.838]                 ...future.rng), started = ...future.startTime, 
[17:40:42.838]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.838]             version = "1.8"), class = "FutureResult")
[17:40:42.838]     }, finally = {
[17:40:42.838]         if (!identical(...future.workdir, getwd())) 
[17:40:42.838]             setwd(...future.workdir)
[17:40:42.838]         {
[17:40:42.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.838]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.838]             }
[17:40:42.838]             base::options(...future.oldOptions)
[17:40:42.838]             if (.Platform$OS.type == "windows") {
[17:40:42.838]                 old_names <- names(...future.oldEnvVars)
[17:40:42.838]                 envs <- base::Sys.getenv()
[17:40:42.838]                 names <- names(envs)
[17:40:42.838]                 common <- intersect(names, old_names)
[17:40:42.838]                 added <- setdiff(names, old_names)
[17:40:42.838]                 removed <- setdiff(old_names, names)
[17:40:42.838]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.838]                   envs[common]]
[17:40:42.838]                 NAMES <- toupper(changed)
[17:40:42.838]                 args <- list()
[17:40:42.838]                 for (kk in seq_along(NAMES)) {
[17:40:42.838]                   name <- changed[[kk]]
[17:40:42.838]                   NAME <- NAMES[[kk]]
[17:40:42.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.838]                     next
[17:40:42.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.838]                 }
[17:40:42.838]                 NAMES <- toupper(added)
[17:40:42.838]                 for (kk in seq_along(NAMES)) {
[17:40:42.838]                   name <- added[[kk]]
[17:40:42.838]                   NAME <- NAMES[[kk]]
[17:40:42.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.838]                     next
[17:40:42.838]                   args[[name]] <- ""
[17:40:42.838]                 }
[17:40:42.838]                 NAMES <- toupper(removed)
[17:40:42.838]                 for (kk in seq_along(NAMES)) {
[17:40:42.838]                   name <- removed[[kk]]
[17:40:42.838]                   NAME <- NAMES[[kk]]
[17:40:42.838]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.838]                     next
[17:40:42.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.838]                 }
[17:40:42.838]                 if (length(args) > 0) 
[17:40:42.838]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.838]             }
[17:40:42.838]             else {
[17:40:42.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.838]             }
[17:40:42.838]             {
[17:40:42.838]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.838]                   0L) {
[17:40:42.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.838]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.838]                   base::options(opts)
[17:40:42.838]                 }
[17:40:42.838]                 {
[17:40:42.838]                   {
[17:40:42.838]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.838]                     NULL
[17:40:42.838]                   }
[17:40:42.838]                   options(future.plan = NULL)
[17:40:42.838]                   if (is.na(NA_character_)) 
[17:40:42.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.838]                     .init = FALSE)
[17:40:42.838]                 }
[17:40:42.838]             }
[17:40:42.838]         }
[17:40:42.838]     })
[17:40:42.838]     if (TRUE) {
[17:40:42.838]         base::sink(type = "output", split = FALSE)
[17:40:42.838]         if (TRUE) {
[17:40:42.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.838]         }
[17:40:42.838]         else {
[17:40:42.838]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.838]         }
[17:40:42.838]         base::close(...future.stdout)
[17:40:42.838]         ...future.stdout <- NULL
[17:40:42.838]     }
[17:40:42.838]     ...future.result$conditions <- ...future.conditions
[17:40:42.838]     ...future.result$finished <- base::Sys.time()
[17:40:42.838]     ...future.result
[17:40:42.838] }
[17:40:42.842] requestCore(): workers = 2
[17:40:42.842] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.853] result() for MulticoreFuture ...
[17:40:42.854] result() for MulticoreFuture ...
[17:40:42.854] result() for MulticoreFuture ... done
[17:40:42.854] result() for MulticoreFuture ... done
[17:40:42.854] result() for MulticoreFuture ...
[17:40:42.854] result() for MulticoreFuture ... done
[17:40:42.857] MulticoreFuture started
[17:40:42.857] - Launch lazy future ... done
[17:40:42.857] run() for ‘MulticoreFuture’ ... done
[17:40:42.858] plan(): Setting new future strategy stack:
[17:40:42.858] List of future strategies:
[17:40:42.858] 1. sequential:
[17:40:42.858]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.858]    - tweaked: FALSE
[17:40:42.858]    - call: NULL
[17:40:42.860] plan(): nbrOfWorkers() = 1
[17:40:42.862] plan(): Setting new future strategy stack:
[17:40:42.862] List of future strategies:
[17:40:42.862] 1. multicore:
[17:40:42.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.862]    - tweaked: FALSE
[17:40:42.862]    - call: plan(strategy)
[17:40:42.867] plan(): nbrOfWorkers() = 2
[17:40:42.868] Future #1
[17:40:42.868]  length: 2 (resolved future 1)
[17:40:42.868] run() for ‘Future’ ...
[17:40:42.869] - state: ‘created’
[17:40:42.869] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.874] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.874]   - Field: ‘label’
[17:40:42.874]   - Field: ‘local’
[17:40:42.875]   - Field: ‘owner’
[17:40:42.875]   - Field: ‘envir’
[17:40:42.875]   - Field: ‘workers’
[17:40:42.875]   - Field: ‘packages’
[17:40:42.875]   - Field: ‘gc’
[17:40:42.875]   - Field: ‘job’
[17:40:42.875]   - Field: ‘conditions’
[17:40:42.876]   - Field: ‘expr’
[17:40:42.876]   - Field: ‘uuid’
[17:40:42.876]   - Field: ‘seed’
[17:40:42.876]   - Field: ‘version’
[17:40:42.876]   - Field: ‘result’
[17:40:42.876]   - Field: ‘asynchronous’
[17:40:42.876]   - Field: ‘calls’
[17:40:42.877]   - Field: ‘globals’
[17:40:42.877]   - Field: ‘stdout’
[17:40:42.877]   - Field: ‘earlySignal’
[17:40:42.877]   - Field: ‘lazy’
[17:40:42.877]   - Field: ‘state’
[17:40:42.877] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.877] - Launch lazy future ...
[17:40:42.878] Packages needed by the future expression (n = 0): <none>
[17:40:42.878] Packages needed by future strategies (n = 0): <none>
[17:40:42.879] {
[17:40:42.879]     {
[17:40:42.879]         {
[17:40:42.879]             ...future.startTime <- base::Sys.time()
[17:40:42.879]             {
[17:40:42.879]                 {
[17:40:42.879]                   {
[17:40:42.879]                     {
[17:40:42.879]                       base::local({
[17:40:42.879]                         has_future <- base::requireNamespace("future", 
[17:40:42.879]                           quietly = TRUE)
[17:40:42.879]                         if (has_future) {
[17:40:42.879]                           ns <- base::getNamespace("future")
[17:40:42.879]                           version <- ns[[".package"]][["version"]]
[17:40:42.879]                           if (is.null(version)) 
[17:40:42.879]                             version <- utils::packageVersion("future")
[17:40:42.879]                         }
[17:40:42.879]                         else {
[17:40:42.879]                           version <- NULL
[17:40:42.879]                         }
[17:40:42.879]                         if (!has_future || version < "1.8.0") {
[17:40:42.879]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.879]                             "", base::R.version$version.string), 
[17:40:42.879]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.879]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.879]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.879]                               "release", "version")], collapse = " "), 
[17:40:42.879]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.879]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.879]                             info)
[17:40:42.879]                           info <- base::paste(info, collapse = "; ")
[17:40:42.879]                           if (!has_future) {
[17:40:42.879]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.879]                               info)
[17:40:42.879]                           }
[17:40:42.879]                           else {
[17:40:42.879]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.879]                               info, version)
[17:40:42.879]                           }
[17:40:42.879]                           base::stop(msg)
[17:40:42.879]                         }
[17:40:42.879]                       })
[17:40:42.879]                     }
[17:40:42.879]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.879]                     base::options(mc.cores = 1L)
[17:40:42.879]                   }
[17:40:42.879]                   ...future.strategy.old <- future::plan("list")
[17:40:42.879]                   options(future.plan = NULL)
[17:40:42.879]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.879]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.879]                 }
[17:40:42.879]                 ...future.workdir <- getwd()
[17:40:42.879]             }
[17:40:42.879]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.879]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.879]         }
[17:40:42.879]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.879]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.879]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.879]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.879]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.879]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.879]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.879]             base::names(...future.oldOptions))
[17:40:42.879]     }
[17:40:42.879]     if (FALSE) {
[17:40:42.879]     }
[17:40:42.879]     else {
[17:40:42.879]         if (TRUE) {
[17:40:42.879]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.879]                 open = "w")
[17:40:42.879]         }
[17:40:42.879]         else {
[17:40:42.879]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.879]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.879]         }
[17:40:42.879]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.879]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.879]             base::sink(type = "output", split = FALSE)
[17:40:42.879]             base::close(...future.stdout)
[17:40:42.879]         }, add = TRUE)
[17:40:42.879]     }
[17:40:42.879]     ...future.frame <- base::sys.nframe()
[17:40:42.879]     ...future.conditions <- base::list()
[17:40:42.879]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.879]     if (FALSE) {
[17:40:42.879]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.879]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.879]     }
[17:40:42.879]     ...future.result <- base::tryCatch({
[17:40:42.879]         base::withCallingHandlers({
[17:40:42.879]             ...future.value <- base::withVisible(base::local({
[17:40:42.879]                 withCallingHandlers({
[17:40:42.879]                   2
[17:40:42.879]                 }, immediateCondition = function(cond) {
[17:40:42.879]                   save_rds <- function (object, pathname, ...) 
[17:40:42.879]                   {
[17:40:42.879]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.879]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.879]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.879]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.879]                         fi_tmp[["mtime"]])
[17:40:42.879]                     }
[17:40:42.879]                     tryCatch({
[17:40:42.879]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.879]                     }, error = function(ex) {
[17:40:42.879]                       msg <- conditionMessage(ex)
[17:40:42.879]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.879]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.879]                         fi_tmp[["mtime"]], msg)
[17:40:42.879]                       ex$message <- msg
[17:40:42.879]                       stop(ex)
[17:40:42.879]                     })
[17:40:42.879]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.879]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.879]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.879]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.879]                       fi <- file.info(pathname)
[17:40:42.879]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.879]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.879]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.879]                         fi[["size"]], fi[["mtime"]])
[17:40:42.879]                       stop(msg)
[17:40:42.879]                     }
[17:40:42.879]                     invisible(pathname)
[17:40:42.879]                   }
[17:40:42.879]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.879]                     rootPath = tempdir()) 
[17:40:42.879]                   {
[17:40:42.879]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.879]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.879]                       tmpdir = path, fileext = ".rds")
[17:40:42.879]                     save_rds(obj, file)
[17:40:42.879]                   }
[17:40:42.879]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.879]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.879]                   {
[17:40:42.879]                     inherits <- base::inherits
[17:40:42.879]                     invokeRestart <- base::invokeRestart
[17:40:42.879]                     is.null <- base::is.null
[17:40:42.879]                     muffled <- FALSE
[17:40:42.879]                     if (inherits(cond, "message")) {
[17:40:42.879]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.879]                       if (muffled) 
[17:40:42.879]                         invokeRestart("muffleMessage")
[17:40:42.879]                     }
[17:40:42.879]                     else if (inherits(cond, "warning")) {
[17:40:42.879]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.879]                       if (muffled) 
[17:40:42.879]                         invokeRestart("muffleWarning")
[17:40:42.879]                     }
[17:40:42.879]                     else if (inherits(cond, "condition")) {
[17:40:42.879]                       if (!is.null(pattern)) {
[17:40:42.879]                         computeRestarts <- base::computeRestarts
[17:40:42.879]                         grepl <- base::grepl
[17:40:42.879]                         restarts <- computeRestarts(cond)
[17:40:42.879]                         for (restart in restarts) {
[17:40:42.879]                           name <- restart$name
[17:40:42.879]                           if (is.null(name)) 
[17:40:42.879]                             next
[17:40:42.879]                           if (!grepl(pattern, name)) 
[17:40:42.879]                             next
[17:40:42.879]                           invokeRestart(restart)
[17:40:42.879]                           muffled <- TRUE
[17:40:42.879]                           break
[17:40:42.879]                         }
[17:40:42.879]                       }
[17:40:42.879]                     }
[17:40:42.879]                     invisible(muffled)
[17:40:42.879]                   }
[17:40:42.879]                   muffleCondition(cond)
[17:40:42.879]                 })
[17:40:42.879]             }))
[17:40:42.879]             future::FutureResult(value = ...future.value$value, 
[17:40:42.879]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.879]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.879]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.879]                     ...future.globalenv.names))
[17:40:42.879]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.879]         }, condition = base::local({
[17:40:42.879]             c <- base::c
[17:40:42.879]             inherits <- base::inherits
[17:40:42.879]             invokeRestart <- base::invokeRestart
[17:40:42.879]             length <- base::length
[17:40:42.879]             list <- base::list
[17:40:42.879]             seq.int <- base::seq.int
[17:40:42.879]             signalCondition <- base::signalCondition
[17:40:42.879]             sys.calls <- base::sys.calls
[17:40:42.879]             `[[` <- base::`[[`
[17:40:42.879]             `+` <- base::`+`
[17:40:42.879]             `<<-` <- base::`<<-`
[17:40:42.879]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.879]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.879]                   3L)]
[17:40:42.879]             }
[17:40:42.879]             function(cond) {
[17:40:42.879]                 is_error <- inherits(cond, "error")
[17:40:42.879]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.879]                   NULL)
[17:40:42.879]                 if (is_error) {
[17:40:42.879]                   sessionInformation <- function() {
[17:40:42.879]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.879]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.879]                       search = base::search(), system = base::Sys.info())
[17:40:42.879]                   }
[17:40:42.879]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.879]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.879]                     cond$call), session = sessionInformation(), 
[17:40:42.879]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.879]                   signalCondition(cond)
[17:40:42.879]                 }
[17:40:42.879]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.879]                 "immediateCondition"))) {
[17:40:42.879]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.879]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.879]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.879]                   if (TRUE && !signal) {
[17:40:42.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.879]                     {
[17:40:42.879]                       inherits <- base::inherits
[17:40:42.879]                       invokeRestart <- base::invokeRestart
[17:40:42.879]                       is.null <- base::is.null
[17:40:42.879]                       muffled <- FALSE
[17:40:42.879]                       if (inherits(cond, "message")) {
[17:40:42.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.879]                         if (muffled) 
[17:40:42.879]                           invokeRestart("muffleMessage")
[17:40:42.879]                       }
[17:40:42.879]                       else if (inherits(cond, "warning")) {
[17:40:42.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.879]                         if (muffled) 
[17:40:42.879]                           invokeRestart("muffleWarning")
[17:40:42.879]                       }
[17:40:42.879]                       else if (inherits(cond, "condition")) {
[17:40:42.879]                         if (!is.null(pattern)) {
[17:40:42.879]                           computeRestarts <- base::computeRestarts
[17:40:42.879]                           grepl <- base::grepl
[17:40:42.879]                           restarts <- computeRestarts(cond)
[17:40:42.879]                           for (restart in restarts) {
[17:40:42.879]                             name <- restart$name
[17:40:42.879]                             if (is.null(name)) 
[17:40:42.879]                               next
[17:40:42.879]                             if (!grepl(pattern, name)) 
[17:40:42.879]                               next
[17:40:42.879]                             invokeRestart(restart)
[17:40:42.879]                             muffled <- TRUE
[17:40:42.879]                             break
[17:40:42.879]                           }
[17:40:42.879]                         }
[17:40:42.879]                       }
[17:40:42.879]                       invisible(muffled)
[17:40:42.879]                     }
[17:40:42.879]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.879]                   }
[17:40:42.879]                 }
[17:40:42.879]                 else {
[17:40:42.879]                   if (TRUE) {
[17:40:42.879]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.879]                     {
[17:40:42.879]                       inherits <- base::inherits
[17:40:42.879]                       invokeRestart <- base::invokeRestart
[17:40:42.879]                       is.null <- base::is.null
[17:40:42.879]                       muffled <- FALSE
[17:40:42.879]                       if (inherits(cond, "message")) {
[17:40:42.879]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.879]                         if (muffled) 
[17:40:42.879]                           invokeRestart("muffleMessage")
[17:40:42.879]                       }
[17:40:42.879]                       else if (inherits(cond, "warning")) {
[17:40:42.879]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.879]                         if (muffled) 
[17:40:42.879]                           invokeRestart("muffleWarning")
[17:40:42.879]                       }
[17:40:42.879]                       else if (inherits(cond, "condition")) {
[17:40:42.879]                         if (!is.null(pattern)) {
[17:40:42.879]                           computeRestarts <- base::computeRestarts
[17:40:42.879]                           grepl <- base::grepl
[17:40:42.879]                           restarts <- computeRestarts(cond)
[17:40:42.879]                           for (restart in restarts) {
[17:40:42.879]                             name <- restart$name
[17:40:42.879]                             if (is.null(name)) 
[17:40:42.879]                               next
[17:40:42.879]                             if (!grepl(pattern, name)) 
[17:40:42.879]                               next
[17:40:42.879]                             invokeRestart(restart)
[17:40:42.879]                             muffled <- TRUE
[17:40:42.879]                             break
[17:40:42.879]                           }
[17:40:42.879]                         }
[17:40:42.879]                       }
[17:40:42.879]                       invisible(muffled)
[17:40:42.879]                     }
[17:40:42.879]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.879]                   }
[17:40:42.879]                 }
[17:40:42.879]             }
[17:40:42.879]         }))
[17:40:42.879]     }, error = function(ex) {
[17:40:42.879]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.879]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.879]                 ...future.rng), started = ...future.startTime, 
[17:40:42.879]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.879]             version = "1.8"), class = "FutureResult")
[17:40:42.879]     }, finally = {
[17:40:42.879]         if (!identical(...future.workdir, getwd())) 
[17:40:42.879]             setwd(...future.workdir)
[17:40:42.879]         {
[17:40:42.879]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.879]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.879]             }
[17:40:42.879]             base::options(...future.oldOptions)
[17:40:42.879]             if (.Platform$OS.type == "windows") {
[17:40:42.879]                 old_names <- names(...future.oldEnvVars)
[17:40:42.879]                 envs <- base::Sys.getenv()
[17:40:42.879]                 names <- names(envs)
[17:40:42.879]                 common <- intersect(names, old_names)
[17:40:42.879]                 added <- setdiff(names, old_names)
[17:40:42.879]                 removed <- setdiff(old_names, names)
[17:40:42.879]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.879]                   envs[common]]
[17:40:42.879]                 NAMES <- toupper(changed)
[17:40:42.879]                 args <- list()
[17:40:42.879]                 for (kk in seq_along(NAMES)) {
[17:40:42.879]                   name <- changed[[kk]]
[17:40:42.879]                   NAME <- NAMES[[kk]]
[17:40:42.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.879]                     next
[17:40:42.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.879]                 }
[17:40:42.879]                 NAMES <- toupper(added)
[17:40:42.879]                 for (kk in seq_along(NAMES)) {
[17:40:42.879]                   name <- added[[kk]]
[17:40:42.879]                   NAME <- NAMES[[kk]]
[17:40:42.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.879]                     next
[17:40:42.879]                   args[[name]] <- ""
[17:40:42.879]                 }
[17:40:42.879]                 NAMES <- toupper(removed)
[17:40:42.879]                 for (kk in seq_along(NAMES)) {
[17:40:42.879]                   name <- removed[[kk]]
[17:40:42.879]                   NAME <- NAMES[[kk]]
[17:40:42.879]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.879]                     next
[17:40:42.879]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.879]                 }
[17:40:42.879]                 if (length(args) > 0) 
[17:40:42.879]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.879]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.879]             }
[17:40:42.879]             else {
[17:40:42.879]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.879]             }
[17:40:42.879]             {
[17:40:42.879]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.879]                   0L) {
[17:40:42.879]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.879]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.879]                   base::options(opts)
[17:40:42.879]                 }
[17:40:42.879]                 {
[17:40:42.879]                   {
[17:40:42.879]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.879]                     NULL
[17:40:42.879]                   }
[17:40:42.879]                   options(future.plan = NULL)
[17:40:42.879]                   if (is.na(NA_character_)) 
[17:40:42.879]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.879]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.879]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.879]                     .init = FALSE)
[17:40:42.879]                 }
[17:40:42.879]             }
[17:40:42.879]         }
[17:40:42.879]     })
[17:40:42.879]     if (TRUE) {
[17:40:42.879]         base::sink(type = "output", split = FALSE)
[17:40:42.879]         if (TRUE) {
[17:40:42.879]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.879]         }
[17:40:42.879]         else {
[17:40:42.879]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.879]         }
[17:40:42.879]         base::close(...future.stdout)
[17:40:42.879]         ...future.stdout <- NULL
[17:40:42.879]     }
[17:40:42.879]     ...future.result$conditions <- ...future.conditions
[17:40:42.879]     ...future.result$finished <- base::Sys.time()
[17:40:42.879]     ...future.result
[17:40:42.879] }
[17:40:42.882] requestCore(): workers = 2
[17:40:42.883] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.894] result() for MulticoreFuture ...
[17:40:42.895] result() for MulticoreFuture ...
[17:40:42.895] result() for MulticoreFuture ... done
[17:40:42.895] result() for MulticoreFuture ... done
[17:40:42.895] result() for MulticoreFuture ...
[17:40:42.895] result() for MulticoreFuture ... done
[17:40:42.898] MulticoreFuture started
[17:40:42.899] - Launch lazy future ... done
[17:40:42.899] run() for ‘MulticoreFuture’ ... done
[17:40:42.899] plan(): Setting new future strategy stack:
[17:40:42.899] List of future strategies:
[17:40:42.899] 1. sequential:
[17:40:42.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.899]    - tweaked: FALSE
[17:40:42.899]    - call: NULL
[17:40:42.901] plan(): nbrOfWorkers() = 1
[17:40:42.903] plan(): Setting new future strategy stack:
[17:40:42.903] List of future strategies:
[17:40:42.903] 1. multicore:
[17:40:42.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.903]    - tweaked: FALSE
[17:40:42.903]    - call: plan(strategy)
[17:40:42.908] plan(): nbrOfWorkers() = 2
[17:40:42.909] Future #2
[17:40:42.909]  length: 1 (resolved future 2)
[17:40:42.910]  length: 0 (resolved future 3)
[17:40:42.910] resolve() on list ... DONE
[17:40:42.910] getGlobalsAndPackages() ...
[17:40:42.911] Searching for globals...
[17:40:42.911] 
[17:40:42.911] Searching for globals ... DONE
[17:40:42.912] - globals: [0] <none>
[17:40:42.912] getGlobalsAndPackages() ... DONE
[17:40:42.912] run() for ‘Future’ ...
[17:40:42.912] - state: ‘created’
[17:40:42.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.918]   - Field: ‘label’
[17:40:42.918]   - Field: ‘local’
[17:40:42.918]   - Field: ‘owner’
[17:40:42.918]   - Field: ‘envir’
[17:40:42.918]   - Field: ‘workers’
[17:40:42.918]   - Field: ‘packages’
[17:40:42.919]   - Field: ‘gc’
[17:40:42.919]   - Field: ‘job’
[17:40:42.919]   - Field: ‘conditions’
[17:40:42.919]   - Field: ‘expr’
[17:40:42.919]   - Field: ‘uuid’
[17:40:42.919]   - Field: ‘seed’
[17:40:42.920]   - Field: ‘version’
[17:40:42.920]   - Field: ‘result’
[17:40:42.920]   - Field: ‘asynchronous’
[17:40:42.920]   - Field: ‘calls’
[17:40:42.920]   - Field: ‘globals’
[17:40:42.920]   - Field: ‘stdout’
[17:40:42.920]   - Field: ‘earlySignal’
[17:40:42.921]   - Field: ‘lazy’
[17:40:42.921]   - Field: ‘state’
[17:40:42.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.921] - Launch lazy future ...
[17:40:42.922] Packages needed by the future expression (n = 0): <none>
[17:40:42.922] Packages needed by future strategies (n = 0): <none>
[17:40:42.927] {
[17:40:42.927]     {
[17:40:42.927]         {
[17:40:42.927]             ...future.startTime <- base::Sys.time()
[17:40:42.927]             {
[17:40:42.927]                 {
[17:40:42.927]                   {
[17:40:42.927]                     {
[17:40:42.927]                       base::local({
[17:40:42.927]                         has_future <- base::requireNamespace("future", 
[17:40:42.927]                           quietly = TRUE)
[17:40:42.927]                         if (has_future) {
[17:40:42.927]                           ns <- base::getNamespace("future")
[17:40:42.927]                           version <- ns[[".package"]][["version"]]
[17:40:42.927]                           if (is.null(version)) 
[17:40:42.927]                             version <- utils::packageVersion("future")
[17:40:42.927]                         }
[17:40:42.927]                         else {
[17:40:42.927]                           version <- NULL
[17:40:42.927]                         }
[17:40:42.927]                         if (!has_future || version < "1.8.0") {
[17:40:42.927]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.927]                             "", base::R.version$version.string), 
[17:40:42.927]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.927]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.927]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.927]                               "release", "version")], collapse = " "), 
[17:40:42.927]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.927]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.927]                             info)
[17:40:42.927]                           info <- base::paste(info, collapse = "; ")
[17:40:42.927]                           if (!has_future) {
[17:40:42.927]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.927]                               info)
[17:40:42.927]                           }
[17:40:42.927]                           else {
[17:40:42.927]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.927]                               info, version)
[17:40:42.927]                           }
[17:40:42.927]                           base::stop(msg)
[17:40:42.927]                         }
[17:40:42.927]                       })
[17:40:42.927]                     }
[17:40:42.927]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.927]                     base::options(mc.cores = 1L)
[17:40:42.927]                   }
[17:40:42.927]                   ...future.strategy.old <- future::plan("list")
[17:40:42.927]                   options(future.plan = NULL)
[17:40:42.927]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.927]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.927]                 }
[17:40:42.927]                 ...future.workdir <- getwd()
[17:40:42.927]             }
[17:40:42.927]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.927]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.927]         }
[17:40:42.927]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.927]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.927]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.927]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.927]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.927]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.927]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.927]             base::names(...future.oldOptions))
[17:40:42.927]     }
[17:40:42.927]     if (FALSE) {
[17:40:42.927]     }
[17:40:42.927]     else {
[17:40:42.927]         if (TRUE) {
[17:40:42.927]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.927]                 open = "w")
[17:40:42.927]         }
[17:40:42.927]         else {
[17:40:42.927]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.927]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.927]         }
[17:40:42.927]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.927]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.927]             base::sink(type = "output", split = FALSE)
[17:40:42.927]             base::close(...future.stdout)
[17:40:42.927]         }, add = TRUE)
[17:40:42.927]     }
[17:40:42.927]     ...future.frame <- base::sys.nframe()
[17:40:42.927]     ...future.conditions <- base::list()
[17:40:42.927]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.927]     if (FALSE) {
[17:40:42.927]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.927]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.927]     }
[17:40:42.927]     ...future.result <- base::tryCatch({
[17:40:42.927]         base::withCallingHandlers({
[17:40:42.927]             ...future.value <- base::withVisible(base::local({
[17:40:42.927]                 withCallingHandlers({
[17:40:42.927]                   1
[17:40:42.927]                 }, immediateCondition = function(cond) {
[17:40:42.927]                   save_rds <- function (object, pathname, ...) 
[17:40:42.927]                   {
[17:40:42.927]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.927]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.927]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.927]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.927]                         fi_tmp[["mtime"]])
[17:40:42.927]                     }
[17:40:42.927]                     tryCatch({
[17:40:42.927]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.927]                     }, error = function(ex) {
[17:40:42.927]                       msg <- conditionMessage(ex)
[17:40:42.927]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.927]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.927]                         fi_tmp[["mtime"]], msg)
[17:40:42.927]                       ex$message <- msg
[17:40:42.927]                       stop(ex)
[17:40:42.927]                     })
[17:40:42.927]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.927]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.927]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.927]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.927]                       fi <- file.info(pathname)
[17:40:42.927]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.927]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.927]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.927]                         fi[["size"]], fi[["mtime"]])
[17:40:42.927]                       stop(msg)
[17:40:42.927]                     }
[17:40:42.927]                     invisible(pathname)
[17:40:42.927]                   }
[17:40:42.927]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.927]                     rootPath = tempdir()) 
[17:40:42.927]                   {
[17:40:42.927]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.927]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.927]                       tmpdir = path, fileext = ".rds")
[17:40:42.927]                     save_rds(obj, file)
[17:40:42.927]                   }
[17:40:42.927]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.927]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.927]                   {
[17:40:42.927]                     inherits <- base::inherits
[17:40:42.927]                     invokeRestart <- base::invokeRestart
[17:40:42.927]                     is.null <- base::is.null
[17:40:42.927]                     muffled <- FALSE
[17:40:42.927]                     if (inherits(cond, "message")) {
[17:40:42.927]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.927]                       if (muffled) 
[17:40:42.927]                         invokeRestart("muffleMessage")
[17:40:42.927]                     }
[17:40:42.927]                     else if (inherits(cond, "warning")) {
[17:40:42.927]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.927]                       if (muffled) 
[17:40:42.927]                         invokeRestart("muffleWarning")
[17:40:42.927]                     }
[17:40:42.927]                     else if (inherits(cond, "condition")) {
[17:40:42.927]                       if (!is.null(pattern)) {
[17:40:42.927]                         computeRestarts <- base::computeRestarts
[17:40:42.927]                         grepl <- base::grepl
[17:40:42.927]                         restarts <- computeRestarts(cond)
[17:40:42.927]                         for (restart in restarts) {
[17:40:42.927]                           name <- restart$name
[17:40:42.927]                           if (is.null(name)) 
[17:40:42.927]                             next
[17:40:42.927]                           if (!grepl(pattern, name)) 
[17:40:42.927]                             next
[17:40:42.927]                           invokeRestart(restart)
[17:40:42.927]                           muffled <- TRUE
[17:40:42.927]                           break
[17:40:42.927]                         }
[17:40:42.927]                       }
[17:40:42.927]                     }
[17:40:42.927]                     invisible(muffled)
[17:40:42.927]                   }
[17:40:42.927]                   muffleCondition(cond)
[17:40:42.927]                 })
[17:40:42.927]             }))
[17:40:42.927]             future::FutureResult(value = ...future.value$value, 
[17:40:42.927]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.927]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.927]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.927]                     ...future.globalenv.names))
[17:40:42.927]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.927]         }, condition = base::local({
[17:40:42.927]             c <- base::c
[17:40:42.927]             inherits <- base::inherits
[17:40:42.927]             invokeRestart <- base::invokeRestart
[17:40:42.927]             length <- base::length
[17:40:42.927]             list <- base::list
[17:40:42.927]             seq.int <- base::seq.int
[17:40:42.927]             signalCondition <- base::signalCondition
[17:40:42.927]             sys.calls <- base::sys.calls
[17:40:42.927]             `[[` <- base::`[[`
[17:40:42.927]             `+` <- base::`+`
[17:40:42.927]             `<<-` <- base::`<<-`
[17:40:42.927]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.927]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.927]                   3L)]
[17:40:42.927]             }
[17:40:42.927]             function(cond) {
[17:40:42.927]                 is_error <- inherits(cond, "error")
[17:40:42.927]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.927]                   NULL)
[17:40:42.927]                 if (is_error) {
[17:40:42.927]                   sessionInformation <- function() {
[17:40:42.927]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.927]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.927]                       search = base::search(), system = base::Sys.info())
[17:40:42.927]                   }
[17:40:42.927]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.927]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.927]                     cond$call), session = sessionInformation(), 
[17:40:42.927]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.927]                   signalCondition(cond)
[17:40:42.927]                 }
[17:40:42.927]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.927]                 "immediateCondition"))) {
[17:40:42.927]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.927]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.927]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.927]                   if (TRUE && !signal) {
[17:40:42.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.927]                     {
[17:40:42.927]                       inherits <- base::inherits
[17:40:42.927]                       invokeRestart <- base::invokeRestart
[17:40:42.927]                       is.null <- base::is.null
[17:40:42.927]                       muffled <- FALSE
[17:40:42.927]                       if (inherits(cond, "message")) {
[17:40:42.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.927]                         if (muffled) 
[17:40:42.927]                           invokeRestart("muffleMessage")
[17:40:42.927]                       }
[17:40:42.927]                       else if (inherits(cond, "warning")) {
[17:40:42.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.927]                         if (muffled) 
[17:40:42.927]                           invokeRestart("muffleWarning")
[17:40:42.927]                       }
[17:40:42.927]                       else if (inherits(cond, "condition")) {
[17:40:42.927]                         if (!is.null(pattern)) {
[17:40:42.927]                           computeRestarts <- base::computeRestarts
[17:40:42.927]                           grepl <- base::grepl
[17:40:42.927]                           restarts <- computeRestarts(cond)
[17:40:42.927]                           for (restart in restarts) {
[17:40:42.927]                             name <- restart$name
[17:40:42.927]                             if (is.null(name)) 
[17:40:42.927]                               next
[17:40:42.927]                             if (!grepl(pattern, name)) 
[17:40:42.927]                               next
[17:40:42.927]                             invokeRestart(restart)
[17:40:42.927]                             muffled <- TRUE
[17:40:42.927]                             break
[17:40:42.927]                           }
[17:40:42.927]                         }
[17:40:42.927]                       }
[17:40:42.927]                       invisible(muffled)
[17:40:42.927]                     }
[17:40:42.927]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.927]                   }
[17:40:42.927]                 }
[17:40:42.927]                 else {
[17:40:42.927]                   if (TRUE) {
[17:40:42.927]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.927]                     {
[17:40:42.927]                       inherits <- base::inherits
[17:40:42.927]                       invokeRestart <- base::invokeRestart
[17:40:42.927]                       is.null <- base::is.null
[17:40:42.927]                       muffled <- FALSE
[17:40:42.927]                       if (inherits(cond, "message")) {
[17:40:42.927]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.927]                         if (muffled) 
[17:40:42.927]                           invokeRestart("muffleMessage")
[17:40:42.927]                       }
[17:40:42.927]                       else if (inherits(cond, "warning")) {
[17:40:42.927]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.927]                         if (muffled) 
[17:40:42.927]                           invokeRestart("muffleWarning")
[17:40:42.927]                       }
[17:40:42.927]                       else if (inherits(cond, "condition")) {
[17:40:42.927]                         if (!is.null(pattern)) {
[17:40:42.927]                           computeRestarts <- base::computeRestarts
[17:40:42.927]                           grepl <- base::grepl
[17:40:42.927]                           restarts <- computeRestarts(cond)
[17:40:42.927]                           for (restart in restarts) {
[17:40:42.927]                             name <- restart$name
[17:40:42.927]                             if (is.null(name)) 
[17:40:42.927]                               next
[17:40:42.927]                             if (!grepl(pattern, name)) 
[17:40:42.927]                               next
[17:40:42.927]                             invokeRestart(restart)
[17:40:42.927]                             muffled <- TRUE
[17:40:42.927]                             break
[17:40:42.927]                           }
[17:40:42.927]                         }
[17:40:42.927]                       }
[17:40:42.927]                       invisible(muffled)
[17:40:42.927]                     }
[17:40:42.927]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.927]                   }
[17:40:42.927]                 }
[17:40:42.927]             }
[17:40:42.927]         }))
[17:40:42.927]     }, error = function(ex) {
[17:40:42.927]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.927]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.927]                 ...future.rng), started = ...future.startTime, 
[17:40:42.927]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.927]             version = "1.8"), class = "FutureResult")
[17:40:42.927]     }, finally = {
[17:40:42.927]         if (!identical(...future.workdir, getwd())) 
[17:40:42.927]             setwd(...future.workdir)
[17:40:42.927]         {
[17:40:42.927]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.927]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.927]             }
[17:40:42.927]             base::options(...future.oldOptions)
[17:40:42.927]             if (.Platform$OS.type == "windows") {
[17:40:42.927]                 old_names <- names(...future.oldEnvVars)
[17:40:42.927]                 envs <- base::Sys.getenv()
[17:40:42.927]                 names <- names(envs)
[17:40:42.927]                 common <- intersect(names, old_names)
[17:40:42.927]                 added <- setdiff(names, old_names)
[17:40:42.927]                 removed <- setdiff(old_names, names)
[17:40:42.927]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.927]                   envs[common]]
[17:40:42.927]                 NAMES <- toupper(changed)
[17:40:42.927]                 args <- list()
[17:40:42.927]                 for (kk in seq_along(NAMES)) {
[17:40:42.927]                   name <- changed[[kk]]
[17:40:42.927]                   NAME <- NAMES[[kk]]
[17:40:42.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.927]                     next
[17:40:42.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.927]                 }
[17:40:42.927]                 NAMES <- toupper(added)
[17:40:42.927]                 for (kk in seq_along(NAMES)) {
[17:40:42.927]                   name <- added[[kk]]
[17:40:42.927]                   NAME <- NAMES[[kk]]
[17:40:42.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.927]                     next
[17:40:42.927]                   args[[name]] <- ""
[17:40:42.927]                 }
[17:40:42.927]                 NAMES <- toupper(removed)
[17:40:42.927]                 for (kk in seq_along(NAMES)) {
[17:40:42.927]                   name <- removed[[kk]]
[17:40:42.927]                   NAME <- NAMES[[kk]]
[17:40:42.927]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.927]                     next
[17:40:42.927]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.927]                 }
[17:40:42.927]                 if (length(args) > 0) 
[17:40:42.927]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.927]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.927]             }
[17:40:42.927]             else {
[17:40:42.927]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.927]             }
[17:40:42.927]             {
[17:40:42.927]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.927]                   0L) {
[17:40:42.927]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.927]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.927]                   base::options(opts)
[17:40:42.927]                 }
[17:40:42.927]                 {
[17:40:42.927]                   {
[17:40:42.927]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.927]                     NULL
[17:40:42.927]                   }
[17:40:42.927]                   options(future.plan = NULL)
[17:40:42.927]                   if (is.na(NA_character_)) 
[17:40:42.927]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.927]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.927]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.927]                     .init = FALSE)
[17:40:42.927]                 }
[17:40:42.927]             }
[17:40:42.927]         }
[17:40:42.927]     })
[17:40:42.927]     if (TRUE) {
[17:40:42.927]         base::sink(type = "output", split = FALSE)
[17:40:42.927]         if (TRUE) {
[17:40:42.927]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.927]         }
[17:40:42.927]         else {
[17:40:42.927]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.927]         }
[17:40:42.927]         base::close(...future.stdout)
[17:40:42.927]         ...future.stdout <- NULL
[17:40:42.927]     }
[17:40:42.927]     ...future.result$conditions <- ...future.conditions
[17:40:42.927]     ...future.result$finished <- base::Sys.time()
[17:40:42.927]     ...future.result
[17:40:42.927] }
[17:40:42.930] requestCore(): workers = 2
[17:40:42.931] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.942] result() for MulticoreFuture ...
[17:40:42.943] result() for MulticoreFuture ...
[17:40:42.943] result() for MulticoreFuture ... done
[17:40:42.944] result() for MulticoreFuture ... done
[17:40:42.944] result() for MulticoreFuture ...
[17:40:42.944] result() for MulticoreFuture ... done
[17:40:42.947] MulticoreFuture started
[17:40:42.947] - Launch lazy future ... done
[17:40:42.947] run() for ‘MulticoreFuture’ ... done
[17:40:42.948] getGlobalsAndPackages() ...
[17:40:42.948] plan(): Setting new future strategy stack:
[17:40:42.948] Searching for globals...
[17:40:42.948] List of future strategies:
[17:40:42.948] 1. sequential:
[17:40:42.948]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.948]    - tweaked: FALSE
[17:40:42.948]    - call: NULL
[17:40:42.950] plan(): nbrOfWorkers() = 1
[17:40:42.951] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:40:42.951] Searching for globals ... DONE
[17:40:42.952] Resolving globals: FALSE
[17:40:42.952] plan(): Setting new future strategy stack:
[17:40:42.952] 
[17:40:42.952] 
[17:40:42.952] List of future strategies:
[17:40:42.952] 1. multicore:
[17:40:42.952]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:42.952]    - tweaked: FALSE
[17:40:42.952]    - call: plan(strategy)
[17:40:42.953] getGlobalsAndPackages() ... DONE
[17:40:42.953] run() for ‘Future’ ...
[17:40:42.953] - state: ‘created’
[17:40:42.953] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:42.957] plan(): nbrOfWorkers() = 2
[17:40:42.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:42.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:42.959]   - Field: ‘label’
[17:40:42.959]   - Field: ‘local’
[17:40:42.959]   - Field: ‘owner’
[17:40:42.960]   - Field: ‘envir’
[17:40:42.960]   - Field: ‘workers’
[17:40:42.960]   - Field: ‘packages’
[17:40:42.960]   - Field: ‘gc’
[17:40:42.960]   - Field: ‘job’
[17:40:42.960]   - Field: ‘conditions’
[17:40:42.960]   - Field: ‘expr’
[17:40:42.961]   - Field: ‘uuid’
[17:40:42.961]   - Field: ‘seed’
[17:40:42.961]   - Field: ‘version’
[17:40:42.961]   - Field: ‘result’
[17:40:42.961]   - Field: ‘asynchronous’
[17:40:42.961]   - Field: ‘calls’
[17:40:42.961]   - Field: ‘globals’
[17:40:42.962]   - Field: ‘stdout’
[17:40:42.962]   - Field: ‘earlySignal’
[17:40:42.962]   - Field: ‘lazy’
[17:40:42.962]   - Field: ‘state’
[17:40:42.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:42.962] - Launch lazy future ...
[17:40:42.963] Packages needed by the future expression (n = 0): <none>
[17:40:42.963] Packages needed by future strategies (n = 0): <none>
[17:40:42.964] {
[17:40:42.964]     {
[17:40:42.964]         {
[17:40:42.964]             ...future.startTime <- base::Sys.time()
[17:40:42.964]             {
[17:40:42.964]                 {
[17:40:42.964]                   {
[17:40:42.964]                     {
[17:40:42.964]                       base::local({
[17:40:42.964]                         has_future <- base::requireNamespace("future", 
[17:40:42.964]                           quietly = TRUE)
[17:40:42.964]                         if (has_future) {
[17:40:42.964]                           ns <- base::getNamespace("future")
[17:40:42.964]                           version <- ns[[".package"]][["version"]]
[17:40:42.964]                           if (is.null(version)) 
[17:40:42.964]                             version <- utils::packageVersion("future")
[17:40:42.964]                         }
[17:40:42.964]                         else {
[17:40:42.964]                           version <- NULL
[17:40:42.964]                         }
[17:40:42.964]                         if (!has_future || version < "1.8.0") {
[17:40:42.964]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:42.964]                             "", base::R.version$version.string), 
[17:40:42.964]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:42.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:42.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:42.964]                               "release", "version")], collapse = " "), 
[17:40:42.964]                             hostname = base::Sys.info()[["nodename"]])
[17:40:42.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:42.964]                             info)
[17:40:42.964]                           info <- base::paste(info, collapse = "; ")
[17:40:42.964]                           if (!has_future) {
[17:40:42.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:42.964]                               info)
[17:40:42.964]                           }
[17:40:42.964]                           else {
[17:40:42.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:42.964]                               info, version)
[17:40:42.964]                           }
[17:40:42.964]                           base::stop(msg)
[17:40:42.964]                         }
[17:40:42.964]                       })
[17:40:42.964]                     }
[17:40:42.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:42.964]                     base::options(mc.cores = 1L)
[17:40:42.964]                   }
[17:40:42.964]                   ...future.strategy.old <- future::plan("list")
[17:40:42.964]                   options(future.plan = NULL)
[17:40:42.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:42.964]                 }
[17:40:42.964]                 ...future.workdir <- getwd()
[17:40:42.964]             }
[17:40:42.964]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:42.964]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:42.964]         }
[17:40:42.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:42.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:42.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:42.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:42.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:42.964]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:42.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:42.964]             base::names(...future.oldOptions))
[17:40:42.964]     }
[17:40:42.964]     if (FALSE) {
[17:40:42.964]     }
[17:40:42.964]     else {
[17:40:42.964]         if (TRUE) {
[17:40:42.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:42.964]                 open = "w")
[17:40:42.964]         }
[17:40:42.964]         else {
[17:40:42.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:42.964]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:42.964]         }
[17:40:42.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:42.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:42.964]             base::sink(type = "output", split = FALSE)
[17:40:42.964]             base::close(...future.stdout)
[17:40:42.964]         }, add = TRUE)
[17:40:42.964]     }
[17:40:42.964]     ...future.frame <- base::sys.nframe()
[17:40:42.964]     ...future.conditions <- base::list()
[17:40:42.964]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:42.964]     if (FALSE) {
[17:40:42.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:42.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:42.964]     }
[17:40:42.964]     ...future.result <- base::tryCatch({
[17:40:42.964]         base::withCallingHandlers({
[17:40:42.964]             ...future.value <- base::withVisible(base::local({
[17:40:42.964]                 withCallingHandlers({
[17:40:42.964]                   {
[17:40:42.964]                     Sys.sleep(0.5)
[17:40:42.964]                     2
[17:40:42.964]                   }
[17:40:42.964]                 }, immediateCondition = function(cond) {
[17:40:42.964]                   save_rds <- function (object, pathname, ...) 
[17:40:42.964]                   {
[17:40:42.964]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:42.964]                     if (file_test("-f", pathname_tmp)) {
[17:40:42.964]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.964]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:42.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.964]                         fi_tmp[["mtime"]])
[17:40:42.964]                     }
[17:40:42.964]                     tryCatch({
[17:40:42.964]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:42.964]                     }, error = function(ex) {
[17:40:42.964]                       msg <- conditionMessage(ex)
[17:40:42.964]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.964]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:42.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.964]                         fi_tmp[["mtime"]], msg)
[17:40:42.964]                       ex$message <- msg
[17:40:42.964]                       stop(ex)
[17:40:42.964]                     })
[17:40:42.964]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:42.964]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:42.964]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:42.964]                       fi_tmp <- file.info(pathname_tmp)
[17:40:42.964]                       fi <- file.info(pathname)
[17:40:42.964]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:42.964]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:42.964]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:42.964]                         fi[["size"]], fi[["mtime"]])
[17:40:42.964]                       stop(msg)
[17:40:42.964]                     }
[17:40:42.964]                     invisible(pathname)
[17:40:42.964]                   }
[17:40:42.964]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:42.964]                     rootPath = tempdir()) 
[17:40:42.964]                   {
[17:40:42.964]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:42.964]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:42.964]                       tmpdir = path, fileext = ".rds")
[17:40:42.964]                     save_rds(obj, file)
[17:40:42.964]                   }
[17:40:42.964]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:42.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.964]                   {
[17:40:42.964]                     inherits <- base::inherits
[17:40:42.964]                     invokeRestart <- base::invokeRestart
[17:40:42.964]                     is.null <- base::is.null
[17:40:42.964]                     muffled <- FALSE
[17:40:42.964]                     if (inherits(cond, "message")) {
[17:40:42.964]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:42.964]                       if (muffled) 
[17:40:42.964]                         invokeRestart("muffleMessage")
[17:40:42.964]                     }
[17:40:42.964]                     else if (inherits(cond, "warning")) {
[17:40:42.964]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:42.964]                       if (muffled) 
[17:40:42.964]                         invokeRestart("muffleWarning")
[17:40:42.964]                     }
[17:40:42.964]                     else if (inherits(cond, "condition")) {
[17:40:42.964]                       if (!is.null(pattern)) {
[17:40:42.964]                         computeRestarts <- base::computeRestarts
[17:40:42.964]                         grepl <- base::grepl
[17:40:42.964]                         restarts <- computeRestarts(cond)
[17:40:42.964]                         for (restart in restarts) {
[17:40:42.964]                           name <- restart$name
[17:40:42.964]                           if (is.null(name)) 
[17:40:42.964]                             next
[17:40:42.964]                           if (!grepl(pattern, name)) 
[17:40:42.964]                             next
[17:40:42.964]                           invokeRestart(restart)
[17:40:42.964]                           muffled <- TRUE
[17:40:42.964]                           break
[17:40:42.964]                         }
[17:40:42.964]                       }
[17:40:42.964]                     }
[17:40:42.964]                     invisible(muffled)
[17:40:42.964]                   }
[17:40:42.964]                   muffleCondition(cond)
[17:40:42.964]                 })
[17:40:42.964]             }))
[17:40:42.964]             future::FutureResult(value = ...future.value$value, 
[17:40:42.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.964]                   ...future.rng), globalenv = if (FALSE) 
[17:40:42.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:42.964]                     ...future.globalenv.names))
[17:40:42.964]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:42.964]         }, condition = base::local({
[17:40:42.964]             c <- base::c
[17:40:42.964]             inherits <- base::inherits
[17:40:42.964]             invokeRestart <- base::invokeRestart
[17:40:42.964]             length <- base::length
[17:40:42.964]             list <- base::list
[17:40:42.964]             seq.int <- base::seq.int
[17:40:42.964]             signalCondition <- base::signalCondition
[17:40:42.964]             sys.calls <- base::sys.calls
[17:40:42.964]             `[[` <- base::`[[`
[17:40:42.964]             `+` <- base::`+`
[17:40:42.964]             `<<-` <- base::`<<-`
[17:40:42.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:42.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:42.964]                   3L)]
[17:40:42.964]             }
[17:40:42.964]             function(cond) {
[17:40:42.964]                 is_error <- inherits(cond, "error")
[17:40:42.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:42.964]                   NULL)
[17:40:42.964]                 if (is_error) {
[17:40:42.964]                   sessionInformation <- function() {
[17:40:42.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:42.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:42.964]                       search = base::search(), system = base::Sys.info())
[17:40:42.964]                   }
[17:40:42.964]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:42.964]                     cond$call), session = sessionInformation(), 
[17:40:42.964]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:42.964]                   signalCondition(cond)
[17:40:42.964]                 }
[17:40:42.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:42.964]                 "immediateCondition"))) {
[17:40:42.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:42.964]                   ...future.conditions[[length(...future.conditions) + 
[17:40:42.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:42.964]                   if (TRUE && !signal) {
[17:40:42.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.964]                     {
[17:40:42.964]                       inherits <- base::inherits
[17:40:42.964]                       invokeRestart <- base::invokeRestart
[17:40:42.964]                       is.null <- base::is.null
[17:40:42.964]                       muffled <- FALSE
[17:40:42.964]                       if (inherits(cond, "message")) {
[17:40:42.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.964]                         if (muffled) 
[17:40:42.964]                           invokeRestart("muffleMessage")
[17:40:42.964]                       }
[17:40:42.964]                       else if (inherits(cond, "warning")) {
[17:40:42.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.964]                         if (muffled) 
[17:40:42.964]                           invokeRestart("muffleWarning")
[17:40:42.964]                       }
[17:40:42.964]                       else if (inherits(cond, "condition")) {
[17:40:42.964]                         if (!is.null(pattern)) {
[17:40:42.964]                           computeRestarts <- base::computeRestarts
[17:40:42.964]                           grepl <- base::grepl
[17:40:42.964]                           restarts <- computeRestarts(cond)
[17:40:42.964]                           for (restart in restarts) {
[17:40:42.964]                             name <- restart$name
[17:40:42.964]                             if (is.null(name)) 
[17:40:42.964]                               next
[17:40:42.964]                             if (!grepl(pattern, name)) 
[17:40:42.964]                               next
[17:40:42.964]                             invokeRestart(restart)
[17:40:42.964]                             muffled <- TRUE
[17:40:42.964]                             break
[17:40:42.964]                           }
[17:40:42.964]                         }
[17:40:42.964]                       }
[17:40:42.964]                       invisible(muffled)
[17:40:42.964]                     }
[17:40:42.964]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.964]                   }
[17:40:42.964]                 }
[17:40:42.964]                 else {
[17:40:42.964]                   if (TRUE) {
[17:40:42.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:42.964]                     {
[17:40:42.964]                       inherits <- base::inherits
[17:40:42.964]                       invokeRestart <- base::invokeRestart
[17:40:42.964]                       is.null <- base::is.null
[17:40:42.964]                       muffled <- FALSE
[17:40:42.964]                       if (inherits(cond, "message")) {
[17:40:42.964]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:42.964]                         if (muffled) 
[17:40:42.964]                           invokeRestart("muffleMessage")
[17:40:42.964]                       }
[17:40:42.964]                       else if (inherits(cond, "warning")) {
[17:40:42.964]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:42.964]                         if (muffled) 
[17:40:42.964]                           invokeRestart("muffleWarning")
[17:40:42.964]                       }
[17:40:42.964]                       else if (inherits(cond, "condition")) {
[17:40:42.964]                         if (!is.null(pattern)) {
[17:40:42.964]                           computeRestarts <- base::computeRestarts
[17:40:42.964]                           grepl <- base::grepl
[17:40:42.964]                           restarts <- computeRestarts(cond)
[17:40:42.964]                           for (restart in restarts) {
[17:40:42.964]                             name <- restart$name
[17:40:42.964]                             if (is.null(name)) 
[17:40:42.964]                               next
[17:40:42.964]                             if (!grepl(pattern, name)) 
[17:40:42.964]                               next
[17:40:42.964]                             invokeRestart(restart)
[17:40:42.964]                             muffled <- TRUE
[17:40:42.964]                             break
[17:40:42.964]                           }
[17:40:42.964]                         }
[17:40:42.964]                       }
[17:40:42.964]                       invisible(muffled)
[17:40:42.964]                     }
[17:40:42.964]                     muffleCondition(cond, pattern = "^muffle")
[17:40:42.964]                   }
[17:40:42.964]                 }
[17:40:42.964]             }
[17:40:42.964]         }))
[17:40:42.964]     }, error = function(ex) {
[17:40:42.964]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:42.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:42.964]                 ...future.rng), started = ...future.startTime, 
[17:40:42.964]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:42.964]             version = "1.8"), class = "FutureResult")
[17:40:42.964]     }, finally = {
[17:40:42.964]         if (!identical(...future.workdir, getwd())) 
[17:40:42.964]             setwd(...future.workdir)
[17:40:42.964]         {
[17:40:42.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:42.964]                 ...future.oldOptions$nwarnings <- NULL
[17:40:42.964]             }
[17:40:42.964]             base::options(...future.oldOptions)
[17:40:42.964]             if (.Platform$OS.type == "windows") {
[17:40:42.964]                 old_names <- names(...future.oldEnvVars)
[17:40:42.964]                 envs <- base::Sys.getenv()
[17:40:42.964]                 names <- names(envs)
[17:40:42.964]                 common <- intersect(names, old_names)
[17:40:42.964]                 added <- setdiff(names, old_names)
[17:40:42.964]                 removed <- setdiff(old_names, names)
[17:40:42.964]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:42.964]                   envs[common]]
[17:40:42.964]                 NAMES <- toupper(changed)
[17:40:42.964]                 args <- list()
[17:40:42.964]                 for (kk in seq_along(NAMES)) {
[17:40:42.964]                   name <- changed[[kk]]
[17:40:42.964]                   NAME <- NAMES[[kk]]
[17:40:42.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.964]                     next
[17:40:42.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.964]                 }
[17:40:42.964]                 NAMES <- toupper(added)
[17:40:42.964]                 for (kk in seq_along(NAMES)) {
[17:40:42.964]                   name <- added[[kk]]
[17:40:42.964]                   NAME <- NAMES[[kk]]
[17:40:42.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.964]                     next
[17:40:42.964]                   args[[name]] <- ""
[17:40:42.964]                 }
[17:40:42.964]                 NAMES <- toupper(removed)
[17:40:42.964]                 for (kk in seq_along(NAMES)) {
[17:40:42.964]                   name <- removed[[kk]]
[17:40:42.964]                   NAME <- NAMES[[kk]]
[17:40:42.964]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:42.964]                     next
[17:40:42.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:42.964]                 }
[17:40:42.964]                 if (length(args) > 0) 
[17:40:42.964]                   base::do.call(base::Sys.setenv, args = args)
[17:40:42.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:42.964]             }
[17:40:42.964]             else {
[17:40:42.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:42.964]             }
[17:40:42.964]             {
[17:40:42.964]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:42.964]                   0L) {
[17:40:42.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:42.964]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:42.964]                   base::options(opts)
[17:40:42.964]                 }
[17:40:42.964]                 {
[17:40:42.964]                   {
[17:40:42.964]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:42.964]                     NULL
[17:40:42.964]                   }
[17:40:42.964]                   options(future.plan = NULL)
[17:40:42.964]                   if (is.na(NA_character_)) 
[17:40:42.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:42.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:42.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:42.964]                     .init = FALSE)
[17:40:42.964]                 }
[17:40:42.964]             }
[17:40:42.964]         }
[17:40:42.964]     })
[17:40:42.964]     if (TRUE) {
[17:40:42.964]         base::sink(type = "output", split = FALSE)
[17:40:42.964]         if (TRUE) {
[17:40:42.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:42.964]         }
[17:40:42.964]         else {
[17:40:42.964]             ...future.result["stdout"] <- base::list(NULL)
[17:40:42.964]         }
[17:40:42.964]         base::close(...future.stdout)
[17:40:42.964]         ...future.stdout <- NULL
[17:40:42.964]     }
[17:40:42.964]     ...future.result$conditions <- ...future.conditions
[17:40:42.964]     ...future.result$finished <- base::Sys.time()
[17:40:42.964]     ...future.result
[17:40:42.964] }
[17:40:42.967] requestCore(): workers = 2
[17:40:42.967] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:42.978] result() for MulticoreFuture ...
[17:40:42.979] result() for MulticoreFuture ...
[17:40:42.979] result() for MulticoreFuture ... done
[17:40:42.979] result() for MulticoreFuture ... done
[17:40:42.979] result() for MulticoreFuture ...
[17:40:42.979] result() for MulticoreFuture ... done
[17:40:42.982] MulticoreFuture started
[17:40:42.983] - Launch lazy future ... done
[17:40:42.983] run() for ‘MulticoreFuture’ ... done
[17:40:42.983] plan(): Setting new future strategy stack:
[17:40:42.983] resolve() on list ...
[17:40:42.984]  recursive: 0
[17:40:42.984]  length: 1
[17:40:42.984] 
[17:40:42.983] List of future strategies:
[17:40:42.983] 1. sequential:
[17:40:42.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:42.983]    - tweaked: FALSE
[17:40:42.983]    - call: NULL
[17:40:42.984] Future #1
[17:40:42.985] plan(): nbrOfWorkers() = 1
[17:40:42.985]  length: 0 (resolved future 1)
[17:40:42.985] resolve() on list ... DONE
[17:40:42.985] resolve() on list ...
[17:40:42.985]  recursive: 0
[17:40:42.986]  length: 1
[17:40:42.986] 
[17:40:43.487] plan(): Setting new future strategy stack:
[17:40:43.487] List of future strategies:
[17:40:43.487] 1. multicore:
[17:40:43.487]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.487]    - tweaked: FALSE
[17:40:43.487]    - call: plan(strategy)
[17:40:43.493] plan(): nbrOfWorkers() = 2
[17:40:43.496] Future #1
[17:40:43.496]  length: 0 (resolved future 1)
[17:40:43.496] resolve() on list ... DONE
[17:40:43.497] resolve() on list ...
[17:40:43.497]  recursive: 0
[17:40:43.497]  length: 1
[17:40:43.497] 
[17:40:43.497]  length: 0 (resolved future 1)
[17:40:43.498] resolve() on list ... DONE
[17:40:43.498] resolve() on list ...
[17:40:43.498]  recursive: 0
[17:40:43.498]  length: 4
[17:40:43.498] 
[17:40:43.499] Future #1
[17:40:43.499]  length: 3 (resolved future 1)
[17:40:43.499] Future #2
[17:40:43.499]  length: 2 (resolved future 2)
[17:40:43.499]  length: 1 (resolved future 3)
[17:40:43.500]  length: 0 (resolved future 4)
[17:40:43.500] resolve() on list ... DONE
[17:40:43.500] resolve() on list ...
[17:40:43.500]  recursive: 0
[17:40:43.500]  length: 4
[17:40:43.500] 
[17:40:43.501] Future #1
[17:40:43.501]  length: 3 (resolved future 1)
[17:40:43.501] Future #2
[17:40:43.501]  length: 2 (resolved future 2)
[17:40:43.501]  length: 1 (resolved future 3)
[17:40:43.502]  length: 0 (resolved future 4)
[17:40:43.502] resolve() on list ... DONE
[17:40:43.502] resolve() on list ...
[17:40:43.502]  recursive: 0
[17:40:43.502]  length: 1
[17:40:43.502] 
[17:40:43.503]  length: 0 (resolved future 1)
[17:40:43.503] resolve() on list ... DONE
[17:40:43.503] getGlobalsAndPackages() ...
[17:40:43.503] Searching for globals...
[17:40:43.505] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.505] Searching for globals ... DONE
[17:40:43.505] Resolving globals: FALSE
[17:40:43.506] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.507] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.507] - globals: [1] ‘kk’
[17:40:43.507] 
[17:40:43.507] getGlobalsAndPackages() ... DONE
[17:40:43.508] run() for ‘Future’ ...
[17:40:43.508] - state: ‘created’
[17:40:43.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.513]   - Field: ‘label’
[17:40:43.513]   - Field: ‘local’
[17:40:43.513]   - Field: ‘owner’
[17:40:43.513]   - Field: ‘envir’
[17:40:43.513]   - Field: ‘workers’
[17:40:43.513]   - Field: ‘packages’
[17:40:43.514]   - Field: ‘gc’
[17:40:43.514]   - Field: ‘job’
[17:40:43.514]   - Field: ‘conditions’
[17:40:43.514]   - Field: ‘expr’
[17:40:43.514]   - Field: ‘uuid’
[17:40:43.514]   - Field: ‘seed’
[17:40:43.514]   - Field: ‘version’
[17:40:43.515]   - Field: ‘result’
[17:40:43.515]   - Field: ‘asynchronous’
[17:40:43.518]   - Field: ‘calls’
[17:40:43.518]   - Field: ‘globals’
[17:40:43.518]   - Field: ‘stdout’
[17:40:43.519]   - Field: ‘earlySignal’
[17:40:43.519]   - Field: ‘lazy’
[17:40:43.519]   - Field: ‘state’
[17:40:43.519] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.520] - Launch lazy future ...
[17:40:43.520] Packages needed by the future expression (n = 0): <none>
[17:40:43.520] Packages needed by future strategies (n = 0): <none>
[17:40:43.521] {
[17:40:43.521]     {
[17:40:43.521]         {
[17:40:43.521]             ...future.startTime <- base::Sys.time()
[17:40:43.521]             {
[17:40:43.521]                 {
[17:40:43.521]                   {
[17:40:43.521]                     {
[17:40:43.521]                       base::local({
[17:40:43.521]                         has_future <- base::requireNamespace("future", 
[17:40:43.521]                           quietly = TRUE)
[17:40:43.521]                         if (has_future) {
[17:40:43.521]                           ns <- base::getNamespace("future")
[17:40:43.521]                           version <- ns[[".package"]][["version"]]
[17:40:43.521]                           if (is.null(version)) 
[17:40:43.521]                             version <- utils::packageVersion("future")
[17:40:43.521]                         }
[17:40:43.521]                         else {
[17:40:43.521]                           version <- NULL
[17:40:43.521]                         }
[17:40:43.521]                         if (!has_future || version < "1.8.0") {
[17:40:43.521]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.521]                             "", base::R.version$version.string), 
[17:40:43.521]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.521]                               "release", "version")], collapse = " "), 
[17:40:43.521]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.521]                             info)
[17:40:43.521]                           info <- base::paste(info, collapse = "; ")
[17:40:43.521]                           if (!has_future) {
[17:40:43.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.521]                               info)
[17:40:43.521]                           }
[17:40:43.521]                           else {
[17:40:43.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.521]                               info, version)
[17:40:43.521]                           }
[17:40:43.521]                           base::stop(msg)
[17:40:43.521]                         }
[17:40:43.521]                       })
[17:40:43.521]                     }
[17:40:43.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.521]                     base::options(mc.cores = 1L)
[17:40:43.521]                   }
[17:40:43.521]                   ...future.strategy.old <- future::plan("list")
[17:40:43.521]                   options(future.plan = NULL)
[17:40:43.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.521]                 }
[17:40:43.521]                 ...future.workdir <- getwd()
[17:40:43.521]             }
[17:40:43.521]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.521]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.521]         }
[17:40:43.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.521]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.521]             base::names(...future.oldOptions))
[17:40:43.521]     }
[17:40:43.521]     if (FALSE) {
[17:40:43.521]     }
[17:40:43.521]     else {
[17:40:43.521]         if (TRUE) {
[17:40:43.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.521]                 open = "w")
[17:40:43.521]         }
[17:40:43.521]         else {
[17:40:43.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.521]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.521]         }
[17:40:43.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.521]             base::sink(type = "output", split = FALSE)
[17:40:43.521]             base::close(...future.stdout)
[17:40:43.521]         }, add = TRUE)
[17:40:43.521]     }
[17:40:43.521]     ...future.frame <- base::sys.nframe()
[17:40:43.521]     ...future.conditions <- base::list()
[17:40:43.521]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.521]     if (FALSE) {
[17:40:43.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.521]     }
[17:40:43.521]     ...future.result <- base::tryCatch({
[17:40:43.521]         base::withCallingHandlers({
[17:40:43.521]             ...future.value <- base::withVisible(base::local({
[17:40:43.521]                 withCallingHandlers({
[17:40:43.521]                   {
[17:40:43.521]                     Sys.sleep(0.1)
[17:40:43.521]                     kk
[17:40:43.521]                   }
[17:40:43.521]                 }, immediateCondition = function(cond) {
[17:40:43.521]                   save_rds <- function (object, pathname, ...) 
[17:40:43.521]                   {
[17:40:43.521]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.521]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.521]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.521]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.521]                         fi_tmp[["mtime"]])
[17:40:43.521]                     }
[17:40:43.521]                     tryCatch({
[17:40:43.521]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.521]                     }, error = function(ex) {
[17:40:43.521]                       msg <- conditionMessage(ex)
[17:40:43.521]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.521]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.521]                         fi_tmp[["mtime"]], msg)
[17:40:43.521]                       ex$message <- msg
[17:40:43.521]                       stop(ex)
[17:40:43.521]                     })
[17:40:43.521]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.521]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.521]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.521]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.521]                       fi <- file.info(pathname)
[17:40:43.521]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.521]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.521]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.521]                         fi[["size"]], fi[["mtime"]])
[17:40:43.521]                       stop(msg)
[17:40:43.521]                     }
[17:40:43.521]                     invisible(pathname)
[17:40:43.521]                   }
[17:40:43.521]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.521]                     rootPath = tempdir()) 
[17:40:43.521]                   {
[17:40:43.521]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.521]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.521]                       tmpdir = path, fileext = ".rds")
[17:40:43.521]                     save_rds(obj, file)
[17:40:43.521]                   }
[17:40:43.521]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.521]                   {
[17:40:43.521]                     inherits <- base::inherits
[17:40:43.521]                     invokeRestart <- base::invokeRestart
[17:40:43.521]                     is.null <- base::is.null
[17:40:43.521]                     muffled <- FALSE
[17:40:43.521]                     if (inherits(cond, "message")) {
[17:40:43.521]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.521]                       if (muffled) 
[17:40:43.521]                         invokeRestart("muffleMessage")
[17:40:43.521]                     }
[17:40:43.521]                     else if (inherits(cond, "warning")) {
[17:40:43.521]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.521]                       if (muffled) 
[17:40:43.521]                         invokeRestart("muffleWarning")
[17:40:43.521]                     }
[17:40:43.521]                     else if (inherits(cond, "condition")) {
[17:40:43.521]                       if (!is.null(pattern)) {
[17:40:43.521]                         computeRestarts <- base::computeRestarts
[17:40:43.521]                         grepl <- base::grepl
[17:40:43.521]                         restarts <- computeRestarts(cond)
[17:40:43.521]                         for (restart in restarts) {
[17:40:43.521]                           name <- restart$name
[17:40:43.521]                           if (is.null(name)) 
[17:40:43.521]                             next
[17:40:43.521]                           if (!grepl(pattern, name)) 
[17:40:43.521]                             next
[17:40:43.521]                           invokeRestart(restart)
[17:40:43.521]                           muffled <- TRUE
[17:40:43.521]                           break
[17:40:43.521]                         }
[17:40:43.521]                       }
[17:40:43.521]                     }
[17:40:43.521]                     invisible(muffled)
[17:40:43.521]                   }
[17:40:43.521]                   muffleCondition(cond)
[17:40:43.521]                 })
[17:40:43.521]             }))
[17:40:43.521]             future::FutureResult(value = ...future.value$value, 
[17:40:43.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.521]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.521]                     ...future.globalenv.names))
[17:40:43.521]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.521]         }, condition = base::local({
[17:40:43.521]             c <- base::c
[17:40:43.521]             inherits <- base::inherits
[17:40:43.521]             invokeRestart <- base::invokeRestart
[17:40:43.521]             length <- base::length
[17:40:43.521]             list <- base::list
[17:40:43.521]             seq.int <- base::seq.int
[17:40:43.521]             signalCondition <- base::signalCondition
[17:40:43.521]             sys.calls <- base::sys.calls
[17:40:43.521]             `[[` <- base::`[[`
[17:40:43.521]             `+` <- base::`+`
[17:40:43.521]             `<<-` <- base::`<<-`
[17:40:43.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.521]                   3L)]
[17:40:43.521]             }
[17:40:43.521]             function(cond) {
[17:40:43.521]                 is_error <- inherits(cond, "error")
[17:40:43.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.521]                   NULL)
[17:40:43.521]                 if (is_error) {
[17:40:43.521]                   sessionInformation <- function() {
[17:40:43.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.521]                       search = base::search(), system = base::Sys.info())
[17:40:43.521]                   }
[17:40:43.521]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.521]                     cond$call), session = sessionInformation(), 
[17:40:43.521]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.521]                   signalCondition(cond)
[17:40:43.521]                 }
[17:40:43.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.521]                 "immediateCondition"))) {
[17:40:43.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.521]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.521]                   if (TRUE && !signal) {
[17:40:43.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.521]                     {
[17:40:43.521]                       inherits <- base::inherits
[17:40:43.521]                       invokeRestart <- base::invokeRestart
[17:40:43.521]                       is.null <- base::is.null
[17:40:43.521]                       muffled <- FALSE
[17:40:43.521]                       if (inherits(cond, "message")) {
[17:40:43.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.521]                         if (muffled) 
[17:40:43.521]                           invokeRestart("muffleMessage")
[17:40:43.521]                       }
[17:40:43.521]                       else if (inherits(cond, "warning")) {
[17:40:43.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.521]                         if (muffled) 
[17:40:43.521]                           invokeRestart("muffleWarning")
[17:40:43.521]                       }
[17:40:43.521]                       else if (inherits(cond, "condition")) {
[17:40:43.521]                         if (!is.null(pattern)) {
[17:40:43.521]                           computeRestarts <- base::computeRestarts
[17:40:43.521]                           grepl <- base::grepl
[17:40:43.521]                           restarts <- computeRestarts(cond)
[17:40:43.521]                           for (restart in restarts) {
[17:40:43.521]                             name <- restart$name
[17:40:43.521]                             if (is.null(name)) 
[17:40:43.521]                               next
[17:40:43.521]                             if (!grepl(pattern, name)) 
[17:40:43.521]                               next
[17:40:43.521]                             invokeRestart(restart)
[17:40:43.521]                             muffled <- TRUE
[17:40:43.521]                             break
[17:40:43.521]                           }
[17:40:43.521]                         }
[17:40:43.521]                       }
[17:40:43.521]                       invisible(muffled)
[17:40:43.521]                     }
[17:40:43.521]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.521]                   }
[17:40:43.521]                 }
[17:40:43.521]                 else {
[17:40:43.521]                   if (TRUE) {
[17:40:43.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.521]                     {
[17:40:43.521]                       inherits <- base::inherits
[17:40:43.521]                       invokeRestart <- base::invokeRestart
[17:40:43.521]                       is.null <- base::is.null
[17:40:43.521]                       muffled <- FALSE
[17:40:43.521]                       if (inherits(cond, "message")) {
[17:40:43.521]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.521]                         if (muffled) 
[17:40:43.521]                           invokeRestart("muffleMessage")
[17:40:43.521]                       }
[17:40:43.521]                       else if (inherits(cond, "warning")) {
[17:40:43.521]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.521]                         if (muffled) 
[17:40:43.521]                           invokeRestart("muffleWarning")
[17:40:43.521]                       }
[17:40:43.521]                       else if (inherits(cond, "condition")) {
[17:40:43.521]                         if (!is.null(pattern)) {
[17:40:43.521]                           computeRestarts <- base::computeRestarts
[17:40:43.521]                           grepl <- base::grepl
[17:40:43.521]                           restarts <- computeRestarts(cond)
[17:40:43.521]                           for (restart in restarts) {
[17:40:43.521]                             name <- restart$name
[17:40:43.521]                             if (is.null(name)) 
[17:40:43.521]                               next
[17:40:43.521]                             if (!grepl(pattern, name)) 
[17:40:43.521]                               next
[17:40:43.521]                             invokeRestart(restart)
[17:40:43.521]                             muffled <- TRUE
[17:40:43.521]                             break
[17:40:43.521]                           }
[17:40:43.521]                         }
[17:40:43.521]                       }
[17:40:43.521]                       invisible(muffled)
[17:40:43.521]                     }
[17:40:43.521]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.521]                   }
[17:40:43.521]                 }
[17:40:43.521]             }
[17:40:43.521]         }))
[17:40:43.521]     }, error = function(ex) {
[17:40:43.521]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.521]                 ...future.rng), started = ...future.startTime, 
[17:40:43.521]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.521]             version = "1.8"), class = "FutureResult")
[17:40:43.521]     }, finally = {
[17:40:43.521]         if (!identical(...future.workdir, getwd())) 
[17:40:43.521]             setwd(...future.workdir)
[17:40:43.521]         {
[17:40:43.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.521]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.521]             }
[17:40:43.521]             base::options(...future.oldOptions)
[17:40:43.521]             if (.Platform$OS.type == "windows") {
[17:40:43.521]                 old_names <- names(...future.oldEnvVars)
[17:40:43.521]                 envs <- base::Sys.getenv()
[17:40:43.521]                 names <- names(envs)
[17:40:43.521]                 common <- intersect(names, old_names)
[17:40:43.521]                 added <- setdiff(names, old_names)
[17:40:43.521]                 removed <- setdiff(old_names, names)
[17:40:43.521]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.521]                   envs[common]]
[17:40:43.521]                 NAMES <- toupper(changed)
[17:40:43.521]                 args <- list()
[17:40:43.521]                 for (kk in seq_along(NAMES)) {
[17:40:43.521]                   name <- changed[[kk]]
[17:40:43.521]                   NAME <- NAMES[[kk]]
[17:40:43.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.521]                     next
[17:40:43.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.521]                 }
[17:40:43.521]                 NAMES <- toupper(added)
[17:40:43.521]                 for (kk in seq_along(NAMES)) {
[17:40:43.521]                   name <- added[[kk]]
[17:40:43.521]                   NAME <- NAMES[[kk]]
[17:40:43.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.521]                     next
[17:40:43.521]                   args[[name]] <- ""
[17:40:43.521]                 }
[17:40:43.521]                 NAMES <- toupper(removed)
[17:40:43.521]                 for (kk in seq_along(NAMES)) {
[17:40:43.521]                   name <- removed[[kk]]
[17:40:43.521]                   NAME <- NAMES[[kk]]
[17:40:43.521]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.521]                     next
[17:40:43.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.521]                 }
[17:40:43.521]                 if (length(args) > 0) 
[17:40:43.521]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.521]             }
[17:40:43.521]             else {
[17:40:43.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.521]             }
[17:40:43.521]             {
[17:40:43.521]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.521]                   0L) {
[17:40:43.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.521]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.521]                   base::options(opts)
[17:40:43.521]                 }
[17:40:43.521]                 {
[17:40:43.521]                   {
[17:40:43.521]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.521]                     NULL
[17:40:43.521]                   }
[17:40:43.521]                   options(future.plan = NULL)
[17:40:43.521]                   if (is.na(NA_character_)) 
[17:40:43.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.521]                     .init = FALSE)
[17:40:43.521]                 }
[17:40:43.521]             }
[17:40:43.521]         }
[17:40:43.521]     })
[17:40:43.521]     if (TRUE) {
[17:40:43.521]         base::sink(type = "output", split = FALSE)
[17:40:43.521]         if (TRUE) {
[17:40:43.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.521]         }
[17:40:43.521]         else {
[17:40:43.521]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.521]         }
[17:40:43.521]         base::close(...future.stdout)
[17:40:43.521]         ...future.stdout <- NULL
[17:40:43.521]     }
[17:40:43.521]     ...future.result$conditions <- ...future.conditions
[17:40:43.521]     ...future.result$finished <- base::Sys.time()
[17:40:43.521]     ...future.result
[17:40:43.521] }
[17:40:43.524] assign_globals() ...
[17:40:43.524] List of 1
[17:40:43.524]  $ kk: int 1
[17:40:43.524]  - attr(*, "where")=List of 1
[17:40:43.524]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.524]  - attr(*, "resolved")= logi FALSE
[17:40:43.524]  - attr(*, "total_size")= num 56
[17:40:43.524]  - attr(*, "already-done")= logi TRUE
[17:40:43.528] - copied ‘kk’ to environment
[17:40:43.528] assign_globals() ... done
[17:40:43.528] requestCore(): workers = 2
[17:40:43.528] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.539] result() for MulticoreFuture ...
[17:40:43.540] result() for MulticoreFuture ...
[17:40:43.540] result() for MulticoreFuture ... done
[17:40:43.540] result() for MulticoreFuture ... done
[17:40:43.540] result() for MulticoreFuture ...
[17:40:43.541] result() for MulticoreFuture ... done
[17:40:43.543] MulticoreFuture started
[17:40:43.544] - Launch lazy future ... done
[17:40:43.544] run() for ‘MulticoreFuture’ ... done
[17:40:43.544] getGlobalsAndPackages() ...
[17:40:43.544] plan(): Setting new future strategy stack:
[17:40:43.545] Searching for globals...
[17:40:43.545] List of future strategies:
[17:40:43.545] 1. sequential:
[17:40:43.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.545]    - tweaked: FALSE
[17:40:43.545]    - call: NULL
[17:40:43.546] plan(): nbrOfWorkers() = 1
[17:40:43.547] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.547] Searching for globals ... DONE
[17:40:43.547] Resolving globals: FALSE
[17:40:43.548] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.549] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.549] - globals: [1] ‘kk’
[17:40:43.549] 
[17:40:43.549] getGlobalsAndPackages() ... DONE
[17:40:43.550] run() for ‘Future’ ...
[17:40:43.550] - state: ‘created’
[17:40:43.550] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.556]   - Field: ‘label’
[17:40:43.556]   - Field: ‘local’
[17:40:43.556]   - Field: ‘owner’
[17:40:43.556]   - Field: ‘envir’
[17:40:43.556]   - Field: ‘workers’
[17:40:43.556]   - Field: ‘packages’
[17:40:43.556]   - Field: ‘gc’
[17:40:43.557]   - Field: ‘job’
[17:40:43.557]   - Field: ‘conditions’
[17:40:43.557]   - Field: ‘expr’
[17:40:43.557]   - Field: ‘uuid’
[17:40:43.557]   - Field: ‘seed’
[17:40:43.557]   - Field: ‘version’
[17:40:43.557]   - Field: ‘result’
[17:40:43.558]   - Field: ‘asynchronous’
[17:40:43.558]   - Field: ‘calls’
[17:40:43.558]   - Field: ‘globals’
[17:40:43.558]   - Field: ‘stdout’
[17:40:43.558]   - Field: ‘earlySignal’
[17:40:43.558]   - Field: ‘lazy’
[17:40:43.558]   - Field: ‘state’
[17:40:43.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.559] - Launch lazy future ...
[17:40:43.559] Packages needed by the future expression (n = 0): <none>
[17:40:43.559] Packages needed by future strategies (n = 0): <none>
[17:40:43.560] {
[17:40:43.560]     {
[17:40:43.560]         {
[17:40:43.560]             ...future.startTime <- base::Sys.time()
[17:40:43.560]             {
[17:40:43.560]                 {
[17:40:43.560]                   {
[17:40:43.560]                     {
[17:40:43.560]                       base::local({
[17:40:43.560]                         has_future <- base::requireNamespace("future", 
[17:40:43.560]                           quietly = TRUE)
[17:40:43.560]                         if (has_future) {
[17:40:43.560]                           ns <- base::getNamespace("future")
[17:40:43.560]                           version <- ns[[".package"]][["version"]]
[17:40:43.560]                           if (is.null(version)) 
[17:40:43.560]                             version <- utils::packageVersion("future")
[17:40:43.560]                         }
[17:40:43.560]                         else {
[17:40:43.560]                           version <- NULL
[17:40:43.560]                         }
[17:40:43.560]                         if (!has_future || version < "1.8.0") {
[17:40:43.560]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.560]                             "", base::R.version$version.string), 
[17:40:43.560]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.560]                               "release", "version")], collapse = " "), 
[17:40:43.560]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.560]                             info)
[17:40:43.560]                           info <- base::paste(info, collapse = "; ")
[17:40:43.560]                           if (!has_future) {
[17:40:43.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.560]                               info)
[17:40:43.560]                           }
[17:40:43.560]                           else {
[17:40:43.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.560]                               info, version)
[17:40:43.560]                           }
[17:40:43.560]                           base::stop(msg)
[17:40:43.560]                         }
[17:40:43.560]                       })
[17:40:43.560]                     }
[17:40:43.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.560]                     base::options(mc.cores = 1L)
[17:40:43.560]                   }
[17:40:43.560]                   ...future.strategy.old <- future::plan("list")
[17:40:43.560]                   options(future.plan = NULL)
[17:40:43.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.560]                 }
[17:40:43.560]                 ...future.workdir <- getwd()
[17:40:43.560]             }
[17:40:43.560]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.560]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.560]         }
[17:40:43.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.560]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.560]             base::names(...future.oldOptions))
[17:40:43.560]     }
[17:40:43.560]     if (FALSE) {
[17:40:43.560]     }
[17:40:43.560]     else {
[17:40:43.560]         if (TRUE) {
[17:40:43.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.560]                 open = "w")
[17:40:43.560]         }
[17:40:43.560]         else {
[17:40:43.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.560]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.560]         }
[17:40:43.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.560]             base::sink(type = "output", split = FALSE)
[17:40:43.560]             base::close(...future.stdout)
[17:40:43.560]         }, add = TRUE)
[17:40:43.560]     }
[17:40:43.560]     ...future.frame <- base::sys.nframe()
[17:40:43.560]     ...future.conditions <- base::list()
[17:40:43.560]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.560]     if (FALSE) {
[17:40:43.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.560]     }
[17:40:43.560]     ...future.result <- base::tryCatch({
[17:40:43.560]         base::withCallingHandlers({
[17:40:43.560]             ...future.value <- base::withVisible(base::local({
[17:40:43.560]                 withCallingHandlers({
[17:40:43.560]                   {
[17:40:43.560]                     Sys.sleep(0.1)
[17:40:43.560]                     kk
[17:40:43.560]                   }
[17:40:43.560]                 }, immediateCondition = function(cond) {
[17:40:43.560]                   save_rds <- function (object, pathname, ...) 
[17:40:43.560]                   {
[17:40:43.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.560]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.560]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.560]                         fi_tmp[["mtime"]])
[17:40:43.560]                     }
[17:40:43.560]                     tryCatch({
[17:40:43.560]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.560]                     }, error = function(ex) {
[17:40:43.560]                       msg <- conditionMessage(ex)
[17:40:43.560]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.560]                         fi_tmp[["mtime"]], msg)
[17:40:43.560]                       ex$message <- msg
[17:40:43.560]                       stop(ex)
[17:40:43.560]                     })
[17:40:43.560]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.560]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.560]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.560]                       fi <- file.info(pathname)
[17:40:43.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.560]                         fi[["size"]], fi[["mtime"]])
[17:40:43.560]                       stop(msg)
[17:40:43.560]                     }
[17:40:43.560]                     invisible(pathname)
[17:40:43.560]                   }
[17:40:43.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.560]                     rootPath = tempdir()) 
[17:40:43.560]                   {
[17:40:43.560]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.560]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.560]                       tmpdir = path, fileext = ".rds")
[17:40:43.560]                     save_rds(obj, file)
[17:40:43.560]                   }
[17:40:43.560]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.560]                   {
[17:40:43.560]                     inherits <- base::inherits
[17:40:43.560]                     invokeRestart <- base::invokeRestart
[17:40:43.560]                     is.null <- base::is.null
[17:40:43.560]                     muffled <- FALSE
[17:40:43.560]                     if (inherits(cond, "message")) {
[17:40:43.560]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.560]                       if (muffled) 
[17:40:43.560]                         invokeRestart("muffleMessage")
[17:40:43.560]                     }
[17:40:43.560]                     else if (inherits(cond, "warning")) {
[17:40:43.560]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.560]                       if (muffled) 
[17:40:43.560]                         invokeRestart("muffleWarning")
[17:40:43.560]                     }
[17:40:43.560]                     else if (inherits(cond, "condition")) {
[17:40:43.560]                       if (!is.null(pattern)) {
[17:40:43.560]                         computeRestarts <- base::computeRestarts
[17:40:43.560]                         grepl <- base::grepl
[17:40:43.560]                         restarts <- computeRestarts(cond)
[17:40:43.560]                         for (restart in restarts) {
[17:40:43.560]                           name <- restart$name
[17:40:43.560]                           if (is.null(name)) 
[17:40:43.560]                             next
[17:40:43.560]                           if (!grepl(pattern, name)) 
[17:40:43.560]                             next
[17:40:43.560]                           invokeRestart(restart)
[17:40:43.560]                           muffled <- TRUE
[17:40:43.560]                           break
[17:40:43.560]                         }
[17:40:43.560]                       }
[17:40:43.560]                     }
[17:40:43.560]                     invisible(muffled)
[17:40:43.560]                   }
[17:40:43.560]                   muffleCondition(cond)
[17:40:43.560]                 })
[17:40:43.560]             }))
[17:40:43.560]             future::FutureResult(value = ...future.value$value, 
[17:40:43.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.560]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.560]                     ...future.globalenv.names))
[17:40:43.560]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.560]         }, condition = base::local({
[17:40:43.560]             c <- base::c
[17:40:43.560]             inherits <- base::inherits
[17:40:43.560]             invokeRestart <- base::invokeRestart
[17:40:43.560]             length <- base::length
[17:40:43.560]             list <- base::list
[17:40:43.560]             seq.int <- base::seq.int
[17:40:43.560]             signalCondition <- base::signalCondition
[17:40:43.560]             sys.calls <- base::sys.calls
[17:40:43.560]             `[[` <- base::`[[`
[17:40:43.560]             `+` <- base::`+`
[17:40:43.560]             `<<-` <- base::`<<-`
[17:40:43.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.560]                   3L)]
[17:40:43.560]             }
[17:40:43.560]             function(cond) {
[17:40:43.560]                 is_error <- inherits(cond, "error")
[17:40:43.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.560]                   NULL)
[17:40:43.560]                 if (is_error) {
[17:40:43.560]                   sessionInformation <- function() {
[17:40:43.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.560]                       search = base::search(), system = base::Sys.info())
[17:40:43.560]                   }
[17:40:43.560]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.560]                     cond$call), session = sessionInformation(), 
[17:40:43.560]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.560]                   signalCondition(cond)
[17:40:43.560]                 }
[17:40:43.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.560]                 "immediateCondition"))) {
[17:40:43.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.560]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.560]                   if (TRUE && !signal) {
[17:40:43.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.560]                     {
[17:40:43.560]                       inherits <- base::inherits
[17:40:43.560]                       invokeRestart <- base::invokeRestart
[17:40:43.560]                       is.null <- base::is.null
[17:40:43.560]                       muffled <- FALSE
[17:40:43.560]                       if (inherits(cond, "message")) {
[17:40:43.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.560]                         if (muffled) 
[17:40:43.560]                           invokeRestart("muffleMessage")
[17:40:43.560]                       }
[17:40:43.560]                       else if (inherits(cond, "warning")) {
[17:40:43.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.560]                         if (muffled) 
[17:40:43.560]                           invokeRestart("muffleWarning")
[17:40:43.560]                       }
[17:40:43.560]                       else if (inherits(cond, "condition")) {
[17:40:43.560]                         if (!is.null(pattern)) {
[17:40:43.560]                           computeRestarts <- base::computeRestarts
[17:40:43.560]                           grepl <- base::grepl
[17:40:43.560]                           restarts <- computeRestarts(cond)
[17:40:43.560]                           for (restart in restarts) {
[17:40:43.560]                             name <- restart$name
[17:40:43.560]                             if (is.null(name)) 
[17:40:43.560]                               next
[17:40:43.560]                             if (!grepl(pattern, name)) 
[17:40:43.560]                               next
[17:40:43.560]                             invokeRestart(restart)
[17:40:43.560]                             muffled <- TRUE
[17:40:43.560]                             break
[17:40:43.560]                           }
[17:40:43.560]                         }
[17:40:43.560]                       }
[17:40:43.560]                       invisible(muffled)
[17:40:43.560]                     }
[17:40:43.560]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.560]                   }
[17:40:43.560]                 }
[17:40:43.560]                 else {
[17:40:43.560]                   if (TRUE) {
[17:40:43.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.560]                     {
[17:40:43.560]                       inherits <- base::inherits
[17:40:43.560]                       invokeRestart <- base::invokeRestart
[17:40:43.560]                       is.null <- base::is.null
[17:40:43.560]                       muffled <- FALSE
[17:40:43.560]                       if (inherits(cond, "message")) {
[17:40:43.560]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.560]                         if (muffled) 
[17:40:43.560]                           invokeRestart("muffleMessage")
[17:40:43.560]                       }
[17:40:43.560]                       else if (inherits(cond, "warning")) {
[17:40:43.560]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.560]                         if (muffled) 
[17:40:43.560]                           invokeRestart("muffleWarning")
[17:40:43.560]                       }
[17:40:43.560]                       else if (inherits(cond, "condition")) {
[17:40:43.560]                         if (!is.null(pattern)) {
[17:40:43.560]                           computeRestarts <- base::computeRestarts
[17:40:43.560]                           grepl <- base::grepl
[17:40:43.560]                           restarts <- computeRestarts(cond)
[17:40:43.560]                           for (restart in restarts) {
[17:40:43.560]                             name <- restart$name
[17:40:43.560]                             if (is.null(name)) 
[17:40:43.560]                               next
[17:40:43.560]                             if (!grepl(pattern, name)) 
[17:40:43.560]                               next
[17:40:43.560]                             invokeRestart(restart)
[17:40:43.560]                             muffled <- TRUE
[17:40:43.560]                             break
[17:40:43.560]                           }
[17:40:43.560]                         }
[17:40:43.560]                       }
[17:40:43.560]                       invisible(muffled)
[17:40:43.560]                     }
[17:40:43.560]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.560]                   }
[17:40:43.560]                 }
[17:40:43.560]             }
[17:40:43.560]         }))
[17:40:43.560]     }, error = function(ex) {
[17:40:43.560]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.560]                 ...future.rng), started = ...future.startTime, 
[17:40:43.560]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.560]             version = "1.8"), class = "FutureResult")
[17:40:43.560]     }, finally = {
[17:40:43.560]         if (!identical(...future.workdir, getwd())) 
[17:40:43.560]             setwd(...future.workdir)
[17:40:43.560]         {
[17:40:43.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.560]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.560]             }
[17:40:43.560]             base::options(...future.oldOptions)
[17:40:43.560]             if (.Platform$OS.type == "windows") {
[17:40:43.560]                 old_names <- names(...future.oldEnvVars)
[17:40:43.560]                 envs <- base::Sys.getenv()
[17:40:43.560]                 names <- names(envs)
[17:40:43.560]                 common <- intersect(names, old_names)
[17:40:43.560]                 added <- setdiff(names, old_names)
[17:40:43.560]                 removed <- setdiff(old_names, names)
[17:40:43.560]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.560]                   envs[common]]
[17:40:43.560]                 NAMES <- toupper(changed)
[17:40:43.560]                 args <- list()
[17:40:43.560]                 for (kk in seq_along(NAMES)) {
[17:40:43.560]                   name <- changed[[kk]]
[17:40:43.560]                   NAME <- NAMES[[kk]]
[17:40:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.560]                     next
[17:40:43.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.560]                 }
[17:40:43.560]                 NAMES <- toupper(added)
[17:40:43.560]                 for (kk in seq_along(NAMES)) {
[17:40:43.560]                   name <- added[[kk]]
[17:40:43.560]                   NAME <- NAMES[[kk]]
[17:40:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.560]                     next
[17:40:43.560]                   args[[name]] <- ""
[17:40:43.560]                 }
[17:40:43.560]                 NAMES <- toupper(removed)
[17:40:43.560]                 for (kk in seq_along(NAMES)) {
[17:40:43.560]                   name <- removed[[kk]]
[17:40:43.560]                   NAME <- NAMES[[kk]]
[17:40:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.560]                     next
[17:40:43.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.560]                 }
[17:40:43.560]                 if (length(args) > 0) 
[17:40:43.560]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.560]             }
[17:40:43.560]             else {
[17:40:43.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.560]             }
[17:40:43.560]             {
[17:40:43.560]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.560]                   0L) {
[17:40:43.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.560]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.560]                   base::options(opts)
[17:40:43.560]                 }
[17:40:43.560]                 {
[17:40:43.560]                   {
[17:40:43.560]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.560]                     NULL
[17:40:43.560]                   }
[17:40:43.560]                   options(future.plan = NULL)
[17:40:43.560]                   if (is.na(NA_character_)) 
[17:40:43.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.560]                     .init = FALSE)
[17:40:43.560]                 }
[17:40:43.560]             }
[17:40:43.560]         }
[17:40:43.560]     })
[17:40:43.560]     if (TRUE) {
[17:40:43.560]         base::sink(type = "output", split = FALSE)
[17:40:43.560]         if (TRUE) {
[17:40:43.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.560]         }
[17:40:43.560]         else {
[17:40:43.560]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.560]         }
[17:40:43.560]         base::close(...future.stdout)
[17:40:43.560]         ...future.stdout <- NULL
[17:40:43.560]     }
[17:40:43.560]     ...future.result$conditions <- ...future.conditions
[17:40:43.560]     ...future.result$finished <- base::Sys.time()
[17:40:43.560]     ...future.result
[17:40:43.560] }
[17:40:43.563] assign_globals() ...
[17:40:43.563] List of 1
[17:40:43.563]  $ kk: int 2
[17:40:43.563]  - attr(*, "where")=List of 1
[17:40:43.563]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.563]  - attr(*, "resolved")= logi FALSE
[17:40:43.563]  - attr(*, "total_size")= num 56
[17:40:43.563]  - attr(*, "already-done")= logi TRUE
[17:40:43.567] - copied ‘kk’ to environment
[17:40:43.567] assign_globals() ... done
[17:40:43.567] requestCore(): workers = 2
[17:40:43.568] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.578] result() for MulticoreFuture ...
[17:40:43.579] result() for MulticoreFuture ...
[17:40:43.579] result() for MulticoreFuture ... done
[17:40:43.579] result() for MulticoreFuture ... done
[17:40:43.580] result() for MulticoreFuture ...
[17:40:43.580] result() for MulticoreFuture ... done
[17:40:43.582] MulticoreFuture started
[17:40:43.582] - Launch lazy future ... done
[17:40:43.583] run() for ‘MulticoreFuture’ ... done
[17:40:43.583] getGlobalsAndPackages() ...
[17:40:43.583] Searching for globals...
[17:40:43.583] plan(): Setting new future strategy stack:
[17:40:43.584] List of future strategies:
[17:40:43.584] 1. sequential:
[17:40:43.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.584]    - tweaked: FALSE
[17:40:43.584]    - call: NULL
[17:40:43.585] plan(): nbrOfWorkers() = 1
[17:40:43.586] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.587] Searching for globals ... DONE
[17:40:43.587] Resolving globals: FALSE
[17:40:43.588] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.588] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.589] - globals: [1] ‘kk’
[17:40:43.589] 
[17:40:43.589] getGlobalsAndPackages() ... DONE
[17:40:43.589] run() for ‘Future’ ...
[17:40:43.590] - state: ‘created’
[17:40:43.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.595] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.595] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.595]   - Field: ‘label’
[17:40:43.595]   - Field: ‘local’
[17:40:43.595]   - Field: ‘owner’
[17:40:43.595]   - Field: ‘envir’
[17:40:43.596]   - Field: ‘workers’
[17:40:43.596]   - Field: ‘packages’
[17:40:43.596]   - Field: ‘gc’
[17:40:43.596]   - Field: ‘job’
[17:40:43.596]   - Field: ‘conditions’
[17:40:43.596]   - Field: ‘expr’
[17:40:43.596]   - Field: ‘uuid’
[17:40:43.597]   - Field: ‘seed’
[17:40:43.597]   - Field: ‘version’
[17:40:43.597]   - Field: ‘result’
[17:40:43.597]   - Field: ‘asynchronous’
[17:40:43.597]   - Field: ‘calls’
[17:40:43.601]   - Field: ‘globals’
[17:40:43.601]   - Field: ‘stdout’
[17:40:43.601]   - Field: ‘earlySignal’
[17:40:43.602]   - Field: ‘lazy’
[17:40:43.602]   - Field: ‘state’
[17:40:43.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.603] - Launch lazy future ...
[17:40:43.603] Packages needed by the future expression (n = 0): <none>
[17:40:43.603] Packages needed by future strategies (n = 0): <none>
[17:40:43.605] {
[17:40:43.605]     {
[17:40:43.605]         {
[17:40:43.605]             ...future.startTime <- base::Sys.time()
[17:40:43.605]             {
[17:40:43.605]                 {
[17:40:43.605]                   {
[17:40:43.605]                     {
[17:40:43.605]                       base::local({
[17:40:43.605]                         has_future <- base::requireNamespace("future", 
[17:40:43.605]                           quietly = TRUE)
[17:40:43.605]                         if (has_future) {
[17:40:43.605]                           ns <- base::getNamespace("future")
[17:40:43.605]                           version <- ns[[".package"]][["version"]]
[17:40:43.605]                           if (is.null(version)) 
[17:40:43.605]                             version <- utils::packageVersion("future")
[17:40:43.605]                         }
[17:40:43.605]                         else {
[17:40:43.605]                           version <- NULL
[17:40:43.605]                         }
[17:40:43.605]                         if (!has_future || version < "1.8.0") {
[17:40:43.605]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.605]                             "", base::R.version$version.string), 
[17:40:43.605]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.605]                               "release", "version")], collapse = " "), 
[17:40:43.605]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.605]                             info)
[17:40:43.605]                           info <- base::paste(info, collapse = "; ")
[17:40:43.605]                           if (!has_future) {
[17:40:43.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.605]                               info)
[17:40:43.605]                           }
[17:40:43.605]                           else {
[17:40:43.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.605]                               info, version)
[17:40:43.605]                           }
[17:40:43.605]                           base::stop(msg)
[17:40:43.605]                         }
[17:40:43.605]                       })
[17:40:43.605]                     }
[17:40:43.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.605]                     base::options(mc.cores = 1L)
[17:40:43.605]                   }
[17:40:43.605]                   ...future.strategy.old <- future::plan("list")
[17:40:43.605]                   options(future.plan = NULL)
[17:40:43.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.605]                 }
[17:40:43.605]                 ...future.workdir <- getwd()
[17:40:43.605]             }
[17:40:43.605]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.605]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.605]         }
[17:40:43.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.605]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.605]             base::names(...future.oldOptions))
[17:40:43.605]     }
[17:40:43.605]     if (FALSE) {
[17:40:43.605]     }
[17:40:43.605]     else {
[17:40:43.605]         if (TRUE) {
[17:40:43.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.605]                 open = "w")
[17:40:43.605]         }
[17:40:43.605]         else {
[17:40:43.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.605]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.605]         }
[17:40:43.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.605]             base::sink(type = "output", split = FALSE)
[17:40:43.605]             base::close(...future.stdout)
[17:40:43.605]         }, add = TRUE)
[17:40:43.605]     }
[17:40:43.605]     ...future.frame <- base::sys.nframe()
[17:40:43.605]     ...future.conditions <- base::list()
[17:40:43.605]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.605]     if (FALSE) {
[17:40:43.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.605]     }
[17:40:43.605]     ...future.result <- base::tryCatch({
[17:40:43.605]         base::withCallingHandlers({
[17:40:43.605]             ...future.value <- base::withVisible(base::local({
[17:40:43.605]                 withCallingHandlers({
[17:40:43.605]                   {
[17:40:43.605]                     Sys.sleep(0.1)
[17:40:43.605]                     kk
[17:40:43.605]                   }
[17:40:43.605]                 }, immediateCondition = function(cond) {
[17:40:43.605]                   save_rds <- function (object, pathname, ...) 
[17:40:43.605]                   {
[17:40:43.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.605]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.605]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.605]                         fi_tmp[["mtime"]])
[17:40:43.605]                     }
[17:40:43.605]                     tryCatch({
[17:40:43.605]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.605]                     }, error = function(ex) {
[17:40:43.605]                       msg <- conditionMessage(ex)
[17:40:43.605]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.605]                         fi_tmp[["mtime"]], msg)
[17:40:43.605]                       ex$message <- msg
[17:40:43.605]                       stop(ex)
[17:40:43.605]                     })
[17:40:43.605]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.605]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.605]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.605]                       fi <- file.info(pathname)
[17:40:43.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.605]                         fi[["size"]], fi[["mtime"]])
[17:40:43.605]                       stop(msg)
[17:40:43.605]                     }
[17:40:43.605]                     invisible(pathname)
[17:40:43.605]                   }
[17:40:43.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.605]                     rootPath = tempdir()) 
[17:40:43.605]                   {
[17:40:43.605]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.605]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.605]                       tmpdir = path, fileext = ".rds")
[17:40:43.605]                     save_rds(obj, file)
[17:40:43.605]                   }
[17:40:43.605]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.605]                   {
[17:40:43.605]                     inherits <- base::inherits
[17:40:43.605]                     invokeRestart <- base::invokeRestart
[17:40:43.605]                     is.null <- base::is.null
[17:40:43.605]                     muffled <- FALSE
[17:40:43.605]                     if (inherits(cond, "message")) {
[17:40:43.605]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.605]                       if (muffled) 
[17:40:43.605]                         invokeRestart("muffleMessage")
[17:40:43.605]                     }
[17:40:43.605]                     else if (inherits(cond, "warning")) {
[17:40:43.605]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.605]                       if (muffled) 
[17:40:43.605]                         invokeRestart("muffleWarning")
[17:40:43.605]                     }
[17:40:43.605]                     else if (inherits(cond, "condition")) {
[17:40:43.605]                       if (!is.null(pattern)) {
[17:40:43.605]                         computeRestarts <- base::computeRestarts
[17:40:43.605]                         grepl <- base::grepl
[17:40:43.605]                         restarts <- computeRestarts(cond)
[17:40:43.605]                         for (restart in restarts) {
[17:40:43.605]                           name <- restart$name
[17:40:43.605]                           if (is.null(name)) 
[17:40:43.605]                             next
[17:40:43.605]                           if (!grepl(pattern, name)) 
[17:40:43.605]                             next
[17:40:43.605]                           invokeRestart(restart)
[17:40:43.605]                           muffled <- TRUE
[17:40:43.605]                           break
[17:40:43.605]                         }
[17:40:43.605]                       }
[17:40:43.605]                     }
[17:40:43.605]                     invisible(muffled)
[17:40:43.605]                   }
[17:40:43.605]                   muffleCondition(cond)
[17:40:43.605]                 })
[17:40:43.605]             }))
[17:40:43.605]             future::FutureResult(value = ...future.value$value, 
[17:40:43.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.605]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.605]                     ...future.globalenv.names))
[17:40:43.605]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.605]         }, condition = base::local({
[17:40:43.605]             c <- base::c
[17:40:43.605]             inherits <- base::inherits
[17:40:43.605]             invokeRestart <- base::invokeRestart
[17:40:43.605]             length <- base::length
[17:40:43.605]             list <- base::list
[17:40:43.605]             seq.int <- base::seq.int
[17:40:43.605]             signalCondition <- base::signalCondition
[17:40:43.605]             sys.calls <- base::sys.calls
[17:40:43.605]             `[[` <- base::`[[`
[17:40:43.605]             `+` <- base::`+`
[17:40:43.605]             `<<-` <- base::`<<-`
[17:40:43.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.605]                   3L)]
[17:40:43.605]             }
[17:40:43.605]             function(cond) {
[17:40:43.605]                 is_error <- inherits(cond, "error")
[17:40:43.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.605]                   NULL)
[17:40:43.605]                 if (is_error) {
[17:40:43.605]                   sessionInformation <- function() {
[17:40:43.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.605]                       search = base::search(), system = base::Sys.info())
[17:40:43.605]                   }
[17:40:43.605]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.605]                     cond$call), session = sessionInformation(), 
[17:40:43.605]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.605]                   signalCondition(cond)
[17:40:43.605]                 }
[17:40:43.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.605]                 "immediateCondition"))) {
[17:40:43.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.605]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.605]                   if (TRUE && !signal) {
[17:40:43.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.605]                     {
[17:40:43.605]                       inherits <- base::inherits
[17:40:43.605]                       invokeRestart <- base::invokeRestart
[17:40:43.605]                       is.null <- base::is.null
[17:40:43.605]                       muffled <- FALSE
[17:40:43.605]                       if (inherits(cond, "message")) {
[17:40:43.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.605]                         if (muffled) 
[17:40:43.605]                           invokeRestart("muffleMessage")
[17:40:43.605]                       }
[17:40:43.605]                       else if (inherits(cond, "warning")) {
[17:40:43.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.605]                         if (muffled) 
[17:40:43.605]                           invokeRestart("muffleWarning")
[17:40:43.605]                       }
[17:40:43.605]                       else if (inherits(cond, "condition")) {
[17:40:43.605]                         if (!is.null(pattern)) {
[17:40:43.605]                           computeRestarts <- base::computeRestarts
[17:40:43.605]                           grepl <- base::grepl
[17:40:43.605]                           restarts <- computeRestarts(cond)
[17:40:43.605]                           for (restart in restarts) {
[17:40:43.605]                             name <- restart$name
[17:40:43.605]                             if (is.null(name)) 
[17:40:43.605]                               next
[17:40:43.605]                             if (!grepl(pattern, name)) 
[17:40:43.605]                               next
[17:40:43.605]                             invokeRestart(restart)
[17:40:43.605]                             muffled <- TRUE
[17:40:43.605]                             break
[17:40:43.605]                           }
[17:40:43.605]                         }
[17:40:43.605]                       }
[17:40:43.605]                       invisible(muffled)
[17:40:43.605]                     }
[17:40:43.605]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.605]                   }
[17:40:43.605]                 }
[17:40:43.605]                 else {
[17:40:43.605]                   if (TRUE) {
[17:40:43.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.605]                     {
[17:40:43.605]                       inherits <- base::inherits
[17:40:43.605]                       invokeRestart <- base::invokeRestart
[17:40:43.605]                       is.null <- base::is.null
[17:40:43.605]                       muffled <- FALSE
[17:40:43.605]                       if (inherits(cond, "message")) {
[17:40:43.605]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.605]                         if (muffled) 
[17:40:43.605]                           invokeRestart("muffleMessage")
[17:40:43.605]                       }
[17:40:43.605]                       else if (inherits(cond, "warning")) {
[17:40:43.605]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.605]                         if (muffled) 
[17:40:43.605]                           invokeRestart("muffleWarning")
[17:40:43.605]                       }
[17:40:43.605]                       else if (inherits(cond, "condition")) {
[17:40:43.605]                         if (!is.null(pattern)) {
[17:40:43.605]                           computeRestarts <- base::computeRestarts
[17:40:43.605]                           grepl <- base::grepl
[17:40:43.605]                           restarts <- computeRestarts(cond)
[17:40:43.605]                           for (restart in restarts) {
[17:40:43.605]                             name <- restart$name
[17:40:43.605]                             if (is.null(name)) 
[17:40:43.605]                               next
[17:40:43.605]                             if (!grepl(pattern, name)) 
[17:40:43.605]                               next
[17:40:43.605]                             invokeRestart(restart)
[17:40:43.605]                             muffled <- TRUE
[17:40:43.605]                             break
[17:40:43.605]                           }
[17:40:43.605]                         }
[17:40:43.605]                       }
[17:40:43.605]                       invisible(muffled)
[17:40:43.605]                     }
[17:40:43.605]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.605]                   }
[17:40:43.605]                 }
[17:40:43.605]             }
[17:40:43.605]         }))
[17:40:43.605]     }, error = function(ex) {
[17:40:43.605]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.605]                 ...future.rng), started = ...future.startTime, 
[17:40:43.605]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.605]             version = "1.8"), class = "FutureResult")
[17:40:43.605]     }, finally = {
[17:40:43.605]         if (!identical(...future.workdir, getwd())) 
[17:40:43.605]             setwd(...future.workdir)
[17:40:43.605]         {
[17:40:43.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.605]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.605]             }
[17:40:43.605]             base::options(...future.oldOptions)
[17:40:43.605]             if (.Platform$OS.type == "windows") {
[17:40:43.605]                 old_names <- names(...future.oldEnvVars)
[17:40:43.605]                 envs <- base::Sys.getenv()
[17:40:43.605]                 names <- names(envs)
[17:40:43.605]                 common <- intersect(names, old_names)
[17:40:43.605]                 added <- setdiff(names, old_names)
[17:40:43.605]                 removed <- setdiff(old_names, names)
[17:40:43.605]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.605]                   envs[common]]
[17:40:43.605]                 NAMES <- toupper(changed)
[17:40:43.605]                 args <- list()
[17:40:43.605]                 for (kk in seq_along(NAMES)) {
[17:40:43.605]                   name <- changed[[kk]]
[17:40:43.605]                   NAME <- NAMES[[kk]]
[17:40:43.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.605]                     next
[17:40:43.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.605]                 }
[17:40:43.605]                 NAMES <- toupper(added)
[17:40:43.605]                 for (kk in seq_along(NAMES)) {
[17:40:43.605]                   name <- added[[kk]]
[17:40:43.605]                   NAME <- NAMES[[kk]]
[17:40:43.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.605]                     next
[17:40:43.605]                   args[[name]] <- ""
[17:40:43.605]                 }
[17:40:43.605]                 NAMES <- toupper(removed)
[17:40:43.605]                 for (kk in seq_along(NAMES)) {
[17:40:43.605]                   name <- removed[[kk]]
[17:40:43.605]                   NAME <- NAMES[[kk]]
[17:40:43.605]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.605]                     next
[17:40:43.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.605]                 }
[17:40:43.605]                 if (length(args) > 0) 
[17:40:43.605]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.605]             }
[17:40:43.605]             else {
[17:40:43.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.605]             }
[17:40:43.605]             {
[17:40:43.605]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.605]                   0L) {
[17:40:43.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.605]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.605]                   base::options(opts)
[17:40:43.605]                 }
[17:40:43.605]                 {
[17:40:43.605]                   {
[17:40:43.605]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.605]                     NULL
[17:40:43.605]                   }
[17:40:43.605]                   options(future.plan = NULL)
[17:40:43.605]                   if (is.na(NA_character_)) 
[17:40:43.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.605]                     .init = FALSE)
[17:40:43.605]                 }
[17:40:43.605]             }
[17:40:43.605]         }
[17:40:43.605]     })
[17:40:43.605]     if (TRUE) {
[17:40:43.605]         base::sink(type = "output", split = FALSE)
[17:40:43.605]         if (TRUE) {
[17:40:43.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.605]         }
[17:40:43.605]         else {
[17:40:43.605]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.605]         }
[17:40:43.605]         base::close(...future.stdout)
[17:40:43.605]         ...future.stdout <- NULL
[17:40:43.605]     }
[17:40:43.605]     ...future.result$conditions <- ...future.conditions
[17:40:43.605]     ...future.result$finished <- base::Sys.time()
[17:40:43.605]     ...future.result
[17:40:43.605] }
[17:40:43.607] assign_globals() ...
[17:40:43.608] List of 1
[17:40:43.608]  $ kk: int 3
[17:40:43.608]  - attr(*, "where")=List of 1
[17:40:43.608]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.608]  - attr(*, "resolved")= logi FALSE
[17:40:43.608]  - attr(*, "total_size")= num 56
[17:40:43.608]  - attr(*, "already-done")= logi TRUE
[17:40:43.612] - copied ‘kk’ to environment
[17:40:43.612] assign_globals() ... done
[17:40:43.612] requestCore(): workers = 2
[17:40:43.612] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.643] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:40:43.648] plan(): Setting new future strategy stack:
[17:40:43.648] List of future strategies:
[17:40:43.648] 1. multicore:
[17:40:43.648]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.648]    - tweaked: FALSE
[17:40:43.648]    - call: plan(strategy)
[17:40:43.653] plan(): nbrOfWorkers() = 2
[17:40:43.654] result() for MulticoreFuture ...
[17:40:43.655] result() for MulticoreFuture ...
[17:40:43.655] result() for MulticoreFuture ... done
[17:40:43.655] result() for MulticoreFuture ... done
[17:40:43.655] result() for MulticoreFuture ...
[17:40:43.656] result() for MulticoreFuture ... done
[17:40:43.658] MulticoreFuture started
[17:40:43.658] - Launch lazy future ... done
[17:40:43.659] run() for ‘MulticoreFuture’ ... done
[17:40:43.659] resolve() on list ...
[17:40:43.659] plan(): Setting new future strategy stack:
[17:40:43.659]  recursive: 0
[17:40:43.660]  length: 3
[17:40:43.660] 
[17:40:43.660] Future #1
[17:40:43.661]  length: 2 (resolved future 1)
[17:40:43.660] List of future strategies:
[17:40:43.660] 1. sequential:
[17:40:43.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.660]    - tweaked: FALSE
[17:40:43.660]    - call: NULL
[17:40:43.661] plan(): nbrOfWorkers() = 1
[17:40:43.688] plan(): Setting new future strategy stack:
[17:40:43.688] List of future strategies:
[17:40:43.688] 1. multicore:
[17:40:43.688]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.688]    - tweaked: FALSE
[17:40:43.688]    - call: plan(strategy)
[17:40:43.693] plan(): nbrOfWorkers() = 2
[17:40:43.693] Future #2
[17:40:43.693]  length: 1 (resolved future 2)
[17:40:43.764] plan(): Setting new future strategy stack:
[17:40:43.764] List of future strategies:
[17:40:43.764] 1. multicore:
[17:40:43.764]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.764]    - tweaked: FALSE
[17:40:43.764]    - call: plan(strategy)
[17:40:43.771] plan(): nbrOfWorkers() = 2
[17:40:43.775] Future #3
[17:40:43.776]  length: 0 (resolved future 3)
[17:40:43.776] resolve() on list ... DONE
[17:40:43.776] getGlobalsAndPackages() ...
[17:40:43.776] Searching for globals...
[17:40:43.778] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.779] Searching for globals ... DONE
[17:40:43.779] Resolving globals: FALSE
[17:40:43.780] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.780] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.780] - globals: [1] ‘kk’
[17:40:43.781] 
[17:40:43.781] getGlobalsAndPackages() ... DONE
[17:40:43.781] getGlobalsAndPackages() ...
[17:40:43.781] Searching for globals...
[17:40:43.783] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.783] Searching for globals ... DONE
[17:40:43.783] Resolving globals: FALSE
[17:40:43.784] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.784] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.784] - globals: [1] ‘kk’
[17:40:43.784] 
[17:40:43.785] getGlobalsAndPackages() ... DONE
[17:40:43.785] getGlobalsAndPackages() ...
[17:40:43.785] Searching for globals...
[17:40:43.786] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:43.787] Searching for globals ... DONE
[17:40:43.787] Resolving globals: FALSE
[17:40:43.787] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:43.788] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:43.788] - globals: [1] ‘kk’
[17:40:43.788] 
[17:40:43.788] getGlobalsAndPackages() ... DONE
[17:40:43.788] resolve() on list ...
[17:40:43.789]  recursive: 0
[17:40:43.789]  length: 3
[17:40:43.789] 
[17:40:43.789] run() for ‘Future’ ...
[17:40:43.789] - state: ‘created’
[17:40:43.789] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.794] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.794] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.794]   - Field: ‘label’
[17:40:43.794]   - Field: ‘local’
[17:40:43.794]   - Field: ‘owner’
[17:40:43.795]   - Field: ‘envir’
[17:40:43.795]   - Field: ‘workers’
[17:40:43.795]   - Field: ‘packages’
[17:40:43.795]   - Field: ‘gc’
[17:40:43.795]   - Field: ‘job’
[17:40:43.795]   - Field: ‘conditions’
[17:40:43.795]   - Field: ‘expr’
[17:40:43.796]   - Field: ‘uuid’
[17:40:43.796]   - Field: ‘seed’
[17:40:43.796]   - Field: ‘version’
[17:40:43.796]   - Field: ‘result’
[17:40:43.796]   - Field: ‘asynchronous’
[17:40:43.796]   - Field: ‘calls’
[17:40:43.796]   - Field: ‘globals’
[17:40:43.797]   - Field: ‘stdout’
[17:40:43.797]   - Field: ‘earlySignal’
[17:40:43.797]   - Field: ‘lazy’
[17:40:43.797]   - Field: ‘state’
[17:40:43.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.797] - Launch lazy future ...
[17:40:43.798] Packages needed by the future expression (n = 0): <none>
[17:40:43.798] Packages needed by future strategies (n = 0): <none>
[17:40:43.798] {
[17:40:43.798]     {
[17:40:43.798]         {
[17:40:43.798]             ...future.startTime <- base::Sys.time()
[17:40:43.798]             {
[17:40:43.798]                 {
[17:40:43.798]                   {
[17:40:43.798]                     {
[17:40:43.798]                       base::local({
[17:40:43.798]                         has_future <- base::requireNamespace("future", 
[17:40:43.798]                           quietly = TRUE)
[17:40:43.798]                         if (has_future) {
[17:40:43.798]                           ns <- base::getNamespace("future")
[17:40:43.798]                           version <- ns[[".package"]][["version"]]
[17:40:43.798]                           if (is.null(version)) 
[17:40:43.798]                             version <- utils::packageVersion("future")
[17:40:43.798]                         }
[17:40:43.798]                         else {
[17:40:43.798]                           version <- NULL
[17:40:43.798]                         }
[17:40:43.798]                         if (!has_future || version < "1.8.0") {
[17:40:43.798]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.798]                             "", base::R.version$version.string), 
[17:40:43.798]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.798]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.798]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.798]                               "release", "version")], collapse = " "), 
[17:40:43.798]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.798]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.798]                             info)
[17:40:43.798]                           info <- base::paste(info, collapse = "; ")
[17:40:43.798]                           if (!has_future) {
[17:40:43.798]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.798]                               info)
[17:40:43.798]                           }
[17:40:43.798]                           else {
[17:40:43.798]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.798]                               info, version)
[17:40:43.798]                           }
[17:40:43.798]                           base::stop(msg)
[17:40:43.798]                         }
[17:40:43.798]                       })
[17:40:43.798]                     }
[17:40:43.798]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.798]                     base::options(mc.cores = 1L)
[17:40:43.798]                   }
[17:40:43.798]                   ...future.strategy.old <- future::plan("list")
[17:40:43.798]                   options(future.plan = NULL)
[17:40:43.798]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.798]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.798]                 }
[17:40:43.798]                 ...future.workdir <- getwd()
[17:40:43.798]             }
[17:40:43.798]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.798]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.798]         }
[17:40:43.798]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.798]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.798]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.798]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.798]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.798]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.798]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.798]             base::names(...future.oldOptions))
[17:40:43.798]     }
[17:40:43.798]     if (FALSE) {
[17:40:43.798]     }
[17:40:43.798]     else {
[17:40:43.798]         if (TRUE) {
[17:40:43.798]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.798]                 open = "w")
[17:40:43.798]         }
[17:40:43.798]         else {
[17:40:43.798]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.798]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.798]         }
[17:40:43.798]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.798]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.798]             base::sink(type = "output", split = FALSE)
[17:40:43.798]             base::close(...future.stdout)
[17:40:43.798]         }, add = TRUE)
[17:40:43.798]     }
[17:40:43.798]     ...future.frame <- base::sys.nframe()
[17:40:43.798]     ...future.conditions <- base::list()
[17:40:43.798]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.798]     if (FALSE) {
[17:40:43.798]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.798]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.798]     }
[17:40:43.798]     ...future.result <- base::tryCatch({
[17:40:43.798]         base::withCallingHandlers({
[17:40:43.798]             ...future.value <- base::withVisible(base::local({
[17:40:43.798]                 withCallingHandlers({
[17:40:43.798]                   {
[17:40:43.798]                     Sys.sleep(0.1)
[17:40:43.798]                     kk
[17:40:43.798]                   }
[17:40:43.798]                 }, immediateCondition = function(cond) {
[17:40:43.798]                   save_rds <- function (object, pathname, ...) 
[17:40:43.798]                   {
[17:40:43.798]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.798]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.798]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.798]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.798]                         fi_tmp[["mtime"]])
[17:40:43.798]                     }
[17:40:43.798]                     tryCatch({
[17:40:43.798]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.798]                     }, error = function(ex) {
[17:40:43.798]                       msg <- conditionMessage(ex)
[17:40:43.798]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.798]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.798]                         fi_tmp[["mtime"]], msg)
[17:40:43.798]                       ex$message <- msg
[17:40:43.798]                       stop(ex)
[17:40:43.798]                     })
[17:40:43.798]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.798]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.798]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.798]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.798]                       fi <- file.info(pathname)
[17:40:43.798]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.798]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.798]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.798]                         fi[["size"]], fi[["mtime"]])
[17:40:43.798]                       stop(msg)
[17:40:43.798]                     }
[17:40:43.798]                     invisible(pathname)
[17:40:43.798]                   }
[17:40:43.798]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.798]                     rootPath = tempdir()) 
[17:40:43.798]                   {
[17:40:43.798]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.798]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.798]                       tmpdir = path, fileext = ".rds")
[17:40:43.798]                     save_rds(obj, file)
[17:40:43.798]                   }
[17:40:43.798]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.798]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.798]                   {
[17:40:43.798]                     inherits <- base::inherits
[17:40:43.798]                     invokeRestart <- base::invokeRestart
[17:40:43.798]                     is.null <- base::is.null
[17:40:43.798]                     muffled <- FALSE
[17:40:43.798]                     if (inherits(cond, "message")) {
[17:40:43.798]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.798]                       if (muffled) 
[17:40:43.798]                         invokeRestart("muffleMessage")
[17:40:43.798]                     }
[17:40:43.798]                     else if (inherits(cond, "warning")) {
[17:40:43.798]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.798]                       if (muffled) 
[17:40:43.798]                         invokeRestart("muffleWarning")
[17:40:43.798]                     }
[17:40:43.798]                     else if (inherits(cond, "condition")) {
[17:40:43.798]                       if (!is.null(pattern)) {
[17:40:43.798]                         computeRestarts <- base::computeRestarts
[17:40:43.798]                         grepl <- base::grepl
[17:40:43.798]                         restarts <- computeRestarts(cond)
[17:40:43.798]                         for (restart in restarts) {
[17:40:43.798]                           name <- restart$name
[17:40:43.798]                           if (is.null(name)) 
[17:40:43.798]                             next
[17:40:43.798]                           if (!grepl(pattern, name)) 
[17:40:43.798]                             next
[17:40:43.798]                           invokeRestart(restart)
[17:40:43.798]                           muffled <- TRUE
[17:40:43.798]                           break
[17:40:43.798]                         }
[17:40:43.798]                       }
[17:40:43.798]                     }
[17:40:43.798]                     invisible(muffled)
[17:40:43.798]                   }
[17:40:43.798]                   muffleCondition(cond)
[17:40:43.798]                 })
[17:40:43.798]             }))
[17:40:43.798]             future::FutureResult(value = ...future.value$value, 
[17:40:43.798]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.798]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.798]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.798]                     ...future.globalenv.names))
[17:40:43.798]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.798]         }, condition = base::local({
[17:40:43.798]             c <- base::c
[17:40:43.798]             inherits <- base::inherits
[17:40:43.798]             invokeRestart <- base::invokeRestart
[17:40:43.798]             length <- base::length
[17:40:43.798]             list <- base::list
[17:40:43.798]             seq.int <- base::seq.int
[17:40:43.798]             signalCondition <- base::signalCondition
[17:40:43.798]             sys.calls <- base::sys.calls
[17:40:43.798]             `[[` <- base::`[[`
[17:40:43.798]             `+` <- base::`+`
[17:40:43.798]             `<<-` <- base::`<<-`
[17:40:43.798]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.798]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.798]                   3L)]
[17:40:43.798]             }
[17:40:43.798]             function(cond) {
[17:40:43.798]                 is_error <- inherits(cond, "error")
[17:40:43.798]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.798]                   NULL)
[17:40:43.798]                 if (is_error) {
[17:40:43.798]                   sessionInformation <- function() {
[17:40:43.798]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.798]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.798]                       search = base::search(), system = base::Sys.info())
[17:40:43.798]                   }
[17:40:43.798]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.798]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.798]                     cond$call), session = sessionInformation(), 
[17:40:43.798]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.798]                   signalCondition(cond)
[17:40:43.798]                 }
[17:40:43.798]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.798]                 "immediateCondition"))) {
[17:40:43.798]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.798]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.798]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.798]                   if (TRUE && !signal) {
[17:40:43.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.798]                     {
[17:40:43.798]                       inherits <- base::inherits
[17:40:43.798]                       invokeRestart <- base::invokeRestart
[17:40:43.798]                       is.null <- base::is.null
[17:40:43.798]                       muffled <- FALSE
[17:40:43.798]                       if (inherits(cond, "message")) {
[17:40:43.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.798]                         if (muffled) 
[17:40:43.798]                           invokeRestart("muffleMessage")
[17:40:43.798]                       }
[17:40:43.798]                       else if (inherits(cond, "warning")) {
[17:40:43.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.798]                         if (muffled) 
[17:40:43.798]                           invokeRestart("muffleWarning")
[17:40:43.798]                       }
[17:40:43.798]                       else if (inherits(cond, "condition")) {
[17:40:43.798]                         if (!is.null(pattern)) {
[17:40:43.798]                           computeRestarts <- base::computeRestarts
[17:40:43.798]                           grepl <- base::grepl
[17:40:43.798]                           restarts <- computeRestarts(cond)
[17:40:43.798]                           for (restart in restarts) {
[17:40:43.798]                             name <- restart$name
[17:40:43.798]                             if (is.null(name)) 
[17:40:43.798]                               next
[17:40:43.798]                             if (!grepl(pattern, name)) 
[17:40:43.798]                               next
[17:40:43.798]                             invokeRestart(restart)
[17:40:43.798]                             muffled <- TRUE
[17:40:43.798]                             break
[17:40:43.798]                           }
[17:40:43.798]                         }
[17:40:43.798]                       }
[17:40:43.798]                       invisible(muffled)
[17:40:43.798]                     }
[17:40:43.798]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.798]                   }
[17:40:43.798]                 }
[17:40:43.798]                 else {
[17:40:43.798]                   if (TRUE) {
[17:40:43.798]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.798]                     {
[17:40:43.798]                       inherits <- base::inherits
[17:40:43.798]                       invokeRestart <- base::invokeRestart
[17:40:43.798]                       is.null <- base::is.null
[17:40:43.798]                       muffled <- FALSE
[17:40:43.798]                       if (inherits(cond, "message")) {
[17:40:43.798]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.798]                         if (muffled) 
[17:40:43.798]                           invokeRestart("muffleMessage")
[17:40:43.798]                       }
[17:40:43.798]                       else if (inherits(cond, "warning")) {
[17:40:43.798]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.798]                         if (muffled) 
[17:40:43.798]                           invokeRestart("muffleWarning")
[17:40:43.798]                       }
[17:40:43.798]                       else if (inherits(cond, "condition")) {
[17:40:43.798]                         if (!is.null(pattern)) {
[17:40:43.798]                           computeRestarts <- base::computeRestarts
[17:40:43.798]                           grepl <- base::grepl
[17:40:43.798]                           restarts <- computeRestarts(cond)
[17:40:43.798]                           for (restart in restarts) {
[17:40:43.798]                             name <- restart$name
[17:40:43.798]                             if (is.null(name)) 
[17:40:43.798]                               next
[17:40:43.798]                             if (!grepl(pattern, name)) 
[17:40:43.798]                               next
[17:40:43.798]                             invokeRestart(restart)
[17:40:43.798]                             muffled <- TRUE
[17:40:43.798]                             break
[17:40:43.798]                           }
[17:40:43.798]                         }
[17:40:43.798]                       }
[17:40:43.798]                       invisible(muffled)
[17:40:43.798]                     }
[17:40:43.798]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.798]                   }
[17:40:43.798]                 }
[17:40:43.798]             }
[17:40:43.798]         }))
[17:40:43.798]     }, error = function(ex) {
[17:40:43.798]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.798]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.798]                 ...future.rng), started = ...future.startTime, 
[17:40:43.798]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.798]             version = "1.8"), class = "FutureResult")
[17:40:43.798]     }, finally = {
[17:40:43.798]         if (!identical(...future.workdir, getwd())) 
[17:40:43.798]             setwd(...future.workdir)
[17:40:43.798]         {
[17:40:43.798]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.798]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.798]             }
[17:40:43.798]             base::options(...future.oldOptions)
[17:40:43.798]             if (.Platform$OS.type == "windows") {
[17:40:43.798]                 old_names <- names(...future.oldEnvVars)
[17:40:43.798]                 envs <- base::Sys.getenv()
[17:40:43.798]                 names <- names(envs)
[17:40:43.798]                 common <- intersect(names, old_names)
[17:40:43.798]                 added <- setdiff(names, old_names)
[17:40:43.798]                 removed <- setdiff(old_names, names)
[17:40:43.798]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.798]                   envs[common]]
[17:40:43.798]                 NAMES <- toupper(changed)
[17:40:43.798]                 args <- list()
[17:40:43.798]                 for (kk in seq_along(NAMES)) {
[17:40:43.798]                   name <- changed[[kk]]
[17:40:43.798]                   NAME <- NAMES[[kk]]
[17:40:43.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.798]                     next
[17:40:43.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.798]                 }
[17:40:43.798]                 NAMES <- toupper(added)
[17:40:43.798]                 for (kk in seq_along(NAMES)) {
[17:40:43.798]                   name <- added[[kk]]
[17:40:43.798]                   NAME <- NAMES[[kk]]
[17:40:43.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.798]                     next
[17:40:43.798]                   args[[name]] <- ""
[17:40:43.798]                 }
[17:40:43.798]                 NAMES <- toupper(removed)
[17:40:43.798]                 for (kk in seq_along(NAMES)) {
[17:40:43.798]                   name <- removed[[kk]]
[17:40:43.798]                   NAME <- NAMES[[kk]]
[17:40:43.798]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.798]                     next
[17:40:43.798]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.798]                 }
[17:40:43.798]                 if (length(args) > 0) 
[17:40:43.798]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.798]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.798]             }
[17:40:43.798]             else {
[17:40:43.798]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.798]             }
[17:40:43.798]             {
[17:40:43.798]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.798]                   0L) {
[17:40:43.798]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.798]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.798]                   base::options(opts)
[17:40:43.798]                 }
[17:40:43.798]                 {
[17:40:43.798]                   {
[17:40:43.798]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.798]                     NULL
[17:40:43.798]                   }
[17:40:43.798]                   options(future.plan = NULL)
[17:40:43.798]                   if (is.na(NA_character_)) 
[17:40:43.798]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.798]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.798]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.798]                     .init = FALSE)
[17:40:43.798]                 }
[17:40:43.798]             }
[17:40:43.798]         }
[17:40:43.798]     })
[17:40:43.798]     if (TRUE) {
[17:40:43.798]         base::sink(type = "output", split = FALSE)
[17:40:43.798]         if (TRUE) {
[17:40:43.798]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.798]         }
[17:40:43.798]         else {
[17:40:43.798]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.798]         }
[17:40:43.798]         base::close(...future.stdout)
[17:40:43.798]         ...future.stdout <- NULL
[17:40:43.798]     }
[17:40:43.798]     ...future.result$conditions <- ...future.conditions
[17:40:43.798]     ...future.result$finished <- base::Sys.time()
[17:40:43.798]     ...future.result
[17:40:43.798] }
[17:40:43.802] assign_globals() ...
[17:40:43.802] List of 1
[17:40:43.802]  $ kk: int 1
[17:40:43.802]  - attr(*, "where")=List of 1
[17:40:43.802]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.802]  - attr(*, "resolved")= logi FALSE
[17:40:43.802]  - attr(*, "total_size")= num 56
[17:40:43.802]  - attr(*, "already-done")= logi TRUE
[17:40:43.806] - copied ‘kk’ to environment
[17:40:43.806] assign_globals() ... done
[17:40:43.808] requestCore(): workers = 2
[17:40:43.809] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.820] result() for MulticoreFuture ...
[17:40:43.821] result() for MulticoreFuture ...
[17:40:43.821] result() for MulticoreFuture ... done
[17:40:43.821] result() for MulticoreFuture ... done
[17:40:43.821] result() for MulticoreFuture ...
[17:40:43.821] result() for MulticoreFuture ... done
[17:40:43.824] MulticoreFuture started
[17:40:43.825] - Launch lazy future ... done
[17:40:43.825] run() for ‘MulticoreFuture’ ... done
[17:40:43.826] plan(): Setting new future strategy stack:
[17:40:43.826] List of future strategies:
[17:40:43.826] 1. sequential:
[17:40:43.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.826]    - tweaked: FALSE
[17:40:43.826]    - call: NULL
[17:40:43.827] plan(): nbrOfWorkers() = 1
[17:40:43.836] run() for ‘Future’ ...
[17:40:43.837] - state: ‘created’
[17:40:43.837] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.843] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.844] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.844]   - Field: ‘label’
[17:40:43.844]   - Field: ‘local’
[17:40:43.844]   - Field: ‘owner’
[17:40:43.845]   - Field: ‘envir’
[17:40:43.845]   - Field: ‘workers’
[17:40:43.845]   - Field: ‘packages’
[17:40:43.845]   - Field: ‘gc’
[17:40:43.845]   - Field: ‘job’
[17:40:43.845]   - Field: ‘conditions’
[17:40:43.846]   - Field: ‘expr’
[17:40:43.846]   - Field: ‘uuid’
[17:40:43.846]   - Field: ‘seed’
[17:40:43.846]   - Field: ‘version’
[17:40:43.846]   - Field: ‘result’
[17:40:43.846]   - Field: ‘asynchronous’
[17:40:43.847]   - Field: ‘calls’
[17:40:43.847]   - Field: ‘globals’
[17:40:43.847]   - Field: ‘stdout’
[17:40:43.847]   - Field: ‘earlySignal’
[17:40:43.847]   - Field: ‘lazy’
[17:40:43.847]   - Field: ‘state’
[17:40:43.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.848] - Launch lazy future ...
[17:40:43.848] Packages needed by the future expression (n = 0): <none>
[17:40:43.849] Packages needed by future strategies (n = 0): <none>
[17:40:43.849] {
[17:40:43.849]     {
[17:40:43.849]         {
[17:40:43.849]             ...future.startTime <- base::Sys.time()
[17:40:43.849]             {
[17:40:43.849]                 {
[17:40:43.849]                   {
[17:40:43.849]                     {
[17:40:43.849]                       base::local({
[17:40:43.849]                         has_future <- base::requireNamespace("future", 
[17:40:43.849]                           quietly = TRUE)
[17:40:43.849]                         if (has_future) {
[17:40:43.849]                           ns <- base::getNamespace("future")
[17:40:43.849]                           version <- ns[[".package"]][["version"]]
[17:40:43.849]                           if (is.null(version)) 
[17:40:43.849]                             version <- utils::packageVersion("future")
[17:40:43.849]                         }
[17:40:43.849]                         else {
[17:40:43.849]                           version <- NULL
[17:40:43.849]                         }
[17:40:43.849]                         if (!has_future || version < "1.8.0") {
[17:40:43.849]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.849]                             "", base::R.version$version.string), 
[17:40:43.849]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.849]                               "release", "version")], collapse = " "), 
[17:40:43.849]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.849]                             info)
[17:40:43.849]                           info <- base::paste(info, collapse = "; ")
[17:40:43.849]                           if (!has_future) {
[17:40:43.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.849]                               info)
[17:40:43.849]                           }
[17:40:43.849]                           else {
[17:40:43.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.849]                               info, version)
[17:40:43.849]                           }
[17:40:43.849]                           base::stop(msg)
[17:40:43.849]                         }
[17:40:43.849]                       })
[17:40:43.849]                     }
[17:40:43.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.849]                     base::options(mc.cores = 1L)
[17:40:43.849]                   }
[17:40:43.849]                   ...future.strategy.old <- future::plan("list")
[17:40:43.849]                   options(future.plan = NULL)
[17:40:43.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.849]                 }
[17:40:43.849]                 ...future.workdir <- getwd()
[17:40:43.849]             }
[17:40:43.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.849]         }
[17:40:43.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.849]             base::names(...future.oldOptions))
[17:40:43.849]     }
[17:40:43.849]     if (FALSE) {
[17:40:43.849]     }
[17:40:43.849]     else {
[17:40:43.849]         if (TRUE) {
[17:40:43.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.849]                 open = "w")
[17:40:43.849]         }
[17:40:43.849]         else {
[17:40:43.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.849]         }
[17:40:43.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.849]             base::sink(type = "output", split = FALSE)
[17:40:43.849]             base::close(...future.stdout)
[17:40:43.849]         }, add = TRUE)
[17:40:43.849]     }
[17:40:43.849]     ...future.frame <- base::sys.nframe()
[17:40:43.849]     ...future.conditions <- base::list()
[17:40:43.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.849]     if (FALSE) {
[17:40:43.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.849]     }
[17:40:43.849]     ...future.result <- base::tryCatch({
[17:40:43.849]         base::withCallingHandlers({
[17:40:43.849]             ...future.value <- base::withVisible(base::local({
[17:40:43.849]                 withCallingHandlers({
[17:40:43.849]                   {
[17:40:43.849]                     Sys.sleep(0.1)
[17:40:43.849]                     kk
[17:40:43.849]                   }
[17:40:43.849]                 }, immediateCondition = function(cond) {
[17:40:43.849]                   save_rds <- function (object, pathname, ...) 
[17:40:43.849]                   {
[17:40:43.849]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.849]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.849]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.849]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.849]                         fi_tmp[["mtime"]])
[17:40:43.849]                     }
[17:40:43.849]                     tryCatch({
[17:40:43.849]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.849]                     }, error = function(ex) {
[17:40:43.849]                       msg <- conditionMessage(ex)
[17:40:43.849]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.849]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.849]                         fi_tmp[["mtime"]], msg)
[17:40:43.849]                       ex$message <- msg
[17:40:43.849]                       stop(ex)
[17:40:43.849]                     })
[17:40:43.849]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.849]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.849]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.849]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.849]                       fi <- file.info(pathname)
[17:40:43.849]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.849]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.849]                         fi[["size"]], fi[["mtime"]])
[17:40:43.849]                       stop(msg)
[17:40:43.849]                     }
[17:40:43.849]                     invisible(pathname)
[17:40:43.849]                   }
[17:40:43.849]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.849]                     rootPath = tempdir()) 
[17:40:43.849]                   {
[17:40:43.849]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.849]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.849]                       tmpdir = path, fileext = ".rds")
[17:40:43.849]                     save_rds(obj, file)
[17:40:43.849]                   }
[17:40:43.849]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.849]                   {
[17:40:43.849]                     inherits <- base::inherits
[17:40:43.849]                     invokeRestart <- base::invokeRestart
[17:40:43.849]                     is.null <- base::is.null
[17:40:43.849]                     muffled <- FALSE
[17:40:43.849]                     if (inherits(cond, "message")) {
[17:40:43.849]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.849]                       if (muffled) 
[17:40:43.849]                         invokeRestart("muffleMessage")
[17:40:43.849]                     }
[17:40:43.849]                     else if (inherits(cond, "warning")) {
[17:40:43.849]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.849]                       if (muffled) 
[17:40:43.849]                         invokeRestart("muffleWarning")
[17:40:43.849]                     }
[17:40:43.849]                     else if (inherits(cond, "condition")) {
[17:40:43.849]                       if (!is.null(pattern)) {
[17:40:43.849]                         computeRestarts <- base::computeRestarts
[17:40:43.849]                         grepl <- base::grepl
[17:40:43.849]                         restarts <- computeRestarts(cond)
[17:40:43.849]                         for (restart in restarts) {
[17:40:43.849]                           name <- restart$name
[17:40:43.849]                           if (is.null(name)) 
[17:40:43.849]                             next
[17:40:43.849]                           if (!grepl(pattern, name)) 
[17:40:43.849]                             next
[17:40:43.849]                           invokeRestart(restart)
[17:40:43.849]                           muffled <- TRUE
[17:40:43.849]                           break
[17:40:43.849]                         }
[17:40:43.849]                       }
[17:40:43.849]                     }
[17:40:43.849]                     invisible(muffled)
[17:40:43.849]                   }
[17:40:43.849]                   muffleCondition(cond)
[17:40:43.849]                 })
[17:40:43.849]             }))
[17:40:43.849]             future::FutureResult(value = ...future.value$value, 
[17:40:43.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.849]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.849]                     ...future.globalenv.names))
[17:40:43.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.849]         }, condition = base::local({
[17:40:43.849]             c <- base::c
[17:40:43.849]             inherits <- base::inherits
[17:40:43.849]             invokeRestart <- base::invokeRestart
[17:40:43.849]             length <- base::length
[17:40:43.849]             list <- base::list
[17:40:43.849]             seq.int <- base::seq.int
[17:40:43.849]             signalCondition <- base::signalCondition
[17:40:43.849]             sys.calls <- base::sys.calls
[17:40:43.849]             `[[` <- base::`[[`
[17:40:43.849]             `+` <- base::`+`
[17:40:43.849]             `<<-` <- base::`<<-`
[17:40:43.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.849]                   3L)]
[17:40:43.849]             }
[17:40:43.849]             function(cond) {
[17:40:43.849]                 is_error <- inherits(cond, "error")
[17:40:43.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.849]                   NULL)
[17:40:43.849]                 if (is_error) {
[17:40:43.849]                   sessionInformation <- function() {
[17:40:43.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.849]                       search = base::search(), system = base::Sys.info())
[17:40:43.849]                   }
[17:40:43.849]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.849]                     cond$call), session = sessionInformation(), 
[17:40:43.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.849]                   signalCondition(cond)
[17:40:43.849]                 }
[17:40:43.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.849]                 "immediateCondition"))) {
[17:40:43.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.849]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.849]                   if (TRUE && !signal) {
[17:40:43.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.849]                     {
[17:40:43.849]                       inherits <- base::inherits
[17:40:43.849]                       invokeRestart <- base::invokeRestart
[17:40:43.849]                       is.null <- base::is.null
[17:40:43.849]                       muffled <- FALSE
[17:40:43.849]                       if (inherits(cond, "message")) {
[17:40:43.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.849]                         if (muffled) 
[17:40:43.849]                           invokeRestart("muffleMessage")
[17:40:43.849]                       }
[17:40:43.849]                       else if (inherits(cond, "warning")) {
[17:40:43.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.849]                         if (muffled) 
[17:40:43.849]                           invokeRestart("muffleWarning")
[17:40:43.849]                       }
[17:40:43.849]                       else if (inherits(cond, "condition")) {
[17:40:43.849]                         if (!is.null(pattern)) {
[17:40:43.849]                           computeRestarts <- base::computeRestarts
[17:40:43.849]                           grepl <- base::grepl
[17:40:43.849]                           restarts <- computeRestarts(cond)
[17:40:43.849]                           for (restart in restarts) {
[17:40:43.849]                             name <- restart$name
[17:40:43.849]                             if (is.null(name)) 
[17:40:43.849]                               next
[17:40:43.849]                             if (!grepl(pattern, name)) 
[17:40:43.849]                               next
[17:40:43.849]                             invokeRestart(restart)
[17:40:43.849]                             muffled <- TRUE
[17:40:43.849]                             break
[17:40:43.849]                           }
[17:40:43.849]                         }
[17:40:43.849]                       }
[17:40:43.849]                       invisible(muffled)
[17:40:43.849]                     }
[17:40:43.849]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.849]                   }
[17:40:43.849]                 }
[17:40:43.849]                 else {
[17:40:43.849]                   if (TRUE) {
[17:40:43.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.849]                     {
[17:40:43.849]                       inherits <- base::inherits
[17:40:43.849]                       invokeRestart <- base::invokeRestart
[17:40:43.849]                       is.null <- base::is.null
[17:40:43.849]                       muffled <- FALSE
[17:40:43.849]                       if (inherits(cond, "message")) {
[17:40:43.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.849]                         if (muffled) 
[17:40:43.849]                           invokeRestart("muffleMessage")
[17:40:43.849]                       }
[17:40:43.849]                       else if (inherits(cond, "warning")) {
[17:40:43.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.849]                         if (muffled) 
[17:40:43.849]                           invokeRestart("muffleWarning")
[17:40:43.849]                       }
[17:40:43.849]                       else if (inherits(cond, "condition")) {
[17:40:43.849]                         if (!is.null(pattern)) {
[17:40:43.849]                           computeRestarts <- base::computeRestarts
[17:40:43.849]                           grepl <- base::grepl
[17:40:43.849]                           restarts <- computeRestarts(cond)
[17:40:43.849]                           for (restart in restarts) {
[17:40:43.849]                             name <- restart$name
[17:40:43.849]                             if (is.null(name)) 
[17:40:43.849]                               next
[17:40:43.849]                             if (!grepl(pattern, name)) 
[17:40:43.849]                               next
[17:40:43.849]                             invokeRestart(restart)
[17:40:43.849]                             muffled <- TRUE
[17:40:43.849]                             break
[17:40:43.849]                           }
[17:40:43.849]                         }
[17:40:43.849]                       }
[17:40:43.849]                       invisible(muffled)
[17:40:43.849]                     }
[17:40:43.849]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.849]                   }
[17:40:43.849]                 }
[17:40:43.849]             }
[17:40:43.849]         }))
[17:40:43.849]     }, error = function(ex) {
[17:40:43.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.849]                 ...future.rng), started = ...future.startTime, 
[17:40:43.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.849]             version = "1.8"), class = "FutureResult")
[17:40:43.849]     }, finally = {
[17:40:43.849]         if (!identical(...future.workdir, getwd())) 
[17:40:43.849]             setwd(...future.workdir)
[17:40:43.849]         {
[17:40:43.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.849]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.849]             }
[17:40:43.849]             base::options(...future.oldOptions)
[17:40:43.849]             if (.Platform$OS.type == "windows") {
[17:40:43.849]                 old_names <- names(...future.oldEnvVars)
[17:40:43.849]                 envs <- base::Sys.getenv()
[17:40:43.849]                 names <- names(envs)
[17:40:43.849]                 common <- intersect(names, old_names)
[17:40:43.849]                 added <- setdiff(names, old_names)
[17:40:43.849]                 removed <- setdiff(old_names, names)
[17:40:43.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.849]                   envs[common]]
[17:40:43.849]                 NAMES <- toupper(changed)
[17:40:43.849]                 args <- list()
[17:40:43.849]                 for (kk in seq_along(NAMES)) {
[17:40:43.849]                   name <- changed[[kk]]
[17:40:43.849]                   NAME <- NAMES[[kk]]
[17:40:43.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.849]                     next
[17:40:43.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.849]                 }
[17:40:43.849]                 NAMES <- toupper(added)
[17:40:43.849]                 for (kk in seq_along(NAMES)) {
[17:40:43.849]                   name <- added[[kk]]
[17:40:43.849]                   NAME <- NAMES[[kk]]
[17:40:43.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.849]                     next
[17:40:43.849]                   args[[name]] <- ""
[17:40:43.849]                 }
[17:40:43.849]                 NAMES <- toupper(removed)
[17:40:43.849]                 for (kk in seq_along(NAMES)) {
[17:40:43.849]                   name <- removed[[kk]]
[17:40:43.849]                   NAME <- NAMES[[kk]]
[17:40:43.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.849]                     next
[17:40:43.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.849]                 }
[17:40:43.849]                 if (length(args) > 0) 
[17:40:43.849]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.849]             }
[17:40:43.849]             else {
[17:40:43.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.849]             }
[17:40:43.849]             {
[17:40:43.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.849]                   0L) {
[17:40:43.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.849]                   base::options(opts)
[17:40:43.849]                 }
[17:40:43.849]                 {
[17:40:43.849]                   {
[17:40:43.849]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.849]                     NULL
[17:40:43.849]                   }
[17:40:43.849]                   options(future.plan = NULL)
[17:40:43.849]                   if (is.na(NA_character_)) 
[17:40:43.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.849]                     .init = FALSE)
[17:40:43.849]                 }
[17:40:43.849]             }
[17:40:43.849]         }
[17:40:43.849]     })
[17:40:43.849]     if (TRUE) {
[17:40:43.849]         base::sink(type = "output", split = FALSE)
[17:40:43.849]         if (TRUE) {
[17:40:43.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.849]         }
[17:40:43.849]         else {
[17:40:43.849]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.849]         }
[17:40:43.849]         base::close(...future.stdout)
[17:40:43.849]         ...future.stdout <- NULL
[17:40:43.849]     }
[17:40:43.849]     ...future.result$conditions <- ...future.conditions
[17:40:43.849]     ...future.result$finished <- base::Sys.time()
[17:40:43.849]     ...future.result
[17:40:43.849] }
[17:40:43.853] assign_globals() ...
[17:40:43.853] List of 1
[17:40:43.853]  $ kk: int 2
[17:40:43.853]  - attr(*, "where")=List of 1
[17:40:43.853]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.853]  - attr(*, "resolved")= logi FALSE
[17:40:43.853]  - attr(*, "total_size")= num 56
[17:40:43.853]  - attr(*, "already-done")= logi TRUE
[17:40:43.857] - copied ‘kk’ to environment
[17:40:43.857] assign_globals() ... done
[17:40:43.857] requestCore(): workers = 2
[17:40:43.858] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.868] result() for MulticoreFuture ...
[17:40:43.869] result() for MulticoreFuture ...
[17:40:43.869] result() for MulticoreFuture ... done
[17:40:43.870] result() for MulticoreFuture ... done
[17:40:43.870] result() for MulticoreFuture ...
[17:40:43.870] result() for MulticoreFuture ... done
[17:40:43.872] MulticoreFuture started
[17:40:43.873] - Launch lazy future ... done
[17:40:43.873] run() for ‘MulticoreFuture’ ... done
[17:40:43.873] plan(): Setting new future strategy stack:
[17:40:43.874] List of future strategies:
[17:40:43.874] 1. sequential:
[17:40:43.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.874]    - tweaked: FALSE
[17:40:43.874]    - call: NULL
[17:40:43.875] plan(): nbrOfWorkers() = 1
[17:40:43.884] run() for ‘Future’ ...
[17:40:43.884] - state: ‘created’
[17:40:43.884] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:43.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:43.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:43.890]   - Field: ‘label’
[17:40:43.890]   - Field: ‘local’
[17:40:43.890]   - Field: ‘owner’
[17:40:43.891]   - Field: ‘envir’
[17:40:43.891]   - Field: ‘workers’
[17:40:43.891]   - Field: ‘packages’
[17:40:43.891]   - Field: ‘gc’
[17:40:43.891]   - Field: ‘job’
[17:40:43.891]   - Field: ‘conditions’
[17:40:43.891]   - Field: ‘expr’
[17:40:43.892]   - Field: ‘uuid’
[17:40:43.892]   - Field: ‘seed’
[17:40:43.892]   - Field: ‘version’
[17:40:43.892]   - Field: ‘result’
[17:40:43.892]   - Field: ‘asynchronous’
[17:40:43.892]   - Field: ‘calls’
[17:40:43.893]   - Field: ‘globals’
[17:40:43.893]   - Field: ‘stdout’
[17:40:43.893]   - Field: ‘earlySignal’
[17:40:43.893]   - Field: ‘lazy’
[17:40:43.893]   - Field: ‘state’
[17:40:43.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:43.893] - Launch lazy future ...
[17:40:43.894] Packages needed by the future expression (n = 0): <none>
[17:40:43.894] Packages needed by future strategies (n = 0): <none>
[17:40:43.895] {
[17:40:43.895]     {
[17:40:43.895]         {
[17:40:43.895]             ...future.startTime <- base::Sys.time()
[17:40:43.895]             {
[17:40:43.895]                 {
[17:40:43.895]                   {
[17:40:43.895]                     {
[17:40:43.895]                       base::local({
[17:40:43.895]                         has_future <- base::requireNamespace("future", 
[17:40:43.895]                           quietly = TRUE)
[17:40:43.895]                         if (has_future) {
[17:40:43.895]                           ns <- base::getNamespace("future")
[17:40:43.895]                           version <- ns[[".package"]][["version"]]
[17:40:43.895]                           if (is.null(version)) 
[17:40:43.895]                             version <- utils::packageVersion("future")
[17:40:43.895]                         }
[17:40:43.895]                         else {
[17:40:43.895]                           version <- NULL
[17:40:43.895]                         }
[17:40:43.895]                         if (!has_future || version < "1.8.0") {
[17:40:43.895]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:43.895]                             "", base::R.version$version.string), 
[17:40:43.895]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:43.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:43.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:43.895]                               "release", "version")], collapse = " "), 
[17:40:43.895]                             hostname = base::Sys.info()[["nodename"]])
[17:40:43.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:43.895]                             info)
[17:40:43.895]                           info <- base::paste(info, collapse = "; ")
[17:40:43.895]                           if (!has_future) {
[17:40:43.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:43.895]                               info)
[17:40:43.895]                           }
[17:40:43.895]                           else {
[17:40:43.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:43.895]                               info, version)
[17:40:43.895]                           }
[17:40:43.895]                           base::stop(msg)
[17:40:43.895]                         }
[17:40:43.895]                       })
[17:40:43.895]                     }
[17:40:43.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:43.895]                     base::options(mc.cores = 1L)
[17:40:43.895]                   }
[17:40:43.895]                   ...future.strategy.old <- future::plan("list")
[17:40:43.895]                   options(future.plan = NULL)
[17:40:43.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:43.895]                 }
[17:40:43.895]                 ...future.workdir <- getwd()
[17:40:43.895]             }
[17:40:43.895]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:43.895]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:43.895]         }
[17:40:43.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:43.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:43.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:43.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:43.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:43.895]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:43.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:43.895]             base::names(...future.oldOptions))
[17:40:43.895]     }
[17:40:43.895]     if (FALSE) {
[17:40:43.895]     }
[17:40:43.895]     else {
[17:40:43.895]         if (TRUE) {
[17:40:43.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:43.895]                 open = "w")
[17:40:43.895]         }
[17:40:43.895]         else {
[17:40:43.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:43.895]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:43.895]         }
[17:40:43.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:43.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:43.895]             base::sink(type = "output", split = FALSE)
[17:40:43.895]             base::close(...future.stdout)
[17:40:43.895]         }, add = TRUE)
[17:40:43.895]     }
[17:40:43.895]     ...future.frame <- base::sys.nframe()
[17:40:43.895]     ...future.conditions <- base::list()
[17:40:43.895]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:43.895]     if (FALSE) {
[17:40:43.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:43.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:43.895]     }
[17:40:43.895]     ...future.result <- base::tryCatch({
[17:40:43.895]         base::withCallingHandlers({
[17:40:43.895]             ...future.value <- base::withVisible(base::local({
[17:40:43.895]                 withCallingHandlers({
[17:40:43.895]                   {
[17:40:43.895]                     Sys.sleep(0.1)
[17:40:43.895]                     kk
[17:40:43.895]                   }
[17:40:43.895]                 }, immediateCondition = function(cond) {
[17:40:43.895]                   save_rds <- function (object, pathname, ...) 
[17:40:43.895]                   {
[17:40:43.895]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:43.895]                     if (file_test("-f", pathname_tmp)) {
[17:40:43.895]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.895]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:43.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.895]                         fi_tmp[["mtime"]])
[17:40:43.895]                     }
[17:40:43.895]                     tryCatch({
[17:40:43.895]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:43.895]                     }, error = function(ex) {
[17:40:43.895]                       msg <- conditionMessage(ex)
[17:40:43.895]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.895]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:43.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.895]                         fi_tmp[["mtime"]], msg)
[17:40:43.895]                       ex$message <- msg
[17:40:43.895]                       stop(ex)
[17:40:43.895]                     })
[17:40:43.895]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:43.895]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:43.895]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:43.895]                       fi_tmp <- file.info(pathname_tmp)
[17:40:43.895]                       fi <- file.info(pathname)
[17:40:43.895]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:43.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:43.895]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:43.895]                         fi[["size"]], fi[["mtime"]])
[17:40:43.895]                       stop(msg)
[17:40:43.895]                     }
[17:40:43.895]                     invisible(pathname)
[17:40:43.895]                   }
[17:40:43.895]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:43.895]                     rootPath = tempdir()) 
[17:40:43.895]                   {
[17:40:43.895]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:43.895]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:43.895]                       tmpdir = path, fileext = ".rds")
[17:40:43.895]                     save_rds(obj, file)
[17:40:43.895]                   }
[17:40:43.895]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:43.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.895]                   {
[17:40:43.895]                     inherits <- base::inherits
[17:40:43.895]                     invokeRestart <- base::invokeRestart
[17:40:43.895]                     is.null <- base::is.null
[17:40:43.895]                     muffled <- FALSE
[17:40:43.895]                     if (inherits(cond, "message")) {
[17:40:43.895]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:43.895]                       if (muffled) 
[17:40:43.895]                         invokeRestart("muffleMessage")
[17:40:43.895]                     }
[17:40:43.895]                     else if (inherits(cond, "warning")) {
[17:40:43.895]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:43.895]                       if (muffled) 
[17:40:43.895]                         invokeRestart("muffleWarning")
[17:40:43.895]                     }
[17:40:43.895]                     else if (inherits(cond, "condition")) {
[17:40:43.895]                       if (!is.null(pattern)) {
[17:40:43.895]                         computeRestarts <- base::computeRestarts
[17:40:43.895]                         grepl <- base::grepl
[17:40:43.895]                         restarts <- computeRestarts(cond)
[17:40:43.895]                         for (restart in restarts) {
[17:40:43.895]                           name <- restart$name
[17:40:43.895]                           if (is.null(name)) 
[17:40:43.895]                             next
[17:40:43.895]                           if (!grepl(pattern, name)) 
[17:40:43.895]                             next
[17:40:43.895]                           invokeRestart(restart)
[17:40:43.895]                           muffled <- TRUE
[17:40:43.895]                           break
[17:40:43.895]                         }
[17:40:43.895]                       }
[17:40:43.895]                     }
[17:40:43.895]                     invisible(muffled)
[17:40:43.895]                   }
[17:40:43.895]                   muffleCondition(cond)
[17:40:43.895]                 })
[17:40:43.895]             }))
[17:40:43.895]             future::FutureResult(value = ...future.value$value, 
[17:40:43.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.895]                   ...future.rng), globalenv = if (FALSE) 
[17:40:43.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:43.895]                     ...future.globalenv.names))
[17:40:43.895]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:43.895]         }, condition = base::local({
[17:40:43.895]             c <- base::c
[17:40:43.895]             inherits <- base::inherits
[17:40:43.895]             invokeRestart <- base::invokeRestart
[17:40:43.895]             length <- base::length
[17:40:43.895]             list <- base::list
[17:40:43.895]             seq.int <- base::seq.int
[17:40:43.895]             signalCondition <- base::signalCondition
[17:40:43.895]             sys.calls <- base::sys.calls
[17:40:43.895]             `[[` <- base::`[[`
[17:40:43.895]             `+` <- base::`+`
[17:40:43.895]             `<<-` <- base::`<<-`
[17:40:43.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:43.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:43.895]                   3L)]
[17:40:43.895]             }
[17:40:43.895]             function(cond) {
[17:40:43.895]                 is_error <- inherits(cond, "error")
[17:40:43.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:43.895]                   NULL)
[17:40:43.895]                 if (is_error) {
[17:40:43.895]                   sessionInformation <- function() {
[17:40:43.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:43.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:43.895]                       search = base::search(), system = base::Sys.info())
[17:40:43.895]                   }
[17:40:43.895]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:43.895]                     cond$call), session = sessionInformation(), 
[17:40:43.895]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:43.895]                   signalCondition(cond)
[17:40:43.895]                 }
[17:40:43.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:43.895]                 "immediateCondition"))) {
[17:40:43.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:43.895]                   ...future.conditions[[length(...future.conditions) + 
[17:40:43.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:43.895]                   if (TRUE && !signal) {
[17:40:43.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.895]                     {
[17:40:43.895]                       inherits <- base::inherits
[17:40:43.895]                       invokeRestart <- base::invokeRestart
[17:40:43.895]                       is.null <- base::is.null
[17:40:43.895]                       muffled <- FALSE
[17:40:43.895]                       if (inherits(cond, "message")) {
[17:40:43.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.895]                         if (muffled) 
[17:40:43.895]                           invokeRestart("muffleMessage")
[17:40:43.895]                       }
[17:40:43.895]                       else if (inherits(cond, "warning")) {
[17:40:43.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.895]                         if (muffled) 
[17:40:43.895]                           invokeRestart("muffleWarning")
[17:40:43.895]                       }
[17:40:43.895]                       else if (inherits(cond, "condition")) {
[17:40:43.895]                         if (!is.null(pattern)) {
[17:40:43.895]                           computeRestarts <- base::computeRestarts
[17:40:43.895]                           grepl <- base::grepl
[17:40:43.895]                           restarts <- computeRestarts(cond)
[17:40:43.895]                           for (restart in restarts) {
[17:40:43.895]                             name <- restart$name
[17:40:43.895]                             if (is.null(name)) 
[17:40:43.895]                               next
[17:40:43.895]                             if (!grepl(pattern, name)) 
[17:40:43.895]                               next
[17:40:43.895]                             invokeRestart(restart)
[17:40:43.895]                             muffled <- TRUE
[17:40:43.895]                             break
[17:40:43.895]                           }
[17:40:43.895]                         }
[17:40:43.895]                       }
[17:40:43.895]                       invisible(muffled)
[17:40:43.895]                     }
[17:40:43.895]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.895]                   }
[17:40:43.895]                 }
[17:40:43.895]                 else {
[17:40:43.895]                   if (TRUE) {
[17:40:43.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:43.895]                     {
[17:40:43.895]                       inherits <- base::inherits
[17:40:43.895]                       invokeRestart <- base::invokeRestart
[17:40:43.895]                       is.null <- base::is.null
[17:40:43.895]                       muffled <- FALSE
[17:40:43.895]                       if (inherits(cond, "message")) {
[17:40:43.895]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:43.895]                         if (muffled) 
[17:40:43.895]                           invokeRestart("muffleMessage")
[17:40:43.895]                       }
[17:40:43.895]                       else if (inherits(cond, "warning")) {
[17:40:43.895]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:43.895]                         if (muffled) 
[17:40:43.895]                           invokeRestart("muffleWarning")
[17:40:43.895]                       }
[17:40:43.895]                       else if (inherits(cond, "condition")) {
[17:40:43.895]                         if (!is.null(pattern)) {
[17:40:43.895]                           computeRestarts <- base::computeRestarts
[17:40:43.895]                           grepl <- base::grepl
[17:40:43.895]                           restarts <- computeRestarts(cond)
[17:40:43.895]                           for (restart in restarts) {
[17:40:43.895]                             name <- restart$name
[17:40:43.895]                             if (is.null(name)) 
[17:40:43.895]                               next
[17:40:43.895]                             if (!grepl(pattern, name)) 
[17:40:43.895]                               next
[17:40:43.895]                             invokeRestart(restart)
[17:40:43.895]                             muffled <- TRUE
[17:40:43.895]                             break
[17:40:43.895]                           }
[17:40:43.895]                         }
[17:40:43.895]                       }
[17:40:43.895]                       invisible(muffled)
[17:40:43.895]                     }
[17:40:43.895]                     muffleCondition(cond, pattern = "^muffle")
[17:40:43.895]                   }
[17:40:43.895]                 }
[17:40:43.895]             }
[17:40:43.895]         }))
[17:40:43.895]     }, error = function(ex) {
[17:40:43.895]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:43.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:43.895]                 ...future.rng), started = ...future.startTime, 
[17:40:43.895]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:43.895]             version = "1.8"), class = "FutureResult")
[17:40:43.895]     }, finally = {
[17:40:43.895]         if (!identical(...future.workdir, getwd())) 
[17:40:43.895]             setwd(...future.workdir)
[17:40:43.895]         {
[17:40:43.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:43.895]                 ...future.oldOptions$nwarnings <- NULL
[17:40:43.895]             }
[17:40:43.895]             base::options(...future.oldOptions)
[17:40:43.895]             if (.Platform$OS.type == "windows") {
[17:40:43.895]                 old_names <- names(...future.oldEnvVars)
[17:40:43.895]                 envs <- base::Sys.getenv()
[17:40:43.895]                 names <- names(envs)
[17:40:43.895]                 common <- intersect(names, old_names)
[17:40:43.895]                 added <- setdiff(names, old_names)
[17:40:43.895]                 removed <- setdiff(old_names, names)
[17:40:43.895]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:43.895]                   envs[common]]
[17:40:43.895]                 NAMES <- toupper(changed)
[17:40:43.895]                 args <- list()
[17:40:43.895]                 for (kk in seq_along(NAMES)) {
[17:40:43.895]                   name <- changed[[kk]]
[17:40:43.895]                   NAME <- NAMES[[kk]]
[17:40:43.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.895]                     next
[17:40:43.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.895]                 }
[17:40:43.895]                 NAMES <- toupper(added)
[17:40:43.895]                 for (kk in seq_along(NAMES)) {
[17:40:43.895]                   name <- added[[kk]]
[17:40:43.895]                   NAME <- NAMES[[kk]]
[17:40:43.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.895]                     next
[17:40:43.895]                   args[[name]] <- ""
[17:40:43.895]                 }
[17:40:43.895]                 NAMES <- toupper(removed)
[17:40:43.895]                 for (kk in seq_along(NAMES)) {
[17:40:43.895]                   name <- removed[[kk]]
[17:40:43.895]                   NAME <- NAMES[[kk]]
[17:40:43.895]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:43.895]                     next
[17:40:43.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:43.895]                 }
[17:40:43.895]                 if (length(args) > 0) 
[17:40:43.895]                   base::do.call(base::Sys.setenv, args = args)
[17:40:43.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:43.895]             }
[17:40:43.895]             else {
[17:40:43.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:43.895]             }
[17:40:43.895]             {
[17:40:43.895]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:43.895]                   0L) {
[17:40:43.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:43.895]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:43.895]                   base::options(opts)
[17:40:43.895]                 }
[17:40:43.895]                 {
[17:40:43.895]                   {
[17:40:43.895]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:43.895]                     NULL
[17:40:43.895]                   }
[17:40:43.895]                   options(future.plan = NULL)
[17:40:43.895]                   if (is.na(NA_character_)) 
[17:40:43.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:43.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:43.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:43.895]                     .init = FALSE)
[17:40:43.895]                 }
[17:40:43.895]             }
[17:40:43.895]         }
[17:40:43.895]     })
[17:40:43.895]     if (TRUE) {
[17:40:43.895]         base::sink(type = "output", split = FALSE)
[17:40:43.895]         if (TRUE) {
[17:40:43.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:43.895]         }
[17:40:43.895]         else {
[17:40:43.895]             ...future.result["stdout"] <- base::list(NULL)
[17:40:43.895]         }
[17:40:43.895]         base::close(...future.stdout)
[17:40:43.895]         ...future.stdout <- NULL
[17:40:43.895]     }
[17:40:43.895]     ...future.result$conditions <- ...future.conditions
[17:40:43.895]     ...future.result$finished <- base::Sys.time()
[17:40:43.895]     ...future.result
[17:40:43.895] }
[17:40:43.898] assign_globals() ...
[17:40:43.899] List of 1
[17:40:43.899]  $ kk: int 3
[17:40:43.899]  - attr(*, "where")=List of 1
[17:40:43.899]   ..$ kk:<environment: R_EmptyEnv> 
[17:40:43.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:40:43.899]  - attr(*, "resolved")= logi FALSE
[17:40:43.899]  - attr(*, "total_size")= num 56
[17:40:43.899]  - attr(*, "already-done")= logi TRUE
[17:40:43.903] - copied ‘kk’ to environment
[17:40:43.903] assign_globals() ... done
[17:40:43.903] requestCore(): workers = 2
[17:40:43.903] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:43.930] plan(): Setting new future strategy stack:
[17:40:43.930] List of future strategies:
[17:40:43.930] 1. multicore:
[17:40:43.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.930]    - tweaked: FALSE
[17:40:43.930]    - call: plan(strategy)
[17:40:43.934] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[17:40:43.935] plan(): nbrOfWorkers() = 2
[17:40:43.945] result() for MulticoreFuture ...
[17:40:43.946] result() for MulticoreFuture ...
[17:40:43.946] result() for MulticoreFuture ... done
[17:40:43.946] result() for MulticoreFuture ... done
[17:40:43.947] result() for MulticoreFuture ...
[17:40:43.947] result() for MulticoreFuture ... done
[17:40:43.949] MulticoreFuture started
[17:40:43.949] - Launch lazy future ... done
[17:40:43.950] run() for ‘MulticoreFuture’ ... done
[17:40:43.950] plan(): Setting new future strategy stack:
[17:40:43.951] List of future strategies:
[17:40:43.951] 1. sequential:
[17:40:43.951]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:43.951]    - tweaked: FALSE
[17:40:43.951]    - call: NULL
[17:40:43.952] plan(): nbrOfWorkers() = 1
[17:40:43.971] Future #1
[17:40:43.971]  length: 2 (resolved future 1)
[17:40:43.977] plan(): Setting new future strategy stack:
[17:40:43.977] List of future strategies:
[17:40:43.977] 1. multicore:
[17:40:43.977]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:43.977]    - tweaked: FALSE
[17:40:43.977]    - call: plan(strategy)
[17:40:43.982] plan(): nbrOfWorkers() = 2
[17:40:44.002] Future #2
[17:40:44.002]  length: 1 (resolved future 2)
[17:40:44.054] plan(): Setting new future strategy stack:
[17:40:44.055] List of future strategies:
[17:40:44.055] 1. multicore:
[17:40:44.055]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.055]    - tweaked: FALSE
[17:40:44.055]    - call: plan(strategy)
[17:40:44.060] plan(): nbrOfWorkers() = 2
[17:40:44.064] Future #3
[17:40:44.064]  length: 0 (resolved future 3)
[17:40:44.064] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:40:44.066] resolve() on environment ...
[17:40:44.066]  recursive: 0
[17:40:44.067]  elements: [2] ‘a’, ‘b’
[17:40:44.067]  length: 1 (resolved future 1)
[17:40:44.071]  length: 0 (resolved future 2)
[17:40:44.071] resolve() on environment ... DONE
[17:40:44.073] getGlobalsAndPackages() ...
[17:40:44.074] Searching for globals...
[17:40:44.075] 
[17:40:44.075] Searching for globals ... DONE
[17:40:44.075] - globals: [0] <none>
[17:40:44.076] getGlobalsAndPackages() ... DONE
[17:40:44.076] run() for ‘Future’ ...
[17:40:44.077] - state: ‘created’
[17:40:44.077] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.082] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.082] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.083]   - Field: ‘label’
[17:40:44.083]   - Field: ‘local’
[17:40:44.083]   - Field: ‘owner’
[17:40:44.083]   - Field: ‘envir’
[17:40:44.083]   - Field: ‘workers’
[17:40:44.084]   - Field: ‘packages’
[17:40:44.084]   - Field: ‘gc’
[17:40:44.084]   - Field: ‘job’
[17:40:44.084]   - Field: ‘conditions’
[17:40:44.084]   - Field: ‘expr’
[17:40:44.084]   - Field: ‘uuid’
[17:40:44.084]   - Field: ‘seed’
[17:40:44.085]   - Field: ‘version’
[17:40:44.085]   - Field: ‘result’
[17:40:44.085]   - Field: ‘asynchronous’
[17:40:44.085]   - Field: ‘calls’
[17:40:44.085]   - Field: ‘globals’
[17:40:44.085]   - Field: ‘stdout’
[17:40:44.085]   - Field: ‘earlySignal’
[17:40:44.085]   - Field: ‘lazy’
[17:40:44.086]   - Field: ‘state’
[17:40:44.086] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.086] - Launch lazy future ...
[17:40:44.086] Packages needed by the future expression (n = 0): <none>
[17:40:44.087] Packages needed by future strategies (n = 0): <none>
[17:40:44.087] {
[17:40:44.087]     {
[17:40:44.087]         {
[17:40:44.087]             ...future.startTime <- base::Sys.time()
[17:40:44.087]             {
[17:40:44.087]                 {
[17:40:44.087]                   {
[17:40:44.087]                     {
[17:40:44.087]                       base::local({
[17:40:44.087]                         has_future <- base::requireNamespace("future", 
[17:40:44.087]                           quietly = TRUE)
[17:40:44.087]                         if (has_future) {
[17:40:44.087]                           ns <- base::getNamespace("future")
[17:40:44.087]                           version <- ns[[".package"]][["version"]]
[17:40:44.087]                           if (is.null(version)) 
[17:40:44.087]                             version <- utils::packageVersion("future")
[17:40:44.087]                         }
[17:40:44.087]                         else {
[17:40:44.087]                           version <- NULL
[17:40:44.087]                         }
[17:40:44.087]                         if (!has_future || version < "1.8.0") {
[17:40:44.087]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.087]                             "", base::R.version$version.string), 
[17:40:44.087]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.087]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.087]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.087]                               "release", "version")], collapse = " "), 
[17:40:44.087]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.087]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.087]                             info)
[17:40:44.087]                           info <- base::paste(info, collapse = "; ")
[17:40:44.087]                           if (!has_future) {
[17:40:44.087]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.087]                               info)
[17:40:44.087]                           }
[17:40:44.087]                           else {
[17:40:44.087]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.087]                               info, version)
[17:40:44.087]                           }
[17:40:44.087]                           base::stop(msg)
[17:40:44.087]                         }
[17:40:44.087]                       })
[17:40:44.087]                     }
[17:40:44.087]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.087]                     base::options(mc.cores = 1L)
[17:40:44.087]                   }
[17:40:44.087]                   ...future.strategy.old <- future::plan("list")
[17:40:44.087]                   options(future.plan = NULL)
[17:40:44.087]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.087]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.087]                 }
[17:40:44.087]                 ...future.workdir <- getwd()
[17:40:44.087]             }
[17:40:44.087]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.087]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.087]         }
[17:40:44.087]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.087]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.087]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.087]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.087]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.087]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.087]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.087]             base::names(...future.oldOptions))
[17:40:44.087]     }
[17:40:44.087]     if (FALSE) {
[17:40:44.087]     }
[17:40:44.087]     else {
[17:40:44.087]         if (TRUE) {
[17:40:44.087]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.087]                 open = "w")
[17:40:44.087]         }
[17:40:44.087]         else {
[17:40:44.087]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.087]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.087]         }
[17:40:44.087]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.087]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.087]             base::sink(type = "output", split = FALSE)
[17:40:44.087]             base::close(...future.stdout)
[17:40:44.087]         }, add = TRUE)
[17:40:44.087]     }
[17:40:44.087]     ...future.frame <- base::sys.nframe()
[17:40:44.087]     ...future.conditions <- base::list()
[17:40:44.087]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.087]     if (FALSE) {
[17:40:44.087]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.087]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.087]     }
[17:40:44.087]     ...future.result <- base::tryCatch({
[17:40:44.087]         base::withCallingHandlers({
[17:40:44.087]             ...future.value <- base::withVisible(base::local({
[17:40:44.087]                 withCallingHandlers({
[17:40:44.087]                   1
[17:40:44.087]                 }, immediateCondition = function(cond) {
[17:40:44.087]                   save_rds <- function (object, pathname, ...) 
[17:40:44.087]                   {
[17:40:44.087]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.087]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.087]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.087]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.087]                         fi_tmp[["mtime"]])
[17:40:44.087]                     }
[17:40:44.087]                     tryCatch({
[17:40:44.087]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.087]                     }, error = function(ex) {
[17:40:44.087]                       msg <- conditionMessage(ex)
[17:40:44.087]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.087]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.087]                         fi_tmp[["mtime"]], msg)
[17:40:44.087]                       ex$message <- msg
[17:40:44.087]                       stop(ex)
[17:40:44.087]                     })
[17:40:44.087]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.087]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.087]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.087]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.087]                       fi <- file.info(pathname)
[17:40:44.087]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.087]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.087]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.087]                         fi[["size"]], fi[["mtime"]])
[17:40:44.087]                       stop(msg)
[17:40:44.087]                     }
[17:40:44.087]                     invisible(pathname)
[17:40:44.087]                   }
[17:40:44.087]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.087]                     rootPath = tempdir()) 
[17:40:44.087]                   {
[17:40:44.087]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.087]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.087]                       tmpdir = path, fileext = ".rds")
[17:40:44.087]                     save_rds(obj, file)
[17:40:44.087]                   }
[17:40:44.087]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.087]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.087]                   {
[17:40:44.087]                     inherits <- base::inherits
[17:40:44.087]                     invokeRestart <- base::invokeRestart
[17:40:44.087]                     is.null <- base::is.null
[17:40:44.087]                     muffled <- FALSE
[17:40:44.087]                     if (inherits(cond, "message")) {
[17:40:44.087]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.087]                       if (muffled) 
[17:40:44.087]                         invokeRestart("muffleMessage")
[17:40:44.087]                     }
[17:40:44.087]                     else if (inherits(cond, "warning")) {
[17:40:44.087]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.087]                       if (muffled) 
[17:40:44.087]                         invokeRestart("muffleWarning")
[17:40:44.087]                     }
[17:40:44.087]                     else if (inherits(cond, "condition")) {
[17:40:44.087]                       if (!is.null(pattern)) {
[17:40:44.087]                         computeRestarts <- base::computeRestarts
[17:40:44.087]                         grepl <- base::grepl
[17:40:44.087]                         restarts <- computeRestarts(cond)
[17:40:44.087]                         for (restart in restarts) {
[17:40:44.087]                           name <- restart$name
[17:40:44.087]                           if (is.null(name)) 
[17:40:44.087]                             next
[17:40:44.087]                           if (!grepl(pattern, name)) 
[17:40:44.087]                             next
[17:40:44.087]                           invokeRestart(restart)
[17:40:44.087]                           muffled <- TRUE
[17:40:44.087]                           break
[17:40:44.087]                         }
[17:40:44.087]                       }
[17:40:44.087]                     }
[17:40:44.087]                     invisible(muffled)
[17:40:44.087]                   }
[17:40:44.087]                   muffleCondition(cond)
[17:40:44.087]                 })
[17:40:44.087]             }))
[17:40:44.087]             future::FutureResult(value = ...future.value$value, 
[17:40:44.087]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.087]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.087]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.087]                     ...future.globalenv.names))
[17:40:44.087]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.087]         }, condition = base::local({
[17:40:44.087]             c <- base::c
[17:40:44.087]             inherits <- base::inherits
[17:40:44.087]             invokeRestart <- base::invokeRestart
[17:40:44.087]             length <- base::length
[17:40:44.087]             list <- base::list
[17:40:44.087]             seq.int <- base::seq.int
[17:40:44.087]             signalCondition <- base::signalCondition
[17:40:44.087]             sys.calls <- base::sys.calls
[17:40:44.087]             `[[` <- base::`[[`
[17:40:44.087]             `+` <- base::`+`
[17:40:44.087]             `<<-` <- base::`<<-`
[17:40:44.087]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.087]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.087]                   3L)]
[17:40:44.087]             }
[17:40:44.087]             function(cond) {
[17:40:44.087]                 is_error <- inherits(cond, "error")
[17:40:44.087]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.087]                   NULL)
[17:40:44.087]                 if (is_error) {
[17:40:44.087]                   sessionInformation <- function() {
[17:40:44.087]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.087]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.087]                       search = base::search(), system = base::Sys.info())
[17:40:44.087]                   }
[17:40:44.087]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.087]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.087]                     cond$call), session = sessionInformation(), 
[17:40:44.087]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.087]                   signalCondition(cond)
[17:40:44.087]                 }
[17:40:44.087]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.087]                 "immediateCondition"))) {
[17:40:44.087]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.087]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.087]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.087]                   if (TRUE && !signal) {
[17:40:44.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.087]                     {
[17:40:44.087]                       inherits <- base::inherits
[17:40:44.087]                       invokeRestart <- base::invokeRestart
[17:40:44.087]                       is.null <- base::is.null
[17:40:44.087]                       muffled <- FALSE
[17:40:44.087]                       if (inherits(cond, "message")) {
[17:40:44.087]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.087]                         if (muffled) 
[17:40:44.087]                           invokeRestart("muffleMessage")
[17:40:44.087]                       }
[17:40:44.087]                       else if (inherits(cond, "warning")) {
[17:40:44.087]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.087]                         if (muffled) 
[17:40:44.087]                           invokeRestart("muffleWarning")
[17:40:44.087]                       }
[17:40:44.087]                       else if (inherits(cond, "condition")) {
[17:40:44.087]                         if (!is.null(pattern)) {
[17:40:44.087]                           computeRestarts <- base::computeRestarts
[17:40:44.087]                           grepl <- base::grepl
[17:40:44.087]                           restarts <- computeRestarts(cond)
[17:40:44.087]                           for (restart in restarts) {
[17:40:44.087]                             name <- restart$name
[17:40:44.087]                             if (is.null(name)) 
[17:40:44.087]                               next
[17:40:44.087]                             if (!grepl(pattern, name)) 
[17:40:44.087]                               next
[17:40:44.087]                             invokeRestart(restart)
[17:40:44.087]                             muffled <- TRUE
[17:40:44.087]                             break
[17:40:44.087]                           }
[17:40:44.087]                         }
[17:40:44.087]                       }
[17:40:44.087]                       invisible(muffled)
[17:40:44.087]                     }
[17:40:44.087]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.087]                   }
[17:40:44.087]                 }
[17:40:44.087]                 else {
[17:40:44.087]                   if (TRUE) {
[17:40:44.087]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.087]                     {
[17:40:44.087]                       inherits <- base::inherits
[17:40:44.087]                       invokeRestart <- base::invokeRestart
[17:40:44.087]                       is.null <- base::is.null
[17:40:44.087]                       muffled <- FALSE
[17:40:44.087]                       if (inherits(cond, "message")) {
[17:40:44.087]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.087]                         if (muffled) 
[17:40:44.087]                           invokeRestart("muffleMessage")
[17:40:44.087]                       }
[17:40:44.087]                       else if (inherits(cond, "warning")) {
[17:40:44.087]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.087]                         if (muffled) 
[17:40:44.087]                           invokeRestart("muffleWarning")
[17:40:44.087]                       }
[17:40:44.087]                       else if (inherits(cond, "condition")) {
[17:40:44.087]                         if (!is.null(pattern)) {
[17:40:44.087]                           computeRestarts <- base::computeRestarts
[17:40:44.087]                           grepl <- base::grepl
[17:40:44.087]                           restarts <- computeRestarts(cond)
[17:40:44.087]                           for (restart in restarts) {
[17:40:44.087]                             name <- restart$name
[17:40:44.087]                             if (is.null(name)) 
[17:40:44.087]                               next
[17:40:44.087]                             if (!grepl(pattern, name)) 
[17:40:44.087]                               next
[17:40:44.087]                             invokeRestart(restart)
[17:40:44.087]                             muffled <- TRUE
[17:40:44.087]                             break
[17:40:44.087]                           }
[17:40:44.087]                         }
[17:40:44.087]                       }
[17:40:44.087]                       invisible(muffled)
[17:40:44.087]                     }
[17:40:44.087]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.087]                   }
[17:40:44.087]                 }
[17:40:44.087]             }
[17:40:44.087]         }))
[17:40:44.087]     }, error = function(ex) {
[17:40:44.087]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.087]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.087]                 ...future.rng), started = ...future.startTime, 
[17:40:44.087]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.087]             version = "1.8"), class = "FutureResult")
[17:40:44.087]     }, finally = {
[17:40:44.087]         if (!identical(...future.workdir, getwd())) 
[17:40:44.087]             setwd(...future.workdir)
[17:40:44.087]         {
[17:40:44.087]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.087]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.087]             }
[17:40:44.087]             base::options(...future.oldOptions)
[17:40:44.087]             if (.Platform$OS.type == "windows") {
[17:40:44.087]                 old_names <- names(...future.oldEnvVars)
[17:40:44.087]                 envs <- base::Sys.getenv()
[17:40:44.087]                 names <- names(envs)
[17:40:44.087]                 common <- intersect(names, old_names)
[17:40:44.087]                 added <- setdiff(names, old_names)
[17:40:44.087]                 removed <- setdiff(old_names, names)
[17:40:44.087]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.087]                   envs[common]]
[17:40:44.087]                 NAMES <- toupper(changed)
[17:40:44.087]                 args <- list()
[17:40:44.087]                 for (kk in seq_along(NAMES)) {
[17:40:44.087]                   name <- changed[[kk]]
[17:40:44.087]                   NAME <- NAMES[[kk]]
[17:40:44.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.087]                     next
[17:40:44.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.087]                 }
[17:40:44.087]                 NAMES <- toupper(added)
[17:40:44.087]                 for (kk in seq_along(NAMES)) {
[17:40:44.087]                   name <- added[[kk]]
[17:40:44.087]                   NAME <- NAMES[[kk]]
[17:40:44.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.087]                     next
[17:40:44.087]                   args[[name]] <- ""
[17:40:44.087]                 }
[17:40:44.087]                 NAMES <- toupper(removed)
[17:40:44.087]                 for (kk in seq_along(NAMES)) {
[17:40:44.087]                   name <- removed[[kk]]
[17:40:44.087]                   NAME <- NAMES[[kk]]
[17:40:44.087]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.087]                     next
[17:40:44.087]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.087]                 }
[17:40:44.087]                 if (length(args) > 0) 
[17:40:44.087]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.087]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.087]             }
[17:40:44.087]             else {
[17:40:44.087]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.087]             }
[17:40:44.087]             {
[17:40:44.087]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.087]                   0L) {
[17:40:44.087]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.087]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.087]                   base::options(opts)
[17:40:44.087]                 }
[17:40:44.087]                 {
[17:40:44.087]                   {
[17:40:44.087]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.087]                     NULL
[17:40:44.087]                   }
[17:40:44.087]                   options(future.plan = NULL)
[17:40:44.087]                   if (is.na(NA_character_)) 
[17:40:44.087]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.087]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.087]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.087]                     .init = FALSE)
[17:40:44.087]                 }
[17:40:44.087]             }
[17:40:44.087]         }
[17:40:44.087]     })
[17:40:44.087]     if (TRUE) {
[17:40:44.087]         base::sink(type = "output", split = FALSE)
[17:40:44.087]         if (TRUE) {
[17:40:44.087]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.087]         }
[17:40:44.087]         else {
[17:40:44.087]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.087]         }
[17:40:44.087]         base::close(...future.stdout)
[17:40:44.087]         ...future.stdout <- NULL
[17:40:44.087]     }
[17:40:44.087]     ...future.result$conditions <- ...future.conditions
[17:40:44.087]     ...future.result$finished <- base::Sys.time()
[17:40:44.087]     ...future.result
[17:40:44.087] }
[17:40:44.090] requestCore(): workers = 2
[17:40:44.090] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.101] result() for MulticoreFuture ...
[17:40:44.102] result() for MulticoreFuture ...
[17:40:44.102] result() for MulticoreFuture ... done
[17:40:44.102] result() for MulticoreFuture ... done
[17:40:44.102] result() for MulticoreFuture ...
[17:40:44.102] result() for MulticoreFuture ... done
[17:40:44.104] MulticoreFuture started
[17:40:44.105] - Launch lazy future ... done
[17:40:44.105] run() for ‘MulticoreFuture’ ... done
[17:40:44.106] getGlobalsAndPackages() ...
[17:40:44.106] plan(): Setting new future strategy stack:
[17:40:44.106] Searching for globals...
[17:40:44.107] 
[17:40:44.106] List of future strategies:
[17:40:44.106] 1. sequential:
[17:40:44.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.106]    - tweaked: FALSE
[17:40:44.106]    - call: NULL
[17:40:44.107] Searching for globals ... DONE
[17:40:44.107] plan(): nbrOfWorkers() = 1
[17:40:44.108] - globals: [0] <none>
[17:40:44.108] getGlobalsAndPackages() ... DONE
[17:40:44.109] run() for ‘Future’ ...
[17:40:44.109] - state: ‘created’
[17:40:44.109] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.110] plan(): Setting new future strategy stack:
[17:40:44.110] List of future strategies:
[17:40:44.110] 1. multicore:
[17:40:44.110]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.110]    - tweaked: FALSE
[17:40:44.110]    - call: plan(strategy)
[17:40:44.116] plan(): nbrOfWorkers() = 2
[17:40:44.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.116]   - Field: ‘label’
[17:40:44.117]   - Field: ‘local’
[17:40:44.117]   - Field: ‘owner’
[17:40:44.117]   - Field: ‘envir’
[17:40:44.117]   - Field: ‘workers’
[17:40:44.117]   - Field: ‘packages’
[17:40:44.117]   - Field: ‘gc’
[17:40:44.117]   - Field: ‘job’
[17:40:44.118]   - Field: ‘conditions’
[17:40:44.118]   - Field: ‘expr’
[17:40:44.118]   - Field: ‘uuid’
[17:40:44.118]   - Field: ‘seed’
[17:40:44.118]   - Field: ‘version’
[17:40:44.118]   - Field: ‘result’
[17:40:44.119]   - Field: ‘asynchronous’
[17:40:44.119]   - Field: ‘calls’
[17:40:44.119]   - Field: ‘globals’
[17:40:44.119]   - Field: ‘stdout’
[17:40:44.119]   - Field: ‘earlySignal’
[17:40:44.119]   - Field: ‘lazy’
[17:40:44.119]   - Field: ‘state’
[17:40:44.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.120] - Launch lazy future ...
[17:40:44.120] Packages needed by the future expression (n = 0): <none>
[17:40:44.120] Packages needed by future strategies (n = 0): <none>
[17:40:44.121] {
[17:40:44.121]     {
[17:40:44.121]         {
[17:40:44.121]             ...future.startTime <- base::Sys.time()
[17:40:44.121]             {
[17:40:44.121]                 {
[17:40:44.121]                   {
[17:40:44.121]                     {
[17:40:44.121]                       base::local({
[17:40:44.121]                         has_future <- base::requireNamespace("future", 
[17:40:44.121]                           quietly = TRUE)
[17:40:44.121]                         if (has_future) {
[17:40:44.121]                           ns <- base::getNamespace("future")
[17:40:44.121]                           version <- ns[[".package"]][["version"]]
[17:40:44.121]                           if (is.null(version)) 
[17:40:44.121]                             version <- utils::packageVersion("future")
[17:40:44.121]                         }
[17:40:44.121]                         else {
[17:40:44.121]                           version <- NULL
[17:40:44.121]                         }
[17:40:44.121]                         if (!has_future || version < "1.8.0") {
[17:40:44.121]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.121]                             "", base::R.version$version.string), 
[17:40:44.121]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.121]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.121]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.121]                               "release", "version")], collapse = " "), 
[17:40:44.121]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.121]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.121]                             info)
[17:40:44.121]                           info <- base::paste(info, collapse = "; ")
[17:40:44.121]                           if (!has_future) {
[17:40:44.121]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.121]                               info)
[17:40:44.121]                           }
[17:40:44.121]                           else {
[17:40:44.121]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.121]                               info, version)
[17:40:44.121]                           }
[17:40:44.121]                           base::stop(msg)
[17:40:44.121]                         }
[17:40:44.121]                       })
[17:40:44.121]                     }
[17:40:44.121]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.121]                     base::options(mc.cores = 1L)
[17:40:44.121]                   }
[17:40:44.121]                   ...future.strategy.old <- future::plan("list")
[17:40:44.121]                   options(future.plan = NULL)
[17:40:44.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.121]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.121]                 }
[17:40:44.121]                 ...future.workdir <- getwd()
[17:40:44.121]             }
[17:40:44.121]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.121]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.121]         }
[17:40:44.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.121]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.121]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.121]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.121]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.121]             base::names(...future.oldOptions))
[17:40:44.121]     }
[17:40:44.121]     if (FALSE) {
[17:40:44.121]     }
[17:40:44.121]     else {
[17:40:44.121]         if (TRUE) {
[17:40:44.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.121]                 open = "w")
[17:40:44.121]         }
[17:40:44.121]         else {
[17:40:44.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.121]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.121]         }
[17:40:44.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.121]             base::sink(type = "output", split = FALSE)
[17:40:44.121]             base::close(...future.stdout)
[17:40:44.121]         }, add = TRUE)
[17:40:44.121]     }
[17:40:44.121]     ...future.frame <- base::sys.nframe()
[17:40:44.121]     ...future.conditions <- base::list()
[17:40:44.121]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.121]     if (FALSE) {
[17:40:44.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.121]     }
[17:40:44.121]     ...future.result <- base::tryCatch({
[17:40:44.121]         base::withCallingHandlers({
[17:40:44.121]             ...future.value <- base::withVisible(base::local({
[17:40:44.121]                 withCallingHandlers({
[17:40:44.121]                   2
[17:40:44.121]                 }, immediateCondition = function(cond) {
[17:40:44.121]                   save_rds <- function (object, pathname, ...) 
[17:40:44.121]                   {
[17:40:44.121]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.121]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.121]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.121]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.121]                         fi_tmp[["mtime"]])
[17:40:44.121]                     }
[17:40:44.121]                     tryCatch({
[17:40:44.121]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.121]                     }, error = function(ex) {
[17:40:44.121]                       msg <- conditionMessage(ex)
[17:40:44.121]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.121]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.121]                         fi_tmp[["mtime"]], msg)
[17:40:44.121]                       ex$message <- msg
[17:40:44.121]                       stop(ex)
[17:40:44.121]                     })
[17:40:44.121]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.121]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.121]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.121]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.121]                       fi <- file.info(pathname)
[17:40:44.121]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.121]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.121]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.121]                         fi[["size"]], fi[["mtime"]])
[17:40:44.121]                       stop(msg)
[17:40:44.121]                     }
[17:40:44.121]                     invisible(pathname)
[17:40:44.121]                   }
[17:40:44.121]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.121]                     rootPath = tempdir()) 
[17:40:44.121]                   {
[17:40:44.121]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.121]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.121]                       tmpdir = path, fileext = ".rds")
[17:40:44.121]                     save_rds(obj, file)
[17:40:44.121]                   }
[17:40:44.121]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.121]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.121]                   {
[17:40:44.121]                     inherits <- base::inherits
[17:40:44.121]                     invokeRestart <- base::invokeRestart
[17:40:44.121]                     is.null <- base::is.null
[17:40:44.121]                     muffled <- FALSE
[17:40:44.121]                     if (inherits(cond, "message")) {
[17:40:44.121]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.121]                       if (muffled) 
[17:40:44.121]                         invokeRestart("muffleMessage")
[17:40:44.121]                     }
[17:40:44.121]                     else if (inherits(cond, "warning")) {
[17:40:44.121]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.121]                       if (muffled) 
[17:40:44.121]                         invokeRestart("muffleWarning")
[17:40:44.121]                     }
[17:40:44.121]                     else if (inherits(cond, "condition")) {
[17:40:44.121]                       if (!is.null(pattern)) {
[17:40:44.121]                         computeRestarts <- base::computeRestarts
[17:40:44.121]                         grepl <- base::grepl
[17:40:44.121]                         restarts <- computeRestarts(cond)
[17:40:44.121]                         for (restart in restarts) {
[17:40:44.121]                           name <- restart$name
[17:40:44.121]                           if (is.null(name)) 
[17:40:44.121]                             next
[17:40:44.121]                           if (!grepl(pattern, name)) 
[17:40:44.121]                             next
[17:40:44.121]                           invokeRestart(restart)
[17:40:44.121]                           muffled <- TRUE
[17:40:44.121]                           break
[17:40:44.121]                         }
[17:40:44.121]                       }
[17:40:44.121]                     }
[17:40:44.121]                     invisible(muffled)
[17:40:44.121]                   }
[17:40:44.121]                   muffleCondition(cond)
[17:40:44.121]                 })
[17:40:44.121]             }))
[17:40:44.121]             future::FutureResult(value = ...future.value$value, 
[17:40:44.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.121]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.121]                     ...future.globalenv.names))
[17:40:44.121]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.121]         }, condition = base::local({
[17:40:44.121]             c <- base::c
[17:40:44.121]             inherits <- base::inherits
[17:40:44.121]             invokeRestart <- base::invokeRestart
[17:40:44.121]             length <- base::length
[17:40:44.121]             list <- base::list
[17:40:44.121]             seq.int <- base::seq.int
[17:40:44.121]             signalCondition <- base::signalCondition
[17:40:44.121]             sys.calls <- base::sys.calls
[17:40:44.121]             `[[` <- base::`[[`
[17:40:44.121]             `+` <- base::`+`
[17:40:44.121]             `<<-` <- base::`<<-`
[17:40:44.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.121]                   3L)]
[17:40:44.121]             }
[17:40:44.121]             function(cond) {
[17:40:44.121]                 is_error <- inherits(cond, "error")
[17:40:44.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.121]                   NULL)
[17:40:44.121]                 if (is_error) {
[17:40:44.121]                   sessionInformation <- function() {
[17:40:44.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.121]                       search = base::search(), system = base::Sys.info())
[17:40:44.121]                   }
[17:40:44.121]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.121]                     cond$call), session = sessionInformation(), 
[17:40:44.121]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.121]                   signalCondition(cond)
[17:40:44.121]                 }
[17:40:44.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.121]                 "immediateCondition"))) {
[17:40:44.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.121]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.121]                   if (TRUE && !signal) {
[17:40:44.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.121]                     {
[17:40:44.121]                       inherits <- base::inherits
[17:40:44.121]                       invokeRestart <- base::invokeRestart
[17:40:44.121]                       is.null <- base::is.null
[17:40:44.121]                       muffled <- FALSE
[17:40:44.121]                       if (inherits(cond, "message")) {
[17:40:44.121]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.121]                         if (muffled) 
[17:40:44.121]                           invokeRestart("muffleMessage")
[17:40:44.121]                       }
[17:40:44.121]                       else if (inherits(cond, "warning")) {
[17:40:44.121]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.121]                         if (muffled) 
[17:40:44.121]                           invokeRestart("muffleWarning")
[17:40:44.121]                       }
[17:40:44.121]                       else if (inherits(cond, "condition")) {
[17:40:44.121]                         if (!is.null(pattern)) {
[17:40:44.121]                           computeRestarts <- base::computeRestarts
[17:40:44.121]                           grepl <- base::grepl
[17:40:44.121]                           restarts <- computeRestarts(cond)
[17:40:44.121]                           for (restart in restarts) {
[17:40:44.121]                             name <- restart$name
[17:40:44.121]                             if (is.null(name)) 
[17:40:44.121]                               next
[17:40:44.121]                             if (!grepl(pattern, name)) 
[17:40:44.121]                               next
[17:40:44.121]                             invokeRestart(restart)
[17:40:44.121]                             muffled <- TRUE
[17:40:44.121]                             break
[17:40:44.121]                           }
[17:40:44.121]                         }
[17:40:44.121]                       }
[17:40:44.121]                       invisible(muffled)
[17:40:44.121]                     }
[17:40:44.121]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.121]                   }
[17:40:44.121]                 }
[17:40:44.121]                 else {
[17:40:44.121]                   if (TRUE) {
[17:40:44.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.121]                     {
[17:40:44.121]                       inherits <- base::inherits
[17:40:44.121]                       invokeRestart <- base::invokeRestart
[17:40:44.121]                       is.null <- base::is.null
[17:40:44.121]                       muffled <- FALSE
[17:40:44.121]                       if (inherits(cond, "message")) {
[17:40:44.121]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.121]                         if (muffled) 
[17:40:44.121]                           invokeRestart("muffleMessage")
[17:40:44.121]                       }
[17:40:44.121]                       else if (inherits(cond, "warning")) {
[17:40:44.121]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.121]                         if (muffled) 
[17:40:44.121]                           invokeRestart("muffleWarning")
[17:40:44.121]                       }
[17:40:44.121]                       else if (inherits(cond, "condition")) {
[17:40:44.121]                         if (!is.null(pattern)) {
[17:40:44.121]                           computeRestarts <- base::computeRestarts
[17:40:44.121]                           grepl <- base::grepl
[17:40:44.121]                           restarts <- computeRestarts(cond)
[17:40:44.121]                           for (restart in restarts) {
[17:40:44.121]                             name <- restart$name
[17:40:44.121]                             if (is.null(name)) 
[17:40:44.121]                               next
[17:40:44.121]                             if (!grepl(pattern, name)) 
[17:40:44.121]                               next
[17:40:44.121]                             invokeRestart(restart)
[17:40:44.121]                             muffled <- TRUE
[17:40:44.121]                             break
[17:40:44.121]                           }
[17:40:44.121]                         }
[17:40:44.121]                       }
[17:40:44.121]                       invisible(muffled)
[17:40:44.121]                     }
[17:40:44.121]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.121]                   }
[17:40:44.121]                 }
[17:40:44.121]             }
[17:40:44.121]         }))
[17:40:44.121]     }, error = function(ex) {
[17:40:44.121]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.121]                 ...future.rng), started = ...future.startTime, 
[17:40:44.121]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.121]             version = "1.8"), class = "FutureResult")
[17:40:44.121]     }, finally = {
[17:40:44.121]         if (!identical(...future.workdir, getwd())) 
[17:40:44.121]             setwd(...future.workdir)
[17:40:44.121]         {
[17:40:44.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.121]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.121]             }
[17:40:44.121]             base::options(...future.oldOptions)
[17:40:44.121]             if (.Platform$OS.type == "windows") {
[17:40:44.121]                 old_names <- names(...future.oldEnvVars)
[17:40:44.121]                 envs <- base::Sys.getenv()
[17:40:44.121]                 names <- names(envs)
[17:40:44.121]                 common <- intersect(names, old_names)
[17:40:44.121]                 added <- setdiff(names, old_names)
[17:40:44.121]                 removed <- setdiff(old_names, names)
[17:40:44.121]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.121]                   envs[common]]
[17:40:44.121]                 NAMES <- toupper(changed)
[17:40:44.121]                 args <- list()
[17:40:44.121]                 for (kk in seq_along(NAMES)) {
[17:40:44.121]                   name <- changed[[kk]]
[17:40:44.121]                   NAME <- NAMES[[kk]]
[17:40:44.121]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.121]                     next
[17:40:44.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.121]                 }
[17:40:44.121]                 NAMES <- toupper(added)
[17:40:44.121]                 for (kk in seq_along(NAMES)) {
[17:40:44.121]                   name <- added[[kk]]
[17:40:44.121]                   NAME <- NAMES[[kk]]
[17:40:44.121]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.121]                     next
[17:40:44.121]                   args[[name]] <- ""
[17:40:44.121]                 }
[17:40:44.121]                 NAMES <- toupper(removed)
[17:40:44.121]                 for (kk in seq_along(NAMES)) {
[17:40:44.121]                   name <- removed[[kk]]
[17:40:44.121]                   NAME <- NAMES[[kk]]
[17:40:44.121]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.121]                     next
[17:40:44.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.121]                 }
[17:40:44.121]                 if (length(args) > 0) 
[17:40:44.121]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.121]             }
[17:40:44.121]             else {
[17:40:44.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.121]             }
[17:40:44.121]             {
[17:40:44.121]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.121]                   0L) {
[17:40:44.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.121]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.121]                   base::options(opts)
[17:40:44.121]                 }
[17:40:44.121]                 {
[17:40:44.121]                   {
[17:40:44.121]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.121]                     NULL
[17:40:44.121]                   }
[17:40:44.121]                   options(future.plan = NULL)
[17:40:44.121]                   if (is.na(NA_character_)) 
[17:40:44.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.121]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.121]                     .init = FALSE)
[17:40:44.121]                 }
[17:40:44.121]             }
[17:40:44.121]         }
[17:40:44.121]     })
[17:40:44.121]     if (TRUE) {
[17:40:44.121]         base::sink(type = "output", split = FALSE)
[17:40:44.121]         if (TRUE) {
[17:40:44.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.121]         }
[17:40:44.121]         else {
[17:40:44.121]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.121]         }
[17:40:44.121]         base::close(...future.stdout)
[17:40:44.121]         ...future.stdout <- NULL
[17:40:44.121]     }
[17:40:44.121]     ...future.result$conditions <- ...future.conditions
[17:40:44.121]     ...future.result$finished <- base::Sys.time()
[17:40:44.121]     ...future.result
[17:40:44.121] }
[17:40:44.125] requestCore(): workers = 2
[17:40:44.125] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.136] result() for MulticoreFuture ...
[17:40:44.137] result() for MulticoreFuture ...
[17:40:44.137] result() for MulticoreFuture ... done
[17:40:44.137] result() for MulticoreFuture ... done
[17:40:44.137] result() for MulticoreFuture ...
[17:40:44.138] result() for MulticoreFuture ... done
[17:40:44.140] MulticoreFuture started
[17:40:44.141] - Launch lazy future ... done
[17:40:44.141] run() for ‘MulticoreFuture’ ... done
[17:40:44.141] plan(): Setting new future strategy stack:
[17:40:44.142] resolve() on environment ...
[17:40:44.142]  recursive: 0
[17:40:44.142] List of future strategies:
[17:40:44.142] 1. sequential:
[17:40:44.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.142]    - tweaked: FALSE
[17:40:44.142]    - call: NULL
[17:40:44.143] plan(): nbrOfWorkers() = 1
[17:40:44.143]  elements: [3] ‘a’, ‘b’, ‘c’
[17:40:44.144] Future #1
[17:40:44.144]  length: 2 (resolved future 1)
[17:40:44.145] plan(): Setting new future strategy stack:
[17:40:44.145] List of future strategies:
[17:40:44.145] 1. multicore:
[17:40:44.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.145]    - tweaked: FALSE
[17:40:44.145]    - call: plan(strategy)
[17:40:44.150] plan(): nbrOfWorkers() = 2
[17:40:44.150] Future #2
[17:40:44.150]  length: 1 (resolved future 2)
[17:40:44.150]  length: 0 (resolved future 3)
[17:40:44.151] resolve() on environment ... DONE
[17:40:44.152] getGlobalsAndPackages() ...
[17:40:44.152] Searching for globals...
[17:40:44.153] - globals found: [1] ‘{’
[17:40:44.154] Searching for globals ... DONE
[17:40:44.154] Resolving globals: FALSE
[17:40:44.154] 
[17:40:44.154] 
[17:40:44.154] getGlobalsAndPackages() ... DONE
[17:40:44.155] run() for ‘Future’ ...
[17:40:44.155] - state: ‘created’
[17:40:44.155] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.160]   - Field: ‘label’
[17:40:44.160]   - Field: ‘local’
[17:40:44.161]   - Field: ‘owner’
[17:40:44.161]   - Field: ‘envir’
[17:40:44.161]   - Field: ‘workers’
[17:40:44.161]   - Field: ‘packages’
[17:40:44.161]   - Field: ‘gc’
[17:40:44.161]   - Field: ‘job’
[17:40:44.161]   - Field: ‘conditions’
[17:40:44.162]   - Field: ‘expr’
[17:40:44.162]   - Field: ‘uuid’
[17:40:44.162]   - Field: ‘seed’
[17:40:44.162]   - Field: ‘version’
[17:40:44.162]   - Field: ‘result’
[17:40:44.162]   - Field: ‘asynchronous’
[17:40:44.162]   - Field: ‘calls’
[17:40:44.163]   - Field: ‘globals’
[17:40:44.163]   - Field: ‘stdout’
[17:40:44.163]   - Field: ‘earlySignal’
[17:40:44.163]   - Field: ‘lazy’
[17:40:44.163]   - Field: ‘state’
[17:40:44.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.163] - Launch lazy future ...
[17:40:44.168] Packages needed by the future expression (n = 0): <none>
[17:40:44.168] Packages needed by future strategies (n = 0): <none>
[17:40:44.170] {
[17:40:44.170]     {
[17:40:44.170]         {
[17:40:44.170]             ...future.startTime <- base::Sys.time()
[17:40:44.170]             {
[17:40:44.170]                 {
[17:40:44.170]                   {
[17:40:44.170]                     {
[17:40:44.170]                       base::local({
[17:40:44.170]                         has_future <- base::requireNamespace("future", 
[17:40:44.170]                           quietly = TRUE)
[17:40:44.170]                         if (has_future) {
[17:40:44.170]                           ns <- base::getNamespace("future")
[17:40:44.170]                           version <- ns[[".package"]][["version"]]
[17:40:44.170]                           if (is.null(version)) 
[17:40:44.170]                             version <- utils::packageVersion("future")
[17:40:44.170]                         }
[17:40:44.170]                         else {
[17:40:44.170]                           version <- NULL
[17:40:44.170]                         }
[17:40:44.170]                         if (!has_future || version < "1.8.0") {
[17:40:44.170]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.170]                             "", base::R.version$version.string), 
[17:40:44.170]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.170]                               "release", "version")], collapse = " "), 
[17:40:44.170]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.170]                             info)
[17:40:44.170]                           info <- base::paste(info, collapse = "; ")
[17:40:44.170]                           if (!has_future) {
[17:40:44.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.170]                               info)
[17:40:44.170]                           }
[17:40:44.170]                           else {
[17:40:44.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.170]                               info, version)
[17:40:44.170]                           }
[17:40:44.170]                           base::stop(msg)
[17:40:44.170]                         }
[17:40:44.170]                       })
[17:40:44.170]                     }
[17:40:44.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.170]                     base::options(mc.cores = 1L)
[17:40:44.170]                   }
[17:40:44.170]                   ...future.strategy.old <- future::plan("list")
[17:40:44.170]                   options(future.plan = NULL)
[17:40:44.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.170]                 }
[17:40:44.170]                 ...future.workdir <- getwd()
[17:40:44.170]             }
[17:40:44.170]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.170]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.170]         }
[17:40:44.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.170]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.170]             base::names(...future.oldOptions))
[17:40:44.170]     }
[17:40:44.170]     if (FALSE) {
[17:40:44.170]     }
[17:40:44.170]     else {
[17:40:44.170]         if (TRUE) {
[17:40:44.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.170]                 open = "w")
[17:40:44.170]         }
[17:40:44.170]         else {
[17:40:44.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.170]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.170]         }
[17:40:44.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.170]             base::sink(type = "output", split = FALSE)
[17:40:44.170]             base::close(...future.stdout)
[17:40:44.170]         }, add = TRUE)
[17:40:44.170]     }
[17:40:44.170]     ...future.frame <- base::sys.nframe()
[17:40:44.170]     ...future.conditions <- base::list()
[17:40:44.170]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.170]     if (FALSE) {
[17:40:44.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.170]     }
[17:40:44.170]     ...future.result <- base::tryCatch({
[17:40:44.170]         base::withCallingHandlers({
[17:40:44.170]             ...future.value <- base::withVisible(base::local({
[17:40:44.170]                 withCallingHandlers({
[17:40:44.170]                   {
[17:40:44.170]                     1
[17:40:44.170]                   }
[17:40:44.170]                 }, immediateCondition = function(cond) {
[17:40:44.170]                   save_rds <- function (object, pathname, ...) 
[17:40:44.170]                   {
[17:40:44.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.170]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.170]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.170]                         fi_tmp[["mtime"]])
[17:40:44.170]                     }
[17:40:44.170]                     tryCatch({
[17:40:44.170]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.170]                     }, error = function(ex) {
[17:40:44.170]                       msg <- conditionMessage(ex)
[17:40:44.170]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.170]                         fi_tmp[["mtime"]], msg)
[17:40:44.170]                       ex$message <- msg
[17:40:44.170]                       stop(ex)
[17:40:44.170]                     })
[17:40:44.170]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.170]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.170]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.170]                       fi <- file.info(pathname)
[17:40:44.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.170]                         fi[["size"]], fi[["mtime"]])
[17:40:44.170]                       stop(msg)
[17:40:44.170]                     }
[17:40:44.170]                     invisible(pathname)
[17:40:44.170]                   }
[17:40:44.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.170]                     rootPath = tempdir()) 
[17:40:44.170]                   {
[17:40:44.170]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.170]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.170]                       tmpdir = path, fileext = ".rds")
[17:40:44.170]                     save_rds(obj, file)
[17:40:44.170]                   }
[17:40:44.170]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.170]                   {
[17:40:44.170]                     inherits <- base::inherits
[17:40:44.170]                     invokeRestart <- base::invokeRestart
[17:40:44.170]                     is.null <- base::is.null
[17:40:44.170]                     muffled <- FALSE
[17:40:44.170]                     if (inherits(cond, "message")) {
[17:40:44.170]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.170]                       if (muffled) 
[17:40:44.170]                         invokeRestart("muffleMessage")
[17:40:44.170]                     }
[17:40:44.170]                     else if (inherits(cond, "warning")) {
[17:40:44.170]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.170]                       if (muffled) 
[17:40:44.170]                         invokeRestart("muffleWarning")
[17:40:44.170]                     }
[17:40:44.170]                     else if (inherits(cond, "condition")) {
[17:40:44.170]                       if (!is.null(pattern)) {
[17:40:44.170]                         computeRestarts <- base::computeRestarts
[17:40:44.170]                         grepl <- base::grepl
[17:40:44.170]                         restarts <- computeRestarts(cond)
[17:40:44.170]                         for (restart in restarts) {
[17:40:44.170]                           name <- restart$name
[17:40:44.170]                           if (is.null(name)) 
[17:40:44.170]                             next
[17:40:44.170]                           if (!grepl(pattern, name)) 
[17:40:44.170]                             next
[17:40:44.170]                           invokeRestart(restart)
[17:40:44.170]                           muffled <- TRUE
[17:40:44.170]                           break
[17:40:44.170]                         }
[17:40:44.170]                       }
[17:40:44.170]                     }
[17:40:44.170]                     invisible(muffled)
[17:40:44.170]                   }
[17:40:44.170]                   muffleCondition(cond)
[17:40:44.170]                 })
[17:40:44.170]             }))
[17:40:44.170]             future::FutureResult(value = ...future.value$value, 
[17:40:44.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.170]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.170]                     ...future.globalenv.names))
[17:40:44.170]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.170]         }, condition = base::local({
[17:40:44.170]             c <- base::c
[17:40:44.170]             inherits <- base::inherits
[17:40:44.170]             invokeRestart <- base::invokeRestart
[17:40:44.170]             length <- base::length
[17:40:44.170]             list <- base::list
[17:40:44.170]             seq.int <- base::seq.int
[17:40:44.170]             signalCondition <- base::signalCondition
[17:40:44.170]             sys.calls <- base::sys.calls
[17:40:44.170]             `[[` <- base::`[[`
[17:40:44.170]             `+` <- base::`+`
[17:40:44.170]             `<<-` <- base::`<<-`
[17:40:44.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.170]                   3L)]
[17:40:44.170]             }
[17:40:44.170]             function(cond) {
[17:40:44.170]                 is_error <- inherits(cond, "error")
[17:40:44.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.170]                   NULL)
[17:40:44.170]                 if (is_error) {
[17:40:44.170]                   sessionInformation <- function() {
[17:40:44.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.170]                       search = base::search(), system = base::Sys.info())
[17:40:44.170]                   }
[17:40:44.170]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.170]                     cond$call), session = sessionInformation(), 
[17:40:44.170]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.170]                   signalCondition(cond)
[17:40:44.170]                 }
[17:40:44.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.170]                 "immediateCondition"))) {
[17:40:44.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.170]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.170]                   if (TRUE && !signal) {
[17:40:44.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.170]                     {
[17:40:44.170]                       inherits <- base::inherits
[17:40:44.170]                       invokeRestart <- base::invokeRestart
[17:40:44.170]                       is.null <- base::is.null
[17:40:44.170]                       muffled <- FALSE
[17:40:44.170]                       if (inherits(cond, "message")) {
[17:40:44.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.170]                         if (muffled) 
[17:40:44.170]                           invokeRestart("muffleMessage")
[17:40:44.170]                       }
[17:40:44.170]                       else if (inherits(cond, "warning")) {
[17:40:44.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.170]                         if (muffled) 
[17:40:44.170]                           invokeRestart("muffleWarning")
[17:40:44.170]                       }
[17:40:44.170]                       else if (inherits(cond, "condition")) {
[17:40:44.170]                         if (!is.null(pattern)) {
[17:40:44.170]                           computeRestarts <- base::computeRestarts
[17:40:44.170]                           grepl <- base::grepl
[17:40:44.170]                           restarts <- computeRestarts(cond)
[17:40:44.170]                           for (restart in restarts) {
[17:40:44.170]                             name <- restart$name
[17:40:44.170]                             if (is.null(name)) 
[17:40:44.170]                               next
[17:40:44.170]                             if (!grepl(pattern, name)) 
[17:40:44.170]                               next
[17:40:44.170]                             invokeRestart(restart)
[17:40:44.170]                             muffled <- TRUE
[17:40:44.170]                             break
[17:40:44.170]                           }
[17:40:44.170]                         }
[17:40:44.170]                       }
[17:40:44.170]                       invisible(muffled)
[17:40:44.170]                     }
[17:40:44.170]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.170]                   }
[17:40:44.170]                 }
[17:40:44.170]                 else {
[17:40:44.170]                   if (TRUE) {
[17:40:44.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.170]                     {
[17:40:44.170]                       inherits <- base::inherits
[17:40:44.170]                       invokeRestart <- base::invokeRestart
[17:40:44.170]                       is.null <- base::is.null
[17:40:44.170]                       muffled <- FALSE
[17:40:44.170]                       if (inherits(cond, "message")) {
[17:40:44.170]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.170]                         if (muffled) 
[17:40:44.170]                           invokeRestart("muffleMessage")
[17:40:44.170]                       }
[17:40:44.170]                       else if (inherits(cond, "warning")) {
[17:40:44.170]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.170]                         if (muffled) 
[17:40:44.170]                           invokeRestart("muffleWarning")
[17:40:44.170]                       }
[17:40:44.170]                       else if (inherits(cond, "condition")) {
[17:40:44.170]                         if (!is.null(pattern)) {
[17:40:44.170]                           computeRestarts <- base::computeRestarts
[17:40:44.170]                           grepl <- base::grepl
[17:40:44.170]                           restarts <- computeRestarts(cond)
[17:40:44.170]                           for (restart in restarts) {
[17:40:44.170]                             name <- restart$name
[17:40:44.170]                             if (is.null(name)) 
[17:40:44.170]                               next
[17:40:44.170]                             if (!grepl(pattern, name)) 
[17:40:44.170]                               next
[17:40:44.170]                             invokeRestart(restart)
[17:40:44.170]                             muffled <- TRUE
[17:40:44.170]                             break
[17:40:44.170]                           }
[17:40:44.170]                         }
[17:40:44.170]                       }
[17:40:44.170]                       invisible(muffled)
[17:40:44.170]                     }
[17:40:44.170]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.170]                   }
[17:40:44.170]                 }
[17:40:44.170]             }
[17:40:44.170]         }))
[17:40:44.170]     }, error = function(ex) {
[17:40:44.170]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.170]                 ...future.rng), started = ...future.startTime, 
[17:40:44.170]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.170]             version = "1.8"), class = "FutureResult")
[17:40:44.170]     }, finally = {
[17:40:44.170]         if (!identical(...future.workdir, getwd())) 
[17:40:44.170]             setwd(...future.workdir)
[17:40:44.170]         {
[17:40:44.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.170]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.170]             }
[17:40:44.170]             base::options(...future.oldOptions)
[17:40:44.170]             if (.Platform$OS.type == "windows") {
[17:40:44.170]                 old_names <- names(...future.oldEnvVars)
[17:40:44.170]                 envs <- base::Sys.getenv()
[17:40:44.170]                 names <- names(envs)
[17:40:44.170]                 common <- intersect(names, old_names)
[17:40:44.170]                 added <- setdiff(names, old_names)
[17:40:44.170]                 removed <- setdiff(old_names, names)
[17:40:44.170]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.170]                   envs[common]]
[17:40:44.170]                 NAMES <- toupper(changed)
[17:40:44.170]                 args <- list()
[17:40:44.170]                 for (kk in seq_along(NAMES)) {
[17:40:44.170]                   name <- changed[[kk]]
[17:40:44.170]                   NAME <- NAMES[[kk]]
[17:40:44.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.170]                     next
[17:40:44.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.170]                 }
[17:40:44.170]                 NAMES <- toupper(added)
[17:40:44.170]                 for (kk in seq_along(NAMES)) {
[17:40:44.170]                   name <- added[[kk]]
[17:40:44.170]                   NAME <- NAMES[[kk]]
[17:40:44.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.170]                     next
[17:40:44.170]                   args[[name]] <- ""
[17:40:44.170]                 }
[17:40:44.170]                 NAMES <- toupper(removed)
[17:40:44.170]                 for (kk in seq_along(NAMES)) {
[17:40:44.170]                   name <- removed[[kk]]
[17:40:44.170]                   NAME <- NAMES[[kk]]
[17:40:44.170]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.170]                     next
[17:40:44.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.170]                 }
[17:40:44.170]                 if (length(args) > 0) 
[17:40:44.170]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.170]             }
[17:40:44.170]             else {
[17:40:44.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.170]             }
[17:40:44.170]             {
[17:40:44.170]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.170]                   0L) {
[17:40:44.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.170]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.170]                   base::options(opts)
[17:40:44.170]                 }
[17:40:44.170]                 {
[17:40:44.170]                   {
[17:40:44.170]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.170]                     NULL
[17:40:44.170]                   }
[17:40:44.170]                   options(future.plan = NULL)
[17:40:44.170]                   if (is.na(NA_character_)) 
[17:40:44.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.170]                     .init = FALSE)
[17:40:44.170]                 }
[17:40:44.170]             }
[17:40:44.170]         }
[17:40:44.170]     })
[17:40:44.170]     if (TRUE) {
[17:40:44.170]         base::sink(type = "output", split = FALSE)
[17:40:44.170]         if (TRUE) {
[17:40:44.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.170]         }
[17:40:44.170]         else {
[17:40:44.170]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.170]         }
[17:40:44.170]         base::close(...future.stdout)
[17:40:44.170]         ...future.stdout <- NULL
[17:40:44.170]     }
[17:40:44.170]     ...future.result$conditions <- ...future.conditions
[17:40:44.170]     ...future.result$finished <- base::Sys.time()
[17:40:44.170]     ...future.result
[17:40:44.170] }
[17:40:44.172] requestCore(): workers = 2
[17:40:44.173] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.184] result() for MulticoreFuture ...
[17:40:44.185] result() for MulticoreFuture ...
[17:40:44.185] result() for MulticoreFuture ... done
[17:40:44.185] result() for MulticoreFuture ... done
[17:40:44.185] result() for MulticoreFuture ...
[17:40:44.186] result() for MulticoreFuture ... done
[17:40:44.188] MulticoreFuture started
[17:40:44.189] - Launch lazy future ... done
[17:40:44.189] run() for ‘MulticoreFuture’ ... done
[17:40:44.189] plan(): Setting new future strategy stack:
[17:40:44.191] getGlobalsAndPackages() ...
[17:40:44.190] List of future strategies:
[17:40:44.190] 1. sequential:
[17:40:44.190]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.190]    - tweaked: FALSE
[17:40:44.190]    - call: NULL
[17:40:44.191] Searching for globals...
[17:40:44.191] plan(): nbrOfWorkers() = 1
[17:40:44.193] - globals found: [1] ‘{’
[17:40:44.194] Searching for globals ... DONE
[17:40:44.194] Resolving globals: FALSE
[17:40:44.194] plan(): Setting new future strategy stack:
[17:40:44.195] 
[17:40:44.195] 
[17:40:44.195] getGlobalsAndPackages() ... DONE
[17:40:44.195] List of future strategies:
[17:40:44.195] 1. multicore:
[17:40:44.195]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.195]    - tweaked: FALSE
[17:40:44.195]    - call: plan(strategy)
[17:40:44.196] run() for ‘Future’ ...
[17:40:44.196] - state: ‘created’
[17:40:44.196] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.200] plan(): nbrOfWorkers() = 2
[17:40:44.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.202]   - Field: ‘label’
[17:40:44.202]   - Field: ‘local’
[17:40:44.202]   - Field: ‘owner’
[17:40:44.202]   - Field: ‘envir’
[17:40:44.202]   - Field: ‘workers’
[17:40:44.203]   - Field: ‘packages’
[17:40:44.203]   - Field: ‘gc’
[17:40:44.203]   - Field: ‘job’
[17:40:44.203]   - Field: ‘conditions’
[17:40:44.203]   - Field: ‘expr’
[17:40:44.203]   - Field: ‘uuid’
[17:40:44.203]   - Field: ‘seed’
[17:40:44.204]   - Field: ‘version’
[17:40:44.204]   - Field: ‘result’
[17:40:44.204]   - Field: ‘asynchronous’
[17:40:44.204]   - Field: ‘calls’
[17:40:44.204]   - Field: ‘globals’
[17:40:44.204]   - Field: ‘stdout’
[17:40:44.204]   - Field: ‘earlySignal’
[17:40:44.205]   - Field: ‘lazy’
[17:40:44.205]   - Field: ‘state’
[17:40:44.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.205] - Launch lazy future ...
[17:40:44.206] Packages needed by the future expression (n = 0): <none>
[17:40:44.206] Packages needed by future strategies (n = 0): <none>
[17:40:44.207] {
[17:40:44.207]     {
[17:40:44.207]         {
[17:40:44.207]             ...future.startTime <- base::Sys.time()
[17:40:44.207]             {
[17:40:44.207]                 {
[17:40:44.207]                   {
[17:40:44.207]                     {
[17:40:44.207]                       base::local({
[17:40:44.207]                         has_future <- base::requireNamespace("future", 
[17:40:44.207]                           quietly = TRUE)
[17:40:44.207]                         if (has_future) {
[17:40:44.207]                           ns <- base::getNamespace("future")
[17:40:44.207]                           version <- ns[[".package"]][["version"]]
[17:40:44.207]                           if (is.null(version)) 
[17:40:44.207]                             version <- utils::packageVersion("future")
[17:40:44.207]                         }
[17:40:44.207]                         else {
[17:40:44.207]                           version <- NULL
[17:40:44.207]                         }
[17:40:44.207]                         if (!has_future || version < "1.8.0") {
[17:40:44.207]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.207]                             "", base::R.version$version.string), 
[17:40:44.207]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.207]                               "release", "version")], collapse = " "), 
[17:40:44.207]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.207]                             info)
[17:40:44.207]                           info <- base::paste(info, collapse = "; ")
[17:40:44.207]                           if (!has_future) {
[17:40:44.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.207]                               info)
[17:40:44.207]                           }
[17:40:44.207]                           else {
[17:40:44.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.207]                               info, version)
[17:40:44.207]                           }
[17:40:44.207]                           base::stop(msg)
[17:40:44.207]                         }
[17:40:44.207]                       })
[17:40:44.207]                     }
[17:40:44.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.207]                     base::options(mc.cores = 1L)
[17:40:44.207]                   }
[17:40:44.207]                   ...future.strategy.old <- future::plan("list")
[17:40:44.207]                   options(future.plan = NULL)
[17:40:44.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.207]                 }
[17:40:44.207]                 ...future.workdir <- getwd()
[17:40:44.207]             }
[17:40:44.207]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.207]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.207]         }
[17:40:44.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.207]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.207]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.207]             base::names(...future.oldOptions))
[17:40:44.207]     }
[17:40:44.207]     if (FALSE) {
[17:40:44.207]     }
[17:40:44.207]     else {
[17:40:44.207]         if (TRUE) {
[17:40:44.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.207]                 open = "w")
[17:40:44.207]         }
[17:40:44.207]         else {
[17:40:44.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.207]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.207]         }
[17:40:44.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.207]             base::sink(type = "output", split = FALSE)
[17:40:44.207]             base::close(...future.stdout)
[17:40:44.207]         }, add = TRUE)
[17:40:44.207]     }
[17:40:44.207]     ...future.frame <- base::sys.nframe()
[17:40:44.207]     ...future.conditions <- base::list()
[17:40:44.207]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.207]     if (FALSE) {
[17:40:44.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.207]     }
[17:40:44.207]     ...future.result <- base::tryCatch({
[17:40:44.207]         base::withCallingHandlers({
[17:40:44.207]             ...future.value <- base::withVisible(base::local({
[17:40:44.207]                 withCallingHandlers({
[17:40:44.207]                   {
[17:40:44.207]                     2
[17:40:44.207]                   }
[17:40:44.207]                 }, immediateCondition = function(cond) {
[17:40:44.207]                   save_rds <- function (object, pathname, ...) 
[17:40:44.207]                   {
[17:40:44.207]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.207]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.207]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.207]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.207]                         fi_tmp[["mtime"]])
[17:40:44.207]                     }
[17:40:44.207]                     tryCatch({
[17:40:44.207]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.207]                     }, error = function(ex) {
[17:40:44.207]                       msg <- conditionMessage(ex)
[17:40:44.207]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.207]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.207]                         fi_tmp[["mtime"]], msg)
[17:40:44.207]                       ex$message <- msg
[17:40:44.207]                       stop(ex)
[17:40:44.207]                     })
[17:40:44.207]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.207]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.207]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.207]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.207]                       fi <- file.info(pathname)
[17:40:44.207]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.207]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.207]                         fi[["size"]], fi[["mtime"]])
[17:40:44.207]                       stop(msg)
[17:40:44.207]                     }
[17:40:44.207]                     invisible(pathname)
[17:40:44.207]                   }
[17:40:44.207]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.207]                     rootPath = tempdir()) 
[17:40:44.207]                   {
[17:40:44.207]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.207]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.207]                       tmpdir = path, fileext = ".rds")
[17:40:44.207]                     save_rds(obj, file)
[17:40:44.207]                   }
[17:40:44.207]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.207]                   {
[17:40:44.207]                     inherits <- base::inherits
[17:40:44.207]                     invokeRestart <- base::invokeRestart
[17:40:44.207]                     is.null <- base::is.null
[17:40:44.207]                     muffled <- FALSE
[17:40:44.207]                     if (inherits(cond, "message")) {
[17:40:44.207]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.207]                       if (muffled) 
[17:40:44.207]                         invokeRestart("muffleMessage")
[17:40:44.207]                     }
[17:40:44.207]                     else if (inherits(cond, "warning")) {
[17:40:44.207]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.207]                       if (muffled) 
[17:40:44.207]                         invokeRestart("muffleWarning")
[17:40:44.207]                     }
[17:40:44.207]                     else if (inherits(cond, "condition")) {
[17:40:44.207]                       if (!is.null(pattern)) {
[17:40:44.207]                         computeRestarts <- base::computeRestarts
[17:40:44.207]                         grepl <- base::grepl
[17:40:44.207]                         restarts <- computeRestarts(cond)
[17:40:44.207]                         for (restart in restarts) {
[17:40:44.207]                           name <- restart$name
[17:40:44.207]                           if (is.null(name)) 
[17:40:44.207]                             next
[17:40:44.207]                           if (!grepl(pattern, name)) 
[17:40:44.207]                             next
[17:40:44.207]                           invokeRestart(restart)
[17:40:44.207]                           muffled <- TRUE
[17:40:44.207]                           break
[17:40:44.207]                         }
[17:40:44.207]                       }
[17:40:44.207]                     }
[17:40:44.207]                     invisible(muffled)
[17:40:44.207]                   }
[17:40:44.207]                   muffleCondition(cond)
[17:40:44.207]                 })
[17:40:44.207]             }))
[17:40:44.207]             future::FutureResult(value = ...future.value$value, 
[17:40:44.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.207]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.207]                     ...future.globalenv.names))
[17:40:44.207]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.207]         }, condition = base::local({
[17:40:44.207]             c <- base::c
[17:40:44.207]             inherits <- base::inherits
[17:40:44.207]             invokeRestart <- base::invokeRestart
[17:40:44.207]             length <- base::length
[17:40:44.207]             list <- base::list
[17:40:44.207]             seq.int <- base::seq.int
[17:40:44.207]             signalCondition <- base::signalCondition
[17:40:44.207]             sys.calls <- base::sys.calls
[17:40:44.207]             `[[` <- base::`[[`
[17:40:44.207]             `+` <- base::`+`
[17:40:44.207]             `<<-` <- base::`<<-`
[17:40:44.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.207]                   3L)]
[17:40:44.207]             }
[17:40:44.207]             function(cond) {
[17:40:44.207]                 is_error <- inherits(cond, "error")
[17:40:44.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.207]                   NULL)
[17:40:44.207]                 if (is_error) {
[17:40:44.207]                   sessionInformation <- function() {
[17:40:44.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.207]                       search = base::search(), system = base::Sys.info())
[17:40:44.207]                   }
[17:40:44.207]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.207]                     cond$call), session = sessionInformation(), 
[17:40:44.207]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.207]                   signalCondition(cond)
[17:40:44.207]                 }
[17:40:44.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.207]                 "immediateCondition"))) {
[17:40:44.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.207]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.207]                   if (TRUE && !signal) {
[17:40:44.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.207]                     {
[17:40:44.207]                       inherits <- base::inherits
[17:40:44.207]                       invokeRestart <- base::invokeRestart
[17:40:44.207]                       is.null <- base::is.null
[17:40:44.207]                       muffled <- FALSE
[17:40:44.207]                       if (inherits(cond, "message")) {
[17:40:44.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.207]                         if (muffled) 
[17:40:44.207]                           invokeRestart("muffleMessage")
[17:40:44.207]                       }
[17:40:44.207]                       else if (inherits(cond, "warning")) {
[17:40:44.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.207]                         if (muffled) 
[17:40:44.207]                           invokeRestart("muffleWarning")
[17:40:44.207]                       }
[17:40:44.207]                       else if (inherits(cond, "condition")) {
[17:40:44.207]                         if (!is.null(pattern)) {
[17:40:44.207]                           computeRestarts <- base::computeRestarts
[17:40:44.207]                           grepl <- base::grepl
[17:40:44.207]                           restarts <- computeRestarts(cond)
[17:40:44.207]                           for (restart in restarts) {
[17:40:44.207]                             name <- restart$name
[17:40:44.207]                             if (is.null(name)) 
[17:40:44.207]                               next
[17:40:44.207]                             if (!grepl(pattern, name)) 
[17:40:44.207]                               next
[17:40:44.207]                             invokeRestart(restart)
[17:40:44.207]                             muffled <- TRUE
[17:40:44.207]                             break
[17:40:44.207]                           }
[17:40:44.207]                         }
[17:40:44.207]                       }
[17:40:44.207]                       invisible(muffled)
[17:40:44.207]                     }
[17:40:44.207]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.207]                   }
[17:40:44.207]                 }
[17:40:44.207]                 else {
[17:40:44.207]                   if (TRUE) {
[17:40:44.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.207]                     {
[17:40:44.207]                       inherits <- base::inherits
[17:40:44.207]                       invokeRestart <- base::invokeRestart
[17:40:44.207]                       is.null <- base::is.null
[17:40:44.207]                       muffled <- FALSE
[17:40:44.207]                       if (inherits(cond, "message")) {
[17:40:44.207]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.207]                         if (muffled) 
[17:40:44.207]                           invokeRestart("muffleMessage")
[17:40:44.207]                       }
[17:40:44.207]                       else if (inherits(cond, "warning")) {
[17:40:44.207]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.207]                         if (muffled) 
[17:40:44.207]                           invokeRestart("muffleWarning")
[17:40:44.207]                       }
[17:40:44.207]                       else if (inherits(cond, "condition")) {
[17:40:44.207]                         if (!is.null(pattern)) {
[17:40:44.207]                           computeRestarts <- base::computeRestarts
[17:40:44.207]                           grepl <- base::grepl
[17:40:44.207]                           restarts <- computeRestarts(cond)
[17:40:44.207]                           for (restart in restarts) {
[17:40:44.207]                             name <- restart$name
[17:40:44.207]                             if (is.null(name)) 
[17:40:44.207]                               next
[17:40:44.207]                             if (!grepl(pattern, name)) 
[17:40:44.207]                               next
[17:40:44.207]                             invokeRestart(restart)
[17:40:44.207]                             muffled <- TRUE
[17:40:44.207]                             break
[17:40:44.207]                           }
[17:40:44.207]                         }
[17:40:44.207]                       }
[17:40:44.207]                       invisible(muffled)
[17:40:44.207]                     }
[17:40:44.207]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.207]                   }
[17:40:44.207]                 }
[17:40:44.207]             }
[17:40:44.207]         }))
[17:40:44.207]     }, error = function(ex) {
[17:40:44.207]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.207]                 ...future.rng), started = ...future.startTime, 
[17:40:44.207]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.207]             version = "1.8"), class = "FutureResult")
[17:40:44.207]     }, finally = {
[17:40:44.207]         if (!identical(...future.workdir, getwd())) 
[17:40:44.207]             setwd(...future.workdir)
[17:40:44.207]         {
[17:40:44.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.207]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.207]             }
[17:40:44.207]             base::options(...future.oldOptions)
[17:40:44.207]             if (.Platform$OS.type == "windows") {
[17:40:44.207]                 old_names <- names(...future.oldEnvVars)
[17:40:44.207]                 envs <- base::Sys.getenv()
[17:40:44.207]                 names <- names(envs)
[17:40:44.207]                 common <- intersect(names, old_names)
[17:40:44.207]                 added <- setdiff(names, old_names)
[17:40:44.207]                 removed <- setdiff(old_names, names)
[17:40:44.207]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.207]                   envs[common]]
[17:40:44.207]                 NAMES <- toupper(changed)
[17:40:44.207]                 args <- list()
[17:40:44.207]                 for (kk in seq_along(NAMES)) {
[17:40:44.207]                   name <- changed[[kk]]
[17:40:44.207]                   NAME <- NAMES[[kk]]
[17:40:44.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.207]                     next
[17:40:44.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.207]                 }
[17:40:44.207]                 NAMES <- toupper(added)
[17:40:44.207]                 for (kk in seq_along(NAMES)) {
[17:40:44.207]                   name <- added[[kk]]
[17:40:44.207]                   NAME <- NAMES[[kk]]
[17:40:44.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.207]                     next
[17:40:44.207]                   args[[name]] <- ""
[17:40:44.207]                 }
[17:40:44.207]                 NAMES <- toupper(removed)
[17:40:44.207]                 for (kk in seq_along(NAMES)) {
[17:40:44.207]                   name <- removed[[kk]]
[17:40:44.207]                   NAME <- NAMES[[kk]]
[17:40:44.207]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.207]                     next
[17:40:44.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.207]                 }
[17:40:44.207]                 if (length(args) > 0) 
[17:40:44.207]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.207]             }
[17:40:44.207]             else {
[17:40:44.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.207]             }
[17:40:44.207]             {
[17:40:44.207]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.207]                   0L) {
[17:40:44.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.207]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.207]                   base::options(opts)
[17:40:44.207]                 }
[17:40:44.207]                 {
[17:40:44.207]                   {
[17:40:44.207]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.207]                     NULL
[17:40:44.207]                   }
[17:40:44.207]                   options(future.plan = NULL)
[17:40:44.207]                   if (is.na(NA_character_)) 
[17:40:44.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.207]                     .init = FALSE)
[17:40:44.207]                 }
[17:40:44.207]             }
[17:40:44.207]         }
[17:40:44.207]     })
[17:40:44.207]     if (TRUE) {
[17:40:44.207]         base::sink(type = "output", split = FALSE)
[17:40:44.207]         if (TRUE) {
[17:40:44.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.207]         }
[17:40:44.207]         else {
[17:40:44.207]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.207]         }
[17:40:44.207]         base::close(...future.stdout)
[17:40:44.207]         ...future.stdout <- NULL
[17:40:44.207]     }
[17:40:44.207]     ...future.result$conditions <- ...future.conditions
[17:40:44.207]     ...future.result$finished <- base::Sys.time()
[17:40:44.207]     ...future.result
[17:40:44.207] }
[17:40:44.210] requestCore(): workers = 2
[17:40:44.210] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.221] result() for MulticoreFuture ...
[17:40:44.222] result() for MulticoreFuture ...
[17:40:44.222] result() for MulticoreFuture ... done
[17:40:44.222] result() for MulticoreFuture ... done
[17:40:44.222] result() for MulticoreFuture ...
[17:40:44.223] result() for MulticoreFuture ... done
[17:40:44.225] MulticoreFuture started
[17:40:44.226] - Launch lazy future ... done
[17:40:44.226] run() for ‘MulticoreFuture’ ... done
[17:40:44.227] plan(): Setting new future strategy stack:
[17:40:44.227] resolve() on environment ...
[17:40:44.227]  recursive: 0
[17:40:44.227] List of future strategies:
[17:40:44.227] 1. sequential:
[17:40:44.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.227]    - tweaked: FALSE
[17:40:44.227]    - call: NULL
[17:40:44.228]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:40:44.229] plan(): nbrOfWorkers() = 1
[17:40:44.229] Future #1
[17:40:44.229]  length: 2 (resolved future 1)
[17:40:44.232] plan(): Setting new future strategy stack:
[17:40:44.232] List of future strategies:
[17:40:44.232] 1. multicore:
[17:40:44.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.232]    - tweaked: FALSE
[17:40:44.232]    - call: plan(strategy)
[17:40:44.239] plan(): nbrOfWorkers() = 2
[17:40:44.239] Future #2
[17:40:44.239]  length: 1 (resolved future 2)
[17:40:44.240]  length: 0 (resolved future 3)
[17:40:44.240] resolve() on environment ... DONE
[17:40:44.240] getGlobalsAndPackages() ...
[17:40:44.241] Searching for globals...
[17:40:44.242] - globals found: [1] ‘{’
[17:40:44.242] Searching for globals ... DONE
[17:40:44.242] Resolving globals: FALSE
[17:40:44.243] 
[17:40:44.243] 
[17:40:44.243] getGlobalsAndPackages() ... DONE
[17:40:44.243] run() for ‘Future’ ...
[17:40:44.244] - state: ‘created’
[17:40:44.244] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.250]   - Field: ‘label’
[17:40:44.250]   - Field: ‘local’
[17:40:44.251]   - Field: ‘owner’
[17:40:44.251]   - Field: ‘envir’
[17:40:44.251]   - Field: ‘workers’
[17:40:44.251]   - Field: ‘packages’
[17:40:44.252]   - Field: ‘gc’
[17:40:44.252]   - Field: ‘job’
[17:40:44.252]   - Field: ‘conditions’
[17:40:44.252]   - Field: ‘expr’
[17:40:44.253]   - Field: ‘uuid’
[17:40:44.253]   - Field: ‘seed’
[17:40:44.253]   - Field: ‘version’
[17:40:44.253]   - Field: ‘result’
[17:40:44.254]   - Field: ‘asynchronous’
[17:40:44.254]   - Field: ‘calls’
[17:40:44.254]   - Field: ‘globals’
[17:40:44.254]   - Field: ‘stdout’
[17:40:44.255]   - Field: ‘earlySignal’
[17:40:44.255]   - Field: ‘lazy’
[17:40:44.255]   - Field: ‘state’
[17:40:44.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.256] - Launch lazy future ...
[17:40:44.256] Packages needed by the future expression (n = 0): <none>
[17:40:44.257] Packages needed by future strategies (n = 0): <none>
[17:40:44.258] {
[17:40:44.258]     {
[17:40:44.258]         {
[17:40:44.258]             ...future.startTime <- base::Sys.time()
[17:40:44.258]             {
[17:40:44.258]                 {
[17:40:44.258]                   {
[17:40:44.258]                     {
[17:40:44.258]                       base::local({
[17:40:44.258]                         has_future <- base::requireNamespace("future", 
[17:40:44.258]                           quietly = TRUE)
[17:40:44.258]                         if (has_future) {
[17:40:44.258]                           ns <- base::getNamespace("future")
[17:40:44.258]                           version <- ns[[".package"]][["version"]]
[17:40:44.258]                           if (is.null(version)) 
[17:40:44.258]                             version <- utils::packageVersion("future")
[17:40:44.258]                         }
[17:40:44.258]                         else {
[17:40:44.258]                           version <- NULL
[17:40:44.258]                         }
[17:40:44.258]                         if (!has_future || version < "1.8.0") {
[17:40:44.258]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.258]                             "", base::R.version$version.string), 
[17:40:44.258]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.258]                               "release", "version")], collapse = " "), 
[17:40:44.258]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.258]                             info)
[17:40:44.258]                           info <- base::paste(info, collapse = "; ")
[17:40:44.258]                           if (!has_future) {
[17:40:44.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.258]                               info)
[17:40:44.258]                           }
[17:40:44.258]                           else {
[17:40:44.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.258]                               info, version)
[17:40:44.258]                           }
[17:40:44.258]                           base::stop(msg)
[17:40:44.258]                         }
[17:40:44.258]                       })
[17:40:44.258]                     }
[17:40:44.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.258]                     base::options(mc.cores = 1L)
[17:40:44.258]                   }
[17:40:44.258]                   ...future.strategy.old <- future::plan("list")
[17:40:44.258]                   options(future.plan = NULL)
[17:40:44.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.258]                 }
[17:40:44.258]                 ...future.workdir <- getwd()
[17:40:44.258]             }
[17:40:44.258]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.258]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.258]         }
[17:40:44.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.258]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.258]             base::names(...future.oldOptions))
[17:40:44.258]     }
[17:40:44.258]     if (FALSE) {
[17:40:44.258]     }
[17:40:44.258]     else {
[17:40:44.258]         if (TRUE) {
[17:40:44.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.258]                 open = "w")
[17:40:44.258]         }
[17:40:44.258]         else {
[17:40:44.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.258]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.258]         }
[17:40:44.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.258]             base::sink(type = "output", split = FALSE)
[17:40:44.258]             base::close(...future.stdout)
[17:40:44.258]         }, add = TRUE)
[17:40:44.258]     }
[17:40:44.258]     ...future.frame <- base::sys.nframe()
[17:40:44.258]     ...future.conditions <- base::list()
[17:40:44.258]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.258]     if (FALSE) {
[17:40:44.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.258]     }
[17:40:44.258]     ...future.result <- base::tryCatch({
[17:40:44.258]         base::withCallingHandlers({
[17:40:44.258]             ...future.value <- base::withVisible(base::local({
[17:40:44.258]                 withCallingHandlers({
[17:40:44.258]                   {
[17:40:44.258]                     1
[17:40:44.258]                   }
[17:40:44.258]                 }, immediateCondition = function(cond) {
[17:40:44.258]                   save_rds <- function (object, pathname, ...) 
[17:40:44.258]                   {
[17:40:44.258]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.258]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.258]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.258]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.258]                         fi_tmp[["mtime"]])
[17:40:44.258]                     }
[17:40:44.258]                     tryCatch({
[17:40:44.258]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.258]                     }, error = function(ex) {
[17:40:44.258]                       msg <- conditionMessage(ex)
[17:40:44.258]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.258]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.258]                         fi_tmp[["mtime"]], msg)
[17:40:44.258]                       ex$message <- msg
[17:40:44.258]                       stop(ex)
[17:40:44.258]                     })
[17:40:44.258]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.258]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.258]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.258]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.258]                       fi <- file.info(pathname)
[17:40:44.258]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.258]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.258]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.258]                         fi[["size"]], fi[["mtime"]])
[17:40:44.258]                       stop(msg)
[17:40:44.258]                     }
[17:40:44.258]                     invisible(pathname)
[17:40:44.258]                   }
[17:40:44.258]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.258]                     rootPath = tempdir()) 
[17:40:44.258]                   {
[17:40:44.258]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.258]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.258]                       tmpdir = path, fileext = ".rds")
[17:40:44.258]                     save_rds(obj, file)
[17:40:44.258]                   }
[17:40:44.258]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.258]                   {
[17:40:44.258]                     inherits <- base::inherits
[17:40:44.258]                     invokeRestart <- base::invokeRestart
[17:40:44.258]                     is.null <- base::is.null
[17:40:44.258]                     muffled <- FALSE
[17:40:44.258]                     if (inherits(cond, "message")) {
[17:40:44.258]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.258]                       if (muffled) 
[17:40:44.258]                         invokeRestart("muffleMessage")
[17:40:44.258]                     }
[17:40:44.258]                     else if (inherits(cond, "warning")) {
[17:40:44.258]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.258]                       if (muffled) 
[17:40:44.258]                         invokeRestart("muffleWarning")
[17:40:44.258]                     }
[17:40:44.258]                     else if (inherits(cond, "condition")) {
[17:40:44.258]                       if (!is.null(pattern)) {
[17:40:44.258]                         computeRestarts <- base::computeRestarts
[17:40:44.258]                         grepl <- base::grepl
[17:40:44.258]                         restarts <- computeRestarts(cond)
[17:40:44.258]                         for (restart in restarts) {
[17:40:44.258]                           name <- restart$name
[17:40:44.258]                           if (is.null(name)) 
[17:40:44.258]                             next
[17:40:44.258]                           if (!grepl(pattern, name)) 
[17:40:44.258]                             next
[17:40:44.258]                           invokeRestart(restart)
[17:40:44.258]                           muffled <- TRUE
[17:40:44.258]                           break
[17:40:44.258]                         }
[17:40:44.258]                       }
[17:40:44.258]                     }
[17:40:44.258]                     invisible(muffled)
[17:40:44.258]                   }
[17:40:44.258]                   muffleCondition(cond)
[17:40:44.258]                 })
[17:40:44.258]             }))
[17:40:44.258]             future::FutureResult(value = ...future.value$value, 
[17:40:44.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.258]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.258]                     ...future.globalenv.names))
[17:40:44.258]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.258]         }, condition = base::local({
[17:40:44.258]             c <- base::c
[17:40:44.258]             inherits <- base::inherits
[17:40:44.258]             invokeRestart <- base::invokeRestart
[17:40:44.258]             length <- base::length
[17:40:44.258]             list <- base::list
[17:40:44.258]             seq.int <- base::seq.int
[17:40:44.258]             signalCondition <- base::signalCondition
[17:40:44.258]             sys.calls <- base::sys.calls
[17:40:44.258]             `[[` <- base::`[[`
[17:40:44.258]             `+` <- base::`+`
[17:40:44.258]             `<<-` <- base::`<<-`
[17:40:44.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.258]                   3L)]
[17:40:44.258]             }
[17:40:44.258]             function(cond) {
[17:40:44.258]                 is_error <- inherits(cond, "error")
[17:40:44.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.258]                   NULL)
[17:40:44.258]                 if (is_error) {
[17:40:44.258]                   sessionInformation <- function() {
[17:40:44.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.258]                       search = base::search(), system = base::Sys.info())
[17:40:44.258]                   }
[17:40:44.258]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.258]                     cond$call), session = sessionInformation(), 
[17:40:44.258]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.258]                   signalCondition(cond)
[17:40:44.258]                 }
[17:40:44.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.258]                 "immediateCondition"))) {
[17:40:44.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.258]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.258]                   if (TRUE && !signal) {
[17:40:44.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.258]                     {
[17:40:44.258]                       inherits <- base::inherits
[17:40:44.258]                       invokeRestart <- base::invokeRestart
[17:40:44.258]                       is.null <- base::is.null
[17:40:44.258]                       muffled <- FALSE
[17:40:44.258]                       if (inherits(cond, "message")) {
[17:40:44.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.258]                         if (muffled) 
[17:40:44.258]                           invokeRestart("muffleMessage")
[17:40:44.258]                       }
[17:40:44.258]                       else if (inherits(cond, "warning")) {
[17:40:44.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.258]                         if (muffled) 
[17:40:44.258]                           invokeRestart("muffleWarning")
[17:40:44.258]                       }
[17:40:44.258]                       else if (inherits(cond, "condition")) {
[17:40:44.258]                         if (!is.null(pattern)) {
[17:40:44.258]                           computeRestarts <- base::computeRestarts
[17:40:44.258]                           grepl <- base::grepl
[17:40:44.258]                           restarts <- computeRestarts(cond)
[17:40:44.258]                           for (restart in restarts) {
[17:40:44.258]                             name <- restart$name
[17:40:44.258]                             if (is.null(name)) 
[17:40:44.258]                               next
[17:40:44.258]                             if (!grepl(pattern, name)) 
[17:40:44.258]                               next
[17:40:44.258]                             invokeRestart(restart)
[17:40:44.258]                             muffled <- TRUE
[17:40:44.258]                             break
[17:40:44.258]                           }
[17:40:44.258]                         }
[17:40:44.258]                       }
[17:40:44.258]                       invisible(muffled)
[17:40:44.258]                     }
[17:40:44.258]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.258]                   }
[17:40:44.258]                 }
[17:40:44.258]                 else {
[17:40:44.258]                   if (TRUE) {
[17:40:44.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.258]                     {
[17:40:44.258]                       inherits <- base::inherits
[17:40:44.258]                       invokeRestart <- base::invokeRestart
[17:40:44.258]                       is.null <- base::is.null
[17:40:44.258]                       muffled <- FALSE
[17:40:44.258]                       if (inherits(cond, "message")) {
[17:40:44.258]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.258]                         if (muffled) 
[17:40:44.258]                           invokeRestart("muffleMessage")
[17:40:44.258]                       }
[17:40:44.258]                       else if (inherits(cond, "warning")) {
[17:40:44.258]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.258]                         if (muffled) 
[17:40:44.258]                           invokeRestart("muffleWarning")
[17:40:44.258]                       }
[17:40:44.258]                       else if (inherits(cond, "condition")) {
[17:40:44.258]                         if (!is.null(pattern)) {
[17:40:44.258]                           computeRestarts <- base::computeRestarts
[17:40:44.258]                           grepl <- base::grepl
[17:40:44.258]                           restarts <- computeRestarts(cond)
[17:40:44.258]                           for (restart in restarts) {
[17:40:44.258]                             name <- restart$name
[17:40:44.258]                             if (is.null(name)) 
[17:40:44.258]                               next
[17:40:44.258]                             if (!grepl(pattern, name)) 
[17:40:44.258]                               next
[17:40:44.258]                             invokeRestart(restart)
[17:40:44.258]                             muffled <- TRUE
[17:40:44.258]                             break
[17:40:44.258]                           }
[17:40:44.258]                         }
[17:40:44.258]                       }
[17:40:44.258]                       invisible(muffled)
[17:40:44.258]                     }
[17:40:44.258]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.258]                   }
[17:40:44.258]                 }
[17:40:44.258]             }
[17:40:44.258]         }))
[17:40:44.258]     }, error = function(ex) {
[17:40:44.258]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.258]                 ...future.rng), started = ...future.startTime, 
[17:40:44.258]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.258]             version = "1.8"), class = "FutureResult")
[17:40:44.258]     }, finally = {
[17:40:44.258]         if (!identical(...future.workdir, getwd())) 
[17:40:44.258]             setwd(...future.workdir)
[17:40:44.258]         {
[17:40:44.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.258]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.258]             }
[17:40:44.258]             base::options(...future.oldOptions)
[17:40:44.258]             if (.Platform$OS.type == "windows") {
[17:40:44.258]                 old_names <- names(...future.oldEnvVars)
[17:40:44.258]                 envs <- base::Sys.getenv()
[17:40:44.258]                 names <- names(envs)
[17:40:44.258]                 common <- intersect(names, old_names)
[17:40:44.258]                 added <- setdiff(names, old_names)
[17:40:44.258]                 removed <- setdiff(old_names, names)
[17:40:44.258]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.258]                   envs[common]]
[17:40:44.258]                 NAMES <- toupper(changed)
[17:40:44.258]                 args <- list()
[17:40:44.258]                 for (kk in seq_along(NAMES)) {
[17:40:44.258]                   name <- changed[[kk]]
[17:40:44.258]                   NAME <- NAMES[[kk]]
[17:40:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.258]                     next
[17:40:44.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.258]                 }
[17:40:44.258]                 NAMES <- toupper(added)
[17:40:44.258]                 for (kk in seq_along(NAMES)) {
[17:40:44.258]                   name <- added[[kk]]
[17:40:44.258]                   NAME <- NAMES[[kk]]
[17:40:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.258]                     next
[17:40:44.258]                   args[[name]] <- ""
[17:40:44.258]                 }
[17:40:44.258]                 NAMES <- toupper(removed)
[17:40:44.258]                 for (kk in seq_along(NAMES)) {
[17:40:44.258]                   name <- removed[[kk]]
[17:40:44.258]                   NAME <- NAMES[[kk]]
[17:40:44.258]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.258]                     next
[17:40:44.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.258]                 }
[17:40:44.258]                 if (length(args) > 0) 
[17:40:44.258]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.258]             }
[17:40:44.258]             else {
[17:40:44.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.258]             }
[17:40:44.258]             {
[17:40:44.258]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.258]                   0L) {
[17:40:44.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.258]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.258]                   base::options(opts)
[17:40:44.258]                 }
[17:40:44.258]                 {
[17:40:44.258]                   {
[17:40:44.258]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.258]                     NULL
[17:40:44.258]                   }
[17:40:44.258]                   options(future.plan = NULL)
[17:40:44.258]                   if (is.na(NA_character_)) 
[17:40:44.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.258]                     .init = FALSE)
[17:40:44.258]                 }
[17:40:44.258]             }
[17:40:44.258]         }
[17:40:44.258]     })
[17:40:44.258]     if (TRUE) {
[17:40:44.258]         base::sink(type = "output", split = FALSE)
[17:40:44.258]         if (TRUE) {
[17:40:44.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.258]         }
[17:40:44.258]         else {
[17:40:44.258]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.258]         }
[17:40:44.258]         base::close(...future.stdout)
[17:40:44.258]         ...future.stdout <- NULL
[17:40:44.258]     }
[17:40:44.258]     ...future.result$conditions <- ...future.conditions
[17:40:44.258]     ...future.result$finished <- base::Sys.time()
[17:40:44.258]     ...future.result
[17:40:44.258] }
[17:40:44.263] requestCore(): workers = 2
[17:40:44.264] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.275] result() for MulticoreFuture ...
[17:40:44.276] result() for MulticoreFuture ...
[17:40:44.277] result() for MulticoreFuture ... done
[17:40:44.277] result() for MulticoreFuture ... done
[17:40:44.277] result() for MulticoreFuture ...
[17:40:44.277] result() for MulticoreFuture ... done
[17:40:44.281] MulticoreFuture started
[17:40:44.282] - Launch lazy future ... done
[17:40:44.282] run() for ‘MulticoreFuture’ ... done
[17:40:44.282] plan(): Setting new future strategy stack:
[17:40:44.283] getGlobalsAndPackages() ...
[17:40:44.282] List of future strategies:
[17:40:44.282] 1. sequential:
[17:40:44.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.282]    - tweaked: FALSE
[17:40:44.282]    - call: NULL
[17:40:44.283] Searching for globals...
[17:40:44.284] plan(): nbrOfWorkers() = 1
[17:40:44.285] - globals found: [1] ‘{’
[17:40:44.285] Searching for globals ... DONE
[17:40:44.286] Resolving globals: FALSE
[17:40:44.286] 
[17:40:44.286] 
[17:40:44.286] getGlobalsAndPackages() ... DONE
[17:40:44.287] plan(): Setting new future strategy stack:
[17:40:44.287] List of future strategies:
[17:40:44.287] 1. multicore:
[17:40:44.287]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.287]    - tweaked: FALSE
[17:40:44.287]    - call: plan(strategy)
[17:40:44.292] run() for ‘Future’ ...
[17:40:44.293] - state: ‘created’
[17:40:44.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.301] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.301]   - Field: ‘label’
[17:40:44.301]   - Field: ‘local’
[17:40:44.301] plan(): nbrOfWorkers() = 2
[17:40:44.301]   - Field: ‘owner’
[17:40:44.302]   - Field: ‘envir’
[17:40:44.302]   - Field: ‘workers’
[17:40:44.302]   - Field: ‘packages’
[17:40:44.302]   - Field: ‘gc’
[17:40:44.302]   - Field: ‘job’
[17:40:44.303]   - Field: ‘conditions’
[17:40:44.303]   - Field: ‘expr’
[17:40:44.303]   - Field: ‘uuid’
[17:40:44.303]   - Field: ‘seed’
[17:40:44.303]   - Field: ‘version’
[17:40:44.303]   - Field: ‘result’
[17:40:44.304]   - Field: ‘asynchronous’
[17:40:44.304]   - Field: ‘calls’
[17:40:44.304]   - Field: ‘globals’
[17:40:44.304]   - Field: ‘stdout’
[17:40:44.304]   - Field: ‘earlySignal’
[17:40:44.304]   - Field: ‘lazy’
[17:40:44.305]   - Field: ‘state’
[17:40:44.305] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.305] - Launch lazy future ...
[17:40:44.305] Packages needed by the future expression (n = 0): <none>
[17:40:44.306] Packages needed by future strategies (n = 0): <none>
[17:40:44.306] {
[17:40:44.306]     {
[17:40:44.306]         {
[17:40:44.306]             ...future.startTime <- base::Sys.time()
[17:40:44.306]             {
[17:40:44.306]                 {
[17:40:44.306]                   {
[17:40:44.306]                     {
[17:40:44.306]                       base::local({
[17:40:44.306]                         has_future <- base::requireNamespace("future", 
[17:40:44.306]                           quietly = TRUE)
[17:40:44.306]                         if (has_future) {
[17:40:44.306]                           ns <- base::getNamespace("future")
[17:40:44.306]                           version <- ns[[".package"]][["version"]]
[17:40:44.306]                           if (is.null(version)) 
[17:40:44.306]                             version <- utils::packageVersion("future")
[17:40:44.306]                         }
[17:40:44.306]                         else {
[17:40:44.306]                           version <- NULL
[17:40:44.306]                         }
[17:40:44.306]                         if (!has_future || version < "1.8.0") {
[17:40:44.306]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.306]                             "", base::R.version$version.string), 
[17:40:44.306]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.306]                               "release", "version")], collapse = " "), 
[17:40:44.306]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.306]                             info)
[17:40:44.306]                           info <- base::paste(info, collapse = "; ")
[17:40:44.306]                           if (!has_future) {
[17:40:44.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.306]                               info)
[17:40:44.306]                           }
[17:40:44.306]                           else {
[17:40:44.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.306]                               info, version)
[17:40:44.306]                           }
[17:40:44.306]                           base::stop(msg)
[17:40:44.306]                         }
[17:40:44.306]                       })
[17:40:44.306]                     }
[17:40:44.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.306]                     base::options(mc.cores = 1L)
[17:40:44.306]                   }
[17:40:44.306]                   ...future.strategy.old <- future::plan("list")
[17:40:44.306]                   options(future.plan = NULL)
[17:40:44.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.306]                 }
[17:40:44.306]                 ...future.workdir <- getwd()
[17:40:44.306]             }
[17:40:44.306]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.306]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.306]         }
[17:40:44.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.306]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.306]             base::names(...future.oldOptions))
[17:40:44.306]     }
[17:40:44.306]     if (FALSE) {
[17:40:44.306]     }
[17:40:44.306]     else {
[17:40:44.306]         if (TRUE) {
[17:40:44.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.306]                 open = "w")
[17:40:44.306]         }
[17:40:44.306]         else {
[17:40:44.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.306]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.306]         }
[17:40:44.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.306]             base::sink(type = "output", split = FALSE)
[17:40:44.306]             base::close(...future.stdout)
[17:40:44.306]         }, add = TRUE)
[17:40:44.306]     }
[17:40:44.306]     ...future.frame <- base::sys.nframe()
[17:40:44.306]     ...future.conditions <- base::list()
[17:40:44.306]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.306]     if (FALSE) {
[17:40:44.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.306]     }
[17:40:44.306]     ...future.result <- base::tryCatch({
[17:40:44.306]         base::withCallingHandlers({
[17:40:44.306]             ...future.value <- base::withVisible(base::local({
[17:40:44.306]                 withCallingHandlers({
[17:40:44.306]                   {
[17:40:44.306]                     2
[17:40:44.306]                   }
[17:40:44.306]                 }, immediateCondition = function(cond) {
[17:40:44.306]                   save_rds <- function (object, pathname, ...) 
[17:40:44.306]                   {
[17:40:44.306]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.306]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.306]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.306]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.306]                         fi_tmp[["mtime"]])
[17:40:44.306]                     }
[17:40:44.306]                     tryCatch({
[17:40:44.306]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.306]                     }, error = function(ex) {
[17:40:44.306]                       msg <- conditionMessage(ex)
[17:40:44.306]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.306]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.306]                         fi_tmp[["mtime"]], msg)
[17:40:44.306]                       ex$message <- msg
[17:40:44.306]                       stop(ex)
[17:40:44.306]                     })
[17:40:44.306]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.306]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.306]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.306]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.306]                       fi <- file.info(pathname)
[17:40:44.306]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.306]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.306]                         fi[["size"]], fi[["mtime"]])
[17:40:44.306]                       stop(msg)
[17:40:44.306]                     }
[17:40:44.306]                     invisible(pathname)
[17:40:44.306]                   }
[17:40:44.306]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.306]                     rootPath = tempdir()) 
[17:40:44.306]                   {
[17:40:44.306]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.306]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.306]                       tmpdir = path, fileext = ".rds")
[17:40:44.306]                     save_rds(obj, file)
[17:40:44.306]                   }
[17:40:44.306]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.306]                   {
[17:40:44.306]                     inherits <- base::inherits
[17:40:44.306]                     invokeRestart <- base::invokeRestart
[17:40:44.306]                     is.null <- base::is.null
[17:40:44.306]                     muffled <- FALSE
[17:40:44.306]                     if (inherits(cond, "message")) {
[17:40:44.306]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.306]                       if (muffled) 
[17:40:44.306]                         invokeRestart("muffleMessage")
[17:40:44.306]                     }
[17:40:44.306]                     else if (inherits(cond, "warning")) {
[17:40:44.306]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.306]                       if (muffled) 
[17:40:44.306]                         invokeRestart("muffleWarning")
[17:40:44.306]                     }
[17:40:44.306]                     else if (inherits(cond, "condition")) {
[17:40:44.306]                       if (!is.null(pattern)) {
[17:40:44.306]                         computeRestarts <- base::computeRestarts
[17:40:44.306]                         grepl <- base::grepl
[17:40:44.306]                         restarts <- computeRestarts(cond)
[17:40:44.306]                         for (restart in restarts) {
[17:40:44.306]                           name <- restart$name
[17:40:44.306]                           if (is.null(name)) 
[17:40:44.306]                             next
[17:40:44.306]                           if (!grepl(pattern, name)) 
[17:40:44.306]                             next
[17:40:44.306]                           invokeRestart(restart)
[17:40:44.306]                           muffled <- TRUE
[17:40:44.306]                           break
[17:40:44.306]                         }
[17:40:44.306]                       }
[17:40:44.306]                     }
[17:40:44.306]                     invisible(muffled)
[17:40:44.306]                   }
[17:40:44.306]                   muffleCondition(cond)
[17:40:44.306]                 })
[17:40:44.306]             }))
[17:40:44.306]             future::FutureResult(value = ...future.value$value, 
[17:40:44.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.306]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.306]                     ...future.globalenv.names))
[17:40:44.306]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.306]         }, condition = base::local({
[17:40:44.306]             c <- base::c
[17:40:44.306]             inherits <- base::inherits
[17:40:44.306]             invokeRestart <- base::invokeRestart
[17:40:44.306]             length <- base::length
[17:40:44.306]             list <- base::list
[17:40:44.306]             seq.int <- base::seq.int
[17:40:44.306]             signalCondition <- base::signalCondition
[17:40:44.306]             sys.calls <- base::sys.calls
[17:40:44.306]             `[[` <- base::`[[`
[17:40:44.306]             `+` <- base::`+`
[17:40:44.306]             `<<-` <- base::`<<-`
[17:40:44.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.306]                   3L)]
[17:40:44.306]             }
[17:40:44.306]             function(cond) {
[17:40:44.306]                 is_error <- inherits(cond, "error")
[17:40:44.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.306]                   NULL)
[17:40:44.306]                 if (is_error) {
[17:40:44.306]                   sessionInformation <- function() {
[17:40:44.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.306]                       search = base::search(), system = base::Sys.info())
[17:40:44.306]                   }
[17:40:44.306]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.306]                     cond$call), session = sessionInformation(), 
[17:40:44.306]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.306]                   signalCondition(cond)
[17:40:44.306]                 }
[17:40:44.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.306]                 "immediateCondition"))) {
[17:40:44.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.306]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.306]                   if (TRUE && !signal) {
[17:40:44.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.306]                     {
[17:40:44.306]                       inherits <- base::inherits
[17:40:44.306]                       invokeRestart <- base::invokeRestart
[17:40:44.306]                       is.null <- base::is.null
[17:40:44.306]                       muffled <- FALSE
[17:40:44.306]                       if (inherits(cond, "message")) {
[17:40:44.306]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.306]                         if (muffled) 
[17:40:44.306]                           invokeRestart("muffleMessage")
[17:40:44.306]                       }
[17:40:44.306]                       else if (inherits(cond, "warning")) {
[17:40:44.306]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.306]                         if (muffled) 
[17:40:44.306]                           invokeRestart("muffleWarning")
[17:40:44.306]                       }
[17:40:44.306]                       else if (inherits(cond, "condition")) {
[17:40:44.306]                         if (!is.null(pattern)) {
[17:40:44.306]                           computeRestarts <- base::computeRestarts
[17:40:44.306]                           grepl <- base::grepl
[17:40:44.306]                           restarts <- computeRestarts(cond)
[17:40:44.306]                           for (restart in restarts) {
[17:40:44.306]                             name <- restart$name
[17:40:44.306]                             if (is.null(name)) 
[17:40:44.306]                               next
[17:40:44.306]                             if (!grepl(pattern, name)) 
[17:40:44.306]                               next
[17:40:44.306]                             invokeRestart(restart)
[17:40:44.306]                             muffled <- TRUE
[17:40:44.306]                             break
[17:40:44.306]                           }
[17:40:44.306]                         }
[17:40:44.306]                       }
[17:40:44.306]                       invisible(muffled)
[17:40:44.306]                     }
[17:40:44.306]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.306]                   }
[17:40:44.306]                 }
[17:40:44.306]                 else {
[17:40:44.306]                   if (TRUE) {
[17:40:44.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.306]                     {
[17:40:44.306]                       inherits <- base::inherits
[17:40:44.306]                       invokeRestart <- base::invokeRestart
[17:40:44.306]                       is.null <- base::is.null
[17:40:44.306]                       muffled <- FALSE
[17:40:44.306]                       if (inherits(cond, "message")) {
[17:40:44.306]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.306]                         if (muffled) 
[17:40:44.306]                           invokeRestart("muffleMessage")
[17:40:44.306]                       }
[17:40:44.306]                       else if (inherits(cond, "warning")) {
[17:40:44.306]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.306]                         if (muffled) 
[17:40:44.306]                           invokeRestart("muffleWarning")
[17:40:44.306]                       }
[17:40:44.306]                       else if (inherits(cond, "condition")) {
[17:40:44.306]                         if (!is.null(pattern)) {
[17:40:44.306]                           computeRestarts <- base::computeRestarts
[17:40:44.306]                           grepl <- base::grepl
[17:40:44.306]                           restarts <- computeRestarts(cond)
[17:40:44.306]                           for (restart in restarts) {
[17:40:44.306]                             name <- restart$name
[17:40:44.306]                             if (is.null(name)) 
[17:40:44.306]                               next
[17:40:44.306]                             if (!grepl(pattern, name)) 
[17:40:44.306]                               next
[17:40:44.306]                             invokeRestart(restart)
[17:40:44.306]                             muffled <- TRUE
[17:40:44.306]                             break
[17:40:44.306]                           }
[17:40:44.306]                         }
[17:40:44.306]                       }
[17:40:44.306]                       invisible(muffled)
[17:40:44.306]                     }
[17:40:44.306]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.306]                   }
[17:40:44.306]                 }
[17:40:44.306]             }
[17:40:44.306]         }))
[17:40:44.306]     }, error = function(ex) {
[17:40:44.306]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.306]                 ...future.rng), started = ...future.startTime, 
[17:40:44.306]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.306]             version = "1.8"), class = "FutureResult")
[17:40:44.306]     }, finally = {
[17:40:44.306]         if (!identical(...future.workdir, getwd())) 
[17:40:44.306]             setwd(...future.workdir)
[17:40:44.306]         {
[17:40:44.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.306]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.306]             }
[17:40:44.306]             base::options(...future.oldOptions)
[17:40:44.306]             if (.Platform$OS.type == "windows") {
[17:40:44.306]                 old_names <- names(...future.oldEnvVars)
[17:40:44.306]                 envs <- base::Sys.getenv()
[17:40:44.306]                 names <- names(envs)
[17:40:44.306]                 common <- intersect(names, old_names)
[17:40:44.306]                 added <- setdiff(names, old_names)
[17:40:44.306]                 removed <- setdiff(old_names, names)
[17:40:44.306]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.306]                   envs[common]]
[17:40:44.306]                 NAMES <- toupper(changed)
[17:40:44.306]                 args <- list()
[17:40:44.306]                 for (kk in seq_along(NAMES)) {
[17:40:44.306]                   name <- changed[[kk]]
[17:40:44.306]                   NAME <- NAMES[[kk]]
[17:40:44.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.306]                     next
[17:40:44.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.306]                 }
[17:40:44.306]                 NAMES <- toupper(added)
[17:40:44.306]                 for (kk in seq_along(NAMES)) {
[17:40:44.306]                   name <- added[[kk]]
[17:40:44.306]                   NAME <- NAMES[[kk]]
[17:40:44.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.306]                     next
[17:40:44.306]                   args[[name]] <- ""
[17:40:44.306]                 }
[17:40:44.306]                 NAMES <- toupper(removed)
[17:40:44.306]                 for (kk in seq_along(NAMES)) {
[17:40:44.306]                   name <- removed[[kk]]
[17:40:44.306]                   NAME <- NAMES[[kk]]
[17:40:44.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.306]                     next
[17:40:44.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.306]                 }
[17:40:44.306]                 if (length(args) > 0) 
[17:40:44.306]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.306]             }
[17:40:44.306]             else {
[17:40:44.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.306]             }
[17:40:44.306]             {
[17:40:44.306]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.306]                   0L) {
[17:40:44.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.306]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.306]                   base::options(opts)
[17:40:44.306]                 }
[17:40:44.306]                 {
[17:40:44.306]                   {
[17:40:44.306]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.306]                     NULL
[17:40:44.306]                   }
[17:40:44.306]                   options(future.plan = NULL)
[17:40:44.306]                   if (is.na(NA_character_)) 
[17:40:44.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.306]                     .init = FALSE)
[17:40:44.306]                 }
[17:40:44.306]             }
[17:40:44.306]         }
[17:40:44.306]     })
[17:40:44.306]     if (TRUE) {
[17:40:44.306]         base::sink(type = "output", split = FALSE)
[17:40:44.306]         if (TRUE) {
[17:40:44.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.306]         }
[17:40:44.306]         else {
[17:40:44.306]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.306]         }
[17:40:44.306]         base::close(...future.stdout)
[17:40:44.306]         ...future.stdout <- NULL
[17:40:44.306]     }
[17:40:44.306]     ...future.result$conditions <- ...future.conditions
[17:40:44.306]     ...future.result$finished <- base::Sys.time()
[17:40:44.306]     ...future.result
[17:40:44.306] }
[17:40:44.309] requestCore(): workers = 2
[17:40:44.309] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.320] result() for MulticoreFuture ...
[17:40:44.321] result() for MulticoreFuture ...
[17:40:44.321] result() for MulticoreFuture ... done
[17:40:44.321] result() for MulticoreFuture ... done
[17:40:44.321] result() for MulticoreFuture ...
[17:40:44.321] result() for MulticoreFuture ... done
[17:40:44.324] MulticoreFuture started
[17:40:44.324] - Launch lazy future ... done
[17:40:44.325] run() for ‘MulticoreFuture’ ... done
[17:40:44.325] plan(): Setting new future strategy stack:
[17:40:44.326] List of future strategies:
[17:40:44.326] 1. sequential:
[17:40:44.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.326]    - tweaked: FALSE
[17:40:44.326]    - call: NULL
[17:40:44.327] resolve() on environment ...
[17:40:44.327]  recursive: 0
[17:40:44.327] plan(): nbrOfWorkers() = 1
[17:40:44.328]  elements: [3] ‘a’
[17:40:44.329] Future #1
[17:40:44.329]  length: 2 (resolved future 1)
[17:40:44.330] plan(): Setting new future strategy stack:
[17:40:44.330] List of future strategies:
[17:40:44.330] 1. multicore:
[17:40:44.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.330]    - tweaked: FALSE
[17:40:44.330]    - call: plan(strategy)
[17:40:44.335] plan(): nbrOfWorkers() = 2
[17:40:44.335] Future #2
[17:40:44.336]  length: 1 (resolved future 2)
[17:40:44.336]  length: 0 (resolved future 3)
[17:40:44.336] resolve() on environment ... DONE
[17:40:44.337] resolve() on environment ...
[17:40:44.337]  recursive: 0
[17:40:44.338]  elements: [3] ‘b’
[17:40:44.338] Future #1
[17:40:44.338]  length: 2 (resolved future 1)
[17:40:44.339] Future #2
[17:40:44.339]  length: 1 (resolved future 2)
[17:40:44.339]  length: 0 (resolved future 3)
[17:40:44.339] resolve() on environment ... DONE
[17:40:44.340] resolve() on environment ...
[17:40:44.340]  recursive: 0
[17:40:44.341]  elements: [3] ‘c’
[17:40:44.341] Future #1
[17:40:44.341]  length: 2 (resolved future 1)
[17:40:44.341] Future #2
[17:40:44.342]  length: 1 (resolved future 2)
[17:40:44.342]  length: 0 (resolved future 3)
[17:40:44.342] resolve() on environment ... DONE
[17:40:44.343] resolve() on environment ...
[17:40:44.343]  recursive: 0
[17:40:44.343]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:40:44.344] Future #1
[17:40:44.344] result() for MulticoreFuture ...
[17:40:44.345] result() for MulticoreFuture ...
[17:40:44.345] result() for MulticoreFuture ... done
[17:40:44.345] result() for MulticoreFuture ... done
[17:40:44.345] result() for MulticoreFuture ...
[17:40:44.345] result() for MulticoreFuture ... done
[17:40:44.345]  length: 2 (resolved future 1)
[17:40:44.346] Future #2
[17:40:44.346] result() for MulticoreFuture ...
[17:40:44.347] result() for MulticoreFuture ...
[17:40:44.347] result() for MulticoreFuture ... done
[17:40:44.347] result() for MulticoreFuture ... done
[17:40:44.347] result() for MulticoreFuture ...
[17:40:44.347] result() for MulticoreFuture ... done
[17:40:44.348]  length: 1 (resolved future 2)
[17:40:44.348]  length: 0 (resolved future 3)
[17:40:44.348] resolve() on environment ... DONE
[17:40:44.349] resolve() on environment ...
[17:40:44.349]  recursive: 99
[17:40:44.350]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:40:44.350] Future #1
[17:40:44.350] result() for MulticoreFuture ...
[17:40:44.350] result() for MulticoreFuture ... done
[17:40:44.350] result() for MulticoreFuture ...
[17:40:44.350] result() for MulticoreFuture ... done
[17:40:44.350] A MulticoreFuture was resolved
[17:40:44.351]  length: 2 (resolved future 1)
[17:40:44.351] Future #2
[17:40:44.351] result() for MulticoreFuture ...
[17:40:44.351] result() for MulticoreFuture ... done
[17:40:44.351] result() for MulticoreFuture ...
[17:40:44.351] result() for MulticoreFuture ... done
[17:40:44.351] A MulticoreFuture was resolved
[17:40:44.351]  length: 1 (resolved future 2)
[17:40:44.352]  length: 0 (resolved future 3)
[17:40:44.352] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:40:44.353] resolve() on list environment ...
[17:40:44.353]  recursive: 0
[17:40:44.353]  length: 2
[17:40:44.353]  elements: ‘a’, ‘b’
[17:40:44.353]  length: 1 (resolved future 1)
[17:40:44.354]  length: 0 (resolved future 2)
[17:40:44.354] resolve() on list environment ... DONE
[17:40:44.354] getGlobalsAndPackages() ...
[17:40:44.354] Searching for globals...
[17:40:44.354] 
[17:40:44.355] Searching for globals ... DONE
[17:40:44.355] - globals: [0] <none>
[17:40:44.355] getGlobalsAndPackages() ... DONE
[17:40:44.355] run() for ‘Future’ ...
[17:40:44.355] - state: ‘created’
[17:40:44.355] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.360] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.360] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.360]   - Field: ‘label’
[17:40:44.360]   - Field: ‘local’
[17:40:44.360]   - Field: ‘owner’
[17:40:44.360]   - Field: ‘envir’
[17:40:44.363]   - Field: ‘workers’
[17:40:44.363]   - Field: ‘packages’
[17:40:44.363]   - Field: ‘gc’
[17:40:44.363]   - Field: ‘job’
[17:40:44.363]   - Field: ‘conditions’
[17:40:44.363]   - Field: ‘expr’
[17:40:44.364]   - Field: ‘uuid’
[17:40:44.364]   - Field: ‘seed’
[17:40:44.364]   - Field: ‘version’
[17:40:44.364]   - Field: ‘result’
[17:40:44.364]   - Field: ‘asynchronous’
[17:40:44.364]   - Field: ‘calls’
[17:40:44.365]   - Field: ‘globals’
[17:40:44.365]   - Field: ‘stdout’
[17:40:44.365]   - Field: ‘earlySignal’
[17:40:44.365]   - Field: ‘lazy’
[17:40:44.365]   - Field: ‘state’
[17:40:44.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.365] - Launch lazy future ...
[17:40:44.366] Packages needed by the future expression (n = 0): <none>
[17:40:44.366] Packages needed by future strategies (n = 0): <none>
[17:40:44.366] {
[17:40:44.366]     {
[17:40:44.366]         {
[17:40:44.366]             ...future.startTime <- base::Sys.time()
[17:40:44.366]             {
[17:40:44.366]                 {
[17:40:44.366]                   {
[17:40:44.366]                     {
[17:40:44.366]                       base::local({
[17:40:44.366]                         has_future <- base::requireNamespace("future", 
[17:40:44.366]                           quietly = TRUE)
[17:40:44.366]                         if (has_future) {
[17:40:44.366]                           ns <- base::getNamespace("future")
[17:40:44.366]                           version <- ns[[".package"]][["version"]]
[17:40:44.366]                           if (is.null(version)) 
[17:40:44.366]                             version <- utils::packageVersion("future")
[17:40:44.366]                         }
[17:40:44.366]                         else {
[17:40:44.366]                           version <- NULL
[17:40:44.366]                         }
[17:40:44.366]                         if (!has_future || version < "1.8.0") {
[17:40:44.366]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.366]                             "", base::R.version$version.string), 
[17:40:44.366]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.366]                               "release", "version")], collapse = " "), 
[17:40:44.366]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.366]                             info)
[17:40:44.366]                           info <- base::paste(info, collapse = "; ")
[17:40:44.366]                           if (!has_future) {
[17:40:44.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.366]                               info)
[17:40:44.366]                           }
[17:40:44.366]                           else {
[17:40:44.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.366]                               info, version)
[17:40:44.366]                           }
[17:40:44.366]                           base::stop(msg)
[17:40:44.366]                         }
[17:40:44.366]                       })
[17:40:44.366]                     }
[17:40:44.366]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.366]                     base::options(mc.cores = 1L)
[17:40:44.366]                   }
[17:40:44.366]                   ...future.strategy.old <- future::plan("list")
[17:40:44.366]                   options(future.plan = NULL)
[17:40:44.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.366]                 }
[17:40:44.366]                 ...future.workdir <- getwd()
[17:40:44.366]             }
[17:40:44.366]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.366]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.366]         }
[17:40:44.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.366]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.366]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.366]             base::names(...future.oldOptions))
[17:40:44.366]     }
[17:40:44.366]     if (FALSE) {
[17:40:44.366]     }
[17:40:44.366]     else {
[17:40:44.366]         if (TRUE) {
[17:40:44.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.366]                 open = "w")
[17:40:44.366]         }
[17:40:44.366]         else {
[17:40:44.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.366]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.366]         }
[17:40:44.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.366]             base::sink(type = "output", split = FALSE)
[17:40:44.366]             base::close(...future.stdout)
[17:40:44.366]         }, add = TRUE)
[17:40:44.366]     }
[17:40:44.366]     ...future.frame <- base::sys.nframe()
[17:40:44.366]     ...future.conditions <- base::list()
[17:40:44.366]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.366]     if (FALSE) {
[17:40:44.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.366]     }
[17:40:44.366]     ...future.result <- base::tryCatch({
[17:40:44.366]         base::withCallingHandlers({
[17:40:44.366]             ...future.value <- base::withVisible(base::local({
[17:40:44.366]                 withCallingHandlers({
[17:40:44.366]                   1
[17:40:44.366]                 }, immediateCondition = function(cond) {
[17:40:44.366]                   save_rds <- function (object, pathname, ...) 
[17:40:44.366]                   {
[17:40:44.366]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.366]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.366]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.366]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.366]                         fi_tmp[["mtime"]])
[17:40:44.366]                     }
[17:40:44.366]                     tryCatch({
[17:40:44.366]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.366]                     }, error = function(ex) {
[17:40:44.366]                       msg <- conditionMessage(ex)
[17:40:44.366]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.366]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.366]                         fi_tmp[["mtime"]], msg)
[17:40:44.366]                       ex$message <- msg
[17:40:44.366]                       stop(ex)
[17:40:44.366]                     })
[17:40:44.366]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.366]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.366]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.366]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.366]                       fi <- file.info(pathname)
[17:40:44.366]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.366]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.366]                         fi[["size"]], fi[["mtime"]])
[17:40:44.366]                       stop(msg)
[17:40:44.366]                     }
[17:40:44.366]                     invisible(pathname)
[17:40:44.366]                   }
[17:40:44.366]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.366]                     rootPath = tempdir()) 
[17:40:44.366]                   {
[17:40:44.366]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.366]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.366]                       tmpdir = path, fileext = ".rds")
[17:40:44.366]                     save_rds(obj, file)
[17:40:44.366]                   }
[17:40:44.366]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.366]                   {
[17:40:44.366]                     inherits <- base::inherits
[17:40:44.366]                     invokeRestart <- base::invokeRestart
[17:40:44.366]                     is.null <- base::is.null
[17:40:44.366]                     muffled <- FALSE
[17:40:44.366]                     if (inherits(cond, "message")) {
[17:40:44.366]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.366]                       if (muffled) 
[17:40:44.366]                         invokeRestart("muffleMessage")
[17:40:44.366]                     }
[17:40:44.366]                     else if (inherits(cond, "warning")) {
[17:40:44.366]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.366]                       if (muffled) 
[17:40:44.366]                         invokeRestart("muffleWarning")
[17:40:44.366]                     }
[17:40:44.366]                     else if (inherits(cond, "condition")) {
[17:40:44.366]                       if (!is.null(pattern)) {
[17:40:44.366]                         computeRestarts <- base::computeRestarts
[17:40:44.366]                         grepl <- base::grepl
[17:40:44.366]                         restarts <- computeRestarts(cond)
[17:40:44.366]                         for (restart in restarts) {
[17:40:44.366]                           name <- restart$name
[17:40:44.366]                           if (is.null(name)) 
[17:40:44.366]                             next
[17:40:44.366]                           if (!grepl(pattern, name)) 
[17:40:44.366]                             next
[17:40:44.366]                           invokeRestart(restart)
[17:40:44.366]                           muffled <- TRUE
[17:40:44.366]                           break
[17:40:44.366]                         }
[17:40:44.366]                       }
[17:40:44.366]                     }
[17:40:44.366]                     invisible(muffled)
[17:40:44.366]                   }
[17:40:44.366]                   muffleCondition(cond)
[17:40:44.366]                 })
[17:40:44.366]             }))
[17:40:44.366]             future::FutureResult(value = ...future.value$value, 
[17:40:44.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.366]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.366]                     ...future.globalenv.names))
[17:40:44.366]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.366]         }, condition = base::local({
[17:40:44.366]             c <- base::c
[17:40:44.366]             inherits <- base::inherits
[17:40:44.366]             invokeRestart <- base::invokeRestart
[17:40:44.366]             length <- base::length
[17:40:44.366]             list <- base::list
[17:40:44.366]             seq.int <- base::seq.int
[17:40:44.366]             signalCondition <- base::signalCondition
[17:40:44.366]             sys.calls <- base::sys.calls
[17:40:44.366]             `[[` <- base::`[[`
[17:40:44.366]             `+` <- base::`+`
[17:40:44.366]             `<<-` <- base::`<<-`
[17:40:44.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.366]                   3L)]
[17:40:44.366]             }
[17:40:44.366]             function(cond) {
[17:40:44.366]                 is_error <- inherits(cond, "error")
[17:40:44.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.366]                   NULL)
[17:40:44.366]                 if (is_error) {
[17:40:44.366]                   sessionInformation <- function() {
[17:40:44.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.366]                       search = base::search(), system = base::Sys.info())
[17:40:44.366]                   }
[17:40:44.366]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.366]                     cond$call), session = sessionInformation(), 
[17:40:44.366]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.366]                   signalCondition(cond)
[17:40:44.366]                 }
[17:40:44.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.366]                 "immediateCondition"))) {
[17:40:44.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.366]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.366]                   if (TRUE && !signal) {
[17:40:44.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.366]                     {
[17:40:44.366]                       inherits <- base::inherits
[17:40:44.366]                       invokeRestart <- base::invokeRestart
[17:40:44.366]                       is.null <- base::is.null
[17:40:44.366]                       muffled <- FALSE
[17:40:44.366]                       if (inherits(cond, "message")) {
[17:40:44.366]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.366]                         if (muffled) 
[17:40:44.366]                           invokeRestart("muffleMessage")
[17:40:44.366]                       }
[17:40:44.366]                       else if (inherits(cond, "warning")) {
[17:40:44.366]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.366]                         if (muffled) 
[17:40:44.366]                           invokeRestart("muffleWarning")
[17:40:44.366]                       }
[17:40:44.366]                       else if (inherits(cond, "condition")) {
[17:40:44.366]                         if (!is.null(pattern)) {
[17:40:44.366]                           computeRestarts <- base::computeRestarts
[17:40:44.366]                           grepl <- base::grepl
[17:40:44.366]                           restarts <- computeRestarts(cond)
[17:40:44.366]                           for (restart in restarts) {
[17:40:44.366]                             name <- restart$name
[17:40:44.366]                             if (is.null(name)) 
[17:40:44.366]                               next
[17:40:44.366]                             if (!grepl(pattern, name)) 
[17:40:44.366]                               next
[17:40:44.366]                             invokeRestart(restart)
[17:40:44.366]                             muffled <- TRUE
[17:40:44.366]                             break
[17:40:44.366]                           }
[17:40:44.366]                         }
[17:40:44.366]                       }
[17:40:44.366]                       invisible(muffled)
[17:40:44.366]                     }
[17:40:44.366]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.366]                   }
[17:40:44.366]                 }
[17:40:44.366]                 else {
[17:40:44.366]                   if (TRUE) {
[17:40:44.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.366]                     {
[17:40:44.366]                       inherits <- base::inherits
[17:40:44.366]                       invokeRestart <- base::invokeRestart
[17:40:44.366]                       is.null <- base::is.null
[17:40:44.366]                       muffled <- FALSE
[17:40:44.366]                       if (inherits(cond, "message")) {
[17:40:44.366]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.366]                         if (muffled) 
[17:40:44.366]                           invokeRestart("muffleMessage")
[17:40:44.366]                       }
[17:40:44.366]                       else if (inherits(cond, "warning")) {
[17:40:44.366]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.366]                         if (muffled) 
[17:40:44.366]                           invokeRestart("muffleWarning")
[17:40:44.366]                       }
[17:40:44.366]                       else if (inherits(cond, "condition")) {
[17:40:44.366]                         if (!is.null(pattern)) {
[17:40:44.366]                           computeRestarts <- base::computeRestarts
[17:40:44.366]                           grepl <- base::grepl
[17:40:44.366]                           restarts <- computeRestarts(cond)
[17:40:44.366]                           for (restart in restarts) {
[17:40:44.366]                             name <- restart$name
[17:40:44.366]                             if (is.null(name)) 
[17:40:44.366]                               next
[17:40:44.366]                             if (!grepl(pattern, name)) 
[17:40:44.366]                               next
[17:40:44.366]                             invokeRestart(restart)
[17:40:44.366]                             muffled <- TRUE
[17:40:44.366]                             break
[17:40:44.366]                           }
[17:40:44.366]                         }
[17:40:44.366]                       }
[17:40:44.366]                       invisible(muffled)
[17:40:44.366]                     }
[17:40:44.366]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.366]                   }
[17:40:44.366]                 }
[17:40:44.366]             }
[17:40:44.366]         }))
[17:40:44.366]     }, error = function(ex) {
[17:40:44.366]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.366]                 ...future.rng), started = ...future.startTime, 
[17:40:44.366]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.366]             version = "1.8"), class = "FutureResult")
[17:40:44.366]     }, finally = {
[17:40:44.366]         if (!identical(...future.workdir, getwd())) 
[17:40:44.366]             setwd(...future.workdir)
[17:40:44.366]         {
[17:40:44.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.366]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.366]             }
[17:40:44.366]             base::options(...future.oldOptions)
[17:40:44.366]             if (.Platform$OS.type == "windows") {
[17:40:44.366]                 old_names <- names(...future.oldEnvVars)
[17:40:44.366]                 envs <- base::Sys.getenv()
[17:40:44.366]                 names <- names(envs)
[17:40:44.366]                 common <- intersect(names, old_names)
[17:40:44.366]                 added <- setdiff(names, old_names)
[17:40:44.366]                 removed <- setdiff(old_names, names)
[17:40:44.366]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.366]                   envs[common]]
[17:40:44.366]                 NAMES <- toupper(changed)
[17:40:44.366]                 args <- list()
[17:40:44.366]                 for (kk in seq_along(NAMES)) {
[17:40:44.366]                   name <- changed[[kk]]
[17:40:44.366]                   NAME <- NAMES[[kk]]
[17:40:44.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.366]                     next
[17:40:44.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.366]                 }
[17:40:44.366]                 NAMES <- toupper(added)
[17:40:44.366]                 for (kk in seq_along(NAMES)) {
[17:40:44.366]                   name <- added[[kk]]
[17:40:44.366]                   NAME <- NAMES[[kk]]
[17:40:44.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.366]                     next
[17:40:44.366]                   args[[name]] <- ""
[17:40:44.366]                 }
[17:40:44.366]                 NAMES <- toupper(removed)
[17:40:44.366]                 for (kk in seq_along(NAMES)) {
[17:40:44.366]                   name <- removed[[kk]]
[17:40:44.366]                   NAME <- NAMES[[kk]]
[17:40:44.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.366]                     next
[17:40:44.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.366]                 }
[17:40:44.366]                 if (length(args) > 0) 
[17:40:44.366]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.366]             }
[17:40:44.366]             else {
[17:40:44.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.366]             }
[17:40:44.366]             {
[17:40:44.366]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.366]                   0L) {
[17:40:44.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.366]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.366]                   base::options(opts)
[17:40:44.366]                 }
[17:40:44.366]                 {
[17:40:44.366]                   {
[17:40:44.366]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.366]                     NULL
[17:40:44.366]                   }
[17:40:44.366]                   options(future.plan = NULL)
[17:40:44.366]                   if (is.na(NA_character_)) 
[17:40:44.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.366]                     .init = FALSE)
[17:40:44.366]                 }
[17:40:44.366]             }
[17:40:44.366]         }
[17:40:44.366]     })
[17:40:44.366]     if (TRUE) {
[17:40:44.366]         base::sink(type = "output", split = FALSE)
[17:40:44.366]         if (TRUE) {
[17:40:44.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.366]         }
[17:40:44.366]         else {
[17:40:44.366]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.366]         }
[17:40:44.366]         base::close(...future.stdout)
[17:40:44.366]         ...future.stdout <- NULL
[17:40:44.366]     }
[17:40:44.366]     ...future.result$conditions <- ...future.conditions
[17:40:44.366]     ...future.result$finished <- base::Sys.time()
[17:40:44.366]     ...future.result
[17:40:44.366] }
[17:40:44.369] requestCore(): workers = 2
[17:40:44.371] MulticoreFuture started
[17:40:44.371] - Launch lazy future ... done
[17:40:44.372] run() for ‘MulticoreFuture’ ... done
[17:40:44.372] plan(): Setting new future strategy stack:
[17:40:44.372] getGlobalsAndPackages() ...
[17:40:44.372] Searching for globals...
[17:40:44.372] List of future strategies:
[17:40:44.372] 1. sequential:
[17:40:44.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.372]    - tweaked: FALSE
[17:40:44.372]    - call: NULL
[17:40:44.373] 
[17:40:44.373] plan(): nbrOfWorkers() = 1
[17:40:44.374] Searching for globals ... DONE
[17:40:44.374] - globals: [0] <none>
[17:40:44.374] getGlobalsAndPackages() ... DONE
[17:40:44.374] run() for ‘Future’ ...
[17:40:44.375] - state: ‘created’
[17:40:44.375] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.375] plan(): Setting new future strategy stack:
[17:40:44.375] List of future strategies:
[17:40:44.375] 1. multicore:
[17:40:44.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.375]    - tweaked: FALSE
[17:40:44.375]    - call: plan(strategy)
[17:40:44.380] plan(): nbrOfWorkers() = 2
[17:40:44.380] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.380] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.380]   - Field: ‘label’
[17:40:44.381]   - Field: ‘local’
[17:40:44.381]   - Field: ‘owner’
[17:40:44.381]   - Field: ‘envir’
[17:40:44.381]   - Field: ‘workers’
[17:40:44.381]   - Field: ‘packages’
[17:40:44.381]   - Field: ‘gc’
[17:40:44.382]   - Field: ‘job’
[17:40:44.382]   - Field: ‘conditions’
[17:40:44.382]   - Field: ‘expr’
[17:40:44.382]   - Field: ‘uuid’
[17:40:44.382]   - Field: ‘seed’
[17:40:44.382]   - Field: ‘version’
[17:40:44.382]   - Field: ‘result’
[17:40:44.383]   - Field: ‘asynchronous’
[17:40:44.383]   - Field: ‘calls’
[17:40:44.383]   - Field: ‘globals’
[17:40:44.383]   - Field: ‘stdout’
[17:40:44.383]   - Field: ‘earlySignal’
[17:40:44.383]   - Field: ‘lazy’
[17:40:44.383]   - Field: ‘state’
[17:40:44.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.384] - Launch lazy future ...
[17:40:44.384] Packages needed by the future expression (n = 0): <none>
[17:40:44.384] Packages needed by future strategies (n = 0): <none>
[17:40:44.385] {
[17:40:44.385]     {
[17:40:44.385]         {
[17:40:44.385]             ...future.startTime <- base::Sys.time()
[17:40:44.385]             {
[17:40:44.385]                 {
[17:40:44.385]                   {
[17:40:44.385]                     {
[17:40:44.385]                       base::local({
[17:40:44.385]                         has_future <- base::requireNamespace("future", 
[17:40:44.385]                           quietly = TRUE)
[17:40:44.385]                         if (has_future) {
[17:40:44.385]                           ns <- base::getNamespace("future")
[17:40:44.385]                           version <- ns[[".package"]][["version"]]
[17:40:44.385]                           if (is.null(version)) 
[17:40:44.385]                             version <- utils::packageVersion("future")
[17:40:44.385]                         }
[17:40:44.385]                         else {
[17:40:44.385]                           version <- NULL
[17:40:44.385]                         }
[17:40:44.385]                         if (!has_future || version < "1.8.0") {
[17:40:44.385]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.385]                             "", base::R.version$version.string), 
[17:40:44.385]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.385]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.385]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.385]                               "release", "version")], collapse = " "), 
[17:40:44.385]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.385]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.385]                             info)
[17:40:44.385]                           info <- base::paste(info, collapse = "; ")
[17:40:44.385]                           if (!has_future) {
[17:40:44.385]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.385]                               info)
[17:40:44.385]                           }
[17:40:44.385]                           else {
[17:40:44.385]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.385]                               info, version)
[17:40:44.385]                           }
[17:40:44.385]                           base::stop(msg)
[17:40:44.385]                         }
[17:40:44.385]                       })
[17:40:44.385]                     }
[17:40:44.385]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.385]                     base::options(mc.cores = 1L)
[17:40:44.385]                   }
[17:40:44.385]                   ...future.strategy.old <- future::plan("list")
[17:40:44.385]                   options(future.plan = NULL)
[17:40:44.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.385]                 }
[17:40:44.385]                 ...future.workdir <- getwd()
[17:40:44.385]             }
[17:40:44.385]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.385]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.385]         }
[17:40:44.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.385]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.385]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.385]             base::names(...future.oldOptions))
[17:40:44.385]     }
[17:40:44.385]     if (FALSE) {
[17:40:44.385]     }
[17:40:44.385]     else {
[17:40:44.385]         if (TRUE) {
[17:40:44.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.385]                 open = "w")
[17:40:44.385]         }
[17:40:44.385]         else {
[17:40:44.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.385]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.385]         }
[17:40:44.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.385]             base::sink(type = "output", split = FALSE)
[17:40:44.385]             base::close(...future.stdout)
[17:40:44.385]         }, add = TRUE)
[17:40:44.385]     }
[17:40:44.385]     ...future.frame <- base::sys.nframe()
[17:40:44.385]     ...future.conditions <- base::list()
[17:40:44.385]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.385]     if (FALSE) {
[17:40:44.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.385]     }
[17:40:44.385]     ...future.result <- base::tryCatch({
[17:40:44.385]         base::withCallingHandlers({
[17:40:44.385]             ...future.value <- base::withVisible(base::local({
[17:40:44.385]                 withCallingHandlers({
[17:40:44.385]                   2
[17:40:44.385]                 }, immediateCondition = function(cond) {
[17:40:44.385]                   save_rds <- function (object, pathname, ...) 
[17:40:44.385]                   {
[17:40:44.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.385]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.385]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.385]                         fi_tmp[["mtime"]])
[17:40:44.385]                     }
[17:40:44.385]                     tryCatch({
[17:40:44.385]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.385]                     }, error = function(ex) {
[17:40:44.385]                       msg <- conditionMessage(ex)
[17:40:44.385]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.385]                         fi_tmp[["mtime"]], msg)
[17:40:44.385]                       ex$message <- msg
[17:40:44.385]                       stop(ex)
[17:40:44.385]                     })
[17:40:44.385]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.385]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.385]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.385]                       fi <- file.info(pathname)
[17:40:44.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.385]                         fi[["size"]], fi[["mtime"]])
[17:40:44.385]                       stop(msg)
[17:40:44.385]                     }
[17:40:44.385]                     invisible(pathname)
[17:40:44.385]                   }
[17:40:44.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.385]                     rootPath = tempdir()) 
[17:40:44.385]                   {
[17:40:44.385]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.385]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.385]                       tmpdir = path, fileext = ".rds")
[17:40:44.385]                     save_rds(obj, file)
[17:40:44.385]                   }
[17:40:44.385]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.385]                   {
[17:40:44.385]                     inherits <- base::inherits
[17:40:44.385]                     invokeRestart <- base::invokeRestart
[17:40:44.385]                     is.null <- base::is.null
[17:40:44.385]                     muffled <- FALSE
[17:40:44.385]                     if (inherits(cond, "message")) {
[17:40:44.385]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.385]                       if (muffled) 
[17:40:44.385]                         invokeRestart("muffleMessage")
[17:40:44.385]                     }
[17:40:44.385]                     else if (inherits(cond, "warning")) {
[17:40:44.385]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.385]                       if (muffled) 
[17:40:44.385]                         invokeRestart("muffleWarning")
[17:40:44.385]                     }
[17:40:44.385]                     else if (inherits(cond, "condition")) {
[17:40:44.385]                       if (!is.null(pattern)) {
[17:40:44.385]                         computeRestarts <- base::computeRestarts
[17:40:44.385]                         grepl <- base::grepl
[17:40:44.385]                         restarts <- computeRestarts(cond)
[17:40:44.385]                         for (restart in restarts) {
[17:40:44.385]                           name <- restart$name
[17:40:44.385]                           if (is.null(name)) 
[17:40:44.385]                             next
[17:40:44.385]                           if (!grepl(pattern, name)) 
[17:40:44.385]                             next
[17:40:44.385]                           invokeRestart(restart)
[17:40:44.385]                           muffled <- TRUE
[17:40:44.385]                           break
[17:40:44.385]                         }
[17:40:44.385]                       }
[17:40:44.385]                     }
[17:40:44.385]                     invisible(muffled)
[17:40:44.385]                   }
[17:40:44.385]                   muffleCondition(cond)
[17:40:44.385]                 })
[17:40:44.385]             }))
[17:40:44.385]             future::FutureResult(value = ...future.value$value, 
[17:40:44.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.385]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.385]                     ...future.globalenv.names))
[17:40:44.385]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.385]         }, condition = base::local({
[17:40:44.385]             c <- base::c
[17:40:44.385]             inherits <- base::inherits
[17:40:44.385]             invokeRestart <- base::invokeRestart
[17:40:44.385]             length <- base::length
[17:40:44.385]             list <- base::list
[17:40:44.385]             seq.int <- base::seq.int
[17:40:44.385]             signalCondition <- base::signalCondition
[17:40:44.385]             sys.calls <- base::sys.calls
[17:40:44.385]             `[[` <- base::`[[`
[17:40:44.385]             `+` <- base::`+`
[17:40:44.385]             `<<-` <- base::`<<-`
[17:40:44.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.385]                   3L)]
[17:40:44.385]             }
[17:40:44.385]             function(cond) {
[17:40:44.385]                 is_error <- inherits(cond, "error")
[17:40:44.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.385]                   NULL)
[17:40:44.385]                 if (is_error) {
[17:40:44.385]                   sessionInformation <- function() {
[17:40:44.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.385]                       search = base::search(), system = base::Sys.info())
[17:40:44.385]                   }
[17:40:44.385]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.385]                     cond$call), session = sessionInformation(), 
[17:40:44.385]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.385]                   signalCondition(cond)
[17:40:44.385]                 }
[17:40:44.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.385]                 "immediateCondition"))) {
[17:40:44.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.385]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.385]                   if (TRUE && !signal) {
[17:40:44.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.385]                     {
[17:40:44.385]                       inherits <- base::inherits
[17:40:44.385]                       invokeRestart <- base::invokeRestart
[17:40:44.385]                       is.null <- base::is.null
[17:40:44.385]                       muffled <- FALSE
[17:40:44.385]                       if (inherits(cond, "message")) {
[17:40:44.385]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.385]                         if (muffled) 
[17:40:44.385]                           invokeRestart("muffleMessage")
[17:40:44.385]                       }
[17:40:44.385]                       else if (inherits(cond, "warning")) {
[17:40:44.385]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.385]                         if (muffled) 
[17:40:44.385]                           invokeRestart("muffleWarning")
[17:40:44.385]                       }
[17:40:44.385]                       else if (inherits(cond, "condition")) {
[17:40:44.385]                         if (!is.null(pattern)) {
[17:40:44.385]                           computeRestarts <- base::computeRestarts
[17:40:44.385]                           grepl <- base::grepl
[17:40:44.385]                           restarts <- computeRestarts(cond)
[17:40:44.385]                           for (restart in restarts) {
[17:40:44.385]                             name <- restart$name
[17:40:44.385]                             if (is.null(name)) 
[17:40:44.385]                               next
[17:40:44.385]                             if (!grepl(pattern, name)) 
[17:40:44.385]                               next
[17:40:44.385]                             invokeRestart(restart)
[17:40:44.385]                             muffled <- TRUE
[17:40:44.385]                             break
[17:40:44.385]                           }
[17:40:44.385]                         }
[17:40:44.385]                       }
[17:40:44.385]                       invisible(muffled)
[17:40:44.385]                     }
[17:40:44.385]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.385]                   }
[17:40:44.385]                 }
[17:40:44.385]                 else {
[17:40:44.385]                   if (TRUE) {
[17:40:44.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.385]                     {
[17:40:44.385]                       inherits <- base::inherits
[17:40:44.385]                       invokeRestart <- base::invokeRestart
[17:40:44.385]                       is.null <- base::is.null
[17:40:44.385]                       muffled <- FALSE
[17:40:44.385]                       if (inherits(cond, "message")) {
[17:40:44.385]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.385]                         if (muffled) 
[17:40:44.385]                           invokeRestart("muffleMessage")
[17:40:44.385]                       }
[17:40:44.385]                       else if (inherits(cond, "warning")) {
[17:40:44.385]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.385]                         if (muffled) 
[17:40:44.385]                           invokeRestart("muffleWarning")
[17:40:44.385]                       }
[17:40:44.385]                       else if (inherits(cond, "condition")) {
[17:40:44.385]                         if (!is.null(pattern)) {
[17:40:44.385]                           computeRestarts <- base::computeRestarts
[17:40:44.385]                           grepl <- base::grepl
[17:40:44.385]                           restarts <- computeRestarts(cond)
[17:40:44.385]                           for (restart in restarts) {
[17:40:44.385]                             name <- restart$name
[17:40:44.385]                             if (is.null(name)) 
[17:40:44.385]                               next
[17:40:44.385]                             if (!grepl(pattern, name)) 
[17:40:44.385]                               next
[17:40:44.385]                             invokeRestart(restart)
[17:40:44.385]                             muffled <- TRUE
[17:40:44.385]                             break
[17:40:44.385]                           }
[17:40:44.385]                         }
[17:40:44.385]                       }
[17:40:44.385]                       invisible(muffled)
[17:40:44.385]                     }
[17:40:44.385]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.385]                   }
[17:40:44.385]                 }
[17:40:44.385]             }
[17:40:44.385]         }))
[17:40:44.385]     }, error = function(ex) {
[17:40:44.385]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.385]                 ...future.rng), started = ...future.startTime, 
[17:40:44.385]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.385]             version = "1.8"), class = "FutureResult")
[17:40:44.385]     }, finally = {
[17:40:44.385]         if (!identical(...future.workdir, getwd())) 
[17:40:44.385]             setwd(...future.workdir)
[17:40:44.385]         {
[17:40:44.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.385]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.385]             }
[17:40:44.385]             base::options(...future.oldOptions)
[17:40:44.385]             if (.Platform$OS.type == "windows") {
[17:40:44.385]                 old_names <- names(...future.oldEnvVars)
[17:40:44.385]                 envs <- base::Sys.getenv()
[17:40:44.385]                 names <- names(envs)
[17:40:44.385]                 common <- intersect(names, old_names)
[17:40:44.385]                 added <- setdiff(names, old_names)
[17:40:44.385]                 removed <- setdiff(old_names, names)
[17:40:44.385]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.385]                   envs[common]]
[17:40:44.385]                 NAMES <- toupper(changed)
[17:40:44.385]                 args <- list()
[17:40:44.385]                 for (kk in seq_along(NAMES)) {
[17:40:44.385]                   name <- changed[[kk]]
[17:40:44.385]                   NAME <- NAMES[[kk]]
[17:40:44.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.385]                     next
[17:40:44.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.385]                 }
[17:40:44.385]                 NAMES <- toupper(added)
[17:40:44.385]                 for (kk in seq_along(NAMES)) {
[17:40:44.385]                   name <- added[[kk]]
[17:40:44.385]                   NAME <- NAMES[[kk]]
[17:40:44.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.385]                     next
[17:40:44.385]                   args[[name]] <- ""
[17:40:44.385]                 }
[17:40:44.385]                 NAMES <- toupper(removed)
[17:40:44.385]                 for (kk in seq_along(NAMES)) {
[17:40:44.385]                   name <- removed[[kk]]
[17:40:44.385]                   NAME <- NAMES[[kk]]
[17:40:44.385]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.385]                     next
[17:40:44.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.385]                 }
[17:40:44.385]                 if (length(args) > 0) 
[17:40:44.385]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.385]             }
[17:40:44.385]             else {
[17:40:44.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.385]             }
[17:40:44.385]             {
[17:40:44.385]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.385]                   0L) {
[17:40:44.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.385]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.385]                   base::options(opts)
[17:40:44.385]                 }
[17:40:44.385]                 {
[17:40:44.385]                   {
[17:40:44.385]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.385]                     NULL
[17:40:44.385]                   }
[17:40:44.385]                   options(future.plan = NULL)
[17:40:44.385]                   if (is.na(NA_character_)) 
[17:40:44.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.385]                     .init = FALSE)
[17:40:44.385]                 }
[17:40:44.385]             }
[17:40:44.385]         }
[17:40:44.385]     })
[17:40:44.385]     if (TRUE) {
[17:40:44.385]         base::sink(type = "output", split = FALSE)
[17:40:44.385]         if (TRUE) {
[17:40:44.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.385]         }
[17:40:44.385]         else {
[17:40:44.385]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.385]         }
[17:40:44.385]         base::close(...future.stdout)
[17:40:44.385]         ...future.stdout <- NULL
[17:40:44.385]     }
[17:40:44.385]     ...future.result$conditions <- ...future.conditions
[17:40:44.385]     ...future.result$finished <- base::Sys.time()
[17:40:44.385]     ...future.result
[17:40:44.385] }
[17:40:44.389] requestCore(): workers = 2
[17:40:44.391] MulticoreFuture started
[17:40:44.391] - Launch lazy future ... done
[17:40:44.391] run() for ‘MulticoreFuture’ ... done
[17:40:44.392] plan(): Setting new future strategy stack:
[17:40:44.393] resolve() on list environment ...
[17:40:44.393]  recursive: 0
[17:40:44.392] List of future strategies:
[17:40:44.392] 1. sequential:
[17:40:44.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.392]    - tweaked: FALSE
[17:40:44.392]    - call: NULL
[17:40:44.393] plan(): nbrOfWorkers() = 1
[17:40:44.394]  length: 3
[17:40:44.394]  elements: ‘a’, ‘b’, ‘c’
[17:40:44.394] Future #1
[17:40:44.395]  length: 2 (resolved future 1)
[17:40:44.395] plan(): Setting new future strategy stack:
[17:40:44.395] List of future strategies:
[17:40:44.395] 1. multicore:
[17:40:44.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.395]    - tweaked: FALSE
[17:40:44.395]    - call: plan(strategy)
[17:40:44.400] plan(): nbrOfWorkers() = 2
[17:40:44.401] Future #2
[17:40:44.401]  length: 1 (resolved future 2)
[17:40:44.401]  length: 0 (resolved future 3)
[17:40:44.401] resolve() on list environment ... DONE
[17:40:44.402] getGlobalsAndPackages() ...
[17:40:44.402] Searching for globals...
[17:40:44.404] - globals found: [1] ‘{’
[17:40:44.404] Searching for globals ... DONE
[17:40:44.404] Resolving globals: FALSE
[17:40:44.404] 
[17:40:44.405] 
[17:40:44.405] getGlobalsAndPackages() ... DONE
[17:40:44.405] run() for ‘Future’ ...
[17:40:44.405] - state: ‘created’
[17:40:44.406] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.410] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.411]   - Field: ‘label’
[17:40:44.411]   - Field: ‘local’
[17:40:44.411]   - Field: ‘owner’
[17:40:44.411]   - Field: ‘envir’
[17:40:44.411]   - Field: ‘workers’
[17:40:44.411]   - Field: ‘packages’
[17:40:44.411]   - Field: ‘gc’
[17:40:44.412]   - Field: ‘job’
[17:40:44.412]   - Field: ‘conditions’
[17:40:44.412]   - Field: ‘expr’
[17:40:44.412]   - Field: ‘uuid’
[17:40:44.412]   - Field: ‘seed’
[17:40:44.412]   - Field: ‘version’
[17:40:44.412]   - Field: ‘result’
[17:40:44.413]   - Field: ‘asynchronous’
[17:40:44.413]   - Field: ‘calls’
[17:40:44.413]   - Field: ‘globals’
[17:40:44.413]   - Field: ‘stdout’
[17:40:44.413]   - Field: ‘earlySignal’
[17:40:44.413]   - Field: ‘lazy’
[17:40:44.413]   - Field: ‘state’
[17:40:44.414] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.414] - Launch lazy future ...
[17:40:44.414] Packages needed by the future expression (n = 0): <none>
[17:40:44.414] Packages needed by future strategies (n = 0): <none>
[17:40:44.415] {
[17:40:44.415]     {
[17:40:44.415]         {
[17:40:44.415]             ...future.startTime <- base::Sys.time()
[17:40:44.415]             {
[17:40:44.415]                 {
[17:40:44.415]                   {
[17:40:44.415]                     {
[17:40:44.415]                       base::local({
[17:40:44.415]                         has_future <- base::requireNamespace("future", 
[17:40:44.415]                           quietly = TRUE)
[17:40:44.415]                         if (has_future) {
[17:40:44.415]                           ns <- base::getNamespace("future")
[17:40:44.415]                           version <- ns[[".package"]][["version"]]
[17:40:44.415]                           if (is.null(version)) 
[17:40:44.415]                             version <- utils::packageVersion("future")
[17:40:44.415]                         }
[17:40:44.415]                         else {
[17:40:44.415]                           version <- NULL
[17:40:44.415]                         }
[17:40:44.415]                         if (!has_future || version < "1.8.0") {
[17:40:44.415]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.415]                             "", base::R.version$version.string), 
[17:40:44.415]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.415]                               "release", "version")], collapse = " "), 
[17:40:44.415]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.415]                             info)
[17:40:44.415]                           info <- base::paste(info, collapse = "; ")
[17:40:44.415]                           if (!has_future) {
[17:40:44.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.415]                               info)
[17:40:44.415]                           }
[17:40:44.415]                           else {
[17:40:44.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.415]                               info, version)
[17:40:44.415]                           }
[17:40:44.415]                           base::stop(msg)
[17:40:44.415]                         }
[17:40:44.415]                       })
[17:40:44.415]                     }
[17:40:44.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.415]                     base::options(mc.cores = 1L)
[17:40:44.415]                   }
[17:40:44.415]                   ...future.strategy.old <- future::plan("list")
[17:40:44.415]                   options(future.plan = NULL)
[17:40:44.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.415]                 }
[17:40:44.415]                 ...future.workdir <- getwd()
[17:40:44.415]             }
[17:40:44.415]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.415]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.415]         }
[17:40:44.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.415]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.415]             base::names(...future.oldOptions))
[17:40:44.415]     }
[17:40:44.415]     if (FALSE) {
[17:40:44.415]     }
[17:40:44.415]     else {
[17:40:44.415]         if (TRUE) {
[17:40:44.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.415]                 open = "w")
[17:40:44.415]         }
[17:40:44.415]         else {
[17:40:44.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.415]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.415]         }
[17:40:44.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.415]             base::sink(type = "output", split = FALSE)
[17:40:44.415]             base::close(...future.stdout)
[17:40:44.415]         }, add = TRUE)
[17:40:44.415]     }
[17:40:44.415]     ...future.frame <- base::sys.nframe()
[17:40:44.415]     ...future.conditions <- base::list()
[17:40:44.415]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.415]     if (FALSE) {
[17:40:44.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.415]     }
[17:40:44.415]     ...future.result <- base::tryCatch({
[17:40:44.415]         base::withCallingHandlers({
[17:40:44.415]             ...future.value <- base::withVisible(base::local({
[17:40:44.415]                 withCallingHandlers({
[17:40:44.415]                   {
[17:40:44.415]                     1
[17:40:44.415]                   }
[17:40:44.415]                 }, immediateCondition = function(cond) {
[17:40:44.415]                   save_rds <- function (object, pathname, ...) 
[17:40:44.415]                   {
[17:40:44.415]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.415]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.415]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.415]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.415]                         fi_tmp[["mtime"]])
[17:40:44.415]                     }
[17:40:44.415]                     tryCatch({
[17:40:44.415]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.415]                     }, error = function(ex) {
[17:40:44.415]                       msg <- conditionMessage(ex)
[17:40:44.415]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.415]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.415]                         fi_tmp[["mtime"]], msg)
[17:40:44.415]                       ex$message <- msg
[17:40:44.415]                       stop(ex)
[17:40:44.415]                     })
[17:40:44.415]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.415]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.415]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.415]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.415]                       fi <- file.info(pathname)
[17:40:44.415]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.415]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.415]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.415]                         fi[["size"]], fi[["mtime"]])
[17:40:44.415]                       stop(msg)
[17:40:44.415]                     }
[17:40:44.415]                     invisible(pathname)
[17:40:44.415]                   }
[17:40:44.415]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.415]                     rootPath = tempdir()) 
[17:40:44.415]                   {
[17:40:44.415]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.415]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.415]                       tmpdir = path, fileext = ".rds")
[17:40:44.415]                     save_rds(obj, file)
[17:40:44.415]                   }
[17:40:44.415]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.415]                   {
[17:40:44.415]                     inherits <- base::inherits
[17:40:44.415]                     invokeRestart <- base::invokeRestart
[17:40:44.415]                     is.null <- base::is.null
[17:40:44.415]                     muffled <- FALSE
[17:40:44.415]                     if (inherits(cond, "message")) {
[17:40:44.415]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.415]                       if (muffled) 
[17:40:44.415]                         invokeRestart("muffleMessage")
[17:40:44.415]                     }
[17:40:44.415]                     else if (inherits(cond, "warning")) {
[17:40:44.415]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.415]                       if (muffled) 
[17:40:44.415]                         invokeRestart("muffleWarning")
[17:40:44.415]                     }
[17:40:44.415]                     else if (inherits(cond, "condition")) {
[17:40:44.415]                       if (!is.null(pattern)) {
[17:40:44.415]                         computeRestarts <- base::computeRestarts
[17:40:44.415]                         grepl <- base::grepl
[17:40:44.415]                         restarts <- computeRestarts(cond)
[17:40:44.415]                         for (restart in restarts) {
[17:40:44.415]                           name <- restart$name
[17:40:44.415]                           if (is.null(name)) 
[17:40:44.415]                             next
[17:40:44.415]                           if (!grepl(pattern, name)) 
[17:40:44.415]                             next
[17:40:44.415]                           invokeRestart(restart)
[17:40:44.415]                           muffled <- TRUE
[17:40:44.415]                           break
[17:40:44.415]                         }
[17:40:44.415]                       }
[17:40:44.415]                     }
[17:40:44.415]                     invisible(muffled)
[17:40:44.415]                   }
[17:40:44.415]                   muffleCondition(cond)
[17:40:44.415]                 })
[17:40:44.415]             }))
[17:40:44.415]             future::FutureResult(value = ...future.value$value, 
[17:40:44.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.415]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.415]                     ...future.globalenv.names))
[17:40:44.415]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.415]         }, condition = base::local({
[17:40:44.415]             c <- base::c
[17:40:44.415]             inherits <- base::inherits
[17:40:44.415]             invokeRestart <- base::invokeRestart
[17:40:44.415]             length <- base::length
[17:40:44.415]             list <- base::list
[17:40:44.415]             seq.int <- base::seq.int
[17:40:44.415]             signalCondition <- base::signalCondition
[17:40:44.415]             sys.calls <- base::sys.calls
[17:40:44.415]             `[[` <- base::`[[`
[17:40:44.415]             `+` <- base::`+`
[17:40:44.415]             `<<-` <- base::`<<-`
[17:40:44.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.415]                   3L)]
[17:40:44.415]             }
[17:40:44.415]             function(cond) {
[17:40:44.415]                 is_error <- inherits(cond, "error")
[17:40:44.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.415]                   NULL)
[17:40:44.415]                 if (is_error) {
[17:40:44.415]                   sessionInformation <- function() {
[17:40:44.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.415]                       search = base::search(), system = base::Sys.info())
[17:40:44.415]                   }
[17:40:44.415]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.415]                     cond$call), session = sessionInformation(), 
[17:40:44.415]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.415]                   signalCondition(cond)
[17:40:44.415]                 }
[17:40:44.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.415]                 "immediateCondition"))) {
[17:40:44.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.415]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.415]                   if (TRUE && !signal) {
[17:40:44.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.415]                     {
[17:40:44.415]                       inherits <- base::inherits
[17:40:44.415]                       invokeRestart <- base::invokeRestart
[17:40:44.415]                       is.null <- base::is.null
[17:40:44.415]                       muffled <- FALSE
[17:40:44.415]                       if (inherits(cond, "message")) {
[17:40:44.415]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.415]                         if (muffled) 
[17:40:44.415]                           invokeRestart("muffleMessage")
[17:40:44.415]                       }
[17:40:44.415]                       else if (inherits(cond, "warning")) {
[17:40:44.415]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.415]                         if (muffled) 
[17:40:44.415]                           invokeRestart("muffleWarning")
[17:40:44.415]                       }
[17:40:44.415]                       else if (inherits(cond, "condition")) {
[17:40:44.415]                         if (!is.null(pattern)) {
[17:40:44.415]                           computeRestarts <- base::computeRestarts
[17:40:44.415]                           grepl <- base::grepl
[17:40:44.415]                           restarts <- computeRestarts(cond)
[17:40:44.415]                           for (restart in restarts) {
[17:40:44.415]                             name <- restart$name
[17:40:44.415]                             if (is.null(name)) 
[17:40:44.415]                               next
[17:40:44.415]                             if (!grepl(pattern, name)) 
[17:40:44.415]                               next
[17:40:44.415]                             invokeRestart(restart)
[17:40:44.415]                             muffled <- TRUE
[17:40:44.415]                             break
[17:40:44.415]                           }
[17:40:44.415]                         }
[17:40:44.415]                       }
[17:40:44.415]                       invisible(muffled)
[17:40:44.415]                     }
[17:40:44.415]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.415]                   }
[17:40:44.415]                 }
[17:40:44.415]                 else {
[17:40:44.415]                   if (TRUE) {
[17:40:44.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.415]                     {
[17:40:44.415]                       inherits <- base::inherits
[17:40:44.415]                       invokeRestart <- base::invokeRestart
[17:40:44.415]                       is.null <- base::is.null
[17:40:44.415]                       muffled <- FALSE
[17:40:44.415]                       if (inherits(cond, "message")) {
[17:40:44.415]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.415]                         if (muffled) 
[17:40:44.415]                           invokeRestart("muffleMessage")
[17:40:44.415]                       }
[17:40:44.415]                       else if (inherits(cond, "warning")) {
[17:40:44.415]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.415]                         if (muffled) 
[17:40:44.415]                           invokeRestart("muffleWarning")
[17:40:44.415]                       }
[17:40:44.415]                       else if (inherits(cond, "condition")) {
[17:40:44.415]                         if (!is.null(pattern)) {
[17:40:44.415]                           computeRestarts <- base::computeRestarts
[17:40:44.415]                           grepl <- base::grepl
[17:40:44.415]                           restarts <- computeRestarts(cond)
[17:40:44.415]                           for (restart in restarts) {
[17:40:44.415]                             name <- restart$name
[17:40:44.415]                             if (is.null(name)) 
[17:40:44.415]                               next
[17:40:44.415]                             if (!grepl(pattern, name)) 
[17:40:44.415]                               next
[17:40:44.415]                             invokeRestart(restart)
[17:40:44.415]                             muffled <- TRUE
[17:40:44.415]                             break
[17:40:44.415]                           }
[17:40:44.415]                         }
[17:40:44.415]                       }
[17:40:44.415]                       invisible(muffled)
[17:40:44.415]                     }
[17:40:44.415]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.415]                   }
[17:40:44.415]                 }
[17:40:44.415]             }
[17:40:44.415]         }))
[17:40:44.415]     }, error = function(ex) {
[17:40:44.415]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.415]                 ...future.rng), started = ...future.startTime, 
[17:40:44.415]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.415]             version = "1.8"), class = "FutureResult")
[17:40:44.415]     }, finally = {
[17:40:44.415]         if (!identical(...future.workdir, getwd())) 
[17:40:44.415]             setwd(...future.workdir)
[17:40:44.415]         {
[17:40:44.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.415]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.415]             }
[17:40:44.415]             base::options(...future.oldOptions)
[17:40:44.415]             if (.Platform$OS.type == "windows") {
[17:40:44.415]                 old_names <- names(...future.oldEnvVars)
[17:40:44.415]                 envs <- base::Sys.getenv()
[17:40:44.415]                 names <- names(envs)
[17:40:44.415]                 common <- intersect(names, old_names)
[17:40:44.415]                 added <- setdiff(names, old_names)
[17:40:44.415]                 removed <- setdiff(old_names, names)
[17:40:44.415]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.415]                   envs[common]]
[17:40:44.415]                 NAMES <- toupper(changed)
[17:40:44.415]                 args <- list()
[17:40:44.415]                 for (kk in seq_along(NAMES)) {
[17:40:44.415]                   name <- changed[[kk]]
[17:40:44.415]                   NAME <- NAMES[[kk]]
[17:40:44.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.415]                     next
[17:40:44.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.415]                 }
[17:40:44.415]                 NAMES <- toupper(added)
[17:40:44.415]                 for (kk in seq_along(NAMES)) {
[17:40:44.415]                   name <- added[[kk]]
[17:40:44.415]                   NAME <- NAMES[[kk]]
[17:40:44.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.415]                     next
[17:40:44.415]                   args[[name]] <- ""
[17:40:44.415]                 }
[17:40:44.415]                 NAMES <- toupper(removed)
[17:40:44.415]                 for (kk in seq_along(NAMES)) {
[17:40:44.415]                   name <- removed[[kk]]
[17:40:44.415]                   NAME <- NAMES[[kk]]
[17:40:44.415]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.415]                     next
[17:40:44.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.415]                 }
[17:40:44.415]                 if (length(args) > 0) 
[17:40:44.415]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.415]             }
[17:40:44.415]             else {
[17:40:44.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.415]             }
[17:40:44.415]             {
[17:40:44.415]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.415]                   0L) {
[17:40:44.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.415]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.415]                   base::options(opts)
[17:40:44.415]                 }
[17:40:44.415]                 {
[17:40:44.415]                   {
[17:40:44.415]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.415]                     NULL
[17:40:44.415]                   }
[17:40:44.415]                   options(future.plan = NULL)
[17:40:44.415]                   if (is.na(NA_character_)) 
[17:40:44.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.415]                     .init = FALSE)
[17:40:44.415]                 }
[17:40:44.415]             }
[17:40:44.415]         }
[17:40:44.415]     })
[17:40:44.415]     if (TRUE) {
[17:40:44.415]         base::sink(type = "output", split = FALSE)
[17:40:44.415]         if (TRUE) {
[17:40:44.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.415]         }
[17:40:44.415]         else {
[17:40:44.415]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.415]         }
[17:40:44.415]         base::close(...future.stdout)
[17:40:44.415]         ...future.stdout <- NULL
[17:40:44.415]     }
[17:40:44.415]     ...future.result$conditions <- ...future.conditions
[17:40:44.415]     ...future.result$finished <- base::Sys.time()
[17:40:44.415]     ...future.result
[17:40:44.415] }
[17:40:44.418] requestCore(): workers = 2
[17:40:44.419] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.429] result() for MulticoreFuture ...
[17:40:44.430] result() for MulticoreFuture ...
[17:40:44.430] result() for MulticoreFuture ... done
[17:40:44.430] result() for MulticoreFuture ... done
[17:40:44.431] result() for MulticoreFuture ...
[17:40:44.431] result() for MulticoreFuture ... done
[17:40:44.433] MulticoreFuture started
[17:40:44.433] - Launch lazy future ... done
[17:40:44.434] run() for ‘MulticoreFuture’ ... done
[17:40:44.434] plan(): Setting new future strategy stack:
[17:40:44.435] getGlobalsAndPackages() ...
[17:40:44.435] Searching for globals...
[17:40:44.434] List of future strategies:
[17:40:44.434] 1. sequential:
[17:40:44.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.434]    - tweaked: FALSE
[17:40:44.434]    - call: NULL
[17:40:44.436] plan(): nbrOfWorkers() = 1
[17:40:44.437] - globals found: [1] ‘{’
[17:40:44.437] Searching for globals ... DONE
[17:40:44.438] Resolving globals: FALSE
[17:40:44.438] 
[17:40:44.439] plan(): Setting new future strategy stack:
[17:40:44.439] 
[17:40:44.439] getGlobalsAndPackages() ... DONE
[17:40:44.439] List of future strategies:
[17:40:44.439] 1. multicore:
[17:40:44.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.439]    - tweaked: FALSE
[17:40:44.439]    - call: plan(strategy)
[17:40:44.439] run() for ‘Future’ ...
[17:40:44.440] - state: ‘created’
[17:40:44.440] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.449] plan(): nbrOfWorkers() = 2
[17:40:44.453] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.453]   - Field: ‘label’
[17:40:44.454]   - Field: ‘local’
[17:40:44.454]   - Field: ‘owner’
[17:40:44.454]   - Field: ‘envir’
[17:40:44.454]   - Field: ‘workers’
[17:40:44.454]   - Field: ‘packages’
[17:40:44.455]   - Field: ‘gc’
[17:40:44.455]   - Field: ‘job’
[17:40:44.455]   - Field: ‘conditions’
[17:40:44.455]   - Field: ‘expr’
[17:40:44.455]   - Field: ‘uuid’
[17:40:44.455]   - Field: ‘seed’
[17:40:44.456]   - Field: ‘version’
[17:40:44.456]   - Field: ‘result’
[17:40:44.456]   - Field: ‘asynchronous’
[17:40:44.456]   - Field: ‘calls’
[17:40:44.456]   - Field: ‘globals’
[17:40:44.456]   - Field: ‘stdout’
[17:40:44.457]   - Field: ‘earlySignal’
[17:40:44.457]   - Field: ‘lazy’
[17:40:44.457]   - Field: ‘state’
[17:40:44.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.457] - Launch lazy future ...
[17:40:44.458] Packages needed by the future expression (n = 0): <none>
[17:40:44.458] Packages needed by future strategies (n = 0): <none>
[17:40:44.459] {
[17:40:44.459]     {
[17:40:44.459]         {
[17:40:44.459]             ...future.startTime <- base::Sys.time()
[17:40:44.459]             {
[17:40:44.459]                 {
[17:40:44.459]                   {
[17:40:44.459]                     {
[17:40:44.459]                       base::local({
[17:40:44.459]                         has_future <- base::requireNamespace("future", 
[17:40:44.459]                           quietly = TRUE)
[17:40:44.459]                         if (has_future) {
[17:40:44.459]                           ns <- base::getNamespace("future")
[17:40:44.459]                           version <- ns[[".package"]][["version"]]
[17:40:44.459]                           if (is.null(version)) 
[17:40:44.459]                             version <- utils::packageVersion("future")
[17:40:44.459]                         }
[17:40:44.459]                         else {
[17:40:44.459]                           version <- NULL
[17:40:44.459]                         }
[17:40:44.459]                         if (!has_future || version < "1.8.0") {
[17:40:44.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.459]                             "", base::R.version$version.string), 
[17:40:44.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.459]                               "release", "version")], collapse = " "), 
[17:40:44.459]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.459]                             info)
[17:40:44.459]                           info <- base::paste(info, collapse = "; ")
[17:40:44.459]                           if (!has_future) {
[17:40:44.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.459]                               info)
[17:40:44.459]                           }
[17:40:44.459]                           else {
[17:40:44.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.459]                               info, version)
[17:40:44.459]                           }
[17:40:44.459]                           base::stop(msg)
[17:40:44.459]                         }
[17:40:44.459]                       })
[17:40:44.459]                     }
[17:40:44.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.459]                     base::options(mc.cores = 1L)
[17:40:44.459]                   }
[17:40:44.459]                   ...future.strategy.old <- future::plan("list")
[17:40:44.459]                   options(future.plan = NULL)
[17:40:44.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.459]                 }
[17:40:44.459]                 ...future.workdir <- getwd()
[17:40:44.459]             }
[17:40:44.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.459]         }
[17:40:44.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.459]             base::names(...future.oldOptions))
[17:40:44.459]     }
[17:40:44.459]     if (FALSE) {
[17:40:44.459]     }
[17:40:44.459]     else {
[17:40:44.459]         if (TRUE) {
[17:40:44.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.459]                 open = "w")
[17:40:44.459]         }
[17:40:44.459]         else {
[17:40:44.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.459]         }
[17:40:44.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.459]             base::sink(type = "output", split = FALSE)
[17:40:44.459]             base::close(...future.stdout)
[17:40:44.459]         }, add = TRUE)
[17:40:44.459]     }
[17:40:44.459]     ...future.frame <- base::sys.nframe()
[17:40:44.459]     ...future.conditions <- base::list()
[17:40:44.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.459]     if (FALSE) {
[17:40:44.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.459]     }
[17:40:44.459]     ...future.result <- base::tryCatch({
[17:40:44.459]         base::withCallingHandlers({
[17:40:44.459]             ...future.value <- base::withVisible(base::local({
[17:40:44.459]                 withCallingHandlers({
[17:40:44.459]                   {
[17:40:44.459]                     2
[17:40:44.459]                   }
[17:40:44.459]                 }, immediateCondition = function(cond) {
[17:40:44.459]                   save_rds <- function (object, pathname, ...) 
[17:40:44.459]                   {
[17:40:44.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.459]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.459]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.459]                         fi_tmp[["mtime"]])
[17:40:44.459]                     }
[17:40:44.459]                     tryCatch({
[17:40:44.459]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.459]                     }, error = function(ex) {
[17:40:44.459]                       msg <- conditionMessage(ex)
[17:40:44.459]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.459]                         fi_tmp[["mtime"]], msg)
[17:40:44.459]                       ex$message <- msg
[17:40:44.459]                       stop(ex)
[17:40:44.459]                     })
[17:40:44.459]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.459]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.459]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.459]                       fi <- file.info(pathname)
[17:40:44.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.459]                         fi[["size"]], fi[["mtime"]])
[17:40:44.459]                       stop(msg)
[17:40:44.459]                     }
[17:40:44.459]                     invisible(pathname)
[17:40:44.459]                   }
[17:40:44.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.459]                     rootPath = tempdir()) 
[17:40:44.459]                   {
[17:40:44.459]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.459]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.459]                       tmpdir = path, fileext = ".rds")
[17:40:44.459]                     save_rds(obj, file)
[17:40:44.459]                   }
[17:40:44.459]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.459]                   {
[17:40:44.459]                     inherits <- base::inherits
[17:40:44.459]                     invokeRestart <- base::invokeRestart
[17:40:44.459]                     is.null <- base::is.null
[17:40:44.459]                     muffled <- FALSE
[17:40:44.459]                     if (inherits(cond, "message")) {
[17:40:44.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.459]                       if (muffled) 
[17:40:44.459]                         invokeRestart("muffleMessage")
[17:40:44.459]                     }
[17:40:44.459]                     else if (inherits(cond, "warning")) {
[17:40:44.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.459]                       if (muffled) 
[17:40:44.459]                         invokeRestart("muffleWarning")
[17:40:44.459]                     }
[17:40:44.459]                     else if (inherits(cond, "condition")) {
[17:40:44.459]                       if (!is.null(pattern)) {
[17:40:44.459]                         computeRestarts <- base::computeRestarts
[17:40:44.459]                         grepl <- base::grepl
[17:40:44.459]                         restarts <- computeRestarts(cond)
[17:40:44.459]                         for (restart in restarts) {
[17:40:44.459]                           name <- restart$name
[17:40:44.459]                           if (is.null(name)) 
[17:40:44.459]                             next
[17:40:44.459]                           if (!grepl(pattern, name)) 
[17:40:44.459]                             next
[17:40:44.459]                           invokeRestart(restart)
[17:40:44.459]                           muffled <- TRUE
[17:40:44.459]                           break
[17:40:44.459]                         }
[17:40:44.459]                       }
[17:40:44.459]                     }
[17:40:44.459]                     invisible(muffled)
[17:40:44.459]                   }
[17:40:44.459]                   muffleCondition(cond)
[17:40:44.459]                 })
[17:40:44.459]             }))
[17:40:44.459]             future::FutureResult(value = ...future.value$value, 
[17:40:44.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.459]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.459]                     ...future.globalenv.names))
[17:40:44.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.459]         }, condition = base::local({
[17:40:44.459]             c <- base::c
[17:40:44.459]             inherits <- base::inherits
[17:40:44.459]             invokeRestart <- base::invokeRestart
[17:40:44.459]             length <- base::length
[17:40:44.459]             list <- base::list
[17:40:44.459]             seq.int <- base::seq.int
[17:40:44.459]             signalCondition <- base::signalCondition
[17:40:44.459]             sys.calls <- base::sys.calls
[17:40:44.459]             `[[` <- base::`[[`
[17:40:44.459]             `+` <- base::`+`
[17:40:44.459]             `<<-` <- base::`<<-`
[17:40:44.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.459]                   3L)]
[17:40:44.459]             }
[17:40:44.459]             function(cond) {
[17:40:44.459]                 is_error <- inherits(cond, "error")
[17:40:44.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.459]                   NULL)
[17:40:44.459]                 if (is_error) {
[17:40:44.459]                   sessionInformation <- function() {
[17:40:44.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.459]                       search = base::search(), system = base::Sys.info())
[17:40:44.459]                   }
[17:40:44.459]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.459]                     cond$call), session = sessionInformation(), 
[17:40:44.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.459]                   signalCondition(cond)
[17:40:44.459]                 }
[17:40:44.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.459]                 "immediateCondition"))) {
[17:40:44.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.459]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.459]                   if (TRUE && !signal) {
[17:40:44.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.459]                     {
[17:40:44.459]                       inherits <- base::inherits
[17:40:44.459]                       invokeRestart <- base::invokeRestart
[17:40:44.459]                       is.null <- base::is.null
[17:40:44.459]                       muffled <- FALSE
[17:40:44.459]                       if (inherits(cond, "message")) {
[17:40:44.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.459]                         if (muffled) 
[17:40:44.459]                           invokeRestart("muffleMessage")
[17:40:44.459]                       }
[17:40:44.459]                       else if (inherits(cond, "warning")) {
[17:40:44.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.459]                         if (muffled) 
[17:40:44.459]                           invokeRestart("muffleWarning")
[17:40:44.459]                       }
[17:40:44.459]                       else if (inherits(cond, "condition")) {
[17:40:44.459]                         if (!is.null(pattern)) {
[17:40:44.459]                           computeRestarts <- base::computeRestarts
[17:40:44.459]                           grepl <- base::grepl
[17:40:44.459]                           restarts <- computeRestarts(cond)
[17:40:44.459]                           for (restart in restarts) {
[17:40:44.459]                             name <- restart$name
[17:40:44.459]                             if (is.null(name)) 
[17:40:44.459]                               next
[17:40:44.459]                             if (!grepl(pattern, name)) 
[17:40:44.459]                               next
[17:40:44.459]                             invokeRestart(restart)
[17:40:44.459]                             muffled <- TRUE
[17:40:44.459]                             break
[17:40:44.459]                           }
[17:40:44.459]                         }
[17:40:44.459]                       }
[17:40:44.459]                       invisible(muffled)
[17:40:44.459]                     }
[17:40:44.459]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.459]                   }
[17:40:44.459]                 }
[17:40:44.459]                 else {
[17:40:44.459]                   if (TRUE) {
[17:40:44.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.459]                     {
[17:40:44.459]                       inherits <- base::inherits
[17:40:44.459]                       invokeRestart <- base::invokeRestart
[17:40:44.459]                       is.null <- base::is.null
[17:40:44.459]                       muffled <- FALSE
[17:40:44.459]                       if (inherits(cond, "message")) {
[17:40:44.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.459]                         if (muffled) 
[17:40:44.459]                           invokeRestart("muffleMessage")
[17:40:44.459]                       }
[17:40:44.459]                       else if (inherits(cond, "warning")) {
[17:40:44.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.459]                         if (muffled) 
[17:40:44.459]                           invokeRestart("muffleWarning")
[17:40:44.459]                       }
[17:40:44.459]                       else if (inherits(cond, "condition")) {
[17:40:44.459]                         if (!is.null(pattern)) {
[17:40:44.459]                           computeRestarts <- base::computeRestarts
[17:40:44.459]                           grepl <- base::grepl
[17:40:44.459]                           restarts <- computeRestarts(cond)
[17:40:44.459]                           for (restart in restarts) {
[17:40:44.459]                             name <- restart$name
[17:40:44.459]                             if (is.null(name)) 
[17:40:44.459]                               next
[17:40:44.459]                             if (!grepl(pattern, name)) 
[17:40:44.459]                               next
[17:40:44.459]                             invokeRestart(restart)
[17:40:44.459]                             muffled <- TRUE
[17:40:44.459]                             break
[17:40:44.459]                           }
[17:40:44.459]                         }
[17:40:44.459]                       }
[17:40:44.459]                       invisible(muffled)
[17:40:44.459]                     }
[17:40:44.459]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.459]                   }
[17:40:44.459]                 }
[17:40:44.459]             }
[17:40:44.459]         }))
[17:40:44.459]     }, error = function(ex) {
[17:40:44.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.459]                 ...future.rng), started = ...future.startTime, 
[17:40:44.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.459]             version = "1.8"), class = "FutureResult")
[17:40:44.459]     }, finally = {
[17:40:44.459]         if (!identical(...future.workdir, getwd())) 
[17:40:44.459]             setwd(...future.workdir)
[17:40:44.459]         {
[17:40:44.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.459]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.459]             }
[17:40:44.459]             base::options(...future.oldOptions)
[17:40:44.459]             if (.Platform$OS.type == "windows") {
[17:40:44.459]                 old_names <- names(...future.oldEnvVars)
[17:40:44.459]                 envs <- base::Sys.getenv()
[17:40:44.459]                 names <- names(envs)
[17:40:44.459]                 common <- intersect(names, old_names)
[17:40:44.459]                 added <- setdiff(names, old_names)
[17:40:44.459]                 removed <- setdiff(old_names, names)
[17:40:44.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.459]                   envs[common]]
[17:40:44.459]                 NAMES <- toupper(changed)
[17:40:44.459]                 args <- list()
[17:40:44.459]                 for (kk in seq_along(NAMES)) {
[17:40:44.459]                   name <- changed[[kk]]
[17:40:44.459]                   NAME <- NAMES[[kk]]
[17:40:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.459]                     next
[17:40:44.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.459]                 }
[17:40:44.459]                 NAMES <- toupper(added)
[17:40:44.459]                 for (kk in seq_along(NAMES)) {
[17:40:44.459]                   name <- added[[kk]]
[17:40:44.459]                   NAME <- NAMES[[kk]]
[17:40:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.459]                     next
[17:40:44.459]                   args[[name]] <- ""
[17:40:44.459]                 }
[17:40:44.459]                 NAMES <- toupper(removed)
[17:40:44.459]                 for (kk in seq_along(NAMES)) {
[17:40:44.459]                   name <- removed[[kk]]
[17:40:44.459]                   NAME <- NAMES[[kk]]
[17:40:44.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.459]                     next
[17:40:44.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.459]                 }
[17:40:44.459]                 if (length(args) > 0) 
[17:40:44.459]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.459]             }
[17:40:44.459]             else {
[17:40:44.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.459]             }
[17:40:44.459]             {
[17:40:44.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.459]                   0L) {
[17:40:44.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.459]                   base::options(opts)
[17:40:44.459]                 }
[17:40:44.459]                 {
[17:40:44.459]                   {
[17:40:44.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.459]                     NULL
[17:40:44.459]                   }
[17:40:44.459]                   options(future.plan = NULL)
[17:40:44.459]                   if (is.na(NA_character_)) 
[17:40:44.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.459]                     .init = FALSE)
[17:40:44.459]                 }
[17:40:44.459]             }
[17:40:44.459]         }
[17:40:44.459]     })
[17:40:44.459]     if (TRUE) {
[17:40:44.459]         base::sink(type = "output", split = FALSE)
[17:40:44.459]         if (TRUE) {
[17:40:44.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.459]         }
[17:40:44.459]         else {
[17:40:44.459]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.459]         }
[17:40:44.459]         base::close(...future.stdout)
[17:40:44.459]         ...future.stdout <- NULL
[17:40:44.459]     }
[17:40:44.459]     ...future.result$conditions <- ...future.conditions
[17:40:44.459]     ...future.result$finished <- base::Sys.time()
[17:40:44.459]     ...future.result
[17:40:44.459] }
[17:40:44.461] requestCore(): workers = 2
[17:40:44.461] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.472] result() for MulticoreFuture ...
[17:40:44.473] result() for MulticoreFuture ...
[17:40:44.473] result() for MulticoreFuture ... done
[17:40:44.473] result() for MulticoreFuture ... done
[17:40:44.473] result() for MulticoreFuture ...
[17:40:44.473] result() for MulticoreFuture ... done
[17:40:44.476] MulticoreFuture started
[17:40:44.476] - Launch lazy future ... done
[17:40:44.477] run() for ‘MulticoreFuture’ ... done
[17:40:44.477] plan(): Setting new future strategy stack:
[17:40:44.479] resolve() on list environment ...
[17:40:44.477] List of future strategies:
[17:40:44.477] 1. sequential:
[17:40:44.477]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.477]    - tweaked: FALSE
[17:40:44.477]    - call: NULL
[17:40:44.479]  recursive: 0
[17:40:44.479] plan(): nbrOfWorkers() = 1
[17:40:44.480]  length: 3
[17:40:44.480]  elements: ‘a’, ‘b’, ‘c’
[17:40:44.481] Future #1
[17:40:44.481]  length: 2 (resolved future 1)
[17:40:44.482] plan(): Setting new future strategy stack:
[17:40:44.482] List of future strategies:
[17:40:44.482] 1. multicore:
[17:40:44.482]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.482]    - tweaked: FALSE
[17:40:44.482]    - call: plan(strategy)
[17:40:44.487] plan(): nbrOfWorkers() = 2
[17:40:44.487] Future #2
[17:40:44.488]  length: 1 (resolved future 2)
[17:40:44.488]  length: 0 (resolved future 3)
[17:40:44.488] resolve() on list environment ... DONE
[17:40:44.489] getGlobalsAndPackages() ...
[17:40:44.489] Searching for globals...
[17:40:44.490] - globals found: [1] ‘{’
[17:40:44.490] Searching for globals ... DONE
[17:40:44.491] Resolving globals: FALSE
[17:40:44.491] 
[17:40:44.491] 
[17:40:44.491] getGlobalsAndPackages() ... DONE
[17:40:44.492] run() for ‘Future’ ...
[17:40:44.492] - state: ‘created’
[17:40:44.492] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.497] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.497]   - Field: ‘label’
[17:40:44.497]   - Field: ‘local’
[17:40:44.497]   - Field: ‘owner’
[17:40:44.498]   - Field: ‘envir’
[17:40:44.498]   - Field: ‘workers’
[17:40:44.498]   - Field: ‘packages’
[17:40:44.498]   - Field: ‘gc’
[17:40:44.498]   - Field: ‘job’
[17:40:44.498]   - Field: ‘conditions’
[17:40:44.498]   - Field: ‘expr’
[17:40:44.499]   - Field: ‘uuid’
[17:40:44.499]   - Field: ‘seed’
[17:40:44.499]   - Field: ‘version’
[17:40:44.499]   - Field: ‘result’
[17:40:44.499]   - Field: ‘asynchronous’
[17:40:44.499]   - Field: ‘calls’
[17:40:44.499]   - Field: ‘globals’
[17:40:44.499]   - Field: ‘stdout’
[17:40:44.500]   - Field: ‘earlySignal’
[17:40:44.500]   - Field: ‘lazy’
[17:40:44.500]   - Field: ‘state’
[17:40:44.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.500] - Launch lazy future ...
[17:40:44.501] Packages needed by the future expression (n = 0): <none>
[17:40:44.501] Packages needed by future strategies (n = 0): <none>
[17:40:44.502] {
[17:40:44.502]     {
[17:40:44.502]         {
[17:40:44.502]             ...future.startTime <- base::Sys.time()
[17:40:44.502]             {
[17:40:44.502]                 {
[17:40:44.502]                   {
[17:40:44.502]                     {
[17:40:44.502]                       base::local({
[17:40:44.502]                         has_future <- base::requireNamespace("future", 
[17:40:44.502]                           quietly = TRUE)
[17:40:44.502]                         if (has_future) {
[17:40:44.502]                           ns <- base::getNamespace("future")
[17:40:44.502]                           version <- ns[[".package"]][["version"]]
[17:40:44.502]                           if (is.null(version)) 
[17:40:44.502]                             version <- utils::packageVersion("future")
[17:40:44.502]                         }
[17:40:44.502]                         else {
[17:40:44.502]                           version <- NULL
[17:40:44.502]                         }
[17:40:44.502]                         if (!has_future || version < "1.8.0") {
[17:40:44.502]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.502]                             "", base::R.version$version.string), 
[17:40:44.502]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.502]                               "release", "version")], collapse = " "), 
[17:40:44.502]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.502]                             info)
[17:40:44.502]                           info <- base::paste(info, collapse = "; ")
[17:40:44.502]                           if (!has_future) {
[17:40:44.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.502]                               info)
[17:40:44.502]                           }
[17:40:44.502]                           else {
[17:40:44.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.502]                               info, version)
[17:40:44.502]                           }
[17:40:44.502]                           base::stop(msg)
[17:40:44.502]                         }
[17:40:44.502]                       })
[17:40:44.502]                     }
[17:40:44.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.502]                     base::options(mc.cores = 1L)
[17:40:44.502]                   }
[17:40:44.502]                   ...future.strategy.old <- future::plan("list")
[17:40:44.502]                   options(future.plan = NULL)
[17:40:44.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.502]                 }
[17:40:44.502]                 ...future.workdir <- getwd()
[17:40:44.502]             }
[17:40:44.502]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.502]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.502]         }
[17:40:44.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.502]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.502]             base::names(...future.oldOptions))
[17:40:44.502]     }
[17:40:44.502]     if (FALSE) {
[17:40:44.502]     }
[17:40:44.502]     else {
[17:40:44.502]         if (TRUE) {
[17:40:44.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.502]                 open = "w")
[17:40:44.502]         }
[17:40:44.502]         else {
[17:40:44.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.502]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.502]         }
[17:40:44.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.502]             base::sink(type = "output", split = FALSE)
[17:40:44.502]             base::close(...future.stdout)
[17:40:44.502]         }, add = TRUE)
[17:40:44.502]     }
[17:40:44.502]     ...future.frame <- base::sys.nframe()
[17:40:44.502]     ...future.conditions <- base::list()
[17:40:44.502]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.502]     if (FALSE) {
[17:40:44.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.502]     }
[17:40:44.502]     ...future.result <- base::tryCatch({
[17:40:44.502]         base::withCallingHandlers({
[17:40:44.502]             ...future.value <- base::withVisible(base::local({
[17:40:44.502]                 withCallingHandlers({
[17:40:44.502]                   {
[17:40:44.502]                     1
[17:40:44.502]                   }
[17:40:44.502]                 }, immediateCondition = function(cond) {
[17:40:44.502]                   save_rds <- function (object, pathname, ...) 
[17:40:44.502]                   {
[17:40:44.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.502]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.502]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.502]                         fi_tmp[["mtime"]])
[17:40:44.502]                     }
[17:40:44.502]                     tryCatch({
[17:40:44.502]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.502]                     }, error = function(ex) {
[17:40:44.502]                       msg <- conditionMessage(ex)
[17:40:44.502]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.502]                         fi_tmp[["mtime"]], msg)
[17:40:44.502]                       ex$message <- msg
[17:40:44.502]                       stop(ex)
[17:40:44.502]                     })
[17:40:44.502]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.502]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.502]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.502]                       fi <- file.info(pathname)
[17:40:44.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.502]                         fi[["size"]], fi[["mtime"]])
[17:40:44.502]                       stop(msg)
[17:40:44.502]                     }
[17:40:44.502]                     invisible(pathname)
[17:40:44.502]                   }
[17:40:44.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.502]                     rootPath = tempdir()) 
[17:40:44.502]                   {
[17:40:44.502]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.502]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.502]                       tmpdir = path, fileext = ".rds")
[17:40:44.502]                     save_rds(obj, file)
[17:40:44.502]                   }
[17:40:44.502]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.502]                   {
[17:40:44.502]                     inherits <- base::inherits
[17:40:44.502]                     invokeRestart <- base::invokeRestart
[17:40:44.502]                     is.null <- base::is.null
[17:40:44.502]                     muffled <- FALSE
[17:40:44.502]                     if (inherits(cond, "message")) {
[17:40:44.502]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.502]                       if (muffled) 
[17:40:44.502]                         invokeRestart("muffleMessage")
[17:40:44.502]                     }
[17:40:44.502]                     else if (inherits(cond, "warning")) {
[17:40:44.502]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.502]                       if (muffled) 
[17:40:44.502]                         invokeRestart("muffleWarning")
[17:40:44.502]                     }
[17:40:44.502]                     else if (inherits(cond, "condition")) {
[17:40:44.502]                       if (!is.null(pattern)) {
[17:40:44.502]                         computeRestarts <- base::computeRestarts
[17:40:44.502]                         grepl <- base::grepl
[17:40:44.502]                         restarts <- computeRestarts(cond)
[17:40:44.502]                         for (restart in restarts) {
[17:40:44.502]                           name <- restart$name
[17:40:44.502]                           if (is.null(name)) 
[17:40:44.502]                             next
[17:40:44.502]                           if (!grepl(pattern, name)) 
[17:40:44.502]                             next
[17:40:44.502]                           invokeRestart(restart)
[17:40:44.502]                           muffled <- TRUE
[17:40:44.502]                           break
[17:40:44.502]                         }
[17:40:44.502]                       }
[17:40:44.502]                     }
[17:40:44.502]                     invisible(muffled)
[17:40:44.502]                   }
[17:40:44.502]                   muffleCondition(cond)
[17:40:44.502]                 })
[17:40:44.502]             }))
[17:40:44.502]             future::FutureResult(value = ...future.value$value, 
[17:40:44.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.502]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.502]                     ...future.globalenv.names))
[17:40:44.502]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.502]         }, condition = base::local({
[17:40:44.502]             c <- base::c
[17:40:44.502]             inherits <- base::inherits
[17:40:44.502]             invokeRestart <- base::invokeRestart
[17:40:44.502]             length <- base::length
[17:40:44.502]             list <- base::list
[17:40:44.502]             seq.int <- base::seq.int
[17:40:44.502]             signalCondition <- base::signalCondition
[17:40:44.502]             sys.calls <- base::sys.calls
[17:40:44.502]             `[[` <- base::`[[`
[17:40:44.502]             `+` <- base::`+`
[17:40:44.502]             `<<-` <- base::`<<-`
[17:40:44.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.502]                   3L)]
[17:40:44.502]             }
[17:40:44.502]             function(cond) {
[17:40:44.502]                 is_error <- inherits(cond, "error")
[17:40:44.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.502]                   NULL)
[17:40:44.502]                 if (is_error) {
[17:40:44.502]                   sessionInformation <- function() {
[17:40:44.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.502]                       search = base::search(), system = base::Sys.info())
[17:40:44.502]                   }
[17:40:44.502]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.502]                     cond$call), session = sessionInformation(), 
[17:40:44.502]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.502]                   signalCondition(cond)
[17:40:44.502]                 }
[17:40:44.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.502]                 "immediateCondition"))) {
[17:40:44.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.502]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.502]                   if (TRUE && !signal) {
[17:40:44.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.502]                     {
[17:40:44.502]                       inherits <- base::inherits
[17:40:44.502]                       invokeRestart <- base::invokeRestart
[17:40:44.502]                       is.null <- base::is.null
[17:40:44.502]                       muffled <- FALSE
[17:40:44.502]                       if (inherits(cond, "message")) {
[17:40:44.502]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.502]                         if (muffled) 
[17:40:44.502]                           invokeRestart("muffleMessage")
[17:40:44.502]                       }
[17:40:44.502]                       else if (inherits(cond, "warning")) {
[17:40:44.502]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.502]                         if (muffled) 
[17:40:44.502]                           invokeRestart("muffleWarning")
[17:40:44.502]                       }
[17:40:44.502]                       else if (inherits(cond, "condition")) {
[17:40:44.502]                         if (!is.null(pattern)) {
[17:40:44.502]                           computeRestarts <- base::computeRestarts
[17:40:44.502]                           grepl <- base::grepl
[17:40:44.502]                           restarts <- computeRestarts(cond)
[17:40:44.502]                           for (restart in restarts) {
[17:40:44.502]                             name <- restart$name
[17:40:44.502]                             if (is.null(name)) 
[17:40:44.502]                               next
[17:40:44.502]                             if (!grepl(pattern, name)) 
[17:40:44.502]                               next
[17:40:44.502]                             invokeRestart(restart)
[17:40:44.502]                             muffled <- TRUE
[17:40:44.502]                             break
[17:40:44.502]                           }
[17:40:44.502]                         }
[17:40:44.502]                       }
[17:40:44.502]                       invisible(muffled)
[17:40:44.502]                     }
[17:40:44.502]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.502]                   }
[17:40:44.502]                 }
[17:40:44.502]                 else {
[17:40:44.502]                   if (TRUE) {
[17:40:44.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.502]                     {
[17:40:44.502]                       inherits <- base::inherits
[17:40:44.502]                       invokeRestart <- base::invokeRestart
[17:40:44.502]                       is.null <- base::is.null
[17:40:44.502]                       muffled <- FALSE
[17:40:44.502]                       if (inherits(cond, "message")) {
[17:40:44.502]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.502]                         if (muffled) 
[17:40:44.502]                           invokeRestart("muffleMessage")
[17:40:44.502]                       }
[17:40:44.502]                       else if (inherits(cond, "warning")) {
[17:40:44.502]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.502]                         if (muffled) 
[17:40:44.502]                           invokeRestart("muffleWarning")
[17:40:44.502]                       }
[17:40:44.502]                       else if (inherits(cond, "condition")) {
[17:40:44.502]                         if (!is.null(pattern)) {
[17:40:44.502]                           computeRestarts <- base::computeRestarts
[17:40:44.502]                           grepl <- base::grepl
[17:40:44.502]                           restarts <- computeRestarts(cond)
[17:40:44.502]                           for (restart in restarts) {
[17:40:44.502]                             name <- restart$name
[17:40:44.502]                             if (is.null(name)) 
[17:40:44.502]                               next
[17:40:44.502]                             if (!grepl(pattern, name)) 
[17:40:44.502]                               next
[17:40:44.502]                             invokeRestart(restart)
[17:40:44.502]                             muffled <- TRUE
[17:40:44.502]                             break
[17:40:44.502]                           }
[17:40:44.502]                         }
[17:40:44.502]                       }
[17:40:44.502]                       invisible(muffled)
[17:40:44.502]                     }
[17:40:44.502]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.502]                   }
[17:40:44.502]                 }
[17:40:44.502]             }
[17:40:44.502]         }))
[17:40:44.502]     }, error = function(ex) {
[17:40:44.502]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.502]                 ...future.rng), started = ...future.startTime, 
[17:40:44.502]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.502]             version = "1.8"), class = "FutureResult")
[17:40:44.502]     }, finally = {
[17:40:44.502]         if (!identical(...future.workdir, getwd())) 
[17:40:44.502]             setwd(...future.workdir)
[17:40:44.502]         {
[17:40:44.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.502]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.502]             }
[17:40:44.502]             base::options(...future.oldOptions)
[17:40:44.502]             if (.Platform$OS.type == "windows") {
[17:40:44.502]                 old_names <- names(...future.oldEnvVars)
[17:40:44.502]                 envs <- base::Sys.getenv()
[17:40:44.502]                 names <- names(envs)
[17:40:44.502]                 common <- intersect(names, old_names)
[17:40:44.502]                 added <- setdiff(names, old_names)
[17:40:44.502]                 removed <- setdiff(old_names, names)
[17:40:44.502]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.502]                   envs[common]]
[17:40:44.502]                 NAMES <- toupper(changed)
[17:40:44.502]                 args <- list()
[17:40:44.502]                 for (kk in seq_along(NAMES)) {
[17:40:44.502]                   name <- changed[[kk]]
[17:40:44.502]                   NAME <- NAMES[[kk]]
[17:40:44.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.502]                     next
[17:40:44.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.502]                 }
[17:40:44.502]                 NAMES <- toupper(added)
[17:40:44.502]                 for (kk in seq_along(NAMES)) {
[17:40:44.502]                   name <- added[[kk]]
[17:40:44.502]                   NAME <- NAMES[[kk]]
[17:40:44.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.502]                     next
[17:40:44.502]                   args[[name]] <- ""
[17:40:44.502]                 }
[17:40:44.502]                 NAMES <- toupper(removed)
[17:40:44.502]                 for (kk in seq_along(NAMES)) {
[17:40:44.502]                   name <- removed[[kk]]
[17:40:44.502]                   NAME <- NAMES[[kk]]
[17:40:44.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.502]                     next
[17:40:44.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.502]                 }
[17:40:44.502]                 if (length(args) > 0) 
[17:40:44.502]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.502]             }
[17:40:44.502]             else {
[17:40:44.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.502]             }
[17:40:44.502]             {
[17:40:44.502]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.502]                   0L) {
[17:40:44.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.502]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.502]                   base::options(opts)
[17:40:44.502]                 }
[17:40:44.502]                 {
[17:40:44.502]                   {
[17:40:44.502]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.502]                     NULL
[17:40:44.502]                   }
[17:40:44.502]                   options(future.plan = NULL)
[17:40:44.502]                   if (is.na(NA_character_)) 
[17:40:44.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.502]                     .init = FALSE)
[17:40:44.502]                 }
[17:40:44.502]             }
[17:40:44.502]         }
[17:40:44.502]     })
[17:40:44.502]     if (TRUE) {
[17:40:44.502]         base::sink(type = "output", split = FALSE)
[17:40:44.502]         if (TRUE) {
[17:40:44.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.502]         }
[17:40:44.502]         else {
[17:40:44.502]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.502]         }
[17:40:44.502]         base::close(...future.stdout)
[17:40:44.502]         ...future.stdout <- NULL
[17:40:44.502]     }
[17:40:44.502]     ...future.result$conditions <- ...future.conditions
[17:40:44.502]     ...future.result$finished <- base::Sys.time()
[17:40:44.502]     ...future.result
[17:40:44.502] }
[17:40:44.505] requestCore(): workers = 2
[17:40:44.506] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.516] result() for MulticoreFuture ...
[17:40:44.517] result() for MulticoreFuture ...
[17:40:44.517] result() for MulticoreFuture ... done
[17:40:44.518] result() for MulticoreFuture ... done
[17:40:44.518] result() for MulticoreFuture ...
[17:40:44.518] result() for MulticoreFuture ... done
[17:40:44.521] MulticoreFuture started
[17:40:44.521] - Launch lazy future ... done
[17:40:44.522] run() for ‘MulticoreFuture’ ... done
[17:40:44.522] plan(): Setting new future strategy stack:
[17:40:44.523] getGlobalsAndPackages() ...
[17:40:44.523] Searching for globals...
[17:40:44.522] List of future strategies:
[17:40:44.522] 1. sequential:
[17:40:44.522]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.522]    - tweaked: FALSE
[17:40:44.522]    - call: NULL
[17:40:44.523] plan(): nbrOfWorkers() = 1
[17:40:44.525] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:40:44.525] Searching for globals ... DONE
[17:40:44.525] Resolving globals: FALSE
[17:40:44.525] plan(): Setting new future strategy stack:
[17:40:44.526] 
[17:40:44.526] 
[17:40:44.526] List of future strategies:
[17:40:44.526] 1. multicore:
[17:40:44.526]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.526]    - tweaked: FALSE
[17:40:44.526]    - call: plan(strategy)
[17:40:44.526] getGlobalsAndPackages() ... DONE
[17:40:44.527] run() for ‘Future’ ...
[17:40:44.527] - state: ‘created’
[17:40:44.527] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.531] plan(): nbrOfWorkers() = 2
[17:40:44.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.532] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.532]   - Field: ‘label’
[17:40:44.533]   - Field: ‘local’
[17:40:44.533]   - Field: ‘owner’
[17:40:44.533]   - Field: ‘envir’
[17:40:44.533]   - Field: ‘workers’
[17:40:44.533]   - Field: ‘packages’
[17:40:44.533]   - Field: ‘gc’
[17:40:44.534]   - Field: ‘job’
[17:40:44.534]   - Field: ‘conditions’
[17:40:44.534]   - Field: ‘expr’
[17:40:44.534]   - Field: ‘uuid’
[17:40:44.534]   - Field: ‘seed’
[17:40:44.534]   - Field: ‘version’
[17:40:44.534]   - Field: ‘result’
[17:40:44.535]   - Field: ‘asynchronous’
[17:40:44.535]   - Field: ‘calls’
[17:40:44.535]   - Field: ‘globals’
[17:40:44.535]   - Field: ‘stdout’
[17:40:44.539]   - Field: ‘earlySignal’
[17:40:44.539]   - Field: ‘lazy’
[17:40:44.540]   - Field: ‘state’
[17:40:44.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.540] - Launch lazy future ...
[17:40:44.541] Packages needed by the future expression (n = 0): <none>
[17:40:44.542] Packages needed by future strategies (n = 0): <none>
[17:40:44.543] {
[17:40:44.543]     {
[17:40:44.543]         {
[17:40:44.543]             ...future.startTime <- base::Sys.time()
[17:40:44.543]             {
[17:40:44.543]                 {
[17:40:44.543]                   {
[17:40:44.543]                     {
[17:40:44.543]                       base::local({
[17:40:44.543]                         has_future <- base::requireNamespace("future", 
[17:40:44.543]                           quietly = TRUE)
[17:40:44.543]                         if (has_future) {
[17:40:44.543]                           ns <- base::getNamespace("future")
[17:40:44.543]                           version <- ns[[".package"]][["version"]]
[17:40:44.543]                           if (is.null(version)) 
[17:40:44.543]                             version <- utils::packageVersion("future")
[17:40:44.543]                         }
[17:40:44.543]                         else {
[17:40:44.543]                           version <- NULL
[17:40:44.543]                         }
[17:40:44.543]                         if (!has_future || version < "1.8.0") {
[17:40:44.543]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.543]                             "", base::R.version$version.string), 
[17:40:44.543]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.543]                               "release", "version")], collapse = " "), 
[17:40:44.543]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.543]                             info)
[17:40:44.543]                           info <- base::paste(info, collapse = "; ")
[17:40:44.543]                           if (!has_future) {
[17:40:44.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.543]                               info)
[17:40:44.543]                           }
[17:40:44.543]                           else {
[17:40:44.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.543]                               info, version)
[17:40:44.543]                           }
[17:40:44.543]                           base::stop(msg)
[17:40:44.543]                         }
[17:40:44.543]                       })
[17:40:44.543]                     }
[17:40:44.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.543]                     base::options(mc.cores = 1L)
[17:40:44.543]                   }
[17:40:44.543]                   ...future.strategy.old <- future::plan("list")
[17:40:44.543]                   options(future.plan = NULL)
[17:40:44.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.543]                 }
[17:40:44.543]                 ...future.workdir <- getwd()
[17:40:44.543]             }
[17:40:44.543]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.543]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.543]         }
[17:40:44.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.543]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.543]             base::names(...future.oldOptions))
[17:40:44.543]     }
[17:40:44.543]     if (FALSE) {
[17:40:44.543]     }
[17:40:44.543]     else {
[17:40:44.543]         if (TRUE) {
[17:40:44.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.543]                 open = "w")
[17:40:44.543]         }
[17:40:44.543]         else {
[17:40:44.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.543]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.543]         }
[17:40:44.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.543]             base::sink(type = "output", split = FALSE)
[17:40:44.543]             base::close(...future.stdout)
[17:40:44.543]         }, add = TRUE)
[17:40:44.543]     }
[17:40:44.543]     ...future.frame <- base::sys.nframe()
[17:40:44.543]     ...future.conditions <- base::list()
[17:40:44.543]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.543]     if (FALSE) {
[17:40:44.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.543]     }
[17:40:44.543]     ...future.result <- base::tryCatch({
[17:40:44.543]         base::withCallingHandlers({
[17:40:44.543]             ...future.value <- base::withVisible(base::local({
[17:40:44.543]                 withCallingHandlers({
[17:40:44.543]                   {
[17:40:44.543]                     Sys.sleep(0.5)
[17:40:44.543]                     2
[17:40:44.543]                   }
[17:40:44.543]                 }, immediateCondition = function(cond) {
[17:40:44.543]                   save_rds <- function (object, pathname, ...) 
[17:40:44.543]                   {
[17:40:44.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.543]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.543]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.543]                         fi_tmp[["mtime"]])
[17:40:44.543]                     }
[17:40:44.543]                     tryCatch({
[17:40:44.543]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.543]                     }, error = function(ex) {
[17:40:44.543]                       msg <- conditionMessage(ex)
[17:40:44.543]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.543]                         fi_tmp[["mtime"]], msg)
[17:40:44.543]                       ex$message <- msg
[17:40:44.543]                       stop(ex)
[17:40:44.543]                     })
[17:40:44.543]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.543]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.543]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.543]                       fi <- file.info(pathname)
[17:40:44.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.543]                         fi[["size"]], fi[["mtime"]])
[17:40:44.543]                       stop(msg)
[17:40:44.543]                     }
[17:40:44.543]                     invisible(pathname)
[17:40:44.543]                   }
[17:40:44.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.543]                     rootPath = tempdir()) 
[17:40:44.543]                   {
[17:40:44.543]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.543]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.543]                       tmpdir = path, fileext = ".rds")
[17:40:44.543]                     save_rds(obj, file)
[17:40:44.543]                   }
[17:40:44.543]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.543]                   {
[17:40:44.543]                     inherits <- base::inherits
[17:40:44.543]                     invokeRestart <- base::invokeRestart
[17:40:44.543]                     is.null <- base::is.null
[17:40:44.543]                     muffled <- FALSE
[17:40:44.543]                     if (inherits(cond, "message")) {
[17:40:44.543]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.543]                       if (muffled) 
[17:40:44.543]                         invokeRestart("muffleMessage")
[17:40:44.543]                     }
[17:40:44.543]                     else if (inherits(cond, "warning")) {
[17:40:44.543]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.543]                       if (muffled) 
[17:40:44.543]                         invokeRestart("muffleWarning")
[17:40:44.543]                     }
[17:40:44.543]                     else if (inherits(cond, "condition")) {
[17:40:44.543]                       if (!is.null(pattern)) {
[17:40:44.543]                         computeRestarts <- base::computeRestarts
[17:40:44.543]                         grepl <- base::grepl
[17:40:44.543]                         restarts <- computeRestarts(cond)
[17:40:44.543]                         for (restart in restarts) {
[17:40:44.543]                           name <- restart$name
[17:40:44.543]                           if (is.null(name)) 
[17:40:44.543]                             next
[17:40:44.543]                           if (!grepl(pattern, name)) 
[17:40:44.543]                             next
[17:40:44.543]                           invokeRestart(restart)
[17:40:44.543]                           muffled <- TRUE
[17:40:44.543]                           break
[17:40:44.543]                         }
[17:40:44.543]                       }
[17:40:44.543]                     }
[17:40:44.543]                     invisible(muffled)
[17:40:44.543]                   }
[17:40:44.543]                   muffleCondition(cond)
[17:40:44.543]                 })
[17:40:44.543]             }))
[17:40:44.543]             future::FutureResult(value = ...future.value$value, 
[17:40:44.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.543]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.543]                     ...future.globalenv.names))
[17:40:44.543]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.543]         }, condition = base::local({
[17:40:44.543]             c <- base::c
[17:40:44.543]             inherits <- base::inherits
[17:40:44.543]             invokeRestart <- base::invokeRestart
[17:40:44.543]             length <- base::length
[17:40:44.543]             list <- base::list
[17:40:44.543]             seq.int <- base::seq.int
[17:40:44.543]             signalCondition <- base::signalCondition
[17:40:44.543]             sys.calls <- base::sys.calls
[17:40:44.543]             `[[` <- base::`[[`
[17:40:44.543]             `+` <- base::`+`
[17:40:44.543]             `<<-` <- base::`<<-`
[17:40:44.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.543]                   3L)]
[17:40:44.543]             }
[17:40:44.543]             function(cond) {
[17:40:44.543]                 is_error <- inherits(cond, "error")
[17:40:44.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.543]                   NULL)
[17:40:44.543]                 if (is_error) {
[17:40:44.543]                   sessionInformation <- function() {
[17:40:44.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.543]                       search = base::search(), system = base::Sys.info())
[17:40:44.543]                   }
[17:40:44.543]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.543]                     cond$call), session = sessionInformation(), 
[17:40:44.543]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.543]                   signalCondition(cond)
[17:40:44.543]                 }
[17:40:44.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.543]                 "immediateCondition"))) {
[17:40:44.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.543]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.543]                   if (TRUE && !signal) {
[17:40:44.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.543]                     {
[17:40:44.543]                       inherits <- base::inherits
[17:40:44.543]                       invokeRestart <- base::invokeRestart
[17:40:44.543]                       is.null <- base::is.null
[17:40:44.543]                       muffled <- FALSE
[17:40:44.543]                       if (inherits(cond, "message")) {
[17:40:44.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.543]                         if (muffled) 
[17:40:44.543]                           invokeRestart("muffleMessage")
[17:40:44.543]                       }
[17:40:44.543]                       else if (inherits(cond, "warning")) {
[17:40:44.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.543]                         if (muffled) 
[17:40:44.543]                           invokeRestart("muffleWarning")
[17:40:44.543]                       }
[17:40:44.543]                       else if (inherits(cond, "condition")) {
[17:40:44.543]                         if (!is.null(pattern)) {
[17:40:44.543]                           computeRestarts <- base::computeRestarts
[17:40:44.543]                           grepl <- base::grepl
[17:40:44.543]                           restarts <- computeRestarts(cond)
[17:40:44.543]                           for (restart in restarts) {
[17:40:44.543]                             name <- restart$name
[17:40:44.543]                             if (is.null(name)) 
[17:40:44.543]                               next
[17:40:44.543]                             if (!grepl(pattern, name)) 
[17:40:44.543]                               next
[17:40:44.543]                             invokeRestart(restart)
[17:40:44.543]                             muffled <- TRUE
[17:40:44.543]                             break
[17:40:44.543]                           }
[17:40:44.543]                         }
[17:40:44.543]                       }
[17:40:44.543]                       invisible(muffled)
[17:40:44.543]                     }
[17:40:44.543]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.543]                   }
[17:40:44.543]                 }
[17:40:44.543]                 else {
[17:40:44.543]                   if (TRUE) {
[17:40:44.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.543]                     {
[17:40:44.543]                       inherits <- base::inherits
[17:40:44.543]                       invokeRestart <- base::invokeRestart
[17:40:44.543]                       is.null <- base::is.null
[17:40:44.543]                       muffled <- FALSE
[17:40:44.543]                       if (inherits(cond, "message")) {
[17:40:44.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.543]                         if (muffled) 
[17:40:44.543]                           invokeRestart("muffleMessage")
[17:40:44.543]                       }
[17:40:44.543]                       else if (inherits(cond, "warning")) {
[17:40:44.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.543]                         if (muffled) 
[17:40:44.543]                           invokeRestart("muffleWarning")
[17:40:44.543]                       }
[17:40:44.543]                       else if (inherits(cond, "condition")) {
[17:40:44.543]                         if (!is.null(pattern)) {
[17:40:44.543]                           computeRestarts <- base::computeRestarts
[17:40:44.543]                           grepl <- base::grepl
[17:40:44.543]                           restarts <- computeRestarts(cond)
[17:40:44.543]                           for (restart in restarts) {
[17:40:44.543]                             name <- restart$name
[17:40:44.543]                             if (is.null(name)) 
[17:40:44.543]                               next
[17:40:44.543]                             if (!grepl(pattern, name)) 
[17:40:44.543]                               next
[17:40:44.543]                             invokeRestart(restart)
[17:40:44.543]                             muffled <- TRUE
[17:40:44.543]                             break
[17:40:44.543]                           }
[17:40:44.543]                         }
[17:40:44.543]                       }
[17:40:44.543]                       invisible(muffled)
[17:40:44.543]                     }
[17:40:44.543]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.543]                   }
[17:40:44.543]                 }
[17:40:44.543]             }
[17:40:44.543]         }))
[17:40:44.543]     }, error = function(ex) {
[17:40:44.543]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.543]                 ...future.rng), started = ...future.startTime, 
[17:40:44.543]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.543]             version = "1.8"), class = "FutureResult")
[17:40:44.543]     }, finally = {
[17:40:44.543]         if (!identical(...future.workdir, getwd())) 
[17:40:44.543]             setwd(...future.workdir)
[17:40:44.543]         {
[17:40:44.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.543]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.543]             }
[17:40:44.543]             base::options(...future.oldOptions)
[17:40:44.543]             if (.Platform$OS.type == "windows") {
[17:40:44.543]                 old_names <- names(...future.oldEnvVars)
[17:40:44.543]                 envs <- base::Sys.getenv()
[17:40:44.543]                 names <- names(envs)
[17:40:44.543]                 common <- intersect(names, old_names)
[17:40:44.543]                 added <- setdiff(names, old_names)
[17:40:44.543]                 removed <- setdiff(old_names, names)
[17:40:44.543]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.543]                   envs[common]]
[17:40:44.543]                 NAMES <- toupper(changed)
[17:40:44.543]                 args <- list()
[17:40:44.543]                 for (kk in seq_along(NAMES)) {
[17:40:44.543]                   name <- changed[[kk]]
[17:40:44.543]                   NAME <- NAMES[[kk]]
[17:40:44.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.543]                     next
[17:40:44.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.543]                 }
[17:40:44.543]                 NAMES <- toupper(added)
[17:40:44.543]                 for (kk in seq_along(NAMES)) {
[17:40:44.543]                   name <- added[[kk]]
[17:40:44.543]                   NAME <- NAMES[[kk]]
[17:40:44.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.543]                     next
[17:40:44.543]                   args[[name]] <- ""
[17:40:44.543]                 }
[17:40:44.543]                 NAMES <- toupper(removed)
[17:40:44.543]                 for (kk in seq_along(NAMES)) {
[17:40:44.543]                   name <- removed[[kk]]
[17:40:44.543]                   NAME <- NAMES[[kk]]
[17:40:44.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.543]                     next
[17:40:44.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.543]                 }
[17:40:44.543]                 if (length(args) > 0) 
[17:40:44.543]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.543]             }
[17:40:44.543]             else {
[17:40:44.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.543]             }
[17:40:44.543]             {
[17:40:44.543]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.543]                   0L) {
[17:40:44.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.543]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.543]                   base::options(opts)
[17:40:44.543]                 }
[17:40:44.543]                 {
[17:40:44.543]                   {
[17:40:44.543]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.543]                     NULL
[17:40:44.543]                   }
[17:40:44.543]                   options(future.plan = NULL)
[17:40:44.543]                   if (is.na(NA_character_)) 
[17:40:44.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.543]                     .init = FALSE)
[17:40:44.543]                 }
[17:40:44.543]             }
[17:40:44.543]         }
[17:40:44.543]     })
[17:40:44.543]     if (TRUE) {
[17:40:44.543]         base::sink(type = "output", split = FALSE)
[17:40:44.543]         if (TRUE) {
[17:40:44.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.543]         }
[17:40:44.543]         else {
[17:40:44.543]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.543]         }
[17:40:44.543]         base::close(...future.stdout)
[17:40:44.543]         ...future.stdout <- NULL
[17:40:44.543]     }
[17:40:44.543]     ...future.result$conditions <- ...future.conditions
[17:40:44.543]     ...future.result$finished <- base::Sys.time()
[17:40:44.543]     ...future.result
[17:40:44.543] }
[17:40:44.546] requestCore(): workers = 2
[17:40:44.546] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.557] result() for MulticoreFuture ...
[17:40:44.558] result() for MulticoreFuture ...
[17:40:44.558] result() for MulticoreFuture ... done
[17:40:44.558] result() for MulticoreFuture ... done
[17:40:44.559] result() for MulticoreFuture ...
[17:40:44.559] result() for MulticoreFuture ... done
[17:40:44.562] MulticoreFuture started
[17:40:44.562] - Launch lazy future ... done
[17:40:44.562] run() for ‘MulticoreFuture’ ... done
[17:40:44.563] plan(): Setting new future strategy stack:
[17:40:44.564] getGlobalsAndPackages() ...
[17:40:44.563] List of future strategies:
[17:40:44.563] 1. sequential:
[17:40:44.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.563]    - tweaked: FALSE
[17:40:44.563]    - call: NULL
[17:40:44.564] Searching for globals...
[17:40:44.564] plan(): nbrOfWorkers() = 1
[17:40:44.566] - globals found: [1] ‘{’
[17:40:44.566] Searching for globals ... DONE
[17:40:44.566] Resolving globals: FALSE
[17:40:44.567] 
[17:40:44.567] 
[17:40:44.567] getGlobalsAndPackages() ... DONE
[17:40:44.568] run() for ‘Future’ ...
[17:40:44.568] - state: ‘created’
[17:40:44.568] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:40:44.573] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:44.573] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:40:44.574]   - Field: ‘label’
[17:40:44.574]   - Field: ‘local’
[17:40:44.574]   - Field: ‘owner’
[17:40:44.574]   - Field: ‘envir’
[17:40:44.574]   - Field: ‘workers’
[17:40:44.574]   - Field: ‘packages’
[17:40:44.575]   - Field: ‘gc’
[17:40:44.575]   - Field: ‘job’
[17:40:44.575]   - Field: ‘conditions’
[17:40:44.575]   - Field: ‘expr’
[17:40:44.575]   - Field: ‘uuid’
[17:40:44.575]   - Field: ‘seed’
[17:40:44.575]   - Field: ‘version’
[17:40:44.576]   - Field: ‘result’
[17:40:44.576]   - Field: ‘asynchronous’
[17:40:44.576]   - Field: ‘calls’
[17:40:44.576]   - Field: ‘globals’
[17:40:44.576]   - Field: ‘stdout’
[17:40:44.576]   - Field: ‘earlySignal’
[17:40:44.577]   - Field: ‘lazy’
[17:40:44.577]   - Field: ‘state’
[17:40:44.577] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:40:44.577] - Launch lazy future ...
[17:40:44.578] Packages needed by the future expression (n = 0): <none>
[17:40:44.578] Packages needed by future strategies (n = 0): <none>
[17:40:44.578] {
[17:40:44.578]     {
[17:40:44.578]         {
[17:40:44.578]             ...future.startTime <- base::Sys.time()
[17:40:44.578]             {
[17:40:44.578]                 {
[17:40:44.578]                   {
[17:40:44.578]                     {
[17:40:44.578]                       base::local({
[17:40:44.578]                         has_future <- base::requireNamespace("future", 
[17:40:44.578]                           quietly = TRUE)
[17:40:44.578]                         if (has_future) {
[17:40:44.578]                           ns <- base::getNamespace("future")
[17:40:44.578]                           version <- ns[[".package"]][["version"]]
[17:40:44.578]                           if (is.null(version)) 
[17:40:44.578]                             version <- utils::packageVersion("future")
[17:40:44.578]                         }
[17:40:44.578]                         else {
[17:40:44.578]                           version <- NULL
[17:40:44.578]                         }
[17:40:44.578]                         if (!has_future || version < "1.8.0") {
[17:40:44.578]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:44.578]                             "", base::R.version$version.string), 
[17:40:44.578]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:44.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:44.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:44.578]                               "release", "version")], collapse = " "), 
[17:40:44.578]                             hostname = base::Sys.info()[["nodename"]])
[17:40:44.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:44.578]                             info)
[17:40:44.578]                           info <- base::paste(info, collapse = "; ")
[17:40:44.578]                           if (!has_future) {
[17:40:44.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:44.578]                               info)
[17:40:44.578]                           }
[17:40:44.578]                           else {
[17:40:44.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:44.578]                               info, version)
[17:40:44.578]                           }
[17:40:44.578]                           base::stop(msg)
[17:40:44.578]                         }
[17:40:44.578]                       })
[17:40:44.578]                     }
[17:40:44.578]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:44.578]                     base::options(mc.cores = 1L)
[17:40:44.578]                   }
[17:40:44.578]                   ...future.strategy.old <- future::plan("list")
[17:40:44.578]                   options(future.plan = NULL)
[17:40:44.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:44.578]                 }
[17:40:44.578]                 ...future.workdir <- getwd()
[17:40:44.578]             }
[17:40:44.578]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:44.578]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:44.578]         }
[17:40:44.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:44.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:44.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:44.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:44.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:44.578]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:44.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:44.578]             base::names(...future.oldOptions))
[17:40:44.578]     }
[17:40:44.578]     if (FALSE) {
[17:40:44.578]     }
[17:40:44.578]     else {
[17:40:44.578]         if (TRUE) {
[17:40:44.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:44.578]                 open = "w")
[17:40:44.578]         }
[17:40:44.578]         else {
[17:40:44.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:44.578]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:44.578]         }
[17:40:44.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:44.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:44.578]             base::sink(type = "output", split = FALSE)
[17:40:44.578]             base::close(...future.stdout)
[17:40:44.578]         }, add = TRUE)
[17:40:44.578]     }
[17:40:44.578]     ...future.frame <- base::sys.nframe()
[17:40:44.578]     ...future.conditions <- base::list()
[17:40:44.578]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:44.578]     if (FALSE) {
[17:40:44.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:44.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:44.578]     }
[17:40:44.578]     ...future.result <- base::tryCatch({
[17:40:44.578]         base::withCallingHandlers({
[17:40:44.578]             ...future.value <- base::withVisible(base::local({
[17:40:44.578]                 withCallingHandlers({
[17:40:44.578]                   {
[17:40:44.578]                     3
[17:40:44.578]                   }
[17:40:44.578]                 }, immediateCondition = function(cond) {
[17:40:44.578]                   save_rds <- function (object, pathname, ...) 
[17:40:44.578]                   {
[17:40:44.578]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:40:44.578]                     if (file_test("-f", pathname_tmp)) {
[17:40:44.578]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.578]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:40:44.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.578]                         fi_tmp[["mtime"]])
[17:40:44.578]                     }
[17:40:44.578]                     tryCatch({
[17:40:44.578]                       saveRDS(object, file = pathname_tmp, ...)
[17:40:44.578]                     }, error = function(ex) {
[17:40:44.578]                       msg <- conditionMessage(ex)
[17:40:44.578]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.578]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:40:44.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.578]                         fi_tmp[["mtime"]], msg)
[17:40:44.578]                       ex$message <- msg
[17:40:44.578]                       stop(ex)
[17:40:44.578]                     })
[17:40:44.578]                     stopifnot(file_test("-f", pathname_tmp))
[17:40:44.578]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:40:44.578]                     if (!res || file_test("-f", pathname_tmp)) {
[17:40:44.578]                       fi_tmp <- file.info(pathname_tmp)
[17:40:44.578]                       fi <- file.info(pathname)
[17:40:44.578]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:40:44.578]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:40:44.578]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:40:44.578]                         fi[["size"]], fi[["mtime"]])
[17:40:44.578]                       stop(msg)
[17:40:44.578]                     }
[17:40:44.578]                     invisible(pathname)
[17:40:44.578]                   }
[17:40:44.578]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:40:44.578]                     rootPath = tempdir()) 
[17:40:44.578]                   {
[17:40:44.578]                     obj <- list(time = Sys.time(), condition = cond)
[17:40:44.578]                     file <- tempfile(pattern = class(cond)[1], 
[17:40:44.578]                       tmpdir = path, fileext = ".rds")
[17:40:44.578]                     save_rds(obj, file)
[17:40:44.578]                   }
[17:40:44.578]                   saveImmediateCondition(cond, path = "/tmp/Rtmpg1n3o0/.future/immediateConditions")
[17:40:44.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.578]                   {
[17:40:44.578]                     inherits <- base::inherits
[17:40:44.578]                     invokeRestart <- base::invokeRestart
[17:40:44.578]                     is.null <- base::is.null
[17:40:44.578]                     muffled <- FALSE
[17:40:44.578]                     if (inherits(cond, "message")) {
[17:40:44.578]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:44.578]                       if (muffled) 
[17:40:44.578]                         invokeRestart("muffleMessage")
[17:40:44.578]                     }
[17:40:44.578]                     else if (inherits(cond, "warning")) {
[17:40:44.578]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:44.578]                       if (muffled) 
[17:40:44.578]                         invokeRestart("muffleWarning")
[17:40:44.578]                     }
[17:40:44.578]                     else if (inherits(cond, "condition")) {
[17:40:44.578]                       if (!is.null(pattern)) {
[17:40:44.578]                         computeRestarts <- base::computeRestarts
[17:40:44.578]                         grepl <- base::grepl
[17:40:44.578]                         restarts <- computeRestarts(cond)
[17:40:44.578]                         for (restart in restarts) {
[17:40:44.578]                           name <- restart$name
[17:40:44.578]                           if (is.null(name)) 
[17:40:44.578]                             next
[17:40:44.578]                           if (!grepl(pattern, name)) 
[17:40:44.578]                             next
[17:40:44.578]                           invokeRestart(restart)
[17:40:44.578]                           muffled <- TRUE
[17:40:44.578]                           break
[17:40:44.578]                         }
[17:40:44.578]                       }
[17:40:44.578]                     }
[17:40:44.578]                     invisible(muffled)
[17:40:44.578]                   }
[17:40:44.578]                   muffleCondition(cond)
[17:40:44.578]                 })
[17:40:44.578]             }))
[17:40:44.578]             future::FutureResult(value = ...future.value$value, 
[17:40:44.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.578]                   ...future.rng), globalenv = if (FALSE) 
[17:40:44.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:44.578]                     ...future.globalenv.names))
[17:40:44.578]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:44.578]         }, condition = base::local({
[17:40:44.578]             c <- base::c
[17:40:44.578]             inherits <- base::inherits
[17:40:44.578]             invokeRestart <- base::invokeRestart
[17:40:44.578]             length <- base::length
[17:40:44.578]             list <- base::list
[17:40:44.578]             seq.int <- base::seq.int
[17:40:44.578]             signalCondition <- base::signalCondition
[17:40:44.578]             sys.calls <- base::sys.calls
[17:40:44.578]             `[[` <- base::`[[`
[17:40:44.578]             `+` <- base::`+`
[17:40:44.578]             `<<-` <- base::`<<-`
[17:40:44.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:44.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:44.578]                   3L)]
[17:40:44.578]             }
[17:40:44.578]             function(cond) {
[17:40:44.578]                 is_error <- inherits(cond, "error")
[17:40:44.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:44.578]                   NULL)
[17:40:44.578]                 if (is_error) {
[17:40:44.578]                   sessionInformation <- function() {
[17:40:44.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:44.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:44.578]                       search = base::search(), system = base::Sys.info())
[17:40:44.578]                   }
[17:40:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:44.578]                     cond$call), session = sessionInformation(), 
[17:40:44.578]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:44.578]                   signalCondition(cond)
[17:40:44.578]                 }
[17:40:44.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:44.578]                 "immediateCondition"))) {
[17:40:44.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:44.578]                   ...future.conditions[[length(...future.conditions) + 
[17:40:44.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:44.578]                   if (TRUE && !signal) {
[17:40:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.578]                     {
[17:40:44.578]                       inherits <- base::inherits
[17:40:44.578]                       invokeRestart <- base::invokeRestart
[17:40:44.578]                       is.null <- base::is.null
[17:40:44.578]                       muffled <- FALSE
[17:40:44.578]                       if (inherits(cond, "message")) {
[17:40:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.578]                         if (muffled) 
[17:40:44.578]                           invokeRestart("muffleMessage")
[17:40:44.578]                       }
[17:40:44.578]                       else if (inherits(cond, "warning")) {
[17:40:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.578]                         if (muffled) 
[17:40:44.578]                           invokeRestart("muffleWarning")
[17:40:44.578]                       }
[17:40:44.578]                       else if (inherits(cond, "condition")) {
[17:40:44.578]                         if (!is.null(pattern)) {
[17:40:44.578]                           computeRestarts <- base::computeRestarts
[17:40:44.578]                           grepl <- base::grepl
[17:40:44.578]                           restarts <- computeRestarts(cond)
[17:40:44.578]                           for (restart in restarts) {
[17:40:44.578]                             name <- restart$name
[17:40:44.578]                             if (is.null(name)) 
[17:40:44.578]                               next
[17:40:44.578]                             if (!grepl(pattern, name)) 
[17:40:44.578]                               next
[17:40:44.578]                             invokeRestart(restart)
[17:40:44.578]                             muffled <- TRUE
[17:40:44.578]                             break
[17:40:44.578]                           }
[17:40:44.578]                         }
[17:40:44.578]                       }
[17:40:44.578]                       invisible(muffled)
[17:40:44.578]                     }
[17:40:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.578]                   }
[17:40:44.578]                 }
[17:40:44.578]                 else {
[17:40:44.578]                   if (TRUE) {
[17:40:44.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:44.578]                     {
[17:40:44.578]                       inherits <- base::inherits
[17:40:44.578]                       invokeRestart <- base::invokeRestart
[17:40:44.578]                       is.null <- base::is.null
[17:40:44.578]                       muffled <- FALSE
[17:40:44.578]                       if (inherits(cond, "message")) {
[17:40:44.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:44.578]                         if (muffled) 
[17:40:44.578]                           invokeRestart("muffleMessage")
[17:40:44.578]                       }
[17:40:44.578]                       else if (inherits(cond, "warning")) {
[17:40:44.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:44.578]                         if (muffled) 
[17:40:44.578]                           invokeRestart("muffleWarning")
[17:40:44.578]                       }
[17:40:44.578]                       else if (inherits(cond, "condition")) {
[17:40:44.578]                         if (!is.null(pattern)) {
[17:40:44.578]                           computeRestarts <- base::computeRestarts
[17:40:44.578]                           grepl <- base::grepl
[17:40:44.578]                           restarts <- computeRestarts(cond)
[17:40:44.578]                           for (restart in restarts) {
[17:40:44.578]                             name <- restart$name
[17:40:44.578]                             if (is.null(name)) 
[17:40:44.578]                               next
[17:40:44.578]                             if (!grepl(pattern, name)) 
[17:40:44.578]                               next
[17:40:44.578]                             invokeRestart(restart)
[17:40:44.578]                             muffled <- TRUE
[17:40:44.578]                             break
[17:40:44.578]                           }
[17:40:44.578]                         }
[17:40:44.578]                       }
[17:40:44.578]                       invisible(muffled)
[17:40:44.578]                     }
[17:40:44.578]                     muffleCondition(cond, pattern = "^muffle")
[17:40:44.578]                   }
[17:40:44.578]                 }
[17:40:44.578]             }
[17:40:44.578]         }))
[17:40:44.578]     }, error = function(ex) {
[17:40:44.578]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:44.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:44.578]                 ...future.rng), started = ...future.startTime, 
[17:40:44.578]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:44.578]             version = "1.8"), class = "FutureResult")
[17:40:44.578]     }, finally = {
[17:40:44.578]         if (!identical(...future.workdir, getwd())) 
[17:40:44.578]             setwd(...future.workdir)
[17:40:44.578]         {
[17:40:44.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:44.578]                 ...future.oldOptions$nwarnings <- NULL
[17:40:44.578]             }
[17:40:44.578]             base::options(...future.oldOptions)
[17:40:44.578]             if (.Platform$OS.type == "windows") {
[17:40:44.578]                 old_names <- names(...future.oldEnvVars)
[17:40:44.578]                 envs <- base::Sys.getenv()
[17:40:44.578]                 names <- names(envs)
[17:40:44.578]                 common <- intersect(names, old_names)
[17:40:44.578]                 added <- setdiff(names, old_names)
[17:40:44.578]                 removed <- setdiff(old_names, names)
[17:40:44.578]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:44.578]                   envs[common]]
[17:40:44.578]                 NAMES <- toupper(changed)
[17:40:44.578]                 args <- list()
[17:40:44.578]                 for (kk in seq_along(NAMES)) {
[17:40:44.578]                   name <- changed[[kk]]
[17:40:44.578]                   NAME <- NAMES[[kk]]
[17:40:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.578]                     next
[17:40:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.578]                 }
[17:40:44.578]                 NAMES <- toupper(added)
[17:40:44.578]                 for (kk in seq_along(NAMES)) {
[17:40:44.578]                   name <- added[[kk]]
[17:40:44.578]                   NAME <- NAMES[[kk]]
[17:40:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.578]                     next
[17:40:44.578]                   args[[name]] <- ""
[17:40:44.578]                 }
[17:40:44.578]                 NAMES <- toupper(removed)
[17:40:44.578]                 for (kk in seq_along(NAMES)) {
[17:40:44.578]                   name <- removed[[kk]]
[17:40:44.578]                   NAME <- NAMES[[kk]]
[17:40:44.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:44.578]                     next
[17:40:44.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:44.578]                 }
[17:40:44.578]                 if (length(args) > 0) 
[17:40:44.578]                   base::do.call(base::Sys.setenv, args = args)
[17:40:44.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:44.578]             }
[17:40:44.578]             else {
[17:40:44.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:44.578]             }
[17:40:44.578]             {
[17:40:44.578]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:44.578]                   0L) {
[17:40:44.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:44.578]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:44.578]                   base::options(opts)
[17:40:44.578]                 }
[17:40:44.578]                 {
[17:40:44.578]                   {
[17:40:44.578]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:44.578]                     NULL
[17:40:44.578]                   }
[17:40:44.578]                   options(future.plan = NULL)
[17:40:44.578]                   if (is.na(NA_character_)) 
[17:40:44.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:44.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:44.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:44.578]                     .init = FALSE)
[17:40:44.578]                 }
[17:40:44.578]             }
[17:40:44.578]         }
[17:40:44.578]     })
[17:40:44.578]     if (TRUE) {
[17:40:44.578]         base::sink(type = "output", split = FALSE)
[17:40:44.578]         if (TRUE) {
[17:40:44.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:44.578]         }
[17:40:44.578]         else {
[17:40:44.578]             ...future.result["stdout"] <- base::list(NULL)
[17:40:44.578]         }
[17:40:44.578]         base::close(...future.stdout)
[17:40:44.578]         ...future.stdout <- NULL
[17:40:44.578]     }
[17:40:44.578]     ...future.result$conditions <- ...future.conditions
[17:40:44.578]     ...future.result$finished <- base::Sys.time()
[17:40:44.578]     ...future.result
[17:40:44.578] }
[17:40:44.582] requestCore(): workers = 2
[17:40:44.582] Poll #1 (0): usedCores() = 2, workers = 2
[17:40:44.593] result() for MulticoreFuture ...
[17:40:44.594] result() for MulticoreFuture ...
[17:40:44.594] result() for MulticoreFuture ... done
[17:40:44.594] result() for MulticoreFuture ... done
[17:40:44.594] result() for MulticoreFuture ...
[17:40:44.594] result() for MulticoreFuture ... done
[17:40:44.596] MulticoreFuture started
[17:40:44.597] - Launch lazy future ... done
[17:40:44.597] run() for ‘MulticoreFuture’ ... done
[17:40:44.598] plan(): Setting new future strategy stack:
[17:40:44.598] List of future strategies:
[17:40:44.598] 1. sequential:
[17:40:44.598]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:40:44.598]    - tweaked: FALSE
[17:40:44.598]    - call: NULL
[17:40:44.599] resolve() on list environment ...
[17:40:44.600]  recursive: 0
[17:40:44.600] plan(): nbrOfWorkers() = 1
[17:40:44.601]  length: 4
[17:40:44.601]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:44.602] Future #1
[17:40:44.602]  length: 3 (resolved future 1)
[17:40:44.602] plan(): Setting new future strategy stack:
[17:40:44.603] List of future strategies:
[17:40:44.603] 1. multicore:
[17:40:44.603]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:44.603]    - tweaked: FALSE
[17:40:44.603]    - call: plan(strategy)
[17:40:44.608] plan(): nbrOfWorkers() = 2
[17:40:44.613] Future #3
[17:40:44.613]  length: 2 (resolved future 3)
[17:40:44.613]  length: 1 (resolved future 4)
[17:40:45.067] plan(): Setting new future strategy stack:
[17:40:45.067] List of future strategies:
[17:40:45.067] 1. multicore:
[17:40:45.067]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:40:45.067]    - tweaked: FALSE
[17:40:45.067]    - call: plan(strategy)
[17:40:45.072] plan(): nbrOfWorkers() = 2
[17:40:45.073] Future #2
[17:40:45.073]  length: 0 (resolved future 2)
[17:40:45.073] resolve() on list environment ... DONE
[17:40:45.074] resolve() on list environment ...
[17:40:45.074]  recursive: 0
[17:40:45.075]  length: 4
[17:40:45.075]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:45.076] Future #1
[17:40:45.076]  length: 3 (resolved future 1)
[17:40:45.076] Future #2
[17:40:45.076]  length: 2 (resolved future 2)
[17:40:45.077] Future #3
[17:40:45.077]  length: 1 (resolved future 3)
[17:40:45.077]  length: 0 (resolved future 4)
[17:40:45.077] resolve() on list environment ... DONE
[17:40:45.078] resolve() on list environment ...
[17:40:45.078]  recursive: 0
[17:40:45.079]  length: 4
[17:40:45.079]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:45.079] Future #1
[17:40:45.079]  length: 3 (resolved future 1)
[17:40:45.080] Future #2
[17:40:45.080]  length: 2 (resolved future 2)
[17:40:45.080] Future #3
[17:40:45.080]  length: 1 (resolved future 3)
[17:40:45.081]  length: 0 (resolved future 4)
[17:40:45.081] resolve() on list environment ... DONE
[17:40:45.081] resolve() on list environment ...
[17:40:45.082]  recursive: 0
[17:40:45.083]  length: 4
[17:40:45.083]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:45.083] Future #1
[17:40:45.087]  length: 3 (resolved future 1)
[17:40:45.088] Future #2
[17:40:45.088]  length: 2 (resolved future 2)
[17:40:45.089] Future #3
[17:40:45.089]  length: 1 (resolved future 3)
[17:40:45.089]  length: 0 (resolved future 4)
[17:40:45.090] resolve() on list environment ... DONE
[17:40:45.091] resolve() on list environment ...
[17:40:45.091]  recursive: 0
[17:40:45.092]  length: 4
[17:40:45.092]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:45.093] Future #1
[17:40:45.093] result() for MulticoreFuture ...
[17:40:45.093] result() for MulticoreFuture ... done
[17:40:45.093] result() for MulticoreFuture ...
[17:40:45.093] result() for MulticoreFuture ... done
[17:40:45.094]  length: 3 (resolved future 1)
[17:40:45.094] Future #2
[17:40:45.094] result() for MulticoreFuture ...
[17:40:45.095] result() for MulticoreFuture ...
[17:40:45.095] result() for MulticoreFuture ... done
[17:40:45.095] result() for MulticoreFuture ... done
[17:40:45.095] result() for MulticoreFuture ...
[17:40:45.095] result() for MulticoreFuture ... done
[17:40:45.096]  length: 2 (resolved future 2)
[17:40:45.096] Future #3
[17:40:45.096] result() for MulticoreFuture ...
[17:40:45.097] result() for MulticoreFuture ...
[17:40:45.097] result() for MulticoreFuture ... done
[17:40:45.097] result() for MulticoreFuture ... done
[17:40:45.097] result() for MulticoreFuture ...
[17:40:45.097] result() for MulticoreFuture ... done
[17:40:45.098]  length: 1 (resolved future 3)
[17:40:45.098]  length: 0 (resolved future 4)
[17:40:45.098] resolve() on list environment ... DONE
[17:40:45.098] resolve() on list environment ...
[17:40:45.099]  recursive: 99
[17:40:45.099]  length: 4
[17:40:45.099]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:40:45.099] Future #1
[17:40:45.100] result() for MulticoreFuture ...
[17:40:45.100] result() for MulticoreFuture ... done
[17:40:45.100] result() for MulticoreFuture ...
[17:40:45.100] result() for MulticoreFuture ... done
[17:40:45.100] A MulticoreFuture was resolved
[17:40:45.100]  length: 3 (resolved future 1)
[17:40:45.100] Future #2
[17:40:45.100] result() for MulticoreFuture ...
[17:40:45.101] result() for MulticoreFuture ... done
[17:40:45.101] result() for MulticoreFuture ...
[17:40:45.101] result() for MulticoreFuture ... done
[17:40:45.101] A MulticoreFuture was resolved
[17:40:45.101]  length: 2 (resolved future 2)
[17:40:45.101] Future #3
[17:40:45.101] result() for MulticoreFuture ...
[17:40:45.101] result() for MulticoreFuture ... done
[17:40:45.101] result() for MulticoreFuture ...
[17:40:45.102] result() for MulticoreFuture ... done
[17:40:45.102] A MulticoreFuture was resolved
[17:40:45.102]  length: 1 (resolved future 3)
[17:40:45.102]  length: 0 (resolved future 4)
[17:40:45.102] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[17:40:45.103] plan(): Setting new future strategy stack:
[17:40:45.103] List of future strategies:
[17:40:45.103] 1. multisession:
[17:40:45.103]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:45.103]    - tweaked: FALSE
[17:40:45.103]    - call: plan(strategy)
[17:40:45.103] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:40:45.103] multisession:
[17:40:45.103] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:40:45.103] - tweaked: FALSE
[17:40:45.103] - call: plan(strategy)
[17:40:45.110] getGlobalsAndPackages() ...
[17:40:45.110] Not searching for globals
[17:40:45.110] - globals: [0] <none>
[17:40:45.110] getGlobalsAndPackages() ... DONE
[17:40:45.111] [local output] makeClusterPSOCK() ...
[17:40:45.151] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:40:45.152] [local output] Base port: 11832
[17:40:45.152] [local output] Getting setup options for 2 cluster nodes ...
[17:40:45.152] [local output]  - Node 1 of 2 ...
[17:40:45.153] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:45.153] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpg1n3o0/worker.rank=1.parallelly.parent=48734.be5e14aad051.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpg1n3o0/worker.rank=1.parallelly.parent=48734.be5e14aad051.pid")'’
[17:40:45.340] - Possible to infer worker's PID: TRUE
[17:40:45.340] [local output] Rscript port: 11832

[17:40:45.341] [local output]  - Node 2 of 2 ...
[17:40:45.341] [local output] localMachine=TRUE => revtunnel=FALSE

[17:40:45.342] [local output] Rscript port: 11832

[17:40:45.342] [local output] Getting setup options for 2 cluster nodes ... done
[17:40:45.342] [local output]  - Parallel setup requested for some PSOCK nodes
[17:40:45.342] [local output] Setting up PSOCK nodes in parallel
[17:40:45.343] List of 36
[17:40:45.343]  $ worker          : chr "localhost"
[17:40:45.343]   ..- attr(*, "localhost")= logi TRUE
[17:40:45.343]  $ master          : chr "localhost"
[17:40:45.343]  $ port            : int 11832
[17:40:45.343]  $ connectTimeout  : num 120
[17:40:45.343]  $ timeout         : num 2592000
[17:40:45.343]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:40:45.343]  $ homogeneous     : logi TRUE
[17:40:45.343]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:40:45.343]  $ rscript_envs    : NULL
[17:40:45.343]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:45.343]  $ rscript_startup : NULL
[17:40:45.343]  $ rscript_sh      : chr "sh"
[17:40:45.343]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:45.343]  $ methods         : logi TRUE
[17:40:45.343]  $ socketOptions   : chr "no-delay"
[17:40:45.343]  $ useXDR          : logi FALSE
[17:40:45.343]  $ outfile         : chr "/dev/null"
[17:40:45.343]  $ renice          : int NA
[17:40:45.343]  $ rshcmd          : NULL
[17:40:45.343]  $ user            : chr(0) 
[17:40:45.343]  $ revtunnel       : logi FALSE
[17:40:45.343]  $ rshlogfile      : NULL
[17:40:45.343]  $ rshopts         : chr(0) 
[17:40:45.343]  $ rank            : int 1
[17:40:45.343]  $ manual          : logi FALSE
[17:40:45.343]  $ dryrun          : logi FALSE
[17:40:45.343]  $ quiet           : logi FALSE
[17:40:45.343]  $ setup_strategy  : chr "parallel"
[17:40:45.343]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:45.343]  $ pidfile         : chr "/tmp/Rtmpg1n3o0/worker.rank=1.parallelly.parent=48734.be5e14aad051.pid"
[17:40:45.343]  $ rshcmd_label    : NULL
[17:40:45.343]  $ rsh_call        : NULL
[17:40:45.343]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:40:45.343]  $ localMachine    : logi TRUE
[17:40:45.343]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:40:45.343]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:40:45.343]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:40:45.343]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:40:45.343]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:40:45.343]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:40:45.343]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:40:45.343]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:40:45.343]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:40:45.343]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:40:45.343]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:40:45.343]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:40:45.343]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:40:45.343]  $ arguments       :List of 28
[17:40:45.343]   ..$ worker          : chr "localhost"
[17:40:45.343]   ..$ master          : NULL
[17:40:45.343]   ..$ port            : int 11832
[17:40:45.343]   ..$ connectTimeout  : num 120
[17:40:45.343]   ..$ timeout         : num 2592000
[17:40:45.343]   ..$ rscript         : NULL
[17:40:45.343]   ..$ homogeneous     : NULL
[17:40:45.343]   ..$ rscript_args    : NULL
[17:40:45.343]   ..$ rscript_envs    : NULL
[17:40:45.343]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:40:45.343]   ..$ rscript_startup : NULL
[17:40:45.343]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:40:45.343]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:40:45.343]   ..$ methods         : logi TRUE
[17:40:45.343]   ..$ socketOptions   : chr "no-delay"
[17:40:45.343]   ..$ useXDR          : logi FALSE
[17:40:45.343]   ..$ outfile         : chr "/dev/null"
[17:40:45.343]   ..$ renice          : int NA
[17:40:45.343]   ..$ rshcmd          : NULL
[17:40:45.343]   ..$ user            : NULL
[17:40:45.343]   ..$ revtunnel       : logi NA
[17:40:45.343]   ..$ rshlogfile      : NULL
[17:40:45.343]   ..$ rshopts         : NULL
[17:40:45.343]   ..$ rank            : int 1
[17:40:45.343]   ..$ manual          : logi FALSE
[17:40:45.343]   ..$ dryrun          : logi FALSE
[17:40:45.343]   ..$ quiet           : logi FALSE
[17:40:45.343]   ..$ setup_strategy  : chr "parallel"
[17:40:45.343]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:40:45.359] [local output] System call to launch all workers:
[17:40:45.359] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpg1n3o0/worker.rank=1.parallelly.parent=48734.be5e14aad051.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11832 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:40:45.359] [local output] Starting PSOCK main server
[17:40:45.364] [local output] Workers launched
[17:40:45.365] [local output] Waiting for workers to connect back
[17:40:45.365]  - [local output] 0 workers out of 2 ready
[17:40:45.605]  - [local output] 0 workers out of 2 ready
[17:40:45.606]  - [local output] 1 workers out of 2 ready
[17:40:45.606]  - [local output] 2 workers out of 2 ready
[17:40:45.606] [local output] Launching of workers completed
[17:40:45.606] [local output] Collecting session information from workers
[17:40:45.607] [local output]  - Worker #1 of 2
[17:40:45.607] [local output]  - Worker #2 of 2
[17:40:45.608] [local output] makeClusterPSOCK() ... done
[17:40:45.619] Packages needed by the future expression (n = 0): <none>
[17:40:45.619] Packages needed by future strategies (n = 0): <none>
[17:40:45.619] {
[17:40:45.619]     {
[17:40:45.619]         {
[17:40:45.619]             ...future.startTime <- base::Sys.time()
[17:40:45.619]             {
[17:40:45.619]                 {
[17:40:45.619]                   {
[17:40:45.619]                     {
[17:40:45.619]                       base::local({
[17:40:45.619]                         has_future <- base::requireNamespace("future", 
[17:40:45.619]                           quietly = TRUE)
[17:40:45.619]                         if (has_future) {
[17:40:45.619]                           ns <- base::getNamespace("future")
[17:40:45.619]                           version <- ns[[".package"]][["version"]]
[17:40:45.619]                           if (is.null(version)) 
[17:40:45.619]                             version <- utils::packageVersion("future")
[17:40:45.619]                         }
[17:40:45.619]                         else {
[17:40:45.619]                           version <- NULL
[17:40:45.619]                         }
[17:40:45.619]                         if (!has_future || version < "1.8.0") {
[17:40:45.619]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:45.619]                             "", base::R.version$version.string), 
[17:40:45.619]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:45.619]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:45.619]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:45.619]                               "release", "version")], collapse = " "), 
[17:40:45.619]                             hostname = base::Sys.info()[["nodename"]])
[17:40:45.619]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:45.619]                             info)
[17:40:45.619]                           info <- base::paste(info, collapse = "; ")
[17:40:45.619]                           if (!has_future) {
[17:40:45.619]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:45.619]                               info)
[17:40:45.619]                           }
[17:40:45.619]                           else {
[17:40:45.619]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:45.619]                               info, version)
[17:40:45.619]                           }
[17:40:45.619]                           base::stop(msg)
[17:40:45.619]                         }
[17:40:45.619]                       })
[17:40:45.619]                     }
[17:40:45.619]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:45.619]                     base::options(mc.cores = 1L)
[17:40:45.619]                   }
[17:40:45.619]                   ...future.strategy.old <- future::plan("list")
[17:40:45.619]                   options(future.plan = NULL)
[17:40:45.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:45.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:45.619]                 }
[17:40:45.619]                 ...future.workdir <- getwd()
[17:40:45.619]             }
[17:40:45.619]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:45.619]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:45.619]         }
[17:40:45.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:45.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:45.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:45.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:45.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:45.619]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:45.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:45.619]             base::names(...future.oldOptions))
[17:40:45.619]     }
[17:40:45.619]     if (FALSE) {
[17:40:45.619]     }
[17:40:45.619]     else {
[17:40:45.619]         if (TRUE) {
[17:40:45.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:45.619]                 open = "w")
[17:40:45.619]         }
[17:40:45.619]         else {
[17:40:45.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:45.619]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:45.619]         }
[17:40:45.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:45.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:45.619]             base::sink(type = "output", split = FALSE)
[17:40:45.619]             base::close(...future.stdout)
[17:40:45.619]         }, add = TRUE)
[17:40:45.619]     }
[17:40:45.619]     ...future.frame <- base::sys.nframe()
[17:40:45.619]     ...future.conditions <- base::list()
[17:40:45.619]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:45.619]     if (FALSE) {
[17:40:45.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:45.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:45.619]     }
[17:40:45.619]     ...future.result <- base::tryCatch({
[17:40:45.619]         base::withCallingHandlers({
[17:40:45.619]             ...future.value <- base::withVisible(base::local({
[17:40:45.619]                 ...future.makeSendCondition <- base::local({
[17:40:45.619]                   sendCondition <- NULL
[17:40:45.619]                   function(frame = 1L) {
[17:40:45.619]                     if (is.function(sendCondition)) 
[17:40:45.619]                       return(sendCondition)
[17:40:45.619]                     ns <- getNamespace("parallel")
[17:40:45.619]                     if (exists("sendData", mode = "function", 
[17:40:45.619]                       envir = ns)) {
[17:40:45.619]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:45.619]                         envir = ns)
[17:40:45.619]                       envir <- sys.frame(frame)
[17:40:45.619]                       master <- NULL
[17:40:45.619]                       while (!identical(envir, .GlobalEnv) && 
[17:40:45.619]                         !identical(envir, emptyenv())) {
[17:40:45.619]                         if (exists("master", mode = "list", envir = envir, 
[17:40:45.619]                           inherits = FALSE)) {
[17:40:45.619]                           master <- get("master", mode = "list", 
[17:40:45.619]                             envir = envir, inherits = FALSE)
[17:40:45.619]                           if (inherits(master, c("SOCKnode", 
[17:40:45.619]                             "SOCK0node"))) {
[17:40:45.619]                             sendCondition <<- function(cond) {
[17:40:45.619]                               data <- list(type = "VALUE", value = cond, 
[17:40:45.619]                                 success = TRUE)
[17:40:45.619]                               parallel_sendData(master, data)
[17:40:45.619]                             }
[17:40:45.619]                             return(sendCondition)
[17:40:45.619]                           }
[17:40:45.619]                         }
[17:40:45.619]                         frame <- frame + 1L
[17:40:45.619]                         envir <- sys.frame(frame)
[17:40:45.619]                       }
[17:40:45.619]                     }
[17:40:45.619]                     sendCondition <<- function(cond) NULL
[17:40:45.619]                   }
[17:40:45.619]                 })
[17:40:45.619]                 withCallingHandlers({
[17:40:45.619]                   NA
[17:40:45.619]                 }, immediateCondition = function(cond) {
[17:40:45.619]                   sendCondition <- ...future.makeSendCondition()
[17:40:45.619]                   sendCondition(cond)
[17:40:45.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.619]                   {
[17:40:45.619]                     inherits <- base::inherits
[17:40:45.619]                     invokeRestart <- base::invokeRestart
[17:40:45.619]                     is.null <- base::is.null
[17:40:45.619]                     muffled <- FALSE
[17:40:45.619]                     if (inherits(cond, "message")) {
[17:40:45.619]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:45.619]                       if (muffled) 
[17:40:45.619]                         invokeRestart("muffleMessage")
[17:40:45.619]                     }
[17:40:45.619]                     else if (inherits(cond, "warning")) {
[17:40:45.619]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:45.619]                       if (muffled) 
[17:40:45.619]                         invokeRestart("muffleWarning")
[17:40:45.619]                     }
[17:40:45.619]                     else if (inherits(cond, "condition")) {
[17:40:45.619]                       if (!is.null(pattern)) {
[17:40:45.619]                         computeRestarts <- base::computeRestarts
[17:40:45.619]                         grepl <- base::grepl
[17:40:45.619]                         restarts <- computeRestarts(cond)
[17:40:45.619]                         for (restart in restarts) {
[17:40:45.619]                           name <- restart$name
[17:40:45.619]                           if (is.null(name)) 
[17:40:45.619]                             next
[17:40:45.619]                           if (!grepl(pattern, name)) 
[17:40:45.619]                             next
[17:40:45.619]                           invokeRestart(restart)
[17:40:45.619]                           muffled <- TRUE
[17:40:45.619]                           break
[17:40:45.619]                         }
[17:40:45.619]                       }
[17:40:45.619]                     }
[17:40:45.619]                     invisible(muffled)
[17:40:45.619]                   }
[17:40:45.619]                   muffleCondition(cond)
[17:40:45.619]                 })
[17:40:45.619]             }))
[17:40:45.619]             future::FutureResult(value = ...future.value$value, 
[17:40:45.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:45.619]                   ...future.rng), globalenv = if (FALSE) 
[17:40:45.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:45.619]                     ...future.globalenv.names))
[17:40:45.619]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:45.619]         }, condition = base::local({
[17:40:45.619]             c <- base::c
[17:40:45.619]             inherits <- base::inherits
[17:40:45.619]             invokeRestart <- base::invokeRestart
[17:40:45.619]             length <- base::length
[17:40:45.619]             list <- base::list
[17:40:45.619]             seq.int <- base::seq.int
[17:40:45.619]             signalCondition <- base::signalCondition
[17:40:45.619]             sys.calls <- base::sys.calls
[17:40:45.619]             `[[` <- base::`[[`
[17:40:45.619]             `+` <- base::`+`
[17:40:45.619]             `<<-` <- base::`<<-`
[17:40:45.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:45.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:45.619]                   3L)]
[17:40:45.619]             }
[17:40:45.619]             function(cond) {
[17:40:45.619]                 is_error <- inherits(cond, "error")
[17:40:45.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:45.619]                   NULL)
[17:40:45.619]                 if (is_error) {
[17:40:45.619]                   sessionInformation <- function() {
[17:40:45.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:45.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:45.619]                       search = base::search(), system = base::Sys.info())
[17:40:45.619]                   }
[17:40:45.619]                   ...future.conditions[[length(...future.conditions) + 
[17:40:45.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:45.619]                     cond$call), session = sessionInformation(), 
[17:40:45.619]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:45.619]                   signalCondition(cond)
[17:40:45.619]                 }
[17:40:45.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:45.619]                 "immediateCondition"))) {
[17:40:45.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:45.619]                   ...future.conditions[[length(...future.conditions) + 
[17:40:45.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:45.619]                   if (TRUE && !signal) {
[17:40:45.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.619]                     {
[17:40:45.619]                       inherits <- base::inherits
[17:40:45.619]                       invokeRestart <- base::invokeRestart
[17:40:45.619]                       is.null <- base::is.null
[17:40:45.619]                       muffled <- FALSE
[17:40:45.619]                       if (inherits(cond, "message")) {
[17:40:45.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:45.619]                         if (muffled) 
[17:40:45.619]                           invokeRestart("muffleMessage")
[17:40:45.619]                       }
[17:40:45.619]                       else if (inherits(cond, "warning")) {
[17:40:45.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:45.619]                         if (muffled) 
[17:40:45.619]                           invokeRestart("muffleWarning")
[17:40:45.619]                       }
[17:40:45.619]                       else if (inherits(cond, "condition")) {
[17:40:45.619]                         if (!is.null(pattern)) {
[17:40:45.619]                           computeRestarts <- base::computeRestarts
[17:40:45.619]                           grepl <- base::grepl
[17:40:45.619]                           restarts <- computeRestarts(cond)
[17:40:45.619]                           for (restart in restarts) {
[17:40:45.619]                             name <- restart$name
[17:40:45.619]                             if (is.null(name)) 
[17:40:45.619]                               next
[17:40:45.619]                             if (!grepl(pattern, name)) 
[17:40:45.619]                               next
[17:40:45.619]                             invokeRestart(restart)
[17:40:45.619]                             muffled <- TRUE
[17:40:45.619]                             break
[17:40:45.619]                           }
[17:40:45.619]                         }
[17:40:45.619]                       }
[17:40:45.619]                       invisible(muffled)
[17:40:45.619]                     }
[17:40:45.619]                     muffleCondition(cond, pattern = "^muffle")
[17:40:45.619]                   }
[17:40:45.619]                 }
[17:40:45.619]                 else {
[17:40:45.619]                   if (TRUE) {
[17:40:45.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.619]                     {
[17:40:45.619]                       inherits <- base::inherits
[17:40:45.619]                       invokeRestart <- base::invokeRestart
[17:40:45.619]                       is.null <- base::is.null
[17:40:45.619]                       muffled <- FALSE
[17:40:45.619]                       if (inherits(cond, "message")) {
[17:40:45.619]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:45.619]                         if (muffled) 
[17:40:45.619]                           invokeRestart("muffleMessage")
[17:40:45.619]                       }
[17:40:45.619]                       else if (inherits(cond, "warning")) {
[17:40:45.619]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:45.619]                         if (muffled) 
[17:40:45.619]                           invokeRestart("muffleWarning")
[17:40:45.619]                       }
[17:40:45.619]                       else if (inherits(cond, "condition")) {
[17:40:45.619]                         if (!is.null(pattern)) {
[17:40:45.619]                           computeRestarts <- base::computeRestarts
[17:40:45.619]                           grepl <- base::grepl
[17:40:45.619]                           restarts <- computeRestarts(cond)
[17:40:45.619]                           for (restart in restarts) {
[17:40:45.619]                             name <- restart$name
[17:40:45.619]                             if (is.null(name)) 
[17:40:45.619]                               next
[17:40:45.619]                             if (!grepl(pattern, name)) 
[17:40:45.619]                               next
[17:40:45.619]                             invokeRestart(restart)
[17:40:45.619]                             muffled <- TRUE
[17:40:45.619]                             break
[17:40:45.619]                           }
[17:40:45.619]                         }
[17:40:45.619]                       }
[17:40:45.619]                       invisible(muffled)
[17:40:45.619]                     }
[17:40:45.619]                     muffleCondition(cond, pattern = "^muffle")
[17:40:45.619]                   }
[17:40:45.619]                 }
[17:40:45.619]             }
[17:40:45.619]         }))
[17:40:45.619]     }, error = function(ex) {
[17:40:45.619]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:45.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:45.619]                 ...future.rng), started = ...future.startTime, 
[17:40:45.619]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:45.619]             version = "1.8"), class = "FutureResult")
[17:40:45.619]     }, finally = {
[17:40:45.619]         if (!identical(...future.workdir, getwd())) 
[17:40:45.619]             setwd(...future.workdir)
[17:40:45.619]         {
[17:40:45.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:45.619]                 ...future.oldOptions$nwarnings <- NULL
[17:40:45.619]             }
[17:40:45.619]             base::options(...future.oldOptions)
[17:40:45.619]             if (.Platform$OS.type == "windows") {
[17:40:45.619]                 old_names <- names(...future.oldEnvVars)
[17:40:45.619]                 envs <- base::Sys.getenv()
[17:40:45.619]                 names <- names(envs)
[17:40:45.619]                 common <- intersect(names, old_names)
[17:40:45.619]                 added <- setdiff(names, old_names)
[17:40:45.619]                 removed <- setdiff(old_names, names)
[17:40:45.619]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:45.619]                   envs[common]]
[17:40:45.619]                 NAMES <- toupper(changed)
[17:40:45.619]                 args <- list()
[17:40:45.619]                 for (kk in seq_along(NAMES)) {
[17:40:45.619]                   name <- changed[[kk]]
[17:40:45.619]                   NAME <- NAMES[[kk]]
[17:40:45.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.619]                     next
[17:40:45.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:45.619]                 }
[17:40:45.619]                 NAMES <- toupper(added)
[17:40:45.619]                 for (kk in seq_along(NAMES)) {
[17:40:45.619]                   name <- added[[kk]]
[17:40:45.619]                   NAME <- NAMES[[kk]]
[17:40:45.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.619]                     next
[17:40:45.619]                   args[[name]] <- ""
[17:40:45.619]                 }
[17:40:45.619]                 NAMES <- toupper(removed)
[17:40:45.619]                 for (kk in seq_along(NAMES)) {
[17:40:45.619]                   name <- removed[[kk]]
[17:40:45.619]                   NAME <- NAMES[[kk]]
[17:40:45.619]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.619]                     next
[17:40:45.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:45.619]                 }
[17:40:45.619]                 if (length(args) > 0) 
[17:40:45.619]                   base::do.call(base::Sys.setenv, args = args)
[17:40:45.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:45.619]             }
[17:40:45.619]             else {
[17:40:45.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:45.619]             }
[17:40:45.619]             {
[17:40:45.619]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:45.619]                   0L) {
[17:40:45.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:45.619]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:45.619]                   base::options(opts)
[17:40:45.619]                 }
[17:40:45.619]                 {
[17:40:45.619]                   {
[17:40:45.619]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:45.619]                     NULL
[17:40:45.619]                   }
[17:40:45.619]                   options(future.plan = NULL)
[17:40:45.619]                   if (is.na(NA_character_)) 
[17:40:45.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:45.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:45.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:45.619]                     .init = FALSE)
[17:40:45.619]                 }
[17:40:45.619]             }
[17:40:45.619]         }
[17:40:45.619]     })
[17:40:45.619]     if (TRUE) {
[17:40:45.619]         base::sink(type = "output", split = FALSE)
[17:40:45.619]         if (TRUE) {
[17:40:45.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:45.619]         }
[17:40:45.619]         else {
[17:40:45.619]             ...future.result["stdout"] <- base::list(NULL)
[17:40:45.619]         }
[17:40:45.619]         base::close(...future.stdout)
[17:40:45.619]         ...future.stdout <- NULL
[17:40:45.619]     }
[17:40:45.619]     ...future.result$conditions <- ...future.conditions
[17:40:45.619]     ...future.result$finished <- base::Sys.time()
[17:40:45.619]     ...future.result
[17:40:45.619] }
[17:40:45.670] MultisessionFuture started
[17:40:45.671] result() for ClusterFuture ...
[17:40:45.672] receiveMessageFromWorker() for ClusterFuture ...
[17:40:45.672] - Validating connection of MultisessionFuture
[17:40:45.703] - received message: FutureResult
[17:40:45.703] - Received FutureResult
[17:40:45.703] - Erased future from FutureRegistry
[17:40:45.703] result() for ClusterFuture ...
[17:40:45.703] - result already collected: FutureResult
[17:40:45.704] result() for ClusterFuture ... done
[17:40:45.704] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:45.704] result() for ClusterFuture ... done
[17:40:45.704] result() for ClusterFuture ...
[17:40:45.704] - result already collected: FutureResult
[17:40:45.704] result() for ClusterFuture ... done
[17:40:45.704] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:40:45.708] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[17:40:45.712] getGlobalsAndPackages() ...
[17:40:45.712] Searching for globals...
[17:40:45.713] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:45.713] Searching for globals ... DONE
[17:40:45.713] Resolving globals: FALSE
[17:40:45.714] 
[17:40:45.714] 
[17:40:45.714] getGlobalsAndPackages() ... DONE
[17:40:45.714] run() for ‘Future’ ...
[17:40:45.714] - state: ‘created’
[17:40:45.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:45.729] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:45.729] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:45.729]   - Field: ‘node’
[17:40:45.729]   - Field: ‘label’
[17:40:45.729]   - Field: ‘local’
[17:40:45.729]   - Field: ‘owner’
[17:40:45.729]   - Field: ‘envir’
[17:40:45.729]   - Field: ‘workers’
[17:40:45.730]   - Field: ‘packages’
[17:40:45.730]   - Field: ‘gc’
[17:40:45.730]   - Field: ‘conditions’
[17:40:45.730]   - Field: ‘persistent’
[17:40:45.730]   - Field: ‘expr’
[17:40:45.730]   - Field: ‘uuid’
[17:40:45.730]   - Field: ‘seed’
[17:40:45.730]   - Field: ‘version’
[17:40:45.730]   - Field: ‘result’
[17:40:45.731]   - Field: ‘asynchronous’
[17:40:45.731]   - Field: ‘calls’
[17:40:45.731]   - Field: ‘globals’
[17:40:45.731]   - Field: ‘stdout’
[17:40:45.731]   - Field: ‘earlySignal’
[17:40:45.731]   - Field: ‘lazy’
[17:40:45.731]   - Field: ‘state’
[17:40:45.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:45.731] - Launch lazy future ...
[17:40:45.732] Packages needed by the future expression (n = 0): <none>
[17:40:45.732] Packages needed by future strategies (n = 0): <none>
[17:40:45.733] {
[17:40:45.733]     {
[17:40:45.733]         {
[17:40:45.733]             ...future.startTime <- base::Sys.time()
[17:40:45.733]             {
[17:40:45.733]                 {
[17:40:45.733]                   {
[17:40:45.733]                     {
[17:40:45.733]                       base::local({
[17:40:45.733]                         has_future <- base::requireNamespace("future", 
[17:40:45.733]                           quietly = TRUE)
[17:40:45.733]                         if (has_future) {
[17:40:45.733]                           ns <- base::getNamespace("future")
[17:40:45.733]                           version <- ns[[".package"]][["version"]]
[17:40:45.733]                           if (is.null(version)) 
[17:40:45.733]                             version <- utils::packageVersion("future")
[17:40:45.733]                         }
[17:40:45.733]                         else {
[17:40:45.733]                           version <- NULL
[17:40:45.733]                         }
[17:40:45.733]                         if (!has_future || version < "1.8.0") {
[17:40:45.733]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:45.733]                             "", base::R.version$version.string), 
[17:40:45.733]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:45.733]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:45.733]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:45.733]                               "release", "version")], collapse = " "), 
[17:40:45.733]                             hostname = base::Sys.info()[["nodename"]])
[17:40:45.733]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:45.733]                             info)
[17:40:45.733]                           info <- base::paste(info, collapse = "; ")
[17:40:45.733]                           if (!has_future) {
[17:40:45.733]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:45.733]                               info)
[17:40:45.733]                           }
[17:40:45.733]                           else {
[17:40:45.733]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:45.733]                               info, version)
[17:40:45.733]                           }
[17:40:45.733]                           base::stop(msg)
[17:40:45.733]                         }
[17:40:45.733]                       })
[17:40:45.733]                     }
[17:40:45.733]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:45.733]                     base::options(mc.cores = 1L)
[17:40:45.733]                   }
[17:40:45.733]                   ...future.strategy.old <- future::plan("list")
[17:40:45.733]                   options(future.plan = NULL)
[17:40:45.733]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:45.733]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:45.733]                 }
[17:40:45.733]                 ...future.workdir <- getwd()
[17:40:45.733]             }
[17:40:45.733]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:45.733]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:45.733]         }
[17:40:45.733]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:45.733]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:45.733]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:45.733]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:45.733]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:45.733]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:45.733]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:45.733]             base::names(...future.oldOptions))
[17:40:45.733]     }
[17:40:45.733]     if (FALSE) {
[17:40:45.733]     }
[17:40:45.733]     else {
[17:40:45.733]         if (TRUE) {
[17:40:45.733]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:45.733]                 open = "w")
[17:40:45.733]         }
[17:40:45.733]         else {
[17:40:45.733]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:45.733]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:45.733]         }
[17:40:45.733]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:45.733]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:45.733]             base::sink(type = "output", split = FALSE)
[17:40:45.733]             base::close(...future.stdout)
[17:40:45.733]         }, add = TRUE)
[17:40:45.733]     }
[17:40:45.733]     ...future.frame <- base::sys.nframe()
[17:40:45.733]     ...future.conditions <- base::list()
[17:40:45.733]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:45.733]     if (FALSE) {
[17:40:45.733]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:45.733]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:45.733]     }
[17:40:45.733]     ...future.result <- base::tryCatch({
[17:40:45.733]         base::withCallingHandlers({
[17:40:45.733]             ...future.value <- base::withVisible(base::local({
[17:40:45.733]                 ...future.makeSendCondition <- base::local({
[17:40:45.733]                   sendCondition <- NULL
[17:40:45.733]                   function(frame = 1L) {
[17:40:45.733]                     if (is.function(sendCondition)) 
[17:40:45.733]                       return(sendCondition)
[17:40:45.733]                     ns <- getNamespace("parallel")
[17:40:45.733]                     if (exists("sendData", mode = "function", 
[17:40:45.733]                       envir = ns)) {
[17:40:45.733]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:45.733]                         envir = ns)
[17:40:45.733]                       envir <- sys.frame(frame)
[17:40:45.733]                       master <- NULL
[17:40:45.733]                       while (!identical(envir, .GlobalEnv) && 
[17:40:45.733]                         !identical(envir, emptyenv())) {
[17:40:45.733]                         if (exists("master", mode = "list", envir = envir, 
[17:40:45.733]                           inherits = FALSE)) {
[17:40:45.733]                           master <- get("master", mode = "list", 
[17:40:45.733]                             envir = envir, inherits = FALSE)
[17:40:45.733]                           if (inherits(master, c("SOCKnode", 
[17:40:45.733]                             "SOCK0node"))) {
[17:40:45.733]                             sendCondition <<- function(cond) {
[17:40:45.733]                               data <- list(type = "VALUE", value = cond, 
[17:40:45.733]                                 success = TRUE)
[17:40:45.733]                               parallel_sendData(master, data)
[17:40:45.733]                             }
[17:40:45.733]                             return(sendCondition)
[17:40:45.733]                           }
[17:40:45.733]                         }
[17:40:45.733]                         frame <- frame + 1L
[17:40:45.733]                         envir <- sys.frame(frame)
[17:40:45.733]                       }
[17:40:45.733]                     }
[17:40:45.733]                     sendCondition <<- function(cond) NULL
[17:40:45.733]                   }
[17:40:45.733]                 })
[17:40:45.733]                 withCallingHandlers({
[17:40:45.733]                   {
[17:40:45.733]                     Sys.sleep(0.5)
[17:40:45.733]                     list(a = 1, b = 42L)
[17:40:45.733]                   }
[17:40:45.733]                 }, immediateCondition = function(cond) {
[17:40:45.733]                   sendCondition <- ...future.makeSendCondition()
[17:40:45.733]                   sendCondition(cond)
[17:40:45.733]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.733]                   {
[17:40:45.733]                     inherits <- base::inherits
[17:40:45.733]                     invokeRestart <- base::invokeRestart
[17:40:45.733]                     is.null <- base::is.null
[17:40:45.733]                     muffled <- FALSE
[17:40:45.733]                     if (inherits(cond, "message")) {
[17:40:45.733]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:45.733]                       if (muffled) 
[17:40:45.733]                         invokeRestart("muffleMessage")
[17:40:45.733]                     }
[17:40:45.733]                     else if (inherits(cond, "warning")) {
[17:40:45.733]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:45.733]                       if (muffled) 
[17:40:45.733]                         invokeRestart("muffleWarning")
[17:40:45.733]                     }
[17:40:45.733]                     else if (inherits(cond, "condition")) {
[17:40:45.733]                       if (!is.null(pattern)) {
[17:40:45.733]                         computeRestarts <- base::computeRestarts
[17:40:45.733]                         grepl <- base::grepl
[17:40:45.733]                         restarts <- computeRestarts(cond)
[17:40:45.733]                         for (restart in restarts) {
[17:40:45.733]                           name <- restart$name
[17:40:45.733]                           if (is.null(name)) 
[17:40:45.733]                             next
[17:40:45.733]                           if (!grepl(pattern, name)) 
[17:40:45.733]                             next
[17:40:45.733]                           invokeRestart(restart)
[17:40:45.733]                           muffled <- TRUE
[17:40:45.733]                           break
[17:40:45.733]                         }
[17:40:45.733]                       }
[17:40:45.733]                     }
[17:40:45.733]                     invisible(muffled)
[17:40:45.733]                   }
[17:40:45.733]                   muffleCondition(cond)
[17:40:45.733]                 })
[17:40:45.733]             }))
[17:40:45.733]             future::FutureResult(value = ...future.value$value, 
[17:40:45.733]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:45.733]                   ...future.rng), globalenv = if (FALSE) 
[17:40:45.733]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:45.733]                     ...future.globalenv.names))
[17:40:45.733]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:45.733]         }, condition = base::local({
[17:40:45.733]             c <- base::c
[17:40:45.733]             inherits <- base::inherits
[17:40:45.733]             invokeRestart <- base::invokeRestart
[17:40:45.733]             length <- base::length
[17:40:45.733]             list <- base::list
[17:40:45.733]             seq.int <- base::seq.int
[17:40:45.733]             signalCondition <- base::signalCondition
[17:40:45.733]             sys.calls <- base::sys.calls
[17:40:45.733]             `[[` <- base::`[[`
[17:40:45.733]             `+` <- base::`+`
[17:40:45.733]             `<<-` <- base::`<<-`
[17:40:45.733]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:45.733]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:45.733]                   3L)]
[17:40:45.733]             }
[17:40:45.733]             function(cond) {
[17:40:45.733]                 is_error <- inherits(cond, "error")
[17:40:45.733]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:45.733]                   NULL)
[17:40:45.733]                 if (is_error) {
[17:40:45.733]                   sessionInformation <- function() {
[17:40:45.733]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:45.733]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:45.733]                       search = base::search(), system = base::Sys.info())
[17:40:45.733]                   }
[17:40:45.733]                   ...future.conditions[[length(...future.conditions) + 
[17:40:45.733]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:45.733]                     cond$call), session = sessionInformation(), 
[17:40:45.733]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:45.733]                   signalCondition(cond)
[17:40:45.733]                 }
[17:40:45.733]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:45.733]                 "immediateCondition"))) {
[17:40:45.733]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:45.733]                   ...future.conditions[[length(...future.conditions) + 
[17:40:45.733]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:45.733]                   if (TRUE && !signal) {
[17:40:45.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.733]                     {
[17:40:45.733]                       inherits <- base::inherits
[17:40:45.733]                       invokeRestart <- base::invokeRestart
[17:40:45.733]                       is.null <- base::is.null
[17:40:45.733]                       muffled <- FALSE
[17:40:45.733]                       if (inherits(cond, "message")) {
[17:40:45.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:45.733]                         if (muffled) 
[17:40:45.733]                           invokeRestart("muffleMessage")
[17:40:45.733]                       }
[17:40:45.733]                       else if (inherits(cond, "warning")) {
[17:40:45.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:45.733]                         if (muffled) 
[17:40:45.733]                           invokeRestart("muffleWarning")
[17:40:45.733]                       }
[17:40:45.733]                       else if (inherits(cond, "condition")) {
[17:40:45.733]                         if (!is.null(pattern)) {
[17:40:45.733]                           computeRestarts <- base::computeRestarts
[17:40:45.733]                           grepl <- base::grepl
[17:40:45.733]                           restarts <- computeRestarts(cond)
[17:40:45.733]                           for (restart in restarts) {
[17:40:45.733]                             name <- restart$name
[17:40:45.733]                             if (is.null(name)) 
[17:40:45.733]                               next
[17:40:45.733]                             if (!grepl(pattern, name)) 
[17:40:45.733]                               next
[17:40:45.733]                             invokeRestart(restart)
[17:40:45.733]                             muffled <- TRUE
[17:40:45.733]                             break
[17:40:45.733]                           }
[17:40:45.733]                         }
[17:40:45.733]                       }
[17:40:45.733]                       invisible(muffled)
[17:40:45.733]                     }
[17:40:45.733]                     muffleCondition(cond, pattern = "^muffle")
[17:40:45.733]                   }
[17:40:45.733]                 }
[17:40:45.733]                 else {
[17:40:45.733]                   if (TRUE) {
[17:40:45.733]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:45.733]                     {
[17:40:45.733]                       inherits <- base::inherits
[17:40:45.733]                       invokeRestart <- base::invokeRestart
[17:40:45.733]                       is.null <- base::is.null
[17:40:45.733]                       muffled <- FALSE
[17:40:45.733]                       if (inherits(cond, "message")) {
[17:40:45.733]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:45.733]                         if (muffled) 
[17:40:45.733]                           invokeRestart("muffleMessage")
[17:40:45.733]                       }
[17:40:45.733]                       else if (inherits(cond, "warning")) {
[17:40:45.733]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:45.733]                         if (muffled) 
[17:40:45.733]                           invokeRestart("muffleWarning")
[17:40:45.733]                       }
[17:40:45.733]                       else if (inherits(cond, "condition")) {
[17:40:45.733]                         if (!is.null(pattern)) {
[17:40:45.733]                           computeRestarts <- base::computeRestarts
[17:40:45.733]                           grepl <- base::grepl
[17:40:45.733]                           restarts <- computeRestarts(cond)
[17:40:45.733]                           for (restart in restarts) {
[17:40:45.733]                             name <- restart$name
[17:40:45.733]                             if (is.null(name)) 
[17:40:45.733]                               next
[17:40:45.733]                             if (!grepl(pattern, name)) 
[17:40:45.733]                               next
[17:40:45.733]                             invokeRestart(restart)
[17:40:45.733]                             muffled <- TRUE
[17:40:45.733]                             break
[17:40:45.733]                           }
[17:40:45.733]                         }
[17:40:45.733]                       }
[17:40:45.733]                       invisible(muffled)
[17:40:45.733]                     }
[17:40:45.733]                     muffleCondition(cond, pattern = "^muffle")
[17:40:45.733]                   }
[17:40:45.733]                 }
[17:40:45.733]             }
[17:40:45.733]         }))
[17:40:45.733]     }, error = function(ex) {
[17:40:45.733]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:45.733]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:45.733]                 ...future.rng), started = ...future.startTime, 
[17:40:45.733]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:45.733]             version = "1.8"), class = "FutureResult")
[17:40:45.733]     }, finally = {
[17:40:45.733]         if (!identical(...future.workdir, getwd())) 
[17:40:45.733]             setwd(...future.workdir)
[17:40:45.733]         {
[17:40:45.733]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:45.733]                 ...future.oldOptions$nwarnings <- NULL
[17:40:45.733]             }
[17:40:45.733]             base::options(...future.oldOptions)
[17:40:45.733]             if (.Platform$OS.type == "windows") {
[17:40:45.733]                 old_names <- names(...future.oldEnvVars)
[17:40:45.733]                 envs <- base::Sys.getenv()
[17:40:45.733]                 names <- names(envs)
[17:40:45.733]                 common <- intersect(names, old_names)
[17:40:45.733]                 added <- setdiff(names, old_names)
[17:40:45.733]                 removed <- setdiff(old_names, names)
[17:40:45.733]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:45.733]                   envs[common]]
[17:40:45.733]                 NAMES <- toupper(changed)
[17:40:45.733]                 args <- list()
[17:40:45.733]                 for (kk in seq_along(NAMES)) {
[17:40:45.733]                   name <- changed[[kk]]
[17:40:45.733]                   NAME <- NAMES[[kk]]
[17:40:45.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.733]                     next
[17:40:45.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:45.733]                 }
[17:40:45.733]                 NAMES <- toupper(added)
[17:40:45.733]                 for (kk in seq_along(NAMES)) {
[17:40:45.733]                   name <- added[[kk]]
[17:40:45.733]                   NAME <- NAMES[[kk]]
[17:40:45.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.733]                     next
[17:40:45.733]                   args[[name]] <- ""
[17:40:45.733]                 }
[17:40:45.733]                 NAMES <- toupper(removed)
[17:40:45.733]                 for (kk in seq_along(NAMES)) {
[17:40:45.733]                   name <- removed[[kk]]
[17:40:45.733]                   NAME <- NAMES[[kk]]
[17:40:45.733]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:45.733]                     next
[17:40:45.733]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:45.733]                 }
[17:40:45.733]                 if (length(args) > 0) 
[17:40:45.733]                   base::do.call(base::Sys.setenv, args = args)
[17:40:45.733]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:45.733]             }
[17:40:45.733]             else {
[17:40:45.733]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:45.733]             }
[17:40:45.733]             {
[17:40:45.733]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:45.733]                   0L) {
[17:40:45.733]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:45.733]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:45.733]                   base::options(opts)
[17:40:45.733]                 }
[17:40:45.733]                 {
[17:40:45.733]                   {
[17:40:45.733]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:45.733]                     NULL
[17:40:45.733]                   }
[17:40:45.733]                   options(future.plan = NULL)
[17:40:45.733]                   if (is.na(NA_character_)) 
[17:40:45.733]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:45.733]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:45.733]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:45.733]                     .init = FALSE)
[17:40:45.733]                 }
[17:40:45.733]             }
[17:40:45.733]         }
[17:40:45.733]     })
[17:40:45.733]     if (TRUE) {
[17:40:45.733]         base::sink(type = "output", split = FALSE)
[17:40:45.733]         if (TRUE) {
[17:40:45.733]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:45.733]         }
[17:40:45.733]         else {
[17:40:45.733]             ...future.result["stdout"] <- base::list(NULL)
[17:40:45.733]         }
[17:40:45.733]         base::close(...future.stdout)
[17:40:45.733]         ...future.stdout <- NULL
[17:40:45.733]     }
[17:40:45.733]     ...future.result$conditions <- ...future.conditions
[17:40:45.733]     ...future.result$finished <- base::Sys.time()
[17:40:45.733]     ...future.result
[17:40:45.733] }
[17:40:45.736] MultisessionFuture started
[17:40:45.736] - Launch lazy future ... done
[17:40:45.736] run() for ‘MultisessionFuture’ ... done
[17:40:46.239] receiveMessageFromWorker() for ClusterFuture ...
[17:40:46.239] - Validating connection of MultisessionFuture
[17:40:46.239] - received message: FutureResult
[17:40:46.240] - Received FutureResult
[17:40:46.240] - Erased future from FutureRegistry
[17:40:46.240] result() for ClusterFuture ...
[17:40:46.240] - result already collected: FutureResult
[17:40:46.240] result() for ClusterFuture ... done
[17:40:46.240] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:46.240] A MultisessionFuture was resolved (result was not collected)
[17:40:46.241] getGlobalsAndPackages() ...
[17:40:46.241] Searching for globals...
[17:40:46.242] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:46.242] Searching for globals ... DONE
[17:40:46.242] Resolving globals: FALSE
[17:40:46.243] 
[17:40:46.243] 
[17:40:46.243] getGlobalsAndPackages() ... DONE
[17:40:46.243] run() for ‘Future’ ...
[17:40:46.243] - state: ‘created’
[17:40:46.244] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:46.258] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:46.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:46.258]   - Field: ‘node’
[17:40:46.259]   - Field: ‘label’
[17:40:46.259]   - Field: ‘local’
[17:40:46.259]   - Field: ‘owner’
[17:40:46.259]   - Field: ‘envir’
[17:40:46.259]   - Field: ‘workers’
[17:40:46.259]   - Field: ‘packages’
[17:40:46.259]   - Field: ‘gc’
[17:40:46.259]   - Field: ‘conditions’
[17:40:46.259]   - Field: ‘persistent’
[17:40:46.259]   - Field: ‘expr’
[17:40:46.260]   - Field: ‘uuid’
[17:40:46.260]   - Field: ‘seed’
[17:40:46.260]   - Field: ‘version’
[17:40:46.260]   - Field: ‘result’
[17:40:46.260]   - Field: ‘asynchronous’
[17:40:46.260]   - Field: ‘calls’
[17:40:46.260]   - Field: ‘globals’
[17:40:46.260]   - Field: ‘stdout’
[17:40:46.260]   - Field: ‘earlySignal’
[17:40:46.261]   - Field: ‘lazy’
[17:40:46.261]   - Field: ‘state’
[17:40:46.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:46.261] - Launch lazy future ...
[17:40:46.261] Packages needed by the future expression (n = 0): <none>
[17:40:46.261] Packages needed by future strategies (n = 0): <none>
[17:40:46.262] {
[17:40:46.262]     {
[17:40:46.262]         {
[17:40:46.262]             ...future.startTime <- base::Sys.time()
[17:40:46.262]             {
[17:40:46.262]                 {
[17:40:46.262]                   {
[17:40:46.262]                     {
[17:40:46.262]                       base::local({
[17:40:46.262]                         has_future <- base::requireNamespace("future", 
[17:40:46.262]                           quietly = TRUE)
[17:40:46.262]                         if (has_future) {
[17:40:46.262]                           ns <- base::getNamespace("future")
[17:40:46.262]                           version <- ns[[".package"]][["version"]]
[17:40:46.262]                           if (is.null(version)) 
[17:40:46.262]                             version <- utils::packageVersion("future")
[17:40:46.262]                         }
[17:40:46.262]                         else {
[17:40:46.262]                           version <- NULL
[17:40:46.262]                         }
[17:40:46.262]                         if (!has_future || version < "1.8.0") {
[17:40:46.262]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:46.262]                             "", base::R.version$version.string), 
[17:40:46.262]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:46.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:46.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:46.262]                               "release", "version")], collapse = " "), 
[17:40:46.262]                             hostname = base::Sys.info()[["nodename"]])
[17:40:46.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:46.262]                             info)
[17:40:46.262]                           info <- base::paste(info, collapse = "; ")
[17:40:46.262]                           if (!has_future) {
[17:40:46.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:46.262]                               info)
[17:40:46.262]                           }
[17:40:46.262]                           else {
[17:40:46.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:46.262]                               info, version)
[17:40:46.262]                           }
[17:40:46.262]                           base::stop(msg)
[17:40:46.262]                         }
[17:40:46.262]                       })
[17:40:46.262]                     }
[17:40:46.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:46.262]                     base::options(mc.cores = 1L)
[17:40:46.262]                   }
[17:40:46.262]                   ...future.strategy.old <- future::plan("list")
[17:40:46.262]                   options(future.plan = NULL)
[17:40:46.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:46.262]                 }
[17:40:46.262]                 ...future.workdir <- getwd()
[17:40:46.262]             }
[17:40:46.262]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:46.262]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:46.262]         }
[17:40:46.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:46.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:46.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:46.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:46.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:46.262]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:46.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:46.262]             base::names(...future.oldOptions))
[17:40:46.262]     }
[17:40:46.262]     if (FALSE) {
[17:40:46.262]     }
[17:40:46.262]     else {
[17:40:46.262]         if (TRUE) {
[17:40:46.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:46.262]                 open = "w")
[17:40:46.262]         }
[17:40:46.262]         else {
[17:40:46.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:46.262]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:46.262]         }
[17:40:46.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:46.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:46.262]             base::sink(type = "output", split = FALSE)
[17:40:46.262]             base::close(...future.stdout)
[17:40:46.262]         }, add = TRUE)
[17:40:46.262]     }
[17:40:46.262]     ...future.frame <- base::sys.nframe()
[17:40:46.262]     ...future.conditions <- base::list()
[17:40:46.262]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:46.262]     if (FALSE) {
[17:40:46.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:46.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:46.262]     }
[17:40:46.262]     ...future.result <- base::tryCatch({
[17:40:46.262]         base::withCallingHandlers({
[17:40:46.262]             ...future.value <- base::withVisible(base::local({
[17:40:46.262]                 ...future.makeSendCondition <- base::local({
[17:40:46.262]                   sendCondition <- NULL
[17:40:46.262]                   function(frame = 1L) {
[17:40:46.262]                     if (is.function(sendCondition)) 
[17:40:46.262]                       return(sendCondition)
[17:40:46.262]                     ns <- getNamespace("parallel")
[17:40:46.262]                     if (exists("sendData", mode = "function", 
[17:40:46.262]                       envir = ns)) {
[17:40:46.262]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:46.262]                         envir = ns)
[17:40:46.262]                       envir <- sys.frame(frame)
[17:40:46.262]                       master <- NULL
[17:40:46.262]                       while (!identical(envir, .GlobalEnv) && 
[17:40:46.262]                         !identical(envir, emptyenv())) {
[17:40:46.262]                         if (exists("master", mode = "list", envir = envir, 
[17:40:46.262]                           inherits = FALSE)) {
[17:40:46.262]                           master <- get("master", mode = "list", 
[17:40:46.262]                             envir = envir, inherits = FALSE)
[17:40:46.262]                           if (inherits(master, c("SOCKnode", 
[17:40:46.262]                             "SOCK0node"))) {
[17:40:46.262]                             sendCondition <<- function(cond) {
[17:40:46.262]                               data <- list(type = "VALUE", value = cond, 
[17:40:46.262]                                 success = TRUE)
[17:40:46.262]                               parallel_sendData(master, data)
[17:40:46.262]                             }
[17:40:46.262]                             return(sendCondition)
[17:40:46.262]                           }
[17:40:46.262]                         }
[17:40:46.262]                         frame <- frame + 1L
[17:40:46.262]                         envir <- sys.frame(frame)
[17:40:46.262]                       }
[17:40:46.262]                     }
[17:40:46.262]                     sendCondition <<- function(cond) NULL
[17:40:46.262]                   }
[17:40:46.262]                 })
[17:40:46.262]                 withCallingHandlers({
[17:40:46.262]                   {
[17:40:46.262]                     Sys.sleep(0.5)
[17:40:46.262]                     list(a = 1, b = 42L)
[17:40:46.262]                   }
[17:40:46.262]                 }, immediateCondition = function(cond) {
[17:40:46.262]                   sendCondition <- ...future.makeSendCondition()
[17:40:46.262]                   sendCondition(cond)
[17:40:46.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.262]                   {
[17:40:46.262]                     inherits <- base::inherits
[17:40:46.262]                     invokeRestart <- base::invokeRestart
[17:40:46.262]                     is.null <- base::is.null
[17:40:46.262]                     muffled <- FALSE
[17:40:46.262]                     if (inherits(cond, "message")) {
[17:40:46.262]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:46.262]                       if (muffled) 
[17:40:46.262]                         invokeRestart("muffleMessage")
[17:40:46.262]                     }
[17:40:46.262]                     else if (inherits(cond, "warning")) {
[17:40:46.262]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:46.262]                       if (muffled) 
[17:40:46.262]                         invokeRestart("muffleWarning")
[17:40:46.262]                     }
[17:40:46.262]                     else if (inherits(cond, "condition")) {
[17:40:46.262]                       if (!is.null(pattern)) {
[17:40:46.262]                         computeRestarts <- base::computeRestarts
[17:40:46.262]                         grepl <- base::grepl
[17:40:46.262]                         restarts <- computeRestarts(cond)
[17:40:46.262]                         for (restart in restarts) {
[17:40:46.262]                           name <- restart$name
[17:40:46.262]                           if (is.null(name)) 
[17:40:46.262]                             next
[17:40:46.262]                           if (!grepl(pattern, name)) 
[17:40:46.262]                             next
[17:40:46.262]                           invokeRestart(restart)
[17:40:46.262]                           muffled <- TRUE
[17:40:46.262]                           break
[17:40:46.262]                         }
[17:40:46.262]                       }
[17:40:46.262]                     }
[17:40:46.262]                     invisible(muffled)
[17:40:46.262]                   }
[17:40:46.262]                   muffleCondition(cond)
[17:40:46.262]                 })
[17:40:46.262]             }))
[17:40:46.262]             future::FutureResult(value = ...future.value$value, 
[17:40:46.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.262]                   ...future.rng), globalenv = if (FALSE) 
[17:40:46.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:46.262]                     ...future.globalenv.names))
[17:40:46.262]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:46.262]         }, condition = base::local({
[17:40:46.262]             c <- base::c
[17:40:46.262]             inherits <- base::inherits
[17:40:46.262]             invokeRestart <- base::invokeRestart
[17:40:46.262]             length <- base::length
[17:40:46.262]             list <- base::list
[17:40:46.262]             seq.int <- base::seq.int
[17:40:46.262]             signalCondition <- base::signalCondition
[17:40:46.262]             sys.calls <- base::sys.calls
[17:40:46.262]             `[[` <- base::`[[`
[17:40:46.262]             `+` <- base::`+`
[17:40:46.262]             `<<-` <- base::`<<-`
[17:40:46.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:46.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:46.262]                   3L)]
[17:40:46.262]             }
[17:40:46.262]             function(cond) {
[17:40:46.262]                 is_error <- inherits(cond, "error")
[17:40:46.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:46.262]                   NULL)
[17:40:46.262]                 if (is_error) {
[17:40:46.262]                   sessionInformation <- function() {
[17:40:46.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:46.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:46.262]                       search = base::search(), system = base::Sys.info())
[17:40:46.262]                   }
[17:40:46.262]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:46.262]                     cond$call), session = sessionInformation(), 
[17:40:46.262]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:46.262]                   signalCondition(cond)
[17:40:46.262]                 }
[17:40:46.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:46.262]                 "immediateCondition"))) {
[17:40:46.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:46.262]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:46.262]                   if (TRUE && !signal) {
[17:40:46.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.262]                     {
[17:40:46.262]                       inherits <- base::inherits
[17:40:46.262]                       invokeRestart <- base::invokeRestart
[17:40:46.262]                       is.null <- base::is.null
[17:40:46.262]                       muffled <- FALSE
[17:40:46.262]                       if (inherits(cond, "message")) {
[17:40:46.262]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.262]                         if (muffled) 
[17:40:46.262]                           invokeRestart("muffleMessage")
[17:40:46.262]                       }
[17:40:46.262]                       else if (inherits(cond, "warning")) {
[17:40:46.262]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.262]                         if (muffled) 
[17:40:46.262]                           invokeRestart("muffleWarning")
[17:40:46.262]                       }
[17:40:46.262]                       else if (inherits(cond, "condition")) {
[17:40:46.262]                         if (!is.null(pattern)) {
[17:40:46.262]                           computeRestarts <- base::computeRestarts
[17:40:46.262]                           grepl <- base::grepl
[17:40:46.262]                           restarts <- computeRestarts(cond)
[17:40:46.262]                           for (restart in restarts) {
[17:40:46.262]                             name <- restart$name
[17:40:46.262]                             if (is.null(name)) 
[17:40:46.262]                               next
[17:40:46.262]                             if (!grepl(pattern, name)) 
[17:40:46.262]                               next
[17:40:46.262]                             invokeRestart(restart)
[17:40:46.262]                             muffled <- TRUE
[17:40:46.262]                             break
[17:40:46.262]                           }
[17:40:46.262]                         }
[17:40:46.262]                       }
[17:40:46.262]                       invisible(muffled)
[17:40:46.262]                     }
[17:40:46.262]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.262]                   }
[17:40:46.262]                 }
[17:40:46.262]                 else {
[17:40:46.262]                   if (TRUE) {
[17:40:46.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.262]                     {
[17:40:46.262]                       inherits <- base::inherits
[17:40:46.262]                       invokeRestart <- base::invokeRestart
[17:40:46.262]                       is.null <- base::is.null
[17:40:46.262]                       muffled <- FALSE
[17:40:46.262]                       if (inherits(cond, "message")) {
[17:40:46.262]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.262]                         if (muffled) 
[17:40:46.262]                           invokeRestart("muffleMessage")
[17:40:46.262]                       }
[17:40:46.262]                       else if (inherits(cond, "warning")) {
[17:40:46.262]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.262]                         if (muffled) 
[17:40:46.262]                           invokeRestart("muffleWarning")
[17:40:46.262]                       }
[17:40:46.262]                       else if (inherits(cond, "condition")) {
[17:40:46.262]                         if (!is.null(pattern)) {
[17:40:46.262]                           computeRestarts <- base::computeRestarts
[17:40:46.262]                           grepl <- base::grepl
[17:40:46.262]                           restarts <- computeRestarts(cond)
[17:40:46.262]                           for (restart in restarts) {
[17:40:46.262]                             name <- restart$name
[17:40:46.262]                             if (is.null(name)) 
[17:40:46.262]                               next
[17:40:46.262]                             if (!grepl(pattern, name)) 
[17:40:46.262]                               next
[17:40:46.262]                             invokeRestart(restart)
[17:40:46.262]                             muffled <- TRUE
[17:40:46.262]                             break
[17:40:46.262]                           }
[17:40:46.262]                         }
[17:40:46.262]                       }
[17:40:46.262]                       invisible(muffled)
[17:40:46.262]                     }
[17:40:46.262]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.262]                   }
[17:40:46.262]                 }
[17:40:46.262]             }
[17:40:46.262]         }))
[17:40:46.262]     }, error = function(ex) {
[17:40:46.262]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:46.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.262]                 ...future.rng), started = ...future.startTime, 
[17:40:46.262]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:46.262]             version = "1.8"), class = "FutureResult")
[17:40:46.262]     }, finally = {
[17:40:46.262]         if (!identical(...future.workdir, getwd())) 
[17:40:46.262]             setwd(...future.workdir)
[17:40:46.262]         {
[17:40:46.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:46.262]                 ...future.oldOptions$nwarnings <- NULL
[17:40:46.262]             }
[17:40:46.262]             base::options(...future.oldOptions)
[17:40:46.262]             if (.Platform$OS.type == "windows") {
[17:40:46.262]                 old_names <- names(...future.oldEnvVars)
[17:40:46.262]                 envs <- base::Sys.getenv()
[17:40:46.262]                 names <- names(envs)
[17:40:46.262]                 common <- intersect(names, old_names)
[17:40:46.262]                 added <- setdiff(names, old_names)
[17:40:46.262]                 removed <- setdiff(old_names, names)
[17:40:46.262]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:46.262]                   envs[common]]
[17:40:46.262]                 NAMES <- toupper(changed)
[17:40:46.262]                 args <- list()
[17:40:46.262]                 for (kk in seq_along(NAMES)) {
[17:40:46.262]                   name <- changed[[kk]]
[17:40:46.262]                   NAME <- NAMES[[kk]]
[17:40:46.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.262]                     next
[17:40:46.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.262]                 }
[17:40:46.262]                 NAMES <- toupper(added)
[17:40:46.262]                 for (kk in seq_along(NAMES)) {
[17:40:46.262]                   name <- added[[kk]]
[17:40:46.262]                   NAME <- NAMES[[kk]]
[17:40:46.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.262]                     next
[17:40:46.262]                   args[[name]] <- ""
[17:40:46.262]                 }
[17:40:46.262]                 NAMES <- toupper(removed)
[17:40:46.262]                 for (kk in seq_along(NAMES)) {
[17:40:46.262]                   name <- removed[[kk]]
[17:40:46.262]                   NAME <- NAMES[[kk]]
[17:40:46.262]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.262]                     next
[17:40:46.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.262]                 }
[17:40:46.262]                 if (length(args) > 0) 
[17:40:46.262]                   base::do.call(base::Sys.setenv, args = args)
[17:40:46.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:46.262]             }
[17:40:46.262]             else {
[17:40:46.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:46.262]             }
[17:40:46.262]             {
[17:40:46.262]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:46.262]                   0L) {
[17:40:46.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:46.262]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:46.262]                   base::options(opts)
[17:40:46.262]                 }
[17:40:46.262]                 {
[17:40:46.262]                   {
[17:40:46.262]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:46.262]                     NULL
[17:40:46.262]                   }
[17:40:46.262]                   options(future.plan = NULL)
[17:40:46.262]                   if (is.na(NA_character_)) 
[17:40:46.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:46.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:46.262]                     .init = FALSE)
[17:40:46.262]                 }
[17:40:46.262]             }
[17:40:46.262]         }
[17:40:46.262]     })
[17:40:46.262]     if (TRUE) {
[17:40:46.262]         base::sink(type = "output", split = FALSE)
[17:40:46.262]         if (TRUE) {
[17:40:46.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:46.262]         }
[17:40:46.262]         else {
[17:40:46.262]             ...future.result["stdout"] <- base::list(NULL)
[17:40:46.262]         }
[17:40:46.262]         base::close(...future.stdout)
[17:40:46.262]         ...future.stdout <- NULL
[17:40:46.262]     }
[17:40:46.262]     ...future.result$conditions <- ...future.conditions
[17:40:46.262]     ...future.result$finished <- base::Sys.time()
[17:40:46.262]     ...future.result
[17:40:46.262] }
[17:40:46.265] MultisessionFuture started
[17:40:46.265] - Launch lazy future ... done
[17:40:46.265] run() for ‘MultisessionFuture’ ... done
[17:40:46.771] receiveMessageFromWorker() for ClusterFuture ...
[17:40:46.771] - Validating connection of MultisessionFuture
[17:40:46.772] - received message: FutureResult
[17:40:46.772] - Received FutureResult
[17:40:46.772] - Erased future from FutureRegistry
[17:40:46.772] result() for ClusterFuture ...
[17:40:46.772] - result already collected: FutureResult
[17:40:46.772] result() for ClusterFuture ... done
[17:40:46.772] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:46.773] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:46.773] getGlobalsAndPackages() ...
[17:40:46.773] Searching for globals...
[17:40:46.774] - globals found: [2] ‘list’, ‘stop’
[17:40:46.774] Searching for globals ... DONE
[17:40:46.774] Resolving globals: FALSE
[17:40:46.774] 
[17:40:46.775] 
[17:40:46.775] getGlobalsAndPackages() ... DONE
[17:40:46.775] run() for ‘Future’ ...
[17:40:46.775] - state: ‘created’
[17:40:46.775] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:46.790] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:46.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:46.793]   - Field: ‘node’
[17:40:46.793]   - Field: ‘label’
[17:40:46.793]   - Field: ‘local’
[17:40:46.794]   - Field: ‘owner’
[17:40:46.794]   - Field: ‘envir’
[17:40:46.794]   - Field: ‘workers’
[17:40:46.794]   - Field: ‘packages’
[17:40:46.794]   - Field: ‘gc’
[17:40:46.794]   - Field: ‘conditions’
[17:40:46.794]   - Field: ‘persistent’
[17:40:46.794]   - Field: ‘expr’
[17:40:46.795]   - Field: ‘uuid’
[17:40:46.795]   - Field: ‘seed’
[17:40:46.795]   - Field: ‘version’
[17:40:46.795]   - Field: ‘result’
[17:40:46.795]   - Field: ‘asynchronous’
[17:40:46.795]   - Field: ‘calls’
[17:40:46.795]   - Field: ‘globals’
[17:40:46.796]   - Field: ‘stdout’
[17:40:46.796]   - Field: ‘earlySignal’
[17:40:46.796]   - Field: ‘lazy’
[17:40:46.796]   - Field: ‘state’
[17:40:46.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:46.797] - Launch lazy future ...
[17:40:46.797] Packages needed by the future expression (n = 0): <none>
[17:40:46.797] Packages needed by future strategies (n = 0): <none>
[17:40:46.797] {
[17:40:46.797]     {
[17:40:46.797]         {
[17:40:46.797]             ...future.startTime <- base::Sys.time()
[17:40:46.797]             {
[17:40:46.797]                 {
[17:40:46.797]                   {
[17:40:46.797]                     {
[17:40:46.797]                       base::local({
[17:40:46.797]                         has_future <- base::requireNamespace("future", 
[17:40:46.797]                           quietly = TRUE)
[17:40:46.797]                         if (has_future) {
[17:40:46.797]                           ns <- base::getNamespace("future")
[17:40:46.797]                           version <- ns[[".package"]][["version"]]
[17:40:46.797]                           if (is.null(version)) 
[17:40:46.797]                             version <- utils::packageVersion("future")
[17:40:46.797]                         }
[17:40:46.797]                         else {
[17:40:46.797]                           version <- NULL
[17:40:46.797]                         }
[17:40:46.797]                         if (!has_future || version < "1.8.0") {
[17:40:46.797]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:46.797]                             "", base::R.version$version.string), 
[17:40:46.797]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:46.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:46.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:46.797]                               "release", "version")], collapse = " "), 
[17:40:46.797]                             hostname = base::Sys.info()[["nodename"]])
[17:40:46.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:46.797]                             info)
[17:40:46.797]                           info <- base::paste(info, collapse = "; ")
[17:40:46.797]                           if (!has_future) {
[17:40:46.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:46.797]                               info)
[17:40:46.797]                           }
[17:40:46.797]                           else {
[17:40:46.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:46.797]                               info, version)
[17:40:46.797]                           }
[17:40:46.797]                           base::stop(msg)
[17:40:46.797]                         }
[17:40:46.797]                       })
[17:40:46.797]                     }
[17:40:46.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:46.797]                     base::options(mc.cores = 1L)
[17:40:46.797]                   }
[17:40:46.797]                   ...future.strategy.old <- future::plan("list")
[17:40:46.797]                   options(future.plan = NULL)
[17:40:46.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:46.797]                 }
[17:40:46.797]                 ...future.workdir <- getwd()
[17:40:46.797]             }
[17:40:46.797]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:46.797]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:46.797]         }
[17:40:46.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:46.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:46.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:46.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:46.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:46.797]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:46.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:46.797]             base::names(...future.oldOptions))
[17:40:46.797]     }
[17:40:46.797]     if (FALSE) {
[17:40:46.797]     }
[17:40:46.797]     else {
[17:40:46.797]         if (TRUE) {
[17:40:46.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:46.797]                 open = "w")
[17:40:46.797]         }
[17:40:46.797]         else {
[17:40:46.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:46.797]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:46.797]         }
[17:40:46.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:46.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:46.797]             base::sink(type = "output", split = FALSE)
[17:40:46.797]             base::close(...future.stdout)
[17:40:46.797]         }, add = TRUE)
[17:40:46.797]     }
[17:40:46.797]     ...future.frame <- base::sys.nframe()
[17:40:46.797]     ...future.conditions <- base::list()
[17:40:46.797]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:46.797]     if (FALSE) {
[17:40:46.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:46.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:46.797]     }
[17:40:46.797]     ...future.result <- base::tryCatch({
[17:40:46.797]         base::withCallingHandlers({
[17:40:46.797]             ...future.value <- base::withVisible(base::local({
[17:40:46.797]                 ...future.makeSendCondition <- base::local({
[17:40:46.797]                   sendCondition <- NULL
[17:40:46.797]                   function(frame = 1L) {
[17:40:46.797]                     if (is.function(sendCondition)) 
[17:40:46.797]                       return(sendCondition)
[17:40:46.797]                     ns <- getNamespace("parallel")
[17:40:46.797]                     if (exists("sendData", mode = "function", 
[17:40:46.797]                       envir = ns)) {
[17:40:46.797]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:46.797]                         envir = ns)
[17:40:46.797]                       envir <- sys.frame(frame)
[17:40:46.797]                       master <- NULL
[17:40:46.797]                       while (!identical(envir, .GlobalEnv) && 
[17:40:46.797]                         !identical(envir, emptyenv())) {
[17:40:46.797]                         if (exists("master", mode = "list", envir = envir, 
[17:40:46.797]                           inherits = FALSE)) {
[17:40:46.797]                           master <- get("master", mode = "list", 
[17:40:46.797]                             envir = envir, inherits = FALSE)
[17:40:46.797]                           if (inherits(master, c("SOCKnode", 
[17:40:46.797]                             "SOCK0node"))) {
[17:40:46.797]                             sendCondition <<- function(cond) {
[17:40:46.797]                               data <- list(type = "VALUE", value = cond, 
[17:40:46.797]                                 success = TRUE)
[17:40:46.797]                               parallel_sendData(master, data)
[17:40:46.797]                             }
[17:40:46.797]                             return(sendCondition)
[17:40:46.797]                           }
[17:40:46.797]                         }
[17:40:46.797]                         frame <- frame + 1L
[17:40:46.797]                         envir <- sys.frame(frame)
[17:40:46.797]                       }
[17:40:46.797]                     }
[17:40:46.797]                     sendCondition <<- function(cond) NULL
[17:40:46.797]                   }
[17:40:46.797]                 })
[17:40:46.797]                 withCallingHandlers({
[17:40:46.797]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:46.797]                 }, immediateCondition = function(cond) {
[17:40:46.797]                   sendCondition <- ...future.makeSendCondition()
[17:40:46.797]                   sendCondition(cond)
[17:40:46.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.797]                   {
[17:40:46.797]                     inherits <- base::inherits
[17:40:46.797]                     invokeRestart <- base::invokeRestart
[17:40:46.797]                     is.null <- base::is.null
[17:40:46.797]                     muffled <- FALSE
[17:40:46.797]                     if (inherits(cond, "message")) {
[17:40:46.797]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:46.797]                       if (muffled) 
[17:40:46.797]                         invokeRestart("muffleMessage")
[17:40:46.797]                     }
[17:40:46.797]                     else if (inherits(cond, "warning")) {
[17:40:46.797]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:46.797]                       if (muffled) 
[17:40:46.797]                         invokeRestart("muffleWarning")
[17:40:46.797]                     }
[17:40:46.797]                     else if (inherits(cond, "condition")) {
[17:40:46.797]                       if (!is.null(pattern)) {
[17:40:46.797]                         computeRestarts <- base::computeRestarts
[17:40:46.797]                         grepl <- base::grepl
[17:40:46.797]                         restarts <- computeRestarts(cond)
[17:40:46.797]                         for (restart in restarts) {
[17:40:46.797]                           name <- restart$name
[17:40:46.797]                           if (is.null(name)) 
[17:40:46.797]                             next
[17:40:46.797]                           if (!grepl(pattern, name)) 
[17:40:46.797]                             next
[17:40:46.797]                           invokeRestart(restart)
[17:40:46.797]                           muffled <- TRUE
[17:40:46.797]                           break
[17:40:46.797]                         }
[17:40:46.797]                       }
[17:40:46.797]                     }
[17:40:46.797]                     invisible(muffled)
[17:40:46.797]                   }
[17:40:46.797]                   muffleCondition(cond)
[17:40:46.797]                 })
[17:40:46.797]             }))
[17:40:46.797]             future::FutureResult(value = ...future.value$value, 
[17:40:46.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.797]                   ...future.rng), globalenv = if (FALSE) 
[17:40:46.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:46.797]                     ...future.globalenv.names))
[17:40:46.797]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:46.797]         }, condition = base::local({
[17:40:46.797]             c <- base::c
[17:40:46.797]             inherits <- base::inherits
[17:40:46.797]             invokeRestart <- base::invokeRestart
[17:40:46.797]             length <- base::length
[17:40:46.797]             list <- base::list
[17:40:46.797]             seq.int <- base::seq.int
[17:40:46.797]             signalCondition <- base::signalCondition
[17:40:46.797]             sys.calls <- base::sys.calls
[17:40:46.797]             `[[` <- base::`[[`
[17:40:46.797]             `+` <- base::`+`
[17:40:46.797]             `<<-` <- base::`<<-`
[17:40:46.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:46.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:46.797]                   3L)]
[17:40:46.797]             }
[17:40:46.797]             function(cond) {
[17:40:46.797]                 is_error <- inherits(cond, "error")
[17:40:46.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:46.797]                   NULL)
[17:40:46.797]                 if (is_error) {
[17:40:46.797]                   sessionInformation <- function() {
[17:40:46.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:46.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:46.797]                       search = base::search(), system = base::Sys.info())
[17:40:46.797]                   }
[17:40:46.797]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:46.797]                     cond$call), session = sessionInformation(), 
[17:40:46.797]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:46.797]                   signalCondition(cond)
[17:40:46.797]                 }
[17:40:46.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:46.797]                 "immediateCondition"))) {
[17:40:46.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:46.797]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:46.797]                   if (TRUE && !signal) {
[17:40:46.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.797]                     {
[17:40:46.797]                       inherits <- base::inherits
[17:40:46.797]                       invokeRestart <- base::invokeRestart
[17:40:46.797]                       is.null <- base::is.null
[17:40:46.797]                       muffled <- FALSE
[17:40:46.797]                       if (inherits(cond, "message")) {
[17:40:46.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.797]                         if (muffled) 
[17:40:46.797]                           invokeRestart("muffleMessage")
[17:40:46.797]                       }
[17:40:46.797]                       else if (inherits(cond, "warning")) {
[17:40:46.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.797]                         if (muffled) 
[17:40:46.797]                           invokeRestart("muffleWarning")
[17:40:46.797]                       }
[17:40:46.797]                       else if (inherits(cond, "condition")) {
[17:40:46.797]                         if (!is.null(pattern)) {
[17:40:46.797]                           computeRestarts <- base::computeRestarts
[17:40:46.797]                           grepl <- base::grepl
[17:40:46.797]                           restarts <- computeRestarts(cond)
[17:40:46.797]                           for (restart in restarts) {
[17:40:46.797]                             name <- restart$name
[17:40:46.797]                             if (is.null(name)) 
[17:40:46.797]                               next
[17:40:46.797]                             if (!grepl(pattern, name)) 
[17:40:46.797]                               next
[17:40:46.797]                             invokeRestart(restart)
[17:40:46.797]                             muffled <- TRUE
[17:40:46.797]                             break
[17:40:46.797]                           }
[17:40:46.797]                         }
[17:40:46.797]                       }
[17:40:46.797]                       invisible(muffled)
[17:40:46.797]                     }
[17:40:46.797]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.797]                   }
[17:40:46.797]                 }
[17:40:46.797]                 else {
[17:40:46.797]                   if (TRUE) {
[17:40:46.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.797]                     {
[17:40:46.797]                       inherits <- base::inherits
[17:40:46.797]                       invokeRestart <- base::invokeRestart
[17:40:46.797]                       is.null <- base::is.null
[17:40:46.797]                       muffled <- FALSE
[17:40:46.797]                       if (inherits(cond, "message")) {
[17:40:46.797]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.797]                         if (muffled) 
[17:40:46.797]                           invokeRestart("muffleMessage")
[17:40:46.797]                       }
[17:40:46.797]                       else if (inherits(cond, "warning")) {
[17:40:46.797]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.797]                         if (muffled) 
[17:40:46.797]                           invokeRestart("muffleWarning")
[17:40:46.797]                       }
[17:40:46.797]                       else if (inherits(cond, "condition")) {
[17:40:46.797]                         if (!is.null(pattern)) {
[17:40:46.797]                           computeRestarts <- base::computeRestarts
[17:40:46.797]                           grepl <- base::grepl
[17:40:46.797]                           restarts <- computeRestarts(cond)
[17:40:46.797]                           for (restart in restarts) {
[17:40:46.797]                             name <- restart$name
[17:40:46.797]                             if (is.null(name)) 
[17:40:46.797]                               next
[17:40:46.797]                             if (!grepl(pattern, name)) 
[17:40:46.797]                               next
[17:40:46.797]                             invokeRestart(restart)
[17:40:46.797]                             muffled <- TRUE
[17:40:46.797]                             break
[17:40:46.797]                           }
[17:40:46.797]                         }
[17:40:46.797]                       }
[17:40:46.797]                       invisible(muffled)
[17:40:46.797]                     }
[17:40:46.797]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.797]                   }
[17:40:46.797]                 }
[17:40:46.797]             }
[17:40:46.797]         }))
[17:40:46.797]     }, error = function(ex) {
[17:40:46.797]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:46.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.797]                 ...future.rng), started = ...future.startTime, 
[17:40:46.797]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:46.797]             version = "1.8"), class = "FutureResult")
[17:40:46.797]     }, finally = {
[17:40:46.797]         if (!identical(...future.workdir, getwd())) 
[17:40:46.797]             setwd(...future.workdir)
[17:40:46.797]         {
[17:40:46.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:46.797]                 ...future.oldOptions$nwarnings <- NULL
[17:40:46.797]             }
[17:40:46.797]             base::options(...future.oldOptions)
[17:40:46.797]             if (.Platform$OS.type == "windows") {
[17:40:46.797]                 old_names <- names(...future.oldEnvVars)
[17:40:46.797]                 envs <- base::Sys.getenv()
[17:40:46.797]                 names <- names(envs)
[17:40:46.797]                 common <- intersect(names, old_names)
[17:40:46.797]                 added <- setdiff(names, old_names)
[17:40:46.797]                 removed <- setdiff(old_names, names)
[17:40:46.797]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:46.797]                   envs[common]]
[17:40:46.797]                 NAMES <- toupper(changed)
[17:40:46.797]                 args <- list()
[17:40:46.797]                 for (kk in seq_along(NAMES)) {
[17:40:46.797]                   name <- changed[[kk]]
[17:40:46.797]                   NAME <- NAMES[[kk]]
[17:40:46.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.797]                     next
[17:40:46.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.797]                 }
[17:40:46.797]                 NAMES <- toupper(added)
[17:40:46.797]                 for (kk in seq_along(NAMES)) {
[17:40:46.797]                   name <- added[[kk]]
[17:40:46.797]                   NAME <- NAMES[[kk]]
[17:40:46.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.797]                     next
[17:40:46.797]                   args[[name]] <- ""
[17:40:46.797]                 }
[17:40:46.797]                 NAMES <- toupper(removed)
[17:40:46.797]                 for (kk in seq_along(NAMES)) {
[17:40:46.797]                   name <- removed[[kk]]
[17:40:46.797]                   NAME <- NAMES[[kk]]
[17:40:46.797]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.797]                     next
[17:40:46.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.797]                 }
[17:40:46.797]                 if (length(args) > 0) 
[17:40:46.797]                   base::do.call(base::Sys.setenv, args = args)
[17:40:46.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:46.797]             }
[17:40:46.797]             else {
[17:40:46.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:46.797]             }
[17:40:46.797]             {
[17:40:46.797]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:46.797]                   0L) {
[17:40:46.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:46.797]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:46.797]                   base::options(opts)
[17:40:46.797]                 }
[17:40:46.797]                 {
[17:40:46.797]                   {
[17:40:46.797]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:46.797]                     NULL
[17:40:46.797]                   }
[17:40:46.797]                   options(future.plan = NULL)
[17:40:46.797]                   if (is.na(NA_character_)) 
[17:40:46.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:46.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:46.797]                     .init = FALSE)
[17:40:46.797]                 }
[17:40:46.797]             }
[17:40:46.797]         }
[17:40:46.797]     })
[17:40:46.797]     if (TRUE) {
[17:40:46.797]         base::sink(type = "output", split = FALSE)
[17:40:46.797]         if (TRUE) {
[17:40:46.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:46.797]         }
[17:40:46.797]         else {
[17:40:46.797]             ...future.result["stdout"] <- base::list(NULL)
[17:40:46.797]         }
[17:40:46.797]         base::close(...future.stdout)
[17:40:46.797]         ...future.stdout <- NULL
[17:40:46.797]     }
[17:40:46.797]     ...future.result$conditions <- ...future.conditions
[17:40:46.797]     ...future.result$finished <- base::Sys.time()
[17:40:46.797]     ...future.result
[17:40:46.797] }
[17:40:46.800] MultisessionFuture started
[17:40:46.800] - Launch lazy future ... done
[17:40:46.801] run() for ‘MultisessionFuture’ ... done
[17:40:46.802] receiveMessageFromWorker() for ClusterFuture ...
[17:40:46.802] - Validating connection of MultisessionFuture
[17:40:46.803] - received message: FutureResult
[17:40:46.803] - Received FutureResult
[17:40:46.803] - Erased future from FutureRegistry
[17:40:46.803] result() for ClusterFuture ...
[17:40:46.803] - result already collected: FutureResult
[17:40:46.803] result() for ClusterFuture ... done
[17:40:46.804] signalConditions() ...
[17:40:46.804]  - include = ‘immediateCondition’
[17:40:46.804]  - exclude = 
[17:40:46.804]  - resignal = FALSE
[17:40:46.804]  - Number of conditions: 1
[17:40:46.804] signalConditions() ... done
[17:40:46.804] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:46.804] A MultisessionFuture was resolved (result was not collected)
[17:40:46.804] getGlobalsAndPackages() ...
[17:40:46.804] Searching for globals...
[17:40:46.805] - globals found: [2] ‘list’, ‘stop’
[17:40:46.805] Searching for globals ... DONE
[17:40:46.805] Resolving globals: FALSE
[17:40:46.806] 
[17:40:46.806] 
[17:40:46.806] getGlobalsAndPackages() ... DONE
[17:40:46.806] run() for ‘Future’ ...
[17:40:46.806] - state: ‘created’
[17:40:46.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:46.819] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:46.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:46.820]   - Field: ‘node’
[17:40:46.820]   - Field: ‘label’
[17:40:46.820]   - Field: ‘local’
[17:40:46.820]   - Field: ‘owner’
[17:40:46.820]   - Field: ‘envir’
[17:40:46.820]   - Field: ‘workers’
[17:40:46.820]   - Field: ‘packages’
[17:40:46.820]   - Field: ‘gc’
[17:40:46.820]   - Field: ‘conditions’
[17:40:46.821]   - Field: ‘persistent’
[17:40:46.821]   - Field: ‘expr’
[17:40:46.821]   - Field: ‘uuid’
[17:40:46.821]   - Field: ‘seed’
[17:40:46.821]   - Field: ‘version’
[17:40:46.821]   - Field: ‘result’
[17:40:46.821]   - Field: ‘asynchronous’
[17:40:46.821]   - Field: ‘calls’
[17:40:46.821]   - Field: ‘globals’
[17:40:46.821]   - Field: ‘stdout’
[17:40:46.821]   - Field: ‘earlySignal’
[17:40:46.822]   - Field: ‘lazy’
[17:40:46.822]   - Field: ‘state’
[17:40:46.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:46.822] - Launch lazy future ...
[17:40:46.822] Packages needed by the future expression (n = 0): <none>
[17:40:46.822] Packages needed by future strategies (n = 0): <none>
[17:40:46.823] {
[17:40:46.823]     {
[17:40:46.823]         {
[17:40:46.823]             ...future.startTime <- base::Sys.time()
[17:40:46.823]             {
[17:40:46.823]                 {
[17:40:46.823]                   {
[17:40:46.823]                     {
[17:40:46.823]                       base::local({
[17:40:46.823]                         has_future <- base::requireNamespace("future", 
[17:40:46.823]                           quietly = TRUE)
[17:40:46.823]                         if (has_future) {
[17:40:46.823]                           ns <- base::getNamespace("future")
[17:40:46.823]                           version <- ns[[".package"]][["version"]]
[17:40:46.823]                           if (is.null(version)) 
[17:40:46.823]                             version <- utils::packageVersion("future")
[17:40:46.823]                         }
[17:40:46.823]                         else {
[17:40:46.823]                           version <- NULL
[17:40:46.823]                         }
[17:40:46.823]                         if (!has_future || version < "1.8.0") {
[17:40:46.823]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:46.823]                             "", base::R.version$version.string), 
[17:40:46.823]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:46.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:46.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:46.823]                               "release", "version")], collapse = " "), 
[17:40:46.823]                             hostname = base::Sys.info()[["nodename"]])
[17:40:46.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:46.823]                             info)
[17:40:46.823]                           info <- base::paste(info, collapse = "; ")
[17:40:46.823]                           if (!has_future) {
[17:40:46.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:46.823]                               info)
[17:40:46.823]                           }
[17:40:46.823]                           else {
[17:40:46.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:46.823]                               info, version)
[17:40:46.823]                           }
[17:40:46.823]                           base::stop(msg)
[17:40:46.823]                         }
[17:40:46.823]                       })
[17:40:46.823]                     }
[17:40:46.823]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:46.823]                     base::options(mc.cores = 1L)
[17:40:46.823]                   }
[17:40:46.823]                   ...future.strategy.old <- future::plan("list")
[17:40:46.823]                   options(future.plan = NULL)
[17:40:46.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:46.823]                 }
[17:40:46.823]                 ...future.workdir <- getwd()
[17:40:46.823]             }
[17:40:46.823]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:46.823]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:46.823]         }
[17:40:46.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:46.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:46.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:46.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:46.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:46.823]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:46.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:46.823]             base::names(...future.oldOptions))
[17:40:46.823]     }
[17:40:46.823]     if (FALSE) {
[17:40:46.823]     }
[17:40:46.823]     else {
[17:40:46.823]         if (TRUE) {
[17:40:46.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:46.823]                 open = "w")
[17:40:46.823]         }
[17:40:46.823]         else {
[17:40:46.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:46.823]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:46.823]         }
[17:40:46.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:46.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:46.823]             base::sink(type = "output", split = FALSE)
[17:40:46.823]             base::close(...future.stdout)
[17:40:46.823]         }, add = TRUE)
[17:40:46.823]     }
[17:40:46.823]     ...future.frame <- base::sys.nframe()
[17:40:46.823]     ...future.conditions <- base::list()
[17:40:46.823]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:46.823]     if (FALSE) {
[17:40:46.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:46.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:46.823]     }
[17:40:46.823]     ...future.result <- base::tryCatch({
[17:40:46.823]         base::withCallingHandlers({
[17:40:46.823]             ...future.value <- base::withVisible(base::local({
[17:40:46.823]                 ...future.makeSendCondition <- base::local({
[17:40:46.823]                   sendCondition <- NULL
[17:40:46.823]                   function(frame = 1L) {
[17:40:46.823]                     if (is.function(sendCondition)) 
[17:40:46.823]                       return(sendCondition)
[17:40:46.823]                     ns <- getNamespace("parallel")
[17:40:46.823]                     if (exists("sendData", mode = "function", 
[17:40:46.823]                       envir = ns)) {
[17:40:46.823]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:46.823]                         envir = ns)
[17:40:46.823]                       envir <- sys.frame(frame)
[17:40:46.823]                       master <- NULL
[17:40:46.823]                       while (!identical(envir, .GlobalEnv) && 
[17:40:46.823]                         !identical(envir, emptyenv())) {
[17:40:46.823]                         if (exists("master", mode = "list", envir = envir, 
[17:40:46.823]                           inherits = FALSE)) {
[17:40:46.823]                           master <- get("master", mode = "list", 
[17:40:46.823]                             envir = envir, inherits = FALSE)
[17:40:46.823]                           if (inherits(master, c("SOCKnode", 
[17:40:46.823]                             "SOCK0node"))) {
[17:40:46.823]                             sendCondition <<- function(cond) {
[17:40:46.823]                               data <- list(type = "VALUE", value = cond, 
[17:40:46.823]                                 success = TRUE)
[17:40:46.823]                               parallel_sendData(master, data)
[17:40:46.823]                             }
[17:40:46.823]                             return(sendCondition)
[17:40:46.823]                           }
[17:40:46.823]                         }
[17:40:46.823]                         frame <- frame + 1L
[17:40:46.823]                         envir <- sys.frame(frame)
[17:40:46.823]                       }
[17:40:46.823]                     }
[17:40:46.823]                     sendCondition <<- function(cond) NULL
[17:40:46.823]                   }
[17:40:46.823]                 })
[17:40:46.823]                 withCallingHandlers({
[17:40:46.823]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:46.823]                 }, immediateCondition = function(cond) {
[17:40:46.823]                   sendCondition <- ...future.makeSendCondition()
[17:40:46.823]                   sendCondition(cond)
[17:40:46.823]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.823]                   {
[17:40:46.823]                     inherits <- base::inherits
[17:40:46.823]                     invokeRestart <- base::invokeRestart
[17:40:46.823]                     is.null <- base::is.null
[17:40:46.823]                     muffled <- FALSE
[17:40:46.823]                     if (inherits(cond, "message")) {
[17:40:46.823]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:46.823]                       if (muffled) 
[17:40:46.823]                         invokeRestart("muffleMessage")
[17:40:46.823]                     }
[17:40:46.823]                     else if (inherits(cond, "warning")) {
[17:40:46.823]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:46.823]                       if (muffled) 
[17:40:46.823]                         invokeRestart("muffleWarning")
[17:40:46.823]                     }
[17:40:46.823]                     else if (inherits(cond, "condition")) {
[17:40:46.823]                       if (!is.null(pattern)) {
[17:40:46.823]                         computeRestarts <- base::computeRestarts
[17:40:46.823]                         grepl <- base::grepl
[17:40:46.823]                         restarts <- computeRestarts(cond)
[17:40:46.823]                         for (restart in restarts) {
[17:40:46.823]                           name <- restart$name
[17:40:46.823]                           if (is.null(name)) 
[17:40:46.823]                             next
[17:40:46.823]                           if (!grepl(pattern, name)) 
[17:40:46.823]                             next
[17:40:46.823]                           invokeRestart(restart)
[17:40:46.823]                           muffled <- TRUE
[17:40:46.823]                           break
[17:40:46.823]                         }
[17:40:46.823]                       }
[17:40:46.823]                     }
[17:40:46.823]                     invisible(muffled)
[17:40:46.823]                   }
[17:40:46.823]                   muffleCondition(cond)
[17:40:46.823]                 })
[17:40:46.823]             }))
[17:40:46.823]             future::FutureResult(value = ...future.value$value, 
[17:40:46.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.823]                   ...future.rng), globalenv = if (FALSE) 
[17:40:46.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:46.823]                     ...future.globalenv.names))
[17:40:46.823]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:46.823]         }, condition = base::local({
[17:40:46.823]             c <- base::c
[17:40:46.823]             inherits <- base::inherits
[17:40:46.823]             invokeRestart <- base::invokeRestart
[17:40:46.823]             length <- base::length
[17:40:46.823]             list <- base::list
[17:40:46.823]             seq.int <- base::seq.int
[17:40:46.823]             signalCondition <- base::signalCondition
[17:40:46.823]             sys.calls <- base::sys.calls
[17:40:46.823]             `[[` <- base::`[[`
[17:40:46.823]             `+` <- base::`+`
[17:40:46.823]             `<<-` <- base::`<<-`
[17:40:46.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:46.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:46.823]                   3L)]
[17:40:46.823]             }
[17:40:46.823]             function(cond) {
[17:40:46.823]                 is_error <- inherits(cond, "error")
[17:40:46.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:46.823]                   NULL)
[17:40:46.823]                 if (is_error) {
[17:40:46.823]                   sessionInformation <- function() {
[17:40:46.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:46.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:46.823]                       search = base::search(), system = base::Sys.info())
[17:40:46.823]                   }
[17:40:46.823]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:46.823]                     cond$call), session = sessionInformation(), 
[17:40:46.823]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:46.823]                   signalCondition(cond)
[17:40:46.823]                 }
[17:40:46.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:46.823]                 "immediateCondition"))) {
[17:40:46.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:46.823]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:46.823]                   if (TRUE && !signal) {
[17:40:46.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.823]                     {
[17:40:46.823]                       inherits <- base::inherits
[17:40:46.823]                       invokeRestart <- base::invokeRestart
[17:40:46.823]                       is.null <- base::is.null
[17:40:46.823]                       muffled <- FALSE
[17:40:46.823]                       if (inherits(cond, "message")) {
[17:40:46.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.823]                         if (muffled) 
[17:40:46.823]                           invokeRestart("muffleMessage")
[17:40:46.823]                       }
[17:40:46.823]                       else if (inherits(cond, "warning")) {
[17:40:46.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.823]                         if (muffled) 
[17:40:46.823]                           invokeRestart("muffleWarning")
[17:40:46.823]                       }
[17:40:46.823]                       else if (inherits(cond, "condition")) {
[17:40:46.823]                         if (!is.null(pattern)) {
[17:40:46.823]                           computeRestarts <- base::computeRestarts
[17:40:46.823]                           grepl <- base::grepl
[17:40:46.823]                           restarts <- computeRestarts(cond)
[17:40:46.823]                           for (restart in restarts) {
[17:40:46.823]                             name <- restart$name
[17:40:46.823]                             if (is.null(name)) 
[17:40:46.823]                               next
[17:40:46.823]                             if (!grepl(pattern, name)) 
[17:40:46.823]                               next
[17:40:46.823]                             invokeRestart(restart)
[17:40:46.823]                             muffled <- TRUE
[17:40:46.823]                             break
[17:40:46.823]                           }
[17:40:46.823]                         }
[17:40:46.823]                       }
[17:40:46.823]                       invisible(muffled)
[17:40:46.823]                     }
[17:40:46.823]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.823]                   }
[17:40:46.823]                 }
[17:40:46.823]                 else {
[17:40:46.823]                   if (TRUE) {
[17:40:46.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.823]                     {
[17:40:46.823]                       inherits <- base::inherits
[17:40:46.823]                       invokeRestart <- base::invokeRestart
[17:40:46.823]                       is.null <- base::is.null
[17:40:46.823]                       muffled <- FALSE
[17:40:46.823]                       if (inherits(cond, "message")) {
[17:40:46.823]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.823]                         if (muffled) 
[17:40:46.823]                           invokeRestart("muffleMessage")
[17:40:46.823]                       }
[17:40:46.823]                       else if (inherits(cond, "warning")) {
[17:40:46.823]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.823]                         if (muffled) 
[17:40:46.823]                           invokeRestart("muffleWarning")
[17:40:46.823]                       }
[17:40:46.823]                       else if (inherits(cond, "condition")) {
[17:40:46.823]                         if (!is.null(pattern)) {
[17:40:46.823]                           computeRestarts <- base::computeRestarts
[17:40:46.823]                           grepl <- base::grepl
[17:40:46.823]                           restarts <- computeRestarts(cond)
[17:40:46.823]                           for (restart in restarts) {
[17:40:46.823]                             name <- restart$name
[17:40:46.823]                             if (is.null(name)) 
[17:40:46.823]                               next
[17:40:46.823]                             if (!grepl(pattern, name)) 
[17:40:46.823]                               next
[17:40:46.823]                             invokeRestart(restart)
[17:40:46.823]                             muffled <- TRUE
[17:40:46.823]                             break
[17:40:46.823]                           }
[17:40:46.823]                         }
[17:40:46.823]                       }
[17:40:46.823]                       invisible(muffled)
[17:40:46.823]                     }
[17:40:46.823]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.823]                   }
[17:40:46.823]                 }
[17:40:46.823]             }
[17:40:46.823]         }))
[17:40:46.823]     }, error = function(ex) {
[17:40:46.823]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:46.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.823]                 ...future.rng), started = ...future.startTime, 
[17:40:46.823]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:46.823]             version = "1.8"), class = "FutureResult")
[17:40:46.823]     }, finally = {
[17:40:46.823]         if (!identical(...future.workdir, getwd())) 
[17:40:46.823]             setwd(...future.workdir)
[17:40:46.823]         {
[17:40:46.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:46.823]                 ...future.oldOptions$nwarnings <- NULL
[17:40:46.823]             }
[17:40:46.823]             base::options(...future.oldOptions)
[17:40:46.823]             if (.Platform$OS.type == "windows") {
[17:40:46.823]                 old_names <- names(...future.oldEnvVars)
[17:40:46.823]                 envs <- base::Sys.getenv()
[17:40:46.823]                 names <- names(envs)
[17:40:46.823]                 common <- intersect(names, old_names)
[17:40:46.823]                 added <- setdiff(names, old_names)
[17:40:46.823]                 removed <- setdiff(old_names, names)
[17:40:46.823]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:46.823]                   envs[common]]
[17:40:46.823]                 NAMES <- toupper(changed)
[17:40:46.823]                 args <- list()
[17:40:46.823]                 for (kk in seq_along(NAMES)) {
[17:40:46.823]                   name <- changed[[kk]]
[17:40:46.823]                   NAME <- NAMES[[kk]]
[17:40:46.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.823]                     next
[17:40:46.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.823]                 }
[17:40:46.823]                 NAMES <- toupper(added)
[17:40:46.823]                 for (kk in seq_along(NAMES)) {
[17:40:46.823]                   name <- added[[kk]]
[17:40:46.823]                   NAME <- NAMES[[kk]]
[17:40:46.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.823]                     next
[17:40:46.823]                   args[[name]] <- ""
[17:40:46.823]                 }
[17:40:46.823]                 NAMES <- toupper(removed)
[17:40:46.823]                 for (kk in seq_along(NAMES)) {
[17:40:46.823]                   name <- removed[[kk]]
[17:40:46.823]                   NAME <- NAMES[[kk]]
[17:40:46.823]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.823]                     next
[17:40:46.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.823]                 }
[17:40:46.823]                 if (length(args) > 0) 
[17:40:46.823]                   base::do.call(base::Sys.setenv, args = args)
[17:40:46.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:46.823]             }
[17:40:46.823]             else {
[17:40:46.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:46.823]             }
[17:40:46.823]             {
[17:40:46.823]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:46.823]                   0L) {
[17:40:46.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:46.823]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:46.823]                   base::options(opts)
[17:40:46.823]                 }
[17:40:46.823]                 {
[17:40:46.823]                   {
[17:40:46.823]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:46.823]                     NULL
[17:40:46.823]                   }
[17:40:46.823]                   options(future.plan = NULL)
[17:40:46.823]                   if (is.na(NA_character_)) 
[17:40:46.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:46.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:46.823]                     .init = FALSE)
[17:40:46.823]                 }
[17:40:46.823]             }
[17:40:46.823]         }
[17:40:46.823]     })
[17:40:46.823]     if (TRUE) {
[17:40:46.823]         base::sink(type = "output", split = FALSE)
[17:40:46.823]         if (TRUE) {
[17:40:46.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:46.823]         }
[17:40:46.823]         else {
[17:40:46.823]             ...future.result["stdout"] <- base::list(NULL)
[17:40:46.823]         }
[17:40:46.823]         base::close(...future.stdout)
[17:40:46.823]         ...future.stdout <- NULL
[17:40:46.823]     }
[17:40:46.823]     ...future.result$conditions <- ...future.conditions
[17:40:46.823]     ...future.result$finished <- base::Sys.time()
[17:40:46.823]     ...future.result
[17:40:46.823] }
[17:40:46.825] MultisessionFuture started
[17:40:46.825] - Launch lazy future ... done
[17:40:46.826] run() for ‘MultisessionFuture’ ... done
[17:40:46.827] receiveMessageFromWorker() for ClusterFuture ...
[17:40:46.827] - Validating connection of MultisessionFuture
[17:40:46.828] - received message: FutureResult
[17:40:46.828] - Received FutureResult
[17:40:46.828] - Erased future from FutureRegistry
[17:40:46.828] result() for ClusterFuture ...
[17:40:46.828] - result already collected: FutureResult
[17:40:46.828] result() for ClusterFuture ... done
[17:40:46.828] signalConditions() ...
[17:40:46.829]  - include = ‘immediateCondition’
[17:40:46.829]  - exclude = 
[17:40:46.829]  - resignal = FALSE
[17:40:46.829]  - Number of conditions: 1
[17:40:46.829] signalConditions() ... done
[17:40:46.829] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:46.829] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[17:40:46.829] getGlobalsAndPackages() ...
[17:40:46.829] Searching for globals...
[17:40:46.830] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:46.831] Searching for globals ... DONE
[17:40:46.831] Resolving globals: FALSE
[17:40:46.831] 
[17:40:46.831] 
[17:40:46.831] getGlobalsAndPackages() ... DONE
[17:40:46.831] run() for ‘Future’ ...
[17:40:46.831] - state: ‘created’
[17:40:46.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:46.846] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:46.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:46.846]   - Field: ‘node’
[17:40:46.846]   - Field: ‘label’
[17:40:46.846]   - Field: ‘local’
[17:40:46.846]   - Field: ‘owner’
[17:40:46.846]   - Field: ‘envir’
[17:40:46.846]   - Field: ‘workers’
[17:40:46.846]   - Field: ‘packages’
[17:40:46.847]   - Field: ‘gc’
[17:40:46.847]   - Field: ‘conditions’
[17:40:46.847]   - Field: ‘persistent’
[17:40:46.847]   - Field: ‘expr’
[17:40:46.847]   - Field: ‘uuid’
[17:40:46.847]   - Field: ‘seed’
[17:40:46.847]   - Field: ‘version’
[17:40:46.847]   - Field: ‘result’
[17:40:46.847]   - Field: ‘asynchronous’
[17:40:46.847]   - Field: ‘calls’
[17:40:46.847]   - Field: ‘globals’
[17:40:46.848]   - Field: ‘stdout’
[17:40:46.848]   - Field: ‘earlySignal’
[17:40:46.848]   - Field: ‘lazy’
[17:40:46.848]   - Field: ‘state’
[17:40:46.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:46.848] - Launch lazy future ...
[17:40:46.848] Packages needed by the future expression (n = 0): <none>
[17:40:46.848] Packages needed by future strategies (n = 0): <none>
[17:40:46.849] {
[17:40:46.849]     {
[17:40:46.849]         {
[17:40:46.849]             ...future.startTime <- base::Sys.time()
[17:40:46.849]             {
[17:40:46.849]                 {
[17:40:46.849]                   {
[17:40:46.849]                     {
[17:40:46.849]                       base::local({
[17:40:46.849]                         has_future <- base::requireNamespace("future", 
[17:40:46.849]                           quietly = TRUE)
[17:40:46.849]                         if (has_future) {
[17:40:46.849]                           ns <- base::getNamespace("future")
[17:40:46.849]                           version <- ns[[".package"]][["version"]]
[17:40:46.849]                           if (is.null(version)) 
[17:40:46.849]                             version <- utils::packageVersion("future")
[17:40:46.849]                         }
[17:40:46.849]                         else {
[17:40:46.849]                           version <- NULL
[17:40:46.849]                         }
[17:40:46.849]                         if (!has_future || version < "1.8.0") {
[17:40:46.849]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:46.849]                             "", base::R.version$version.string), 
[17:40:46.849]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:46.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:46.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:46.849]                               "release", "version")], collapse = " "), 
[17:40:46.849]                             hostname = base::Sys.info()[["nodename"]])
[17:40:46.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:46.849]                             info)
[17:40:46.849]                           info <- base::paste(info, collapse = "; ")
[17:40:46.849]                           if (!has_future) {
[17:40:46.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:46.849]                               info)
[17:40:46.849]                           }
[17:40:46.849]                           else {
[17:40:46.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:46.849]                               info, version)
[17:40:46.849]                           }
[17:40:46.849]                           base::stop(msg)
[17:40:46.849]                         }
[17:40:46.849]                       })
[17:40:46.849]                     }
[17:40:46.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:46.849]                     base::options(mc.cores = 1L)
[17:40:46.849]                   }
[17:40:46.849]                   ...future.strategy.old <- future::plan("list")
[17:40:46.849]                   options(future.plan = NULL)
[17:40:46.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:46.849]                 }
[17:40:46.849]                 ...future.workdir <- getwd()
[17:40:46.849]             }
[17:40:46.849]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:46.849]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:46.849]         }
[17:40:46.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:46.849]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:46.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:46.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:46.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:46.849]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:46.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:46.849]             base::names(...future.oldOptions))
[17:40:46.849]     }
[17:40:46.849]     if (FALSE) {
[17:40:46.849]     }
[17:40:46.849]     else {
[17:40:46.849]         if (TRUE) {
[17:40:46.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:46.849]                 open = "w")
[17:40:46.849]         }
[17:40:46.849]         else {
[17:40:46.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:46.849]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:46.849]         }
[17:40:46.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:46.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:46.849]             base::sink(type = "output", split = FALSE)
[17:40:46.849]             base::close(...future.stdout)
[17:40:46.849]         }, add = TRUE)
[17:40:46.849]     }
[17:40:46.849]     ...future.frame <- base::sys.nframe()
[17:40:46.849]     ...future.conditions <- base::list()
[17:40:46.849]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:46.849]     if (FALSE) {
[17:40:46.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:46.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:46.849]     }
[17:40:46.849]     ...future.result <- base::tryCatch({
[17:40:46.849]         base::withCallingHandlers({
[17:40:46.849]             ...future.value <- base::withVisible(base::local({
[17:40:46.849]                 ...future.makeSendCondition <- base::local({
[17:40:46.849]                   sendCondition <- NULL
[17:40:46.849]                   function(frame = 1L) {
[17:40:46.849]                     if (is.function(sendCondition)) 
[17:40:46.849]                       return(sendCondition)
[17:40:46.849]                     ns <- getNamespace("parallel")
[17:40:46.849]                     if (exists("sendData", mode = "function", 
[17:40:46.849]                       envir = ns)) {
[17:40:46.849]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:46.849]                         envir = ns)
[17:40:46.849]                       envir <- sys.frame(frame)
[17:40:46.849]                       master <- NULL
[17:40:46.849]                       while (!identical(envir, .GlobalEnv) && 
[17:40:46.849]                         !identical(envir, emptyenv())) {
[17:40:46.849]                         if (exists("master", mode = "list", envir = envir, 
[17:40:46.849]                           inherits = FALSE)) {
[17:40:46.849]                           master <- get("master", mode = "list", 
[17:40:46.849]                             envir = envir, inherits = FALSE)
[17:40:46.849]                           if (inherits(master, c("SOCKnode", 
[17:40:46.849]                             "SOCK0node"))) {
[17:40:46.849]                             sendCondition <<- function(cond) {
[17:40:46.849]                               data <- list(type = "VALUE", value = cond, 
[17:40:46.849]                                 success = TRUE)
[17:40:46.849]                               parallel_sendData(master, data)
[17:40:46.849]                             }
[17:40:46.849]                             return(sendCondition)
[17:40:46.849]                           }
[17:40:46.849]                         }
[17:40:46.849]                         frame <- frame + 1L
[17:40:46.849]                         envir <- sys.frame(frame)
[17:40:46.849]                       }
[17:40:46.849]                     }
[17:40:46.849]                     sendCondition <<- function(cond) NULL
[17:40:46.849]                   }
[17:40:46.849]                 })
[17:40:46.849]                 withCallingHandlers({
[17:40:46.849]                   {
[17:40:46.849]                     Sys.sleep(0.5)
[17:40:46.849]                     list(a = 1, b = 42L)
[17:40:46.849]                   }
[17:40:46.849]                 }, immediateCondition = function(cond) {
[17:40:46.849]                   sendCondition <- ...future.makeSendCondition()
[17:40:46.849]                   sendCondition(cond)
[17:40:46.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.849]                   {
[17:40:46.849]                     inherits <- base::inherits
[17:40:46.849]                     invokeRestart <- base::invokeRestart
[17:40:46.849]                     is.null <- base::is.null
[17:40:46.849]                     muffled <- FALSE
[17:40:46.849]                     if (inherits(cond, "message")) {
[17:40:46.849]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:46.849]                       if (muffled) 
[17:40:46.849]                         invokeRestart("muffleMessage")
[17:40:46.849]                     }
[17:40:46.849]                     else if (inherits(cond, "warning")) {
[17:40:46.849]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:46.849]                       if (muffled) 
[17:40:46.849]                         invokeRestart("muffleWarning")
[17:40:46.849]                     }
[17:40:46.849]                     else if (inherits(cond, "condition")) {
[17:40:46.849]                       if (!is.null(pattern)) {
[17:40:46.849]                         computeRestarts <- base::computeRestarts
[17:40:46.849]                         grepl <- base::grepl
[17:40:46.849]                         restarts <- computeRestarts(cond)
[17:40:46.849]                         for (restart in restarts) {
[17:40:46.849]                           name <- restart$name
[17:40:46.849]                           if (is.null(name)) 
[17:40:46.849]                             next
[17:40:46.849]                           if (!grepl(pattern, name)) 
[17:40:46.849]                             next
[17:40:46.849]                           invokeRestart(restart)
[17:40:46.849]                           muffled <- TRUE
[17:40:46.849]                           break
[17:40:46.849]                         }
[17:40:46.849]                       }
[17:40:46.849]                     }
[17:40:46.849]                     invisible(muffled)
[17:40:46.849]                   }
[17:40:46.849]                   muffleCondition(cond)
[17:40:46.849]                 })
[17:40:46.849]             }))
[17:40:46.849]             future::FutureResult(value = ...future.value$value, 
[17:40:46.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.849]                   ...future.rng), globalenv = if (FALSE) 
[17:40:46.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:46.849]                     ...future.globalenv.names))
[17:40:46.849]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:46.849]         }, condition = base::local({
[17:40:46.849]             c <- base::c
[17:40:46.849]             inherits <- base::inherits
[17:40:46.849]             invokeRestart <- base::invokeRestart
[17:40:46.849]             length <- base::length
[17:40:46.849]             list <- base::list
[17:40:46.849]             seq.int <- base::seq.int
[17:40:46.849]             signalCondition <- base::signalCondition
[17:40:46.849]             sys.calls <- base::sys.calls
[17:40:46.849]             `[[` <- base::`[[`
[17:40:46.849]             `+` <- base::`+`
[17:40:46.849]             `<<-` <- base::`<<-`
[17:40:46.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:46.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:46.849]                   3L)]
[17:40:46.849]             }
[17:40:46.849]             function(cond) {
[17:40:46.849]                 is_error <- inherits(cond, "error")
[17:40:46.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:46.849]                   NULL)
[17:40:46.849]                 if (is_error) {
[17:40:46.849]                   sessionInformation <- function() {
[17:40:46.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:46.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:46.849]                       search = base::search(), system = base::Sys.info())
[17:40:46.849]                   }
[17:40:46.849]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:46.849]                     cond$call), session = sessionInformation(), 
[17:40:46.849]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:46.849]                   signalCondition(cond)
[17:40:46.849]                 }
[17:40:46.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:46.849]                 "immediateCondition"))) {
[17:40:46.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:46.849]                   ...future.conditions[[length(...future.conditions) + 
[17:40:46.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:46.849]                   if (TRUE && !signal) {
[17:40:46.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.849]                     {
[17:40:46.849]                       inherits <- base::inherits
[17:40:46.849]                       invokeRestart <- base::invokeRestart
[17:40:46.849]                       is.null <- base::is.null
[17:40:46.849]                       muffled <- FALSE
[17:40:46.849]                       if (inherits(cond, "message")) {
[17:40:46.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.849]                         if (muffled) 
[17:40:46.849]                           invokeRestart("muffleMessage")
[17:40:46.849]                       }
[17:40:46.849]                       else if (inherits(cond, "warning")) {
[17:40:46.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.849]                         if (muffled) 
[17:40:46.849]                           invokeRestart("muffleWarning")
[17:40:46.849]                       }
[17:40:46.849]                       else if (inherits(cond, "condition")) {
[17:40:46.849]                         if (!is.null(pattern)) {
[17:40:46.849]                           computeRestarts <- base::computeRestarts
[17:40:46.849]                           grepl <- base::grepl
[17:40:46.849]                           restarts <- computeRestarts(cond)
[17:40:46.849]                           for (restart in restarts) {
[17:40:46.849]                             name <- restart$name
[17:40:46.849]                             if (is.null(name)) 
[17:40:46.849]                               next
[17:40:46.849]                             if (!grepl(pattern, name)) 
[17:40:46.849]                               next
[17:40:46.849]                             invokeRestart(restart)
[17:40:46.849]                             muffled <- TRUE
[17:40:46.849]                             break
[17:40:46.849]                           }
[17:40:46.849]                         }
[17:40:46.849]                       }
[17:40:46.849]                       invisible(muffled)
[17:40:46.849]                     }
[17:40:46.849]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.849]                   }
[17:40:46.849]                 }
[17:40:46.849]                 else {
[17:40:46.849]                   if (TRUE) {
[17:40:46.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:46.849]                     {
[17:40:46.849]                       inherits <- base::inherits
[17:40:46.849]                       invokeRestart <- base::invokeRestart
[17:40:46.849]                       is.null <- base::is.null
[17:40:46.849]                       muffled <- FALSE
[17:40:46.849]                       if (inherits(cond, "message")) {
[17:40:46.849]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:46.849]                         if (muffled) 
[17:40:46.849]                           invokeRestart("muffleMessage")
[17:40:46.849]                       }
[17:40:46.849]                       else if (inherits(cond, "warning")) {
[17:40:46.849]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:46.849]                         if (muffled) 
[17:40:46.849]                           invokeRestart("muffleWarning")
[17:40:46.849]                       }
[17:40:46.849]                       else if (inherits(cond, "condition")) {
[17:40:46.849]                         if (!is.null(pattern)) {
[17:40:46.849]                           computeRestarts <- base::computeRestarts
[17:40:46.849]                           grepl <- base::grepl
[17:40:46.849]                           restarts <- computeRestarts(cond)
[17:40:46.849]                           for (restart in restarts) {
[17:40:46.849]                             name <- restart$name
[17:40:46.849]                             if (is.null(name)) 
[17:40:46.849]                               next
[17:40:46.849]                             if (!grepl(pattern, name)) 
[17:40:46.849]                               next
[17:40:46.849]                             invokeRestart(restart)
[17:40:46.849]                             muffled <- TRUE
[17:40:46.849]                             break
[17:40:46.849]                           }
[17:40:46.849]                         }
[17:40:46.849]                       }
[17:40:46.849]                       invisible(muffled)
[17:40:46.849]                     }
[17:40:46.849]                     muffleCondition(cond, pattern = "^muffle")
[17:40:46.849]                   }
[17:40:46.849]                 }
[17:40:46.849]             }
[17:40:46.849]         }))
[17:40:46.849]     }, error = function(ex) {
[17:40:46.849]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:46.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:46.849]                 ...future.rng), started = ...future.startTime, 
[17:40:46.849]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:46.849]             version = "1.8"), class = "FutureResult")
[17:40:46.849]     }, finally = {
[17:40:46.849]         if (!identical(...future.workdir, getwd())) 
[17:40:46.849]             setwd(...future.workdir)
[17:40:46.849]         {
[17:40:46.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:46.849]                 ...future.oldOptions$nwarnings <- NULL
[17:40:46.849]             }
[17:40:46.849]             base::options(...future.oldOptions)
[17:40:46.849]             if (.Platform$OS.type == "windows") {
[17:40:46.849]                 old_names <- names(...future.oldEnvVars)
[17:40:46.849]                 envs <- base::Sys.getenv()
[17:40:46.849]                 names <- names(envs)
[17:40:46.849]                 common <- intersect(names, old_names)
[17:40:46.849]                 added <- setdiff(names, old_names)
[17:40:46.849]                 removed <- setdiff(old_names, names)
[17:40:46.849]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:46.849]                   envs[common]]
[17:40:46.849]                 NAMES <- toupper(changed)
[17:40:46.849]                 args <- list()
[17:40:46.849]                 for (kk in seq_along(NAMES)) {
[17:40:46.849]                   name <- changed[[kk]]
[17:40:46.849]                   NAME <- NAMES[[kk]]
[17:40:46.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.849]                     next
[17:40:46.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.849]                 }
[17:40:46.849]                 NAMES <- toupper(added)
[17:40:46.849]                 for (kk in seq_along(NAMES)) {
[17:40:46.849]                   name <- added[[kk]]
[17:40:46.849]                   NAME <- NAMES[[kk]]
[17:40:46.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.849]                     next
[17:40:46.849]                   args[[name]] <- ""
[17:40:46.849]                 }
[17:40:46.849]                 NAMES <- toupper(removed)
[17:40:46.849]                 for (kk in seq_along(NAMES)) {
[17:40:46.849]                   name <- removed[[kk]]
[17:40:46.849]                   NAME <- NAMES[[kk]]
[17:40:46.849]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:46.849]                     next
[17:40:46.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:46.849]                 }
[17:40:46.849]                 if (length(args) > 0) 
[17:40:46.849]                   base::do.call(base::Sys.setenv, args = args)
[17:40:46.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:46.849]             }
[17:40:46.849]             else {
[17:40:46.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:46.849]             }
[17:40:46.849]             {
[17:40:46.849]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:46.849]                   0L) {
[17:40:46.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:46.849]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:46.849]                   base::options(opts)
[17:40:46.849]                 }
[17:40:46.849]                 {
[17:40:46.849]                   {
[17:40:46.849]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:46.849]                     NULL
[17:40:46.849]                   }
[17:40:46.849]                   options(future.plan = NULL)
[17:40:46.849]                   if (is.na(NA_character_)) 
[17:40:46.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:46.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:46.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:46.849]                     .init = FALSE)
[17:40:46.849]                 }
[17:40:46.849]             }
[17:40:46.849]         }
[17:40:46.849]     })
[17:40:46.849]     if (TRUE) {
[17:40:46.849]         base::sink(type = "output", split = FALSE)
[17:40:46.849]         if (TRUE) {
[17:40:46.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:46.849]         }
[17:40:46.849]         else {
[17:40:46.849]             ...future.result["stdout"] <- base::list(NULL)
[17:40:46.849]         }
[17:40:46.849]         base::close(...future.stdout)
[17:40:46.849]         ...future.stdout <- NULL
[17:40:46.849]     }
[17:40:46.849]     ...future.result$conditions <- ...future.conditions
[17:40:46.849]     ...future.result$finished <- base::Sys.time()
[17:40:46.849]     ...future.result
[17:40:46.849] }
[17:40:46.851] MultisessionFuture started
[17:40:46.852] - Launch lazy future ... done
[17:40:46.852] run() for ‘MultisessionFuture’ ... done
[17:40:47.354] receiveMessageFromWorker() for ClusterFuture ...
[17:40:47.354] - Validating connection of MultisessionFuture
[17:40:47.354] - received message: FutureResult
[17:40:47.355] - Received FutureResult
[17:40:47.355] - Erased future from FutureRegistry
[17:40:47.355] result() for ClusterFuture ...
[17:40:47.355] - result already collected: FutureResult
[17:40:47.355] result() for ClusterFuture ... done
[17:40:47.355] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:47.355] A MultisessionFuture was resolved (result was not collected)
[17:40:47.355] getGlobalsAndPackages() ...
[17:40:47.355] Searching for globals...
[17:40:47.357] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:47.357] Searching for globals ... DONE
[17:40:47.357] Resolving globals: FALSE
[17:40:47.357] 
[17:40:47.357] 
[17:40:47.357] getGlobalsAndPackages() ... DONE
[17:40:47.358] run() for ‘Future’ ...
[17:40:47.358] - state: ‘created’
[17:40:47.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:47.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:47.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:47.372]   - Field: ‘node’
[17:40:47.372]   - Field: ‘label’
[17:40:47.372]   - Field: ‘local’
[17:40:47.372]   - Field: ‘owner’
[17:40:47.372]   - Field: ‘envir’
[17:40:47.372]   - Field: ‘workers’
[17:40:47.372]   - Field: ‘packages’
[17:40:47.373]   - Field: ‘gc’
[17:40:47.373]   - Field: ‘conditions’
[17:40:47.373]   - Field: ‘persistent’
[17:40:47.373]   - Field: ‘expr’
[17:40:47.373]   - Field: ‘uuid’
[17:40:47.373]   - Field: ‘seed’
[17:40:47.373]   - Field: ‘version’
[17:40:47.373]   - Field: ‘result’
[17:40:47.373]   - Field: ‘asynchronous’
[17:40:47.373]   - Field: ‘calls’
[17:40:47.373]   - Field: ‘globals’
[17:40:47.374]   - Field: ‘stdout’
[17:40:47.374]   - Field: ‘earlySignal’
[17:40:47.374]   - Field: ‘lazy’
[17:40:47.374]   - Field: ‘state’
[17:40:47.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:47.374] - Launch lazy future ...
[17:40:47.374] Packages needed by the future expression (n = 0): <none>
[17:40:47.374] Packages needed by future strategies (n = 0): <none>
[17:40:47.375] {
[17:40:47.375]     {
[17:40:47.375]         {
[17:40:47.375]             ...future.startTime <- base::Sys.time()
[17:40:47.375]             {
[17:40:47.375]                 {
[17:40:47.375]                   {
[17:40:47.375]                     {
[17:40:47.375]                       base::local({
[17:40:47.375]                         has_future <- base::requireNamespace("future", 
[17:40:47.375]                           quietly = TRUE)
[17:40:47.375]                         if (has_future) {
[17:40:47.375]                           ns <- base::getNamespace("future")
[17:40:47.375]                           version <- ns[[".package"]][["version"]]
[17:40:47.375]                           if (is.null(version)) 
[17:40:47.375]                             version <- utils::packageVersion("future")
[17:40:47.375]                         }
[17:40:47.375]                         else {
[17:40:47.375]                           version <- NULL
[17:40:47.375]                         }
[17:40:47.375]                         if (!has_future || version < "1.8.0") {
[17:40:47.375]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:47.375]                             "", base::R.version$version.string), 
[17:40:47.375]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:47.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:47.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:47.375]                               "release", "version")], collapse = " "), 
[17:40:47.375]                             hostname = base::Sys.info()[["nodename"]])
[17:40:47.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:47.375]                             info)
[17:40:47.375]                           info <- base::paste(info, collapse = "; ")
[17:40:47.375]                           if (!has_future) {
[17:40:47.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:47.375]                               info)
[17:40:47.375]                           }
[17:40:47.375]                           else {
[17:40:47.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:47.375]                               info, version)
[17:40:47.375]                           }
[17:40:47.375]                           base::stop(msg)
[17:40:47.375]                         }
[17:40:47.375]                       })
[17:40:47.375]                     }
[17:40:47.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:47.375]                     base::options(mc.cores = 1L)
[17:40:47.375]                   }
[17:40:47.375]                   ...future.strategy.old <- future::plan("list")
[17:40:47.375]                   options(future.plan = NULL)
[17:40:47.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:47.375]                 }
[17:40:47.375]                 ...future.workdir <- getwd()
[17:40:47.375]             }
[17:40:47.375]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:47.375]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:47.375]         }
[17:40:47.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:47.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:47.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:47.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:47.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:47.375]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:47.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:47.375]             base::names(...future.oldOptions))
[17:40:47.375]     }
[17:40:47.375]     if (FALSE) {
[17:40:47.375]     }
[17:40:47.375]     else {
[17:40:47.375]         if (TRUE) {
[17:40:47.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:47.375]                 open = "w")
[17:40:47.375]         }
[17:40:47.375]         else {
[17:40:47.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:47.375]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:47.375]         }
[17:40:47.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:47.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:47.375]             base::sink(type = "output", split = FALSE)
[17:40:47.375]             base::close(...future.stdout)
[17:40:47.375]         }, add = TRUE)
[17:40:47.375]     }
[17:40:47.375]     ...future.frame <- base::sys.nframe()
[17:40:47.375]     ...future.conditions <- base::list()
[17:40:47.375]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:47.375]     if (FALSE) {
[17:40:47.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:47.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:47.375]     }
[17:40:47.375]     ...future.result <- base::tryCatch({
[17:40:47.375]         base::withCallingHandlers({
[17:40:47.375]             ...future.value <- base::withVisible(base::local({
[17:40:47.375]                 ...future.makeSendCondition <- base::local({
[17:40:47.375]                   sendCondition <- NULL
[17:40:47.375]                   function(frame = 1L) {
[17:40:47.375]                     if (is.function(sendCondition)) 
[17:40:47.375]                       return(sendCondition)
[17:40:47.375]                     ns <- getNamespace("parallel")
[17:40:47.375]                     if (exists("sendData", mode = "function", 
[17:40:47.375]                       envir = ns)) {
[17:40:47.375]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:47.375]                         envir = ns)
[17:40:47.375]                       envir <- sys.frame(frame)
[17:40:47.375]                       master <- NULL
[17:40:47.375]                       while (!identical(envir, .GlobalEnv) && 
[17:40:47.375]                         !identical(envir, emptyenv())) {
[17:40:47.375]                         if (exists("master", mode = "list", envir = envir, 
[17:40:47.375]                           inherits = FALSE)) {
[17:40:47.375]                           master <- get("master", mode = "list", 
[17:40:47.375]                             envir = envir, inherits = FALSE)
[17:40:47.375]                           if (inherits(master, c("SOCKnode", 
[17:40:47.375]                             "SOCK0node"))) {
[17:40:47.375]                             sendCondition <<- function(cond) {
[17:40:47.375]                               data <- list(type = "VALUE", value = cond, 
[17:40:47.375]                                 success = TRUE)
[17:40:47.375]                               parallel_sendData(master, data)
[17:40:47.375]                             }
[17:40:47.375]                             return(sendCondition)
[17:40:47.375]                           }
[17:40:47.375]                         }
[17:40:47.375]                         frame <- frame + 1L
[17:40:47.375]                         envir <- sys.frame(frame)
[17:40:47.375]                       }
[17:40:47.375]                     }
[17:40:47.375]                     sendCondition <<- function(cond) NULL
[17:40:47.375]                   }
[17:40:47.375]                 })
[17:40:47.375]                 withCallingHandlers({
[17:40:47.375]                   {
[17:40:47.375]                     Sys.sleep(0.5)
[17:40:47.375]                     list(a = 1, b = 42L)
[17:40:47.375]                   }
[17:40:47.375]                 }, immediateCondition = function(cond) {
[17:40:47.375]                   sendCondition <- ...future.makeSendCondition()
[17:40:47.375]                   sendCondition(cond)
[17:40:47.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.375]                   {
[17:40:47.375]                     inherits <- base::inherits
[17:40:47.375]                     invokeRestart <- base::invokeRestart
[17:40:47.375]                     is.null <- base::is.null
[17:40:47.375]                     muffled <- FALSE
[17:40:47.375]                     if (inherits(cond, "message")) {
[17:40:47.375]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:47.375]                       if (muffled) 
[17:40:47.375]                         invokeRestart("muffleMessage")
[17:40:47.375]                     }
[17:40:47.375]                     else if (inherits(cond, "warning")) {
[17:40:47.375]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:47.375]                       if (muffled) 
[17:40:47.375]                         invokeRestart("muffleWarning")
[17:40:47.375]                     }
[17:40:47.375]                     else if (inherits(cond, "condition")) {
[17:40:47.375]                       if (!is.null(pattern)) {
[17:40:47.375]                         computeRestarts <- base::computeRestarts
[17:40:47.375]                         grepl <- base::grepl
[17:40:47.375]                         restarts <- computeRestarts(cond)
[17:40:47.375]                         for (restart in restarts) {
[17:40:47.375]                           name <- restart$name
[17:40:47.375]                           if (is.null(name)) 
[17:40:47.375]                             next
[17:40:47.375]                           if (!grepl(pattern, name)) 
[17:40:47.375]                             next
[17:40:47.375]                           invokeRestart(restart)
[17:40:47.375]                           muffled <- TRUE
[17:40:47.375]                           break
[17:40:47.375]                         }
[17:40:47.375]                       }
[17:40:47.375]                     }
[17:40:47.375]                     invisible(muffled)
[17:40:47.375]                   }
[17:40:47.375]                   muffleCondition(cond)
[17:40:47.375]                 })
[17:40:47.375]             }))
[17:40:47.375]             future::FutureResult(value = ...future.value$value, 
[17:40:47.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.375]                   ...future.rng), globalenv = if (FALSE) 
[17:40:47.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:47.375]                     ...future.globalenv.names))
[17:40:47.375]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:47.375]         }, condition = base::local({
[17:40:47.375]             c <- base::c
[17:40:47.375]             inherits <- base::inherits
[17:40:47.375]             invokeRestart <- base::invokeRestart
[17:40:47.375]             length <- base::length
[17:40:47.375]             list <- base::list
[17:40:47.375]             seq.int <- base::seq.int
[17:40:47.375]             signalCondition <- base::signalCondition
[17:40:47.375]             sys.calls <- base::sys.calls
[17:40:47.375]             `[[` <- base::`[[`
[17:40:47.375]             `+` <- base::`+`
[17:40:47.375]             `<<-` <- base::`<<-`
[17:40:47.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:47.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:47.375]                   3L)]
[17:40:47.375]             }
[17:40:47.375]             function(cond) {
[17:40:47.375]                 is_error <- inherits(cond, "error")
[17:40:47.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:47.375]                   NULL)
[17:40:47.375]                 if (is_error) {
[17:40:47.375]                   sessionInformation <- function() {
[17:40:47.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:47.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:47.375]                       search = base::search(), system = base::Sys.info())
[17:40:47.375]                   }
[17:40:47.375]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:47.375]                     cond$call), session = sessionInformation(), 
[17:40:47.375]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:47.375]                   signalCondition(cond)
[17:40:47.375]                 }
[17:40:47.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:47.375]                 "immediateCondition"))) {
[17:40:47.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:47.375]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:47.375]                   if (TRUE && !signal) {
[17:40:47.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.375]                     {
[17:40:47.375]                       inherits <- base::inherits
[17:40:47.375]                       invokeRestart <- base::invokeRestart
[17:40:47.375]                       is.null <- base::is.null
[17:40:47.375]                       muffled <- FALSE
[17:40:47.375]                       if (inherits(cond, "message")) {
[17:40:47.375]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.375]                         if (muffled) 
[17:40:47.375]                           invokeRestart("muffleMessage")
[17:40:47.375]                       }
[17:40:47.375]                       else if (inherits(cond, "warning")) {
[17:40:47.375]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.375]                         if (muffled) 
[17:40:47.375]                           invokeRestart("muffleWarning")
[17:40:47.375]                       }
[17:40:47.375]                       else if (inherits(cond, "condition")) {
[17:40:47.375]                         if (!is.null(pattern)) {
[17:40:47.375]                           computeRestarts <- base::computeRestarts
[17:40:47.375]                           grepl <- base::grepl
[17:40:47.375]                           restarts <- computeRestarts(cond)
[17:40:47.375]                           for (restart in restarts) {
[17:40:47.375]                             name <- restart$name
[17:40:47.375]                             if (is.null(name)) 
[17:40:47.375]                               next
[17:40:47.375]                             if (!grepl(pattern, name)) 
[17:40:47.375]                               next
[17:40:47.375]                             invokeRestart(restart)
[17:40:47.375]                             muffled <- TRUE
[17:40:47.375]                             break
[17:40:47.375]                           }
[17:40:47.375]                         }
[17:40:47.375]                       }
[17:40:47.375]                       invisible(muffled)
[17:40:47.375]                     }
[17:40:47.375]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.375]                   }
[17:40:47.375]                 }
[17:40:47.375]                 else {
[17:40:47.375]                   if (TRUE) {
[17:40:47.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.375]                     {
[17:40:47.375]                       inherits <- base::inherits
[17:40:47.375]                       invokeRestart <- base::invokeRestart
[17:40:47.375]                       is.null <- base::is.null
[17:40:47.375]                       muffled <- FALSE
[17:40:47.375]                       if (inherits(cond, "message")) {
[17:40:47.375]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.375]                         if (muffled) 
[17:40:47.375]                           invokeRestart("muffleMessage")
[17:40:47.375]                       }
[17:40:47.375]                       else if (inherits(cond, "warning")) {
[17:40:47.375]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.375]                         if (muffled) 
[17:40:47.375]                           invokeRestart("muffleWarning")
[17:40:47.375]                       }
[17:40:47.375]                       else if (inherits(cond, "condition")) {
[17:40:47.375]                         if (!is.null(pattern)) {
[17:40:47.375]                           computeRestarts <- base::computeRestarts
[17:40:47.375]                           grepl <- base::grepl
[17:40:47.375]                           restarts <- computeRestarts(cond)
[17:40:47.375]                           for (restart in restarts) {
[17:40:47.375]                             name <- restart$name
[17:40:47.375]                             if (is.null(name)) 
[17:40:47.375]                               next
[17:40:47.375]                             if (!grepl(pattern, name)) 
[17:40:47.375]                               next
[17:40:47.375]                             invokeRestart(restart)
[17:40:47.375]                             muffled <- TRUE
[17:40:47.375]                             break
[17:40:47.375]                           }
[17:40:47.375]                         }
[17:40:47.375]                       }
[17:40:47.375]                       invisible(muffled)
[17:40:47.375]                     }
[17:40:47.375]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.375]                   }
[17:40:47.375]                 }
[17:40:47.375]             }
[17:40:47.375]         }))
[17:40:47.375]     }, error = function(ex) {
[17:40:47.375]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:47.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.375]                 ...future.rng), started = ...future.startTime, 
[17:40:47.375]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:47.375]             version = "1.8"), class = "FutureResult")
[17:40:47.375]     }, finally = {
[17:40:47.375]         if (!identical(...future.workdir, getwd())) 
[17:40:47.375]             setwd(...future.workdir)
[17:40:47.375]         {
[17:40:47.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:47.375]                 ...future.oldOptions$nwarnings <- NULL
[17:40:47.375]             }
[17:40:47.375]             base::options(...future.oldOptions)
[17:40:47.375]             if (.Platform$OS.type == "windows") {
[17:40:47.375]                 old_names <- names(...future.oldEnvVars)
[17:40:47.375]                 envs <- base::Sys.getenv()
[17:40:47.375]                 names <- names(envs)
[17:40:47.375]                 common <- intersect(names, old_names)
[17:40:47.375]                 added <- setdiff(names, old_names)
[17:40:47.375]                 removed <- setdiff(old_names, names)
[17:40:47.375]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:47.375]                   envs[common]]
[17:40:47.375]                 NAMES <- toupper(changed)
[17:40:47.375]                 args <- list()
[17:40:47.375]                 for (kk in seq_along(NAMES)) {
[17:40:47.375]                   name <- changed[[kk]]
[17:40:47.375]                   NAME <- NAMES[[kk]]
[17:40:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.375]                     next
[17:40:47.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.375]                 }
[17:40:47.375]                 NAMES <- toupper(added)
[17:40:47.375]                 for (kk in seq_along(NAMES)) {
[17:40:47.375]                   name <- added[[kk]]
[17:40:47.375]                   NAME <- NAMES[[kk]]
[17:40:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.375]                     next
[17:40:47.375]                   args[[name]] <- ""
[17:40:47.375]                 }
[17:40:47.375]                 NAMES <- toupper(removed)
[17:40:47.375]                 for (kk in seq_along(NAMES)) {
[17:40:47.375]                   name <- removed[[kk]]
[17:40:47.375]                   NAME <- NAMES[[kk]]
[17:40:47.375]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.375]                     next
[17:40:47.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.375]                 }
[17:40:47.375]                 if (length(args) > 0) 
[17:40:47.375]                   base::do.call(base::Sys.setenv, args = args)
[17:40:47.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:47.375]             }
[17:40:47.375]             else {
[17:40:47.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:47.375]             }
[17:40:47.375]             {
[17:40:47.375]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:47.375]                   0L) {
[17:40:47.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:47.375]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:47.375]                   base::options(opts)
[17:40:47.375]                 }
[17:40:47.375]                 {
[17:40:47.375]                   {
[17:40:47.375]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:47.375]                     NULL
[17:40:47.375]                   }
[17:40:47.375]                   options(future.plan = NULL)
[17:40:47.375]                   if (is.na(NA_character_)) 
[17:40:47.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:47.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:47.375]                     .init = FALSE)
[17:40:47.375]                 }
[17:40:47.375]             }
[17:40:47.375]         }
[17:40:47.375]     })
[17:40:47.375]     if (TRUE) {
[17:40:47.375]         base::sink(type = "output", split = FALSE)
[17:40:47.375]         if (TRUE) {
[17:40:47.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:47.375]         }
[17:40:47.375]         else {
[17:40:47.375]             ...future.result["stdout"] <- base::list(NULL)
[17:40:47.375]         }
[17:40:47.375]         base::close(...future.stdout)
[17:40:47.375]         ...future.stdout <- NULL
[17:40:47.375]     }
[17:40:47.375]     ...future.result$conditions <- ...future.conditions
[17:40:47.375]     ...future.result$finished <- base::Sys.time()
[17:40:47.375]     ...future.result
[17:40:47.375] }
[17:40:47.378] MultisessionFuture started
[17:40:47.378] - Launch lazy future ... done
[17:40:47.378] run() for ‘MultisessionFuture’ ... done
[17:40:47.881] receiveMessageFromWorker() for ClusterFuture ...
[17:40:47.881] - Validating connection of MultisessionFuture
[17:40:47.881] - received message: FutureResult
[17:40:47.881] - Received FutureResult
[17:40:47.881] - Erased future from FutureRegistry
[17:40:47.882] result() for ClusterFuture ...
[17:40:47.882] - result already collected: FutureResult
[17:40:47.882] result() for ClusterFuture ... done
[17:40:47.882] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:47.882] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:47.882] getGlobalsAndPackages() ...
[17:40:47.882] Searching for globals...
[17:40:47.883] - globals found: [2] ‘list’, ‘stop’
[17:40:47.883] Searching for globals ... DONE
[17:40:47.883] Resolving globals: FALSE
[17:40:47.883] 
[17:40:47.883] 
[17:40:47.884] getGlobalsAndPackages() ... DONE
[17:40:47.884] run() for ‘Future’ ...
[17:40:47.884] - state: ‘created’
[17:40:47.884] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:47.898] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:47.898] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:47.898]   - Field: ‘node’
[17:40:47.898]   - Field: ‘label’
[17:40:47.898]   - Field: ‘local’
[17:40:47.898]   - Field: ‘owner’
[17:40:47.899]   - Field: ‘envir’
[17:40:47.899]   - Field: ‘workers’
[17:40:47.899]   - Field: ‘packages’
[17:40:47.899]   - Field: ‘gc’
[17:40:47.899]   - Field: ‘conditions’
[17:40:47.899]   - Field: ‘persistent’
[17:40:47.899]   - Field: ‘expr’
[17:40:47.899]   - Field: ‘uuid’
[17:40:47.899]   - Field: ‘seed’
[17:40:47.899]   - Field: ‘version’
[17:40:47.899]   - Field: ‘result’
[17:40:47.900]   - Field: ‘asynchronous’
[17:40:47.900]   - Field: ‘calls’
[17:40:47.900]   - Field: ‘globals’
[17:40:47.900]   - Field: ‘stdout’
[17:40:47.900]   - Field: ‘earlySignal’
[17:40:47.900]   - Field: ‘lazy’
[17:40:47.900]   - Field: ‘state’
[17:40:47.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:47.900] - Launch lazy future ...
[17:40:47.901] Packages needed by the future expression (n = 0): <none>
[17:40:47.901] Packages needed by future strategies (n = 0): <none>
[17:40:47.901] {
[17:40:47.901]     {
[17:40:47.901]         {
[17:40:47.901]             ...future.startTime <- base::Sys.time()
[17:40:47.901]             {
[17:40:47.901]                 {
[17:40:47.901]                   {
[17:40:47.901]                     {
[17:40:47.901]                       base::local({
[17:40:47.901]                         has_future <- base::requireNamespace("future", 
[17:40:47.901]                           quietly = TRUE)
[17:40:47.901]                         if (has_future) {
[17:40:47.901]                           ns <- base::getNamespace("future")
[17:40:47.901]                           version <- ns[[".package"]][["version"]]
[17:40:47.901]                           if (is.null(version)) 
[17:40:47.901]                             version <- utils::packageVersion("future")
[17:40:47.901]                         }
[17:40:47.901]                         else {
[17:40:47.901]                           version <- NULL
[17:40:47.901]                         }
[17:40:47.901]                         if (!has_future || version < "1.8.0") {
[17:40:47.901]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:47.901]                             "", base::R.version$version.string), 
[17:40:47.901]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:47.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:47.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:47.901]                               "release", "version")], collapse = " "), 
[17:40:47.901]                             hostname = base::Sys.info()[["nodename"]])
[17:40:47.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:47.901]                             info)
[17:40:47.901]                           info <- base::paste(info, collapse = "; ")
[17:40:47.901]                           if (!has_future) {
[17:40:47.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:47.901]                               info)
[17:40:47.901]                           }
[17:40:47.901]                           else {
[17:40:47.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:47.901]                               info, version)
[17:40:47.901]                           }
[17:40:47.901]                           base::stop(msg)
[17:40:47.901]                         }
[17:40:47.901]                       })
[17:40:47.901]                     }
[17:40:47.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:47.901]                     base::options(mc.cores = 1L)
[17:40:47.901]                   }
[17:40:47.901]                   ...future.strategy.old <- future::plan("list")
[17:40:47.901]                   options(future.plan = NULL)
[17:40:47.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:47.901]                 }
[17:40:47.901]                 ...future.workdir <- getwd()
[17:40:47.901]             }
[17:40:47.901]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:47.901]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:47.901]         }
[17:40:47.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:47.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:47.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:47.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:47.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:47.901]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:47.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:47.901]             base::names(...future.oldOptions))
[17:40:47.901]     }
[17:40:47.901]     if (FALSE) {
[17:40:47.901]     }
[17:40:47.901]     else {
[17:40:47.901]         if (TRUE) {
[17:40:47.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:47.901]                 open = "w")
[17:40:47.901]         }
[17:40:47.901]         else {
[17:40:47.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:47.901]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:47.901]         }
[17:40:47.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:47.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:47.901]             base::sink(type = "output", split = FALSE)
[17:40:47.901]             base::close(...future.stdout)
[17:40:47.901]         }, add = TRUE)
[17:40:47.901]     }
[17:40:47.901]     ...future.frame <- base::sys.nframe()
[17:40:47.901]     ...future.conditions <- base::list()
[17:40:47.901]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:47.901]     if (FALSE) {
[17:40:47.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:47.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:47.901]     }
[17:40:47.901]     ...future.result <- base::tryCatch({
[17:40:47.901]         base::withCallingHandlers({
[17:40:47.901]             ...future.value <- base::withVisible(base::local({
[17:40:47.901]                 ...future.makeSendCondition <- base::local({
[17:40:47.901]                   sendCondition <- NULL
[17:40:47.901]                   function(frame = 1L) {
[17:40:47.901]                     if (is.function(sendCondition)) 
[17:40:47.901]                       return(sendCondition)
[17:40:47.901]                     ns <- getNamespace("parallel")
[17:40:47.901]                     if (exists("sendData", mode = "function", 
[17:40:47.901]                       envir = ns)) {
[17:40:47.901]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:47.901]                         envir = ns)
[17:40:47.901]                       envir <- sys.frame(frame)
[17:40:47.901]                       master <- NULL
[17:40:47.901]                       while (!identical(envir, .GlobalEnv) && 
[17:40:47.901]                         !identical(envir, emptyenv())) {
[17:40:47.901]                         if (exists("master", mode = "list", envir = envir, 
[17:40:47.901]                           inherits = FALSE)) {
[17:40:47.901]                           master <- get("master", mode = "list", 
[17:40:47.901]                             envir = envir, inherits = FALSE)
[17:40:47.901]                           if (inherits(master, c("SOCKnode", 
[17:40:47.901]                             "SOCK0node"))) {
[17:40:47.901]                             sendCondition <<- function(cond) {
[17:40:47.901]                               data <- list(type = "VALUE", value = cond, 
[17:40:47.901]                                 success = TRUE)
[17:40:47.901]                               parallel_sendData(master, data)
[17:40:47.901]                             }
[17:40:47.901]                             return(sendCondition)
[17:40:47.901]                           }
[17:40:47.901]                         }
[17:40:47.901]                         frame <- frame + 1L
[17:40:47.901]                         envir <- sys.frame(frame)
[17:40:47.901]                       }
[17:40:47.901]                     }
[17:40:47.901]                     sendCondition <<- function(cond) NULL
[17:40:47.901]                   }
[17:40:47.901]                 })
[17:40:47.901]                 withCallingHandlers({
[17:40:47.901]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:47.901]                 }, immediateCondition = function(cond) {
[17:40:47.901]                   sendCondition <- ...future.makeSendCondition()
[17:40:47.901]                   sendCondition(cond)
[17:40:47.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.901]                   {
[17:40:47.901]                     inherits <- base::inherits
[17:40:47.901]                     invokeRestart <- base::invokeRestart
[17:40:47.901]                     is.null <- base::is.null
[17:40:47.901]                     muffled <- FALSE
[17:40:47.901]                     if (inherits(cond, "message")) {
[17:40:47.901]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:47.901]                       if (muffled) 
[17:40:47.901]                         invokeRestart("muffleMessage")
[17:40:47.901]                     }
[17:40:47.901]                     else if (inherits(cond, "warning")) {
[17:40:47.901]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:47.901]                       if (muffled) 
[17:40:47.901]                         invokeRestart("muffleWarning")
[17:40:47.901]                     }
[17:40:47.901]                     else if (inherits(cond, "condition")) {
[17:40:47.901]                       if (!is.null(pattern)) {
[17:40:47.901]                         computeRestarts <- base::computeRestarts
[17:40:47.901]                         grepl <- base::grepl
[17:40:47.901]                         restarts <- computeRestarts(cond)
[17:40:47.901]                         for (restart in restarts) {
[17:40:47.901]                           name <- restart$name
[17:40:47.901]                           if (is.null(name)) 
[17:40:47.901]                             next
[17:40:47.901]                           if (!grepl(pattern, name)) 
[17:40:47.901]                             next
[17:40:47.901]                           invokeRestart(restart)
[17:40:47.901]                           muffled <- TRUE
[17:40:47.901]                           break
[17:40:47.901]                         }
[17:40:47.901]                       }
[17:40:47.901]                     }
[17:40:47.901]                     invisible(muffled)
[17:40:47.901]                   }
[17:40:47.901]                   muffleCondition(cond)
[17:40:47.901]                 })
[17:40:47.901]             }))
[17:40:47.901]             future::FutureResult(value = ...future.value$value, 
[17:40:47.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.901]                   ...future.rng), globalenv = if (FALSE) 
[17:40:47.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:47.901]                     ...future.globalenv.names))
[17:40:47.901]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:47.901]         }, condition = base::local({
[17:40:47.901]             c <- base::c
[17:40:47.901]             inherits <- base::inherits
[17:40:47.901]             invokeRestart <- base::invokeRestart
[17:40:47.901]             length <- base::length
[17:40:47.901]             list <- base::list
[17:40:47.901]             seq.int <- base::seq.int
[17:40:47.901]             signalCondition <- base::signalCondition
[17:40:47.901]             sys.calls <- base::sys.calls
[17:40:47.901]             `[[` <- base::`[[`
[17:40:47.901]             `+` <- base::`+`
[17:40:47.901]             `<<-` <- base::`<<-`
[17:40:47.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:47.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:47.901]                   3L)]
[17:40:47.901]             }
[17:40:47.901]             function(cond) {
[17:40:47.901]                 is_error <- inherits(cond, "error")
[17:40:47.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:47.901]                   NULL)
[17:40:47.901]                 if (is_error) {
[17:40:47.901]                   sessionInformation <- function() {
[17:40:47.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:47.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:47.901]                       search = base::search(), system = base::Sys.info())
[17:40:47.901]                   }
[17:40:47.901]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:47.901]                     cond$call), session = sessionInformation(), 
[17:40:47.901]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:47.901]                   signalCondition(cond)
[17:40:47.901]                 }
[17:40:47.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:47.901]                 "immediateCondition"))) {
[17:40:47.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:47.901]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:47.901]                   if (TRUE && !signal) {
[17:40:47.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.901]                     {
[17:40:47.901]                       inherits <- base::inherits
[17:40:47.901]                       invokeRestart <- base::invokeRestart
[17:40:47.901]                       is.null <- base::is.null
[17:40:47.901]                       muffled <- FALSE
[17:40:47.901]                       if (inherits(cond, "message")) {
[17:40:47.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.901]                         if (muffled) 
[17:40:47.901]                           invokeRestart("muffleMessage")
[17:40:47.901]                       }
[17:40:47.901]                       else if (inherits(cond, "warning")) {
[17:40:47.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.901]                         if (muffled) 
[17:40:47.901]                           invokeRestart("muffleWarning")
[17:40:47.901]                       }
[17:40:47.901]                       else if (inherits(cond, "condition")) {
[17:40:47.901]                         if (!is.null(pattern)) {
[17:40:47.901]                           computeRestarts <- base::computeRestarts
[17:40:47.901]                           grepl <- base::grepl
[17:40:47.901]                           restarts <- computeRestarts(cond)
[17:40:47.901]                           for (restart in restarts) {
[17:40:47.901]                             name <- restart$name
[17:40:47.901]                             if (is.null(name)) 
[17:40:47.901]                               next
[17:40:47.901]                             if (!grepl(pattern, name)) 
[17:40:47.901]                               next
[17:40:47.901]                             invokeRestart(restart)
[17:40:47.901]                             muffled <- TRUE
[17:40:47.901]                             break
[17:40:47.901]                           }
[17:40:47.901]                         }
[17:40:47.901]                       }
[17:40:47.901]                       invisible(muffled)
[17:40:47.901]                     }
[17:40:47.901]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.901]                   }
[17:40:47.901]                 }
[17:40:47.901]                 else {
[17:40:47.901]                   if (TRUE) {
[17:40:47.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.901]                     {
[17:40:47.901]                       inherits <- base::inherits
[17:40:47.901]                       invokeRestart <- base::invokeRestart
[17:40:47.901]                       is.null <- base::is.null
[17:40:47.901]                       muffled <- FALSE
[17:40:47.901]                       if (inherits(cond, "message")) {
[17:40:47.901]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.901]                         if (muffled) 
[17:40:47.901]                           invokeRestart("muffleMessage")
[17:40:47.901]                       }
[17:40:47.901]                       else if (inherits(cond, "warning")) {
[17:40:47.901]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.901]                         if (muffled) 
[17:40:47.901]                           invokeRestart("muffleWarning")
[17:40:47.901]                       }
[17:40:47.901]                       else if (inherits(cond, "condition")) {
[17:40:47.901]                         if (!is.null(pattern)) {
[17:40:47.901]                           computeRestarts <- base::computeRestarts
[17:40:47.901]                           grepl <- base::grepl
[17:40:47.901]                           restarts <- computeRestarts(cond)
[17:40:47.901]                           for (restart in restarts) {
[17:40:47.901]                             name <- restart$name
[17:40:47.901]                             if (is.null(name)) 
[17:40:47.901]                               next
[17:40:47.901]                             if (!grepl(pattern, name)) 
[17:40:47.901]                               next
[17:40:47.901]                             invokeRestart(restart)
[17:40:47.901]                             muffled <- TRUE
[17:40:47.901]                             break
[17:40:47.901]                           }
[17:40:47.901]                         }
[17:40:47.901]                       }
[17:40:47.901]                       invisible(muffled)
[17:40:47.901]                     }
[17:40:47.901]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.901]                   }
[17:40:47.901]                 }
[17:40:47.901]             }
[17:40:47.901]         }))
[17:40:47.901]     }, error = function(ex) {
[17:40:47.901]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:47.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.901]                 ...future.rng), started = ...future.startTime, 
[17:40:47.901]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:47.901]             version = "1.8"), class = "FutureResult")
[17:40:47.901]     }, finally = {
[17:40:47.901]         if (!identical(...future.workdir, getwd())) 
[17:40:47.901]             setwd(...future.workdir)
[17:40:47.901]         {
[17:40:47.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:47.901]                 ...future.oldOptions$nwarnings <- NULL
[17:40:47.901]             }
[17:40:47.901]             base::options(...future.oldOptions)
[17:40:47.901]             if (.Platform$OS.type == "windows") {
[17:40:47.901]                 old_names <- names(...future.oldEnvVars)
[17:40:47.901]                 envs <- base::Sys.getenv()
[17:40:47.901]                 names <- names(envs)
[17:40:47.901]                 common <- intersect(names, old_names)
[17:40:47.901]                 added <- setdiff(names, old_names)
[17:40:47.901]                 removed <- setdiff(old_names, names)
[17:40:47.901]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:47.901]                   envs[common]]
[17:40:47.901]                 NAMES <- toupper(changed)
[17:40:47.901]                 args <- list()
[17:40:47.901]                 for (kk in seq_along(NAMES)) {
[17:40:47.901]                   name <- changed[[kk]]
[17:40:47.901]                   NAME <- NAMES[[kk]]
[17:40:47.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.901]                     next
[17:40:47.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.901]                 }
[17:40:47.901]                 NAMES <- toupper(added)
[17:40:47.901]                 for (kk in seq_along(NAMES)) {
[17:40:47.901]                   name <- added[[kk]]
[17:40:47.901]                   NAME <- NAMES[[kk]]
[17:40:47.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.901]                     next
[17:40:47.901]                   args[[name]] <- ""
[17:40:47.901]                 }
[17:40:47.901]                 NAMES <- toupper(removed)
[17:40:47.901]                 for (kk in seq_along(NAMES)) {
[17:40:47.901]                   name <- removed[[kk]]
[17:40:47.901]                   NAME <- NAMES[[kk]]
[17:40:47.901]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.901]                     next
[17:40:47.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.901]                 }
[17:40:47.901]                 if (length(args) > 0) 
[17:40:47.901]                   base::do.call(base::Sys.setenv, args = args)
[17:40:47.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:47.901]             }
[17:40:47.901]             else {
[17:40:47.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:47.901]             }
[17:40:47.901]             {
[17:40:47.901]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:47.901]                   0L) {
[17:40:47.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:47.901]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:47.901]                   base::options(opts)
[17:40:47.901]                 }
[17:40:47.901]                 {
[17:40:47.901]                   {
[17:40:47.901]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:47.901]                     NULL
[17:40:47.901]                   }
[17:40:47.901]                   options(future.plan = NULL)
[17:40:47.901]                   if (is.na(NA_character_)) 
[17:40:47.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:47.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:47.901]                     .init = FALSE)
[17:40:47.901]                 }
[17:40:47.901]             }
[17:40:47.901]         }
[17:40:47.901]     })
[17:40:47.901]     if (TRUE) {
[17:40:47.901]         base::sink(type = "output", split = FALSE)
[17:40:47.901]         if (TRUE) {
[17:40:47.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:47.901]         }
[17:40:47.901]         else {
[17:40:47.901]             ...future.result["stdout"] <- base::list(NULL)
[17:40:47.901]         }
[17:40:47.901]         base::close(...future.stdout)
[17:40:47.901]         ...future.stdout <- NULL
[17:40:47.901]     }
[17:40:47.901]     ...future.result$conditions <- ...future.conditions
[17:40:47.901]     ...future.result$finished <- base::Sys.time()
[17:40:47.901]     ...future.result
[17:40:47.901] }
[17:40:47.904] MultisessionFuture started
[17:40:47.905] - Launch lazy future ... done
[17:40:47.905] run() for ‘MultisessionFuture’ ... done
[17:40:47.906] receiveMessageFromWorker() for ClusterFuture ...
[17:40:47.907] - Validating connection of MultisessionFuture
[17:40:47.907] - received message: FutureResult
[17:40:47.907] - Received FutureResult
[17:40:47.907] - Erased future from FutureRegistry
[17:40:47.908] result() for ClusterFuture ...
[17:40:47.908] - result already collected: FutureResult
[17:40:47.908] result() for ClusterFuture ... done
[17:40:47.908] signalConditions() ...
[17:40:47.908]  - include = ‘immediateCondition’
[17:40:47.908]  - exclude = 
[17:40:47.908]  - resignal = FALSE
[17:40:47.908]  - Number of conditions: 1
[17:40:47.908] signalConditions() ... done
[17:40:47.908] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:47.908] A MultisessionFuture was resolved (result was not collected)
[17:40:47.909] getGlobalsAndPackages() ...
[17:40:47.909] Searching for globals...
[17:40:47.909] - globals found: [2] ‘list’, ‘stop’
[17:40:47.909] Searching for globals ... DONE
[17:40:47.910] Resolving globals: FALSE
[17:40:47.910] 
[17:40:47.910] 
[17:40:47.910] getGlobalsAndPackages() ... DONE
[17:40:47.910] run() for ‘Future’ ...
[17:40:47.910] - state: ‘created’
[17:40:47.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:47.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:47.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:47.925]   - Field: ‘node’
[17:40:47.925]   - Field: ‘label’
[17:40:47.925]   - Field: ‘local’
[17:40:47.926]   - Field: ‘owner’
[17:40:47.926]   - Field: ‘envir’
[17:40:47.926]   - Field: ‘workers’
[17:40:47.926]   - Field: ‘packages’
[17:40:47.926]   - Field: ‘gc’
[17:40:47.926]   - Field: ‘conditions’
[17:40:47.926]   - Field: ‘persistent’
[17:40:47.926]   - Field: ‘expr’
[17:40:47.926]   - Field: ‘uuid’
[17:40:47.926]   - Field: ‘seed’
[17:40:47.926]   - Field: ‘version’
[17:40:47.927]   - Field: ‘result’
[17:40:47.927]   - Field: ‘asynchronous’
[17:40:47.927]   - Field: ‘calls’
[17:40:47.927]   - Field: ‘globals’
[17:40:47.927]   - Field: ‘stdout’
[17:40:47.927]   - Field: ‘earlySignal’
[17:40:47.927]   - Field: ‘lazy’
[17:40:47.927]   - Field: ‘state’
[17:40:47.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:47.927] - Launch lazy future ...
[17:40:47.928] Packages needed by the future expression (n = 0): <none>
[17:40:47.928] Packages needed by future strategies (n = 0): <none>
[17:40:47.928] {
[17:40:47.928]     {
[17:40:47.928]         {
[17:40:47.928]             ...future.startTime <- base::Sys.time()
[17:40:47.928]             {
[17:40:47.928]                 {
[17:40:47.928]                   {
[17:40:47.928]                     {
[17:40:47.928]                       base::local({
[17:40:47.928]                         has_future <- base::requireNamespace("future", 
[17:40:47.928]                           quietly = TRUE)
[17:40:47.928]                         if (has_future) {
[17:40:47.928]                           ns <- base::getNamespace("future")
[17:40:47.928]                           version <- ns[[".package"]][["version"]]
[17:40:47.928]                           if (is.null(version)) 
[17:40:47.928]                             version <- utils::packageVersion("future")
[17:40:47.928]                         }
[17:40:47.928]                         else {
[17:40:47.928]                           version <- NULL
[17:40:47.928]                         }
[17:40:47.928]                         if (!has_future || version < "1.8.0") {
[17:40:47.928]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:47.928]                             "", base::R.version$version.string), 
[17:40:47.928]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:47.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:47.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:47.928]                               "release", "version")], collapse = " "), 
[17:40:47.928]                             hostname = base::Sys.info()[["nodename"]])
[17:40:47.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:47.928]                             info)
[17:40:47.928]                           info <- base::paste(info, collapse = "; ")
[17:40:47.928]                           if (!has_future) {
[17:40:47.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:47.928]                               info)
[17:40:47.928]                           }
[17:40:47.928]                           else {
[17:40:47.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:47.928]                               info, version)
[17:40:47.928]                           }
[17:40:47.928]                           base::stop(msg)
[17:40:47.928]                         }
[17:40:47.928]                       })
[17:40:47.928]                     }
[17:40:47.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:47.928]                     base::options(mc.cores = 1L)
[17:40:47.928]                   }
[17:40:47.928]                   ...future.strategy.old <- future::plan("list")
[17:40:47.928]                   options(future.plan = NULL)
[17:40:47.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:47.928]                 }
[17:40:47.928]                 ...future.workdir <- getwd()
[17:40:47.928]             }
[17:40:47.928]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:47.928]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:47.928]         }
[17:40:47.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:47.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:47.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:47.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:47.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:47.928]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:47.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:47.928]             base::names(...future.oldOptions))
[17:40:47.928]     }
[17:40:47.928]     if (FALSE) {
[17:40:47.928]     }
[17:40:47.928]     else {
[17:40:47.928]         if (TRUE) {
[17:40:47.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:47.928]                 open = "w")
[17:40:47.928]         }
[17:40:47.928]         else {
[17:40:47.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:47.928]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:47.928]         }
[17:40:47.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:47.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:47.928]             base::sink(type = "output", split = FALSE)
[17:40:47.928]             base::close(...future.stdout)
[17:40:47.928]         }, add = TRUE)
[17:40:47.928]     }
[17:40:47.928]     ...future.frame <- base::sys.nframe()
[17:40:47.928]     ...future.conditions <- base::list()
[17:40:47.928]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:47.928]     if (FALSE) {
[17:40:47.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:47.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:47.928]     }
[17:40:47.928]     ...future.result <- base::tryCatch({
[17:40:47.928]         base::withCallingHandlers({
[17:40:47.928]             ...future.value <- base::withVisible(base::local({
[17:40:47.928]                 ...future.makeSendCondition <- base::local({
[17:40:47.928]                   sendCondition <- NULL
[17:40:47.928]                   function(frame = 1L) {
[17:40:47.928]                     if (is.function(sendCondition)) 
[17:40:47.928]                       return(sendCondition)
[17:40:47.928]                     ns <- getNamespace("parallel")
[17:40:47.928]                     if (exists("sendData", mode = "function", 
[17:40:47.928]                       envir = ns)) {
[17:40:47.928]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:47.928]                         envir = ns)
[17:40:47.928]                       envir <- sys.frame(frame)
[17:40:47.928]                       master <- NULL
[17:40:47.928]                       while (!identical(envir, .GlobalEnv) && 
[17:40:47.928]                         !identical(envir, emptyenv())) {
[17:40:47.928]                         if (exists("master", mode = "list", envir = envir, 
[17:40:47.928]                           inherits = FALSE)) {
[17:40:47.928]                           master <- get("master", mode = "list", 
[17:40:47.928]                             envir = envir, inherits = FALSE)
[17:40:47.928]                           if (inherits(master, c("SOCKnode", 
[17:40:47.928]                             "SOCK0node"))) {
[17:40:47.928]                             sendCondition <<- function(cond) {
[17:40:47.928]                               data <- list(type = "VALUE", value = cond, 
[17:40:47.928]                                 success = TRUE)
[17:40:47.928]                               parallel_sendData(master, data)
[17:40:47.928]                             }
[17:40:47.928]                             return(sendCondition)
[17:40:47.928]                           }
[17:40:47.928]                         }
[17:40:47.928]                         frame <- frame + 1L
[17:40:47.928]                         envir <- sys.frame(frame)
[17:40:47.928]                       }
[17:40:47.928]                     }
[17:40:47.928]                     sendCondition <<- function(cond) NULL
[17:40:47.928]                   }
[17:40:47.928]                 })
[17:40:47.928]                 withCallingHandlers({
[17:40:47.928]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:47.928]                 }, immediateCondition = function(cond) {
[17:40:47.928]                   sendCondition <- ...future.makeSendCondition()
[17:40:47.928]                   sendCondition(cond)
[17:40:47.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.928]                   {
[17:40:47.928]                     inherits <- base::inherits
[17:40:47.928]                     invokeRestart <- base::invokeRestart
[17:40:47.928]                     is.null <- base::is.null
[17:40:47.928]                     muffled <- FALSE
[17:40:47.928]                     if (inherits(cond, "message")) {
[17:40:47.928]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:47.928]                       if (muffled) 
[17:40:47.928]                         invokeRestart("muffleMessage")
[17:40:47.928]                     }
[17:40:47.928]                     else if (inherits(cond, "warning")) {
[17:40:47.928]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:47.928]                       if (muffled) 
[17:40:47.928]                         invokeRestart("muffleWarning")
[17:40:47.928]                     }
[17:40:47.928]                     else if (inherits(cond, "condition")) {
[17:40:47.928]                       if (!is.null(pattern)) {
[17:40:47.928]                         computeRestarts <- base::computeRestarts
[17:40:47.928]                         grepl <- base::grepl
[17:40:47.928]                         restarts <- computeRestarts(cond)
[17:40:47.928]                         for (restart in restarts) {
[17:40:47.928]                           name <- restart$name
[17:40:47.928]                           if (is.null(name)) 
[17:40:47.928]                             next
[17:40:47.928]                           if (!grepl(pattern, name)) 
[17:40:47.928]                             next
[17:40:47.928]                           invokeRestart(restart)
[17:40:47.928]                           muffled <- TRUE
[17:40:47.928]                           break
[17:40:47.928]                         }
[17:40:47.928]                       }
[17:40:47.928]                     }
[17:40:47.928]                     invisible(muffled)
[17:40:47.928]                   }
[17:40:47.928]                   muffleCondition(cond)
[17:40:47.928]                 })
[17:40:47.928]             }))
[17:40:47.928]             future::FutureResult(value = ...future.value$value, 
[17:40:47.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.928]                   ...future.rng), globalenv = if (FALSE) 
[17:40:47.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:47.928]                     ...future.globalenv.names))
[17:40:47.928]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:47.928]         }, condition = base::local({
[17:40:47.928]             c <- base::c
[17:40:47.928]             inherits <- base::inherits
[17:40:47.928]             invokeRestart <- base::invokeRestart
[17:40:47.928]             length <- base::length
[17:40:47.928]             list <- base::list
[17:40:47.928]             seq.int <- base::seq.int
[17:40:47.928]             signalCondition <- base::signalCondition
[17:40:47.928]             sys.calls <- base::sys.calls
[17:40:47.928]             `[[` <- base::`[[`
[17:40:47.928]             `+` <- base::`+`
[17:40:47.928]             `<<-` <- base::`<<-`
[17:40:47.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:47.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:47.928]                   3L)]
[17:40:47.928]             }
[17:40:47.928]             function(cond) {
[17:40:47.928]                 is_error <- inherits(cond, "error")
[17:40:47.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:47.928]                   NULL)
[17:40:47.928]                 if (is_error) {
[17:40:47.928]                   sessionInformation <- function() {
[17:40:47.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:47.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:47.928]                       search = base::search(), system = base::Sys.info())
[17:40:47.928]                   }
[17:40:47.928]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:47.928]                     cond$call), session = sessionInformation(), 
[17:40:47.928]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:47.928]                   signalCondition(cond)
[17:40:47.928]                 }
[17:40:47.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:47.928]                 "immediateCondition"))) {
[17:40:47.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:47.928]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:47.928]                   if (TRUE && !signal) {
[17:40:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.928]                     {
[17:40:47.928]                       inherits <- base::inherits
[17:40:47.928]                       invokeRestart <- base::invokeRestart
[17:40:47.928]                       is.null <- base::is.null
[17:40:47.928]                       muffled <- FALSE
[17:40:47.928]                       if (inherits(cond, "message")) {
[17:40:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.928]                         if (muffled) 
[17:40:47.928]                           invokeRestart("muffleMessage")
[17:40:47.928]                       }
[17:40:47.928]                       else if (inherits(cond, "warning")) {
[17:40:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.928]                         if (muffled) 
[17:40:47.928]                           invokeRestart("muffleWarning")
[17:40:47.928]                       }
[17:40:47.928]                       else if (inherits(cond, "condition")) {
[17:40:47.928]                         if (!is.null(pattern)) {
[17:40:47.928]                           computeRestarts <- base::computeRestarts
[17:40:47.928]                           grepl <- base::grepl
[17:40:47.928]                           restarts <- computeRestarts(cond)
[17:40:47.928]                           for (restart in restarts) {
[17:40:47.928]                             name <- restart$name
[17:40:47.928]                             if (is.null(name)) 
[17:40:47.928]                               next
[17:40:47.928]                             if (!grepl(pattern, name)) 
[17:40:47.928]                               next
[17:40:47.928]                             invokeRestart(restart)
[17:40:47.928]                             muffled <- TRUE
[17:40:47.928]                             break
[17:40:47.928]                           }
[17:40:47.928]                         }
[17:40:47.928]                       }
[17:40:47.928]                       invisible(muffled)
[17:40:47.928]                     }
[17:40:47.928]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.928]                   }
[17:40:47.928]                 }
[17:40:47.928]                 else {
[17:40:47.928]                   if (TRUE) {
[17:40:47.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.928]                     {
[17:40:47.928]                       inherits <- base::inherits
[17:40:47.928]                       invokeRestart <- base::invokeRestart
[17:40:47.928]                       is.null <- base::is.null
[17:40:47.928]                       muffled <- FALSE
[17:40:47.928]                       if (inherits(cond, "message")) {
[17:40:47.928]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.928]                         if (muffled) 
[17:40:47.928]                           invokeRestart("muffleMessage")
[17:40:47.928]                       }
[17:40:47.928]                       else if (inherits(cond, "warning")) {
[17:40:47.928]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.928]                         if (muffled) 
[17:40:47.928]                           invokeRestart("muffleWarning")
[17:40:47.928]                       }
[17:40:47.928]                       else if (inherits(cond, "condition")) {
[17:40:47.928]                         if (!is.null(pattern)) {
[17:40:47.928]                           computeRestarts <- base::computeRestarts
[17:40:47.928]                           grepl <- base::grepl
[17:40:47.928]                           restarts <- computeRestarts(cond)
[17:40:47.928]                           for (restart in restarts) {
[17:40:47.928]                             name <- restart$name
[17:40:47.928]                             if (is.null(name)) 
[17:40:47.928]                               next
[17:40:47.928]                             if (!grepl(pattern, name)) 
[17:40:47.928]                               next
[17:40:47.928]                             invokeRestart(restart)
[17:40:47.928]                             muffled <- TRUE
[17:40:47.928]                             break
[17:40:47.928]                           }
[17:40:47.928]                         }
[17:40:47.928]                       }
[17:40:47.928]                       invisible(muffled)
[17:40:47.928]                     }
[17:40:47.928]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.928]                   }
[17:40:47.928]                 }
[17:40:47.928]             }
[17:40:47.928]         }))
[17:40:47.928]     }, error = function(ex) {
[17:40:47.928]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:47.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.928]                 ...future.rng), started = ...future.startTime, 
[17:40:47.928]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:47.928]             version = "1.8"), class = "FutureResult")
[17:40:47.928]     }, finally = {
[17:40:47.928]         if (!identical(...future.workdir, getwd())) 
[17:40:47.928]             setwd(...future.workdir)
[17:40:47.928]         {
[17:40:47.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:47.928]                 ...future.oldOptions$nwarnings <- NULL
[17:40:47.928]             }
[17:40:47.928]             base::options(...future.oldOptions)
[17:40:47.928]             if (.Platform$OS.type == "windows") {
[17:40:47.928]                 old_names <- names(...future.oldEnvVars)
[17:40:47.928]                 envs <- base::Sys.getenv()
[17:40:47.928]                 names <- names(envs)
[17:40:47.928]                 common <- intersect(names, old_names)
[17:40:47.928]                 added <- setdiff(names, old_names)
[17:40:47.928]                 removed <- setdiff(old_names, names)
[17:40:47.928]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:47.928]                   envs[common]]
[17:40:47.928]                 NAMES <- toupper(changed)
[17:40:47.928]                 args <- list()
[17:40:47.928]                 for (kk in seq_along(NAMES)) {
[17:40:47.928]                   name <- changed[[kk]]
[17:40:47.928]                   NAME <- NAMES[[kk]]
[17:40:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.928]                     next
[17:40:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.928]                 }
[17:40:47.928]                 NAMES <- toupper(added)
[17:40:47.928]                 for (kk in seq_along(NAMES)) {
[17:40:47.928]                   name <- added[[kk]]
[17:40:47.928]                   NAME <- NAMES[[kk]]
[17:40:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.928]                     next
[17:40:47.928]                   args[[name]] <- ""
[17:40:47.928]                 }
[17:40:47.928]                 NAMES <- toupper(removed)
[17:40:47.928]                 for (kk in seq_along(NAMES)) {
[17:40:47.928]                   name <- removed[[kk]]
[17:40:47.928]                   NAME <- NAMES[[kk]]
[17:40:47.928]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.928]                     next
[17:40:47.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.928]                 }
[17:40:47.928]                 if (length(args) > 0) 
[17:40:47.928]                   base::do.call(base::Sys.setenv, args = args)
[17:40:47.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:47.928]             }
[17:40:47.928]             else {
[17:40:47.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:47.928]             }
[17:40:47.928]             {
[17:40:47.928]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:47.928]                   0L) {
[17:40:47.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:47.928]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:47.928]                   base::options(opts)
[17:40:47.928]                 }
[17:40:47.928]                 {
[17:40:47.928]                   {
[17:40:47.928]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:47.928]                     NULL
[17:40:47.928]                   }
[17:40:47.928]                   options(future.plan = NULL)
[17:40:47.928]                   if (is.na(NA_character_)) 
[17:40:47.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:47.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:47.928]                     .init = FALSE)
[17:40:47.928]                 }
[17:40:47.928]             }
[17:40:47.928]         }
[17:40:47.928]     })
[17:40:47.928]     if (TRUE) {
[17:40:47.928]         base::sink(type = "output", split = FALSE)
[17:40:47.928]         if (TRUE) {
[17:40:47.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:47.928]         }
[17:40:47.928]         else {
[17:40:47.928]             ...future.result["stdout"] <- base::list(NULL)
[17:40:47.928]         }
[17:40:47.928]         base::close(...future.stdout)
[17:40:47.928]         ...future.stdout <- NULL
[17:40:47.928]     }
[17:40:47.928]     ...future.result$conditions <- ...future.conditions
[17:40:47.928]     ...future.result$finished <- base::Sys.time()
[17:40:47.928]     ...future.result
[17:40:47.928] }
[17:40:47.931] MultisessionFuture started
[17:40:47.932] - Launch lazy future ... done
[17:40:47.932] run() for ‘MultisessionFuture’ ... done
[17:40:47.933] receiveMessageFromWorker() for ClusterFuture ...
[17:40:47.933] - Validating connection of MultisessionFuture
[17:40:47.934] - received message: FutureResult
[17:40:47.934] - Received FutureResult
[17:40:47.934] - Erased future from FutureRegistry
[17:40:47.936] result() for ClusterFuture ...
[17:40:47.936] - result already collected: FutureResult
[17:40:47.937] result() for ClusterFuture ... done
[17:40:47.937] signalConditions() ...
[17:40:47.937]  - include = ‘immediateCondition’
[17:40:47.937]  - exclude = 
[17:40:47.937]  - resignal = FALSE
[17:40:47.937]  - Number of conditions: 1
[17:40:47.937] signalConditions() ... done
[17:40:47.937] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:47.937] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[17:40:47.937] getGlobalsAndPackages() ...
[17:40:47.938] Searching for globals...
[17:40:47.939] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:47.939] Searching for globals ... DONE
[17:40:47.939] Resolving globals: FALSE
[17:40:47.939] 
[17:40:47.939] 
[17:40:47.939] getGlobalsAndPackages() ... DONE
[17:40:47.940] run() for ‘Future’ ...
[17:40:47.940] - state: ‘created’
[17:40:47.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:47.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:47.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:47.954]   - Field: ‘node’
[17:40:47.954]   - Field: ‘label’
[17:40:47.954]   - Field: ‘local’
[17:40:47.954]   - Field: ‘owner’
[17:40:47.954]   - Field: ‘envir’
[17:40:47.954]   - Field: ‘workers’
[17:40:47.954]   - Field: ‘packages’
[17:40:47.954]   - Field: ‘gc’
[17:40:47.955]   - Field: ‘conditions’
[17:40:47.955]   - Field: ‘persistent’
[17:40:47.955]   - Field: ‘expr’
[17:40:47.955]   - Field: ‘uuid’
[17:40:47.955]   - Field: ‘seed’
[17:40:47.955]   - Field: ‘version’
[17:40:47.955]   - Field: ‘result’
[17:40:47.955]   - Field: ‘asynchronous’
[17:40:47.955]   - Field: ‘calls’
[17:40:47.955]   - Field: ‘globals’
[17:40:47.955]   - Field: ‘stdout’
[17:40:47.955]   - Field: ‘earlySignal’
[17:40:47.956]   - Field: ‘lazy’
[17:40:47.956]   - Field: ‘state’
[17:40:47.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:47.956] - Launch lazy future ...
[17:40:47.956] Packages needed by the future expression (n = 0): <none>
[17:40:47.956] Packages needed by future strategies (n = 0): <none>
[17:40:47.957] {
[17:40:47.957]     {
[17:40:47.957]         {
[17:40:47.957]             ...future.startTime <- base::Sys.time()
[17:40:47.957]             {
[17:40:47.957]                 {
[17:40:47.957]                   {
[17:40:47.957]                     {
[17:40:47.957]                       base::local({
[17:40:47.957]                         has_future <- base::requireNamespace("future", 
[17:40:47.957]                           quietly = TRUE)
[17:40:47.957]                         if (has_future) {
[17:40:47.957]                           ns <- base::getNamespace("future")
[17:40:47.957]                           version <- ns[[".package"]][["version"]]
[17:40:47.957]                           if (is.null(version)) 
[17:40:47.957]                             version <- utils::packageVersion("future")
[17:40:47.957]                         }
[17:40:47.957]                         else {
[17:40:47.957]                           version <- NULL
[17:40:47.957]                         }
[17:40:47.957]                         if (!has_future || version < "1.8.0") {
[17:40:47.957]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:47.957]                             "", base::R.version$version.string), 
[17:40:47.957]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:47.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:47.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:47.957]                               "release", "version")], collapse = " "), 
[17:40:47.957]                             hostname = base::Sys.info()[["nodename"]])
[17:40:47.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:47.957]                             info)
[17:40:47.957]                           info <- base::paste(info, collapse = "; ")
[17:40:47.957]                           if (!has_future) {
[17:40:47.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:47.957]                               info)
[17:40:47.957]                           }
[17:40:47.957]                           else {
[17:40:47.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:47.957]                               info, version)
[17:40:47.957]                           }
[17:40:47.957]                           base::stop(msg)
[17:40:47.957]                         }
[17:40:47.957]                       })
[17:40:47.957]                     }
[17:40:47.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:47.957]                     base::options(mc.cores = 1L)
[17:40:47.957]                   }
[17:40:47.957]                   ...future.strategy.old <- future::plan("list")
[17:40:47.957]                   options(future.plan = NULL)
[17:40:47.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:47.957]                 }
[17:40:47.957]                 ...future.workdir <- getwd()
[17:40:47.957]             }
[17:40:47.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:47.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:47.957]         }
[17:40:47.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:47.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:47.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:47.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:47.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:47.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:47.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:47.957]             base::names(...future.oldOptions))
[17:40:47.957]     }
[17:40:47.957]     if (FALSE) {
[17:40:47.957]     }
[17:40:47.957]     else {
[17:40:47.957]         if (TRUE) {
[17:40:47.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:47.957]                 open = "w")
[17:40:47.957]         }
[17:40:47.957]         else {
[17:40:47.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:47.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:47.957]         }
[17:40:47.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:47.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:47.957]             base::sink(type = "output", split = FALSE)
[17:40:47.957]             base::close(...future.stdout)
[17:40:47.957]         }, add = TRUE)
[17:40:47.957]     }
[17:40:47.957]     ...future.frame <- base::sys.nframe()
[17:40:47.957]     ...future.conditions <- base::list()
[17:40:47.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:47.957]     if (FALSE) {
[17:40:47.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:47.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:47.957]     }
[17:40:47.957]     ...future.result <- base::tryCatch({
[17:40:47.957]         base::withCallingHandlers({
[17:40:47.957]             ...future.value <- base::withVisible(base::local({
[17:40:47.957]                 ...future.makeSendCondition <- base::local({
[17:40:47.957]                   sendCondition <- NULL
[17:40:47.957]                   function(frame = 1L) {
[17:40:47.957]                     if (is.function(sendCondition)) 
[17:40:47.957]                       return(sendCondition)
[17:40:47.957]                     ns <- getNamespace("parallel")
[17:40:47.957]                     if (exists("sendData", mode = "function", 
[17:40:47.957]                       envir = ns)) {
[17:40:47.957]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:47.957]                         envir = ns)
[17:40:47.957]                       envir <- sys.frame(frame)
[17:40:47.957]                       master <- NULL
[17:40:47.957]                       while (!identical(envir, .GlobalEnv) && 
[17:40:47.957]                         !identical(envir, emptyenv())) {
[17:40:47.957]                         if (exists("master", mode = "list", envir = envir, 
[17:40:47.957]                           inherits = FALSE)) {
[17:40:47.957]                           master <- get("master", mode = "list", 
[17:40:47.957]                             envir = envir, inherits = FALSE)
[17:40:47.957]                           if (inherits(master, c("SOCKnode", 
[17:40:47.957]                             "SOCK0node"))) {
[17:40:47.957]                             sendCondition <<- function(cond) {
[17:40:47.957]                               data <- list(type = "VALUE", value = cond, 
[17:40:47.957]                                 success = TRUE)
[17:40:47.957]                               parallel_sendData(master, data)
[17:40:47.957]                             }
[17:40:47.957]                             return(sendCondition)
[17:40:47.957]                           }
[17:40:47.957]                         }
[17:40:47.957]                         frame <- frame + 1L
[17:40:47.957]                         envir <- sys.frame(frame)
[17:40:47.957]                       }
[17:40:47.957]                     }
[17:40:47.957]                     sendCondition <<- function(cond) NULL
[17:40:47.957]                   }
[17:40:47.957]                 })
[17:40:47.957]                 withCallingHandlers({
[17:40:47.957]                   {
[17:40:47.957]                     Sys.sleep(0.5)
[17:40:47.957]                     list(a = 1, b = 42L)
[17:40:47.957]                   }
[17:40:47.957]                 }, immediateCondition = function(cond) {
[17:40:47.957]                   sendCondition <- ...future.makeSendCondition()
[17:40:47.957]                   sendCondition(cond)
[17:40:47.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.957]                   {
[17:40:47.957]                     inherits <- base::inherits
[17:40:47.957]                     invokeRestart <- base::invokeRestart
[17:40:47.957]                     is.null <- base::is.null
[17:40:47.957]                     muffled <- FALSE
[17:40:47.957]                     if (inherits(cond, "message")) {
[17:40:47.957]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:47.957]                       if (muffled) 
[17:40:47.957]                         invokeRestart("muffleMessage")
[17:40:47.957]                     }
[17:40:47.957]                     else if (inherits(cond, "warning")) {
[17:40:47.957]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:47.957]                       if (muffled) 
[17:40:47.957]                         invokeRestart("muffleWarning")
[17:40:47.957]                     }
[17:40:47.957]                     else if (inherits(cond, "condition")) {
[17:40:47.957]                       if (!is.null(pattern)) {
[17:40:47.957]                         computeRestarts <- base::computeRestarts
[17:40:47.957]                         grepl <- base::grepl
[17:40:47.957]                         restarts <- computeRestarts(cond)
[17:40:47.957]                         for (restart in restarts) {
[17:40:47.957]                           name <- restart$name
[17:40:47.957]                           if (is.null(name)) 
[17:40:47.957]                             next
[17:40:47.957]                           if (!grepl(pattern, name)) 
[17:40:47.957]                             next
[17:40:47.957]                           invokeRestart(restart)
[17:40:47.957]                           muffled <- TRUE
[17:40:47.957]                           break
[17:40:47.957]                         }
[17:40:47.957]                       }
[17:40:47.957]                     }
[17:40:47.957]                     invisible(muffled)
[17:40:47.957]                   }
[17:40:47.957]                   muffleCondition(cond)
[17:40:47.957]                 })
[17:40:47.957]             }))
[17:40:47.957]             future::FutureResult(value = ...future.value$value, 
[17:40:47.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.957]                   ...future.rng), globalenv = if (FALSE) 
[17:40:47.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:47.957]                     ...future.globalenv.names))
[17:40:47.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:47.957]         }, condition = base::local({
[17:40:47.957]             c <- base::c
[17:40:47.957]             inherits <- base::inherits
[17:40:47.957]             invokeRestart <- base::invokeRestart
[17:40:47.957]             length <- base::length
[17:40:47.957]             list <- base::list
[17:40:47.957]             seq.int <- base::seq.int
[17:40:47.957]             signalCondition <- base::signalCondition
[17:40:47.957]             sys.calls <- base::sys.calls
[17:40:47.957]             `[[` <- base::`[[`
[17:40:47.957]             `+` <- base::`+`
[17:40:47.957]             `<<-` <- base::`<<-`
[17:40:47.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:47.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:47.957]                   3L)]
[17:40:47.957]             }
[17:40:47.957]             function(cond) {
[17:40:47.957]                 is_error <- inherits(cond, "error")
[17:40:47.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:47.957]                   NULL)
[17:40:47.957]                 if (is_error) {
[17:40:47.957]                   sessionInformation <- function() {
[17:40:47.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:47.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:47.957]                       search = base::search(), system = base::Sys.info())
[17:40:47.957]                   }
[17:40:47.957]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:47.957]                     cond$call), session = sessionInformation(), 
[17:40:47.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:47.957]                   signalCondition(cond)
[17:40:47.957]                 }
[17:40:47.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:47.957]                 "immediateCondition"))) {
[17:40:47.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:47.957]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:47.957]                   if (TRUE && !signal) {
[17:40:47.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.957]                     {
[17:40:47.957]                       inherits <- base::inherits
[17:40:47.957]                       invokeRestart <- base::invokeRestart
[17:40:47.957]                       is.null <- base::is.null
[17:40:47.957]                       muffled <- FALSE
[17:40:47.957]                       if (inherits(cond, "message")) {
[17:40:47.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.957]                         if (muffled) 
[17:40:47.957]                           invokeRestart("muffleMessage")
[17:40:47.957]                       }
[17:40:47.957]                       else if (inherits(cond, "warning")) {
[17:40:47.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.957]                         if (muffled) 
[17:40:47.957]                           invokeRestart("muffleWarning")
[17:40:47.957]                       }
[17:40:47.957]                       else if (inherits(cond, "condition")) {
[17:40:47.957]                         if (!is.null(pattern)) {
[17:40:47.957]                           computeRestarts <- base::computeRestarts
[17:40:47.957]                           grepl <- base::grepl
[17:40:47.957]                           restarts <- computeRestarts(cond)
[17:40:47.957]                           for (restart in restarts) {
[17:40:47.957]                             name <- restart$name
[17:40:47.957]                             if (is.null(name)) 
[17:40:47.957]                               next
[17:40:47.957]                             if (!grepl(pattern, name)) 
[17:40:47.957]                               next
[17:40:47.957]                             invokeRestart(restart)
[17:40:47.957]                             muffled <- TRUE
[17:40:47.957]                             break
[17:40:47.957]                           }
[17:40:47.957]                         }
[17:40:47.957]                       }
[17:40:47.957]                       invisible(muffled)
[17:40:47.957]                     }
[17:40:47.957]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.957]                   }
[17:40:47.957]                 }
[17:40:47.957]                 else {
[17:40:47.957]                   if (TRUE) {
[17:40:47.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.957]                     {
[17:40:47.957]                       inherits <- base::inherits
[17:40:47.957]                       invokeRestart <- base::invokeRestart
[17:40:47.957]                       is.null <- base::is.null
[17:40:47.957]                       muffled <- FALSE
[17:40:47.957]                       if (inherits(cond, "message")) {
[17:40:47.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.957]                         if (muffled) 
[17:40:47.957]                           invokeRestart("muffleMessage")
[17:40:47.957]                       }
[17:40:47.957]                       else if (inherits(cond, "warning")) {
[17:40:47.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.957]                         if (muffled) 
[17:40:47.957]                           invokeRestart("muffleWarning")
[17:40:47.957]                       }
[17:40:47.957]                       else if (inherits(cond, "condition")) {
[17:40:47.957]                         if (!is.null(pattern)) {
[17:40:47.957]                           computeRestarts <- base::computeRestarts
[17:40:47.957]                           grepl <- base::grepl
[17:40:47.957]                           restarts <- computeRestarts(cond)
[17:40:47.957]                           for (restart in restarts) {
[17:40:47.957]                             name <- restart$name
[17:40:47.957]                             if (is.null(name)) 
[17:40:47.957]                               next
[17:40:47.957]                             if (!grepl(pattern, name)) 
[17:40:47.957]                               next
[17:40:47.957]                             invokeRestart(restart)
[17:40:47.957]                             muffled <- TRUE
[17:40:47.957]                             break
[17:40:47.957]                           }
[17:40:47.957]                         }
[17:40:47.957]                       }
[17:40:47.957]                       invisible(muffled)
[17:40:47.957]                     }
[17:40:47.957]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.957]                   }
[17:40:47.957]                 }
[17:40:47.957]             }
[17:40:47.957]         }))
[17:40:47.957]     }, error = function(ex) {
[17:40:47.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:47.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.957]                 ...future.rng), started = ...future.startTime, 
[17:40:47.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:47.957]             version = "1.8"), class = "FutureResult")
[17:40:47.957]     }, finally = {
[17:40:47.957]         if (!identical(...future.workdir, getwd())) 
[17:40:47.957]             setwd(...future.workdir)
[17:40:47.957]         {
[17:40:47.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:47.957]                 ...future.oldOptions$nwarnings <- NULL
[17:40:47.957]             }
[17:40:47.957]             base::options(...future.oldOptions)
[17:40:47.957]             if (.Platform$OS.type == "windows") {
[17:40:47.957]                 old_names <- names(...future.oldEnvVars)
[17:40:47.957]                 envs <- base::Sys.getenv()
[17:40:47.957]                 names <- names(envs)
[17:40:47.957]                 common <- intersect(names, old_names)
[17:40:47.957]                 added <- setdiff(names, old_names)
[17:40:47.957]                 removed <- setdiff(old_names, names)
[17:40:47.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:47.957]                   envs[common]]
[17:40:47.957]                 NAMES <- toupper(changed)
[17:40:47.957]                 args <- list()
[17:40:47.957]                 for (kk in seq_along(NAMES)) {
[17:40:47.957]                   name <- changed[[kk]]
[17:40:47.957]                   NAME <- NAMES[[kk]]
[17:40:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.957]                     next
[17:40:47.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.957]                 }
[17:40:47.957]                 NAMES <- toupper(added)
[17:40:47.957]                 for (kk in seq_along(NAMES)) {
[17:40:47.957]                   name <- added[[kk]]
[17:40:47.957]                   NAME <- NAMES[[kk]]
[17:40:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.957]                     next
[17:40:47.957]                   args[[name]] <- ""
[17:40:47.957]                 }
[17:40:47.957]                 NAMES <- toupper(removed)
[17:40:47.957]                 for (kk in seq_along(NAMES)) {
[17:40:47.957]                   name <- removed[[kk]]
[17:40:47.957]                   NAME <- NAMES[[kk]]
[17:40:47.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.957]                     next
[17:40:47.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.957]                 }
[17:40:47.957]                 if (length(args) > 0) 
[17:40:47.957]                   base::do.call(base::Sys.setenv, args = args)
[17:40:47.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:47.957]             }
[17:40:47.957]             else {
[17:40:47.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:47.957]             }
[17:40:47.957]             {
[17:40:47.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:47.957]                   0L) {
[17:40:47.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:47.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:47.957]                   base::options(opts)
[17:40:47.957]                 }
[17:40:47.957]                 {
[17:40:47.957]                   {
[17:40:47.957]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:47.957]                     NULL
[17:40:47.957]                   }
[17:40:47.957]                   options(future.plan = NULL)
[17:40:47.957]                   if (is.na(NA_character_)) 
[17:40:47.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:47.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:47.957]                     .init = FALSE)
[17:40:47.957]                 }
[17:40:47.957]             }
[17:40:47.957]         }
[17:40:47.957]     })
[17:40:47.957]     if (TRUE) {
[17:40:47.957]         base::sink(type = "output", split = FALSE)
[17:40:47.957]         if (TRUE) {
[17:40:47.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:47.957]         }
[17:40:47.957]         else {
[17:40:47.957]             ...future.result["stdout"] <- base::list(NULL)
[17:40:47.957]         }
[17:40:47.957]         base::close(...future.stdout)
[17:40:47.957]         ...future.stdout <- NULL
[17:40:47.957]     }
[17:40:47.957]     ...future.result$conditions <- ...future.conditions
[17:40:47.957]     ...future.result$finished <- base::Sys.time()
[17:40:47.957]     ...future.result
[17:40:47.957] }
[17:40:47.960] MultisessionFuture started
[17:40:47.960] - Launch lazy future ... done
[17:40:47.960] run() for ‘MultisessionFuture’ ... done
[17:40:47.960] getGlobalsAndPackages() ...
[17:40:47.960] Searching for globals...
[17:40:47.961] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:47.961] Searching for globals ... DONE
[17:40:47.961] Resolving globals: FALSE
[17:40:47.962] 
[17:40:47.962] 
[17:40:47.962] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:40:47.962] getGlobalsAndPackages() ...
[17:40:47.962] Searching for globals...
[17:40:47.963] - globals found: [2] ‘list’, ‘stop’
[17:40:47.963] Searching for globals ... DONE
[17:40:47.963] Resolving globals: FALSE
[17:40:47.963] 
[17:40:47.963] 
[17:40:47.964] getGlobalsAndPackages() ... DONE
[17:40:47.964] run() for ‘Future’ ...
[17:40:47.964] - state: ‘created’
[17:40:47.964] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:47.978] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:47.978] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:47.978]   - Field: ‘node’
[17:40:47.978]   - Field: ‘label’
[17:40:47.978]   - Field: ‘local’
[17:40:47.978]   - Field: ‘owner’
[17:40:47.978]   - Field: ‘envir’
[17:40:47.979]   - Field: ‘workers’
[17:40:47.979]   - Field: ‘packages’
[17:40:47.979]   - Field: ‘gc’
[17:40:47.979]   - Field: ‘conditions’
[17:40:47.979]   - Field: ‘persistent’
[17:40:47.979]   - Field: ‘expr’
[17:40:47.979]   - Field: ‘uuid’
[17:40:47.979]   - Field: ‘seed’
[17:40:47.979]   - Field: ‘version’
[17:40:47.979]   - Field: ‘result’
[17:40:47.979]   - Field: ‘asynchronous’
[17:40:47.980]   - Field: ‘calls’
[17:40:47.980]   - Field: ‘globals’
[17:40:47.980]   - Field: ‘stdout’
[17:40:47.980]   - Field: ‘earlySignal’
[17:40:47.980]   - Field: ‘lazy’
[17:40:47.980]   - Field: ‘state’
[17:40:47.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:47.980] - Launch lazy future ...
[17:40:47.981] Packages needed by the future expression (n = 0): <none>
[17:40:47.981] Packages needed by future strategies (n = 0): <none>
[17:40:47.981] {
[17:40:47.981]     {
[17:40:47.981]         {
[17:40:47.981]             ...future.startTime <- base::Sys.time()
[17:40:47.981]             {
[17:40:47.981]                 {
[17:40:47.981]                   {
[17:40:47.981]                     {
[17:40:47.981]                       base::local({
[17:40:47.981]                         has_future <- base::requireNamespace("future", 
[17:40:47.981]                           quietly = TRUE)
[17:40:47.981]                         if (has_future) {
[17:40:47.981]                           ns <- base::getNamespace("future")
[17:40:47.981]                           version <- ns[[".package"]][["version"]]
[17:40:47.981]                           if (is.null(version)) 
[17:40:47.981]                             version <- utils::packageVersion("future")
[17:40:47.981]                         }
[17:40:47.981]                         else {
[17:40:47.981]                           version <- NULL
[17:40:47.981]                         }
[17:40:47.981]                         if (!has_future || version < "1.8.0") {
[17:40:47.981]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:47.981]                             "", base::R.version$version.string), 
[17:40:47.981]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:47.981]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:47.981]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:47.981]                               "release", "version")], collapse = " "), 
[17:40:47.981]                             hostname = base::Sys.info()[["nodename"]])
[17:40:47.981]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:47.981]                             info)
[17:40:47.981]                           info <- base::paste(info, collapse = "; ")
[17:40:47.981]                           if (!has_future) {
[17:40:47.981]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:47.981]                               info)
[17:40:47.981]                           }
[17:40:47.981]                           else {
[17:40:47.981]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:47.981]                               info, version)
[17:40:47.981]                           }
[17:40:47.981]                           base::stop(msg)
[17:40:47.981]                         }
[17:40:47.981]                       })
[17:40:47.981]                     }
[17:40:47.981]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:47.981]                     base::options(mc.cores = 1L)
[17:40:47.981]                   }
[17:40:47.981]                   ...future.strategy.old <- future::plan("list")
[17:40:47.981]                   options(future.plan = NULL)
[17:40:47.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:47.981]                 }
[17:40:47.981]                 ...future.workdir <- getwd()
[17:40:47.981]             }
[17:40:47.981]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:47.981]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:47.981]         }
[17:40:47.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:47.981]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:47.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:47.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:47.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:47.981]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:47.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:47.981]             base::names(...future.oldOptions))
[17:40:47.981]     }
[17:40:47.981]     if (FALSE) {
[17:40:47.981]     }
[17:40:47.981]     else {
[17:40:47.981]         if (TRUE) {
[17:40:47.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:47.981]                 open = "w")
[17:40:47.981]         }
[17:40:47.981]         else {
[17:40:47.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:47.981]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:47.981]         }
[17:40:47.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:47.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:47.981]             base::sink(type = "output", split = FALSE)
[17:40:47.981]             base::close(...future.stdout)
[17:40:47.981]         }, add = TRUE)
[17:40:47.981]     }
[17:40:47.981]     ...future.frame <- base::sys.nframe()
[17:40:47.981]     ...future.conditions <- base::list()
[17:40:47.981]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:47.981]     if (FALSE) {
[17:40:47.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:47.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:47.981]     }
[17:40:47.981]     ...future.result <- base::tryCatch({
[17:40:47.981]         base::withCallingHandlers({
[17:40:47.981]             ...future.value <- base::withVisible(base::local({
[17:40:47.981]                 ...future.makeSendCondition <- base::local({
[17:40:47.981]                   sendCondition <- NULL
[17:40:47.981]                   function(frame = 1L) {
[17:40:47.981]                     if (is.function(sendCondition)) 
[17:40:47.981]                       return(sendCondition)
[17:40:47.981]                     ns <- getNamespace("parallel")
[17:40:47.981]                     if (exists("sendData", mode = "function", 
[17:40:47.981]                       envir = ns)) {
[17:40:47.981]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:47.981]                         envir = ns)
[17:40:47.981]                       envir <- sys.frame(frame)
[17:40:47.981]                       master <- NULL
[17:40:47.981]                       while (!identical(envir, .GlobalEnv) && 
[17:40:47.981]                         !identical(envir, emptyenv())) {
[17:40:47.981]                         if (exists("master", mode = "list", envir = envir, 
[17:40:47.981]                           inherits = FALSE)) {
[17:40:47.981]                           master <- get("master", mode = "list", 
[17:40:47.981]                             envir = envir, inherits = FALSE)
[17:40:47.981]                           if (inherits(master, c("SOCKnode", 
[17:40:47.981]                             "SOCK0node"))) {
[17:40:47.981]                             sendCondition <<- function(cond) {
[17:40:47.981]                               data <- list(type = "VALUE", value = cond, 
[17:40:47.981]                                 success = TRUE)
[17:40:47.981]                               parallel_sendData(master, data)
[17:40:47.981]                             }
[17:40:47.981]                             return(sendCondition)
[17:40:47.981]                           }
[17:40:47.981]                         }
[17:40:47.981]                         frame <- frame + 1L
[17:40:47.981]                         envir <- sys.frame(frame)
[17:40:47.981]                       }
[17:40:47.981]                     }
[17:40:47.981]                     sendCondition <<- function(cond) NULL
[17:40:47.981]                   }
[17:40:47.981]                 })
[17:40:47.981]                 withCallingHandlers({
[17:40:47.981]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:47.981]                 }, immediateCondition = function(cond) {
[17:40:47.981]                   sendCondition <- ...future.makeSendCondition()
[17:40:47.981]                   sendCondition(cond)
[17:40:47.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.981]                   {
[17:40:47.981]                     inherits <- base::inherits
[17:40:47.981]                     invokeRestart <- base::invokeRestart
[17:40:47.981]                     is.null <- base::is.null
[17:40:47.981]                     muffled <- FALSE
[17:40:47.981]                     if (inherits(cond, "message")) {
[17:40:47.981]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:47.981]                       if (muffled) 
[17:40:47.981]                         invokeRestart("muffleMessage")
[17:40:47.981]                     }
[17:40:47.981]                     else if (inherits(cond, "warning")) {
[17:40:47.981]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:47.981]                       if (muffled) 
[17:40:47.981]                         invokeRestart("muffleWarning")
[17:40:47.981]                     }
[17:40:47.981]                     else if (inherits(cond, "condition")) {
[17:40:47.981]                       if (!is.null(pattern)) {
[17:40:47.981]                         computeRestarts <- base::computeRestarts
[17:40:47.981]                         grepl <- base::grepl
[17:40:47.981]                         restarts <- computeRestarts(cond)
[17:40:47.981]                         for (restart in restarts) {
[17:40:47.981]                           name <- restart$name
[17:40:47.981]                           if (is.null(name)) 
[17:40:47.981]                             next
[17:40:47.981]                           if (!grepl(pattern, name)) 
[17:40:47.981]                             next
[17:40:47.981]                           invokeRestart(restart)
[17:40:47.981]                           muffled <- TRUE
[17:40:47.981]                           break
[17:40:47.981]                         }
[17:40:47.981]                       }
[17:40:47.981]                     }
[17:40:47.981]                     invisible(muffled)
[17:40:47.981]                   }
[17:40:47.981]                   muffleCondition(cond)
[17:40:47.981]                 })
[17:40:47.981]             }))
[17:40:47.981]             future::FutureResult(value = ...future.value$value, 
[17:40:47.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.981]                   ...future.rng), globalenv = if (FALSE) 
[17:40:47.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:47.981]                     ...future.globalenv.names))
[17:40:47.981]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:47.981]         }, condition = base::local({
[17:40:47.981]             c <- base::c
[17:40:47.981]             inherits <- base::inherits
[17:40:47.981]             invokeRestart <- base::invokeRestart
[17:40:47.981]             length <- base::length
[17:40:47.981]             list <- base::list
[17:40:47.981]             seq.int <- base::seq.int
[17:40:47.981]             signalCondition <- base::signalCondition
[17:40:47.981]             sys.calls <- base::sys.calls
[17:40:47.981]             `[[` <- base::`[[`
[17:40:47.981]             `+` <- base::`+`
[17:40:47.981]             `<<-` <- base::`<<-`
[17:40:47.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:47.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:47.981]                   3L)]
[17:40:47.981]             }
[17:40:47.981]             function(cond) {
[17:40:47.981]                 is_error <- inherits(cond, "error")
[17:40:47.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:47.981]                   NULL)
[17:40:47.981]                 if (is_error) {
[17:40:47.981]                   sessionInformation <- function() {
[17:40:47.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:47.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:47.981]                       search = base::search(), system = base::Sys.info())
[17:40:47.981]                   }
[17:40:47.981]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:47.981]                     cond$call), session = sessionInformation(), 
[17:40:47.981]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:47.981]                   signalCondition(cond)
[17:40:47.981]                 }
[17:40:47.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:47.981]                 "immediateCondition"))) {
[17:40:47.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:47.981]                   ...future.conditions[[length(...future.conditions) + 
[17:40:47.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:47.981]                   if (TRUE && !signal) {
[17:40:47.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.981]                     {
[17:40:47.981]                       inherits <- base::inherits
[17:40:47.981]                       invokeRestart <- base::invokeRestart
[17:40:47.981]                       is.null <- base::is.null
[17:40:47.981]                       muffled <- FALSE
[17:40:47.981]                       if (inherits(cond, "message")) {
[17:40:47.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.981]                         if (muffled) 
[17:40:47.981]                           invokeRestart("muffleMessage")
[17:40:47.981]                       }
[17:40:47.981]                       else if (inherits(cond, "warning")) {
[17:40:47.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.981]                         if (muffled) 
[17:40:47.981]                           invokeRestart("muffleWarning")
[17:40:47.981]                       }
[17:40:47.981]                       else if (inherits(cond, "condition")) {
[17:40:47.981]                         if (!is.null(pattern)) {
[17:40:47.981]                           computeRestarts <- base::computeRestarts
[17:40:47.981]                           grepl <- base::grepl
[17:40:47.981]                           restarts <- computeRestarts(cond)
[17:40:47.981]                           for (restart in restarts) {
[17:40:47.981]                             name <- restart$name
[17:40:47.981]                             if (is.null(name)) 
[17:40:47.981]                               next
[17:40:47.981]                             if (!grepl(pattern, name)) 
[17:40:47.981]                               next
[17:40:47.981]                             invokeRestart(restart)
[17:40:47.981]                             muffled <- TRUE
[17:40:47.981]                             break
[17:40:47.981]                           }
[17:40:47.981]                         }
[17:40:47.981]                       }
[17:40:47.981]                       invisible(muffled)
[17:40:47.981]                     }
[17:40:47.981]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.981]                   }
[17:40:47.981]                 }
[17:40:47.981]                 else {
[17:40:47.981]                   if (TRUE) {
[17:40:47.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:47.981]                     {
[17:40:47.981]                       inherits <- base::inherits
[17:40:47.981]                       invokeRestart <- base::invokeRestart
[17:40:47.981]                       is.null <- base::is.null
[17:40:47.981]                       muffled <- FALSE
[17:40:47.981]                       if (inherits(cond, "message")) {
[17:40:47.981]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:47.981]                         if (muffled) 
[17:40:47.981]                           invokeRestart("muffleMessage")
[17:40:47.981]                       }
[17:40:47.981]                       else if (inherits(cond, "warning")) {
[17:40:47.981]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:47.981]                         if (muffled) 
[17:40:47.981]                           invokeRestart("muffleWarning")
[17:40:47.981]                       }
[17:40:47.981]                       else if (inherits(cond, "condition")) {
[17:40:47.981]                         if (!is.null(pattern)) {
[17:40:47.981]                           computeRestarts <- base::computeRestarts
[17:40:47.981]                           grepl <- base::grepl
[17:40:47.981]                           restarts <- computeRestarts(cond)
[17:40:47.981]                           for (restart in restarts) {
[17:40:47.981]                             name <- restart$name
[17:40:47.981]                             if (is.null(name)) 
[17:40:47.981]                               next
[17:40:47.981]                             if (!grepl(pattern, name)) 
[17:40:47.981]                               next
[17:40:47.981]                             invokeRestart(restart)
[17:40:47.981]                             muffled <- TRUE
[17:40:47.981]                             break
[17:40:47.981]                           }
[17:40:47.981]                         }
[17:40:47.981]                       }
[17:40:47.981]                       invisible(muffled)
[17:40:47.981]                     }
[17:40:47.981]                     muffleCondition(cond, pattern = "^muffle")
[17:40:47.981]                   }
[17:40:47.981]                 }
[17:40:47.981]             }
[17:40:47.981]         }))
[17:40:47.981]     }, error = function(ex) {
[17:40:47.981]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:47.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:47.981]                 ...future.rng), started = ...future.startTime, 
[17:40:47.981]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:47.981]             version = "1.8"), class = "FutureResult")
[17:40:47.981]     }, finally = {
[17:40:47.981]         if (!identical(...future.workdir, getwd())) 
[17:40:47.981]             setwd(...future.workdir)
[17:40:47.981]         {
[17:40:47.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:47.981]                 ...future.oldOptions$nwarnings <- NULL
[17:40:47.981]             }
[17:40:47.981]             base::options(...future.oldOptions)
[17:40:47.981]             if (.Platform$OS.type == "windows") {
[17:40:47.981]                 old_names <- names(...future.oldEnvVars)
[17:40:47.981]                 envs <- base::Sys.getenv()
[17:40:47.981]                 names <- names(envs)
[17:40:47.981]                 common <- intersect(names, old_names)
[17:40:47.981]                 added <- setdiff(names, old_names)
[17:40:47.981]                 removed <- setdiff(old_names, names)
[17:40:47.981]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:47.981]                   envs[common]]
[17:40:47.981]                 NAMES <- toupper(changed)
[17:40:47.981]                 args <- list()
[17:40:47.981]                 for (kk in seq_along(NAMES)) {
[17:40:47.981]                   name <- changed[[kk]]
[17:40:47.981]                   NAME <- NAMES[[kk]]
[17:40:47.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.981]                     next
[17:40:47.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.981]                 }
[17:40:47.981]                 NAMES <- toupper(added)
[17:40:47.981]                 for (kk in seq_along(NAMES)) {
[17:40:47.981]                   name <- added[[kk]]
[17:40:47.981]                   NAME <- NAMES[[kk]]
[17:40:47.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.981]                     next
[17:40:47.981]                   args[[name]] <- ""
[17:40:47.981]                 }
[17:40:47.981]                 NAMES <- toupper(removed)
[17:40:47.981]                 for (kk in seq_along(NAMES)) {
[17:40:47.981]                   name <- removed[[kk]]
[17:40:47.981]                   NAME <- NAMES[[kk]]
[17:40:47.981]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:47.981]                     next
[17:40:47.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:47.981]                 }
[17:40:47.981]                 if (length(args) > 0) 
[17:40:47.981]                   base::do.call(base::Sys.setenv, args = args)
[17:40:47.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:47.981]             }
[17:40:47.981]             else {
[17:40:47.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:47.981]             }
[17:40:47.981]             {
[17:40:47.981]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:47.981]                   0L) {
[17:40:47.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:47.981]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:47.981]                   base::options(opts)
[17:40:47.981]                 }
[17:40:47.981]                 {
[17:40:47.981]                   {
[17:40:47.981]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:47.981]                     NULL
[17:40:47.981]                   }
[17:40:47.981]                   options(future.plan = NULL)
[17:40:47.981]                   if (is.na(NA_character_)) 
[17:40:47.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:47.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:47.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:47.981]                     .init = FALSE)
[17:40:47.981]                 }
[17:40:47.981]             }
[17:40:47.981]         }
[17:40:47.981]     })
[17:40:47.981]     if (TRUE) {
[17:40:47.981]         base::sink(type = "output", split = FALSE)
[17:40:47.981]         if (TRUE) {
[17:40:47.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:47.981]         }
[17:40:47.981]         else {
[17:40:47.981]             ...future.result["stdout"] <- base::list(NULL)
[17:40:47.981]         }
[17:40:47.981]         base::close(...future.stdout)
[17:40:47.981]         ...future.stdout <- NULL
[17:40:47.981]     }
[17:40:47.981]     ...future.result$conditions <- ...future.conditions
[17:40:47.981]     ...future.result$finished <- base::Sys.time()
[17:40:47.981]     ...future.result
[17:40:47.981] }
[17:40:48.034] MultisessionFuture started
[17:40:48.035] - Launch lazy future ... done
[17:40:48.035] run() for ‘MultisessionFuture’ ... done
[17:40:48.035] getGlobalsAndPackages() ...
[17:40:48.035] Searching for globals...
[17:40:48.036] - globals found: [2] ‘list’, ‘stop’
[17:40:48.036] Searching for globals ... DONE
[17:40:48.036] Resolving globals: FALSE
[17:40:48.036] 
[17:40:48.036] 
[17:40:48.037] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[17:40:48.037] getGlobalsAndPackages() ...
[17:40:48.037] Searching for globals...
[17:40:48.038] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:48.038] Searching for globals ... DONE
[17:40:48.038] Resolving globals: FALSE
[17:40:48.039] 
[17:40:48.039] 
[17:40:48.039] getGlobalsAndPackages() ... DONE
[17:40:48.039] run() for ‘Future’ ...
[17:40:48.039] - state: ‘created’
[17:40:48.039] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:48.053] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:48.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:48.053]   - Field: ‘node’
[17:40:48.053]   - Field: ‘label’
[17:40:48.053]   - Field: ‘local’
[17:40:48.054]   - Field: ‘owner’
[17:40:48.054]   - Field: ‘envir’
[17:40:48.054]   - Field: ‘workers’
[17:40:48.054]   - Field: ‘packages’
[17:40:48.054]   - Field: ‘gc’
[17:40:48.054]   - Field: ‘conditions’
[17:40:48.054]   - Field: ‘persistent’
[17:40:48.054]   - Field: ‘expr’
[17:40:48.054]   - Field: ‘uuid’
[17:40:48.054]   - Field: ‘seed’
[17:40:48.054]   - Field: ‘version’
[17:40:48.055]   - Field: ‘result’
[17:40:48.055]   - Field: ‘asynchronous’
[17:40:48.055]   - Field: ‘calls’
[17:40:48.055]   - Field: ‘globals’
[17:40:48.055]   - Field: ‘stdout’
[17:40:48.055]   - Field: ‘earlySignal’
[17:40:48.055]   - Field: ‘lazy’
[17:40:48.055]   - Field: ‘state’
[17:40:48.055] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:48.055] - Launch lazy future ...
[17:40:48.056] Packages needed by the future expression (n = 0): <none>
[17:40:48.056] Packages needed by future strategies (n = 0): <none>
[17:40:48.056] {
[17:40:48.056]     {
[17:40:48.056]         {
[17:40:48.056]             ...future.startTime <- base::Sys.time()
[17:40:48.056]             {
[17:40:48.056]                 {
[17:40:48.056]                   {
[17:40:48.056]                     {
[17:40:48.056]                       base::local({
[17:40:48.056]                         has_future <- base::requireNamespace("future", 
[17:40:48.056]                           quietly = TRUE)
[17:40:48.056]                         if (has_future) {
[17:40:48.056]                           ns <- base::getNamespace("future")
[17:40:48.056]                           version <- ns[[".package"]][["version"]]
[17:40:48.056]                           if (is.null(version)) 
[17:40:48.056]                             version <- utils::packageVersion("future")
[17:40:48.056]                         }
[17:40:48.056]                         else {
[17:40:48.056]                           version <- NULL
[17:40:48.056]                         }
[17:40:48.056]                         if (!has_future || version < "1.8.0") {
[17:40:48.056]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:48.056]                             "", base::R.version$version.string), 
[17:40:48.056]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:48.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:48.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:48.056]                               "release", "version")], collapse = " "), 
[17:40:48.056]                             hostname = base::Sys.info()[["nodename"]])
[17:40:48.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:48.056]                             info)
[17:40:48.056]                           info <- base::paste(info, collapse = "; ")
[17:40:48.056]                           if (!has_future) {
[17:40:48.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:48.056]                               info)
[17:40:48.056]                           }
[17:40:48.056]                           else {
[17:40:48.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:48.056]                               info, version)
[17:40:48.056]                           }
[17:40:48.056]                           base::stop(msg)
[17:40:48.056]                         }
[17:40:48.056]                       })
[17:40:48.056]                     }
[17:40:48.056]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:48.056]                     base::options(mc.cores = 1L)
[17:40:48.056]                   }
[17:40:48.056]                   ...future.strategy.old <- future::plan("list")
[17:40:48.056]                   options(future.plan = NULL)
[17:40:48.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:48.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:48.056]                 }
[17:40:48.056]                 ...future.workdir <- getwd()
[17:40:48.056]             }
[17:40:48.056]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:48.056]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:48.056]         }
[17:40:48.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:48.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:48.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:48.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:48.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:48.056]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:48.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:48.056]             base::names(...future.oldOptions))
[17:40:48.056]     }
[17:40:48.056]     if (FALSE) {
[17:40:48.056]     }
[17:40:48.056]     else {
[17:40:48.056]         if (TRUE) {
[17:40:48.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:48.056]                 open = "w")
[17:40:48.056]         }
[17:40:48.056]         else {
[17:40:48.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:48.056]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:48.056]         }
[17:40:48.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:48.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:48.056]             base::sink(type = "output", split = FALSE)
[17:40:48.056]             base::close(...future.stdout)
[17:40:48.056]         }, add = TRUE)
[17:40:48.056]     }
[17:40:48.056]     ...future.frame <- base::sys.nframe()
[17:40:48.056]     ...future.conditions <- base::list()
[17:40:48.056]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:48.056]     if (FALSE) {
[17:40:48.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:48.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:48.056]     }
[17:40:48.056]     ...future.result <- base::tryCatch({
[17:40:48.056]         base::withCallingHandlers({
[17:40:48.056]             ...future.value <- base::withVisible(base::local({
[17:40:48.056]                 ...future.makeSendCondition <- base::local({
[17:40:48.056]                   sendCondition <- NULL
[17:40:48.056]                   function(frame = 1L) {
[17:40:48.056]                     if (is.function(sendCondition)) 
[17:40:48.056]                       return(sendCondition)
[17:40:48.056]                     ns <- getNamespace("parallel")
[17:40:48.056]                     if (exists("sendData", mode = "function", 
[17:40:48.056]                       envir = ns)) {
[17:40:48.056]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:48.056]                         envir = ns)
[17:40:48.056]                       envir <- sys.frame(frame)
[17:40:48.056]                       master <- NULL
[17:40:48.056]                       while (!identical(envir, .GlobalEnv) && 
[17:40:48.056]                         !identical(envir, emptyenv())) {
[17:40:48.056]                         if (exists("master", mode = "list", envir = envir, 
[17:40:48.056]                           inherits = FALSE)) {
[17:40:48.056]                           master <- get("master", mode = "list", 
[17:40:48.056]                             envir = envir, inherits = FALSE)
[17:40:48.056]                           if (inherits(master, c("SOCKnode", 
[17:40:48.056]                             "SOCK0node"))) {
[17:40:48.056]                             sendCondition <<- function(cond) {
[17:40:48.056]                               data <- list(type = "VALUE", value = cond, 
[17:40:48.056]                                 success = TRUE)
[17:40:48.056]                               parallel_sendData(master, data)
[17:40:48.056]                             }
[17:40:48.056]                             return(sendCondition)
[17:40:48.056]                           }
[17:40:48.056]                         }
[17:40:48.056]                         frame <- frame + 1L
[17:40:48.056]                         envir <- sys.frame(frame)
[17:40:48.056]                       }
[17:40:48.056]                     }
[17:40:48.056]                     sendCondition <<- function(cond) NULL
[17:40:48.056]                   }
[17:40:48.056]                 })
[17:40:48.056]                 withCallingHandlers({
[17:40:48.056]                   {
[17:40:48.056]                     Sys.sleep(0.5)
[17:40:48.056]                     list(a = 1, b = 42L)
[17:40:48.056]                   }
[17:40:48.056]                 }, immediateCondition = function(cond) {
[17:40:48.056]                   sendCondition <- ...future.makeSendCondition()
[17:40:48.056]                   sendCondition(cond)
[17:40:48.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.056]                   {
[17:40:48.056]                     inherits <- base::inherits
[17:40:48.056]                     invokeRestart <- base::invokeRestart
[17:40:48.056]                     is.null <- base::is.null
[17:40:48.056]                     muffled <- FALSE
[17:40:48.056]                     if (inherits(cond, "message")) {
[17:40:48.056]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:48.056]                       if (muffled) 
[17:40:48.056]                         invokeRestart("muffleMessage")
[17:40:48.056]                     }
[17:40:48.056]                     else if (inherits(cond, "warning")) {
[17:40:48.056]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:48.056]                       if (muffled) 
[17:40:48.056]                         invokeRestart("muffleWarning")
[17:40:48.056]                     }
[17:40:48.056]                     else if (inherits(cond, "condition")) {
[17:40:48.056]                       if (!is.null(pattern)) {
[17:40:48.056]                         computeRestarts <- base::computeRestarts
[17:40:48.056]                         grepl <- base::grepl
[17:40:48.056]                         restarts <- computeRestarts(cond)
[17:40:48.056]                         for (restart in restarts) {
[17:40:48.056]                           name <- restart$name
[17:40:48.056]                           if (is.null(name)) 
[17:40:48.056]                             next
[17:40:48.056]                           if (!grepl(pattern, name)) 
[17:40:48.056]                             next
[17:40:48.056]                           invokeRestart(restart)
[17:40:48.056]                           muffled <- TRUE
[17:40:48.056]                           break
[17:40:48.056]                         }
[17:40:48.056]                       }
[17:40:48.056]                     }
[17:40:48.056]                     invisible(muffled)
[17:40:48.056]                   }
[17:40:48.056]                   muffleCondition(cond)
[17:40:48.056]                 })
[17:40:48.056]             }))
[17:40:48.056]             future::FutureResult(value = ...future.value$value, 
[17:40:48.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:48.056]                   ...future.rng), globalenv = if (FALSE) 
[17:40:48.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:48.056]                     ...future.globalenv.names))
[17:40:48.056]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:48.056]         }, condition = base::local({
[17:40:48.056]             c <- base::c
[17:40:48.056]             inherits <- base::inherits
[17:40:48.056]             invokeRestart <- base::invokeRestart
[17:40:48.056]             length <- base::length
[17:40:48.056]             list <- base::list
[17:40:48.056]             seq.int <- base::seq.int
[17:40:48.056]             signalCondition <- base::signalCondition
[17:40:48.056]             sys.calls <- base::sys.calls
[17:40:48.056]             `[[` <- base::`[[`
[17:40:48.056]             `+` <- base::`+`
[17:40:48.056]             `<<-` <- base::`<<-`
[17:40:48.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:48.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:48.056]                   3L)]
[17:40:48.056]             }
[17:40:48.056]             function(cond) {
[17:40:48.056]                 is_error <- inherits(cond, "error")
[17:40:48.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:48.056]                   NULL)
[17:40:48.056]                 if (is_error) {
[17:40:48.056]                   sessionInformation <- function() {
[17:40:48.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:48.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:48.056]                       search = base::search(), system = base::Sys.info())
[17:40:48.056]                   }
[17:40:48.056]                   ...future.conditions[[length(...future.conditions) + 
[17:40:48.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:48.056]                     cond$call), session = sessionInformation(), 
[17:40:48.056]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:48.056]                   signalCondition(cond)
[17:40:48.056]                 }
[17:40:48.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:48.056]                 "immediateCondition"))) {
[17:40:48.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:48.056]                   ...future.conditions[[length(...future.conditions) + 
[17:40:48.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:48.056]                   if (TRUE && !signal) {
[17:40:48.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.056]                     {
[17:40:48.056]                       inherits <- base::inherits
[17:40:48.056]                       invokeRestart <- base::invokeRestart
[17:40:48.056]                       is.null <- base::is.null
[17:40:48.056]                       muffled <- FALSE
[17:40:48.056]                       if (inherits(cond, "message")) {
[17:40:48.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:48.056]                         if (muffled) 
[17:40:48.056]                           invokeRestart("muffleMessage")
[17:40:48.056]                       }
[17:40:48.056]                       else if (inherits(cond, "warning")) {
[17:40:48.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:48.056]                         if (muffled) 
[17:40:48.056]                           invokeRestart("muffleWarning")
[17:40:48.056]                       }
[17:40:48.056]                       else if (inherits(cond, "condition")) {
[17:40:48.056]                         if (!is.null(pattern)) {
[17:40:48.056]                           computeRestarts <- base::computeRestarts
[17:40:48.056]                           grepl <- base::grepl
[17:40:48.056]                           restarts <- computeRestarts(cond)
[17:40:48.056]                           for (restart in restarts) {
[17:40:48.056]                             name <- restart$name
[17:40:48.056]                             if (is.null(name)) 
[17:40:48.056]                               next
[17:40:48.056]                             if (!grepl(pattern, name)) 
[17:40:48.056]                               next
[17:40:48.056]                             invokeRestart(restart)
[17:40:48.056]                             muffled <- TRUE
[17:40:48.056]                             break
[17:40:48.056]                           }
[17:40:48.056]                         }
[17:40:48.056]                       }
[17:40:48.056]                       invisible(muffled)
[17:40:48.056]                     }
[17:40:48.056]                     muffleCondition(cond, pattern = "^muffle")
[17:40:48.056]                   }
[17:40:48.056]                 }
[17:40:48.056]                 else {
[17:40:48.056]                   if (TRUE) {
[17:40:48.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.056]                     {
[17:40:48.056]                       inherits <- base::inherits
[17:40:48.056]                       invokeRestart <- base::invokeRestart
[17:40:48.056]                       is.null <- base::is.null
[17:40:48.056]                       muffled <- FALSE
[17:40:48.056]                       if (inherits(cond, "message")) {
[17:40:48.056]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:48.056]                         if (muffled) 
[17:40:48.056]                           invokeRestart("muffleMessage")
[17:40:48.056]                       }
[17:40:48.056]                       else if (inherits(cond, "warning")) {
[17:40:48.056]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:48.056]                         if (muffled) 
[17:40:48.056]                           invokeRestart("muffleWarning")
[17:40:48.056]                       }
[17:40:48.056]                       else if (inherits(cond, "condition")) {
[17:40:48.056]                         if (!is.null(pattern)) {
[17:40:48.056]                           computeRestarts <- base::computeRestarts
[17:40:48.056]                           grepl <- base::grepl
[17:40:48.056]                           restarts <- computeRestarts(cond)
[17:40:48.056]                           for (restart in restarts) {
[17:40:48.056]                             name <- restart$name
[17:40:48.056]                             if (is.null(name)) 
[17:40:48.056]                               next
[17:40:48.056]                             if (!grepl(pattern, name)) 
[17:40:48.056]                               next
[17:40:48.056]                             invokeRestart(restart)
[17:40:48.056]                             muffled <- TRUE
[17:40:48.056]                             break
[17:40:48.056]                           }
[17:40:48.056]                         }
[17:40:48.056]                       }
[17:40:48.056]                       invisible(muffled)
[17:40:48.056]                     }
[17:40:48.056]                     muffleCondition(cond, pattern = "^muffle")
[17:40:48.056]                   }
[17:40:48.056]                 }
[17:40:48.056]             }
[17:40:48.056]         }))
[17:40:48.056]     }, error = function(ex) {
[17:40:48.056]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:48.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:48.056]                 ...future.rng), started = ...future.startTime, 
[17:40:48.056]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:48.056]             version = "1.8"), class = "FutureResult")
[17:40:48.056]     }, finally = {
[17:40:48.056]         if (!identical(...future.workdir, getwd())) 
[17:40:48.056]             setwd(...future.workdir)
[17:40:48.056]         {
[17:40:48.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:48.056]                 ...future.oldOptions$nwarnings <- NULL
[17:40:48.056]             }
[17:40:48.056]             base::options(...future.oldOptions)
[17:40:48.056]             if (.Platform$OS.type == "windows") {
[17:40:48.056]                 old_names <- names(...future.oldEnvVars)
[17:40:48.056]                 envs <- base::Sys.getenv()
[17:40:48.056]                 names <- names(envs)
[17:40:48.056]                 common <- intersect(names, old_names)
[17:40:48.056]                 added <- setdiff(names, old_names)
[17:40:48.056]                 removed <- setdiff(old_names, names)
[17:40:48.056]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:48.056]                   envs[common]]
[17:40:48.056]                 NAMES <- toupper(changed)
[17:40:48.056]                 args <- list()
[17:40:48.056]                 for (kk in seq_along(NAMES)) {
[17:40:48.056]                   name <- changed[[kk]]
[17:40:48.056]                   NAME <- NAMES[[kk]]
[17:40:48.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.056]                     next
[17:40:48.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:48.056]                 }
[17:40:48.056]                 NAMES <- toupper(added)
[17:40:48.056]                 for (kk in seq_along(NAMES)) {
[17:40:48.056]                   name <- added[[kk]]
[17:40:48.056]                   NAME <- NAMES[[kk]]
[17:40:48.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.056]                     next
[17:40:48.056]                   args[[name]] <- ""
[17:40:48.056]                 }
[17:40:48.056]                 NAMES <- toupper(removed)
[17:40:48.056]                 for (kk in seq_along(NAMES)) {
[17:40:48.056]                   name <- removed[[kk]]
[17:40:48.056]                   NAME <- NAMES[[kk]]
[17:40:48.056]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.056]                     next
[17:40:48.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:48.056]                 }
[17:40:48.056]                 if (length(args) > 0) 
[17:40:48.056]                   base::do.call(base::Sys.setenv, args = args)
[17:40:48.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:48.056]             }
[17:40:48.056]             else {
[17:40:48.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:48.056]             }
[17:40:48.056]             {
[17:40:48.056]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:48.056]                   0L) {
[17:40:48.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:48.056]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:48.056]                   base::options(opts)
[17:40:48.056]                 }
[17:40:48.056]                 {
[17:40:48.056]                   {
[17:40:48.056]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:48.056]                     NULL
[17:40:48.056]                   }
[17:40:48.056]                   options(future.plan = NULL)
[17:40:48.056]                   if (is.na(NA_character_)) 
[17:40:48.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:48.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:48.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:48.056]                     .init = FALSE)
[17:40:48.056]                 }
[17:40:48.056]             }
[17:40:48.056]         }
[17:40:48.056]     })
[17:40:48.056]     if (TRUE) {
[17:40:48.056]         base::sink(type = "output", split = FALSE)
[17:40:48.056]         if (TRUE) {
[17:40:48.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:48.056]         }
[17:40:48.056]         else {
[17:40:48.056]             ...future.result["stdout"] <- base::list(NULL)
[17:40:48.056]         }
[17:40:48.056]         base::close(...future.stdout)
[17:40:48.056]         ...future.stdout <- NULL
[17:40:48.056]     }
[17:40:48.056]     ...future.result$conditions <- ...future.conditions
[17:40:48.056]     ...future.result$finished <- base::Sys.time()
[17:40:48.056]     ...future.result
[17:40:48.056] }
[17:40:48.058] Poll #1 (0): usedNodes() = 2, workers = 2
[17:40:48.080] receiveMessageFromWorker() for ClusterFuture ...
[17:40:48.080] - Validating connection of MultisessionFuture
[17:40:48.080] - received message: FutureResult
[17:40:48.080] - Received FutureResult
[17:40:48.081] - Erased future from FutureRegistry
[17:40:48.081] result() for ClusterFuture ...
[17:40:48.081] - result already collected: FutureResult
[17:40:48.081] result() for ClusterFuture ... done
[17:40:48.081] signalConditions() ...
[17:40:48.081]  - include = ‘immediateCondition’
[17:40:48.081]  - exclude = 
[17:40:48.081]  - resignal = FALSE
[17:40:48.081]  - Number of conditions: 1
[17:40:48.081] signalConditions() ... done
[17:40:48.082] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:48.082] result() for ClusterFuture ...
[17:40:48.082] - result already collected: FutureResult
[17:40:48.082] result() for ClusterFuture ... done
[17:40:48.082] result() for ClusterFuture ...
[17:40:48.082] - result already collected: FutureResult
[17:40:48.082] result() for ClusterFuture ... done
[17:40:48.082] signalConditions() ...
[17:40:48.082]  - include = ‘immediateCondition’
[17:40:48.082]  - exclude = 
[17:40:48.082]  - resignal = FALSE
[17:40:48.082]  - Number of conditions: 1
[17:40:48.083] signalConditions() ... done
[17:40:48.084] MultisessionFuture started
[17:40:48.084] - Launch lazy future ... done
[17:40:48.084] run() for ‘MultisessionFuture’ ... done
[17:40:48.587] receiveMessageFromWorker() for ClusterFuture ...
[17:40:48.587] - Validating connection of MultisessionFuture
[17:40:48.587] - received message: FutureResult
[17:40:48.587] - Received FutureResult
[17:40:48.587] - Erased future from FutureRegistry
[17:40:48.588] result() for ClusterFuture ...
[17:40:48.588] - result already collected: FutureResult
[17:40:48.588] result() for ClusterFuture ... done
[17:40:48.588] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:48.588] A MultisessionFuture was resolved (result was not collected)
[17:40:48.588] getGlobalsAndPackages() ...
[17:40:48.588] Searching for globals...
[17:40:48.589] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:48.589] Searching for globals ... DONE
[17:40:48.590] Resolving globals: FALSE
[17:40:48.590] 
[17:40:48.590] 
[17:40:48.590] getGlobalsAndPackages() ... DONE
[17:40:48.590] run() for ‘Future’ ...
[17:40:48.590] - state: ‘created’
[17:40:48.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:48.604] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:48.604] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:48.605]   - Field: ‘node’
[17:40:48.605]   - Field: ‘label’
[17:40:48.605]   - Field: ‘local’
[17:40:48.605]   - Field: ‘owner’
[17:40:48.605]   - Field: ‘envir’
[17:40:48.605]   - Field: ‘workers’
[17:40:48.605]   - Field: ‘packages’
[17:40:48.605]   - Field: ‘gc’
[17:40:48.605]   - Field: ‘conditions’
[17:40:48.605]   - Field: ‘persistent’
[17:40:48.605]   - Field: ‘expr’
[17:40:48.606]   - Field: ‘uuid’
[17:40:48.606]   - Field: ‘seed’
[17:40:48.606]   - Field: ‘version’
[17:40:48.606]   - Field: ‘result’
[17:40:48.606]   - Field: ‘asynchronous’
[17:40:48.606]   - Field: ‘calls’
[17:40:48.606]   - Field: ‘globals’
[17:40:48.606]   - Field: ‘stdout’
[17:40:48.606]   - Field: ‘earlySignal’
[17:40:48.606]   - Field: ‘lazy’
[17:40:48.606]   - Field: ‘state’
[17:40:48.607] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:48.607] - Launch lazy future ...
[17:40:48.607] Packages needed by the future expression (n = 0): <none>
[17:40:48.607] Packages needed by future strategies (n = 0): <none>
[17:40:48.607] {
[17:40:48.607]     {
[17:40:48.607]         {
[17:40:48.607]             ...future.startTime <- base::Sys.time()
[17:40:48.607]             {
[17:40:48.607]                 {
[17:40:48.607]                   {
[17:40:48.607]                     {
[17:40:48.607]                       base::local({
[17:40:48.607]                         has_future <- base::requireNamespace("future", 
[17:40:48.607]                           quietly = TRUE)
[17:40:48.607]                         if (has_future) {
[17:40:48.607]                           ns <- base::getNamespace("future")
[17:40:48.607]                           version <- ns[[".package"]][["version"]]
[17:40:48.607]                           if (is.null(version)) 
[17:40:48.607]                             version <- utils::packageVersion("future")
[17:40:48.607]                         }
[17:40:48.607]                         else {
[17:40:48.607]                           version <- NULL
[17:40:48.607]                         }
[17:40:48.607]                         if (!has_future || version < "1.8.0") {
[17:40:48.607]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:48.607]                             "", base::R.version$version.string), 
[17:40:48.607]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:48.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:48.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:48.607]                               "release", "version")], collapse = " "), 
[17:40:48.607]                             hostname = base::Sys.info()[["nodename"]])
[17:40:48.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:48.607]                             info)
[17:40:48.607]                           info <- base::paste(info, collapse = "; ")
[17:40:48.607]                           if (!has_future) {
[17:40:48.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:48.607]                               info)
[17:40:48.607]                           }
[17:40:48.607]                           else {
[17:40:48.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:48.607]                               info, version)
[17:40:48.607]                           }
[17:40:48.607]                           base::stop(msg)
[17:40:48.607]                         }
[17:40:48.607]                       })
[17:40:48.607]                     }
[17:40:48.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:48.607]                     base::options(mc.cores = 1L)
[17:40:48.607]                   }
[17:40:48.607]                   ...future.strategy.old <- future::plan("list")
[17:40:48.607]                   options(future.plan = NULL)
[17:40:48.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:48.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:48.607]                 }
[17:40:48.607]                 ...future.workdir <- getwd()
[17:40:48.607]             }
[17:40:48.607]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:48.607]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:48.607]         }
[17:40:48.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:48.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:48.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:48.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:48.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:48.607]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:48.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:48.607]             base::names(...future.oldOptions))
[17:40:48.607]     }
[17:40:48.607]     if (FALSE) {
[17:40:48.607]     }
[17:40:48.607]     else {
[17:40:48.607]         if (TRUE) {
[17:40:48.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:48.607]                 open = "w")
[17:40:48.607]         }
[17:40:48.607]         else {
[17:40:48.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:48.607]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:48.607]         }
[17:40:48.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:48.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:48.607]             base::sink(type = "output", split = FALSE)
[17:40:48.607]             base::close(...future.stdout)
[17:40:48.607]         }, add = TRUE)
[17:40:48.607]     }
[17:40:48.607]     ...future.frame <- base::sys.nframe()
[17:40:48.607]     ...future.conditions <- base::list()
[17:40:48.607]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:48.607]     if (FALSE) {
[17:40:48.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:48.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:48.607]     }
[17:40:48.607]     ...future.result <- base::tryCatch({
[17:40:48.607]         base::withCallingHandlers({
[17:40:48.607]             ...future.value <- base::withVisible(base::local({
[17:40:48.607]                 ...future.makeSendCondition <- base::local({
[17:40:48.607]                   sendCondition <- NULL
[17:40:48.607]                   function(frame = 1L) {
[17:40:48.607]                     if (is.function(sendCondition)) 
[17:40:48.607]                       return(sendCondition)
[17:40:48.607]                     ns <- getNamespace("parallel")
[17:40:48.607]                     if (exists("sendData", mode = "function", 
[17:40:48.607]                       envir = ns)) {
[17:40:48.607]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:48.607]                         envir = ns)
[17:40:48.607]                       envir <- sys.frame(frame)
[17:40:48.607]                       master <- NULL
[17:40:48.607]                       while (!identical(envir, .GlobalEnv) && 
[17:40:48.607]                         !identical(envir, emptyenv())) {
[17:40:48.607]                         if (exists("master", mode = "list", envir = envir, 
[17:40:48.607]                           inherits = FALSE)) {
[17:40:48.607]                           master <- get("master", mode = "list", 
[17:40:48.607]                             envir = envir, inherits = FALSE)
[17:40:48.607]                           if (inherits(master, c("SOCKnode", 
[17:40:48.607]                             "SOCK0node"))) {
[17:40:48.607]                             sendCondition <<- function(cond) {
[17:40:48.607]                               data <- list(type = "VALUE", value = cond, 
[17:40:48.607]                                 success = TRUE)
[17:40:48.607]                               parallel_sendData(master, data)
[17:40:48.607]                             }
[17:40:48.607]                             return(sendCondition)
[17:40:48.607]                           }
[17:40:48.607]                         }
[17:40:48.607]                         frame <- frame + 1L
[17:40:48.607]                         envir <- sys.frame(frame)
[17:40:48.607]                       }
[17:40:48.607]                     }
[17:40:48.607]                     sendCondition <<- function(cond) NULL
[17:40:48.607]                   }
[17:40:48.607]                 })
[17:40:48.607]                 withCallingHandlers({
[17:40:48.607]                   {
[17:40:48.607]                     Sys.sleep(0.5)
[17:40:48.607]                     list(a = 1, b = 42L)
[17:40:48.607]                   }
[17:40:48.607]                 }, immediateCondition = function(cond) {
[17:40:48.607]                   sendCondition <- ...future.makeSendCondition()
[17:40:48.607]                   sendCondition(cond)
[17:40:48.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.607]                   {
[17:40:48.607]                     inherits <- base::inherits
[17:40:48.607]                     invokeRestart <- base::invokeRestart
[17:40:48.607]                     is.null <- base::is.null
[17:40:48.607]                     muffled <- FALSE
[17:40:48.607]                     if (inherits(cond, "message")) {
[17:40:48.607]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:48.607]                       if (muffled) 
[17:40:48.607]                         invokeRestart("muffleMessage")
[17:40:48.607]                     }
[17:40:48.607]                     else if (inherits(cond, "warning")) {
[17:40:48.607]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:48.607]                       if (muffled) 
[17:40:48.607]                         invokeRestart("muffleWarning")
[17:40:48.607]                     }
[17:40:48.607]                     else if (inherits(cond, "condition")) {
[17:40:48.607]                       if (!is.null(pattern)) {
[17:40:48.607]                         computeRestarts <- base::computeRestarts
[17:40:48.607]                         grepl <- base::grepl
[17:40:48.607]                         restarts <- computeRestarts(cond)
[17:40:48.607]                         for (restart in restarts) {
[17:40:48.607]                           name <- restart$name
[17:40:48.607]                           if (is.null(name)) 
[17:40:48.607]                             next
[17:40:48.607]                           if (!grepl(pattern, name)) 
[17:40:48.607]                             next
[17:40:48.607]                           invokeRestart(restart)
[17:40:48.607]                           muffled <- TRUE
[17:40:48.607]                           break
[17:40:48.607]                         }
[17:40:48.607]                       }
[17:40:48.607]                     }
[17:40:48.607]                     invisible(muffled)
[17:40:48.607]                   }
[17:40:48.607]                   muffleCondition(cond)
[17:40:48.607]                 })
[17:40:48.607]             }))
[17:40:48.607]             future::FutureResult(value = ...future.value$value, 
[17:40:48.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:48.607]                   ...future.rng), globalenv = if (FALSE) 
[17:40:48.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:48.607]                     ...future.globalenv.names))
[17:40:48.607]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:48.607]         }, condition = base::local({
[17:40:48.607]             c <- base::c
[17:40:48.607]             inherits <- base::inherits
[17:40:48.607]             invokeRestart <- base::invokeRestart
[17:40:48.607]             length <- base::length
[17:40:48.607]             list <- base::list
[17:40:48.607]             seq.int <- base::seq.int
[17:40:48.607]             signalCondition <- base::signalCondition
[17:40:48.607]             sys.calls <- base::sys.calls
[17:40:48.607]             `[[` <- base::`[[`
[17:40:48.607]             `+` <- base::`+`
[17:40:48.607]             `<<-` <- base::`<<-`
[17:40:48.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:48.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:48.607]                   3L)]
[17:40:48.607]             }
[17:40:48.607]             function(cond) {
[17:40:48.607]                 is_error <- inherits(cond, "error")
[17:40:48.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:48.607]                   NULL)
[17:40:48.607]                 if (is_error) {
[17:40:48.607]                   sessionInformation <- function() {
[17:40:48.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:48.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:48.607]                       search = base::search(), system = base::Sys.info())
[17:40:48.607]                   }
[17:40:48.607]                   ...future.conditions[[length(...future.conditions) + 
[17:40:48.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:48.607]                     cond$call), session = sessionInformation(), 
[17:40:48.607]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:48.607]                   signalCondition(cond)
[17:40:48.607]                 }
[17:40:48.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:48.607]                 "immediateCondition"))) {
[17:40:48.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:48.607]                   ...future.conditions[[length(...future.conditions) + 
[17:40:48.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:48.607]                   if (TRUE && !signal) {
[17:40:48.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.607]                     {
[17:40:48.607]                       inherits <- base::inherits
[17:40:48.607]                       invokeRestart <- base::invokeRestart
[17:40:48.607]                       is.null <- base::is.null
[17:40:48.607]                       muffled <- FALSE
[17:40:48.607]                       if (inherits(cond, "message")) {
[17:40:48.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:48.607]                         if (muffled) 
[17:40:48.607]                           invokeRestart("muffleMessage")
[17:40:48.607]                       }
[17:40:48.607]                       else if (inherits(cond, "warning")) {
[17:40:48.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:48.607]                         if (muffled) 
[17:40:48.607]                           invokeRestart("muffleWarning")
[17:40:48.607]                       }
[17:40:48.607]                       else if (inherits(cond, "condition")) {
[17:40:48.607]                         if (!is.null(pattern)) {
[17:40:48.607]                           computeRestarts <- base::computeRestarts
[17:40:48.607]                           grepl <- base::grepl
[17:40:48.607]                           restarts <- computeRestarts(cond)
[17:40:48.607]                           for (restart in restarts) {
[17:40:48.607]                             name <- restart$name
[17:40:48.607]                             if (is.null(name)) 
[17:40:48.607]                               next
[17:40:48.607]                             if (!grepl(pattern, name)) 
[17:40:48.607]                               next
[17:40:48.607]                             invokeRestart(restart)
[17:40:48.607]                             muffled <- TRUE
[17:40:48.607]                             break
[17:40:48.607]                           }
[17:40:48.607]                         }
[17:40:48.607]                       }
[17:40:48.607]                       invisible(muffled)
[17:40:48.607]                     }
[17:40:48.607]                     muffleCondition(cond, pattern = "^muffle")
[17:40:48.607]                   }
[17:40:48.607]                 }
[17:40:48.607]                 else {
[17:40:48.607]                   if (TRUE) {
[17:40:48.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:48.607]                     {
[17:40:48.607]                       inherits <- base::inherits
[17:40:48.607]                       invokeRestart <- base::invokeRestart
[17:40:48.607]                       is.null <- base::is.null
[17:40:48.607]                       muffled <- FALSE
[17:40:48.607]                       if (inherits(cond, "message")) {
[17:40:48.607]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:48.607]                         if (muffled) 
[17:40:48.607]                           invokeRestart("muffleMessage")
[17:40:48.607]                       }
[17:40:48.607]                       else if (inherits(cond, "warning")) {
[17:40:48.607]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:48.607]                         if (muffled) 
[17:40:48.607]                           invokeRestart("muffleWarning")
[17:40:48.607]                       }
[17:40:48.607]                       else if (inherits(cond, "condition")) {
[17:40:48.607]                         if (!is.null(pattern)) {
[17:40:48.607]                           computeRestarts <- base::computeRestarts
[17:40:48.607]                           grepl <- base::grepl
[17:40:48.607]                           restarts <- computeRestarts(cond)
[17:40:48.607]                           for (restart in restarts) {
[17:40:48.607]                             name <- restart$name
[17:40:48.607]                             if (is.null(name)) 
[17:40:48.607]                               next
[17:40:48.607]                             if (!grepl(pattern, name)) 
[17:40:48.607]                               next
[17:40:48.607]                             invokeRestart(restart)
[17:40:48.607]                             muffled <- TRUE
[17:40:48.607]                             break
[17:40:48.607]                           }
[17:40:48.607]                         }
[17:40:48.607]                       }
[17:40:48.607]                       invisible(muffled)
[17:40:48.607]                     }
[17:40:48.607]                     muffleCondition(cond, pattern = "^muffle")
[17:40:48.607]                   }
[17:40:48.607]                 }
[17:40:48.607]             }
[17:40:48.607]         }))
[17:40:48.607]     }, error = function(ex) {
[17:40:48.607]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:48.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:48.607]                 ...future.rng), started = ...future.startTime, 
[17:40:48.607]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:48.607]             version = "1.8"), class = "FutureResult")
[17:40:48.607]     }, finally = {
[17:40:48.607]         if (!identical(...future.workdir, getwd())) 
[17:40:48.607]             setwd(...future.workdir)
[17:40:48.607]         {
[17:40:48.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:48.607]                 ...future.oldOptions$nwarnings <- NULL
[17:40:48.607]             }
[17:40:48.607]             base::options(...future.oldOptions)
[17:40:48.607]             if (.Platform$OS.type == "windows") {
[17:40:48.607]                 old_names <- names(...future.oldEnvVars)
[17:40:48.607]                 envs <- base::Sys.getenv()
[17:40:48.607]                 names <- names(envs)
[17:40:48.607]                 common <- intersect(names, old_names)
[17:40:48.607]                 added <- setdiff(names, old_names)
[17:40:48.607]                 removed <- setdiff(old_names, names)
[17:40:48.607]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:48.607]                   envs[common]]
[17:40:48.607]                 NAMES <- toupper(changed)
[17:40:48.607]                 args <- list()
[17:40:48.607]                 for (kk in seq_along(NAMES)) {
[17:40:48.607]                   name <- changed[[kk]]
[17:40:48.607]                   NAME <- NAMES[[kk]]
[17:40:48.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.607]                     next
[17:40:48.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:48.607]                 }
[17:40:48.607]                 NAMES <- toupper(added)
[17:40:48.607]                 for (kk in seq_along(NAMES)) {
[17:40:48.607]                   name <- added[[kk]]
[17:40:48.607]                   NAME <- NAMES[[kk]]
[17:40:48.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.607]                     next
[17:40:48.607]                   args[[name]] <- ""
[17:40:48.607]                 }
[17:40:48.607]                 NAMES <- toupper(removed)
[17:40:48.607]                 for (kk in seq_along(NAMES)) {
[17:40:48.607]                   name <- removed[[kk]]
[17:40:48.607]                   NAME <- NAMES[[kk]]
[17:40:48.607]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:48.607]                     next
[17:40:48.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:48.607]                 }
[17:40:48.607]                 if (length(args) > 0) 
[17:40:48.607]                   base::do.call(base::Sys.setenv, args = args)
[17:40:48.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:48.607]             }
[17:40:48.607]             else {
[17:40:48.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:48.607]             }
[17:40:48.607]             {
[17:40:48.607]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:48.607]                   0L) {
[17:40:48.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:48.607]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:48.607]                   base::options(opts)
[17:40:48.607]                 }
[17:40:48.607]                 {
[17:40:48.607]                   {
[17:40:48.607]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:48.607]                     NULL
[17:40:48.607]                   }
[17:40:48.607]                   options(future.plan = NULL)
[17:40:48.607]                   if (is.na(NA_character_)) 
[17:40:48.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:48.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:48.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:48.607]                     .init = FALSE)
[17:40:48.607]                 }
[17:40:48.607]             }
[17:40:48.607]         }
[17:40:48.607]     })
[17:40:48.607]     if (TRUE) {
[17:40:48.607]         base::sink(type = "output", split = FALSE)
[17:40:48.607]         if (TRUE) {
[17:40:48.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:48.607]         }
[17:40:48.607]         else {
[17:40:48.607]             ...future.result["stdout"] <- base::list(NULL)
[17:40:48.607]         }
[17:40:48.607]         base::close(...future.stdout)
[17:40:48.607]         ...future.stdout <- NULL
[17:40:48.607]     }
[17:40:48.607]     ...future.result$conditions <- ...future.conditions
[17:40:48.607]     ...future.result$finished <- base::Sys.time()
[17:40:48.607]     ...future.result
[17:40:48.607] }
[17:40:48.610] MultisessionFuture started
[17:40:48.611] - Launch lazy future ... done
[17:40:48.611] run() for ‘MultisessionFuture’ ... done
[17:40:49.116] receiveMessageFromWorker() for ClusterFuture ...
[17:40:49.117] - Validating connection of MultisessionFuture
[17:40:49.117] - received message: FutureResult
[17:40:49.117] - Received FutureResult
[17:40:49.117] - Erased future from FutureRegistry
[17:40:49.117] result() for ClusterFuture ...
[17:40:49.117] - result already collected: FutureResult
[17:40:49.118] result() for ClusterFuture ... done
[17:40:49.118] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:49.118] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:49.118] getGlobalsAndPackages() ...
[17:40:49.118] Searching for globals...
[17:40:49.119] - globals found: [2] ‘list’, ‘stop’
[17:40:49.119] Searching for globals ... DONE
[17:40:49.119] Resolving globals: FALSE
[17:40:49.119] 
[17:40:49.119] 
[17:40:49.119] getGlobalsAndPackages() ... DONE
[17:40:49.120] run() for ‘Future’ ...
[17:40:49.120] - state: ‘created’
[17:40:49.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:49.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:49.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:49.134]   - Field: ‘node’
[17:40:49.134]   - Field: ‘label’
[17:40:49.134]   - Field: ‘local’
[17:40:49.134]   - Field: ‘owner’
[17:40:49.134]   - Field: ‘envir’
[17:40:49.134]   - Field: ‘workers’
[17:40:49.135]   - Field: ‘packages’
[17:40:49.135]   - Field: ‘gc’
[17:40:49.135]   - Field: ‘conditions’
[17:40:49.135]   - Field: ‘persistent’
[17:40:49.135]   - Field: ‘expr’
[17:40:49.135]   - Field: ‘uuid’
[17:40:49.135]   - Field: ‘seed’
[17:40:49.135]   - Field: ‘version’
[17:40:49.135]   - Field: ‘result’
[17:40:49.135]   - Field: ‘asynchronous’
[17:40:49.135]   - Field: ‘calls’
[17:40:49.135]   - Field: ‘globals’
[17:40:49.136]   - Field: ‘stdout’
[17:40:49.136]   - Field: ‘earlySignal’
[17:40:49.136]   - Field: ‘lazy’
[17:40:49.136]   - Field: ‘state’
[17:40:49.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:49.136] - Launch lazy future ...
[17:40:49.136] Packages needed by the future expression (n = 0): <none>
[17:40:49.137] Packages needed by future strategies (n = 0): <none>
[17:40:49.137] {
[17:40:49.137]     {
[17:40:49.137]         {
[17:40:49.137]             ...future.startTime <- base::Sys.time()
[17:40:49.137]             {
[17:40:49.137]                 {
[17:40:49.137]                   {
[17:40:49.137]                     {
[17:40:49.137]                       base::local({
[17:40:49.137]                         has_future <- base::requireNamespace("future", 
[17:40:49.137]                           quietly = TRUE)
[17:40:49.137]                         if (has_future) {
[17:40:49.137]                           ns <- base::getNamespace("future")
[17:40:49.137]                           version <- ns[[".package"]][["version"]]
[17:40:49.137]                           if (is.null(version)) 
[17:40:49.137]                             version <- utils::packageVersion("future")
[17:40:49.137]                         }
[17:40:49.137]                         else {
[17:40:49.137]                           version <- NULL
[17:40:49.137]                         }
[17:40:49.137]                         if (!has_future || version < "1.8.0") {
[17:40:49.137]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:49.137]                             "", base::R.version$version.string), 
[17:40:49.137]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:49.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:49.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:49.137]                               "release", "version")], collapse = " "), 
[17:40:49.137]                             hostname = base::Sys.info()[["nodename"]])
[17:40:49.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:49.137]                             info)
[17:40:49.137]                           info <- base::paste(info, collapse = "; ")
[17:40:49.137]                           if (!has_future) {
[17:40:49.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:49.137]                               info)
[17:40:49.137]                           }
[17:40:49.137]                           else {
[17:40:49.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:49.137]                               info, version)
[17:40:49.137]                           }
[17:40:49.137]                           base::stop(msg)
[17:40:49.137]                         }
[17:40:49.137]                       })
[17:40:49.137]                     }
[17:40:49.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:49.137]                     base::options(mc.cores = 1L)
[17:40:49.137]                   }
[17:40:49.137]                   ...future.strategy.old <- future::plan("list")
[17:40:49.137]                   options(future.plan = NULL)
[17:40:49.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:49.137]                 }
[17:40:49.137]                 ...future.workdir <- getwd()
[17:40:49.137]             }
[17:40:49.137]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:49.137]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:49.137]         }
[17:40:49.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:49.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:49.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:49.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:49.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:49.137]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:49.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:49.137]             base::names(...future.oldOptions))
[17:40:49.137]     }
[17:40:49.137]     if (FALSE) {
[17:40:49.137]     }
[17:40:49.137]     else {
[17:40:49.137]         if (TRUE) {
[17:40:49.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:49.137]                 open = "w")
[17:40:49.137]         }
[17:40:49.137]         else {
[17:40:49.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:49.137]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:49.137]         }
[17:40:49.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:49.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:49.137]             base::sink(type = "output", split = FALSE)
[17:40:49.137]             base::close(...future.stdout)
[17:40:49.137]         }, add = TRUE)
[17:40:49.137]     }
[17:40:49.137]     ...future.frame <- base::sys.nframe()
[17:40:49.137]     ...future.conditions <- base::list()
[17:40:49.137]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:49.137]     if (FALSE) {
[17:40:49.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:49.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:49.137]     }
[17:40:49.137]     ...future.result <- base::tryCatch({
[17:40:49.137]         base::withCallingHandlers({
[17:40:49.137]             ...future.value <- base::withVisible(base::local({
[17:40:49.137]                 ...future.makeSendCondition <- base::local({
[17:40:49.137]                   sendCondition <- NULL
[17:40:49.137]                   function(frame = 1L) {
[17:40:49.137]                     if (is.function(sendCondition)) 
[17:40:49.137]                       return(sendCondition)
[17:40:49.137]                     ns <- getNamespace("parallel")
[17:40:49.137]                     if (exists("sendData", mode = "function", 
[17:40:49.137]                       envir = ns)) {
[17:40:49.137]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:49.137]                         envir = ns)
[17:40:49.137]                       envir <- sys.frame(frame)
[17:40:49.137]                       master <- NULL
[17:40:49.137]                       while (!identical(envir, .GlobalEnv) && 
[17:40:49.137]                         !identical(envir, emptyenv())) {
[17:40:49.137]                         if (exists("master", mode = "list", envir = envir, 
[17:40:49.137]                           inherits = FALSE)) {
[17:40:49.137]                           master <- get("master", mode = "list", 
[17:40:49.137]                             envir = envir, inherits = FALSE)
[17:40:49.137]                           if (inherits(master, c("SOCKnode", 
[17:40:49.137]                             "SOCK0node"))) {
[17:40:49.137]                             sendCondition <<- function(cond) {
[17:40:49.137]                               data <- list(type = "VALUE", value = cond, 
[17:40:49.137]                                 success = TRUE)
[17:40:49.137]                               parallel_sendData(master, data)
[17:40:49.137]                             }
[17:40:49.137]                             return(sendCondition)
[17:40:49.137]                           }
[17:40:49.137]                         }
[17:40:49.137]                         frame <- frame + 1L
[17:40:49.137]                         envir <- sys.frame(frame)
[17:40:49.137]                       }
[17:40:49.137]                     }
[17:40:49.137]                     sendCondition <<- function(cond) NULL
[17:40:49.137]                   }
[17:40:49.137]                 })
[17:40:49.137]                 withCallingHandlers({
[17:40:49.137]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:49.137]                 }, immediateCondition = function(cond) {
[17:40:49.137]                   sendCondition <- ...future.makeSendCondition()
[17:40:49.137]                   sendCondition(cond)
[17:40:49.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.137]                   {
[17:40:49.137]                     inherits <- base::inherits
[17:40:49.137]                     invokeRestart <- base::invokeRestart
[17:40:49.137]                     is.null <- base::is.null
[17:40:49.137]                     muffled <- FALSE
[17:40:49.137]                     if (inherits(cond, "message")) {
[17:40:49.137]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:49.137]                       if (muffled) 
[17:40:49.137]                         invokeRestart("muffleMessage")
[17:40:49.137]                     }
[17:40:49.137]                     else if (inherits(cond, "warning")) {
[17:40:49.137]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:49.137]                       if (muffled) 
[17:40:49.137]                         invokeRestart("muffleWarning")
[17:40:49.137]                     }
[17:40:49.137]                     else if (inherits(cond, "condition")) {
[17:40:49.137]                       if (!is.null(pattern)) {
[17:40:49.137]                         computeRestarts <- base::computeRestarts
[17:40:49.137]                         grepl <- base::grepl
[17:40:49.137]                         restarts <- computeRestarts(cond)
[17:40:49.137]                         for (restart in restarts) {
[17:40:49.137]                           name <- restart$name
[17:40:49.137]                           if (is.null(name)) 
[17:40:49.137]                             next
[17:40:49.137]                           if (!grepl(pattern, name)) 
[17:40:49.137]                             next
[17:40:49.137]                           invokeRestart(restart)
[17:40:49.137]                           muffled <- TRUE
[17:40:49.137]                           break
[17:40:49.137]                         }
[17:40:49.137]                       }
[17:40:49.137]                     }
[17:40:49.137]                     invisible(muffled)
[17:40:49.137]                   }
[17:40:49.137]                   muffleCondition(cond)
[17:40:49.137]                 })
[17:40:49.137]             }))
[17:40:49.137]             future::FutureResult(value = ...future.value$value, 
[17:40:49.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.137]                   ...future.rng), globalenv = if (FALSE) 
[17:40:49.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:49.137]                     ...future.globalenv.names))
[17:40:49.137]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:49.137]         }, condition = base::local({
[17:40:49.137]             c <- base::c
[17:40:49.137]             inherits <- base::inherits
[17:40:49.137]             invokeRestart <- base::invokeRestart
[17:40:49.137]             length <- base::length
[17:40:49.137]             list <- base::list
[17:40:49.137]             seq.int <- base::seq.int
[17:40:49.137]             signalCondition <- base::signalCondition
[17:40:49.137]             sys.calls <- base::sys.calls
[17:40:49.137]             `[[` <- base::`[[`
[17:40:49.137]             `+` <- base::`+`
[17:40:49.137]             `<<-` <- base::`<<-`
[17:40:49.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:49.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:49.137]                   3L)]
[17:40:49.137]             }
[17:40:49.137]             function(cond) {
[17:40:49.137]                 is_error <- inherits(cond, "error")
[17:40:49.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:49.137]                   NULL)
[17:40:49.137]                 if (is_error) {
[17:40:49.137]                   sessionInformation <- function() {
[17:40:49.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:49.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:49.137]                       search = base::search(), system = base::Sys.info())
[17:40:49.137]                   }
[17:40:49.137]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:49.137]                     cond$call), session = sessionInformation(), 
[17:40:49.137]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:49.137]                   signalCondition(cond)
[17:40:49.137]                 }
[17:40:49.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:49.137]                 "immediateCondition"))) {
[17:40:49.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:49.137]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:49.137]                   if (TRUE && !signal) {
[17:40:49.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.137]                     {
[17:40:49.137]                       inherits <- base::inherits
[17:40:49.137]                       invokeRestart <- base::invokeRestart
[17:40:49.137]                       is.null <- base::is.null
[17:40:49.137]                       muffled <- FALSE
[17:40:49.137]                       if (inherits(cond, "message")) {
[17:40:49.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.137]                         if (muffled) 
[17:40:49.137]                           invokeRestart("muffleMessage")
[17:40:49.137]                       }
[17:40:49.137]                       else if (inherits(cond, "warning")) {
[17:40:49.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.137]                         if (muffled) 
[17:40:49.137]                           invokeRestart("muffleWarning")
[17:40:49.137]                       }
[17:40:49.137]                       else if (inherits(cond, "condition")) {
[17:40:49.137]                         if (!is.null(pattern)) {
[17:40:49.137]                           computeRestarts <- base::computeRestarts
[17:40:49.137]                           grepl <- base::grepl
[17:40:49.137]                           restarts <- computeRestarts(cond)
[17:40:49.137]                           for (restart in restarts) {
[17:40:49.137]                             name <- restart$name
[17:40:49.137]                             if (is.null(name)) 
[17:40:49.137]                               next
[17:40:49.137]                             if (!grepl(pattern, name)) 
[17:40:49.137]                               next
[17:40:49.137]                             invokeRestart(restart)
[17:40:49.137]                             muffled <- TRUE
[17:40:49.137]                             break
[17:40:49.137]                           }
[17:40:49.137]                         }
[17:40:49.137]                       }
[17:40:49.137]                       invisible(muffled)
[17:40:49.137]                     }
[17:40:49.137]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.137]                   }
[17:40:49.137]                 }
[17:40:49.137]                 else {
[17:40:49.137]                   if (TRUE) {
[17:40:49.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.137]                     {
[17:40:49.137]                       inherits <- base::inherits
[17:40:49.137]                       invokeRestart <- base::invokeRestart
[17:40:49.137]                       is.null <- base::is.null
[17:40:49.137]                       muffled <- FALSE
[17:40:49.137]                       if (inherits(cond, "message")) {
[17:40:49.137]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.137]                         if (muffled) 
[17:40:49.137]                           invokeRestart("muffleMessage")
[17:40:49.137]                       }
[17:40:49.137]                       else if (inherits(cond, "warning")) {
[17:40:49.137]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.137]                         if (muffled) 
[17:40:49.137]                           invokeRestart("muffleWarning")
[17:40:49.137]                       }
[17:40:49.137]                       else if (inherits(cond, "condition")) {
[17:40:49.137]                         if (!is.null(pattern)) {
[17:40:49.137]                           computeRestarts <- base::computeRestarts
[17:40:49.137]                           grepl <- base::grepl
[17:40:49.137]                           restarts <- computeRestarts(cond)
[17:40:49.137]                           for (restart in restarts) {
[17:40:49.137]                             name <- restart$name
[17:40:49.137]                             if (is.null(name)) 
[17:40:49.137]                               next
[17:40:49.137]                             if (!grepl(pattern, name)) 
[17:40:49.137]                               next
[17:40:49.137]                             invokeRestart(restart)
[17:40:49.137]                             muffled <- TRUE
[17:40:49.137]                             break
[17:40:49.137]                           }
[17:40:49.137]                         }
[17:40:49.137]                       }
[17:40:49.137]                       invisible(muffled)
[17:40:49.137]                     }
[17:40:49.137]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.137]                   }
[17:40:49.137]                 }
[17:40:49.137]             }
[17:40:49.137]         }))
[17:40:49.137]     }, error = function(ex) {
[17:40:49.137]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:49.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.137]                 ...future.rng), started = ...future.startTime, 
[17:40:49.137]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:49.137]             version = "1.8"), class = "FutureResult")
[17:40:49.137]     }, finally = {
[17:40:49.137]         if (!identical(...future.workdir, getwd())) 
[17:40:49.137]             setwd(...future.workdir)
[17:40:49.137]         {
[17:40:49.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:49.137]                 ...future.oldOptions$nwarnings <- NULL
[17:40:49.137]             }
[17:40:49.137]             base::options(...future.oldOptions)
[17:40:49.137]             if (.Platform$OS.type == "windows") {
[17:40:49.137]                 old_names <- names(...future.oldEnvVars)
[17:40:49.137]                 envs <- base::Sys.getenv()
[17:40:49.137]                 names <- names(envs)
[17:40:49.137]                 common <- intersect(names, old_names)
[17:40:49.137]                 added <- setdiff(names, old_names)
[17:40:49.137]                 removed <- setdiff(old_names, names)
[17:40:49.137]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:49.137]                   envs[common]]
[17:40:49.137]                 NAMES <- toupper(changed)
[17:40:49.137]                 args <- list()
[17:40:49.137]                 for (kk in seq_along(NAMES)) {
[17:40:49.137]                   name <- changed[[kk]]
[17:40:49.137]                   NAME <- NAMES[[kk]]
[17:40:49.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.137]                     next
[17:40:49.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.137]                 }
[17:40:49.137]                 NAMES <- toupper(added)
[17:40:49.137]                 for (kk in seq_along(NAMES)) {
[17:40:49.137]                   name <- added[[kk]]
[17:40:49.137]                   NAME <- NAMES[[kk]]
[17:40:49.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.137]                     next
[17:40:49.137]                   args[[name]] <- ""
[17:40:49.137]                 }
[17:40:49.137]                 NAMES <- toupper(removed)
[17:40:49.137]                 for (kk in seq_along(NAMES)) {
[17:40:49.137]                   name <- removed[[kk]]
[17:40:49.137]                   NAME <- NAMES[[kk]]
[17:40:49.137]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.137]                     next
[17:40:49.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.137]                 }
[17:40:49.137]                 if (length(args) > 0) 
[17:40:49.137]                   base::do.call(base::Sys.setenv, args = args)
[17:40:49.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:49.137]             }
[17:40:49.137]             else {
[17:40:49.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:49.137]             }
[17:40:49.137]             {
[17:40:49.137]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:49.137]                   0L) {
[17:40:49.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:49.137]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:49.137]                   base::options(opts)
[17:40:49.137]                 }
[17:40:49.137]                 {
[17:40:49.137]                   {
[17:40:49.137]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:49.137]                     NULL
[17:40:49.137]                   }
[17:40:49.137]                   options(future.plan = NULL)
[17:40:49.137]                   if (is.na(NA_character_)) 
[17:40:49.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:49.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:49.137]                     .init = FALSE)
[17:40:49.137]                 }
[17:40:49.137]             }
[17:40:49.137]         }
[17:40:49.137]     })
[17:40:49.137]     if (TRUE) {
[17:40:49.137]         base::sink(type = "output", split = FALSE)
[17:40:49.137]         if (TRUE) {
[17:40:49.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:49.137]         }
[17:40:49.137]         else {
[17:40:49.137]             ...future.result["stdout"] <- base::list(NULL)
[17:40:49.137]         }
[17:40:49.137]         base::close(...future.stdout)
[17:40:49.137]         ...future.stdout <- NULL
[17:40:49.137]     }
[17:40:49.137]     ...future.result$conditions <- ...future.conditions
[17:40:49.137]     ...future.result$finished <- base::Sys.time()
[17:40:49.137]     ...future.result
[17:40:49.137] }
[17:40:49.140] MultisessionFuture started
[17:40:49.140] - Launch lazy future ... done
[17:40:49.141] run() for ‘MultisessionFuture’ ... done
[17:40:49.142] receiveMessageFromWorker() for ClusterFuture ...
[17:40:49.142] - Validating connection of MultisessionFuture
[17:40:49.143] - received message: FutureResult
[17:40:49.143] - Received FutureResult
[17:40:49.145] - Erased future from FutureRegistry
[17:40:49.145] result() for ClusterFuture ...
[17:40:49.145] - result already collected: FutureResult
[17:40:49.145] result() for ClusterFuture ... done
[17:40:49.145] signalConditions() ...
[17:40:49.146]  - include = ‘immediateCondition’
[17:40:49.146]  - exclude = 
[17:40:49.146]  - resignal = FALSE
[17:40:49.146]  - Number of conditions: 1
[17:40:49.146] signalConditions() ... done
[17:40:49.146] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:49.146] A MultisessionFuture was resolved (result was not collected)
[17:40:49.146] getGlobalsAndPackages() ...
[17:40:49.146] Searching for globals...
[17:40:49.147] - globals found: [2] ‘list’, ‘stop’
[17:40:49.147] Searching for globals ... DONE
[17:40:49.147] Resolving globals: FALSE
[17:40:49.147] 
[17:40:49.148] 
[17:40:49.148] getGlobalsAndPackages() ... DONE
[17:40:49.148] run() for ‘Future’ ...
[17:40:49.148] - state: ‘created’
[17:40:49.148] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:49.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:49.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:49.162]   - Field: ‘node’
[17:40:49.162]   - Field: ‘label’
[17:40:49.163]   - Field: ‘local’
[17:40:49.163]   - Field: ‘owner’
[17:40:49.163]   - Field: ‘envir’
[17:40:49.163]   - Field: ‘workers’
[17:40:49.163]   - Field: ‘packages’
[17:40:49.163]   - Field: ‘gc’
[17:40:49.163]   - Field: ‘conditions’
[17:40:49.163]   - Field: ‘persistent’
[17:40:49.163]   - Field: ‘expr’
[17:40:49.163]   - Field: ‘uuid’
[17:40:49.163]   - Field: ‘seed’
[17:40:49.164]   - Field: ‘version’
[17:40:49.164]   - Field: ‘result’
[17:40:49.164]   - Field: ‘asynchronous’
[17:40:49.164]   - Field: ‘calls’
[17:40:49.164]   - Field: ‘globals’
[17:40:49.164]   - Field: ‘stdout’
[17:40:49.164]   - Field: ‘earlySignal’
[17:40:49.164]   - Field: ‘lazy’
[17:40:49.164]   - Field: ‘state’
[17:40:49.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:49.164] - Launch lazy future ...
[17:40:49.165] Packages needed by the future expression (n = 0): <none>
[17:40:49.165] Packages needed by future strategies (n = 0): <none>
[17:40:49.165] {
[17:40:49.165]     {
[17:40:49.165]         {
[17:40:49.165]             ...future.startTime <- base::Sys.time()
[17:40:49.165]             {
[17:40:49.165]                 {
[17:40:49.165]                   {
[17:40:49.165]                     {
[17:40:49.165]                       base::local({
[17:40:49.165]                         has_future <- base::requireNamespace("future", 
[17:40:49.165]                           quietly = TRUE)
[17:40:49.165]                         if (has_future) {
[17:40:49.165]                           ns <- base::getNamespace("future")
[17:40:49.165]                           version <- ns[[".package"]][["version"]]
[17:40:49.165]                           if (is.null(version)) 
[17:40:49.165]                             version <- utils::packageVersion("future")
[17:40:49.165]                         }
[17:40:49.165]                         else {
[17:40:49.165]                           version <- NULL
[17:40:49.165]                         }
[17:40:49.165]                         if (!has_future || version < "1.8.0") {
[17:40:49.165]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:49.165]                             "", base::R.version$version.string), 
[17:40:49.165]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:49.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:49.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:49.165]                               "release", "version")], collapse = " "), 
[17:40:49.165]                             hostname = base::Sys.info()[["nodename"]])
[17:40:49.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:49.165]                             info)
[17:40:49.165]                           info <- base::paste(info, collapse = "; ")
[17:40:49.165]                           if (!has_future) {
[17:40:49.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:49.165]                               info)
[17:40:49.165]                           }
[17:40:49.165]                           else {
[17:40:49.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:49.165]                               info, version)
[17:40:49.165]                           }
[17:40:49.165]                           base::stop(msg)
[17:40:49.165]                         }
[17:40:49.165]                       })
[17:40:49.165]                     }
[17:40:49.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:49.165]                     base::options(mc.cores = 1L)
[17:40:49.165]                   }
[17:40:49.165]                   ...future.strategy.old <- future::plan("list")
[17:40:49.165]                   options(future.plan = NULL)
[17:40:49.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:49.165]                 }
[17:40:49.165]                 ...future.workdir <- getwd()
[17:40:49.165]             }
[17:40:49.165]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:49.165]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:49.165]         }
[17:40:49.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:49.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:49.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:49.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:49.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:49.165]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:49.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:49.165]             base::names(...future.oldOptions))
[17:40:49.165]     }
[17:40:49.165]     if (FALSE) {
[17:40:49.165]     }
[17:40:49.165]     else {
[17:40:49.165]         if (TRUE) {
[17:40:49.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:49.165]                 open = "w")
[17:40:49.165]         }
[17:40:49.165]         else {
[17:40:49.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:49.165]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:49.165]         }
[17:40:49.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:49.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:49.165]             base::sink(type = "output", split = FALSE)
[17:40:49.165]             base::close(...future.stdout)
[17:40:49.165]         }, add = TRUE)
[17:40:49.165]     }
[17:40:49.165]     ...future.frame <- base::sys.nframe()
[17:40:49.165]     ...future.conditions <- base::list()
[17:40:49.165]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:49.165]     if (FALSE) {
[17:40:49.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:49.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:49.165]     }
[17:40:49.165]     ...future.result <- base::tryCatch({
[17:40:49.165]         base::withCallingHandlers({
[17:40:49.165]             ...future.value <- base::withVisible(base::local({
[17:40:49.165]                 ...future.makeSendCondition <- base::local({
[17:40:49.165]                   sendCondition <- NULL
[17:40:49.165]                   function(frame = 1L) {
[17:40:49.165]                     if (is.function(sendCondition)) 
[17:40:49.165]                       return(sendCondition)
[17:40:49.165]                     ns <- getNamespace("parallel")
[17:40:49.165]                     if (exists("sendData", mode = "function", 
[17:40:49.165]                       envir = ns)) {
[17:40:49.165]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:49.165]                         envir = ns)
[17:40:49.165]                       envir <- sys.frame(frame)
[17:40:49.165]                       master <- NULL
[17:40:49.165]                       while (!identical(envir, .GlobalEnv) && 
[17:40:49.165]                         !identical(envir, emptyenv())) {
[17:40:49.165]                         if (exists("master", mode = "list", envir = envir, 
[17:40:49.165]                           inherits = FALSE)) {
[17:40:49.165]                           master <- get("master", mode = "list", 
[17:40:49.165]                             envir = envir, inherits = FALSE)
[17:40:49.165]                           if (inherits(master, c("SOCKnode", 
[17:40:49.165]                             "SOCK0node"))) {
[17:40:49.165]                             sendCondition <<- function(cond) {
[17:40:49.165]                               data <- list(type = "VALUE", value = cond, 
[17:40:49.165]                                 success = TRUE)
[17:40:49.165]                               parallel_sendData(master, data)
[17:40:49.165]                             }
[17:40:49.165]                             return(sendCondition)
[17:40:49.165]                           }
[17:40:49.165]                         }
[17:40:49.165]                         frame <- frame + 1L
[17:40:49.165]                         envir <- sys.frame(frame)
[17:40:49.165]                       }
[17:40:49.165]                     }
[17:40:49.165]                     sendCondition <<- function(cond) NULL
[17:40:49.165]                   }
[17:40:49.165]                 })
[17:40:49.165]                 withCallingHandlers({
[17:40:49.165]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:49.165]                 }, immediateCondition = function(cond) {
[17:40:49.165]                   sendCondition <- ...future.makeSendCondition()
[17:40:49.165]                   sendCondition(cond)
[17:40:49.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.165]                   {
[17:40:49.165]                     inherits <- base::inherits
[17:40:49.165]                     invokeRestart <- base::invokeRestart
[17:40:49.165]                     is.null <- base::is.null
[17:40:49.165]                     muffled <- FALSE
[17:40:49.165]                     if (inherits(cond, "message")) {
[17:40:49.165]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:49.165]                       if (muffled) 
[17:40:49.165]                         invokeRestart("muffleMessage")
[17:40:49.165]                     }
[17:40:49.165]                     else if (inherits(cond, "warning")) {
[17:40:49.165]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:49.165]                       if (muffled) 
[17:40:49.165]                         invokeRestart("muffleWarning")
[17:40:49.165]                     }
[17:40:49.165]                     else if (inherits(cond, "condition")) {
[17:40:49.165]                       if (!is.null(pattern)) {
[17:40:49.165]                         computeRestarts <- base::computeRestarts
[17:40:49.165]                         grepl <- base::grepl
[17:40:49.165]                         restarts <- computeRestarts(cond)
[17:40:49.165]                         for (restart in restarts) {
[17:40:49.165]                           name <- restart$name
[17:40:49.165]                           if (is.null(name)) 
[17:40:49.165]                             next
[17:40:49.165]                           if (!grepl(pattern, name)) 
[17:40:49.165]                             next
[17:40:49.165]                           invokeRestart(restart)
[17:40:49.165]                           muffled <- TRUE
[17:40:49.165]                           break
[17:40:49.165]                         }
[17:40:49.165]                       }
[17:40:49.165]                     }
[17:40:49.165]                     invisible(muffled)
[17:40:49.165]                   }
[17:40:49.165]                   muffleCondition(cond)
[17:40:49.165]                 })
[17:40:49.165]             }))
[17:40:49.165]             future::FutureResult(value = ...future.value$value, 
[17:40:49.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.165]                   ...future.rng), globalenv = if (FALSE) 
[17:40:49.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:49.165]                     ...future.globalenv.names))
[17:40:49.165]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:49.165]         }, condition = base::local({
[17:40:49.165]             c <- base::c
[17:40:49.165]             inherits <- base::inherits
[17:40:49.165]             invokeRestart <- base::invokeRestart
[17:40:49.165]             length <- base::length
[17:40:49.165]             list <- base::list
[17:40:49.165]             seq.int <- base::seq.int
[17:40:49.165]             signalCondition <- base::signalCondition
[17:40:49.165]             sys.calls <- base::sys.calls
[17:40:49.165]             `[[` <- base::`[[`
[17:40:49.165]             `+` <- base::`+`
[17:40:49.165]             `<<-` <- base::`<<-`
[17:40:49.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:49.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:49.165]                   3L)]
[17:40:49.165]             }
[17:40:49.165]             function(cond) {
[17:40:49.165]                 is_error <- inherits(cond, "error")
[17:40:49.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:49.165]                   NULL)
[17:40:49.165]                 if (is_error) {
[17:40:49.165]                   sessionInformation <- function() {
[17:40:49.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:49.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:49.165]                       search = base::search(), system = base::Sys.info())
[17:40:49.165]                   }
[17:40:49.165]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:49.165]                     cond$call), session = sessionInformation(), 
[17:40:49.165]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:49.165]                   signalCondition(cond)
[17:40:49.165]                 }
[17:40:49.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:49.165]                 "immediateCondition"))) {
[17:40:49.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:49.165]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:49.165]                   if (TRUE && !signal) {
[17:40:49.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.165]                     {
[17:40:49.165]                       inherits <- base::inherits
[17:40:49.165]                       invokeRestart <- base::invokeRestart
[17:40:49.165]                       is.null <- base::is.null
[17:40:49.165]                       muffled <- FALSE
[17:40:49.165]                       if (inherits(cond, "message")) {
[17:40:49.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.165]                         if (muffled) 
[17:40:49.165]                           invokeRestart("muffleMessage")
[17:40:49.165]                       }
[17:40:49.165]                       else if (inherits(cond, "warning")) {
[17:40:49.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.165]                         if (muffled) 
[17:40:49.165]                           invokeRestart("muffleWarning")
[17:40:49.165]                       }
[17:40:49.165]                       else if (inherits(cond, "condition")) {
[17:40:49.165]                         if (!is.null(pattern)) {
[17:40:49.165]                           computeRestarts <- base::computeRestarts
[17:40:49.165]                           grepl <- base::grepl
[17:40:49.165]                           restarts <- computeRestarts(cond)
[17:40:49.165]                           for (restart in restarts) {
[17:40:49.165]                             name <- restart$name
[17:40:49.165]                             if (is.null(name)) 
[17:40:49.165]                               next
[17:40:49.165]                             if (!grepl(pattern, name)) 
[17:40:49.165]                               next
[17:40:49.165]                             invokeRestart(restart)
[17:40:49.165]                             muffled <- TRUE
[17:40:49.165]                             break
[17:40:49.165]                           }
[17:40:49.165]                         }
[17:40:49.165]                       }
[17:40:49.165]                       invisible(muffled)
[17:40:49.165]                     }
[17:40:49.165]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.165]                   }
[17:40:49.165]                 }
[17:40:49.165]                 else {
[17:40:49.165]                   if (TRUE) {
[17:40:49.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.165]                     {
[17:40:49.165]                       inherits <- base::inherits
[17:40:49.165]                       invokeRestart <- base::invokeRestart
[17:40:49.165]                       is.null <- base::is.null
[17:40:49.165]                       muffled <- FALSE
[17:40:49.165]                       if (inherits(cond, "message")) {
[17:40:49.165]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.165]                         if (muffled) 
[17:40:49.165]                           invokeRestart("muffleMessage")
[17:40:49.165]                       }
[17:40:49.165]                       else if (inherits(cond, "warning")) {
[17:40:49.165]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.165]                         if (muffled) 
[17:40:49.165]                           invokeRestart("muffleWarning")
[17:40:49.165]                       }
[17:40:49.165]                       else if (inherits(cond, "condition")) {
[17:40:49.165]                         if (!is.null(pattern)) {
[17:40:49.165]                           computeRestarts <- base::computeRestarts
[17:40:49.165]                           grepl <- base::grepl
[17:40:49.165]                           restarts <- computeRestarts(cond)
[17:40:49.165]                           for (restart in restarts) {
[17:40:49.165]                             name <- restart$name
[17:40:49.165]                             if (is.null(name)) 
[17:40:49.165]                               next
[17:40:49.165]                             if (!grepl(pattern, name)) 
[17:40:49.165]                               next
[17:40:49.165]                             invokeRestart(restart)
[17:40:49.165]                             muffled <- TRUE
[17:40:49.165]                             break
[17:40:49.165]                           }
[17:40:49.165]                         }
[17:40:49.165]                       }
[17:40:49.165]                       invisible(muffled)
[17:40:49.165]                     }
[17:40:49.165]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.165]                   }
[17:40:49.165]                 }
[17:40:49.165]             }
[17:40:49.165]         }))
[17:40:49.165]     }, error = function(ex) {
[17:40:49.165]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:49.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.165]                 ...future.rng), started = ...future.startTime, 
[17:40:49.165]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:49.165]             version = "1.8"), class = "FutureResult")
[17:40:49.165]     }, finally = {
[17:40:49.165]         if (!identical(...future.workdir, getwd())) 
[17:40:49.165]             setwd(...future.workdir)
[17:40:49.165]         {
[17:40:49.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:49.165]                 ...future.oldOptions$nwarnings <- NULL
[17:40:49.165]             }
[17:40:49.165]             base::options(...future.oldOptions)
[17:40:49.165]             if (.Platform$OS.type == "windows") {
[17:40:49.165]                 old_names <- names(...future.oldEnvVars)
[17:40:49.165]                 envs <- base::Sys.getenv()
[17:40:49.165]                 names <- names(envs)
[17:40:49.165]                 common <- intersect(names, old_names)
[17:40:49.165]                 added <- setdiff(names, old_names)
[17:40:49.165]                 removed <- setdiff(old_names, names)
[17:40:49.165]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:49.165]                   envs[common]]
[17:40:49.165]                 NAMES <- toupper(changed)
[17:40:49.165]                 args <- list()
[17:40:49.165]                 for (kk in seq_along(NAMES)) {
[17:40:49.165]                   name <- changed[[kk]]
[17:40:49.165]                   NAME <- NAMES[[kk]]
[17:40:49.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.165]                     next
[17:40:49.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.165]                 }
[17:40:49.165]                 NAMES <- toupper(added)
[17:40:49.165]                 for (kk in seq_along(NAMES)) {
[17:40:49.165]                   name <- added[[kk]]
[17:40:49.165]                   NAME <- NAMES[[kk]]
[17:40:49.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.165]                     next
[17:40:49.165]                   args[[name]] <- ""
[17:40:49.165]                 }
[17:40:49.165]                 NAMES <- toupper(removed)
[17:40:49.165]                 for (kk in seq_along(NAMES)) {
[17:40:49.165]                   name <- removed[[kk]]
[17:40:49.165]                   NAME <- NAMES[[kk]]
[17:40:49.165]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.165]                     next
[17:40:49.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.165]                 }
[17:40:49.165]                 if (length(args) > 0) 
[17:40:49.165]                   base::do.call(base::Sys.setenv, args = args)
[17:40:49.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:49.165]             }
[17:40:49.165]             else {
[17:40:49.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:49.165]             }
[17:40:49.165]             {
[17:40:49.165]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:49.165]                   0L) {
[17:40:49.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:49.165]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:49.165]                   base::options(opts)
[17:40:49.165]                 }
[17:40:49.165]                 {
[17:40:49.165]                   {
[17:40:49.165]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:49.165]                     NULL
[17:40:49.165]                   }
[17:40:49.165]                   options(future.plan = NULL)
[17:40:49.165]                   if (is.na(NA_character_)) 
[17:40:49.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:49.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:49.165]                     .init = FALSE)
[17:40:49.165]                 }
[17:40:49.165]             }
[17:40:49.165]         }
[17:40:49.165]     })
[17:40:49.165]     if (TRUE) {
[17:40:49.165]         base::sink(type = "output", split = FALSE)
[17:40:49.165]         if (TRUE) {
[17:40:49.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:49.165]         }
[17:40:49.165]         else {
[17:40:49.165]             ...future.result["stdout"] <- base::list(NULL)
[17:40:49.165]         }
[17:40:49.165]         base::close(...future.stdout)
[17:40:49.165]         ...future.stdout <- NULL
[17:40:49.165]     }
[17:40:49.165]     ...future.result$conditions <- ...future.conditions
[17:40:49.165]     ...future.result$finished <- base::Sys.time()
[17:40:49.165]     ...future.result
[17:40:49.165] }
[17:40:49.168] MultisessionFuture started
[17:40:49.168] - Launch lazy future ... done
[17:40:49.168] run() for ‘MultisessionFuture’ ... done
[17:40:49.170] receiveMessageFromWorker() for ClusterFuture ...
[17:40:49.170] - Validating connection of MultisessionFuture
[17:40:49.171] - received message: FutureResult
[17:40:49.171] - Received FutureResult
[17:40:49.171] - Erased future from FutureRegistry
[17:40:49.171] result() for ClusterFuture ...
[17:40:49.171] - result already collected: FutureResult
[17:40:49.171] result() for ClusterFuture ... done
[17:40:49.171] signalConditions() ...
[17:40:49.171]  - include = ‘immediateCondition’
[17:40:49.171]  - exclude = 
[17:40:49.171]  - resignal = FALSE
[17:40:49.172]  - Number of conditions: 1
[17:40:49.172] signalConditions() ... done
[17:40:49.172] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:49.172] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[17:40:49.172] getGlobalsAndPackages() ...
[17:40:49.172] Searching for globals...
[17:40:49.173] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:49.173] Searching for globals ... DONE
[17:40:49.173] Resolving globals: FALSE
[17:40:49.174] 
[17:40:49.174] 
[17:40:49.174] getGlobalsAndPackages() ... DONE
[17:40:49.174] run() for ‘Future’ ...
[17:40:49.174] - state: ‘created’
[17:40:49.174] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:49.188] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:49.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:49.189]   - Field: ‘node’
[17:40:49.189]   - Field: ‘label’
[17:40:49.189]   - Field: ‘local’
[17:40:49.189]   - Field: ‘owner’
[17:40:49.189]   - Field: ‘envir’
[17:40:49.189]   - Field: ‘workers’
[17:40:49.189]   - Field: ‘packages’
[17:40:49.189]   - Field: ‘gc’
[17:40:49.189]   - Field: ‘conditions’
[17:40:49.190]   - Field: ‘persistent’
[17:40:49.190]   - Field: ‘expr’
[17:40:49.190]   - Field: ‘uuid’
[17:40:49.190]   - Field: ‘seed’
[17:40:49.190]   - Field: ‘version’
[17:40:49.190]   - Field: ‘result’
[17:40:49.190]   - Field: ‘asynchronous’
[17:40:49.190]   - Field: ‘calls’
[17:40:49.190]   - Field: ‘globals’
[17:40:49.190]   - Field: ‘stdout’
[17:40:49.190]   - Field: ‘earlySignal’
[17:40:49.191]   - Field: ‘lazy’
[17:40:49.191]   - Field: ‘state’
[17:40:49.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:49.191] - Launch lazy future ...
[17:40:49.191] Packages needed by the future expression (n = 0): <none>
[17:40:49.191] Packages needed by future strategies (n = 0): <none>
[17:40:49.192] {
[17:40:49.192]     {
[17:40:49.192]         {
[17:40:49.192]             ...future.startTime <- base::Sys.time()
[17:40:49.192]             {
[17:40:49.192]                 {
[17:40:49.192]                   {
[17:40:49.192]                     {
[17:40:49.192]                       base::local({
[17:40:49.192]                         has_future <- base::requireNamespace("future", 
[17:40:49.192]                           quietly = TRUE)
[17:40:49.192]                         if (has_future) {
[17:40:49.192]                           ns <- base::getNamespace("future")
[17:40:49.192]                           version <- ns[[".package"]][["version"]]
[17:40:49.192]                           if (is.null(version)) 
[17:40:49.192]                             version <- utils::packageVersion("future")
[17:40:49.192]                         }
[17:40:49.192]                         else {
[17:40:49.192]                           version <- NULL
[17:40:49.192]                         }
[17:40:49.192]                         if (!has_future || version < "1.8.0") {
[17:40:49.192]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:49.192]                             "", base::R.version$version.string), 
[17:40:49.192]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:49.192]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:49.192]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:49.192]                               "release", "version")], collapse = " "), 
[17:40:49.192]                             hostname = base::Sys.info()[["nodename"]])
[17:40:49.192]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:49.192]                             info)
[17:40:49.192]                           info <- base::paste(info, collapse = "; ")
[17:40:49.192]                           if (!has_future) {
[17:40:49.192]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:49.192]                               info)
[17:40:49.192]                           }
[17:40:49.192]                           else {
[17:40:49.192]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:49.192]                               info, version)
[17:40:49.192]                           }
[17:40:49.192]                           base::stop(msg)
[17:40:49.192]                         }
[17:40:49.192]                       })
[17:40:49.192]                     }
[17:40:49.192]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:49.192]                     base::options(mc.cores = 1L)
[17:40:49.192]                   }
[17:40:49.192]                   ...future.strategy.old <- future::plan("list")
[17:40:49.192]                   options(future.plan = NULL)
[17:40:49.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:49.192]                 }
[17:40:49.192]                 ...future.workdir <- getwd()
[17:40:49.192]             }
[17:40:49.192]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:49.192]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:49.192]         }
[17:40:49.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:49.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:49.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:49.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:49.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:49.192]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:49.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:49.192]             base::names(...future.oldOptions))
[17:40:49.192]     }
[17:40:49.192]     if (FALSE) {
[17:40:49.192]     }
[17:40:49.192]     else {
[17:40:49.192]         if (TRUE) {
[17:40:49.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:49.192]                 open = "w")
[17:40:49.192]         }
[17:40:49.192]         else {
[17:40:49.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:49.192]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:49.192]         }
[17:40:49.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:49.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:49.192]             base::sink(type = "output", split = FALSE)
[17:40:49.192]             base::close(...future.stdout)
[17:40:49.192]         }, add = TRUE)
[17:40:49.192]     }
[17:40:49.192]     ...future.frame <- base::sys.nframe()
[17:40:49.192]     ...future.conditions <- base::list()
[17:40:49.192]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:49.192]     if (FALSE) {
[17:40:49.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:49.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:49.192]     }
[17:40:49.192]     ...future.result <- base::tryCatch({
[17:40:49.192]         base::withCallingHandlers({
[17:40:49.192]             ...future.value <- base::withVisible(base::local({
[17:40:49.192]                 ...future.makeSendCondition <- base::local({
[17:40:49.192]                   sendCondition <- NULL
[17:40:49.192]                   function(frame = 1L) {
[17:40:49.192]                     if (is.function(sendCondition)) 
[17:40:49.192]                       return(sendCondition)
[17:40:49.192]                     ns <- getNamespace("parallel")
[17:40:49.192]                     if (exists("sendData", mode = "function", 
[17:40:49.192]                       envir = ns)) {
[17:40:49.192]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:49.192]                         envir = ns)
[17:40:49.192]                       envir <- sys.frame(frame)
[17:40:49.192]                       master <- NULL
[17:40:49.192]                       while (!identical(envir, .GlobalEnv) && 
[17:40:49.192]                         !identical(envir, emptyenv())) {
[17:40:49.192]                         if (exists("master", mode = "list", envir = envir, 
[17:40:49.192]                           inherits = FALSE)) {
[17:40:49.192]                           master <- get("master", mode = "list", 
[17:40:49.192]                             envir = envir, inherits = FALSE)
[17:40:49.192]                           if (inherits(master, c("SOCKnode", 
[17:40:49.192]                             "SOCK0node"))) {
[17:40:49.192]                             sendCondition <<- function(cond) {
[17:40:49.192]                               data <- list(type = "VALUE", value = cond, 
[17:40:49.192]                                 success = TRUE)
[17:40:49.192]                               parallel_sendData(master, data)
[17:40:49.192]                             }
[17:40:49.192]                             return(sendCondition)
[17:40:49.192]                           }
[17:40:49.192]                         }
[17:40:49.192]                         frame <- frame + 1L
[17:40:49.192]                         envir <- sys.frame(frame)
[17:40:49.192]                       }
[17:40:49.192]                     }
[17:40:49.192]                     sendCondition <<- function(cond) NULL
[17:40:49.192]                   }
[17:40:49.192]                 })
[17:40:49.192]                 withCallingHandlers({
[17:40:49.192]                   {
[17:40:49.192]                     Sys.sleep(0.5)
[17:40:49.192]                     list(a = 1, b = 42L)
[17:40:49.192]                   }
[17:40:49.192]                 }, immediateCondition = function(cond) {
[17:40:49.192]                   sendCondition <- ...future.makeSendCondition()
[17:40:49.192]                   sendCondition(cond)
[17:40:49.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.192]                   {
[17:40:49.192]                     inherits <- base::inherits
[17:40:49.192]                     invokeRestart <- base::invokeRestart
[17:40:49.192]                     is.null <- base::is.null
[17:40:49.192]                     muffled <- FALSE
[17:40:49.192]                     if (inherits(cond, "message")) {
[17:40:49.192]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:49.192]                       if (muffled) 
[17:40:49.192]                         invokeRestart("muffleMessage")
[17:40:49.192]                     }
[17:40:49.192]                     else if (inherits(cond, "warning")) {
[17:40:49.192]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:49.192]                       if (muffled) 
[17:40:49.192]                         invokeRestart("muffleWarning")
[17:40:49.192]                     }
[17:40:49.192]                     else if (inherits(cond, "condition")) {
[17:40:49.192]                       if (!is.null(pattern)) {
[17:40:49.192]                         computeRestarts <- base::computeRestarts
[17:40:49.192]                         grepl <- base::grepl
[17:40:49.192]                         restarts <- computeRestarts(cond)
[17:40:49.192]                         for (restart in restarts) {
[17:40:49.192]                           name <- restart$name
[17:40:49.192]                           if (is.null(name)) 
[17:40:49.192]                             next
[17:40:49.192]                           if (!grepl(pattern, name)) 
[17:40:49.192]                             next
[17:40:49.192]                           invokeRestart(restart)
[17:40:49.192]                           muffled <- TRUE
[17:40:49.192]                           break
[17:40:49.192]                         }
[17:40:49.192]                       }
[17:40:49.192]                     }
[17:40:49.192]                     invisible(muffled)
[17:40:49.192]                   }
[17:40:49.192]                   muffleCondition(cond)
[17:40:49.192]                 })
[17:40:49.192]             }))
[17:40:49.192]             future::FutureResult(value = ...future.value$value, 
[17:40:49.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.192]                   ...future.rng), globalenv = if (FALSE) 
[17:40:49.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:49.192]                     ...future.globalenv.names))
[17:40:49.192]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:49.192]         }, condition = base::local({
[17:40:49.192]             c <- base::c
[17:40:49.192]             inherits <- base::inherits
[17:40:49.192]             invokeRestart <- base::invokeRestart
[17:40:49.192]             length <- base::length
[17:40:49.192]             list <- base::list
[17:40:49.192]             seq.int <- base::seq.int
[17:40:49.192]             signalCondition <- base::signalCondition
[17:40:49.192]             sys.calls <- base::sys.calls
[17:40:49.192]             `[[` <- base::`[[`
[17:40:49.192]             `+` <- base::`+`
[17:40:49.192]             `<<-` <- base::`<<-`
[17:40:49.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:49.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:49.192]                   3L)]
[17:40:49.192]             }
[17:40:49.192]             function(cond) {
[17:40:49.192]                 is_error <- inherits(cond, "error")
[17:40:49.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:49.192]                   NULL)
[17:40:49.192]                 if (is_error) {
[17:40:49.192]                   sessionInformation <- function() {
[17:40:49.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:49.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:49.192]                       search = base::search(), system = base::Sys.info())
[17:40:49.192]                   }
[17:40:49.192]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:49.192]                     cond$call), session = sessionInformation(), 
[17:40:49.192]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:49.192]                   signalCondition(cond)
[17:40:49.192]                 }
[17:40:49.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:49.192]                 "immediateCondition"))) {
[17:40:49.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:49.192]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:49.192]                   if (TRUE && !signal) {
[17:40:49.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.192]                     {
[17:40:49.192]                       inherits <- base::inherits
[17:40:49.192]                       invokeRestart <- base::invokeRestart
[17:40:49.192]                       is.null <- base::is.null
[17:40:49.192]                       muffled <- FALSE
[17:40:49.192]                       if (inherits(cond, "message")) {
[17:40:49.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.192]                         if (muffled) 
[17:40:49.192]                           invokeRestart("muffleMessage")
[17:40:49.192]                       }
[17:40:49.192]                       else if (inherits(cond, "warning")) {
[17:40:49.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.192]                         if (muffled) 
[17:40:49.192]                           invokeRestart("muffleWarning")
[17:40:49.192]                       }
[17:40:49.192]                       else if (inherits(cond, "condition")) {
[17:40:49.192]                         if (!is.null(pattern)) {
[17:40:49.192]                           computeRestarts <- base::computeRestarts
[17:40:49.192]                           grepl <- base::grepl
[17:40:49.192]                           restarts <- computeRestarts(cond)
[17:40:49.192]                           for (restart in restarts) {
[17:40:49.192]                             name <- restart$name
[17:40:49.192]                             if (is.null(name)) 
[17:40:49.192]                               next
[17:40:49.192]                             if (!grepl(pattern, name)) 
[17:40:49.192]                               next
[17:40:49.192]                             invokeRestart(restart)
[17:40:49.192]                             muffled <- TRUE
[17:40:49.192]                             break
[17:40:49.192]                           }
[17:40:49.192]                         }
[17:40:49.192]                       }
[17:40:49.192]                       invisible(muffled)
[17:40:49.192]                     }
[17:40:49.192]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.192]                   }
[17:40:49.192]                 }
[17:40:49.192]                 else {
[17:40:49.192]                   if (TRUE) {
[17:40:49.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.192]                     {
[17:40:49.192]                       inherits <- base::inherits
[17:40:49.192]                       invokeRestart <- base::invokeRestart
[17:40:49.192]                       is.null <- base::is.null
[17:40:49.192]                       muffled <- FALSE
[17:40:49.192]                       if (inherits(cond, "message")) {
[17:40:49.192]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.192]                         if (muffled) 
[17:40:49.192]                           invokeRestart("muffleMessage")
[17:40:49.192]                       }
[17:40:49.192]                       else if (inherits(cond, "warning")) {
[17:40:49.192]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.192]                         if (muffled) 
[17:40:49.192]                           invokeRestart("muffleWarning")
[17:40:49.192]                       }
[17:40:49.192]                       else if (inherits(cond, "condition")) {
[17:40:49.192]                         if (!is.null(pattern)) {
[17:40:49.192]                           computeRestarts <- base::computeRestarts
[17:40:49.192]                           grepl <- base::grepl
[17:40:49.192]                           restarts <- computeRestarts(cond)
[17:40:49.192]                           for (restart in restarts) {
[17:40:49.192]                             name <- restart$name
[17:40:49.192]                             if (is.null(name)) 
[17:40:49.192]                               next
[17:40:49.192]                             if (!grepl(pattern, name)) 
[17:40:49.192]                               next
[17:40:49.192]                             invokeRestart(restart)
[17:40:49.192]                             muffled <- TRUE
[17:40:49.192]                             break
[17:40:49.192]                           }
[17:40:49.192]                         }
[17:40:49.192]                       }
[17:40:49.192]                       invisible(muffled)
[17:40:49.192]                     }
[17:40:49.192]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.192]                   }
[17:40:49.192]                 }
[17:40:49.192]             }
[17:40:49.192]         }))
[17:40:49.192]     }, error = function(ex) {
[17:40:49.192]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:49.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.192]                 ...future.rng), started = ...future.startTime, 
[17:40:49.192]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:49.192]             version = "1.8"), class = "FutureResult")
[17:40:49.192]     }, finally = {
[17:40:49.192]         if (!identical(...future.workdir, getwd())) 
[17:40:49.192]             setwd(...future.workdir)
[17:40:49.192]         {
[17:40:49.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:49.192]                 ...future.oldOptions$nwarnings <- NULL
[17:40:49.192]             }
[17:40:49.192]             base::options(...future.oldOptions)
[17:40:49.192]             if (.Platform$OS.type == "windows") {
[17:40:49.192]                 old_names <- names(...future.oldEnvVars)
[17:40:49.192]                 envs <- base::Sys.getenv()
[17:40:49.192]                 names <- names(envs)
[17:40:49.192]                 common <- intersect(names, old_names)
[17:40:49.192]                 added <- setdiff(names, old_names)
[17:40:49.192]                 removed <- setdiff(old_names, names)
[17:40:49.192]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:49.192]                   envs[common]]
[17:40:49.192]                 NAMES <- toupper(changed)
[17:40:49.192]                 args <- list()
[17:40:49.192]                 for (kk in seq_along(NAMES)) {
[17:40:49.192]                   name <- changed[[kk]]
[17:40:49.192]                   NAME <- NAMES[[kk]]
[17:40:49.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.192]                     next
[17:40:49.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.192]                 }
[17:40:49.192]                 NAMES <- toupper(added)
[17:40:49.192]                 for (kk in seq_along(NAMES)) {
[17:40:49.192]                   name <- added[[kk]]
[17:40:49.192]                   NAME <- NAMES[[kk]]
[17:40:49.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.192]                     next
[17:40:49.192]                   args[[name]] <- ""
[17:40:49.192]                 }
[17:40:49.192]                 NAMES <- toupper(removed)
[17:40:49.192]                 for (kk in seq_along(NAMES)) {
[17:40:49.192]                   name <- removed[[kk]]
[17:40:49.192]                   NAME <- NAMES[[kk]]
[17:40:49.192]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.192]                     next
[17:40:49.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.192]                 }
[17:40:49.192]                 if (length(args) > 0) 
[17:40:49.192]                   base::do.call(base::Sys.setenv, args = args)
[17:40:49.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:49.192]             }
[17:40:49.192]             else {
[17:40:49.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:49.192]             }
[17:40:49.192]             {
[17:40:49.192]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:49.192]                   0L) {
[17:40:49.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:49.192]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:49.192]                   base::options(opts)
[17:40:49.192]                 }
[17:40:49.192]                 {
[17:40:49.192]                   {
[17:40:49.192]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:49.192]                     NULL
[17:40:49.192]                   }
[17:40:49.192]                   options(future.plan = NULL)
[17:40:49.192]                   if (is.na(NA_character_)) 
[17:40:49.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:49.192]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:49.192]                     .init = FALSE)
[17:40:49.192]                 }
[17:40:49.192]             }
[17:40:49.192]         }
[17:40:49.192]     })
[17:40:49.192]     if (TRUE) {
[17:40:49.192]         base::sink(type = "output", split = FALSE)
[17:40:49.192]         if (TRUE) {
[17:40:49.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:49.192]         }
[17:40:49.192]         else {
[17:40:49.192]             ...future.result["stdout"] <- base::list(NULL)
[17:40:49.192]         }
[17:40:49.192]         base::close(...future.stdout)
[17:40:49.192]         ...future.stdout <- NULL
[17:40:49.192]     }
[17:40:49.192]     ...future.result$conditions <- ...future.conditions
[17:40:49.192]     ...future.result$finished <- base::Sys.time()
[17:40:49.192]     ...future.result
[17:40:49.192] }
[17:40:49.195] MultisessionFuture started
[17:40:49.195] - Launch lazy future ... done
[17:40:49.195] run() for ‘MultisessionFuture’ ... done
[17:40:49.697] receiveMessageFromWorker() for ClusterFuture ...
[17:40:49.698] - Validating connection of MultisessionFuture
[17:40:49.698] - received message: FutureResult
[17:40:49.698] - Received FutureResult
[17:40:49.698] - Erased future from FutureRegistry
[17:40:49.698] result() for ClusterFuture ...
[17:40:49.698] - result already collected: FutureResult
[17:40:49.698] result() for ClusterFuture ... done
[17:40:49.698] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:49.699] A MultisessionFuture was resolved (result was not collected)
[17:40:49.699] getGlobalsAndPackages() ...
[17:40:49.699] Searching for globals...
[17:40:49.700] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:49.700] Searching for globals ... DONE
[17:40:49.700] Resolving globals: FALSE
[17:40:49.700] 
[17:40:49.701] 
[17:40:49.701] getGlobalsAndPackages() ... DONE
[17:40:49.701] run() for ‘Future’ ...
[17:40:49.701] - state: ‘created’
[17:40:49.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:49.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:49.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:49.716]   - Field: ‘node’
[17:40:49.716]   - Field: ‘label’
[17:40:49.716]   - Field: ‘local’
[17:40:49.716]   - Field: ‘owner’
[17:40:49.716]   - Field: ‘envir’
[17:40:49.716]   - Field: ‘workers’
[17:40:49.716]   - Field: ‘packages’
[17:40:49.717]   - Field: ‘gc’
[17:40:49.717]   - Field: ‘conditions’
[17:40:49.717]   - Field: ‘persistent’
[17:40:49.717]   - Field: ‘expr’
[17:40:49.717]   - Field: ‘uuid’
[17:40:49.717]   - Field: ‘seed’
[17:40:49.717]   - Field: ‘version’
[17:40:49.717]   - Field: ‘result’
[17:40:49.717]   - Field: ‘asynchronous’
[17:40:49.717]   - Field: ‘calls’
[17:40:49.717]   - Field: ‘globals’
[17:40:49.718]   - Field: ‘stdout’
[17:40:49.718]   - Field: ‘earlySignal’
[17:40:49.718]   - Field: ‘lazy’
[17:40:49.718]   - Field: ‘state’
[17:40:49.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:49.718] - Launch lazy future ...
[17:40:49.718] Packages needed by the future expression (n = 0): <none>
[17:40:49.718] Packages needed by future strategies (n = 0): <none>
[17:40:49.719] {
[17:40:49.719]     {
[17:40:49.719]         {
[17:40:49.719]             ...future.startTime <- base::Sys.time()
[17:40:49.719]             {
[17:40:49.719]                 {
[17:40:49.719]                   {
[17:40:49.719]                     {
[17:40:49.719]                       base::local({
[17:40:49.719]                         has_future <- base::requireNamespace("future", 
[17:40:49.719]                           quietly = TRUE)
[17:40:49.719]                         if (has_future) {
[17:40:49.719]                           ns <- base::getNamespace("future")
[17:40:49.719]                           version <- ns[[".package"]][["version"]]
[17:40:49.719]                           if (is.null(version)) 
[17:40:49.719]                             version <- utils::packageVersion("future")
[17:40:49.719]                         }
[17:40:49.719]                         else {
[17:40:49.719]                           version <- NULL
[17:40:49.719]                         }
[17:40:49.719]                         if (!has_future || version < "1.8.0") {
[17:40:49.719]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:49.719]                             "", base::R.version$version.string), 
[17:40:49.719]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:49.719]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:49.719]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:49.719]                               "release", "version")], collapse = " "), 
[17:40:49.719]                             hostname = base::Sys.info()[["nodename"]])
[17:40:49.719]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:49.719]                             info)
[17:40:49.719]                           info <- base::paste(info, collapse = "; ")
[17:40:49.719]                           if (!has_future) {
[17:40:49.719]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:49.719]                               info)
[17:40:49.719]                           }
[17:40:49.719]                           else {
[17:40:49.719]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:49.719]                               info, version)
[17:40:49.719]                           }
[17:40:49.719]                           base::stop(msg)
[17:40:49.719]                         }
[17:40:49.719]                       })
[17:40:49.719]                     }
[17:40:49.719]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:49.719]                     base::options(mc.cores = 1L)
[17:40:49.719]                   }
[17:40:49.719]                   ...future.strategy.old <- future::plan("list")
[17:40:49.719]                   options(future.plan = NULL)
[17:40:49.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:49.719]                 }
[17:40:49.719]                 ...future.workdir <- getwd()
[17:40:49.719]             }
[17:40:49.719]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:49.719]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:49.719]         }
[17:40:49.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:49.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:49.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:49.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:49.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:49.719]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:49.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:49.719]             base::names(...future.oldOptions))
[17:40:49.719]     }
[17:40:49.719]     if (FALSE) {
[17:40:49.719]     }
[17:40:49.719]     else {
[17:40:49.719]         if (TRUE) {
[17:40:49.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:49.719]                 open = "w")
[17:40:49.719]         }
[17:40:49.719]         else {
[17:40:49.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:49.719]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:49.719]         }
[17:40:49.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:49.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:49.719]             base::sink(type = "output", split = FALSE)
[17:40:49.719]             base::close(...future.stdout)
[17:40:49.719]         }, add = TRUE)
[17:40:49.719]     }
[17:40:49.719]     ...future.frame <- base::sys.nframe()
[17:40:49.719]     ...future.conditions <- base::list()
[17:40:49.719]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:49.719]     if (FALSE) {
[17:40:49.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:49.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:49.719]     }
[17:40:49.719]     ...future.result <- base::tryCatch({
[17:40:49.719]         base::withCallingHandlers({
[17:40:49.719]             ...future.value <- base::withVisible(base::local({
[17:40:49.719]                 ...future.makeSendCondition <- base::local({
[17:40:49.719]                   sendCondition <- NULL
[17:40:49.719]                   function(frame = 1L) {
[17:40:49.719]                     if (is.function(sendCondition)) 
[17:40:49.719]                       return(sendCondition)
[17:40:49.719]                     ns <- getNamespace("parallel")
[17:40:49.719]                     if (exists("sendData", mode = "function", 
[17:40:49.719]                       envir = ns)) {
[17:40:49.719]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:49.719]                         envir = ns)
[17:40:49.719]                       envir <- sys.frame(frame)
[17:40:49.719]                       master <- NULL
[17:40:49.719]                       while (!identical(envir, .GlobalEnv) && 
[17:40:49.719]                         !identical(envir, emptyenv())) {
[17:40:49.719]                         if (exists("master", mode = "list", envir = envir, 
[17:40:49.719]                           inherits = FALSE)) {
[17:40:49.719]                           master <- get("master", mode = "list", 
[17:40:49.719]                             envir = envir, inherits = FALSE)
[17:40:49.719]                           if (inherits(master, c("SOCKnode", 
[17:40:49.719]                             "SOCK0node"))) {
[17:40:49.719]                             sendCondition <<- function(cond) {
[17:40:49.719]                               data <- list(type = "VALUE", value = cond, 
[17:40:49.719]                                 success = TRUE)
[17:40:49.719]                               parallel_sendData(master, data)
[17:40:49.719]                             }
[17:40:49.719]                             return(sendCondition)
[17:40:49.719]                           }
[17:40:49.719]                         }
[17:40:49.719]                         frame <- frame + 1L
[17:40:49.719]                         envir <- sys.frame(frame)
[17:40:49.719]                       }
[17:40:49.719]                     }
[17:40:49.719]                     sendCondition <<- function(cond) NULL
[17:40:49.719]                   }
[17:40:49.719]                 })
[17:40:49.719]                 withCallingHandlers({
[17:40:49.719]                   {
[17:40:49.719]                     Sys.sleep(0.5)
[17:40:49.719]                     list(a = 1, b = 42L)
[17:40:49.719]                   }
[17:40:49.719]                 }, immediateCondition = function(cond) {
[17:40:49.719]                   sendCondition <- ...future.makeSendCondition()
[17:40:49.719]                   sendCondition(cond)
[17:40:49.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.719]                   {
[17:40:49.719]                     inherits <- base::inherits
[17:40:49.719]                     invokeRestart <- base::invokeRestart
[17:40:49.719]                     is.null <- base::is.null
[17:40:49.719]                     muffled <- FALSE
[17:40:49.719]                     if (inherits(cond, "message")) {
[17:40:49.719]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:49.719]                       if (muffled) 
[17:40:49.719]                         invokeRestart("muffleMessage")
[17:40:49.719]                     }
[17:40:49.719]                     else if (inherits(cond, "warning")) {
[17:40:49.719]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:49.719]                       if (muffled) 
[17:40:49.719]                         invokeRestart("muffleWarning")
[17:40:49.719]                     }
[17:40:49.719]                     else if (inherits(cond, "condition")) {
[17:40:49.719]                       if (!is.null(pattern)) {
[17:40:49.719]                         computeRestarts <- base::computeRestarts
[17:40:49.719]                         grepl <- base::grepl
[17:40:49.719]                         restarts <- computeRestarts(cond)
[17:40:49.719]                         for (restart in restarts) {
[17:40:49.719]                           name <- restart$name
[17:40:49.719]                           if (is.null(name)) 
[17:40:49.719]                             next
[17:40:49.719]                           if (!grepl(pattern, name)) 
[17:40:49.719]                             next
[17:40:49.719]                           invokeRestart(restart)
[17:40:49.719]                           muffled <- TRUE
[17:40:49.719]                           break
[17:40:49.719]                         }
[17:40:49.719]                       }
[17:40:49.719]                     }
[17:40:49.719]                     invisible(muffled)
[17:40:49.719]                   }
[17:40:49.719]                   muffleCondition(cond)
[17:40:49.719]                 })
[17:40:49.719]             }))
[17:40:49.719]             future::FutureResult(value = ...future.value$value, 
[17:40:49.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.719]                   ...future.rng), globalenv = if (FALSE) 
[17:40:49.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:49.719]                     ...future.globalenv.names))
[17:40:49.719]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:49.719]         }, condition = base::local({
[17:40:49.719]             c <- base::c
[17:40:49.719]             inherits <- base::inherits
[17:40:49.719]             invokeRestart <- base::invokeRestart
[17:40:49.719]             length <- base::length
[17:40:49.719]             list <- base::list
[17:40:49.719]             seq.int <- base::seq.int
[17:40:49.719]             signalCondition <- base::signalCondition
[17:40:49.719]             sys.calls <- base::sys.calls
[17:40:49.719]             `[[` <- base::`[[`
[17:40:49.719]             `+` <- base::`+`
[17:40:49.719]             `<<-` <- base::`<<-`
[17:40:49.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:49.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:49.719]                   3L)]
[17:40:49.719]             }
[17:40:49.719]             function(cond) {
[17:40:49.719]                 is_error <- inherits(cond, "error")
[17:40:49.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:49.719]                   NULL)
[17:40:49.719]                 if (is_error) {
[17:40:49.719]                   sessionInformation <- function() {
[17:40:49.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:49.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:49.719]                       search = base::search(), system = base::Sys.info())
[17:40:49.719]                   }
[17:40:49.719]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:49.719]                     cond$call), session = sessionInformation(), 
[17:40:49.719]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:49.719]                   signalCondition(cond)
[17:40:49.719]                 }
[17:40:49.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:49.719]                 "immediateCondition"))) {
[17:40:49.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:49.719]                   ...future.conditions[[length(...future.conditions) + 
[17:40:49.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:49.719]                   if (TRUE && !signal) {
[17:40:49.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.719]                     {
[17:40:49.719]                       inherits <- base::inherits
[17:40:49.719]                       invokeRestart <- base::invokeRestart
[17:40:49.719]                       is.null <- base::is.null
[17:40:49.719]                       muffled <- FALSE
[17:40:49.719]                       if (inherits(cond, "message")) {
[17:40:49.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.719]                         if (muffled) 
[17:40:49.719]                           invokeRestart("muffleMessage")
[17:40:49.719]                       }
[17:40:49.719]                       else if (inherits(cond, "warning")) {
[17:40:49.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.719]                         if (muffled) 
[17:40:49.719]                           invokeRestart("muffleWarning")
[17:40:49.719]                       }
[17:40:49.719]                       else if (inherits(cond, "condition")) {
[17:40:49.719]                         if (!is.null(pattern)) {
[17:40:49.719]                           computeRestarts <- base::computeRestarts
[17:40:49.719]                           grepl <- base::grepl
[17:40:49.719]                           restarts <- computeRestarts(cond)
[17:40:49.719]                           for (restart in restarts) {
[17:40:49.719]                             name <- restart$name
[17:40:49.719]                             if (is.null(name)) 
[17:40:49.719]                               next
[17:40:49.719]                             if (!grepl(pattern, name)) 
[17:40:49.719]                               next
[17:40:49.719]                             invokeRestart(restart)
[17:40:49.719]                             muffled <- TRUE
[17:40:49.719]                             break
[17:40:49.719]                           }
[17:40:49.719]                         }
[17:40:49.719]                       }
[17:40:49.719]                       invisible(muffled)
[17:40:49.719]                     }
[17:40:49.719]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.719]                   }
[17:40:49.719]                 }
[17:40:49.719]                 else {
[17:40:49.719]                   if (TRUE) {
[17:40:49.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:49.719]                     {
[17:40:49.719]                       inherits <- base::inherits
[17:40:49.719]                       invokeRestart <- base::invokeRestart
[17:40:49.719]                       is.null <- base::is.null
[17:40:49.719]                       muffled <- FALSE
[17:40:49.719]                       if (inherits(cond, "message")) {
[17:40:49.719]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:49.719]                         if (muffled) 
[17:40:49.719]                           invokeRestart("muffleMessage")
[17:40:49.719]                       }
[17:40:49.719]                       else if (inherits(cond, "warning")) {
[17:40:49.719]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:49.719]                         if (muffled) 
[17:40:49.719]                           invokeRestart("muffleWarning")
[17:40:49.719]                       }
[17:40:49.719]                       else if (inherits(cond, "condition")) {
[17:40:49.719]                         if (!is.null(pattern)) {
[17:40:49.719]                           computeRestarts <- base::computeRestarts
[17:40:49.719]                           grepl <- base::grepl
[17:40:49.719]                           restarts <- computeRestarts(cond)
[17:40:49.719]                           for (restart in restarts) {
[17:40:49.719]                             name <- restart$name
[17:40:49.719]                             if (is.null(name)) 
[17:40:49.719]                               next
[17:40:49.719]                             if (!grepl(pattern, name)) 
[17:40:49.719]                               next
[17:40:49.719]                             invokeRestart(restart)
[17:40:49.719]                             muffled <- TRUE
[17:40:49.719]                             break
[17:40:49.719]                           }
[17:40:49.719]                         }
[17:40:49.719]                       }
[17:40:49.719]                       invisible(muffled)
[17:40:49.719]                     }
[17:40:49.719]                     muffleCondition(cond, pattern = "^muffle")
[17:40:49.719]                   }
[17:40:49.719]                 }
[17:40:49.719]             }
[17:40:49.719]         }))
[17:40:49.719]     }, error = function(ex) {
[17:40:49.719]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:49.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:49.719]                 ...future.rng), started = ...future.startTime, 
[17:40:49.719]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:49.719]             version = "1.8"), class = "FutureResult")
[17:40:49.719]     }, finally = {
[17:40:49.719]         if (!identical(...future.workdir, getwd())) 
[17:40:49.719]             setwd(...future.workdir)
[17:40:49.719]         {
[17:40:49.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:49.719]                 ...future.oldOptions$nwarnings <- NULL
[17:40:49.719]             }
[17:40:49.719]             base::options(...future.oldOptions)
[17:40:49.719]             if (.Platform$OS.type == "windows") {
[17:40:49.719]                 old_names <- names(...future.oldEnvVars)
[17:40:49.719]                 envs <- base::Sys.getenv()
[17:40:49.719]                 names <- names(envs)
[17:40:49.719]                 common <- intersect(names, old_names)
[17:40:49.719]                 added <- setdiff(names, old_names)
[17:40:49.719]                 removed <- setdiff(old_names, names)
[17:40:49.719]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:49.719]                   envs[common]]
[17:40:49.719]                 NAMES <- toupper(changed)
[17:40:49.719]                 args <- list()
[17:40:49.719]                 for (kk in seq_along(NAMES)) {
[17:40:49.719]                   name <- changed[[kk]]
[17:40:49.719]                   NAME <- NAMES[[kk]]
[17:40:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.719]                     next
[17:40:49.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.719]                 }
[17:40:49.719]                 NAMES <- toupper(added)
[17:40:49.719]                 for (kk in seq_along(NAMES)) {
[17:40:49.719]                   name <- added[[kk]]
[17:40:49.719]                   NAME <- NAMES[[kk]]
[17:40:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.719]                     next
[17:40:49.719]                   args[[name]] <- ""
[17:40:49.719]                 }
[17:40:49.719]                 NAMES <- toupper(removed)
[17:40:49.719]                 for (kk in seq_along(NAMES)) {
[17:40:49.719]                   name <- removed[[kk]]
[17:40:49.719]                   NAME <- NAMES[[kk]]
[17:40:49.719]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:49.719]                     next
[17:40:49.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:49.719]                 }
[17:40:49.719]                 if (length(args) > 0) 
[17:40:49.719]                   base::do.call(base::Sys.setenv, args = args)
[17:40:49.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:49.719]             }
[17:40:49.719]             else {
[17:40:49.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:49.719]             }
[17:40:49.719]             {
[17:40:49.719]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:49.719]                   0L) {
[17:40:49.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:49.719]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:49.719]                   base::options(opts)
[17:40:49.719]                 }
[17:40:49.719]                 {
[17:40:49.719]                   {
[17:40:49.719]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:49.719]                     NULL
[17:40:49.719]                   }
[17:40:49.719]                   options(future.plan = NULL)
[17:40:49.719]                   if (is.na(NA_character_)) 
[17:40:49.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:49.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:49.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:49.719]                     .init = FALSE)
[17:40:49.719]                 }
[17:40:49.719]             }
[17:40:49.719]         }
[17:40:49.719]     })
[17:40:49.719]     if (TRUE) {
[17:40:49.719]         base::sink(type = "output", split = FALSE)
[17:40:49.719]         if (TRUE) {
[17:40:49.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:49.719]         }
[17:40:49.719]         else {
[17:40:49.719]             ...future.result["stdout"] <- base::list(NULL)
[17:40:49.719]         }
[17:40:49.719]         base::close(...future.stdout)
[17:40:49.719]         ...future.stdout <- NULL
[17:40:49.719]     }
[17:40:49.719]     ...future.result$conditions <- ...future.conditions
[17:40:49.719]     ...future.result$finished <- base::Sys.time()
[17:40:49.719]     ...future.result
[17:40:49.719] }
[17:40:49.722] MultisessionFuture started
[17:40:49.722] - Launch lazy future ... done
[17:40:49.722] run() for ‘MultisessionFuture’ ... done
[17:40:50.225] receiveMessageFromWorker() for ClusterFuture ...
[17:40:50.225] - Validating connection of MultisessionFuture
[17:40:50.225] - received message: FutureResult
[17:40:50.225] - Received FutureResult
[17:40:50.225] - Erased future from FutureRegistry
[17:40:50.226] result() for ClusterFuture ...
[17:40:50.226] - result already collected: FutureResult
[17:40:50.226] result() for ClusterFuture ... done
[17:40:50.226] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:50.226] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:50.226] getGlobalsAndPackages() ...
[17:40:50.226] Searching for globals...
[17:40:50.227] - globals found: [2] ‘list’, ‘stop’
[17:40:50.227] Searching for globals ... DONE
[17:40:50.227] Resolving globals: FALSE
[17:40:50.227] 
[17:40:50.228] 
[17:40:50.228] getGlobalsAndPackages() ... DONE
[17:40:50.228] run() for ‘Future’ ...
[17:40:50.228] - state: ‘created’
[17:40:50.228] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:50.242] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:50.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:50.243]   - Field: ‘node’
[17:40:50.243]   - Field: ‘label’
[17:40:50.243]   - Field: ‘local’
[17:40:50.243]   - Field: ‘owner’
[17:40:50.243]   - Field: ‘envir’
[17:40:50.243]   - Field: ‘workers’
[17:40:50.243]   - Field: ‘packages’
[17:40:50.243]   - Field: ‘gc’
[17:40:50.243]   - Field: ‘conditions’
[17:40:50.244]   - Field: ‘persistent’
[17:40:50.244]   - Field: ‘expr’
[17:40:50.244]   - Field: ‘uuid’
[17:40:50.244]   - Field: ‘seed’
[17:40:50.244]   - Field: ‘version’
[17:40:50.244]   - Field: ‘result’
[17:40:50.244]   - Field: ‘asynchronous’
[17:40:50.244]   - Field: ‘calls’
[17:40:50.244]   - Field: ‘globals’
[17:40:50.244]   - Field: ‘stdout’
[17:40:50.244]   - Field: ‘earlySignal’
[17:40:50.245]   - Field: ‘lazy’
[17:40:50.245]   - Field: ‘state’
[17:40:50.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:50.245] - Launch lazy future ...
[17:40:50.245] Packages needed by the future expression (n = 0): <none>
[17:40:50.245] Packages needed by future strategies (n = 0): <none>
[17:40:50.246] {
[17:40:50.246]     {
[17:40:50.246]         {
[17:40:50.246]             ...future.startTime <- base::Sys.time()
[17:40:50.246]             {
[17:40:50.246]                 {
[17:40:50.246]                   {
[17:40:50.246]                     {
[17:40:50.246]                       base::local({
[17:40:50.246]                         has_future <- base::requireNamespace("future", 
[17:40:50.246]                           quietly = TRUE)
[17:40:50.246]                         if (has_future) {
[17:40:50.246]                           ns <- base::getNamespace("future")
[17:40:50.246]                           version <- ns[[".package"]][["version"]]
[17:40:50.246]                           if (is.null(version)) 
[17:40:50.246]                             version <- utils::packageVersion("future")
[17:40:50.246]                         }
[17:40:50.246]                         else {
[17:40:50.246]                           version <- NULL
[17:40:50.246]                         }
[17:40:50.246]                         if (!has_future || version < "1.8.0") {
[17:40:50.246]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:50.246]                             "", base::R.version$version.string), 
[17:40:50.246]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:50.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:50.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:50.246]                               "release", "version")], collapse = " "), 
[17:40:50.246]                             hostname = base::Sys.info()[["nodename"]])
[17:40:50.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:50.246]                             info)
[17:40:50.246]                           info <- base::paste(info, collapse = "; ")
[17:40:50.246]                           if (!has_future) {
[17:40:50.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:50.246]                               info)
[17:40:50.246]                           }
[17:40:50.246]                           else {
[17:40:50.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:50.246]                               info, version)
[17:40:50.246]                           }
[17:40:50.246]                           base::stop(msg)
[17:40:50.246]                         }
[17:40:50.246]                       })
[17:40:50.246]                     }
[17:40:50.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:50.246]                     base::options(mc.cores = 1L)
[17:40:50.246]                   }
[17:40:50.246]                   ...future.strategy.old <- future::plan("list")
[17:40:50.246]                   options(future.plan = NULL)
[17:40:50.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:50.246]                 }
[17:40:50.246]                 ...future.workdir <- getwd()
[17:40:50.246]             }
[17:40:50.246]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:50.246]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:50.246]         }
[17:40:50.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:50.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:50.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:50.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:50.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:50.246]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:50.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:50.246]             base::names(...future.oldOptions))
[17:40:50.246]     }
[17:40:50.246]     if (FALSE) {
[17:40:50.246]     }
[17:40:50.246]     else {
[17:40:50.246]         if (TRUE) {
[17:40:50.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:50.246]                 open = "w")
[17:40:50.246]         }
[17:40:50.246]         else {
[17:40:50.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:50.246]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:50.246]         }
[17:40:50.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:50.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:50.246]             base::sink(type = "output", split = FALSE)
[17:40:50.246]             base::close(...future.stdout)
[17:40:50.246]         }, add = TRUE)
[17:40:50.246]     }
[17:40:50.246]     ...future.frame <- base::sys.nframe()
[17:40:50.246]     ...future.conditions <- base::list()
[17:40:50.246]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:50.246]     if (FALSE) {
[17:40:50.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:50.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:50.246]     }
[17:40:50.246]     ...future.result <- base::tryCatch({
[17:40:50.246]         base::withCallingHandlers({
[17:40:50.246]             ...future.value <- base::withVisible(base::local({
[17:40:50.246]                 ...future.makeSendCondition <- base::local({
[17:40:50.246]                   sendCondition <- NULL
[17:40:50.246]                   function(frame = 1L) {
[17:40:50.246]                     if (is.function(sendCondition)) 
[17:40:50.246]                       return(sendCondition)
[17:40:50.246]                     ns <- getNamespace("parallel")
[17:40:50.246]                     if (exists("sendData", mode = "function", 
[17:40:50.246]                       envir = ns)) {
[17:40:50.246]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:50.246]                         envir = ns)
[17:40:50.246]                       envir <- sys.frame(frame)
[17:40:50.246]                       master <- NULL
[17:40:50.246]                       while (!identical(envir, .GlobalEnv) && 
[17:40:50.246]                         !identical(envir, emptyenv())) {
[17:40:50.246]                         if (exists("master", mode = "list", envir = envir, 
[17:40:50.246]                           inherits = FALSE)) {
[17:40:50.246]                           master <- get("master", mode = "list", 
[17:40:50.246]                             envir = envir, inherits = FALSE)
[17:40:50.246]                           if (inherits(master, c("SOCKnode", 
[17:40:50.246]                             "SOCK0node"))) {
[17:40:50.246]                             sendCondition <<- function(cond) {
[17:40:50.246]                               data <- list(type = "VALUE", value = cond, 
[17:40:50.246]                                 success = TRUE)
[17:40:50.246]                               parallel_sendData(master, data)
[17:40:50.246]                             }
[17:40:50.246]                             return(sendCondition)
[17:40:50.246]                           }
[17:40:50.246]                         }
[17:40:50.246]                         frame <- frame + 1L
[17:40:50.246]                         envir <- sys.frame(frame)
[17:40:50.246]                       }
[17:40:50.246]                     }
[17:40:50.246]                     sendCondition <<- function(cond) NULL
[17:40:50.246]                   }
[17:40:50.246]                 })
[17:40:50.246]                 withCallingHandlers({
[17:40:50.246]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:50.246]                 }, immediateCondition = function(cond) {
[17:40:50.246]                   sendCondition <- ...future.makeSendCondition()
[17:40:50.246]                   sendCondition(cond)
[17:40:50.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.246]                   {
[17:40:50.246]                     inherits <- base::inherits
[17:40:50.246]                     invokeRestart <- base::invokeRestart
[17:40:50.246]                     is.null <- base::is.null
[17:40:50.246]                     muffled <- FALSE
[17:40:50.246]                     if (inherits(cond, "message")) {
[17:40:50.246]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:50.246]                       if (muffled) 
[17:40:50.246]                         invokeRestart("muffleMessage")
[17:40:50.246]                     }
[17:40:50.246]                     else if (inherits(cond, "warning")) {
[17:40:50.246]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:50.246]                       if (muffled) 
[17:40:50.246]                         invokeRestart("muffleWarning")
[17:40:50.246]                     }
[17:40:50.246]                     else if (inherits(cond, "condition")) {
[17:40:50.246]                       if (!is.null(pattern)) {
[17:40:50.246]                         computeRestarts <- base::computeRestarts
[17:40:50.246]                         grepl <- base::grepl
[17:40:50.246]                         restarts <- computeRestarts(cond)
[17:40:50.246]                         for (restart in restarts) {
[17:40:50.246]                           name <- restart$name
[17:40:50.246]                           if (is.null(name)) 
[17:40:50.246]                             next
[17:40:50.246]                           if (!grepl(pattern, name)) 
[17:40:50.246]                             next
[17:40:50.246]                           invokeRestart(restart)
[17:40:50.246]                           muffled <- TRUE
[17:40:50.246]                           break
[17:40:50.246]                         }
[17:40:50.246]                       }
[17:40:50.246]                     }
[17:40:50.246]                     invisible(muffled)
[17:40:50.246]                   }
[17:40:50.246]                   muffleCondition(cond)
[17:40:50.246]                 })
[17:40:50.246]             }))
[17:40:50.246]             future::FutureResult(value = ...future.value$value, 
[17:40:50.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.246]                   ...future.rng), globalenv = if (FALSE) 
[17:40:50.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:50.246]                     ...future.globalenv.names))
[17:40:50.246]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:50.246]         }, condition = base::local({
[17:40:50.246]             c <- base::c
[17:40:50.246]             inherits <- base::inherits
[17:40:50.246]             invokeRestart <- base::invokeRestart
[17:40:50.246]             length <- base::length
[17:40:50.246]             list <- base::list
[17:40:50.246]             seq.int <- base::seq.int
[17:40:50.246]             signalCondition <- base::signalCondition
[17:40:50.246]             sys.calls <- base::sys.calls
[17:40:50.246]             `[[` <- base::`[[`
[17:40:50.246]             `+` <- base::`+`
[17:40:50.246]             `<<-` <- base::`<<-`
[17:40:50.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:50.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:50.246]                   3L)]
[17:40:50.246]             }
[17:40:50.246]             function(cond) {
[17:40:50.246]                 is_error <- inherits(cond, "error")
[17:40:50.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:50.246]                   NULL)
[17:40:50.246]                 if (is_error) {
[17:40:50.246]                   sessionInformation <- function() {
[17:40:50.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:50.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:50.246]                       search = base::search(), system = base::Sys.info())
[17:40:50.246]                   }
[17:40:50.246]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:50.246]                     cond$call), session = sessionInformation(), 
[17:40:50.246]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:50.246]                   signalCondition(cond)
[17:40:50.246]                 }
[17:40:50.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:50.246]                 "immediateCondition"))) {
[17:40:50.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:50.246]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:50.246]                   if (TRUE && !signal) {
[17:40:50.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.246]                     {
[17:40:50.246]                       inherits <- base::inherits
[17:40:50.246]                       invokeRestart <- base::invokeRestart
[17:40:50.246]                       is.null <- base::is.null
[17:40:50.246]                       muffled <- FALSE
[17:40:50.246]                       if (inherits(cond, "message")) {
[17:40:50.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.246]                         if (muffled) 
[17:40:50.246]                           invokeRestart("muffleMessage")
[17:40:50.246]                       }
[17:40:50.246]                       else if (inherits(cond, "warning")) {
[17:40:50.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.246]                         if (muffled) 
[17:40:50.246]                           invokeRestart("muffleWarning")
[17:40:50.246]                       }
[17:40:50.246]                       else if (inherits(cond, "condition")) {
[17:40:50.246]                         if (!is.null(pattern)) {
[17:40:50.246]                           computeRestarts <- base::computeRestarts
[17:40:50.246]                           grepl <- base::grepl
[17:40:50.246]                           restarts <- computeRestarts(cond)
[17:40:50.246]                           for (restart in restarts) {
[17:40:50.246]                             name <- restart$name
[17:40:50.246]                             if (is.null(name)) 
[17:40:50.246]                               next
[17:40:50.246]                             if (!grepl(pattern, name)) 
[17:40:50.246]                               next
[17:40:50.246]                             invokeRestart(restart)
[17:40:50.246]                             muffled <- TRUE
[17:40:50.246]                             break
[17:40:50.246]                           }
[17:40:50.246]                         }
[17:40:50.246]                       }
[17:40:50.246]                       invisible(muffled)
[17:40:50.246]                     }
[17:40:50.246]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.246]                   }
[17:40:50.246]                 }
[17:40:50.246]                 else {
[17:40:50.246]                   if (TRUE) {
[17:40:50.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.246]                     {
[17:40:50.246]                       inherits <- base::inherits
[17:40:50.246]                       invokeRestart <- base::invokeRestart
[17:40:50.246]                       is.null <- base::is.null
[17:40:50.246]                       muffled <- FALSE
[17:40:50.246]                       if (inherits(cond, "message")) {
[17:40:50.246]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.246]                         if (muffled) 
[17:40:50.246]                           invokeRestart("muffleMessage")
[17:40:50.246]                       }
[17:40:50.246]                       else if (inherits(cond, "warning")) {
[17:40:50.246]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.246]                         if (muffled) 
[17:40:50.246]                           invokeRestart("muffleWarning")
[17:40:50.246]                       }
[17:40:50.246]                       else if (inherits(cond, "condition")) {
[17:40:50.246]                         if (!is.null(pattern)) {
[17:40:50.246]                           computeRestarts <- base::computeRestarts
[17:40:50.246]                           grepl <- base::grepl
[17:40:50.246]                           restarts <- computeRestarts(cond)
[17:40:50.246]                           for (restart in restarts) {
[17:40:50.246]                             name <- restart$name
[17:40:50.246]                             if (is.null(name)) 
[17:40:50.246]                               next
[17:40:50.246]                             if (!grepl(pattern, name)) 
[17:40:50.246]                               next
[17:40:50.246]                             invokeRestart(restart)
[17:40:50.246]                             muffled <- TRUE
[17:40:50.246]                             break
[17:40:50.246]                           }
[17:40:50.246]                         }
[17:40:50.246]                       }
[17:40:50.246]                       invisible(muffled)
[17:40:50.246]                     }
[17:40:50.246]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.246]                   }
[17:40:50.246]                 }
[17:40:50.246]             }
[17:40:50.246]         }))
[17:40:50.246]     }, error = function(ex) {
[17:40:50.246]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:50.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.246]                 ...future.rng), started = ...future.startTime, 
[17:40:50.246]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:50.246]             version = "1.8"), class = "FutureResult")
[17:40:50.246]     }, finally = {
[17:40:50.246]         if (!identical(...future.workdir, getwd())) 
[17:40:50.246]             setwd(...future.workdir)
[17:40:50.246]         {
[17:40:50.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:50.246]                 ...future.oldOptions$nwarnings <- NULL
[17:40:50.246]             }
[17:40:50.246]             base::options(...future.oldOptions)
[17:40:50.246]             if (.Platform$OS.type == "windows") {
[17:40:50.246]                 old_names <- names(...future.oldEnvVars)
[17:40:50.246]                 envs <- base::Sys.getenv()
[17:40:50.246]                 names <- names(envs)
[17:40:50.246]                 common <- intersect(names, old_names)
[17:40:50.246]                 added <- setdiff(names, old_names)
[17:40:50.246]                 removed <- setdiff(old_names, names)
[17:40:50.246]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:50.246]                   envs[common]]
[17:40:50.246]                 NAMES <- toupper(changed)
[17:40:50.246]                 args <- list()
[17:40:50.246]                 for (kk in seq_along(NAMES)) {
[17:40:50.246]                   name <- changed[[kk]]
[17:40:50.246]                   NAME <- NAMES[[kk]]
[17:40:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.246]                     next
[17:40:50.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.246]                 }
[17:40:50.246]                 NAMES <- toupper(added)
[17:40:50.246]                 for (kk in seq_along(NAMES)) {
[17:40:50.246]                   name <- added[[kk]]
[17:40:50.246]                   NAME <- NAMES[[kk]]
[17:40:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.246]                     next
[17:40:50.246]                   args[[name]] <- ""
[17:40:50.246]                 }
[17:40:50.246]                 NAMES <- toupper(removed)
[17:40:50.246]                 for (kk in seq_along(NAMES)) {
[17:40:50.246]                   name <- removed[[kk]]
[17:40:50.246]                   NAME <- NAMES[[kk]]
[17:40:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.246]                     next
[17:40:50.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.246]                 }
[17:40:50.246]                 if (length(args) > 0) 
[17:40:50.246]                   base::do.call(base::Sys.setenv, args = args)
[17:40:50.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:50.246]             }
[17:40:50.246]             else {
[17:40:50.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:50.246]             }
[17:40:50.246]             {
[17:40:50.246]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:50.246]                   0L) {
[17:40:50.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:50.246]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:50.246]                   base::options(opts)
[17:40:50.246]                 }
[17:40:50.246]                 {
[17:40:50.246]                   {
[17:40:50.246]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:50.246]                     NULL
[17:40:50.246]                   }
[17:40:50.246]                   options(future.plan = NULL)
[17:40:50.246]                   if (is.na(NA_character_)) 
[17:40:50.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:50.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:50.246]                     .init = FALSE)
[17:40:50.246]                 }
[17:40:50.246]             }
[17:40:50.246]         }
[17:40:50.246]     })
[17:40:50.246]     if (TRUE) {
[17:40:50.246]         base::sink(type = "output", split = FALSE)
[17:40:50.246]         if (TRUE) {
[17:40:50.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:50.246]         }
[17:40:50.246]         else {
[17:40:50.246]             ...future.result["stdout"] <- base::list(NULL)
[17:40:50.246]         }
[17:40:50.246]         base::close(...future.stdout)
[17:40:50.246]         ...future.stdout <- NULL
[17:40:50.246]     }
[17:40:50.246]     ...future.result$conditions <- ...future.conditions
[17:40:50.246]     ...future.result$finished <- base::Sys.time()
[17:40:50.246]     ...future.result
[17:40:50.246] }
[17:40:50.249] MultisessionFuture started
[17:40:50.249] - Launch lazy future ... done
[17:40:50.249] run() for ‘MultisessionFuture’ ... done
[17:40:50.251] receiveMessageFromWorker() for ClusterFuture ...
[17:40:50.251] - Validating connection of MultisessionFuture
[17:40:50.251] - received message: FutureResult
[17:40:50.252] - Received FutureResult
[17:40:50.252] - Erased future from FutureRegistry
[17:40:50.252] result() for ClusterFuture ...
[17:40:50.252] - result already collected: FutureResult
[17:40:50.252] result() for ClusterFuture ... done
[17:40:50.252] signalConditions() ...
[17:40:50.252]  - include = ‘immediateCondition’
[17:40:50.252]  - exclude = 
[17:40:50.253]  - resignal = FALSE
[17:40:50.253]  - Number of conditions: 1
[17:40:50.253] signalConditions() ... done
[17:40:50.253] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:50.253] A MultisessionFuture was resolved (result was not collected)
[17:40:50.253] getGlobalsAndPackages() ...
[17:40:50.253] Searching for globals...
[17:40:50.254] - globals found: [2] ‘list’, ‘stop’
[17:40:50.254] Searching for globals ... DONE
[17:40:50.254] Resolving globals: FALSE
[17:40:50.254] 
[17:40:50.254] 
[17:40:50.254] getGlobalsAndPackages() ... DONE
[17:40:50.255] run() for ‘Future’ ...
[17:40:50.255] - state: ‘created’
[17:40:50.255] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:50.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:50.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:50.269]   - Field: ‘node’
[17:40:50.269]   - Field: ‘label’
[17:40:50.269]   - Field: ‘local’
[17:40:50.269]   - Field: ‘owner’
[17:40:50.269]   - Field: ‘envir’
[17:40:50.269]   - Field: ‘workers’
[17:40:50.270]   - Field: ‘packages’
[17:40:50.270]   - Field: ‘gc’
[17:40:50.270]   - Field: ‘conditions’
[17:40:50.270]   - Field: ‘persistent’
[17:40:50.270]   - Field: ‘expr’
[17:40:50.270]   - Field: ‘uuid’
[17:40:50.270]   - Field: ‘seed’
[17:40:50.270]   - Field: ‘version’
[17:40:50.270]   - Field: ‘result’
[17:40:50.270]   - Field: ‘asynchronous’
[17:40:50.270]   - Field: ‘calls’
[17:40:50.271]   - Field: ‘globals’
[17:40:50.271]   - Field: ‘stdout’
[17:40:50.271]   - Field: ‘earlySignal’
[17:40:50.271]   - Field: ‘lazy’
[17:40:50.271]   - Field: ‘state’
[17:40:50.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:50.271] - Launch lazy future ...
[17:40:50.271] Packages needed by the future expression (n = 0): <none>
[17:40:50.271] Packages needed by future strategies (n = 0): <none>
[17:40:50.272] {
[17:40:50.272]     {
[17:40:50.272]         {
[17:40:50.272]             ...future.startTime <- base::Sys.time()
[17:40:50.272]             {
[17:40:50.272]                 {
[17:40:50.272]                   {
[17:40:50.272]                     {
[17:40:50.272]                       base::local({
[17:40:50.272]                         has_future <- base::requireNamespace("future", 
[17:40:50.272]                           quietly = TRUE)
[17:40:50.272]                         if (has_future) {
[17:40:50.272]                           ns <- base::getNamespace("future")
[17:40:50.272]                           version <- ns[[".package"]][["version"]]
[17:40:50.272]                           if (is.null(version)) 
[17:40:50.272]                             version <- utils::packageVersion("future")
[17:40:50.272]                         }
[17:40:50.272]                         else {
[17:40:50.272]                           version <- NULL
[17:40:50.272]                         }
[17:40:50.272]                         if (!has_future || version < "1.8.0") {
[17:40:50.272]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:50.272]                             "", base::R.version$version.string), 
[17:40:50.272]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:50.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:50.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:50.272]                               "release", "version")], collapse = " "), 
[17:40:50.272]                             hostname = base::Sys.info()[["nodename"]])
[17:40:50.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:50.272]                             info)
[17:40:50.272]                           info <- base::paste(info, collapse = "; ")
[17:40:50.272]                           if (!has_future) {
[17:40:50.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:50.272]                               info)
[17:40:50.272]                           }
[17:40:50.272]                           else {
[17:40:50.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:50.272]                               info, version)
[17:40:50.272]                           }
[17:40:50.272]                           base::stop(msg)
[17:40:50.272]                         }
[17:40:50.272]                       })
[17:40:50.272]                     }
[17:40:50.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:50.272]                     base::options(mc.cores = 1L)
[17:40:50.272]                   }
[17:40:50.272]                   ...future.strategy.old <- future::plan("list")
[17:40:50.272]                   options(future.plan = NULL)
[17:40:50.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:50.272]                 }
[17:40:50.272]                 ...future.workdir <- getwd()
[17:40:50.272]             }
[17:40:50.272]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:50.272]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:50.272]         }
[17:40:50.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:50.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:50.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:50.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:50.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:50.272]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:50.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:50.272]             base::names(...future.oldOptions))
[17:40:50.272]     }
[17:40:50.272]     if (FALSE) {
[17:40:50.272]     }
[17:40:50.272]     else {
[17:40:50.272]         if (TRUE) {
[17:40:50.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:50.272]                 open = "w")
[17:40:50.272]         }
[17:40:50.272]         else {
[17:40:50.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:50.272]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:50.272]         }
[17:40:50.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:50.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:50.272]             base::sink(type = "output", split = FALSE)
[17:40:50.272]             base::close(...future.stdout)
[17:40:50.272]         }, add = TRUE)
[17:40:50.272]     }
[17:40:50.272]     ...future.frame <- base::sys.nframe()
[17:40:50.272]     ...future.conditions <- base::list()
[17:40:50.272]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:50.272]     if (FALSE) {
[17:40:50.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:50.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:50.272]     }
[17:40:50.272]     ...future.result <- base::tryCatch({
[17:40:50.272]         base::withCallingHandlers({
[17:40:50.272]             ...future.value <- base::withVisible(base::local({
[17:40:50.272]                 ...future.makeSendCondition <- base::local({
[17:40:50.272]                   sendCondition <- NULL
[17:40:50.272]                   function(frame = 1L) {
[17:40:50.272]                     if (is.function(sendCondition)) 
[17:40:50.272]                       return(sendCondition)
[17:40:50.272]                     ns <- getNamespace("parallel")
[17:40:50.272]                     if (exists("sendData", mode = "function", 
[17:40:50.272]                       envir = ns)) {
[17:40:50.272]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:50.272]                         envir = ns)
[17:40:50.272]                       envir <- sys.frame(frame)
[17:40:50.272]                       master <- NULL
[17:40:50.272]                       while (!identical(envir, .GlobalEnv) && 
[17:40:50.272]                         !identical(envir, emptyenv())) {
[17:40:50.272]                         if (exists("master", mode = "list", envir = envir, 
[17:40:50.272]                           inherits = FALSE)) {
[17:40:50.272]                           master <- get("master", mode = "list", 
[17:40:50.272]                             envir = envir, inherits = FALSE)
[17:40:50.272]                           if (inherits(master, c("SOCKnode", 
[17:40:50.272]                             "SOCK0node"))) {
[17:40:50.272]                             sendCondition <<- function(cond) {
[17:40:50.272]                               data <- list(type = "VALUE", value = cond, 
[17:40:50.272]                                 success = TRUE)
[17:40:50.272]                               parallel_sendData(master, data)
[17:40:50.272]                             }
[17:40:50.272]                             return(sendCondition)
[17:40:50.272]                           }
[17:40:50.272]                         }
[17:40:50.272]                         frame <- frame + 1L
[17:40:50.272]                         envir <- sys.frame(frame)
[17:40:50.272]                       }
[17:40:50.272]                     }
[17:40:50.272]                     sendCondition <<- function(cond) NULL
[17:40:50.272]                   }
[17:40:50.272]                 })
[17:40:50.272]                 withCallingHandlers({
[17:40:50.272]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:50.272]                 }, immediateCondition = function(cond) {
[17:40:50.272]                   sendCondition <- ...future.makeSendCondition()
[17:40:50.272]                   sendCondition(cond)
[17:40:50.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.272]                   {
[17:40:50.272]                     inherits <- base::inherits
[17:40:50.272]                     invokeRestart <- base::invokeRestart
[17:40:50.272]                     is.null <- base::is.null
[17:40:50.272]                     muffled <- FALSE
[17:40:50.272]                     if (inherits(cond, "message")) {
[17:40:50.272]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:50.272]                       if (muffled) 
[17:40:50.272]                         invokeRestart("muffleMessage")
[17:40:50.272]                     }
[17:40:50.272]                     else if (inherits(cond, "warning")) {
[17:40:50.272]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:50.272]                       if (muffled) 
[17:40:50.272]                         invokeRestart("muffleWarning")
[17:40:50.272]                     }
[17:40:50.272]                     else if (inherits(cond, "condition")) {
[17:40:50.272]                       if (!is.null(pattern)) {
[17:40:50.272]                         computeRestarts <- base::computeRestarts
[17:40:50.272]                         grepl <- base::grepl
[17:40:50.272]                         restarts <- computeRestarts(cond)
[17:40:50.272]                         for (restart in restarts) {
[17:40:50.272]                           name <- restart$name
[17:40:50.272]                           if (is.null(name)) 
[17:40:50.272]                             next
[17:40:50.272]                           if (!grepl(pattern, name)) 
[17:40:50.272]                             next
[17:40:50.272]                           invokeRestart(restart)
[17:40:50.272]                           muffled <- TRUE
[17:40:50.272]                           break
[17:40:50.272]                         }
[17:40:50.272]                       }
[17:40:50.272]                     }
[17:40:50.272]                     invisible(muffled)
[17:40:50.272]                   }
[17:40:50.272]                   muffleCondition(cond)
[17:40:50.272]                 })
[17:40:50.272]             }))
[17:40:50.272]             future::FutureResult(value = ...future.value$value, 
[17:40:50.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.272]                   ...future.rng), globalenv = if (FALSE) 
[17:40:50.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:50.272]                     ...future.globalenv.names))
[17:40:50.272]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:50.272]         }, condition = base::local({
[17:40:50.272]             c <- base::c
[17:40:50.272]             inherits <- base::inherits
[17:40:50.272]             invokeRestart <- base::invokeRestart
[17:40:50.272]             length <- base::length
[17:40:50.272]             list <- base::list
[17:40:50.272]             seq.int <- base::seq.int
[17:40:50.272]             signalCondition <- base::signalCondition
[17:40:50.272]             sys.calls <- base::sys.calls
[17:40:50.272]             `[[` <- base::`[[`
[17:40:50.272]             `+` <- base::`+`
[17:40:50.272]             `<<-` <- base::`<<-`
[17:40:50.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:50.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:50.272]                   3L)]
[17:40:50.272]             }
[17:40:50.272]             function(cond) {
[17:40:50.272]                 is_error <- inherits(cond, "error")
[17:40:50.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:50.272]                   NULL)
[17:40:50.272]                 if (is_error) {
[17:40:50.272]                   sessionInformation <- function() {
[17:40:50.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:50.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:50.272]                       search = base::search(), system = base::Sys.info())
[17:40:50.272]                   }
[17:40:50.272]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:50.272]                     cond$call), session = sessionInformation(), 
[17:40:50.272]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:50.272]                   signalCondition(cond)
[17:40:50.272]                 }
[17:40:50.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:50.272]                 "immediateCondition"))) {
[17:40:50.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:50.272]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:50.272]                   if (TRUE && !signal) {
[17:40:50.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.272]                     {
[17:40:50.272]                       inherits <- base::inherits
[17:40:50.272]                       invokeRestart <- base::invokeRestart
[17:40:50.272]                       is.null <- base::is.null
[17:40:50.272]                       muffled <- FALSE
[17:40:50.272]                       if (inherits(cond, "message")) {
[17:40:50.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.272]                         if (muffled) 
[17:40:50.272]                           invokeRestart("muffleMessage")
[17:40:50.272]                       }
[17:40:50.272]                       else if (inherits(cond, "warning")) {
[17:40:50.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.272]                         if (muffled) 
[17:40:50.272]                           invokeRestart("muffleWarning")
[17:40:50.272]                       }
[17:40:50.272]                       else if (inherits(cond, "condition")) {
[17:40:50.272]                         if (!is.null(pattern)) {
[17:40:50.272]                           computeRestarts <- base::computeRestarts
[17:40:50.272]                           grepl <- base::grepl
[17:40:50.272]                           restarts <- computeRestarts(cond)
[17:40:50.272]                           for (restart in restarts) {
[17:40:50.272]                             name <- restart$name
[17:40:50.272]                             if (is.null(name)) 
[17:40:50.272]                               next
[17:40:50.272]                             if (!grepl(pattern, name)) 
[17:40:50.272]                               next
[17:40:50.272]                             invokeRestart(restart)
[17:40:50.272]                             muffled <- TRUE
[17:40:50.272]                             break
[17:40:50.272]                           }
[17:40:50.272]                         }
[17:40:50.272]                       }
[17:40:50.272]                       invisible(muffled)
[17:40:50.272]                     }
[17:40:50.272]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.272]                   }
[17:40:50.272]                 }
[17:40:50.272]                 else {
[17:40:50.272]                   if (TRUE) {
[17:40:50.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.272]                     {
[17:40:50.272]                       inherits <- base::inherits
[17:40:50.272]                       invokeRestart <- base::invokeRestart
[17:40:50.272]                       is.null <- base::is.null
[17:40:50.272]                       muffled <- FALSE
[17:40:50.272]                       if (inherits(cond, "message")) {
[17:40:50.272]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.272]                         if (muffled) 
[17:40:50.272]                           invokeRestart("muffleMessage")
[17:40:50.272]                       }
[17:40:50.272]                       else if (inherits(cond, "warning")) {
[17:40:50.272]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.272]                         if (muffled) 
[17:40:50.272]                           invokeRestart("muffleWarning")
[17:40:50.272]                       }
[17:40:50.272]                       else if (inherits(cond, "condition")) {
[17:40:50.272]                         if (!is.null(pattern)) {
[17:40:50.272]                           computeRestarts <- base::computeRestarts
[17:40:50.272]                           grepl <- base::grepl
[17:40:50.272]                           restarts <- computeRestarts(cond)
[17:40:50.272]                           for (restart in restarts) {
[17:40:50.272]                             name <- restart$name
[17:40:50.272]                             if (is.null(name)) 
[17:40:50.272]                               next
[17:40:50.272]                             if (!grepl(pattern, name)) 
[17:40:50.272]                               next
[17:40:50.272]                             invokeRestart(restart)
[17:40:50.272]                             muffled <- TRUE
[17:40:50.272]                             break
[17:40:50.272]                           }
[17:40:50.272]                         }
[17:40:50.272]                       }
[17:40:50.272]                       invisible(muffled)
[17:40:50.272]                     }
[17:40:50.272]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.272]                   }
[17:40:50.272]                 }
[17:40:50.272]             }
[17:40:50.272]         }))
[17:40:50.272]     }, error = function(ex) {
[17:40:50.272]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:50.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.272]                 ...future.rng), started = ...future.startTime, 
[17:40:50.272]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:50.272]             version = "1.8"), class = "FutureResult")
[17:40:50.272]     }, finally = {
[17:40:50.272]         if (!identical(...future.workdir, getwd())) 
[17:40:50.272]             setwd(...future.workdir)
[17:40:50.272]         {
[17:40:50.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:50.272]                 ...future.oldOptions$nwarnings <- NULL
[17:40:50.272]             }
[17:40:50.272]             base::options(...future.oldOptions)
[17:40:50.272]             if (.Platform$OS.type == "windows") {
[17:40:50.272]                 old_names <- names(...future.oldEnvVars)
[17:40:50.272]                 envs <- base::Sys.getenv()
[17:40:50.272]                 names <- names(envs)
[17:40:50.272]                 common <- intersect(names, old_names)
[17:40:50.272]                 added <- setdiff(names, old_names)
[17:40:50.272]                 removed <- setdiff(old_names, names)
[17:40:50.272]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:50.272]                   envs[common]]
[17:40:50.272]                 NAMES <- toupper(changed)
[17:40:50.272]                 args <- list()
[17:40:50.272]                 for (kk in seq_along(NAMES)) {
[17:40:50.272]                   name <- changed[[kk]]
[17:40:50.272]                   NAME <- NAMES[[kk]]
[17:40:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.272]                     next
[17:40:50.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.272]                 }
[17:40:50.272]                 NAMES <- toupper(added)
[17:40:50.272]                 for (kk in seq_along(NAMES)) {
[17:40:50.272]                   name <- added[[kk]]
[17:40:50.272]                   NAME <- NAMES[[kk]]
[17:40:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.272]                     next
[17:40:50.272]                   args[[name]] <- ""
[17:40:50.272]                 }
[17:40:50.272]                 NAMES <- toupper(removed)
[17:40:50.272]                 for (kk in seq_along(NAMES)) {
[17:40:50.272]                   name <- removed[[kk]]
[17:40:50.272]                   NAME <- NAMES[[kk]]
[17:40:50.272]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.272]                     next
[17:40:50.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.272]                 }
[17:40:50.272]                 if (length(args) > 0) 
[17:40:50.272]                   base::do.call(base::Sys.setenv, args = args)
[17:40:50.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:50.272]             }
[17:40:50.272]             else {
[17:40:50.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:50.272]             }
[17:40:50.272]             {
[17:40:50.272]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:50.272]                   0L) {
[17:40:50.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:50.272]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:50.272]                   base::options(opts)
[17:40:50.272]                 }
[17:40:50.272]                 {
[17:40:50.272]                   {
[17:40:50.272]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:50.272]                     NULL
[17:40:50.272]                   }
[17:40:50.272]                   options(future.plan = NULL)
[17:40:50.272]                   if (is.na(NA_character_)) 
[17:40:50.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:50.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:50.272]                     .init = FALSE)
[17:40:50.272]                 }
[17:40:50.272]             }
[17:40:50.272]         }
[17:40:50.272]     })
[17:40:50.272]     if (TRUE) {
[17:40:50.272]         base::sink(type = "output", split = FALSE)
[17:40:50.272]         if (TRUE) {
[17:40:50.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:50.272]         }
[17:40:50.272]         else {
[17:40:50.272]             ...future.result["stdout"] <- base::list(NULL)
[17:40:50.272]         }
[17:40:50.272]         base::close(...future.stdout)
[17:40:50.272]         ...future.stdout <- NULL
[17:40:50.272]     }
[17:40:50.272]     ...future.result$conditions <- ...future.conditions
[17:40:50.272]     ...future.result$finished <- base::Sys.time()
[17:40:50.272]     ...future.result
[17:40:50.272] }
[17:40:50.275] MultisessionFuture started
[17:40:50.275] - Launch lazy future ... done
[17:40:50.275] run() for ‘MultisessionFuture’ ... done
[17:40:50.277] receiveMessageFromWorker() for ClusterFuture ...
[17:40:50.277] - Validating connection of MultisessionFuture
[17:40:50.277] - received message: FutureResult
[17:40:50.278] - Received FutureResult
[17:40:50.278] - Erased future from FutureRegistry
[17:40:50.278] result() for ClusterFuture ...
[17:40:50.278] - result already collected: FutureResult
[17:40:50.278] result() for ClusterFuture ... done
[17:40:50.278] signalConditions() ...
[17:40:50.278]  - include = ‘immediateCondition’
[17:40:50.278]  - exclude = 
[17:40:50.278]  - resignal = FALSE
[17:40:50.278]  - Number of conditions: 1
[17:40:50.278] signalConditions() ... done
[17:40:50.279] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:50.279] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[17:40:50.279] getGlobalsAndPackages() ...
[17:40:50.279] Searching for globals...
[17:40:50.280] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:50.280] Searching for globals ... DONE
[17:40:50.280] Resolving globals: FALSE
[17:40:50.281] 
[17:40:50.281] 
[17:40:50.281] getGlobalsAndPackages() ... DONE
[17:40:50.281] run() for ‘Future’ ...
[17:40:50.281] - state: ‘created’
[17:40:50.283] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:50.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:50.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:50.297]   - Field: ‘node’
[17:40:50.297]   - Field: ‘label’
[17:40:50.297]   - Field: ‘local’
[17:40:50.297]   - Field: ‘owner’
[17:40:50.297]   - Field: ‘envir’
[17:40:50.298]   - Field: ‘workers’
[17:40:50.298]   - Field: ‘packages’
[17:40:50.298]   - Field: ‘gc’
[17:40:50.298]   - Field: ‘conditions’
[17:40:50.298]   - Field: ‘persistent’
[17:40:50.298]   - Field: ‘expr’
[17:40:50.298]   - Field: ‘uuid’
[17:40:50.298]   - Field: ‘seed’
[17:40:50.298]   - Field: ‘version’
[17:40:50.298]   - Field: ‘result’
[17:40:50.298]   - Field: ‘asynchronous’
[17:40:50.299]   - Field: ‘calls’
[17:40:50.299]   - Field: ‘globals’
[17:40:50.299]   - Field: ‘stdout’
[17:40:50.299]   - Field: ‘earlySignal’
[17:40:50.299]   - Field: ‘lazy’
[17:40:50.299]   - Field: ‘state’
[17:40:50.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:50.299] - Launch lazy future ...
[17:40:50.299] Packages needed by the future expression (n = 0): <none>
[17:40:50.300] Packages needed by future strategies (n = 0): <none>
[17:40:50.300] {
[17:40:50.300]     {
[17:40:50.300]         {
[17:40:50.300]             ...future.startTime <- base::Sys.time()
[17:40:50.300]             {
[17:40:50.300]                 {
[17:40:50.300]                   {
[17:40:50.300]                     {
[17:40:50.300]                       base::local({
[17:40:50.300]                         has_future <- base::requireNamespace("future", 
[17:40:50.300]                           quietly = TRUE)
[17:40:50.300]                         if (has_future) {
[17:40:50.300]                           ns <- base::getNamespace("future")
[17:40:50.300]                           version <- ns[[".package"]][["version"]]
[17:40:50.300]                           if (is.null(version)) 
[17:40:50.300]                             version <- utils::packageVersion("future")
[17:40:50.300]                         }
[17:40:50.300]                         else {
[17:40:50.300]                           version <- NULL
[17:40:50.300]                         }
[17:40:50.300]                         if (!has_future || version < "1.8.0") {
[17:40:50.300]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:50.300]                             "", base::R.version$version.string), 
[17:40:50.300]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:50.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:50.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:50.300]                               "release", "version")], collapse = " "), 
[17:40:50.300]                             hostname = base::Sys.info()[["nodename"]])
[17:40:50.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:50.300]                             info)
[17:40:50.300]                           info <- base::paste(info, collapse = "; ")
[17:40:50.300]                           if (!has_future) {
[17:40:50.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:50.300]                               info)
[17:40:50.300]                           }
[17:40:50.300]                           else {
[17:40:50.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:50.300]                               info, version)
[17:40:50.300]                           }
[17:40:50.300]                           base::stop(msg)
[17:40:50.300]                         }
[17:40:50.300]                       })
[17:40:50.300]                     }
[17:40:50.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:50.300]                     base::options(mc.cores = 1L)
[17:40:50.300]                   }
[17:40:50.300]                   ...future.strategy.old <- future::plan("list")
[17:40:50.300]                   options(future.plan = NULL)
[17:40:50.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:50.300]                 }
[17:40:50.300]                 ...future.workdir <- getwd()
[17:40:50.300]             }
[17:40:50.300]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:50.300]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:50.300]         }
[17:40:50.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:50.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:50.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:50.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:50.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:50.300]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:50.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:50.300]             base::names(...future.oldOptions))
[17:40:50.300]     }
[17:40:50.300]     if (FALSE) {
[17:40:50.300]     }
[17:40:50.300]     else {
[17:40:50.300]         if (TRUE) {
[17:40:50.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:50.300]                 open = "w")
[17:40:50.300]         }
[17:40:50.300]         else {
[17:40:50.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:50.300]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:50.300]         }
[17:40:50.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:50.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:50.300]             base::sink(type = "output", split = FALSE)
[17:40:50.300]             base::close(...future.stdout)
[17:40:50.300]         }, add = TRUE)
[17:40:50.300]     }
[17:40:50.300]     ...future.frame <- base::sys.nframe()
[17:40:50.300]     ...future.conditions <- base::list()
[17:40:50.300]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:50.300]     if (FALSE) {
[17:40:50.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:50.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:50.300]     }
[17:40:50.300]     ...future.result <- base::tryCatch({
[17:40:50.300]         base::withCallingHandlers({
[17:40:50.300]             ...future.value <- base::withVisible(base::local({
[17:40:50.300]                 ...future.makeSendCondition <- base::local({
[17:40:50.300]                   sendCondition <- NULL
[17:40:50.300]                   function(frame = 1L) {
[17:40:50.300]                     if (is.function(sendCondition)) 
[17:40:50.300]                       return(sendCondition)
[17:40:50.300]                     ns <- getNamespace("parallel")
[17:40:50.300]                     if (exists("sendData", mode = "function", 
[17:40:50.300]                       envir = ns)) {
[17:40:50.300]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:50.300]                         envir = ns)
[17:40:50.300]                       envir <- sys.frame(frame)
[17:40:50.300]                       master <- NULL
[17:40:50.300]                       while (!identical(envir, .GlobalEnv) && 
[17:40:50.300]                         !identical(envir, emptyenv())) {
[17:40:50.300]                         if (exists("master", mode = "list", envir = envir, 
[17:40:50.300]                           inherits = FALSE)) {
[17:40:50.300]                           master <- get("master", mode = "list", 
[17:40:50.300]                             envir = envir, inherits = FALSE)
[17:40:50.300]                           if (inherits(master, c("SOCKnode", 
[17:40:50.300]                             "SOCK0node"))) {
[17:40:50.300]                             sendCondition <<- function(cond) {
[17:40:50.300]                               data <- list(type = "VALUE", value = cond, 
[17:40:50.300]                                 success = TRUE)
[17:40:50.300]                               parallel_sendData(master, data)
[17:40:50.300]                             }
[17:40:50.300]                             return(sendCondition)
[17:40:50.300]                           }
[17:40:50.300]                         }
[17:40:50.300]                         frame <- frame + 1L
[17:40:50.300]                         envir <- sys.frame(frame)
[17:40:50.300]                       }
[17:40:50.300]                     }
[17:40:50.300]                     sendCondition <<- function(cond) NULL
[17:40:50.300]                   }
[17:40:50.300]                 })
[17:40:50.300]                 withCallingHandlers({
[17:40:50.300]                   {
[17:40:50.300]                     Sys.sleep(0.5)
[17:40:50.300]                     list(a = 1, b = 42L)
[17:40:50.300]                   }
[17:40:50.300]                 }, immediateCondition = function(cond) {
[17:40:50.300]                   sendCondition <- ...future.makeSendCondition()
[17:40:50.300]                   sendCondition(cond)
[17:40:50.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.300]                   {
[17:40:50.300]                     inherits <- base::inherits
[17:40:50.300]                     invokeRestart <- base::invokeRestart
[17:40:50.300]                     is.null <- base::is.null
[17:40:50.300]                     muffled <- FALSE
[17:40:50.300]                     if (inherits(cond, "message")) {
[17:40:50.300]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:50.300]                       if (muffled) 
[17:40:50.300]                         invokeRestart("muffleMessage")
[17:40:50.300]                     }
[17:40:50.300]                     else if (inherits(cond, "warning")) {
[17:40:50.300]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:50.300]                       if (muffled) 
[17:40:50.300]                         invokeRestart("muffleWarning")
[17:40:50.300]                     }
[17:40:50.300]                     else if (inherits(cond, "condition")) {
[17:40:50.300]                       if (!is.null(pattern)) {
[17:40:50.300]                         computeRestarts <- base::computeRestarts
[17:40:50.300]                         grepl <- base::grepl
[17:40:50.300]                         restarts <- computeRestarts(cond)
[17:40:50.300]                         for (restart in restarts) {
[17:40:50.300]                           name <- restart$name
[17:40:50.300]                           if (is.null(name)) 
[17:40:50.300]                             next
[17:40:50.300]                           if (!grepl(pattern, name)) 
[17:40:50.300]                             next
[17:40:50.300]                           invokeRestart(restart)
[17:40:50.300]                           muffled <- TRUE
[17:40:50.300]                           break
[17:40:50.300]                         }
[17:40:50.300]                       }
[17:40:50.300]                     }
[17:40:50.300]                     invisible(muffled)
[17:40:50.300]                   }
[17:40:50.300]                   muffleCondition(cond)
[17:40:50.300]                 })
[17:40:50.300]             }))
[17:40:50.300]             future::FutureResult(value = ...future.value$value, 
[17:40:50.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.300]                   ...future.rng), globalenv = if (FALSE) 
[17:40:50.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:50.300]                     ...future.globalenv.names))
[17:40:50.300]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:50.300]         }, condition = base::local({
[17:40:50.300]             c <- base::c
[17:40:50.300]             inherits <- base::inherits
[17:40:50.300]             invokeRestart <- base::invokeRestart
[17:40:50.300]             length <- base::length
[17:40:50.300]             list <- base::list
[17:40:50.300]             seq.int <- base::seq.int
[17:40:50.300]             signalCondition <- base::signalCondition
[17:40:50.300]             sys.calls <- base::sys.calls
[17:40:50.300]             `[[` <- base::`[[`
[17:40:50.300]             `+` <- base::`+`
[17:40:50.300]             `<<-` <- base::`<<-`
[17:40:50.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:50.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:50.300]                   3L)]
[17:40:50.300]             }
[17:40:50.300]             function(cond) {
[17:40:50.300]                 is_error <- inherits(cond, "error")
[17:40:50.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:50.300]                   NULL)
[17:40:50.300]                 if (is_error) {
[17:40:50.300]                   sessionInformation <- function() {
[17:40:50.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:50.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:50.300]                       search = base::search(), system = base::Sys.info())
[17:40:50.300]                   }
[17:40:50.300]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:50.300]                     cond$call), session = sessionInformation(), 
[17:40:50.300]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:50.300]                   signalCondition(cond)
[17:40:50.300]                 }
[17:40:50.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:50.300]                 "immediateCondition"))) {
[17:40:50.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:50.300]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:50.300]                   if (TRUE && !signal) {
[17:40:50.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.300]                     {
[17:40:50.300]                       inherits <- base::inherits
[17:40:50.300]                       invokeRestart <- base::invokeRestart
[17:40:50.300]                       is.null <- base::is.null
[17:40:50.300]                       muffled <- FALSE
[17:40:50.300]                       if (inherits(cond, "message")) {
[17:40:50.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.300]                         if (muffled) 
[17:40:50.300]                           invokeRestart("muffleMessage")
[17:40:50.300]                       }
[17:40:50.300]                       else if (inherits(cond, "warning")) {
[17:40:50.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.300]                         if (muffled) 
[17:40:50.300]                           invokeRestart("muffleWarning")
[17:40:50.300]                       }
[17:40:50.300]                       else if (inherits(cond, "condition")) {
[17:40:50.300]                         if (!is.null(pattern)) {
[17:40:50.300]                           computeRestarts <- base::computeRestarts
[17:40:50.300]                           grepl <- base::grepl
[17:40:50.300]                           restarts <- computeRestarts(cond)
[17:40:50.300]                           for (restart in restarts) {
[17:40:50.300]                             name <- restart$name
[17:40:50.300]                             if (is.null(name)) 
[17:40:50.300]                               next
[17:40:50.300]                             if (!grepl(pattern, name)) 
[17:40:50.300]                               next
[17:40:50.300]                             invokeRestart(restart)
[17:40:50.300]                             muffled <- TRUE
[17:40:50.300]                             break
[17:40:50.300]                           }
[17:40:50.300]                         }
[17:40:50.300]                       }
[17:40:50.300]                       invisible(muffled)
[17:40:50.300]                     }
[17:40:50.300]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.300]                   }
[17:40:50.300]                 }
[17:40:50.300]                 else {
[17:40:50.300]                   if (TRUE) {
[17:40:50.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.300]                     {
[17:40:50.300]                       inherits <- base::inherits
[17:40:50.300]                       invokeRestart <- base::invokeRestart
[17:40:50.300]                       is.null <- base::is.null
[17:40:50.300]                       muffled <- FALSE
[17:40:50.300]                       if (inherits(cond, "message")) {
[17:40:50.300]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.300]                         if (muffled) 
[17:40:50.300]                           invokeRestart("muffleMessage")
[17:40:50.300]                       }
[17:40:50.300]                       else if (inherits(cond, "warning")) {
[17:40:50.300]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.300]                         if (muffled) 
[17:40:50.300]                           invokeRestart("muffleWarning")
[17:40:50.300]                       }
[17:40:50.300]                       else if (inherits(cond, "condition")) {
[17:40:50.300]                         if (!is.null(pattern)) {
[17:40:50.300]                           computeRestarts <- base::computeRestarts
[17:40:50.300]                           grepl <- base::grepl
[17:40:50.300]                           restarts <- computeRestarts(cond)
[17:40:50.300]                           for (restart in restarts) {
[17:40:50.300]                             name <- restart$name
[17:40:50.300]                             if (is.null(name)) 
[17:40:50.300]                               next
[17:40:50.300]                             if (!grepl(pattern, name)) 
[17:40:50.300]                               next
[17:40:50.300]                             invokeRestart(restart)
[17:40:50.300]                             muffled <- TRUE
[17:40:50.300]                             break
[17:40:50.300]                           }
[17:40:50.300]                         }
[17:40:50.300]                       }
[17:40:50.300]                       invisible(muffled)
[17:40:50.300]                     }
[17:40:50.300]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.300]                   }
[17:40:50.300]                 }
[17:40:50.300]             }
[17:40:50.300]         }))
[17:40:50.300]     }, error = function(ex) {
[17:40:50.300]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:50.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.300]                 ...future.rng), started = ...future.startTime, 
[17:40:50.300]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:50.300]             version = "1.8"), class = "FutureResult")
[17:40:50.300]     }, finally = {
[17:40:50.300]         if (!identical(...future.workdir, getwd())) 
[17:40:50.300]             setwd(...future.workdir)
[17:40:50.300]         {
[17:40:50.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:50.300]                 ...future.oldOptions$nwarnings <- NULL
[17:40:50.300]             }
[17:40:50.300]             base::options(...future.oldOptions)
[17:40:50.300]             if (.Platform$OS.type == "windows") {
[17:40:50.300]                 old_names <- names(...future.oldEnvVars)
[17:40:50.300]                 envs <- base::Sys.getenv()
[17:40:50.300]                 names <- names(envs)
[17:40:50.300]                 common <- intersect(names, old_names)
[17:40:50.300]                 added <- setdiff(names, old_names)
[17:40:50.300]                 removed <- setdiff(old_names, names)
[17:40:50.300]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:50.300]                   envs[common]]
[17:40:50.300]                 NAMES <- toupper(changed)
[17:40:50.300]                 args <- list()
[17:40:50.300]                 for (kk in seq_along(NAMES)) {
[17:40:50.300]                   name <- changed[[kk]]
[17:40:50.300]                   NAME <- NAMES[[kk]]
[17:40:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.300]                     next
[17:40:50.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.300]                 }
[17:40:50.300]                 NAMES <- toupper(added)
[17:40:50.300]                 for (kk in seq_along(NAMES)) {
[17:40:50.300]                   name <- added[[kk]]
[17:40:50.300]                   NAME <- NAMES[[kk]]
[17:40:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.300]                     next
[17:40:50.300]                   args[[name]] <- ""
[17:40:50.300]                 }
[17:40:50.300]                 NAMES <- toupper(removed)
[17:40:50.300]                 for (kk in seq_along(NAMES)) {
[17:40:50.300]                   name <- removed[[kk]]
[17:40:50.300]                   NAME <- NAMES[[kk]]
[17:40:50.300]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.300]                     next
[17:40:50.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.300]                 }
[17:40:50.300]                 if (length(args) > 0) 
[17:40:50.300]                   base::do.call(base::Sys.setenv, args = args)
[17:40:50.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:50.300]             }
[17:40:50.300]             else {
[17:40:50.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:50.300]             }
[17:40:50.300]             {
[17:40:50.300]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:50.300]                   0L) {
[17:40:50.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:50.300]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:50.300]                   base::options(opts)
[17:40:50.300]                 }
[17:40:50.300]                 {
[17:40:50.300]                   {
[17:40:50.300]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:50.300]                     NULL
[17:40:50.300]                   }
[17:40:50.300]                   options(future.plan = NULL)
[17:40:50.300]                   if (is.na(NA_character_)) 
[17:40:50.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:50.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:50.300]                     .init = FALSE)
[17:40:50.300]                 }
[17:40:50.300]             }
[17:40:50.300]         }
[17:40:50.300]     })
[17:40:50.300]     if (TRUE) {
[17:40:50.300]         base::sink(type = "output", split = FALSE)
[17:40:50.300]         if (TRUE) {
[17:40:50.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:50.300]         }
[17:40:50.300]         else {
[17:40:50.300]             ...future.result["stdout"] <- base::list(NULL)
[17:40:50.300]         }
[17:40:50.300]         base::close(...future.stdout)
[17:40:50.300]         ...future.stdout <- NULL
[17:40:50.300]     }
[17:40:50.300]     ...future.result$conditions <- ...future.conditions
[17:40:50.300]     ...future.result$finished <- base::Sys.time()
[17:40:50.300]     ...future.result
[17:40:50.300] }
[17:40:50.303] MultisessionFuture started
[17:40:50.303] - Launch lazy future ... done
[17:40:50.303] run() for ‘MultisessionFuture’ ... done
[17:40:50.806] receiveMessageFromWorker() for ClusterFuture ...
[17:40:50.806] - Validating connection of MultisessionFuture
[17:40:50.806] - received message: FutureResult
[17:40:50.806] - Received FutureResult
[17:40:50.806] - Erased future from FutureRegistry
[17:40:50.806] result() for ClusterFuture ...
[17:40:50.806] - result already collected: FutureResult
[17:40:50.807] result() for ClusterFuture ... done
[17:40:50.807] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:50.807] A MultisessionFuture was resolved (result was not collected)
[17:40:50.807] getGlobalsAndPackages() ...
[17:40:50.807] Searching for globals...
[17:40:50.808] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:50.808] Searching for globals ... DONE
[17:40:50.808] Resolving globals: FALSE
[17:40:50.809] 
[17:40:50.809] 
[17:40:50.809] getGlobalsAndPackages() ... DONE
[17:40:50.809] run() for ‘Future’ ...
[17:40:50.809] - state: ‘created’
[17:40:50.809] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:50.823] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:50.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:50.824]   - Field: ‘node’
[17:40:50.824]   - Field: ‘label’
[17:40:50.824]   - Field: ‘local’
[17:40:50.824]   - Field: ‘owner’
[17:40:50.824]   - Field: ‘envir’
[17:40:50.824]   - Field: ‘workers’
[17:40:50.824]   - Field: ‘packages’
[17:40:50.824]   - Field: ‘gc’
[17:40:50.824]   - Field: ‘conditions’
[17:40:50.824]   - Field: ‘persistent’
[17:40:50.825]   - Field: ‘expr’
[17:40:50.825]   - Field: ‘uuid’
[17:40:50.825]   - Field: ‘seed’
[17:40:50.825]   - Field: ‘version’
[17:40:50.825]   - Field: ‘result’
[17:40:50.825]   - Field: ‘asynchronous’
[17:40:50.825]   - Field: ‘calls’
[17:40:50.825]   - Field: ‘globals’
[17:40:50.825]   - Field: ‘stdout’
[17:40:50.825]   - Field: ‘earlySignal’
[17:40:50.825]   - Field: ‘lazy’
[17:40:50.826]   - Field: ‘state’
[17:40:50.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:50.826] - Launch lazy future ...
[17:40:50.826] Packages needed by the future expression (n = 0): <none>
[17:40:50.826] Packages needed by future strategies (n = 0): <none>
[17:40:50.827] {
[17:40:50.827]     {
[17:40:50.827]         {
[17:40:50.827]             ...future.startTime <- base::Sys.time()
[17:40:50.827]             {
[17:40:50.827]                 {
[17:40:50.827]                   {
[17:40:50.827]                     {
[17:40:50.827]                       base::local({
[17:40:50.827]                         has_future <- base::requireNamespace("future", 
[17:40:50.827]                           quietly = TRUE)
[17:40:50.827]                         if (has_future) {
[17:40:50.827]                           ns <- base::getNamespace("future")
[17:40:50.827]                           version <- ns[[".package"]][["version"]]
[17:40:50.827]                           if (is.null(version)) 
[17:40:50.827]                             version <- utils::packageVersion("future")
[17:40:50.827]                         }
[17:40:50.827]                         else {
[17:40:50.827]                           version <- NULL
[17:40:50.827]                         }
[17:40:50.827]                         if (!has_future || version < "1.8.0") {
[17:40:50.827]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:50.827]                             "", base::R.version$version.string), 
[17:40:50.827]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:50.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:50.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:50.827]                               "release", "version")], collapse = " "), 
[17:40:50.827]                             hostname = base::Sys.info()[["nodename"]])
[17:40:50.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:50.827]                             info)
[17:40:50.827]                           info <- base::paste(info, collapse = "; ")
[17:40:50.827]                           if (!has_future) {
[17:40:50.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:50.827]                               info)
[17:40:50.827]                           }
[17:40:50.827]                           else {
[17:40:50.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:50.827]                               info, version)
[17:40:50.827]                           }
[17:40:50.827]                           base::stop(msg)
[17:40:50.827]                         }
[17:40:50.827]                       })
[17:40:50.827]                     }
[17:40:50.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:50.827]                     base::options(mc.cores = 1L)
[17:40:50.827]                   }
[17:40:50.827]                   ...future.strategy.old <- future::plan("list")
[17:40:50.827]                   options(future.plan = NULL)
[17:40:50.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:50.827]                 }
[17:40:50.827]                 ...future.workdir <- getwd()
[17:40:50.827]             }
[17:40:50.827]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:50.827]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:50.827]         }
[17:40:50.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:50.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:50.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:50.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:50.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:50.827]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:50.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:50.827]             base::names(...future.oldOptions))
[17:40:50.827]     }
[17:40:50.827]     if (FALSE) {
[17:40:50.827]     }
[17:40:50.827]     else {
[17:40:50.827]         if (TRUE) {
[17:40:50.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:50.827]                 open = "w")
[17:40:50.827]         }
[17:40:50.827]         else {
[17:40:50.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:50.827]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:50.827]         }
[17:40:50.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:50.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:50.827]             base::sink(type = "output", split = FALSE)
[17:40:50.827]             base::close(...future.stdout)
[17:40:50.827]         }, add = TRUE)
[17:40:50.827]     }
[17:40:50.827]     ...future.frame <- base::sys.nframe()
[17:40:50.827]     ...future.conditions <- base::list()
[17:40:50.827]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:50.827]     if (FALSE) {
[17:40:50.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:50.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:50.827]     }
[17:40:50.827]     ...future.result <- base::tryCatch({
[17:40:50.827]         base::withCallingHandlers({
[17:40:50.827]             ...future.value <- base::withVisible(base::local({
[17:40:50.827]                 ...future.makeSendCondition <- base::local({
[17:40:50.827]                   sendCondition <- NULL
[17:40:50.827]                   function(frame = 1L) {
[17:40:50.827]                     if (is.function(sendCondition)) 
[17:40:50.827]                       return(sendCondition)
[17:40:50.827]                     ns <- getNamespace("parallel")
[17:40:50.827]                     if (exists("sendData", mode = "function", 
[17:40:50.827]                       envir = ns)) {
[17:40:50.827]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:50.827]                         envir = ns)
[17:40:50.827]                       envir <- sys.frame(frame)
[17:40:50.827]                       master <- NULL
[17:40:50.827]                       while (!identical(envir, .GlobalEnv) && 
[17:40:50.827]                         !identical(envir, emptyenv())) {
[17:40:50.827]                         if (exists("master", mode = "list", envir = envir, 
[17:40:50.827]                           inherits = FALSE)) {
[17:40:50.827]                           master <- get("master", mode = "list", 
[17:40:50.827]                             envir = envir, inherits = FALSE)
[17:40:50.827]                           if (inherits(master, c("SOCKnode", 
[17:40:50.827]                             "SOCK0node"))) {
[17:40:50.827]                             sendCondition <<- function(cond) {
[17:40:50.827]                               data <- list(type = "VALUE", value = cond, 
[17:40:50.827]                                 success = TRUE)
[17:40:50.827]                               parallel_sendData(master, data)
[17:40:50.827]                             }
[17:40:50.827]                             return(sendCondition)
[17:40:50.827]                           }
[17:40:50.827]                         }
[17:40:50.827]                         frame <- frame + 1L
[17:40:50.827]                         envir <- sys.frame(frame)
[17:40:50.827]                       }
[17:40:50.827]                     }
[17:40:50.827]                     sendCondition <<- function(cond) NULL
[17:40:50.827]                   }
[17:40:50.827]                 })
[17:40:50.827]                 withCallingHandlers({
[17:40:50.827]                   {
[17:40:50.827]                     Sys.sleep(0.5)
[17:40:50.827]                     list(a = 1, b = 42L)
[17:40:50.827]                   }
[17:40:50.827]                 }, immediateCondition = function(cond) {
[17:40:50.827]                   sendCondition <- ...future.makeSendCondition()
[17:40:50.827]                   sendCondition(cond)
[17:40:50.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.827]                   {
[17:40:50.827]                     inherits <- base::inherits
[17:40:50.827]                     invokeRestart <- base::invokeRestart
[17:40:50.827]                     is.null <- base::is.null
[17:40:50.827]                     muffled <- FALSE
[17:40:50.827]                     if (inherits(cond, "message")) {
[17:40:50.827]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:50.827]                       if (muffled) 
[17:40:50.827]                         invokeRestart("muffleMessage")
[17:40:50.827]                     }
[17:40:50.827]                     else if (inherits(cond, "warning")) {
[17:40:50.827]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:50.827]                       if (muffled) 
[17:40:50.827]                         invokeRestart("muffleWarning")
[17:40:50.827]                     }
[17:40:50.827]                     else if (inherits(cond, "condition")) {
[17:40:50.827]                       if (!is.null(pattern)) {
[17:40:50.827]                         computeRestarts <- base::computeRestarts
[17:40:50.827]                         grepl <- base::grepl
[17:40:50.827]                         restarts <- computeRestarts(cond)
[17:40:50.827]                         for (restart in restarts) {
[17:40:50.827]                           name <- restart$name
[17:40:50.827]                           if (is.null(name)) 
[17:40:50.827]                             next
[17:40:50.827]                           if (!grepl(pattern, name)) 
[17:40:50.827]                             next
[17:40:50.827]                           invokeRestart(restart)
[17:40:50.827]                           muffled <- TRUE
[17:40:50.827]                           break
[17:40:50.827]                         }
[17:40:50.827]                       }
[17:40:50.827]                     }
[17:40:50.827]                     invisible(muffled)
[17:40:50.827]                   }
[17:40:50.827]                   muffleCondition(cond)
[17:40:50.827]                 })
[17:40:50.827]             }))
[17:40:50.827]             future::FutureResult(value = ...future.value$value, 
[17:40:50.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.827]                   ...future.rng), globalenv = if (FALSE) 
[17:40:50.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:50.827]                     ...future.globalenv.names))
[17:40:50.827]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:50.827]         }, condition = base::local({
[17:40:50.827]             c <- base::c
[17:40:50.827]             inherits <- base::inherits
[17:40:50.827]             invokeRestart <- base::invokeRestart
[17:40:50.827]             length <- base::length
[17:40:50.827]             list <- base::list
[17:40:50.827]             seq.int <- base::seq.int
[17:40:50.827]             signalCondition <- base::signalCondition
[17:40:50.827]             sys.calls <- base::sys.calls
[17:40:50.827]             `[[` <- base::`[[`
[17:40:50.827]             `+` <- base::`+`
[17:40:50.827]             `<<-` <- base::`<<-`
[17:40:50.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:50.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:50.827]                   3L)]
[17:40:50.827]             }
[17:40:50.827]             function(cond) {
[17:40:50.827]                 is_error <- inherits(cond, "error")
[17:40:50.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:50.827]                   NULL)
[17:40:50.827]                 if (is_error) {
[17:40:50.827]                   sessionInformation <- function() {
[17:40:50.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:50.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:50.827]                       search = base::search(), system = base::Sys.info())
[17:40:50.827]                   }
[17:40:50.827]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:50.827]                     cond$call), session = sessionInformation(), 
[17:40:50.827]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:50.827]                   signalCondition(cond)
[17:40:50.827]                 }
[17:40:50.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:50.827]                 "immediateCondition"))) {
[17:40:50.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:50.827]                   ...future.conditions[[length(...future.conditions) + 
[17:40:50.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:50.827]                   if (TRUE && !signal) {
[17:40:50.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.827]                     {
[17:40:50.827]                       inherits <- base::inherits
[17:40:50.827]                       invokeRestart <- base::invokeRestart
[17:40:50.827]                       is.null <- base::is.null
[17:40:50.827]                       muffled <- FALSE
[17:40:50.827]                       if (inherits(cond, "message")) {
[17:40:50.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.827]                         if (muffled) 
[17:40:50.827]                           invokeRestart("muffleMessage")
[17:40:50.827]                       }
[17:40:50.827]                       else if (inherits(cond, "warning")) {
[17:40:50.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.827]                         if (muffled) 
[17:40:50.827]                           invokeRestart("muffleWarning")
[17:40:50.827]                       }
[17:40:50.827]                       else if (inherits(cond, "condition")) {
[17:40:50.827]                         if (!is.null(pattern)) {
[17:40:50.827]                           computeRestarts <- base::computeRestarts
[17:40:50.827]                           grepl <- base::grepl
[17:40:50.827]                           restarts <- computeRestarts(cond)
[17:40:50.827]                           for (restart in restarts) {
[17:40:50.827]                             name <- restart$name
[17:40:50.827]                             if (is.null(name)) 
[17:40:50.827]                               next
[17:40:50.827]                             if (!grepl(pattern, name)) 
[17:40:50.827]                               next
[17:40:50.827]                             invokeRestart(restart)
[17:40:50.827]                             muffled <- TRUE
[17:40:50.827]                             break
[17:40:50.827]                           }
[17:40:50.827]                         }
[17:40:50.827]                       }
[17:40:50.827]                       invisible(muffled)
[17:40:50.827]                     }
[17:40:50.827]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.827]                   }
[17:40:50.827]                 }
[17:40:50.827]                 else {
[17:40:50.827]                   if (TRUE) {
[17:40:50.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:50.827]                     {
[17:40:50.827]                       inherits <- base::inherits
[17:40:50.827]                       invokeRestart <- base::invokeRestart
[17:40:50.827]                       is.null <- base::is.null
[17:40:50.827]                       muffled <- FALSE
[17:40:50.827]                       if (inherits(cond, "message")) {
[17:40:50.827]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:50.827]                         if (muffled) 
[17:40:50.827]                           invokeRestart("muffleMessage")
[17:40:50.827]                       }
[17:40:50.827]                       else if (inherits(cond, "warning")) {
[17:40:50.827]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:50.827]                         if (muffled) 
[17:40:50.827]                           invokeRestart("muffleWarning")
[17:40:50.827]                       }
[17:40:50.827]                       else if (inherits(cond, "condition")) {
[17:40:50.827]                         if (!is.null(pattern)) {
[17:40:50.827]                           computeRestarts <- base::computeRestarts
[17:40:50.827]                           grepl <- base::grepl
[17:40:50.827]                           restarts <- computeRestarts(cond)
[17:40:50.827]                           for (restart in restarts) {
[17:40:50.827]                             name <- restart$name
[17:40:50.827]                             if (is.null(name)) 
[17:40:50.827]                               next
[17:40:50.827]                             if (!grepl(pattern, name)) 
[17:40:50.827]                               next
[17:40:50.827]                             invokeRestart(restart)
[17:40:50.827]                             muffled <- TRUE
[17:40:50.827]                             break
[17:40:50.827]                           }
[17:40:50.827]                         }
[17:40:50.827]                       }
[17:40:50.827]                       invisible(muffled)
[17:40:50.827]                     }
[17:40:50.827]                     muffleCondition(cond, pattern = "^muffle")
[17:40:50.827]                   }
[17:40:50.827]                 }
[17:40:50.827]             }
[17:40:50.827]         }))
[17:40:50.827]     }, error = function(ex) {
[17:40:50.827]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:50.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:50.827]                 ...future.rng), started = ...future.startTime, 
[17:40:50.827]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:50.827]             version = "1.8"), class = "FutureResult")
[17:40:50.827]     }, finally = {
[17:40:50.827]         if (!identical(...future.workdir, getwd())) 
[17:40:50.827]             setwd(...future.workdir)
[17:40:50.827]         {
[17:40:50.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:50.827]                 ...future.oldOptions$nwarnings <- NULL
[17:40:50.827]             }
[17:40:50.827]             base::options(...future.oldOptions)
[17:40:50.827]             if (.Platform$OS.type == "windows") {
[17:40:50.827]                 old_names <- names(...future.oldEnvVars)
[17:40:50.827]                 envs <- base::Sys.getenv()
[17:40:50.827]                 names <- names(envs)
[17:40:50.827]                 common <- intersect(names, old_names)
[17:40:50.827]                 added <- setdiff(names, old_names)
[17:40:50.827]                 removed <- setdiff(old_names, names)
[17:40:50.827]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:50.827]                   envs[common]]
[17:40:50.827]                 NAMES <- toupper(changed)
[17:40:50.827]                 args <- list()
[17:40:50.827]                 for (kk in seq_along(NAMES)) {
[17:40:50.827]                   name <- changed[[kk]]
[17:40:50.827]                   NAME <- NAMES[[kk]]
[17:40:50.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.827]                     next
[17:40:50.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.827]                 }
[17:40:50.827]                 NAMES <- toupper(added)
[17:40:50.827]                 for (kk in seq_along(NAMES)) {
[17:40:50.827]                   name <- added[[kk]]
[17:40:50.827]                   NAME <- NAMES[[kk]]
[17:40:50.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.827]                     next
[17:40:50.827]                   args[[name]] <- ""
[17:40:50.827]                 }
[17:40:50.827]                 NAMES <- toupper(removed)
[17:40:50.827]                 for (kk in seq_along(NAMES)) {
[17:40:50.827]                   name <- removed[[kk]]
[17:40:50.827]                   NAME <- NAMES[[kk]]
[17:40:50.827]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:50.827]                     next
[17:40:50.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:50.827]                 }
[17:40:50.827]                 if (length(args) > 0) 
[17:40:50.827]                   base::do.call(base::Sys.setenv, args = args)
[17:40:50.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:50.827]             }
[17:40:50.827]             else {
[17:40:50.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:50.827]             }
[17:40:50.827]             {
[17:40:50.827]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:50.827]                   0L) {
[17:40:50.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:50.827]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:50.827]                   base::options(opts)
[17:40:50.827]                 }
[17:40:50.827]                 {
[17:40:50.827]                   {
[17:40:50.827]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:50.827]                     NULL
[17:40:50.827]                   }
[17:40:50.827]                   options(future.plan = NULL)
[17:40:50.827]                   if (is.na(NA_character_)) 
[17:40:50.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:50.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:50.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:50.827]                     .init = FALSE)
[17:40:50.827]                 }
[17:40:50.827]             }
[17:40:50.827]         }
[17:40:50.827]     })
[17:40:50.827]     if (TRUE) {
[17:40:50.827]         base::sink(type = "output", split = FALSE)
[17:40:50.827]         if (TRUE) {
[17:40:50.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:50.827]         }
[17:40:50.827]         else {
[17:40:50.827]             ...future.result["stdout"] <- base::list(NULL)
[17:40:50.827]         }
[17:40:50.827]         base::close(...future.stdout)
[17:40:50.827]         ...future.stdout <- NULL
[17:40:50.827]     }
[17:40:50.827]     ...future.result$conditions <- ...future.conditions
[17:40:50.827]     ...future.result$finished <- base::Sys.time()
[17:40:50.827]     ...future.result
[17:40:50.827] }
[17:40:50.830] MultisessionFuture started
[17:40:50.830] - Launch lazy future ... done
[17:40:50.830] run() for ‘MultisessionFuture’ ... done
[17:40:51.332] receiveMessageFromWorker() for ClusterFuture ...
[17:40:51.333] - Validating connection of MultisessionFuture
[17:40:51.333] - received message: FutureResult
[17:40:51.333] - Received FutureResult
[17:40:51.333] - Erased future from FutureRegistry
[17:40:51.333] result() for ClusterFuture ...
[17:40:51.333] - result already collected: FutureResult
[17:40:51.333] result() for ClusterFuture ... done
[17:40:51.333] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:51.333] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:51.334] getGlobalsAndPackages() ...
[17:40:51.334] Searching for globals...
[17:40:51.334] - globals found: [2] ‘list’, ‘stop’
[17:40:51.335] Searching for globals ... DONE
[17:40:51.335] Resolving globals: FALSE
[17:40:51.335] 
[17:40:51.335] 
[17:40:51.335] getGlobalsAndPackages() ... DONE
[17:40:51.335] run() for ‘Future’ ...
[17:40:51.335] - state: ‘created’
[17:40:51.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:51.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:51.350] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:51.350]   - Field: ‘node’
[17:40:51.350]   - Field: ‘label’
[17:40:51.350]   - Field: ‘local’
[17:40:51.350]   - Field: ‘owner’
[17:40:51.350]   - Field: ‘envir’
[17:40:51.350]   - Field: ‘workers’
[17:40:51.350]   - Field: ‘packages’
[17:40:51.350]   - Field: ‘gc’
[17:40:51.350]   - Field: ‘conditions’
[17:40:51.351]   - Field: ‘persistent’
[17:40:51.351]   - Field: ‘expr’
[17:40:51.351]   - Field: ‘uuid’
[17:40:51.351]   - Field: ‘seed’
[17:40:51.351]   - Field: ‘version’
[17:40:51.351]   - Field: ‘result’
[17:40:51.351]   - Field: ‘asynchronous’
[17:40:51.351]   - Field: ‘calls’
[17:40:51.351]   - Field: ‘globals’
[17:40:51.351]   - Field: ‘stdout’
[17:40:51.351]   - Field: ‘earlySignal’
[17:40:51.352]   - Field: ‘lazy’
[17:40:51.352]   - Field: ‘state’
[17:40:51.352] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:51.352] - Launch lazy future ...
[17:40:51.352] Packages needed by the future expression (n = 0): <none>
[17:40:51.352] Packages needed by future strategies (n = 0): <none>
[17:40:51.353] {
[17:40:51.353]     {
[17:40:51.353]         {
[17:40:51.353]             ...future.startTime <- base::Sys.time()
[17:40:51.353]             {
[17:40:51.353]                 {
[17:40:51.353]                   {
[17:40:51.353]                     {
[17:40:51.353]                       base::local({
[17:40:51.353]                         has_future <- base::requireNamespace("future", 
[17:40:51.353]                           quietly = TRUE)
[17:40:51.353]                         if (has_future) {
[17:40:51.353]                           ns <- base::getNamespace("future")
[17:40:51.353]                           version <- ns[[".package"]][["version"]]
[17:40:51.353]                           if (is.null(version)) 
[17:40:51.353]                             version <- utils::packageVersion("future")
[17:40:51.353]                         }
[17:40:51.353]                         else {
[17:40:51.353]                           version <- NULL
[17:40:51.353]                         }
[17:40:51.353]                         if (!has_future || version < "1.8.0") {
[17:40:51.353]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:51.353]                             "", base::R.version$version.string), 
[17:40:51.353]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:51.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:51.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:51.353]                               "release", "version")], collapse = " "), 
[17:40:51.353]                             hostname = base::Sys.info()[["nodename"]])
[17:40:51.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:51.353]                             info)
[17:40:51.353]                           info <- base::paste(info, collapse = "; ")
[17:40:51.353]                           if (!has_future) {
[17:40:51.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:51.353]                               info)
[17:40:51.353]                           }
[17:40:51.353]                           else {
[17:40:51.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:51.353]                               info, version)
[17:40:51.353]                           }
[17:40:51.353]                           base::stop(msg)
[17:40:51.353]                         }
[17:40:51.353]                       })
[17:40:51.353]                     }
[17:40:51.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:51.353]                     base::options(mc.cores = 1L)
[17:40:51.353]                   }
[17:40:51.353]                   ...future.strategy.old <- future::plan("list")
[17:40:51.353]                   options(future.plan = NULL)
[17:40:51.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:51.353]                 }
[17:40:51.353]                 ...future.workdir <- getwd()
[17:40:51.353]             }
[17:40:51.353]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:51.353]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:51.353]         }
[17:40:51.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:51.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:51.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:51.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:51.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:51.353]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:51.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:51.353]             base::names(...future.oldOptions))
[17:40:51.353]     }
[17:40:51.353]     if (FALSE) {
[17:40:51.353]     }
[17:40:51.353]     else {
[17:40:51.353]         if (TRUE) {
[17:40:51.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:51.353]                 open = "w")
[17:40:51.353]         }
[17:40:51.353]         else {
[17:40:51.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:51.353]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:51.353]         }
[17:40:51.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:51.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:51.353]             base::sink(type = "output", split = FALSE)
[17:40:51.353]             base::close(...future.stdout)
[17:40:51.353]         }, add = TRUE)
[17:40:51.353]     }
[17:40:51.353]     ...future.frame <- base::sys.nframe()
[17:40:51.353]     ...future.conditions <- base::list()
[17:40:51.353]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:51.353]     if (FALSE) {
[17:40:51.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:51.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:51.353]     }
[17:40:51.353]     ...future.result <- base::tryCatch({
[17:40:51.353]         base::withCallingHandlers({
[17:40:51.353]             ...future.value <- base::withVisible(base::local({
[17:40:51.353]                 ...future.makeSendCondition <- base::local({
[17:40:51.353]                   sendCondition <- NULL
[17:40:51.353]                   function(frame = 1L) {
[17:40:51.353]                     if (is.function(sendCondition)) 
[17:40:51.353]                       return(sendCondition)
[17:40:51.353]                     ns <- getNamespace("parallel")
[17:40:51.353]                     if (exists("sendData", mode = "function", 
[17:40:51.353]                       envir = ns)) {
[17:40:51.353]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:51.353]                         envir = ns)
[17:40:51.353]                       envir <- sys.frame(frame)
[17:40:51.353]                       master <- NULL
[17:40:51.353]                       while (!identical(envir, .GlobalEnv) && 
[17:40:51.353]                         !identical(envir, emptyenv())) {
[17:40:51.353]                         if (exists("master", mode = "list", envir = envir, 
[17:40:51.353]                           inherits = FALSE)) {
[17:40:51.353]                           master <- get("master", mode = "list", 
[17:40:51.353]                             envir = envir, inherits = FALSE)
[17:40:51.353]                           if (inherits(master, c("SOCKnode", 
[17:40:51.353]                             "SOCK0node"))) {
[17:40:51.353]                             sendCondition <<- function(cond) {
[17:40:51.353]                               data <- list(type = "VALUE", value = cond, 
[17:40:51.353]                                 success = TRUE)
[17:40:51.353]                               parallel_sendData(master, data)
[17:40:51.353]                             }
[17:40:51.353]                             return(sendCondition)
[17:40:51.353]                           }
[17:40:51.353]                         }
[17:40:51.353]                         frame <- frame + 1L
[17:40:51.353]                         envir <- sys.frame(frame)
[17:40:51.353]                       }
[17:40:51.353]                     }
[17:40:51.353]                     sendCondition <<- function(cond) NULL
[17:40:51.353]                   }
[17:40:51.353]                 })
[17:40:51.353]                 withCallingHandlers({
[17:40:51.353]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:51.353]                 }, immediateCondition = function(cond) {
[17:40:51.353]                   sendCondition <- ...future.makeSendCondition()
[17:40:51.353]                   sendCondition(cond)
[17:40:51.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.353]                   {
[17:40:51.353]                     inherits <- base::inherits
[17:40:51.353]                     invokeRestart <- base::invokeRestart
[17:40:51.353]                     is.null <- base::is.null
[17:40:51.353]                     muffled <- FALSE
[17:40:51.353]                     if (inherits(cond, "message")) {
[17:40:51.353]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:51.353]                       if (muffled) 
[17:40:51.353]                         invokeRestart("muffleMessage")
[17:40:51.353]                     }
[17:40:51.353]                     else if (inherits(cond, "warning")) {
[17:40:51.353]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:51.353]                       if (muffled) 
[17:40:51.353]                         invokeRestart("muffleWarning")
[17:40:51.353]                     }
[17:40:51.353]                     else if (inherits(cond, "condition")) {
[17:40:51.353]                       if (!is.null(pattern)) {
[17:40:51.353]                         computeRestarts <- base::computeRestarts
[17:40:51.353]                         grepl <- base::grepl
[17:40:51.353]                         restarts <- computeRestarts(cond)
[17:40:51.353]                         for (restart in restarts) {
[17:40:51.353]                           name <- restart$name
[17:40:51.353]                           if (is.null(name)) 
[17:40:51.353]                             next
[17:40:51.353]                           if (!grepl(pattern, name)) 
[17:40:51.353]                             next
[17:40:51.353]                           invokeRestart(restart)
[17:40:51.353]                           muffled <- TRUE
[17:40:51.353]                           break
[17:40:51.353]                         }
[17:40:51.353]                       }
[17:40:51.353]                     }
[17:40:51.353]                     invisible(muffled)
[17:40:51.353]                   }
[17:40:51.353]                   muffleCondition(cond)
[17:40:51.353]                 })
[17:40:51.353]             }))
[17:40:51.353]             future::FutureResult(value = ...future.value$value, 
[17:40:51.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.353]                   ...future.rng), globalenv = if (FALSE) 
[17:40:51.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:51.353]                     ...future.globalenv.names))
[17:40:51.353]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:51.353]         }, condition = base::local({
[17:40:51.353]             c <- base::c
[17:40:51.353]             inherits <- base::inherits
[17:40:51.353]             invokeRestart <- base::invokeRestart
[17:40:51.353]             length <- base::length
[17:40:51.353]             list <- base::list
[17:40:51.353]             seq.int <- base::seq.int
[17:40:51.353]             signalCondition <- base::signalCondition
[17:40:51.353]             sys.calls <- base::sys.calls
[17:40:51.353]             `[[` <- base::`[[`
[17:40:51.353]             `+` <- base::`+`
[17:40:51.353]             `<<-` <- base::`<<-`
[17:40:51.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:51.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:51.353]                   3L)]
[17:40:51.353]             }
[17:40:51.353]             function(cond) {
[17:40:51.353]                 is_error <- inherits(cond, "error")
[17:40:51.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:51.353]                   NULL)
[17:40:51.353]                 if (is_error) {
[17:40:51.353]                   sessionInformation <- function() {
[17:40:51.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:51.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:51.353]                       search = base::search(), system = base::Sys.info())
[17:40:51.353]                   }
[17:40:51.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:51.353]                     cond$call), session = sessionInformation(), 
[17:40:51.353]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:51.353]                   signalCondition(cond)
[17:40:51.353]                 }
[17:40:51.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:51.353]                 "immediateCondition"))) {
[17:40:51.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:51.353]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:51.353]                   if (TRUE && !signal) {
[17:40:51.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.353]                     {
[17:40:51.353]                       inherits <- base::inherits
[17:40:51.353]                       invokeRestart <- base::invokeRestart
[17:40:51.353]                       is.null <- base::is.null
[17:40:51.353]                       muffled <- FALSE
[17:40:51.353]                       if (inherits(cond, "message")) {
[17:40:51.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.353]                         if (muffled) 
[17:40:51.353]                           invokeRestart("muffleMessage")
[17:40:51.353]                       }
[17:40:51.353]                       else if (inherits(cond, "warning")) {
[17:40:51.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.353]                         if (muffled) 
[17:40:51.353]                           invokeRestart("muffleWarning")
[17:40:51.353]                       }
[17:40:51.353]                       else if (inherits(cond, "condition")) {
[17:40:51.353]                         if (!is.null(pattern)) {
[17:40:51.353]                           computeRestarts <- base::computeRestarts
[17:40:51.353]                           grepl <- base::grepl
[17:40:51.353]                           restarts <- computeRestarts(cond)
[17:40:51.353]                           for (restart in restarts) {
[17:40:51.353]                             name <- restart$name
[17:40:51.353]                             if (is.null(name)) 
[17:40:51.353]                               next
[17:40:51.353]                             if (!grepl(pattern, name)) 
[17:40:51.353]                               next
[17:40:51.353]                             invokeRestart(restart)
[17:40:51.353]                             muffled <- TRUE
[17:40:51.353]                             break
[17:40:51.353]                           }
[17:40:51.353]                         }
[17:40:51.353]                       }
[17:40:51.353]                       invisible(muffled)
[17:40:51.353]                     }
[17:40:51.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.353]                   }
[17:40:51.353]                 }
[17:40:51.353]                 else {
[17:40:51.353]                   if (TRUE) {
[17:40:51.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.353]                     {
[17:40:51.353]                       inherits <- base::inherits
[17:40:51.353]                       invokeRestart <- base::invokeRestart
[17:40:51.353]                       is.null <- base::is.null
[17:40:51.353]                       muffled <- FALSE
[17:40:51.353]                       if (inherits(cond, "message")) {
[17:40:51.353]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.353]                         if (muffled) 
[17:40:51.353]                           invokeRestart("muffleMessage")
[17:40:51.353]                       }
[17:40:51.353]                       else if (inherits(cond, "warning")) {
[17:40:51.353]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.353]                         if (muffled) 
[17:40:51.353]                           invokeRestart("muffleWarning")
[17:40:51.353]                       }
[17:40:51.353]                       else if (inherits(cond, "condition")) {
[17:40:51.353]                         if (!is.null(pattern)) {
[17:40:51.353]                           computeRestarts <- base::computeRestarts
[17:40:51.353]                           grepl <- base::grepl
[17:40:51.353]                           restarts <- computeRestarts(cond)
[17:40:51.353]                           for (restart in restarts) {
[17:40:51.353]                             name <- restart$name
[17:40:51.353]                             if (is.null(name)) 
[17:40:51.353]                               next
[17:40:51.353]                             if (!grepl(pattern, name)) 
[17:40:51.353]                               next
[17:40:51.353]                             invokeRestart(restart)
[17:40:51.353]                             muffled <- TRUE
[17:40:51.353]                             break
[17:40:51.353]                           }
[17:40:51.353]                         }
[17:40:51.353]                       }
[17:40:51.353]                       invisible(muffled)
[17:40:51.353]                     }
[17:40:51.353]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.353]                   }
[17:40:51.353]                 }
[17:40:51.353]             }
[17:40:51.353]         }))
[17:40:51.353]     }, error = function(ex) {
[17:40:51.353]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:51.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.353]                 ...future.rng), started = ...future.startTime, 
[17:40:51.353]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:51.353]             version = "1.8"), class = "FutureResult")
[17:40:51.353]     }, finally = {
[17:40:51.353]         if (!identical(...future.workdir, getwd())) 
[17:40:51.353]             setwd(...future.workdir)
[17:40:51.353]         {
[17:40:51.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:51.353]                 ...future.oldOptions$nwarnings <- NULL
[17:40:51.353]             }
[17:40:51.353]             base::options(...future.oldOptions)
[17:40:51.353]             if (.Platform$OS.type == "windows") {
[17:40:51.353]                 old_names <- names(...future.oldEnvVars)
[17:40:51.353]                 envs <- base::Sys.getenv()
[17:40:51.353]                 names <- names(envs)
[17:40:51.353]                 common <- intersect(names, old_names)
[17:40:51.353]                 added <- setdiff(names, old_names)
[17:40:51.353]                 removed <- setdiff(old_names, names)
[17:40:51.353]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:51.353]                   envs[common]]
[17:40:51.353]                 NAMES <- toupper(changed)
[17:40:51.353]                 args <- list()
[17:40:51.353]                 for (kk in seq_along(NAMES)) {
[17:40:51.353]                   name <- changed[[kk]]
[17:40:51.353]                   NAME <- NAMES[[kk]]
[17:40:51.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.353]                     next
[17:40:51.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.353]                 }
[17:40:51.353]                 NAMES <- toupper(added)
[17:40:51.353]                 for (kk in seq_along(NAMES)) {
[17:40:51.353]                   name <- added[[kk]]
[17:40:51.353]                   NAME <- NAMES[[kk]]
[17:40:51.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.353]                     next
[17:40:51.353]                   args[[name]] <- ""
[17:40:51.353]                 }
[17:40:51.353]                 NAMES <- toupper(removed)
[17:40:51.353]                 for (kk in seq_along(NAMES)) {
[17:40:51.353]                   name <- removed[[kk]]
[17:40:51.353]                   NAME <- NAMES[[kk]]
[17:40:51.353]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.353]                     next
[17:40:51.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.353]                 }
[17:40:51.353]                 if (length(args) > 0) 
[17:40:51.353]                   base::do.call(base::Sys.setenv, args = args)
[17:40:51.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:51.353]             }
[17:40:51.353]             else {
[17:40:51.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:51.353]             }
[17:40:51.353]             {
[17:40:51.353]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:51.353]                   0L) {
[17:40:51.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:51.353]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:51.353]                   base::options(opts)
[17:40:51.353]                 }
[17:40:51.353]                 {
[17:40:51.353]                   {
[17:40:51.353]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:51.353]                     NULL
[17:40:51.353]                   }
[17:40:51.353]                   options(future.plan = NULL)
[17:40:51.353]                   if (is.na(NA_character_)) 
[17:40:51.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:51.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:51.353]                     .init = FALSE)
[17:40:51.353]                 }
[17:40:51.353]             }
[17:40:51.353]         }
[17:40:51.353]     })
[17:40:51.353]     if (TRUE) {
[17:40:51.353]         base::sink(type = "output", split = FALSE)
[17:40:51.353]         if (TRUE) {
[17:40:51.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:51.353]         }
[17:40:51.353]         else {
[17:40:51.353]             ...future.result["stdout"] <- base::list(NULL)
[17:40:51.353]         }
[17:40:51.353]         base::close(...future.stdout)
[17:40:51.353]         ...future.stdout <- NULL
[17:40:51.353]     }
[17:40:51.353]     ...future.result$conditions <- ...future.conditions
[17:40:51.353]     ...future.result$finished <- base::Sys.time()
[17:40:51.353]     ...future.result
[17:40:51.353] }
[17:40:51.356] MultisessionFuture started
[17:40:51.356] - Launch lazy future ... done
[17:40:51.356] run() for ‘MultisessionFuture’ ... done
[17:40:51.358] receiveMessageFromWorker() for ClusterFuture ...
[17:40:51.358] - Validating connection of MultisessionFuture
[17:40:51.358] - received message: FutureResult
[17:40:51.358] - Received FutureResult
[17:40:51.359] - Erased future from FutureRegistry
[17:40:51.359] result() for ClusterFuture ...
[17:40:51.359] - result already collected: FutureResult
[17:40:51.359] result() for ClusterFuture ... done
[17:40:51.359] signalConditions() ...
[17:40:51.359]  - include = ‘immediateCondition’
[17:40:51.359]  - exclude = 
[17:40:51.359]  - resignal = FALSE
[17:40:51.359]  - Number of conditions: 1
[17:40:51.359] signalConditions() ... done
[17:40:51.359] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:51.360] A MultisessionFuture was resolved (result was not collected)
[17:40:51.360] getGlobalsAndPackages() ...
[17:40:51.360] Searching for globals...
[17:40:51.361] - globals found: [2] ‘list’, ‘stop’
[17:40:51.361] Searching for globals ... DONE
[17:40:51.361] Resolving globals: FALSE
[17:40:51.361] 
[17:40:51.361] 
[17:40:51.361] getGlobalsAndPackages() ... DONE
[17:40:51.361] run() for ‘Future’ ...
[17:40:51.362] - state: ‘created’
[17:40:51.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:51.376] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:51.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:51.376]   - Field: ‘node’
[17:40:51.376]   - Field: ‘label’
[17:40:51.376]   - Field: ‘local’
[17:40:51.376]   - Field: ‘owner’
[17:40:51.376]   - Field: ‘envir’
[17:40:51.376]   - Field: ‘workers’
[17:40:51.376]   - Field: ‘packages’
[17:40:51.377]   - Field: ‘gc’
[17:40:51.377]   - Field: ‘conditions’
[17:40:51.377]   - Field: ‘persistent’
[17:40:51.377]   - Field: ‘expr’
[17:40:51.377]   - Field: ‘uuid’
[17:40:51.377]   - Field: ‘seed’
[17:40:51.377]   - Field: ‘version’
[17:40:51.377]   - Field: ‘result’
[17:40:51.377]   - Field: ‘asynchronous’
[17:40:51.377]   - Field: ‘calls’
[17:40:51.377]   - Field: ‘globals’
[17:40:51.377]   - Field: ‘stdout’
[17:40:51.378]   - Field: ‘earlySignal’
[17:40:51.378]   - Field: ‘lazy’
[17:40:51.378]   - Field: ‘state’
[17:40:51.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:51.378] - Launch lazy future ...
[17:40:51.378] Packages needed by the future expression (n = 0): <none>
[17:40:51.378] Packages needed by future strategies (n = 0): <none>
[17:40:51.379] {
[17:40:51.379]     {
[17:40:51.379]         {
[17:40:51.379]             ...future.startTime <- base::Sys.time()
[17:40:51.379]             {
[17:40:51.379]                 {
[17:40:51.379]                   {
[17:40:51.379]                     {
[17:40:51.379]                       base::local({
[17:40:51.379]                         has_future <- base::requireNamespace("future", 
[17:40:51.379]                           quietly = TRUE)
[17:40:51.379]                         if (has_future) {
[17:40:51.379]                           ns <- base::getNamespace("future")
[17:40:51.379]                           version <- ns[[".package"]][["version"]]
[17:40:51.379]                           if (is.null(version)) 
[17:40:51.379]                             version <- utils::packageVersion("future")
[17:40:51.379]                         }
[17:40:51.379]                         else {
[17:40:51.379]                           version <- NULL
[17:40:51.379]                         }
[17:40:51.379]                         if (!has_future || version < "1.8.0") {
[17:40:51.379]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:51.379]                             "", base::R.version$version.string), 
[17:40:51.379]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:51.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:51.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:51.379]                               "release", "version")], collapse = " "), 
[17:40:51.379]                             hostname = base::Sys.info()[["nodename"]])
[17:40:51.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:51.379]                             info)
[17:40:51.379]                           info <- base::paste(info, collapse = "; ")
[17:40:51.379]                           if (!has_future) {
[17:40:51.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:51.379]                               info)
[17:40:51.379]                           }
[17:40:51.379]                           else {
[17:40:51.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:51.379]                               info, version)
[17:40:51.379]                           }
[17:40:51.379]                           base::stop(msg)
[17:40:51.379]                         }
[17:40:51.379]                       })
[17:40:51.379]                     }
[17:40:51.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:51.379]                     base::options(mc.cores = 1L)
[17:40:51.379]                   }
[17:40:51.379]                   ...future.strategy.old <- future::plan("list")
[17:40:51.379]                   options(future.plan = NULL)
[17:40:51.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:51.379]                 }
[17:40:51.379]                 ...future.workdir <- getwd()
[17:40:51.379]             }
[17:40:51.379]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:51.379]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:51.379]         }
[17:40:51.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:51.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:51.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:51.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:51.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:51.379]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:51.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:51.379]             base::names(...future.oldOptions))
[17:40:51.379]     }
[17:40:51.379]     if (FALSE) {
[17:40:51.379]     }
[17:40:51.379]     else {
[17:40:51.379]         if (TRUE) {
[17:40:51.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:51.379]                 open = "w")
[17:40:51.379]         }
[17:40:51.379]         else {
[17:40:51.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:51.379]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:51.379]         }
[17:40:51.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:51.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:51.379]             base::sink(type = "output", split = FALSE)
[17:40:51.379]             base::close(...future.stdout)
[17:40:51.379]         }, add = TRUE)
[17:40:51.379]     }
[17:40:51.379]     ...future.frame <- base::sys.nframe()
[17:40:51.379]     ...future.conditions <- base::list()
[17:40:51.379]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:51.379]     if (FALSE) {
[17:40:51.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:51.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:51.379]     }
[17:40:51.379]     ...future.result <- base::tryCatch({
[17:40:51.379]         base::withCallingHandlers({
[17:40:51.379]             ...future.value <- base::withVisible(base::local({
[17:40:51.379]                 ...future.makeSendCondition <- base::local({
[17:40:51.379]                   sendCondition <- NULL
[17:40:51.379]                   function(frame = 1L) {
[17:40:51.379]                     if (is.function(sendCondition)) 
[17:40:51.379]                       return(sendCondition)
[17:40:51.379]                     ns <- getNamespace("parallel")
[17:40:51.379]                     if (exists("sendData", mode = "function", 
[17:40:51.379]                       envir = ns)) {
[17:40:51.379]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:51.379]                         envir = ns)
[17:40:51.379]                       envir <- sys.frame(frame)
[17:40:51.379]                       master <- NULL
[17:40:51.379]                       while (!identical(envir, .GlobalEnv) && 
[17:40:51.379]                         !identical(envir, emptyenv())) {
[17:40:51.379]                         if (exists("master", mode = "list", envir = envir, 
[17:40:51.379]                           inherits = FALSE)) {
[17:40:51.379]                           master <- get("master", mode = "list", 
[17:40:51.379]                             envir = envir, inherits = FALSE)
[17:40:51.379]                           if (inherits(master, c("SOCKnode", 
[17:40:51.379]                             "SOCK0node"))) {
[17:40:51.379]                             sendCondition <<- function(cond) {
[17:40:51.379]                               data <- list(type = "VALUE", value = cond, 
[17:40:51.379]                                 success = TRUE)
[17:40:51.379]                               parallel_sendData(master, data)
[17:40:51.379]                             }
[17:40:51.379]                             return(sendCondition)
[17:40:51.379]                           }
[17:40:51.379]                         }
[17:40:51.379]                         frame <- frame + 1L
[17:40:51.379]                         envir <- sys.frame(frame)
[17:40:51.379]                       }
[17:40:51.379]                     }
[17:40:51.379]                     sendCondition <<- function(cond) NULL
[17:40:51.379]                   }
[17:40:51.379]                 })
[17:40:51.379]                 withCallingHandlers({
[17:40:51.379]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:51.379]                 }, immediateCondition = function(cond) {
[17:40:51.379]                   sendCondition <- ...future.makeSendCondition()
[17:40:51.379]                   sendCondition(cond)
[17:40:51.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.379]                   {
[17:40:51.379]                     inherits <- base::inherits
[17:40:51.379]                     invokeRestart <- base::invokeRestart
[17:40:51.379]                     is.null <- base::is.null
[17:40:51.379]                     muffled <- FALSE
[17:40:51.379]                     if (inherits(cond, "message")) {
[17:40:51.379]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:51.379]                       if (muffled) 
[17:40:51.379]                         invokeRestart("muffleMessage")
[17:40:51.379]                     }
[17:40:51.379]                     else if (inherits(cond, "warning")) {
[17:40:51.379]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:51.379]                       if (muffled) 
[17:40:51.379]                         invokeRestart("muffleWarning")
[17:40:51.379]                     }
[17:40:51.379]                     else if (inherits(cond, "condition")) {
[17:40:51.379]                       if (!is.null(pattern)) {
[17:40:51.379]                         computeRestarts <- base::computeRestarts
[17:40:51.379]                         grepl <- base::grepl
[17:40:51.379]                         restarts <- computeRestarts(cond)
[17:40:51.379]                         for (restart in restarts) {
[17:40:51.379]                           name <- restart$name
[17:40:51.379]                           if (is.null(name)) 
[17:40:51.379]                             next
[17:40:51.379]                           if (!grepl(pattern, name)) 
[17:40:51.379]                             next
[17:40:51.379]                           invokeRestart(restart)
[17:40:51.379]                           muffled <- TRUE
[17:40:51.379]                           break
[17:40:51.379]                         }
[17:40:51.379]                       }
[17:40:51.379]                     }
[17:40:51.379]                     invisible(muffled)
[17:40:51.379]                   }
[17:40:51.379]                   muffleCondition(cond)
[17:40:51.379]                 })
[17:40:51.379]             }))
[17:40:51.379]             future::FutureResult(value = ...future.value$value, 
[17:40:51.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.379]                   ...future.rng), globalenv = if (FALSE) 
[17:40:51.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:51.379]                     ...future.globalenv.names))
[17:40:51.379]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:51.379]         }, condition = base::local({
[17:40:51.379]             c <- base::c
[17:40:51.379]             inherits <- base::inherits
[17:40:51.379]             invokeRestart <- base::invokeRestart
[17:40:51.379]             length <- base::length
[17:40:51.379]             list <- base::list
[17:40:51.379]             seq.int <- base::seq.int
[17:40:51.379]             signalCondition <- base::signalCondition
[17:40:51.379]             sys.calls <- base::sys.calls
[17:40:51.379]             `[[` <- base::`[[`
[17:40:51.379]             `+` <- base::`+`
[17:40:51.379]             `<<-` <- base::`<<-`
[17:40:51.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:51.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:51.379]                   3L)]
[17:40:51.379]             }
[17:40:51.379]             function(cond) {
[17:40:51.379]                 is_error <- inherits(cond, "error")
[17:40:51.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:51.379]                   NULL)
[17:40:51.379]                 if (is_error) {
[17:40:51.379]                   sessionInformation <- function() {
[17:40:51.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:51.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:51.379]                       search = base::search(), system = base::Sys.info())
[17:40:51.379]                   }
[17:40:51.379]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:51.379]                     cond$call), session = sessionInformation(), 
[17:40:51.379]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:51.379]                   signalCondition(cond)
[17:40:51.379]                 }
[17:40:51.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:51.379]                 "immediateCondition"))) {
[17:40:51.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:51.379]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:51.379]                   if (TRUE && !signal) {
[17:40:51.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.379]                     {
[17:40:51.379]                       inherits <- base::inherits
[17:40:51.379]                       invokeRestart <- base::invokeRestart
[17:40:51.379]                       is.null <- base::is.null
[17:40:51.379]                       muffled <- FALSE
[17:40:51.379]                       if (inherits(cond, "message")) {
[17:40:51.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.379]                         if (muffled) 
[17:40:51.379]                           invokeRestart("muffleMessage")
[17:40:51.379]                       }
[17:40:51.379]                       else if (inherits(cond, "warning")) {
[17:40:51.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.379]                         if (muffled) 
[17:40:51.379]                           invokeRestart("muffleWarning")
[17:40:51.379]                       }
[17:40:51.379]                       else if (inherits(cond, "condition")) {
[17:40:51.379]                         if (!is.null(pattern)) {
[17:40:51.379]                           computeRestarts <- base::computeRestarts
[17:40:51.379]                           grepl <- base::grepl
[17:40:51.379]                           restarts <- computeRestarts(cond)
[17:40:51.379]                           for (restart in restarts) {
[17:40:51.379]                             name <- restart$name
[17:40:51.379]                             if (is.null(name)) 
[17:40:51.379]                               next
[17:40:51.379]                             if (!grepl(pattern, name)) 
[17:40:51.379]                               next
[17:40:51.379]                             invokeRestart(restart)
[17:40:51.379]                             muffled <- TRUE
[17:40:51.379]                             break
[17:40:51.379]                           }
[17:40:51.379]                         }
[17:40:51.379]                       }
[17:40:51.379]                       invisible(muffled)
[17:40:51.379]                     }
[17:40:51.379]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.379]                   }
[17:40:51.379]                 }
[17:40:51.379]                 else {
[17:40:51.379]                   if (TRUE) {
[17:40:51.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.379]                     {
[17:40:51.379]                       inherits <- base::inherits
[17:40:51.379]                       invokeRestart <- base::invokeRestart
[17:40:51.379]                       is.null <- base::is.null
[17:40:51.379]                       muffled <- FALSE
[17:40:51.379]                       if (inherits(cond, "message")) {
[17:40:51.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.379]                         if (muffled) 
[17:40:51.379]                           invokeRestart("muffleMessage")
[17:40:51.379]                       }
[17:40:51.379]                       else if (inherits(cond, "warning")) {
[17:40:51.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.379]                         if (muffled) 
[17:40:51.379]                           invokeRestart("muffleWarning")
[17:40:51.379]                       }
[17:40:51.379]                       else if (inherits(cond, "condition")) {
[17:40:51.379]                         if (!is.null(pattern)) {
[17:40:51.379]                           computeRestarts <- base::computeRestarts
[17:40:51.379]                           grepl <- base::grepl
[17:40:51.379]                           restarts <- computeRestarts(cond)
[17:40:51.379]                           for (restart in restarts) {
[17:40:51.379]                             name <- restart$name
[17:40:51.379]                             if (is.null(name)) 
[17:40:51.379]                               next
[17:40:51.379]                             if (!grepl(pattern, name)) 
[17:40:51.379]                               next
[17:40:51.379]                             invokeRestart(restart)
[17:40:51.379]                             muffled <- TRUE
[17:40:51.379]                             break
[17:40:51.379]                           }
[17:40:51.379]                         }
[17:40:51.379]                       }
[17:40:51.379]                       invisible(muffled)
[17:40:51.379]                     }
[17:40:51.379]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.379]                   }
[17:40:51.379]                 }
[17:40:51.379]             }
[17:40:51.379]         }))
[17:40:51.379]     }, error = function(ex) {
[17:40:51.379]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:51.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.379]                 ...future.rng), started = ...future.startTime, 
[17:40:51.379]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:51.379]             version = "1.8"), class = "FutureResult")
[17:40:51.379]     }, finally = {
[17:40:51.379]         if (!identical(...future.workdir, getwd())) 
[17:40:51.379]             setwd(...future.workdir)
[17:40:51.379]         {
[17:40:51.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:51.379]                 ...future.oldOptions$nwarnings <- NULL
[17:40:51.379]             }
[17:40:51.379]             base::options(...future.oldOptions)
[17:40:51.379]             if (.Platform$OS.type == "windows") {
[17:40:51.379]                 old_names <- names(...future.oldEnvVars)
[17:40:51.379]                 envs <- base::Sys.getenv()
[17:40:51.379]                 names <- names(envs)
[17:40:51.379]                 common <- intersect(names, old_names)
[17:40:51.379]                 added <- setdiff(names, old_names)
[17:40:51.379]                 removed <- setdiff(old_names, names)
[17:40:51.379]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:51.379]                   envs[common]]
[17:40:51.379]                 NAMES <- toupper(changed)
[17:40:51.379]                 args <- list()
[17:40:51.379]                 for (kk in seq_along(NAMES)) {
[17:40:51.379]                   name <- changed[[kk]]
[17:40:51.379]                   NAME <- NAMES[[kk]]
[17:40:51.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.379]                     next
[17:40:51.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.379]                 }
[17:40:51.379]                 NAMES <- toupper(added)
[17:40:51.379]                 for (kk in seq_along(NAMES)) {
[17:40:51.379]                   name <- added[[kk]]
[17:40:51.379]                   NAME <- NAMES[[kk]]
[17:40:51.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.379]                     next
[17:40:51.379]                   args[[name]] <- ""
[17:40:51.379]                 }
[17:40:51.379]                 NAMES <- toupper(removed)
[17:40:51.379]                 for (kk in seq_along(NAMES)) {
[17:40:51.379]                   name <- removed[[kk]]
[17:40:51.379]                   NAME <- NAMES[[kk]]
[17:40:51.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.379]                     next
[17:40:51.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.379]                 }
[17:40:51.379]                 if (length(args) > 0) 
[17:40:51.379]                   base::do.call(base::Sys.setenv, args = args)
[17:40:51.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:51.379]             }
[17:40:51.379]             else {
[17:40:51.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:51.379]             }
[17:40:51.379]             {
[17:40:51.379]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:51.379]                   0L) {
[17:40:51.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:51.379]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:51.379]                   base::options(opts)
[17:40:51.379]                 }
[17:40:51.379]                 {
[17:40:51.379]                   {
[17:40:51.379]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:51.379]                     NULL
[17:40:51.379]                   }
[17:40:51.379]                   options(future.plan = NULL)
[17:40:51.379]                   if (is.na(NA_character_)) 
[17:40:51.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:51.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:51.379]                     .init = FALSE)
[17:40:51.379]                 }
[17:40:51.379]             }
[17:40:51.379]         }
[17:40:51.379]     })
[17:40:51.379]     if (TRUE) {
[17:40:51.379]         base::sink(type = "output", split = FALSE)
[17:40:51.379]         if (TRUE) {
[17:40:51.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:51.379]         }
[17:40:51.379]         else {
[17:40:51.379]             ...future.result["stdout"] <- base::list(NULL)
[17:40:51.379]         }
[17:40:51.379]         base::close(...future.stdout)
[17:40:51.379]         ...future.stdout <- NULL
[17:40:51.379]     }
[17:40:51.379]     ...future.result$conditions <- ...future.conditions
[17:40:51.379]     ...future.result$finished <- base::Sys.time()
[17:40:51.379]     ...future.result
[17:40:51.379] }
[17:40:51.382] MultisessionFuture started
[17:40:51.382] - Launch lazy future ... done
[17:40:51.382] run() for ‘MultisessionFuture’ ... done
[17:40:51.384] receiveMessageFromWorker() for ClusterFuture ...
[17:40:51.384] - Validating connection of MultisessionFuture
[17:40:51.384] - received message: FutureResult
[17:40:51.384] - Received FutureResult
[17:40:51.384] - Erased future from FutureRegistry
[17:40:51.385] result() for ClusterFuture ...
[17:40:51.385] - result already collected: FutureResult
[17:40:51.385] result() for ClusterFuture ... done
[17:40:51.385] signalConditions() ...
[17:40:51.385]  - include = ‘immediateCondition’
[17:40:51.385]  - exclude = 
[17:40:51.385]  - resignal = FALSE
[17:40:51.385]  - Number of conditions: 1
[17:40:51.385] signalConditions() ... done
[17:40:51.385] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:51.385] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[17:40:51.386] getGlobalsAndPackages() ...
[17:40:51.386] Searching for globals...
[17:40:51.387] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:51.387] Searching for globals ... DONE
[17:40:51.387] Resolving globals: FALSE
[17:40:51.387] 
[17:40:51.387] 
[17:40:51.387] getGlobalsAndPackages() ... DONE
[17:40:51.388] run() for ‘Future’ ...
[17:40:51.388] - state: ‘created’
[17:40:51.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:51.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:51.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:51.402]   - Field: ‘node’
[17:40:51.402]   - Field: ‘label’
[17:40:51.402]   - Field: ‘local’
[17:40:51.402]   - Field: ‘owner’
[17:40:51.402]   - Field: ‘envir’
[17:40:51.402]   - Field: ‘workers’
[17:40:51.402]   - Field: ‘packages’
[17:40:51.402]   - Field: ‘gc’
[17:40:51.402]   - Field: ‘conditions’
[17:40:51.402]   - Field: ‘persistent’
[17:40:51.402]   - Field: ‘expr’
[17:40:51.403]   - Field: ‘uuid’
[17:40:51.403]   - Field: ‘seed’
[17:40:51.403]   - Field: ‘version’
[17:40:51.403]   - Field: ‘result’
[17:40:51.403]   - Field: ‘asynchronous’
[17:40:51.403]   - Field: ‘calls’
[17:40:51.403]   - Field: ‘globals’
[17:40:51.403]   - Field: ‘stdout’
[17:40:51.403]   - Field: ‘earlySignal’
[17:40:51.403]   - Field: ‘lazy’
[17:40:51.403]   - Field: ‘state’
[17:40:51.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:51.404] - Launch lazy future ...
[17:40:51.404] Packages needed by the future expression (n = 0): <none>
[17:40:51.404] Packages needed by future strategies (n = 0): <none>
[17:40:51.404] {
[17:40:51.404]     {
[17:40:51.404]         {
[17:40:51.404]             ...future.startTime <- base::Sys.time()
[17:40:51.404]             {
[17:40:51.404]                 {
[17:40:51.404]                   {
[17:40:51.404]                     {
[17:40:51.404]                       base::local({
[17:40:51.404]                         has_future <- base::requireNamespace("future", 
[17:40:51.404]                           quietly = TRUE)
[17:40:51.404]                         if (has_future) {
[17:40:51.404]                           ns <- base::getNamespace("future")
[17:40:51.404]                           version <- ns[[".package"]][["version"]]
[17:40:51.404]                           if (is.null(version)) 
[17:40:51.404]                             version <- utils::packageVersion("future")
[17:40:51.404]                         }
[17:40:51.404]                         else {
[17:40:51.404]                           version <- NULL
[17:40:51.404]                         }
[17:40:51.404]                         if (!has_future || version < "1.8.0") {
[17:40:51.404]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:51.404]                             "", base::R.version$version.string), 
[17:40:51.404]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:51.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:51.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:51.404]                               "release", "version")], collapse = " "), 
[17:40:51.404]                             hostname = base::Sys.info()[["nodename"]])
[17:40:51.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:51.404]                             info)
[17:40:51.404]                           info <- base::paste(info, collapse = "; ")
[17:40:51.404]                           if (!has_future) {
[17:40:51.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:51.404]                               info)
[17:40:51.404]                           }
[17:40:51.404]                           else {
[17:40:51.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:51.404]                               info, version)
[17:40:51.404]                           }
[17:40:51.404]                           base::stop(msg)
[17:40:51.404]                         }
[17:40:51.404]                       })
[17:40:51.404]                     }
[17:40:51.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:51.404]                     base::options(mc.cores = 1L)
[17:40:51.404]                   }
[17:40:51.404]                   ...future.strategy.old <- future::plan("list")
[17:40:51.404]                   options(future.plan = NULL)
[17:40:51.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:51.404]                 }
[17:40:51.404]                 ...future.workdir <- getwd()
[17:40:51.404]             }
[17:40:51.404]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:51.404]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:51.404]         }
[17:40:51.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:51.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:51.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:51.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:51.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:51.404]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:51.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:51.404]             base::names(...future.oldOptions))
[17:40:51.404]     }
[17:40:51.404]     if (FALSE) {
[17:40:51.404]     }
[17:40:51.404]     else {
[17:40:51.404]         if (TRUE) {
[17:40:51.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:51.404]                 open = "w")
[17:40:51.404]         }
[17:40:51.404]         else {
[17:40:51.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:51.404]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:51.404]         }
[17:40:51.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:51.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:51.404]             base::sink(type = "output", split = FALSE)
[17:40:51.404]             base::close(...future.stdout)
[17:40:51.404]         }, add = TRUE)
[17:40:51.404]     }
[17:40:51.404]     ...future.frame <- base::sys.nframe()
[17:40:51.404]     ...future.conditions <- base::list()
[17:40:51.404]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:51.404]     if (FALSE) {
[17:40:51.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:51.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:51.404]     }
[17:40:51.404]     ...future.result <- base::tryCatch({
[17:40:51.404]         base::withCallingHandlers({
[17:40:51.404]             ...future.value <- base::withVisible(base::local({
[17:40:51.404]                 ...future.makeSendCondition <- base::local({
[17:40:51.404]                   sendCondition <- NULL
[17:40:51.404]                   function(frame = 1L) {
[17:40:51.404]                     if (is.function(sendCondition)) 
[17:40:51.404]                       return(sendCondition)
[17:40:51.404]                     ns <- getNamespace("parallel")
[17:40:51.404]                     if (exists("sendData", mode = "function", 
[17:40:51.404]                       envir = ns)) {
[17:40:51.404]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:51.404]                         envir = ns)
[17:40:51.404]                       envir <- sys.frame(frame)
[17:40:51.404]                       master <- NULL
[17:40:51.404]                       while (!identical(envir, .GlobalEnv) && 
[17:40:51.404]                         !identical(envir, emptyenv())) {
[17:40:51.404]                         if (exists("master", mode = "list", envir = envir, 
[17:40:51.404]                           inherits = FALSE)) {
[17:40:51.404]                           master <- get("master", mode = "list", 
[17:40:51.404]                             envir = envir, inherits = FALSE)
[17:40:51.404]                           if (inherits(master, c("SOCKnode", 
[17:40:51.404]                             "SOCK0node"))) {
[17:40:51.404]                             sendCondition <<- function(cond) {
[17:40:51.404]                               data <- list(type = "VALUE", value = cond, 
[17:40:51.404]                                 success = TRUE)
[17:40:51.404]                               parallel_sendData(master, data)
[17:40:51.404]                             }
[17:40:51.404]                             return(sendCondition)
[17:40:51.404]                           }
[17:40:51.404]                         }
[17:40:51.404]                         frame <- frame + 1L
[17:40:51.404]                         envir <- sys.frame(frame)
[17:40:51.404]                       }
[17:40:51.404]                     }
[17:40:51.404]                     sendCondition <<- function(cond) NULL
[17:40:51.404]                   }
[17:40:51.404]                 })
[17:40:51.404]                 withCallingHandlers({
[17:40:51.404]                   {
[17:40:51.404]                     Sys.sleep(0.5)
[17:40:51.404]                     list(a = 1, b = 42L)
[17:40:51.404]                   }
[17:40:51.404]                 }, immediateCondition = function(cond) {
[17:40:51.404]                   sendCondition <- ...future.makeSendCondition()
[17:40:51.404]                   sendCondition(cond)
[17:40:51.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.404]                   {
[17:40:51.404]                     inherits <- base::inherits
[17:40:51.404]                     invokeRestart <- base::invokeRestart
[17:40:51.404]                     is.null <- base::is.null
[17:40:51.404]                     muffled <- FALSE
[17:40:51.404]                     if (inherits(cond, "message")) {
[17:40:51.404]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:51.404]                       if (muffled) 
[17:40:51.404]                         invokeRestart("muffleMessage")
[17:40:51.404]                     }
[17:40:51.404]                     else if (inherits(cond, "warning")) {
[17:40:51.404]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:51.404]                       if (muffled) 
[17:40:51.404]                         invokeRestart("muffleWarning")
[17:40:51.404]                     }
[17:40:51.404]                     else if (inherits(cond, "condition")) {
[17:40:51.404]                       if (!is.null(pattern)) {
[17:40:51.404]                         computeRestarts <- base::computeRestarts
[17:40:51.404]                         grepl <- base::grepl
[17:40:51.404]                         restarts <- computeRestarts(cond)
[17:40:51.404]                         for (restart in restarts) {
[17:40:51.404]                           name <- restart$name
[17:40:51.404]                           if (is.null(name)) 
[17:40:51.404]                             next
[17:40:51.404]                           if (!grepl(pattern, name)) 
[17:40:51.404]                             next
[17:40:51.404]                           invokeRestart(restart)
[17:40:51.404]                           muffled <- TRUE
[17:40:51.404]                           break
[17:40:51.404]                         }
[17:40:51.404]                       }
[17:40:51.404]                     }
[17:40:51.404]                     invisible(muffled)
[17:40:51.404]                   }
[17:40:51.404]                   muffleCondition(cond)
[17:40:51.404]                 })
[17:40:51.404]             }))
[17:40:51.404]             future::FutureResult(value = ...future.value$value, 
[17:40:51.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.404]                   ...future.rng), globalenv = if (FALSE) 
[17:40:51.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:51.404]                     ...future.globalenv.names))
[17:40:51.404]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:51.404]         }, condition = base::local({
[17:40:51.404]             c <- base::c
[17:40:51.404]             inherits <- base::inherits
[17:40:51.404]             invokeRestart <- base::invokeRestart
[17:40:51.404]             length <- base::length
[17:40:51.404]             list <- base::list
[17:40:51.404]             seq.int <- base::seq.int
[17:40:51.404]             signalCondition <- base::signalCondition
[17:40:51.404]             sys.calls <- base::sys.calls
[17:40:51.404]             `[[` <- base::`[[`
[17:40:51.404]             `+` <- base::`+`
[17:40:51.404]             `<<-` <- base::`<<-`
[17:40:51.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:51.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:51.404]                   3L)]
[17:40:51.404]             }
[17:40:51.404]             function(cond) {
[17:40:51.404]                 is_error <- inherits(cond, "error")
[17:40:51.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:51.404]                   NULL)
[17:40:51.404]                 if (is_error) {
[17:40:51.404]                   sessionInformation <- function() {
[17:40:51.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:51.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:51.404]                       search = base::search(), system = base::Sys.info())
[17:40:51.404]                   }
[17:40:51.404]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:51.404]                     cond$call), session = sessionInformation(), 
[17:40:51.404]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:51.404]                   signalCondition(cond)
[17:40:51.404]                 }
[17:40:51.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:51.404]                 "immediateCondition"))) {
[17:40:51.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:51.404]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:51.404]                   if (TRUE && !signal) {
[17:40:51.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.404]                     {
[17:40:51.404]                       inherits <- base::inherits
[17:40:51.404]                       invokeRestart <- base::invokeRestart
[17:40:51.404]                       is.null <- base::is.null
[17:40:51.404]                       muffled <- FALSE
[17:40:51.404]                       if (inherits(cond, "message")) {
[17:40:51.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.404]                         if (muffled) 
[17:40:51.404]                           invokeRestart("muffleMessage")
[17:40:51.404]                       }
[17:40:51.404]                       else if (inherits(cond, "warning")) {
[17:40:51.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.404]                         if (muffled) 
[17:40:51.404]                           invokeRestart("muffleWarning")
[17:40:51.404]                       }
[17:40:51.404]                       else if (inherits(cond, "condition")) {
[17:40:51.404]                         if (!is.null(pattern)) {
[17:40:51.404]                           computeRestarts <- base::computeRestarts
[17:40:51.404]                           grepl <- base::grepl
[17:40:51.404]                           restarts <- computeRestarts(cond)
[17:40:51.404]                           for (restart in restarts) {
[17:40:51.404]                             name <- restart$name
[17:40:51.404]                             if (is.null(name)) 
[17:40:51.404]                               next
[17:40:51.404]                             if (!grepl(pattern, name)) 
[17:40:51.404]                               next
[17:40:51.404]                             invokeRestart(restart)
[17:40:51.404]                             muffled <- TRUE
[17:40:51.404]                             break
[17:40:51.404]                           }
[17:40:51.404]                         }
[17:40:51.404]                       }
[17:40:51.404]                       invisible(muffled)
[17:40:51.404]                     }
[17:40:51.404]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.404]                   }
[17:40:51.404]                 }
[17:40:51.404]                 else {
[17:40:51.404]                   if (TRUE) {
[17:40:51.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.404]                     {
[17:40:51.404]                       inherits <- base::inherits
[17:40:51.404]                       invokeRestart <- base::invokeRestart
[17:40:51.404]                       is.null <- base::is.null
[17:40:51.404]                       muffled <- FALSE
[17:40:51.404]                       if (inherits(cond, "message")) {
[17:40:51.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.404]                         if (muffled) 
[17:40:51.404]                           invokeRestart("muffleMessage")
[17:40:51.404]                       }
[17:40:51.404]                       else if (inherits(cond, "warning")) {
[17:40:51.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.404]                         if (muffled) 
[17:40:51.404]                           invokeRestart("muffleWarning")
[17:40:51.404]                       }
[17:40:51.404]                       else if (inherits(cond, "condition")) {
[17:40:51.404]                         if (!is.null(pattern)) {
[17:40:51.404]                           computeRestarts <- base::computeRestarts
[17:40:51.404]                           grepl <- base::grepl
[17:40:51.404]                           restarts <- computeRestarts(cond)
[17:40:51.404]                           for (restart in restarts) {
[17:40:51.404]                             name <- restart$name
[17:40:51.404]                             if (is.null(name)) 
[17:40:51.404]                               next
[17:40:51.404]                             if (!grepl(pattern, name)) 
[17:40:51.404]                               next
[17:40:51.404]                             invokeRestart(restart)
[17:40:51.404]                             muffled <- TRUE
[17:40:51.404]                             break
[17:40:51.404]                           }
[17:40:51.404]                         }
[17:40:51.404]                       }
[17:40:51.404]                       invisible(muffled)
[17:40:51.404]                     }
[17:40:51.404]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.404]                   }
[17:40:51.404]                 }
[17:40:51.404]             }
[17:40:51.404]         }))
[17:40:51.404]     }, error = function(ex) {
[17:40:51.404]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:51.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.404]                 ...future.rng), started = ...future.startTime, 
[17:40:51.404]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:51.404]             version = "1.8"), class = "FutureResult")
[17:40:51.404]     }, finally = {
[17:40:51.404]         if (!identical(...future.workdir, getwd())) 
[17:40:51.404]             setwd(...future.workdir)
[17:40:51.404]         {
[17:40:51.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:51.404]                 ...future.oldOptions$nwarnings <- NULL
[17:40:51.404]             }
[17:40:51.404]             base::options(...future.oldOptions)
[17:40:51.404]             if (.Platform$OS.type == "windows") {
[17:40:51.404]                 old_names <- names(...future.oldEnvVars)
[17:40:51.404]                 envs <- base::Sys.getenv()
[17:40:51.404]                 names <- names(envs)
[17:40:51.404]                 common <- intersect(names, old_names)
[17:40:51.404]                 added <- setdiff(names, old_names)
[17:40:51.404]                 removed <- setdiff(old_names, names)
[17:40:51.404]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:51.404]                   envs[common]]
[17:40:51.404]                 NAMES <- toupper(changed)
[17:40:51.404]                 args <- list()
[17:40:51.404]                 for (kk in seq_along(NAMES)) {
[17:40:51.404]                   name <- changed[[kk]]
[17:40:51.404]                   NAME <- NAMES[[kk]]
[17:40:51.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.404]                     next
[17:40:51.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.404]                 }
[17:40:51.404]                 NAMES <- toupper(added)
[17:40:51.404]                 for (kk in seq_along(NAMES)) {
[17:40:51.404]                   name <- added[[kk]]
[17:40:51.404]                   NAME <- NAMES[[kk]]
[17:40:51.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.404]                     next
[17:40:51.404]                   args[[name]] <- ""
[17:40:51.404]                 }
[17:40:51.404]                 NAMES <- toupper(removed)
[17:40:51.404]                 for (kk in seq_along(NAMES)) {
[17:40:51.404]                   name <- removed[[kk]]
[17:40:51.404]                   NAME <- NAMES[[kk]]
[17:40:51.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.404]                     next
[17:40:51.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.404]                 }
[17:40:51.404]                 if (length(args) > 0) 
[17:40:51.404]                   base::do.call(base::Sys.setenv, args = args)
[17:40:51.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:51.404]             }
[17:40:51.404]             else {
[17:40:51.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:51.404]             }
[17:40:51.404]             {
[17:40:51.404]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:51.404]                   0L) {
[17:40:51.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:51.404]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:51.404]                   base::options(opts)
[17:40:51.404]                 }
[17:40:51.404]                 {
[17:40:51.404]                   {
[17:40:51.404]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:51.404]                     NULL
[17:40:51.404]                   }
[17:40:51.404]                   options(future.plan = NULL)
[17:40:51.404]                   if (is.na(NA_character_)) 
[17:40:51.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:51.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:51.404]                     .init = FALSE)
[17:40:51.404]                 }
[17:40:51.404]             }
[17:40:51.404]         }
[17:40:51.404]     })
[17:40:51.404]     if (TRUE) {
[17:40:51.404]         base::sink(type = "output", split = FALSE)
[17:40:51.404]         if (TRUE) {
[17:40:51.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:51.404]         }
[17:40:51.404]         else {
[17:40:51.404]             ...future.result["stdout"] <- base::list(NULL)
[17:40:51.404]         }
[17:40:51.404]         base::close(...future.stdout)
[17:40:51.404]         ...future.stdout <- NULL
[17:40:51.404]     }
[17:40:51.404]     ...future.result$conditions <- ...future.conditions
[17:40:51.404]     ...future.result$finished <- base::Sys.time()
[17:40:51.404]     ...future.result
[17:40:51.404] }
[17:40:51.407] MultisessionFuture started
[17:40:51.407] - Launch lazy future ... done
[17:40:51.407] run() for ‘MultisessionFuture’ ... done
[17:40:51.909] receiveMessageFromWorker() for ClusterFuture ...
[17:40:51.910] - Validating connection of MultisessionFuture
[17:40:51.910] - received message: FutureResult
[17:40:51.910] - Received FutureResult
[17:40:51.910] - Erased future from FutureRegistry
[17:40:51.910] result() for ClusterFuture ...
[17:40:51.910] - result already collected: FutureResult
[17:40:51.910] result() for ClusterFuture ... done
[17:40:51.911] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:51.913] A MultisessionFuture was resolved (result was not collected)
[17:40:51.913] getGlobalsAndPackages() ...
[17:40:51.913] Searching for globals...
[17:40:51.914] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:51.914] Searching for globals ... DONE
[17:40:51.914] Resolving globals: FALSE
[17:40:51.915] 
[17:40:51.915] 
[17:40:51.915] getGlobalsAndPackages() ... DONE
[17:40:51.915] run() for ‘Future’ ...
[17:40:51.915] - state: ‘created’
[17:40:51.915] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:51.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:51.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:51.930]   - Field: ‘node’
[17:40:51.930]   - Field: ‘label’
[17:40:51.930]   - Field: ‘local’
[17:40:51.930]   - Field: ‘owner’
[17:40:51.930]   - Field: ‘envir’
[17:40:51.930]   - Field: ‘workers’
[17:40:51.930]   - Field: ‘packages’
[17:40:51.930]   - Field: ‘gc’
[17:40:51.930]   - Field: ‘conditions’
[17:40:51.930]   - Field: ‘persistent’
[17:40:51.931]   - Field: ‘expr’
[17:40:51.931]   - Field: ‘uuid’
[17:40:51.931]   - Field: ‘seed’
[17:40:51.931]   - Field: ‘version’
[17:40:51.931]   - Field: ‘result’
[17:40:51.931]   - Field: ‘asynchronous’
[17:40:51.931]   - Field: ‘calls’
[17:40:51.931]   - Field: ‘globals’
[17:40:51.931]   - Field: ‘stdout’
[17:40:51.931]   - Field: ‘earlySignal’
[17:40:51.931]   - Field: ‘lazy’
[17:40:51.931]   - Field: ‘state’
[17:40:51.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:51.932] - Launch lazy future ...
[17:40:51.932] Packages needed by the future expression (n = 0): <none>
[17:40:51.932] Packages needed by future strategies (n = 0): <none>
[17:40:51.932] {
[17:40:51.932]     {
[17:40:51.932]         {
[17:40:51.932]             ...future.startTime <- base::Sys.time()
[17:40:51.932]             {
[17:40:51.932]                 {
[17:40:51.932]                   {
[17:40:51.932]                     {
[17:40:51.932]                       base::local({
[17:40:51.932]                         has_future <- base::requireNamespace("future", 
[17:40:51.932]                           quietly = TRUE)
[17:40:51.932]                         if (has_future) {
[17:40:51.932]                           ns <- base::getNamespace("future")
[17:40:51.932]                           version <- ns[[".package"]][["version"]]
[17:40:51.932]                           if (is.null(version)) 
[17:40:51.932]                             version <- utils::packageVersion("future")
[17:40:51.932]                         }
[17:40:51.932]                         else {
[17:40:51.932]                           version <- NULL
[17:40:51.932]                         }
[17:40:51.932]                         if (!has_future || version < "1.8.0") {
[17:40:51.932]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:51.932]                             "", base::R.version$version.string), 
[17:40:51.932]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:51.932]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:51.932]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:51.932]                               "release", "version")], collapse = " "), 
[17:40:51.932]                             hostname = base::Sys.info()[["nodename"]])
[17:40:51.932]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:51.932]                             info)
[17:40:51.932]                           info <- base::paste(info, collapse = "; ")
[17:40:51.932]                           if (!has_future) {
[17:40:51.932]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:51.932]                               info)
[17:40:51.932]                           }
[17:40:51.932]                           else {
[17:40:51.932]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:51.932]                               info, version)
[17:40:51.932]                           }
[17:40:51.932]                           base::stop(msg)
[17:40:51.932]                         }
[17:40:51.932]                       })
[17:40:51.932]                     }
[17:40:51.932]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:51.932]                     base::options(mc.cores = 1L)
[17:40:51.932]                   }
[17:40:51.932]                   ...future.strategy.old <- future::plan("list")
[17:40:51.932]                   options(future.plan = NULL)
[17:40:51.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:51.932]                 }
[17:40:51.932]                 ...future.workdir <- getwd()
[17:40:51.932]             }
[17:40:51.932]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:51.932]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:51.932]         }
[17:40:51.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:51.932]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:51.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:51.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:51.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:51.932]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:51.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:51.932]             base::names(...future.oldOptions))
[17:40:51.932]     }
[17:40:51.932]     if (FALSE) {
[17:40:51.932]     }
[17:40:51.932]     else {
[17:40:51.932]         if (TRUE) {
[17:40:51.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:51.932]                 open = "w")
[17:40:51.932]         }
[17:40:51.932]         else {
[17:40:51.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:51.932]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:51.932]         }
[17:40:51.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:51.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:51.932]             base::sink(type = "output", split = FALSE)
[17:40:51.932]             base::close(...future.stdout)
[17:40:51.932]         }, add = TRUE)
[17:40:51.932]     }
[17:40:51.932]     ...future.frame <- base::sys.nframe()
[17:40:51.932]     ...future.conditions <- base::list()
[17:40:51.932]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:51.932]     if (FALSE) {
[17:40:51.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:51.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:51.932]     }
[17:40:51.932]     ...future.result <- base::tryCatch({
[17:40:51.932]         base::withCallingHandlers({
[17:40:51.932]             ...future.value <- base::withVisible(base::local({
[17:40:51.932]                 ...future.makeSendCondition <- base::local({
[17:40:51.932]                   sendCondition <- NULL
[17:40:51.932]                   function(frame = 1L) {
[17:40:51.932]                     if (is.function(sendCondition)) 
[17:40:51.932]                       return(sendCondition)
[17:40:51.932]                     ns <- getNamespace("parallel")
[17:40:51.932]                     if (exists("sendData", mode = "function", 
[17:40:51.932]                       envir = ns)) {
[17:40:51.932]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:51.932]                         envir = ns)
[17:40:51.932]                       envir <- sys.frame(frame)
[17:40:51.932]                       master <- NULL
[17:40:51.932]                       while (!identical(envir, .GlobalEnv) && 
[17:40:51.932]                         !identical(envir, emptyenv())) {
[17:40:51.932]                         if (exists("master", mode = "list", envir = envir, 
[17:40:51.932]                           inherits = FALSE)) {
[17:40:51.932]                           master <- get("master", mode = "list", 
[17:40:51.932]                             envir = envir, inherits = FALSE)
[17:40:51.932]                           if (inherits(master, c("SOCKnode", 
[17:40:51.932]                             "SOCK0node"))) {
[17:40:51.932]                             sendCondition <<- function(cond) {
[17:40:51.932]                               data <- list(type = "VALUE", value = cond, 
[17:40:51.932]                                 success = TRUE)
[17:40:51.932]                               parallel_sendData(master, data)
[17:40:51.932]                             }
[17:40:51.932]                             return(sendCondition)
[17:40:51.932]                           }
[17:40:51.932]                         }
[17:40:51.932]                         frame <- frame + 1L
[17:40:51.932]                         envir <- sys.frame(frame)
[17:40:51.932]                       }
[17:40:51.932]                     }
[17:40:51.932]                     sendCondition <<- function(cond) NULL
[17:40:51.932]                   }
[17:40:51.932]                 })
[17:40:51.932]                 withCallingHandlers({
[17:40:51.932]                   {
[17:40:51.932]                     Sys.sleep(0.5)
[17:40:51.932]                     list(a = 1, b = 42L)
[17:40:51.932]                   }
[17:40:51.932]                 }, immediateCondition = function(cond) {
[17:40:51.932]                   sendCondition <- ...future.makeSendCondition()
[17:40:51.932]                   sendCondition(cond)
[17:40:51.932]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.932]                   {
[17:40:51.932]                     inherits <- base::inherits
[17:40:51.932]                     invokeRestart <- base::invokeRestart
[17:40:51.932]                     is.null <- base::is.null
[17:40:51.932]                     muffled <- FALSE
[17:40:51.932]                     if (inherits(cond, "message")) {
[17:40:51.932]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:51.932]                       if (muffled) 
[17:40:51.932]                         invokeRestart("muffleMessage")
[17:40:51.932]                     }
[17:40:51.932]                     else if (inherits(cond, "warning")) {
[17:40:51.932]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:51.932]                       if (muffled) 
[17:40:51.932]                         invokeRestart("muffleWarning")
[17:40:51.932]                     }
[17:40:51.932]                     else if (inherits(cond, "condition")) {
[17:40:51.932]                       if (!is.null(pattern)) {
[17:40:51.932]                         computeRestarts <- base::computeRestarts
[17:40:51.932]                         grepl <- base::grepl
[17:40:51.932]                         restarts <- computeRestarts(cond)
[17:40:51.932]                         for (restart in restarts) {
[17:40:51.932]                           name <- restart$name
[17:40:51.932]                           if (is.null(name)) 
[17:40:51.932]                             next
[17:40:51.932]                           if (!grepl(pattern, name)) 
[17:40:51.932]                             next
[17:40:51.932]                           invokeRestart(restart)
[17:40:51.932]                           muffled <- TRUE
[17:40:51.932]                           break
[17:40:51.932]                         }
[17:40:51.932]                       }
[17:40:51.932]                     }
[17:40:51.932]                     invisible(muffled)
[17:40:51.932]                   }
[17:40:51.932]                   muffleCondition(cond)
[17:40:51.932]                 })
[17:40:51.932]             }))
[17:40:51.932]             future::FutureResult(value = ...future.value$value, 
[17:40:51.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.932]                   ...future.rng), globalenv = if (FALSE) 
[17:40:51.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:51.932]                     ...future.globalenv.names))
[17:40:51.932]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:51.932]         }, condition = base::local({
[17:40:51.932]             c <- base::c
[17:40:51.932]             inherits <- base::inherits
[17:40:51.932]             invokeRestart <- base::invokeRestart
[17:40:51.932]             length <- base::length
[17:40:51.932]             list <- base::list
[17:40:51.932]             seq.int <- base::seq.int
[17:40:51.932]             signalCondition <- base::signalCondition
[17:40:51.932]             sys.calls <- base::sys.calls
[17:40:51.932]             `[[` <- base::`[[`
[17:40:51.932]             `+` <- base::`+`
[17:40:51.932]             `<<-` <- base::`<<-`
[17:40:51.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:51.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:51.932]                   3L)]
[17:40:51.932]             }
[17:40:51.932]             function(cond) {
[17:40:51.932]                 is_error <- inherits(cond, "error")
[17:40:51.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:51.932]                   NULL)
[17:40:51.932]                 if (is_error) {
[17:40:51.932]                   sessionInformation <- function() {
[17:40:51.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:51.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:51.932]                       search = base::search(), system = base::Sys.info())
[17:40:51.932]                   }
[17:40:51.932]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:51.932]                     cond$call), session = sessionInformation(), 
[17:40:51.932]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:51.932]                   signalCondition(cond)
[17:40:51.932]                 }
[17:40:51.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:51.932]                 "immediateCondition"))) {
[17:40:51.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:51.932]                   ...future.conditions[[length(...future.conditions) + 
[17:40:51.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:51.932]                   if (TRUE && !signal) {
[17:40:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.932]                     {
[17:40:51.932]                       inherits <- base::inherits
[17:40:51.932]                       invokeRestart <- base::invokeRestart
[17:40:51.932]                       is.null <- base::is.null
[17:40:51.932]                       muffled <- FALSE
[17:40:51.932]                       if (inherits(cond, "message")) {
[17:40:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.932]                         if (muffled) 
[17:40:51.932]                           invokeRestart("muffleMessage")
[17:40:51.932]                       }
[17:40:51.932]                       else if (inherits(cond, "warning")) {
[17:40:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.932]                         if (muffled) 
[17:40:51.932]                           invokeRestart("muffleWarning")
[17:40:51.932]                       }
[17:40:51.932]                       else if (inherits(cond, "condition")) {
[17:40:51.932]                         if (!is.null(pattern)) {
[17:40:51.932]                           computeRestarts <- base::computeRestarts
[17:40:51.932]                           grepl <- base::grepl
[17:40:51.932]                           restarts <- computeRestarts(cond)
[17:40:51.932]                           for (restart in restarts) {
[17:40:51.932]                             name <- restart$name
[17:40:51.932]                             if (is.null(name)) 
[17:40:51.932]                               next
[17:40:51.932]                             if (!grepl(pattern, name)) 
[17:40:51.932]                               next
[17:40:51.932]                             invokeRestart(restart)
[17:40:51.932]                             muffled <- TRUE
[17:40:51.932]                             break
[17:40:51.932]                           }
[17:40:51.932]                         }
[17:40:51.932]                       }
[17:40:51.932]                       invisible(muffled)
[17:40:51.932]                     }
[17:40:51.932]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.932]                   }
[17:40:51.932]                 }
[17:40:51.932]                 else {
[17:40:51.932]                   if (TRUE) {
[17:40:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:51.932]                     {
[17:40:51.932]                       inherits <- base::inherits
[17:40:51.932]                       invokeRestart <- base::invokeRestart
[17:40:51.932]                       is.null <- base::is.null
[17:40:51.932]                       muffled <- FALSE
[17:40:51.932]                       if (inherits(cond, "message")) {
[17:40:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:51.932]                         if (muffled) 
[17:40:51.932]                           invokeRestart("muffleMessage")
[17:40:51.932]                       }
[17:40:51.932]                       else if (inherits(cond, "warning")) {
[17:40:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:51.932]                         if (muffled) 
[17:40:51.932]                           invokeRestart("muffleWarning")
[17:40:51.932]                       }
[17:40:51.932]                       else if (inherits(cond, "condition")) {
[17:40:51.932]                         if (!is.null(pattern)) {
[17:40:51.932]                           computeRestarts <- base::computeRestarts
[17:40:51.932]                           grepl <- base::grepl
[17:40:51.932]                           restarts <- computeRestarts(cond)
[17:40:51.932]                           for (restart in restarts) {
[17:40:51.932]                             name <- restart$name
[17:40:51.932]                             if (is.null(name)) 
[17:40:51.932]                               next
[17:40:51.932]                             if (!grepl(pattern, name)) 
[17:40:51.932]                               next
[17:40:51.932]                             invokeRestart(restart)
[17:40:51.932]                             muffled <- TRUE
[17:40:51.932]                             break
[17:40:51.932]                           }
[17:40:51.932]                         }
[17:40:51.932]                       }
[17:40:51.932]                       invisible(muffled)
[17:40:51.932]                     }
[17:40:51.932]                     muffleCondition(cond, pattern = "^muffle")
[17:40:51.932]                   }
[17:40:51.932]                 }
[17:40:51.932]             }
[17:40:51.932]         }))
[17:40:51.932]     }, error = function(ex) {
[17:40:51.932]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:51.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:51.932]                 ...future.rng), started = ...future.startTime, 
[17:40:51.932]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:51.932]             version = "1.8"), class = "FutureResult")
[17:40:51.932]     }, finally = {
[17:40:51.932]         if (!identical(...future.workdir, getwd())) 
[17:40:51.932]             setwd(...future.workdir)
[17:40:51.932]         {
[17:40:51.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:51.932]                 ...future.oldOptions$nwarnings <- NULL
[17:40:51.932]             }
[17:40:51.932]             base::options(...future.oldOptions)
[17:40:51.932]             if (.Platform$OS.type == "windows") {
[17:40:51.932]                 old_names <- names(...future.oldEnvVars)
[17:40:51.932]                 envs <- base::Sys.getenv()
[17:40:51.932]                 names <- names(envs)
[17:40:51.932]                 common <- intersect(names, old_names)
[17:40:51.932]                 added <- setdiff(names, old_names)
[17:40:51.932]                 removed <- setdiff(old_names, names)
[17:40:51.932]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:51.932]                   envs[common]]
[17:40:51.932]                 NAMES <- toupper(changed)
[17:40:51.932]                 args <- list()
[17:40:51.932]                 for (kk in seq_along(NAMES)) {
[17:40:51.932]                   name <- changed[[kk]]
[17:40:51.932]                   NAME <- NAMES[[kk]]
[17:40:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.932]                     next
[17:40:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.932]                 }
[17:40:51.932]                 NAMES <- toupper(added)
[17:40:51.932]                 for (kk in seq_along(NAMES)) {
[17:40:51.932]                   name <- added[[kk]]
[17:40:51.932]                   NAME <- NAMES[[kk]]
[17:40:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.932]                     next
[17:40:51.932]                   args[[name]] <- ""
[17:40:51.932]                 }
[17:40:51.932]                 NAMES <- toupper(removed)
[17:40:51.932]                 for (kk in seq_along(NAMES)) {
[17:40:51.932]                   name <- removed[[kk]]
[17:40:51.932]                   NAME <- NAMES[[kk]]
[17:40:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:51.932]                     next
[17:40:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:51.932]                 }
[17:40:51.932]                 if (length(args) > 0) 
[17:40:51.932]                   base::do.call(base::Sys.setenv, args = args)
[17:40:51.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:51.932]             }
[17:40:51.932]             else {
[17:40:51.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:51.932]             }
[17:40:51.932]             {
[17:40:51.932]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:51.932]                   0L) {
[17:40:51.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:51.932]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:51.932]                   base::options(opts)
[17:40:51.932]                 }
[17:40:51.932]                 {
[17:40:51.932]                   {
[17:40:51.932]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:51.932]                     NULL
[17:40:51.932]                   }
[17:40:51.932]                   options(future.plan = NULL)
[17:40:51.932]                   if (is.na(NA_character_)) 
[17:40:51.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:51.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:51.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:51.932]                     .init = FALSE)
[17:40:51.932]                 }
[17:40:51.932]             }
[17:40:51.932]         }
[17:40:51.932]     })
[17:40:51.932]     if (TRUE) {
[17:40:51.932]         base::sink(type = "output", split = FALSE)
[17:40:51.932]         if (TRUE) {
[17:40:51.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:51.932]         }
[17:40:51.932]         else {
[17:40:51.932]             ...future.result["stdout"] <- base::list(NULL)
[17:40:51.932]         }
[17:40:51.932]         base::close(...future.stdout)
[17:40:51.932]         ...future.stdout <- NULL
[17:40:51.932]     }
[17:40:51.932]     ...future.result$conditions <- ...future.conditions
[17:40:51.932]     ...future.result$finished <- base::Sys.time()
[17:40:51.932]     ...future.result
[17:40:51.932] }
[17:40:51.935] MultisessionFuture started
[17:40:51.935] - Launch lazy future ... done
[17:40:51.935] run() for ‘MultisessionFuture’ ... done
[17:40:52.438] receiveMessageFromWorker() for ClusterFuture ...
[17:40:52.438] - Validating connection of MultisessionFuture
[17:40:52.438] - received message: FutureResult
[17:40:52.439] - Received FutureResult
[17:40:52.439] - Erased future from FutureRegistry
[17:40:52.439] result() for ClusterFuture ...
[17:40:52.439] - result already collected: FutureResult
[17:40:52.439] result() for ClusterFuture ... done
[17:40:52.439] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:52.439] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[17:40:52.439] getGlobalsAndPackages() ...
[17:40:52.439] Searching for globals...
[17:40:52.440] - globals found: [2] ‘list’, ‘stop’
[17:40:52.440] Searching for globals ... DONE
[17:40:52.440] Resolving globals: FALSE
[17:40:52.441] 
[17:40:52.441] 
[17:40:52.441] getGlobalsAndPackages() ... DONE
[17:40:52.441] run() for ‘Future’ ...
[17:40:52.441] - state: ‘created’
[17:40:52.441] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:52.455] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:52.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:52.456]   - Field: ‘node’
[17:40:52.456]   - Field: ‘label’
[17:40:52.456]   - Field: ‘local’
[17:40:52.456]   - Field: ‘owner’
[17:40:52.456]   - Field: ‘envir’
[17:40:52.456]   - Field: ‘workers’
[17:40:52.456]   - Field: ‘packages’
[17:40:52.456]   - Field: ‘gc’
[17:40:52.456]   - Field: ‘conditions’
[17:40:52.457]   - Field: ‘persistent’
[17:40:52.457]   - Field: ‘expr’
[17:40:52.457]   - Field: ‘uuid’
[17:40:52.457]   - Field: ‘seed’
[17:40:52.457]   - Field: ‘version’
[17:40:52.457]   - Field: ‘result’
[17:40:52.457]   - Field: ‘asynchronous’
[17:40:52.457]   - Field: ‘calls’
[17:40:52.457]   - Field: ‘globals’
[17:40:52.457]   - Field: ‘stdout’
[17:40:52.457]   - Field: ‘earlySignal’
[17:40:52.458]   - Field: ‘lazy’
[17:40:52.458]   - Field: ‘state’
[17:40:52.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:52.458] - Launch lazy future ...
[17:40:52.458] Packages needed by the future expression (n = 0): <none>
[17:40:52.458] Packages needed by future strategies (n = 0): <none>
[17:40:52.459] {
[17:40:52.459]     {
[17:40:52.459]         {
[17:40:52.459]             ...future.startTime <- base::Sys.time()
[17:40:52.459]             {
[17:40:52.459]                 {
[17:40:52.459]                   {
[17:40:52.459]                     {
[17:40:52.459]                       base::local({
[17:40:52.459]                         has_future <- base::requireNamespace("future", 
[17:40:52.459]                           quietly = TRUE)
[17:40:52.459]                         if (has_future) {
[17:40:52.459]                           ns <- base::getNamespace("future")
[17:40:52.459]                           version <- ns[[".package"]][["version"]]
[17:40:52.459]                           if (is.null(version)) 
[17:40:52.459]                             version <- utils::packageVersion("future")
[17:40:52.459]                         }
[17:40:52.459]                         else {
[17:40:52.459]                           version <- NULL
[17:40:52.459]                         }
[17:40:52.459]                         if (!has_future || version < "1.8.0") {
[17:40:52.459]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:52.459]                             "", base::R.version$version.string), 
[17:40:52.459]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:52.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:52.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:52.459]                               "release", "version")], collapse = " "), 
[17:40:52.459]                             hostname = base::Sys.info()[["nodename"]])
[17:40:52.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:52.459]                             info)
[17:40:52.459]                           info <- base::paste(info, collapse = "; ")
[17:40:52.459]                           if (!has_future) {
[17:40:52.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:52.459]                               info)
[17:40:52.459]                           }
[17:40:52.459]                           else {
[17:40:52.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:52.459]                               info, version)
[17:40:52.459]                           }
[17:40:52.459]                           base::stop(msg)
[17:40:52.459]                         }
[17:40:52.459]                       })
[17:40:52.459]                     }
[17:40:52.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:52.459]                     base::options(mc.cores = 1L)
[17:40:52.459]                   }
[17:40:52.459]                   ...future.strategy.old <- future::plan("list")
[17:40:52.459]                   options(future.plan = NULL)
[17:40:52.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:52.459]                 }
[17:40:52.459]                 ...future.workdir <- getwd()
[17:40:52.459]             }
[17:40:52.459]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:52.459]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:52.459]         }
[17:40:52.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:52.459]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:52.459]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:52.459]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:52.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:52.459]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:52.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:52.459]             base::names(...future.oldOptions))
[17:40:52.459]     }
[17:40:52.459]     if (FALSE) {
[17:40:52.459]     }
[17:40:52.459]     else {
[17:40:52.459]         if (TRUE) {
[17:40:52.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:52.459]                 open = "w")
[17:40:52.459]         }
[17:40:52.459]         else {
[17:40:52.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:52.459]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:52.459]         }
[17:40:52.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:52.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:52.459]             base::sink(type = "output", split = FALSE)
[17:40:52.459]             base::close(...future.stdout)
[17:40:52.459]         }, add = TRUE)
[17:40:52.459]     }
[17:40:52.459]     ...future.frame <- base::sys.nframe()
[17:40:52.459]     ...future.conditions <- base::list()
[17:40:52.459]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:52.459]     if (FALSE) {
[17:40:52.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:52.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:52.459]     }
[17:40:52.459]     ...future.result <- base::tryCatch({
[17:40:52.459]         base::withCallingHandlers({
[17:40:52.459]             ...future.value <- base::withVisible(base::local({
[17:40:52.459]                 ...future.makeSendCondition <- base::local({
[17:40:52.459]                   sendCondition <- NULL
[17:40:52.459]                   function(frame = 1L) {
[17:40:52.459]                     if (is.function(sendCondition)) 
[17:40:52.459]                       return(sendCondition)
[17:40:52.459]                     ns <- getNamespace("parallel")
[17:40:52.459]                     if (exists("sendData", mode = "function", 
[17:40:52.459]                       envir = ns)) {
[17:40:52.459]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:52.459]                         envir = ns)
[17:40:52.459]                       envir <- sys.frame(frame)
[17:40:52.459]                       master <- NULL
[17:40:52.459]                       while (!identical(envir, .GlobalEnv) && 
[17:40:52.459]                         !identical(envir, emptyenv())) {
[17:40:52.459]                         if (exists("master", mode = "list", envir = envir, 
[17:40:52.459]                           inherits = FALSE)) {
[17:40:52.459]                           master <- get("master", mode = "list", 
[17:40:52.459]                             envir = envir, inherits = FALSE)
[17:40:52.459]                           if (inherits(master, c("SOCKnode", 
[17:40:52.459]                             "SOCK0node"))) {
[17:40:52.459]                             sendCondition <<- function(cond) {
[17:40:52.459]                               data <- list(type = "VALUE", value = cond, 
[17:40:52.459]                                 success = TRUE)
[17:40:52.459]                               parallel_sendData(master, data)
[17:40:52.459]                             }
[17:40:52.459]                             return(sendCondition)
[17:40:52.459]                           }
[17:40:52.459]                         }
[17:40:52.459]                         frame <- frame + 1L
[17:40:52.459]                         envir <- sys.frame(frame)
[17:40:52.459]                       }
[17:40:52.459]                     }
[17:40:52.459]                     sendCondition <<- function(cond) NULL
[17:40:52.459]                   }
[17:40:52.459]                 })
[17:40:52.459]                 withCallingHandlers({
[17:40:52.459]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:52.459]                 }, immediateCondition = function(cond) {
[17:40:52.459]                   sendCondition <- ...future.makeSendCondition()
[17:40:52.459]                   sendCondition(cond)
[17:40:52.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.459]                   {
[17:40:52.459]                     inherits <- base::inherits
[17:40:52.459]                     invokeRestart <- base::invokeRestart
[17:40:52.459]                     is.null <- base::is.null
[17:40:52.459]                     muffled <- FALSE
[17:40:52.459]                     if (inherits(cond, "message")) {
[17:40:52.459]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:52.459]                       if (muffled) 
[17:40:52.459]                         invokeRestart("muffleMessage")
[17:40:52.459]                     }
[17:40:52.459]                     else if (inherits(cond, "warning")) {
[17:40:52.459]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:52.459]                       if (muffled) 
[17:40:52.459]                         invokeRestart("muffleWarning")
[17:40:52.459]                     }
[17:40:52.459]                     else if (inherits(cond, "condition")) {
[17:40:52.459]                       if (!is.null(pattern)) {
[17:40:52.459]                         computeRestarts <- base::computeRestarts
[17:40:52.459]                         grepl <- base::grepl
[17:40:52.459]                         restarts <- computeRestarts(cond)
[17:40:52.459]                         for (restart in restarts) {
[17:40:52.459]                           name <- restart$name
[17:40:52.459]                           if (is.null(name)) 
[17:40:52.459]                             next
[17:40:52.459]                           if (!grepl(pattern, name)) 
[17:40:52.459]                             next
[17:40:52.459]                           invokeRestart(restart)
[17:40:52.459]                           muffled <- TRUE
[17:40:52.459]                           break
[17:40:52.459]                         }
[17:40:52.459]                       }
[17:40:52.459]                     }
[17:40:52.459]                     invisible(muffled)
[17:40:52.459]                   }
[17:40:52.459]                   muffleCondition(cond)
[17:40:52.459]                 })
[17:40:52.459]             }))
[17:40:52.459]             future::FutureResult(value = ...future.value$value, 
[17:40:52.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.459]                   ...future.rng), globalenv = if (FALSE) 
[17:40:52.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:52.459]                     ...future.globalenv.names))
[17:40:52.459]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:52.459]         }, condition = base::local({
[17:40:52.459]             c <- base::c
[17:40:52.459]             inherits <- base::inherits
[17:40:52.459]             invokeRestart <- base::invokeRestart
[17:40:52.459]             length <- base::length
[17:40:52.459]             list <- base::list
[17:40:52.459]             seq.int <- base::seq.int
[17:40:52.459]             signalCondition <- base::signalCondition
[17:40:52.459]             sys.calls <- base::sys.calls
[17:40:52.459]             `[[` <- base::`[[`
[17:40:52.459]             `+` <- base::`+`
[17:40:52.459]             `<<-` <- base::`<<-`
[17:40:52.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:52.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:52.459]                   3L)]
[17:40:52.459]             }
[17:40:52.459]             function(cond) {
[17:40:52.459]                 is_error <- inherits(cond, "error")
[17:40:52.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:52.459]                   NULL)
[17:40:52.459]                 if (is_error) {
[17:40:52.459]                   sessionInformation <- function() {
[17:40:52.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:52.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:52.459]                       search = base::search(), system = base::Sys.info())
[17:40:52.459]                   }
[17:40:52.459]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:52.459]                     cond$call), session = sessionInformation(), 
[17:40:52.459]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:52.459]                   signalCondition(cond)
[17:40:52.459]                 }
[17:40:52.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:52.459]                 "immediateCondition"))) {
[17:40:52.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:52.459]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:52.459]                   if (TRUE && !signal) {
[17:40:52.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.459]                     {
[17:40:52.459]                       inherits <- base::inherits
[17:40:52.459]                       invokeRestart <- base::invokeRestart
[17:40:52.459]                       is.null <- base::is.null
[17:40:52.459]                       muffled <- FALSE
[17:40:52.459]                       if (inherits(cond, "message")) {
[17:40:52.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.459]                         if (muffled) 
[17:40:52.459]                           invokeRestart("muffleMessage")
[17:40:52.459]                       }
[17:40:52.459]                       else if (inherits(cond, "warning")) {
[17:40:52.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.459]                         if (muffled) 
[17:40:52.459]                           invokeRestart("muffleWarning")
[17:40:52.459]                       }
[17:40:52.459]                       else if (inherits(cond, "condition")) {
[17:40:52.459]                         if (!is.null(pattern)) {
[17:40:52.459]                           computeRestarts <- base::computeRestarts
[17:40:52.459]                           grepl <- base::grepl
[17:40:52.459]                           restarts <- computeRestarts(cond)
[17:40:52.459]                           for (restart in restarts) {
[17:40:52.459]                             name <- restart$name
[17:40:52.459]                             if (is.null(name)) 
[17:40:52.459]                               next
[17:40:52.459]                             if (!grepl(pattern, name)) 
[17:40:52.459]                               next
[17:40:52.459]                             invokeRestart(restart)
[17:40:52.459]                             muffled <- TRUE
[17:40:52.459]                             break
[17:40:52.459]                           }
[17:40:52.459]                         }
[17:40:52.459]                       }
[17:40:52.459]                       invisible(muffled)
[17:40:52.459]                     }
[17:40:52.459]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.459]                   }
[17:40:52.459]                 }
[17:40:52.459]                 else {
[17:40:52.459]                   if (TRUE) {
[17:40:52.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.459]                     {
[17:40:52.459]                       inherits <- base::inherits
[17:40:52.459]                       invokeRestart <- base::invokeRestart
[17:40:52.459]                       is.null <- base::is.null
[17:40:52.459]                       muffled <- FALSE
[17:40:52.459]                       if (inherits(cond, "message")) {
[17:40:52.459]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.459]                         if (muffled) 
[17:40:52.459]                           invokeRestart("muffleMessage")
[17:40:52.459]                       }
[17:40:52.459]                       else if (inherits(cond, "warning")) {
[17:40:52.459]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.459]                         if (muffled) 
[17:40:52.459]                           invokeRestart("muffleWarning")
[17:40:52.459]                       }
[17:40:52.459]                       else if (inherits(cond, "condition")) {
[17:40:52.459]                         if (!is.null(pattern)) {
[17:40:52.459]                           computeRestarts <- base::computeRestarts
[17:40:52.459]                           grepl <- base::grepl
[17:40:52.459]                           restarts <- computeRestarts(cond)
[17:40:52.459]                           for (restart in restarts) {
[17:40:52.459]                             name <- restart$name
[17:40:52.459]                             if (is.null(name)) 
[17:40:52.459]                               next
[17:40:52.459]                             if (!grepl(pattern, name)) 
[17:40:52.459]                               next
[17:40:52.459]                             invokeRestart(restart)
[17:40:52.459]                             muffled <- TRUE
[17:40:52.459]                             break
[17:40:52.459]                           }
[17:40:52.459]                         }
[17:40:52.459]                       }
[17:40:52.459]                       invisible(muffled)
[17:40:52.459]                     }
[17:40:52.459]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.459]                   }
[17:40:52.459]                 }
[17:40:52.459]             }
[17:40:52.459]         }))
[17:40:52.459]     }, error = function(ex) {
[17:40:52.459]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:52.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.459]                 ...future.rng), started = ...future.startTime, 
[17:40:52.459]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:52.459]             version = "1.8"), class = "FutureResult")
[17:40:52.459]     }, finally = {
[17:40:52.459]         if (!identical(...future.workdir, getwd())) 
[17:40:52.459]             setwd(...future.workdir)
[17:40:52.459]         {
[17:40:52.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:52.459]                 ...future.oldOptions$nwarnings <- NULL
[17:40:52.459]             }
[17:40:52.459]             base::options(...future.oldOptions)
[17:40:52.459]             if (.Platform$OS.type == "windows") {
[17:40:52.459]                 old_names <- names(...future.oldEnvVars)
[17:40:52.459]                 envs <- base::Sys.getenv()
[17:40:52.459]                 names <- names(envs)
[17:40:52.459]                 common <- intersect(names, old_names)
[17:40:52.459]                 added <- setdiff(names, old_names)
[17:40:52.459]                 removed <- setdiff(old_names, names)
[17:40:52.459]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:52.459]                   envs[common]]
[17:40:52.459]                 NAMES <- toupper(changed)
[17:40:52.459]                 args <- list()
[17:40:52.459]                 for (kk in seq_along(NAMES)) {
[17:40:52.459]                   name <- changed[[kk]]
[17:40:52.459]                   NAME <- NAMES[[kk]]
[17:40:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.459]                     next
[17:40:52.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.459]                 }
[17:40:52.459]                 NAMES <- toupper(added)
[17:40:52.459]                 for (kk in seq_along(NAMES)) {
[17:40:52.459]                   name <- added[[kk]]
[17:40:52.459]                   NAME <- NAMES[[kk]]
[17:40:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.459]                     next
[17:40:52.459]                   args[[name]] <- ""
[17:40:52.459]                 }
[17:40:52.459]                 NAMES <- toupper(removed)
[17:40:52.459]                 for (kk in seq_along(NAMES)) {
[17:40:52.459]                   name <- removed[[kk]]
[17:40:52.459]                   NAME <- NAMES[[kk]]
[17:40:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.459]                     next
[17:40:52.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.459]                 }
[17:40:52.459]                 if (length(args) > 0) 
[17:40:52.459]                   base::do.call(base::Sys.setenv, args = args)
[17:40:52.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:52.459]             }
[17:40:52.459]             else {
[17:40:52.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:52.459]             }
[17:40:52.459]             {
[17:40:52.459]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:52.459]                   0L) {
[17:40:52.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:52.459]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:52.459]                   base::options(opts)
[17:40:52.459]                 }
[17:40:52.459]                 {
[17:40:52.459]                   {
[17:40:52.459]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:52.459]                     NULL
[17:40:52.459]                   }
[17:40:52.459]                   options(future.plan = NULL)
[17:40:52.459]                   if (is.na(NA_character_)) 
[17:40:52.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:52.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:52.459]                     .init = FALSE)
[17:40:52.459]                 }
[17:40:52.459]             }
[17:40:52.459]         }
[17:40:52.459]     })
[17:40:52.459]     if (TRUE) {
[17:40:52.459]         base::sink(type = "output", split = FALSE)
[17:40:52.459]         if (TRUE) {
[17:40:52.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:52.459]         }
[17:40:52.459]         else {
[17:40:52.459]             ...future.result["stdout"] <- base::list(NULL)
[17:40:52.459]         }
[17:40:52.459]         base::close(...future.stdout)
[17:40:52.459]         ...future.stdout <- NULL
[17:40:52.459]     }
[17:40:52.459]     ...future.result$conditions <- ...future.conditions
[17:40:52.459]     ...future.result$finished <- base::Sys.time()
[17:40:52.459]     ...future.result
[17:40:52.459] }
[17:40:52.462] MultisessionFuture started
[17:40:52.462] - Launch lazy future ... done
[17:40:52.462] run() for ‘MultisessionFuture’ ... done
[17:40:52.464] receiveMessageFromWorker() for ClusterFuture ...
[17:40:52.464] - Validating connection of MultisessionFuture
[17:40:52.464] - received message: FutureResult
[17:40:52.464] - Received FutureResult
[17:40:52.465] - Erased future from FutureRegistry
[17:40:52.465] result() for ClusterFuture ...
[17:40:52.465] - result already collected: FutureResult
[17:40:52.465] result() for ClusterFuture ... done
[17:40:52.465] signalConditions() ...
[17:40:52.465]  - include = ‘immediateCondition’
[17:40:52.465]  - exclude = 
[17:40:52.465]  - resignal = FALSE
[17:40:52.465]  - Number of conditions: 1
[17:40:52.465] signalConditions() ... done
[17:40:52.465] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:52.465] A MultisessionFuture was resolved (result was not collected)
[17:40:52.466] getGlobalsAndPackages() ...
[17:40:52.466] Searching for globals...
[17:40:52.466] - globals found: [2] ‘list’, ‘stop’
[17:40:52.466] Searching for globals ... DONE
[17:40:52.466] Resolving globals: FALSE
[17:40:52.467] 
[17:40:52.467] 
[17:40:52.467] getGlobalsAndPackages() ... DONE
[17:40:52.467] run() for ‘Future’ ...
[17:40:52.467] - state: ‘created’
[17:40:52.467] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:52.481] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:52.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:52.481]   - Field: ‘node’
[17:40:52.481]   - Field: ‘label’
[17:40:52.481]   - Field: ‘local’
[17:40:52.481]   - Field: ‘owner’
[17:40:52.481]   - Field: ‘envir’
[17:40:52.481]   - Field: ‘workers’
[17:40:52.482]   - Field: ‘packages’
[17:40:52.482]   - Field: ‘gc’
[17:40:52.482]   - Field: ‘conditions’
[17:40:52.482]   - Field: ‘persistent’
[17:40:52.482]   - Field: ‘expr’
[17:40:52.482]   - Field: ‘uuid’
[17:40:52.482]   - Field: ‘seed’
[17:40:52.482]   - Field: ‘version’
[17:40:52.482]   - Field: ‘result’
[17:40:52.482]   - Field: ‘asynchronous’
[17:40:52.482]   - Field: ‘calls’
[17:40:52.483]   - Field: ‘globals’
[17:40:52.483]   - Field: ‘stdout’
[17:40:52.483]   - Field: ‘earlySignal’
[17:40:52.483]   - Field: ‘lazy’
[17:40:52.483]   - Field: ‘state’
[17:40:52.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:52.483] - Launch lazy future ...
[17:40:52.483] Packages needed by the future expression (n = 0): <none>
[17:40:52.483] Packages needed by future strategies (n = 0): <none>
[17:40:52.484] {
[17:40:52.484]     {
[17:40:52.484]         {
[17:40:52.484]             ...future.startTime <- base::Sys.time()
[17:40:52.484]             {
[17:40:52.484]                 {
[17:40:52.484]                   {
[17:40:52.484]                     {
[17:40:52.484]                       base::local({
[17:40:52.484]                         has_future <- base::requireNamespace("future", 
[17:40:52.484]                           quietly = TRUE)
[17:40:52.484]                         if (has_future) {
[17:40:52.484]                           ns <- base::getNamespace("future")
[17:40:52.484]                           version <- ns[[".package"]][["version"]]
[17:40:52.484]                           if (is.null(version)) 
[17:40:52.484]                             version <- utils::packageVersion("future")
[17:40:52.484]                         }
[17:40:52.484]                         else {
[17:40:52.484]                           version <- NULL
[17:40:52.484]                         }
[17:40:52.484]                         if (!has_future || version < "1.8.0") {
[17:40:52.484]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:52.484]                             "", base::R.version$version.string), 
[17:40:52.484]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:52.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:52.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:52.484]                               "release", "version")], collapse = " "), 
[17:40:52.484]                             hostname = base::Sys.info()[["nodename"]])
[17:40:52.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:52.484]                             info)
[17:40:52.484]                           info <- base::paste(info, collapse = "; ")
[17:40:52.484]                           if (!has_future) {
[17:40:52.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:52.484]                               info)
[17:40:52.484]                           }
[17:40:52.484]                           else {
[17:40:52.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:52.484]                               info, version)
[17:40:52.484]                           }
[17:40:52.484]                           base::stop(msg)
[17:40:52.484]                         }
[17:40:52.484]                       })
[17:40:52.484]                     }
[17:40:52.484]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:52.484]                     base::options(mc.cores = 1L)
[17:40:52.484]                   }
[17:40:52.484]                   ...future.strategy.old <- future::plan("list")
[17:40:52.484]                   options(future.plan = NULL)
[17:40:52.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:52.484]                 }
[17:40:52.484]                 ...future.workdir <- getwd()
[17:40:52.484]             }
[17:40:52.484]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:52.484]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:52.484]         }
[17:40:52.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:52.484]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:52.484]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:52.484]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:52.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:52.484]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:52.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:52.484]             base::names(...future.oldOptions))
[17:40:52.484]     }
[17:40:52.484]     if (FALSE) {
[17:40:52.484]     }
[17:40:52.484]     else {
[17:40:52.484]         if (TRUE) {
[17:40:52.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:52.484]                 open = "w")
[17:40:52.484]         }
[17:40:52.484]         else {
[17:40:52.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:52.484]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:52.484]         }
[17:40:52.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:52.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:52.484]             base::sink(type = "output", split = FALSE)
[17:40:52.484]             base::close(...future.stdout)
[17:40:52.484]         }, add = TRUE)
[17:40:52.484]     }
[17:40:52.484]     ...future.frame <- base::sys.nframe()
[17:40:52.484]     ...future.conditions <- base::list()
[17:40:52.484]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:52.484]     if (FALSE) {
[17:40:52.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:52.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:52.484]     }
[17:40:52.484]     ...future.result <- base::tryCatch({
[17:40:52.484]         base::withCallingHandlers({
[17:40:52.484]             ...future.value <- base::withVisible(base::local({
[17:40:52.484]                 ...future.makeSendCondition <- base::local({
[17:40:52.484]                   sendCondition <- NULL
[17:40:52.484]                   function(frame = 1L) {
[17:40:52.484]                     if (is.function(sendCondition)) 
[17:40:52.484]                       return(sendCondition)
[17:40:52.484]                     ns <- getNamespace("parallel")
[17:40:52.484]                     if (exists("sendData", mode = "function", 
[17:40:52.484]                       envir = ns)) {
[17:40:52.484]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:52.484]                         envir = ns)
[17:40:52.484]                       envir <- sys.frame(frame)
[17:40:52.484]                       master <- NULL
[17:40:52.484]                       while (!identical(envir, .GlobalEnv) && 
[17:40:52.484]                         !identical(envir, emptyenv())) {
[17:40:52.484]                         if (exists("master", mode = "list", envir = envir, 
[17:40:52.484]                           inherits = FALSE)) {
[17:40:52.484]                           master <- get("master", mode = "list", 
[17:40:52.484]                             envir = envir, inherits = FALSE)
[17:40:52.484]                           if (inherits(master, c("SOCKnode", 
[17:40:52.484]                             "SOCK0node"))) {
[17:40:52.484]                             sendCondition <<- function(cond) {
[17:40:52.484]                               data <- list(type = "VALUE", value = cond, 
[17:40:52.484]                                 success = TRUE)
[17:40:52.484]                               parallel_sendData(master, data)
[17:40:52.484]                             }
[17:40:52.484]                             return(sendCondition)
[17:40:52.484]                           }
[17:40:52.484]                         }
[17:40:52.484]                         frame <- frame + 1L
[17:40:52.484]                         envir <- sys.frame(frame)
[17:40:52.484]                       }
[17:40:52.484]                     }
[17:40:52.484]                     sendCondition <<- function(cond) NULL
[17:40:52.484]                   }
[17:40:52.484]                 })
[17:40:52.484]                 withCallingHandlers({
[17:40:52.484]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:52.484]                 }, immediateCondition = function(cond) {
[17:40:52.484]                   sendCondition <- ...future.makeSendCondition()
[17:40:52.484]                   sendCondition(cond)
[17:40:52.484]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.484]                   {
[17:40:52.484]                     inherits <- base::inherits
[17:40:52.484]                     invokeRestart <- base::invokeRestart
[17:40:52.484]                     is.null <- base::is.null
[17:40:52.484]                     muffled <- FALSE
[17:40:52.484]                     if (inherits(cond, "message")) {
[17:40:52.484]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:52.484]                       if (muffled) 
[17:40:52.484]                         invokeRestart("muffleMessage")
[17:40:52.484]                     }
[17:40:52.484]                     else if (inherits(cond, "warning")) {
[17:40:52.484]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:52.484]                       if (muffled) 
[17:40:52.484]                         invokeRestart("muffleWarning")
[17:40:52.484]                     }
[17:40:52.484]                     else if (inherits(cond, "condition")) {
[17:40:52.484]                       if (!is.null(pattern)) {
[17:40:52.484]                         computeRestarts <- base::computeRestarts
[17:40:52.484]                         grepl <- base::grepl
[17:40:52.484]                         restarts <- computeRestarts(cond)
[17:40:52.484]                         for (restart in restarts) {
[17:40:52.484]                           name <- restart$name
[17:40:52.484]                           if (is.null(name)) 
[17:40:52.484]                             next
[17:40:52.484]                           if (!grepl(pattern, name)) 
[17:40:52.484]                             next
[17:40:52.484]                           invokeRestart(restart)
[17:40:52.484]                           muffled <- TRUE
[17:40:52.484]                           break
[17:40:52.484]                         }
[17:40:52.484]                       }
[17:40:52.484]                     }
[17:40:52.484]                     invisible(muffled)
[17:40:52.484]                   }
[17:40:52.484]                   muffleCondition(cond)
[17:40:52.484]                 })
[17:40:52.484]             }))
[17:40:52.484]             future::FutureResult(value = ...future.value$value, 
[17:40:52.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.484]                   ...future.rng), globalenv = if (FALSE) 
[17:40:52.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:52.484]                     ...future.globalenv.names))
[17:40:52.484]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:52.484]         }, condition = base::local({
[17:40:52.484]             c <- base::c
[17:40:52.484]             inherits <- base::inherits
[17:40:52.484]             invokeRestart <- base::invokeRestart
[17:40:52.484]             length <- base::length
[17:40:52.484]             list <- base::list
[17:40:52.484]             seq.int <- base::seq.int
[17:40:52.484]             signalCondition <- base::signalCondition
[17:40:52.484]             sys.calls <- base::sys.calls
[17:40:52.484]             `[[` <- base::`[[`
[17:40:52.484]             `+` <- base::`+`
[17:40:52.484]             `<<-` <- base::`<<-`
[17:40:52.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:52.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:52.484]                   3L)]
[17:40:52.484]             }
[17:40:52.484]             function(cond) {
[17:40:52.484]                 is_error <- inherits(cond, "error")
[17:40:52.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:52.484]                   NULL)
[17:40:52.484]                 if (is_error) {
[17:40:52.484]                   sessionInformation <- function() {
[17:40:52.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:52.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:52.484]                       search = base::search(), system = base::Sys.info())
[17:40:52.484]                   }
[17:40:52.484]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:52.484]                     cond$call), session = sessionInformation(), 
[17:40:52.484]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:52.484]                   signalCondition(cond)
[17:40:52.484]                 }
[17:40:52.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:52.484]                 "immediateCondition"))) {
[17:40:52.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:52.484]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:52.484]                   if (TRUE && !signal) {
[17:40:52.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.484]                     {
[17:40:52.484]                       inherits <- base::inherits
[17:40:52.484]                       invokeRestart <- base::invokeRestart
[17:40:52.484]                       is.null <- base::is.null
[17:40:52.484]                       muffled <- FALSE
[17:40:52.484]                       if (inherits(cond, "message")) {
[17:40:52.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.484]                         if (muffled) 
[17:40:52.484]                           invokeRestart("muffleMessage")
[17:40:52.484]                       }
[17:40:52.484]                       else if (inherits(cond, "warning")) {
[17:40:52.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.484]                         if (muffled) 
[17:40:52.484]                           invokeRestart("muffleWarning")
[17:40:52.484]                       }
[17:40:52.484]                       else if (inherits(cond, "condition")) {
[17:40:52.484]                         if (!is.null(pattern)) {
[17:40:52.484]                           computeRestarts <- base::computeRestarts
[17:40:52.484]                           grepl <- base::grepl
[17:40:52.484]                           restarts <- computeRestarts(cond)
[17:40:52.484]                           for (restart in restarts) {
[17:40:52.484]                             name <- restart$name
[17:40:52.484]                             if (is.null(name)) 
[17:40:52.484]                               next
[17:40:52.484]                             if (!grepl(pattern, name)) 
[17:40:52.484]                               next
[17:40:52.484]                             invokeRestart(restart)
[17:40:52.484]                             muffled <- TRUE
[17:40:52.484]                             break
[17:40:52.484]                           }
[17:40:52.484]                         }
[17:40:52.484]                       }
[17:40:52.484]                       invisible(muffled)
[17:40:52.484]                     }
[17:40:52.484]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.484]                   }
[17:40:52.484]                 }
[17:40:52.484]                 else {
[17:40:52.484]                   if (TRUE) {
[17:40:52.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.484]                     {
[17:40:52.484]                       inherits <- base::inherits
[17:40:52.484]                       invokeRestart <- base::invokeRestart
[17:40:52.484]                       is.null <- base::is.null
[17:40:52.484]                       muffled <- FALSE
[17:40:52.484]                       if (inherits(cond, "message")) {
[17:40:52.484]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.484]                         if (muffled) 
[17:40:52.484]                           invokeRestart("muffleMessage")
[17:40:52.484]                       }
[17:40:52.484]                       else if (inherits(cond, "warning")) {
[17:40:52.484]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.484]                         if (muffled) 
[17:40:52.484]                           invokeRestart("muffleWarning")
[17:40:52.484]                       }
[17:40:52.484]                       else if (inherits(cond, "condition")) {
[17:40:52.484]                         if (!is.null(pattern)) {
[17:40:52.484]                           computeRestarts <- base::computeRestarts
[17:40:52.484]                           grepl <- base::grepl
[17:40:52.484]                           restarts <- computeRestarts(cond)
[17:40:52.484]                           for (restart in restarts) {
[17:40:52.484]                             name <- restart$name
[17:40:52.484]                             if (is.null(name)) 
[17:40:52.484]                               next
[17:40:52.484]                             if (!grepl(pattern, name)) 
[17:40:52.484]                               next
[17:40:52.484]                             invokeRestart(restart)
[17:40:52.484]                             muffled <- TRUE
[17:40:52.484]                             break
[17:40:52.484]                           }
[17:40:52.484]                         }
[17:40:52.484]                       }
[17:40:52.484]                       invisible(muffled)
[17:40:52.484]                     }
[17:40:52.484]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.484]                   }
[17:40:52.484]                 }
[17:40:52.484]             }
[17:40:52.484]         }))
[17:40:52.484]     }, error = function(ex) {
[17:40:52.484]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:52.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.484]                 ...future.rng), started = ...future.startTime, 
[17:40:52.484]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:52.484]             version = "1.8"), class = "FutureResult")
[17:40:52.484]     }, finally = {
[17:40:52.484]         if (!identical(...future.workdir, getwd())) 
[17:40:52.484]             setwd(...future.workdir)
[17:40:52.484]         {
[17:40:52.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:52.484]                 ...future.oldOptions$nwarnings <- NULL
[17:40:52.484]             }
[17:40:52.484]             base::options(...future.oldOptions)
[17:40:52.484]             if (.Platform$OS.type == "windows") {
[17:40:52.484]                 old_names <- names(...future.oldEnvVars)
[17:40:52.484]                 envs <- base::Sys.getenv()
[17:40:52.484]                 names <- names(envs)
[17:40:52.484]                 common <- intersect(names, old_names)
[17:40:52.484]                 added <- setdiff(names, old_names)
[17:40:52.484]                 removed <- setdiff(old_names, names)
[17:40:52.484]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:52.484]                   envs[common]]
[17:40:52.484]                 NAMES <- toupper(changed)
[17:40:52.484]                 args <- list()
[17:40:52.484]                 for (kk in seq_along(NAMES)) {
[17:40:52.484]                   name <- changed[[kk]]
[17:40:52.484]                   NAME <- NAMES[[kk]]
[17:40:52.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.484]                     next
[17:40:52.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.484]                 }
[17:40:52.484]                 NAMES <- toupper(added)
[17:40:52.484]                 for (kk in seq_along(NAMES)) {
[17:40:52.484]                   name <- added[[kk]]
[17:40:52.484]                   NAME <- NAMES[[kk]]
[17:40:52.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.484]                     next
[17:40:52.484]                   args[[name]] <- ""
[17:40:52.484]                 }
[17:40:52.484]                 NAMES <- toupper(removed)
[17:40:52.484]                 for (kk in seq_along(NAMES)) {
[17:40:52.484]                   name <- removed[[kk]]
[17:40:52.484]                   NAME <- NAMES[[kk]]
[17:40:52.484]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.484]                     next
[17:40:52.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.484]                 }
[17:40:52.484]                 if (length(args) > 0) 
[17:40:52.484]                   base::do.call(base::Sys.setenv, args = args)
[17:40:52.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:52.484]             }
[17:40:52.484]             else {
[17:40:52.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:52.484]             }
[17:40:52.484]             {
[17:40:52.484]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:52.484]                   0L) {
[17:40:52.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:52.484]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:52.484]                   base::options(opts)
[17:40:52.484]                 }
[17:40:52.484]                 {
[17:40:52.484]                   {
[17:40:52.484]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:52.484]                     NULL
[17:40:52.484]                   }
[17:40:52.484]                   options(future.plan = NULL)
[17:40:52.484]                   if (is.na(NA_character_)) 
[17:40:52.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:52.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:52.484]                     .init = FALSE)
[17:40:52.484]                 }
[17:40:52.484]             }
[17:40:52.484]         }
[17:40:52.484]     })
[17:40:52.484]     if (TRUE) {
[17:40:52.484]         base::sink(type = "output", split = FALSE)
[17:40:52.484]         if (TRUE) {
[17:40:52.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:52.484]         }
[17:40:52.484]         else {
[17:40:52.484]             ...future.result["stdout"] <- base::list(NULL)
[17:40:52.484]         }
[17:40:52.484]         base::close(...future.stdout)
[17:40:52.484]         ...future.stdout <- NULL
[17:40:52.484]     }
[17:40:52.484]     ...future.result$conditions <- ...future.conditions
[17:40:52.484]     ...future.result$finished <- base::Sys.time()
[17:40:52.484]     ...future.result
[17:40:52.484] }
[17:40:52.487] MultisessionFuture started
[17:40:52.487] - Launch lazy future ... done
[17:40:52.487] run() for ‘MultisessionFuture’ ... done
[17:40:52.488] receiveMessageFromWorker() for ClusterFuture ...
[17:40:52.489] - Validating connection of MultisessionFuture
[17:40:52.489] - received message: FutureResult
[17:40:52.489] - Received FutureResult
[17:40:52.489] - Erased future from FutureRegistry
[17:40:52.490] result() for ClusterFuture ...
[17:40:52.490] - result already collected: FutureResult
[17:40:52.490] result() for ClusterFuture ... done
[17:40:52.490] signalConditions() ...
[17:40:52.490]  - include = ‘immediateCondition’
[17:40:52.490]  - exclude = 
[17:40:52.490]  - resignal = FALSE
[17:40:52.490]  - Number of conditions: 1
[17:40:52.490] signalConditions() ... done
[17:40:52.490] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:52.490] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[17:40:52.491] getGlobalsAndPackages() ...
[17:40:52.491] Searching for globals...
[17:40:52.492] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:52.492] Searching for globals ... DONE
[17:40:52.492] Resolving globals: FALSE
[17:40:52.492] 
[17:40:52.492] 
[17:40:52.492] getGlobalsAndPackages() ... DONE
[17:40:52.493] run() for ‘Future’ ...
[17:40:52.493] - state: ‘created’
[17:40:52.493] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:52.506] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:52.506] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:52.506]   - Field: ‘node’
[17:40:52.507]   - Field: ‘label’
[17:40:52.507]   - Field: ‘local’
[17:40:52.507]   - Field: ‘owner’
[17:40:52.507]   - Field: ‘envir’
[17:40:52.507]   - Field: ‘workers’
[17:40:52.507]   - Field: ‘packages’
[17:40:52.507]   - Field: ‘gc’
[17:40:52.507]   - Field: ‘conditions’
[17:40:52.507]   - Field: ‘persistent’
[17:40:52.507]   - Field: ‘expr’
[17:40:52.507]   - Field: ‘uuid’
[17:40:52.508]   - Field: ‘seed’
[17:40:52.508]   - Field: ‘version’
[17:40:52.508]   - Field: ‘result’
[17:40:52.508]   - Field: ‘asynchronous’
[17:40:52.508]   - Field: ‘calls’
[17:40:52.508]   - Field: ‘globals’
[17:40:52.508]   - Field: ‘stdout’
[17:40:52.508]   - Field: ‘earlySignal’
[17:40:52.508]   - Field: ‘lazy’
[17:40:52.508]   - Field: ‘state’
[17:40:52.508] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:52.509] - Launch lazy future ...
[17:40:52.509] Packages needed by the future expression (n = 0): <none>
[17:40:52.509] Packages needed by future strategies (n = 0): <none>
[17:40:52.509] {
[17:40:52.509]     {
[17:40:52.509]         {
[17:40:52.509]             ...future.startTime <- base::Sys.time()
[17:40:52.509]             {
[17:40:52.509]                 {
[17:40:52.509]                   {
[17:40:52.509]                     {
[17:40:52.509]                       base::local({
[17:40:52.509]                         has_future <- base::requireNamespace("future", 
[17:40:52.509]                           quietly = TRUE)
[17:40:52.509]                         if (has_future) {
[17:40:52.509]                           ns <- base::getNamespace("future")
[17:40:52.509]                           version <- ns[[".package"]][["version"]]
[17:40:52.509]                           if (is.null(version)) 
[17:40:52.509]                             version <- utils::packageVersion("future")
[17:40:52.509]                         }
[17:40:52.509]                         else {
[17:40:52.509]                           version <- NULL
[17:40:52.509]                         }
[17:40:52.509]                         if (!has_future || version < "1.8.0") {
[17:40:52.509]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:52.509]                             "", base::R.version$version.string), 
[17:40:52.509]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:52.509]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:52.509]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:52.509]                               "release", "version")], collapse = " "), 
[17:40:52.509]                             hostname = base::Sys.info()[["nodename"]])
[17:40:52.509]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:52.509]                             info)
[17:40:52.509]                           info <- base::paste(info, collapse = "; ")
[17:40:52.509]                           if (!has_future) {
[17:40:52.509]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:52.509]                               info)
[17:40:52.509]                           }
[17:40:52.509]                           else {
[17:40:52.509]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:52.509]                               info, version)
[17:40:52.509]                           }
[17:40:52.509]                           base::stop(msg)
[17:40:52.509]                         }
[17:40:52.509]                       })
[17:40:52.509]                     }
[17:40:52.509]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:52.509]                     base::options(mc.cores = 1L)
[17:40:52.509]                   }
[17:40:52.509]                   ...future.strategy.old <- future::plan("list")
[17:40:52.509]                   options(future.plan = NULL)
[17:40:52.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:52.509]                 }
[17:40:52.509]                 ...future.workdir <- getwd()
[17:40:52.509]             }
[17:40:52.509]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:52.509]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:52.509]         }
[17:40:52.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:52.509]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:52.509]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:52.509]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:52.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:52.509]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:52.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:52.509]             base::names(...future.oldOptions))
[17:40:52.509]     }
[17:40:52.509]     if (FALSE) {
[17:40:52.509]     }
[17:40:52.509]     else {
[17:40:52.509]         if (TRUE) {
[17:40:52.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:52.509]                 open = "w")
[17:40:52.509]         }
[17:40:52.509]         else {
[17:40:52.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:52.509]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:52.509]         }
[17:40:52.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:52.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:52.509]             base::sink(type = "output", split = FALSE)
[17:40:52.509]             base::close(...future.stdout)
[17:40:52.509]         }, add = TRUE)
[17:40:52.509]     }
[17:40:52.509]     ...future.frame <- base::sys.nframe()
[17:40:52.509]     ...future.conditions <- base::list()
[17:40:52.509]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:52.509]     if (FALSE) {
[17:40:52.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:52.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:52.509]     }
[17:40:52.509]     ...future.result <- base::tryCatch({
[17:40:52.509]         base::withCallingHandlers({
[17:40:52.509]             ...future.value <- base::withVisible(base::local({
[17:40:52.509]                 ...future.makeSendCondition <- base::local({
[17:40:52.509]                   sendCondition <- NULL
[17:40:52.509]                   function(frame = 1L) {
[17:40:52.509]                     if (is.function(sendCondition)) 
[17:40:52.509]                       return(sendCondition)
[17:40:52.509]                     ns <- getNamespace("parallel")
[17:40:52.509]                     if (exists("sendData", mode = "function", 
[17:40:52.509]                       envir = ns)) {
[17:40:52.509]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:52.509]                         envir = ns)
[17:40:52.509]                       envir <- sys.frame(frame)
[17:40:52.509]                       master <- NULL
[17:40:52.509]                       while (!identical(envir, .GlobalEnv) && 
[17:40:52.509]                         !identical(envir, emptyenv())) {
[17:40:52.509]                         if (exists("master", mode = "list", envir = envir, 
[17:40:52.509]                           inherits = FALSE)) {
[17:40:52.509]                           master <- get("master", mode = "list", 
[17:40:52.509]                             envir = envir, inherits = FALSE)
[17:40:52.509]                           if (inherits(master, c("SOCKnode", 
[17:40:52.509]                             "SOCK0node"))) {
[17:40:52.509]                             sendCondition <<- function(cond) {
[17:40:52.509]                               data <- list(type = "VALUE", value = cond, 
[17:40:52.509]                                 success = TRUE)
[17:40:52.509]                               parallel_sendData(master, data)
[17:40:52.509]                             }
[17:40:52.509]                             return(sendCondition)
[17:40:52.509]                           }
[17:40:52.509]                         }
[17:40:52.509]                         frame <- frame + 1L
[17:40:52.509]                         envir <- sys.frame(frame)
[17:40:52.509]                       }
[17:40:52.509]                     }
[17:40:52.509]                     sendCondition <<- function(cond) NULL
[17:40:52.509]                   }
[17:40:52.509]                 })
[17:40:52.509]                 withCallingHandlers({
[17:40:52.509]                   {
[17:40:52.509]                     Sys.sleep(0.5)
[17:40:52.509]                     list(a = 1, b = 42L)
[17:40:52.509]                   }
[17:40:52.509]                 }, immediateCondition = function(cond) {
[17:40:52.509]                   sendCondition <- ...future.makeSendCondition()
[17:40:52.509]                   sendCondition(cond)
[17:40:52.509]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.509]                   {
[17:40:52.509]                     inherits <- base::inherits
[17:40:52.509]                     invokeRestart <- base::invokeRestart
[17:40:52.509]                     is.null <- base::is.null
[17:40:52.509]                     muffled <- FALSE
[17:40:52.509]                     if (inherits(cond, "message")) {
[17:40:52.509]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:52.509]                       if (muffled) 
[17:40:52.509]                         invokeRestart("muffleMessage")
[17:40:52.509]                     }
[17:40:52.509]                     else if (inherits(cond, "warning")) {
[17:40:52.509]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:52.509]                       if (muffled) 
[17:40:52.509]                         invokeRestart("muffleWarning")
[17:40:52.509]                     }
[17:40:52.509]                     else if (inherits(cond, "condition")) {
[17:40:52.509]                       if (!is.null(pattern)) {
[17:40:52.509]                         computeRestarts <- base::computeRestarts
[17:40:52.509]                         grepl <- base::grepl
[17:40:52.509]                         restarts <- computeRestarts(cond)
[17:40:52.509]                         for (restart in restarts) {
[17:40:52.509]                           name <- restart$name
[17:40:52.509]                           if (is.null(name)) 
[17:40:52.509]                             next
[17:40:52.509]                           if (!grepl(pattern, name)) 
[17:40:52.509]                             next
[17:40:52.509]                           invokeRestart(restart)
[17:40:52.509]                           muffled <- TRUE
[17:40:52.509]                           break
[17:40:52.509]                         }
[17:40:52.509]                       }
[17:40:52.509]                     }
[17:40:52.509]                     invisible(muffled)
[17:40:52.509]                   }
[17:40:52.509]                   muffleCondition(cond)
[17:40:52.509]                 })
[17:40:52.509]             }))
[17:40:52.509]             future::FutureResult(value = ...future.value$value, 
[17:40:52.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.509]                   ...future.rng), globalenv = if (FALSE) 
[17:40:52.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:52.509]                     ...future.globalenv.names))
[17:40:52.509]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:52.509]         }, condition = base::local({
[17:40:52.509]             c <- base::c
[17:40:52.509]             inherits <- base::inherits
[17:40:52.509]             invokeRestart <- base::invokeRestart
[17:40:52.509]             length <- base::length
[17:40:52.509]             list <- base::list
[17:40:52.509]             seq.int <- base::seq.int
[17:40:52.509]             signalCondition <- base::signalCondition
[17:40:52.509]             sys.calls <- base::sys.calls
[17:40:52.509]             `[[` <- base::`[[`
[17:40:52.509]             `+` <- base::`+`
[17:40:52.509]             `<<-` <- base::`<<-`
[17:40:52.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:52.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:52.509]                   3L)]
[17:40:52.509]             }
[17:40:52.509]             function(cond) {
[17:40:52.509]                 is_error <- inherits(cond, "error")
[17:40:52.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:52.509]                   NULL)
[17:40:52.509]                 if (is_error) {
[17:40:52.509]                   sessionInformation <- function() {
[17:40:52.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:52.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:52.509]                       search = base::search(), system = base::Sys.info())
[17:40:52.509]                   }
[17:40:52.509]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:52.509]                     cond$call), session = sessionInformation(), 
[17:40:52.509]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:52.509]                   signalCondition(cond)
[17:40:52.509]                 }
[17:40:52.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:52.509]                 "immediateCondition"))) {
[17:40:52.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:52.509]                   ...future.conditions[[length(...future.conditions) + 
[17:40:52.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:52.509]                   if (TRUE && !signal) {
[17:40:52.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.509]                     {
[17:40:52.509]                       inherits <- base::inherits
[17:40:52.509]                       invokeRestart <- base::invokeRestart
[17:40:52.509]                       is.null <- base::is.null
[17:40:52.509]                       muffled <- FALSE
[17:40:52.509]                       if (inherits(cond, "message")) {
[17:40:52.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.509]                         if (muffled) 
[17:40:52.509]                           invokeRestart("muffleMessage")
[17:40:52.509]                       }
[17:40:52.509]                       else if (inherits(cond, "warning")) {
[17:40:52.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.509]                         if (muffled) 
[17:40:52.509]                           invokeRestart("muffleWarning")
[17:40:52.509]                       }
[17:40:52.509]                       else if (inherits(cond, "condition")) {
[17:40:52.509]                         if (!is.null(pattern)) {
[17:40:52.509]                           computeRestarts <- base::computeRestarts
[17:40:52.509]                           grepl <- base::grepl
[17:40:52.509]                           restarts <- computeRestarts(cond)
[17:40:52.509]                           for (restart in restarts) {
[17:40:52.509]                             name <- restart$name
[17:40:52.509]                             if (is.null(name)) 
[17:40:52.509]                               next
[17:40:52.509]                             if (!grepl(pattern, name)) 
[17:40:52.509]                               next
[17:40:52.509]                             invokeRestart(restart)
[17:40:52.509]                             muffled <- TRUE
[17:40:52.509]                             break
[17:40:52.509]                           }
[17:40:52.509]                         }
[17:40:52.509]                       }
[17:40:52.509]                       invisible(muffled)
[17:40:52.509]                     }
[17:40:52.509]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.509]                   }
[17:40:52.509]                 }
[17:40:52.509]                 else {
[17:40:52.509]                   if (TRUE) {
[17:40:52.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:52.509]                     {
[17:40:52.509]                       inherits <- base::inherits
[17:40:52.509]                       invokeRestart <- base::invokeRestart
[17:40:52.509]                       is.null <- base::is.null
[17:40:52.509]                       muffled <- FALSE
[17:40:52.509]                       if (inherits(cond, "message")) {
[17:40:52.509]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:52.509]                         if (muffled) 
[17:40:52.509]                           invokeRestart("muffleMessage")
[17:40:52.509]                       }
[17:40:52.509]                       else if (inherits(cond, "warning")) {
[17:40:52.509]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:52.509]                         if (muffled) 
[17:40:52.509]                           invokeRestart("muffleWarning")
[17:40:52.509]                       }
[17:40:52.509]                       else if (inherits(cond, "condition")) {
[17:40:52.509]                         if (!is.null(pattern)) {
[17:40:52.509]                           computeRestarts <- base::computeRestarts
[17:40:52.509]                           grepl <- base::grepl
[17:40:52.509]                           restarts <- computeRestarts(cond)
[17:40:52.509]                           for (restart in restarts) {
[17:40:52.509]                             name <- restart$name
[17:40:52.509]                             if (is.null(name)) 
[17:40:52.509]                               next
[17:40:52.509]                             if (!grepl(pattern, name)) 
[17:40:52.509]                               next
[17:40:52.509]                             invokeRestart(restart)
[17:40:52.509]                             muffled <- TRUE
[17:40:52.509]                             break
[17:40:52.509]                           }
[17:40:52.509]                         }
[17:40:52.509]                       }
[17:40:52.509]                       invisible(muffled)
[17:40:52.509]                     }
[17:40:52.509]                     muffleCondition(cond, pattern = "^muffle")
[17:40:52.509]                   }
[17:40:52.509]                 }
[17:40:52.509]             }
[17:40:52.509]         }))
[17:40:52.509]     }, error = function(ex) {
[17:40:52.509]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:52.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:52.509]                 ...future.rng), started = ...future.startTime, 
[17:40:52.509]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:52.509]             version = "1.8"), class = "FutureResult")
[17:40:52.509]     }, finally = {
[17:40:52.509]         if (!identical(...future.workdir, getwd())) 
[17:40:52.509]             setwd(...future.workdir)
[17:40:52.509]         {
[17:40:52.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:52.509]                 ...future.oldOptions$nwarnings <- NULL
[17:40:52.509]             }
[17:40:52.509]             base::options(...future.oldOptions)
[17:40:52.509]             if (.Platform$OS.type == "windows") {
[17:40:52.509]                 old_names <- names(...future.oldEnvVars)
[17:40:52.509]                 envs <- base::Sys.getenv()
[17:40:52.509]                 names <- names(envs)
[17:40:52.509]                 common <- intersect(names, old_names)
[17:40:52.509]                 added <- setdiff(names, old_names)
[17:40:52.509]                 removed <- setdiff(old_names, names)
[17:40:52.509]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:52.509]                   envs[common]]
[17:40:52.509]                 NAMES <- toupper(changed)
[17:40:52.509]                 args <- list()
[17:40:52.509]                 for (kk in seq_along(NAMES)) {
[17:40:52.509]                   name <- changed[[kk]]
[17:40:52.509]                   NAME <- NAMES[[kk]]
[17:40:52.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.509]                     next
[17:40:52.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.509]                 }
[17:40:52.509]                 NAMES <- toupper(added)
[17:40:52.509]                 for (kk in seq_along(NAMES)) {
[17:40:52.509]                   name <- added[[kk]]
[17:40:52.509]                   NAME <- NAMES[[kk]]
[17:40:52.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.509]                     next
[17:40:52.509]                   args[[name]] <- ""
[17:40:52.509]                 }
[17:40:52.509]                 NAMES <- toupper(removed)
[17:40:52.509]                 for (kk in seq_along(NAMES)) {
[17:40:52.509]                   name <- removed[[kk]]
[17:40:52.509]                   NAME <- NAMES[[kk]]
[17:40:52.509]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:52.509]                     next
[17:40:52.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:52.509]                 }
[17:40:52.509]                 if (length(args) > 0) 
[17:40:52.509]                   base::do.call(base::Sys.setenv, args = args)
[17:40:52.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:52.509]             }
[17:40:52.509]             else {
[17:40:52.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:52.509]             }
[17:40:52.509]             {
[17:40:52.509]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:52.509]                   0L) {
[17:40:52.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:52.509]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:52.509]                   base::options(opts)
[17:40:52.509]                 }
[17:40:52.509]                 {
[17:40:52.509]                   {
[17:40:52.509]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:52.509]                     NULL
[17:40:52.509]                   }
[17:40:52.509]                   options(future.plan = NULL)
[17:40:52.509]                   if (is.na(NA_character_)) 
[17:40:52.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:52.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:52.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:52.509]                     .init = FALSE)
[17:40:52.509]                 }
[17:40:52.509]             }
[17:40:52.509]         }
[17:40:52.509]     })
[17:40:52.509]     if (TRUE) {
[17:40:52.509]         base::sink(type = "output", split = FALSE)
[17:40:52.509]         if (TRUE) {
[17:40:52.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:52.509]         }
[17:40:52.509]         else {
[17:40:52.509]             ...future.result["stdout"] <- base::list(NULL)
[17:40:52.509]         }
[17:40:52.509]         base::close(...future.stdout)
[17:40:52.509]         ...future.stdout <- NULL
[17:40:52.509]     }
[17:40:52.509]     ...future.result$conditions <- ...future.conditions
[17:40:52.509]     ...future.result$finished <- base::Sys.time()
[17:40:52.509]     ...future.result
[17:40:52.509] }
[17:40:52.512] MultisessionFuture started
[17:40:52.512] - Launch lazy future ... done
[17:40:52.512] run() for ‘MultisessionFuture’ ... done
[17:40:53.014] receiveMessageFromWorker() for ClusterFuture ...
[17:40:53.015] - Validating connection of MultisessionFuture
[17:40:53.015] - received message: FutureResult
[17:40:53.015] - Received FutureResult
[17:40:53.015] - Erased future from FutureRegistry
[17:40:53.015] result() for ClusterFuture ...
[17:40:53.015] - result already collected: FutureResult
[17:40:53.015] result() for ClusterFuture ... done
[17:40:53.015] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:53.016] A MultisessionFuture was resolved
[17:40:53.016] getGlobalsAndPackages() ...
[17:40:53.016] Searching for globals...
[17:40:53.017] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:53.017] Searching for globals ... DONE
[17:40:53.017] Resolving globals: FALSE
[17:40:53.017] 
[17:40:53.018] 
[17:40:53.018] getGlobalsAndPackages() ... DONE
[17:40:53.018] run() for ‘Future’ ...
[17:40:53.018] - state: ‘created’
[17:40:53.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:53.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:53.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:53.032]   - Field: ‘node’
[17:40:53.032]   - Field: ‘label’
[17:40:53.033]   - Field: ‘local’
[17:40:53.033]   - Field: ‘owner’
[17:40:53.033]   - Field: ‘envir’
[17:40:53.033]   - Field: ‘workers’
[17:40:53.033]   - Field: ‘packages’
[17:40:53.033]   - Field: ‘gc’
[17:40:53.033]   - Field: ‘conditions’
[17:40:53.033]   - Field: ‘persistent’
[17:40:53.033]   - Field: ‘expr’
[17:40:53.033]   - Field: ‘uuid’
[17:40:53.034]   - Field: ‘seed’
[17:40:53.034]   - Field: ‘version’
[17:40:53.034]   - Field: ‘result’
[17:40:53.034]   - Field: ‘asynchronous’
[17:40:53.034]   - Field: ‘calls’
[17:40:53.034]   - Field: ‘globals’
[17:40:53.034]   - Field: ‘stdout’
[17:40:53.034]   - Field: ‘earlySignal’
[17:40:53.034]   - Field: ‘lazy’
[17:40:53.034]   - Field: ‘state’
[17:40:53.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:53.034] - Launch lazy future ...
[17:40:53.035] Packages needed by the future expression (n = 0): <none>
[17:40:53.035] Packages needed by future strategies (n = 0): <none>
[17:40:53.035] {
[17:40:53.035]     {
[17:40:53.035]         {
[17:40:53.035]             ...future.startTime <- base::Sys.time()
[17:40:53.035]             {
[17:40:53.035]                 {
[17:40:53.035]                   {
[17:40:53.035]                     {
[17:40:53.035]                       base::local({
[17:40:53.035]                         has_future <- base::requireNamespace("future", 
[17:40:53.035]                           quietly = TRUE)
[17:40:53.035]                         if (has_future) {
[17:40:53.035]                           ns <- base::getNamespace("future")
[17:40:53.035]                           version <- ns[[".package"]][["version"]]
[17:40:53.035]                           if (is.null(version)) 
[17:40:53.035]                             version <- utils::packageVersion("future")
[17:40:53.035]                         }
[17:40:53.035]                         else {
[17:40:53.035]                           version <- NULL
[17:40:53.035]                         }
[17:40:53.035]                         if (!has_future || version < "1.8.0") {
[17:40:53.035]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.035]                             "", base::R.version$version.string), 
[17:40:53.035]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.035]                               "release", "version")], collapse = " "), 
[17:40:53.035]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.035]                             info)
[17:40:53.035]                           info <- base::paste(info, collapse = "; ")
[17:40:53.035]                           if (!has_future) {
[17:40:53.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.035]                               info)
[17:40:53.035]                           }
[17:40:53.035]                           else {
[17:40:53.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.035]                               info, version)
[17:40:53.035]                           }
[17:40:53.035]                           base::stop(msg)
[17:40:53.035]                         }
[17:40:53.035]                       })
[17:40:53.035]                     }
[17:40:53.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:53.035]                     base::options(mc.cores = 1L)
[17:40:53.035]                   }
[17:40:53.035]                   ...future.strategy.old <- future::plan("list")
[17:40:53.035]                   options(future.plan = NULL)
[17:40:53.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.035]                 }
[17:40:53.035]                 ...future.workdir <- getwd()
[17:40:53.035]             }
[17:40:53.035]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.035]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.035]         }
[17:40:53.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:53.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.035]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.035]             base::names(...future.oldOptions))
[17:40:53.035]     }
[17:40:53.035]     if (FALSE) {
[17:40:53.035]     }
[17:40:53.035]     else {
[17:40:53.035]         if (TRUE) {
[17:40:53.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.035]                 open = "w")
[17:40:53.035]         }
[17:40:53.035]         else {
[17:40:53.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.035]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.035]         }
[17:40:53.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.035]             base::sink(type = "output", split = FALSE)
[17:40:53.035]             base::close(...future.stdout)
[17:40:53.035]         }, add = TRUE)
[17:40:53.035]     }
[17:40:53.035]     ...future.frame <- base::sys.nframe()
[17:40:53.035]     ...future.conditions <- base::list()
[17:40:53.035]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.035]     if (FALSE) {
[17:40:53.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.035]     }
[17:40:53.035]     ...future.result <- base::tryCatch({
[17:40:53.035]         base::withCallingHandlers({
[17:40:53.035]             ...future.value <- base::withVisible(base::local({
[17:40:53.035]                 ...future.makeSendCondition <- base::local({
[17:40:53.035]                   sendCondition <- NULL
[17:40:53.035]                   function(frame = 1L) {
[17:40:53.035]                     if (is.function(sendCondition)) 
[17:40:53.035]                       return(sendCondition)
[17:40:53.035]                     ns <- getNamespace("parallel")
[17:40:53.035]                     if (exists("sendData", mode = "function", 
[17:40:53.035]                       envir = ns)) {
[17:40:53.035]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:53.035]                         envir = ns)
[17:40:53.035]                       envir <- sys.frame(frame)
[17:40:53.035]                       master <- NULL
[17:40:53.035]                       while (!identical(envir, .GlobalEnv) && 
[17:40:53.035]                         !identical(envir, emptyenv())) {
[17:40:53.035]                         if (exists("master", mode = "list", envir = envir, 
[17:40:53.035]                           inherits = FALSE)) {
[17:40:53.035]                           master <- get("master", mode = "list", 
[17:40:53.035]                             envir = envir, inherits = FALSE)
[17:40:53.035]                           if (inherits(master, c("SOCKnode", 
[17:40:53.035]                             "SOCK0node"))) {
[17:40:53.035]                             sendCondition <<- function(cond) {
[17:40:53.035]                               data <- list(type = "VALUE", value = cond, 
[17:40:53.035]                                 success = TRUE)
[17:40:53.035]                               parallel_sendData(master, data)
[17:40:53.035]                             }
[17:40:53.035]                             return(sendCondition)
[17:40:53.035]                           }
[17:40:53.035]                         }
[17:40:53.035]                         frame <- frame + 1L
[17:40:53.035]                         envir <- sys.frame(frame)
[17:40:53.035]                       }
[17:40:53.035]                     }
[17:40:53.035]                     sendCondition <<- function(cond) NULL
[17:40:53.035]                   }
[17:40:53.035]                 })
[17:40:53.035]                 withCallingHandlers({
[17:40:53.035]                   {
[17:40:53.035]                     Sys.sleep(0.5)
[17:40:53.035]                     list(a = 1, b = 42L)
[17:40:53.035]                   }
[17:40:53.035]                 }, immediateCondition = function(cond) {
[17:40:53.035]                   sendCondition <- ...future.makeSendCondition()
[17:40:53.035]                   sendCondition(cond)
[17:40:53.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.035]                   {
[17:40:53.035]                     inherits <- base::inherits
[17:40:53.035]                     invokeRestart <- base::invokeRestart
[17:40:53.035]                     is.null <- base::is.null
[17:40:53.035]                     muffled <- FALSE
[17:40:53.035]                     if (inherits(cond, "message")) {
[17:40:53.035]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:53.035]                       if (muffled) 
[17:40:53.035]                         invokeRestart("muffleMessage")
[17:40:53.035]                     }
[17:40:53.035]                     else if (inherits(cond, "warning")) {
[17:40:53.035]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:53.035]                       if (muffled) 
[17:40:53.035]                         invokeRestart("muffleWarning")
[17:40:53.035]                     }
[17:40:53.035]                     else if (inherits(cond, "condition")) {
[17:40:53.035]                       if (!is.null(pattern)) {
[17:40:53.035]                         computeRestarts <- base::computeRestarts
[17:40:53.035]                         grepl <- base::grepl
[17:40:53.035]                         restarts <- computeRestarts(cond)
[17:40:53.035]                         for (restart in restarts) {
[17:40:53.035]                           name <- restart$name
[17:40:53.035]                           if (is.null(name)) 
[17:40:53.035]                             next
[17:40:53.035]                           if (!grepl(pattern, name)) 
[17:40:53.035]                             next
[17:40:53.035]                           invokeRestart(restart)
[17:40:53.035]                           muffled <- TRUE
[17:40:53.035]                           break
[17:40:53.035]                         }
[17:40:53.035]                       }
[17:40:53.035]                     }
[17:40:53.035]                     invisible(muffled)
[17:40:53.035]                   }
[17:40:53.035]                   muffleCondition(cond)
[17:40:53.035]                 })
[17:40:53.035]             }))
[17:40:53.035]             future::FutureResult(value = ...future.value$value, 
[17:40:53.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.035]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.035]                     ...future.globalenv.names))
[17:40:53.035]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.035]         }, condition = base::local({
[17:40:53.035]             c <- base::c
[17:40:53.035]             inherits <- base::inherits
[17:40:53.035]             invokeRestart <- base::invokeRestart
[17:40:53.035]             length <- base::length
[17:40:53.035]             list <- base::list
[17:40:53.035]             seq.int <- base::seq.int
[17:40:53.035]             signalCondition <- base::signalCondition
[17:40:53.035]             sys.calls <- base::sys.calls
[17:40:53.035]             `[[` <- base::`[[`
[17:40:53.035]             `+` <- base::`+`
[17:40:53.035]             `<<-` <- base::`<<-`
[17:40:53.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.035]                   3L)]
[17:40:53.035]             }
[17:40:53.035]             function(cond) {
[17:40:53.035]                 is_error <- inherits(cond, "error")
[17:40:53.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.035]                   NULL)
[17:40:53.035]                 if (is_error) {
[17:40:53.035]                   sessionInformation <- function() {
[17:40:53.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.035]                       search = base::search(), system = base::Sys.info())
[17:40:53.035]                   }
[17:40:53.035]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.035]                     cond$call), session = sessionInformation(), 
[17:40:53.035]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.035]                   signalCondition(cond)
[17:40:53.035]                 }
[17:40:53.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.035]                 "immediateCondition"))) {
[17:40:53.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.035]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.035]                   if (TRUE && !signal) {
[17:40:53.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.035]                     {
[17:40:53.035]                       inherits <- base::inherits
[17:40:53.035]                       invokeRestart <- base::invokeRestart
[17:40:53.035]                       is.null <- base::is.null
[17:40:53.035]                       muffled <- FALSE
[17:40:53.035]                       if (inherits(cond, "message")) {
[17:40:53.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.035]                         if (muffled) 
[17:40:53.035]                           invokeRestart("muffleMessage")
[17:40:53.035]                       }
[17:40:53.035]                       else if (inherits(cond, "warning")) {
[17:40:53.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.035]                         if (muffled) 
[17:40:53.035]                           invokeRestart("muffleWarning")
[17:40:53.035]                       }
[17:40:53.035]                       else if (inherits(cond, "condition")) {
[17:40:53.035]                         if (!is.null(pattern)) {
[17:40:53.035]                           computeRestarts <- base::computeRestarts
[17:40:53.035]                           grepl <- base::grepl
[17:40:53.035]                           restarts <- computeRestarts(cond)
[17:40:53.035]                           for (restart in restarts) {
[17:40:53.035]                             name <- restart$name
[17:40:53.035]                             if (is.null(name)) 
[17:40:53.035]                               next
[17:40:53.035]                             if (!grepl(pattern, name)) 
[17:40:53.035]                               next
[17:40:53.035]                             invokeRestart(restart)
[17:40:53.035]                             muffled <- TRUE
[17:40:53.035]                             break
[17:40:53.035]                           }
[17:40:53.035]                         }
[17:40:53.035]                       }
[17:40:53.035]                       invisible(muffled)
[17:40:53.035]                     }
[17:40:53.035]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.035]                   }
[17:40:53.035]                 }
[17:40:53.035]                 else {
[17:40:53.035]                   if (TRUE) {
[17:40:53.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.035]                     {
[17:40:53.035]                       inherits <- base::inherits
[17:40:53.035]                       invokeRestart <- base::invokeRestart
[17:40:53.035]                       is.null <- base::is.null
[17:40:53.035]                       muffled <- FALSE
[17:40:53.035]                       if (inherits(cond, "message")) {
[17:40:53.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.035]                         if (muffled) 
[17:40:53.035]                           invokeRestart("muffleMessage")
[17:40:53.035]                       }
[17:40:53.035]                       else if (inherits(cond, "warning")) {
[17:40:53.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.035]                         if (muffled) 
[17:40:53.035]                           invokeRestart("muffleWarning")
[17:40:53.035]                       }
[17:40:53.035]                       else if (inherits(cond, "condition")) {
[17:40:53.035]                         if (!is.null(pattern)) {
[17:40:53.035]                           computeRestarts <- base::computeRestarts
[17:40:53.035]                           grepl <- base::grepl
[17:40:53.035]                           restarts <- computeRestarts(cond)
[17:40:53.035]                           for (restart in restarts) {
[17:40:53.035]                             name <- restart$name
[17:40:53.035]                             if (is.null(name)) 
[17:40:53.035]                               next
[17:40:53.035]                             if (!grepl(pattern, name)) 
[17:40:53.035]                               next
[17:40:53.035]                             invokeRestart(restart)
[17:40:53.035]                             muffled <- TRUE
[17:40:53.035]                             break
[17:40:53.035]                           }
[17:40:53.035]                         }
[17:40:53.035]                       }
[17:40:53.035]                       invisible(muffled)
[17:40:53.035]                     }
[17:40:53.035]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.035]                   }
[17:40:53.035]                 }
[17:40:53.035]             }
[17:40:53.035]         }))
[17:40:53.035]     }, error = function(ex) {
[17:40:53.035]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.035]                 ...future.rng), started = ...future.startTime, 
[17:40:53.035]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.035]             version = "1.8"), class = "FutureResult")
[17:40:53.035]     }, finally = {
[17:40:53.035]         if (!identical(...future.workdir, getwd())) 
[17:40:53.035]             setwd(...future.workdir)
[17:40:53.035]         {
[17:40:53.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.035]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.035]             }
[17:40:53.035]             base::options(...future.oldOptions)
[17:40:53.035]             if (.Platform$OS.type == "windows") {
[17:40:53.035]                 old_names <- names(...future.oldEnvVars)
[17:40:53.035]                 envs <- base::Sys.getenv()
[17:40:53.035]                 names <- names(envs)
[17:40:53.035]                 common <- intersect(names, old_names)
[17:40:53.035]                 added <- setdiff(names, old_names)
[17:40:53.035]                 removed <- setdiff(old_names, names)
[17:40:53.035]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.035]                   envs[common]]
[17:40:53.035]                 NAMES <- toupper(changed)
[17:40:53.035]                 args <- list()
[17:40:53.035]                 for (kk in seq_along(NAMES)) {
[17:40:53.035]                   name <- changed[[kk]]
[17:40:53.035]                   NAME <- NAMES[[kk]]
[17:40:53.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.035]                     next
[17:40:53.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.035]                 }
[17:40:53.035]                 NAMES <- toupper(added)
[17:40:53.035]                 for (kk in seq_along(NAMES)) {
[17:40:53.035]                   name <- added[[kk]]
[17:40:53.035]                   NAME <- NAMES[[kk]]
[17:40:53.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.035]                     next
[17:40:53.035]                   args[[name]] <- ""
[17:40:53.035]                 }
[17:40:53.035]                 NAMES <- toupper(removed)
[17:40:53.035]                 for (kk in seq_along(NAMES)) {
[17:40:53.035]                   name <- removed[[kk]]
[17:40:53.035]                   NAME <- NAMES[[kk]]
[17:40:53.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.035]                     next
[17:40:53.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.035]                 }
[17:40:53.035]                 if (length(args) > 0) 
[17:40:53.035]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.035]             }
[17:40:53.035]             else {
[17:40:53.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.035]             }
[17:40:53.035]             {
[17:40:53.035]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.035]                   0L) {
[17:40:53.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.035]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.035]                   base::options(opts)
[17:40:53.035]                 }
[17:40:53.035]                 {
[17:40:53.035]                   {
[17:40:53.035]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:53.035]                     NULL
[17:40:53.035]                   }
[17:40:53.035]                   options(future.plan = NULL)
[17:40:53.035]                   if (is.na(NA_character_)) 
[17:40:53.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:53.035]                     .init = FALSE)
[17:40:53.035]                 }
[17:40:53.035]             }
[17:40:53.035]         }
[17:40:53.035]     })
[17:40:53.035]     if (TRUE) {
[17:40:53.035]         base::sink(type = "output", split = FALSE)
[17:40:53.035]         if (TRUE) {
[17:40:53.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.035]         }
[17:40:53.035]         else {
[17:40:53.035]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.035]         }
[17:40:53.035]         base::close(...future.stdout)
[17:40:53.035]         ...future.stdout <- NULL
[17:40:53.035]     }
[17:40:53.035]     ...future.result$conditions <- ...future.conditions
[17:40:53.035]     ...future.result$finished <- base::Sys.time()
[17:40:53.035]     ...future.result
[17:40:53.035] }
[17:40:53.038] MultisessionFuture started
[17:40:53.038] - Launch lazy future ... done
[17:40:53.039] run() for ‘MultisessionFuture’ ... done
[17:40:53.541] receiveMessageFromWorker() for ClusterFuture ...
[17:40:53.541] - Validating connection of MultisessionFuture
[17:40:53.541] - received message: FutureResult
[17:40:53.542] - Received FutureResult
[17:40:53.542] - Erased future from FutureRegistry
[17:40:53.542] result() for ClusterFuture ...
[17:40:53.542] - result already collected: FutureResult
[17:40:53.542] result() for ClusterFuture ... done
[17:40:53.542] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:53.542] A MultisessionFuture was resolved
- w/ exception ...
[17:40:53.542] getGlobalsAndPackages() ...
[17:40:53.542] Searching for globals...
[17:40:53.543] - globals found: [2] ‘list’, ‘stop’
[17:40:53.543] Searching for globals ... DONE
[17:40:53.543] Resolving globals: FALSE
[17:40:53.544] 
[17:40:53.544] 
[17:40:53.544] getGlobalsAndPackages() ... DONE
[17:40:53.544] run() for ‘Future’ ...
[17:40:53.544] - state: ‘created’
[17:40:53.544] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:53.558] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:53.558] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:53.558]   - Field: ‘node’
[17:40:53.559]   - Field: ‘label’
[17:40:53.559]   - Field: ‘local’
[17:40:53.559]   - Field: ‘owner’
[17:40:53.559]   - Field: ‘envir’
[17:40:53.559]   - Field: ‘workers’
[17:40:53.559]   - Field: ‘packages’
[17:40:53.559]   - Field: ‘gc’
[17:40:53.559]   - Field: ‘conditions’
[17:40:53.559]   - Field: ‘persistent’
[17:40:53.559]   - Field: ‘expr’
[17:40:53.559]   - Field: ‘uuid’
[17:40:53.559]   - Field: ‘seed’
[17:40:53.560]   - Field: ‘version’
[17:40:53.560]   - Field: ‘result’
[17:40:53.560]   - Field: ‘asynchronous’
[17:40:53.560]   - Field: ‘calls’
[17:40:53.560]   - Field: ‘globals’
[17:40:53.560]   - Field: ‘stdout’
[17:40:53.560]   - Field: ‘earlySignal’
[17:40:53.560]   - Field: ‘lazy’
[17:40:53.560]   - Field: ‘state’
[17:40:53.560] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:53.561] - Launch lazy future ...
[17:40:53.561] Packages needed by the future expression (n = 0): <none>
[17:40:53.561] Packages needed by future strategies (n = 0): <none>
[17:40:53.561] {
[17:40:53.561]     {
[17:40:53.561]         {
[17:40:53.561]             ...future.startTime <- base::Sys.time()
[17:40:53.561]             {
[17:40:53.561]                 {
[17:40:53.561]                   {
[17:40:53.561]                     {
[17:40:53.561]                       base::local({
[17:40:53.561]                         has_future <- base::requireNamespace("future", 
[17:40:53.561]                           quietly = TRUE)
[17:40:53.561]                         if (has_future) {
[17:40:53.561]                           ns <- base::getNamespace("future")
[17:40:53.561]                           version <- ns[[".package"]][["version"]]
[17:40:53.561]                           if (is.null(version)) 
[17:40:53.561]                             version <- utils::packageVersion("future")
[17:40:53.561]                         }
[17:40:53.561]                         else {
[17:40:53.561]                           version <- NULL
[17:40:53.561]                         }
[17:40:53.561]                         if (!has_future || version < "1.8.0") {
[17:40:53.561]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.561]                             "", base::R.version$version.string), 
[17:40:53.561]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.561]                               "release", "version")], collapse = " "), 
[17:40:53.561]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.561]                             info)
[17:40:53.561]                           info <- base::paste(info, collapse = "; ")
[17:40:53.561]                           if (!has_future) {
[17:40:53.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.561]                               info)
[17:40:53.561]                           }
[17:40:53.561]                           else {
[17:40:53.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.561]                               info, version)
[17:40:53.561]                           }
[17:40:53.561]                           base::stop(msg)
[17:40:53.561]                         }
[17:40:53.561]                       })
[17:40:53.561]                     }
[17:40:53.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:53.561]                     base::options(mc.cores = 1L)
[17:40:53.561]                   }
[17:40:53.561]                   ...future.strategy.old <- future::plan("list")
[17:40:53.561]                   options(future.plan = NULL)
[17:40:53.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.561]                 }
[17:40:53.561]                 ...future.workdir <- getwd()
[17:40:53.561]             }
[17:40:53.561]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.561]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.561]         }
[17:40:53.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:53.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.561]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.561]             base::names(...future.oldOptions))
[17:40:53.561]     }
[17:40:53.561]     if (FALSE) {
[17:40:53.561]     }
[17:40:53.561]     else {
[17:40:53.561]         if (TRUE) {
[17:40:53.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.561]                 open = "w")
[17:40:53.561]         }
[17:40:53.561]         else {
[17:40:53.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.561]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.561]         }
[17:40:53.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.561]             base::sink(type = "output", split = FALSE)
[17:40:53.561]             base::close(...future.stdout)
[17:40:53.561]         }, add = TRUE)
[17:40:53.561]     }
[17:40:53.561]     ...future.frame <- base::sys.nframe()
[17:40:53.561]     ...future.conditions <- base::list()
[17:40:53.561]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.561]     if (FALSE) {
[17:40:53.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.561]     }
[17:40:53.561]     ...future.result <- base::tryCatch({
[17:40:53.561]         base::withCallingHandlers({
[17:40:53.561]             ...future.value <- base::withVisible(base::local({
[17:40:53.561]                 ...future.makeSendCondition <- base::local({
[17:40:53.561]                   sendCondition <- NULL
[17:40:53.561]                   function(frame = 1L) {
[17:40:53.561]                     if (is.function(sendCondition)) 
[17:40:53.561]                       return(sendCondition)
[17:40:53.561]                     ns <- getNamespace("parallel")
[17:40:53.561]                     if (exists("sendData", mode = "function", 
[17:40:53.561]                       envir = ns)) {
[17:40:53.561]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:53.561]                         envir = ns)
[17:40:53.561]                       envir <- sys.frame(frame)
[17:40:53.561]                       master <- NULL
[17:40:53.561]                       while (!identical(envir, .GlobalEnv) && 
[17:40:53.561]                         !identical(envir, emptyenv())) {
[17:40:53.561]                         if (exists("master", mode = "list", envir = envir, 
[17:40:53.561]                           inherits = FALSE)) {
[17:40:53.561]                           master <- get("master", mode = "list", 
[17:40:53.561]                             envir = envir, inherits = FALSE)
[17:40:53.561]                           if (inherits(master, c("SOCKnode", 
[17:40:53.561]                             "SOCK0node"))) {
[17:40:53.561]                             sendCondition <<- function(cond) {
[17:40:53.561]                               data <- list(type = "VALUE", value = cond, 
[17:40:53.561]                                 success = TRUE)
[17:40:53.561]                               parallel_sendData(master, data)
[17:40:53.561]                             }
[17:40:53.561]                             return(sendCondition)
[17:40:53.561]                           }
[17:40:53.561]                         }
[17:40:53.561]                         frame <- frame + 1L
[17:40:53.561]                         envir <- sys.frame(frame)
[17:40:53.561]                       }
[17:40:53.561]                     }
[17:40:53.561]                     sendCondition <<- function(cond) NULL
[17:40:53.561]                   }
[17:40:53.561]                 })
[17:40:53.561]                 withCallingHandlers({
[17:40:53.561]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:53.561]                 }, immediateCondition = function(cond) {
[17:40:53.561]                   sendCondition <- ...future.makeSendCondition()
[17:40:53.561]                   sendCondition(cond)
[17:40:53.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.561]                   {
[17:40:53.561]                     inherits <- base::inherits
[17:40:53.561]                     invokeRestart <- base::invokeRestart
[17:40:53.561]                     is.null <- base::is.null
[17:40:53.561]                     muffled <- FALSE
[17:40:53.561]                     if (inherits(cond, "message")) {
[17:40:53.561]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:53.561]                       if (muffled) 
[17:40:53.561]                         invokeRestart("muffleMessage")
[17:40:53.561]                     }
[17:40:53.561]                     else if (inherits(cond, "warning")) {
[17:40:53.561]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:53.561]                       if (muffled) 
[17:40:53.561]                         invokeRestart("muffleWarning")
[17:40:53.561]                     }
[17:40:53.561]                     else if (inherits(cond, "condition")) {
[17:40:53.561]                       if (!is.null(pattern)) {
[17:40:53.561]                         computeRestarts <- base::computeRestarts
[17:40:53.561]                         grepl <- base::grepl
[17:40:53.561]                         restarts <- computeRestarts(cond)
[17:40:53.561]                         for (restart in restarts) {
[17:40:53.561]                           name <- restart$name
[17:40:53.561]                           if (is.null(name)) 
[17:40:53.561]                             next
[17:40:53.561]                           if (!grepl(pattern, name)) 
[17:40:53.561]                             next
[17:40:53.561]                           invokeRestart(restart)
[17:40:53.561]                           muffled <- TRUE
[17:40:53.561]                           break
[17:40:53.561]                         }
[17:40:53.561]                       }
[17:40:53.561]                     }
[17:40:53.561]                     invisible(muffled)
[17:40:53.561]                   }
[17:40:53.561]                   muffleCondition(cond)
[17:40:53.561]                 })
[17:40:53.561]             }))
[17:40:53.561]             future::FutureResult(value = ...future.value$value, 
[17:40:53.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.561]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.561]                     ...future.globalenv.names))
[17:40:53.561]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.561]         }, condition = base::local({
[17:40:53.561]             c <- base::c
[17:40:53.561]             inherits <- base::inherits
[17:40:53.561]             invokeRestart <- base::invokeRestart
[17:40:53.561]             length <- base::length
[17:40:53.561]             list <- base::list
[17:40:53.561]             seq.int <- base::seq.int
[17:40:53.561]             signalCondition <- base::signalCondition
[17:40:53.561]             sys.calls <- base::sys.calls
[17:40:53.561]             `[[` <- base::`[[`
[17:40:53.561]             `+` <- base::`+`
[17:40:53.561]             `<<-` <- base::`<<-`
[17:40:53.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.561]                   3L)]
[17:40:53.561]             }
[17:40:53.561]             function(cond) {
[17:40:53.561]                 is_error <- inherits(cond, "error")
[17:40:53.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.561]                   NULL)
[17:40:53.561]                 if (is_error) {
[17:40:53.561]                   sessionInformation <- function() {
[17:40:53.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.561]                       search = base::search(), system = base::Sys.info())
[17:40:53.561]                   }
[17:40:53.561]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.561]                     cond$call), session = sessionInformation(), 
[17:40:53.561]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.561]                   signalCondition(cond)
[17:40:53.561]                 }
[17:40:53.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.561]                 "immediateCondition"))) {
[17:40:53.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.561]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.561]                   if (TRUE && !signal) {
[17:40:53.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.561]                     {
[17:40:53.561]                       inherits <- base::inherits
[17:40:53.561]                       invokeRestart <- base::invokeRestart
[17:40:53.561]                       is.null <- base::is.null
[17:40:53.561]                       muffled <- FALSE
[17:40:53.561]                       if (inherits(cond, "message")) {
[17:40:53.561]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.561]                         if (muffled) 
[17:40:53.561]                           invokeRestart("muffleMessage")
[17:40:53.561]                       }
[17:40:53.561]                       else if (inherits(cond, "warning")) {
[17:40:53.561]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.561]                         if (muffled) 
[17:40:53.561]                           invokeRestart("muffleWarning")
[17:40:53.561]                       }
[17:40:53.561]                       else if (inherits(cond, "condition")) {
[17:40:53.561]                         if (!is.null(pattern)) {
[17:40:53.561]                           computeRestarts <- base::computeRestarts
[17:40:53.561]                           grepl <- base::grepl
[17:40:53.561]                           restarts <- computeRestarts(cond)
[17:40:53.561]                           for (restart in restarts) {
[17:40:53.561]                             name <- restart$name
[17:40:53.561]                             if (is.null(name)) 
[17:40:53.561]                               next
[17:40:53.561]                             if (!grepl(pattern, name)) 
[17:40:53.561]                               next
[17:40:53.561]                             invokeRestart(restart)
[17:40:53.561]                             muffled <- TRUE
[17:40:53.561]                             break
[17:40:53.561]                           }
[17:40:53.561]                         }
[17:40:53.561]                       }
[17:40:53.561]                       invisible(muffled)
[17:40:53.561]                     }
[17:40:53.561]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.561]                   }
[17:40:53.561]                 }
[17:40:53.561]                 else {
[17:40:53.561]                   if (TRUE) {
[17:40:53.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.561]                     {
[17:40:53.561]                       inherits <- base::inherits
[17:40:53.561]                       invokeRestart <- base::invokeRestart
[17:40:53.561]                       is.null <- base::is.null
[17:40:53.561]                       muffled <- FALSE
[17:40:53.561]                       if (inherits(cond, "message")) {
[17:40:53.561]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.561]                         if (muffled) 
[17:40:53.561]                           invokeRestart("muffleMessage")
[17:40:53.561]                       }
[17:40:53.561]                       else if (inherits(cond, "warning")) {
[17:40:53.561]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.561]                         if (muffled) 
[17:40:53.561]                           invokeRestart("muffleWarning")
[17:40:53.561]                       }
[17:40:53.561]                       else if (inherits(cond, "condition")) {
[17:40:53.561]                         if (!is.null(pattern)) {
[17:40:53.561]                           computeRestarts <- base::computeRestarts
[17:40:53.561]                           grepl <- base::grepl
[17:40:53.561]                           restarts <- computeRestarts(cond)
[17:40:53.561]                           for (restart in restarts) {
[17:40:53.561]                             name <- restart$name
[17:40:53.561]                             if (is.null(name)) 
[17:40:53.561]                               next
[17:40:53.561]                             if (!grepl(pattern, name)) 
[17:40:53.561]                               next
[17:40:53.561]                             invokeRestart(restart)
[17:40:53.561]                             muffled <- TRUE
[17:40:53.561]                             break
[17:40:53.561]                           }
[17:40:53.561]                         }
[17:40:53.561]                       }
[17:40:53.561]                       invisible(muffled)
[17:40:53.561]                     }
[17:40:53.561]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.561]                   }
[17:40:53.561]                 }
[17:40:53.561]             }
[17:40:53.561]         }))
[17:40:53.561]     }, error = function(ex) {
[17:40:53.561]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.561]                 ...future.rng), started = ...future.startTime, 
[17:40:53.561]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.561]             version = "1.8"), class = "FutureResult")
[17:40:53.561]     }, finally = {
[17:40:53.561]         if (!identical(...future.workdir, getwd())) 
[17:40:53.561]             setwd(...future.workdir)
[17:40:53.561]         {
[17:40:53.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.561]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.561]             }
[17:40:53.561]             base::options(...future.oldOptions)
[17:40:53.561]             if (.Platform$OS.type == "windows") {
[17:40:53.561]                 old_names <- names(...future.oldEnvVars)
[17:40:53.561]                 envs <- base::Sys.getenv()
[17:40:53.561]                 names <- names(envs)
[17:40:53.561]                 common <- intersect(names, old_names)
[17:40:53.561]                 added <- setdiff(names, old_names)
[17:40:53.561]                 removed <- setdiff(old_names, names)
[17:40:53.561]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.561]                   envs[common]]
[17:40:53.561]                 NAMES <- toupper(changed)
[17:40:53.561]                 args <- list()
[17:40:53.561]                 for (kk in seq_along(NAMES)) {
[17:40:53.561]                   name <- changed[[kk]]
[17:40:53.561]                   NAME <- NAMES[[kk]]
[17:40:53.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.561]                     next
[17:40:53.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.561]                 }
[17:40:53.561]                 NAMES <- toupper(added)
[17:40:53.561]                 for (kk in seq_along(NAMES)) {
[17:40:53.561]                   name <- added[[kk]]
[17:40:53.561]                   NAME <- NAMES[[kk]]
[17:40:53.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.561]                     next
[17:40:53.561]                   args[[name]] <- ""
[17:40:53.561]                 }
[17:40:53.561]                 NAMES <- toupper(removed)
[17:40:53.561]                 for (kk in seq_along(NAMES)) {
[17:40:53.561]                   name <- removed[[kk]]
[17:40:53.561]                   NAME <- NAMES[[kk]]
[17:40:53.561]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.561]                     next
[17:40:53.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.561]                 }
[17:40:53.561]                 if (length(args) > 0) 
[17:40:53.561]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.561]             }
[17:40:53.561]             else {
[17:40:53.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.561]             }
[17:40:53.561]             {
[17:40:53.561]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.561]                   0L) {
[17:40:53.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.561]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.561]                   base::options(opts)
[17:40:53.561]                 }
[17:40:53.561]                 {
[17:40:53.561]                   {
[17:40:53.561]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:53.561]                     NULL
[17:40:53.561]                   }
[17:40:53.561]                   options(future.plan = NULL)
[17:40:53.561]                   if (is.na(NA_character_)) 
[17:40:53.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:53.561]                     .init = FALSE)
[17:40:53.561]                 }
[17:40:53.561]             }
[17:40:53.561]         }
[17:40:53.561]     })
[17:40:53.561]     if (TRUE) {
[17:40:53.561]         base::sink(type = "output", split = FALSE)
[17:40:53.561]         if (TRUE) {
[17:40:53.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.561]         }
[17:40:53.561]         else {
[17:40:53.561]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.561]         }
[17:40:53.561]         base::close(...future.stdout)
[17:40:53.561]         ...future.stdout <- NULL
[17:40:53.561]     }
[17:40:53.561]     ...future.result$conditions <- ...future.conditions
[17:40:53.561]     ...future.result$finished <- base::Sys.time()
[17:40:53.561]     ...future.result
[17:40:53.561] }
[17:40:53.564] MultisessionFuture started
[17:40:53.564] - Launch lazy future ... done
[17:40:53.565] run() for ‘MultisessionFuture’ ... done
[17:40:53.566] receiveMessageFromWorker() for ClusterFuture ...
[17:40:53.567] - Validating connection of MultisessionFuture
[17:40:53.567] - received message: FutureResult
[17:40:53.567] - Received FutureResult
[17:40:53.567] - Erased future from FutureRegistry
[17:40:53.567] result() for ClusterFuture ...
[17:40:53.567] - result already collected: FutureResult
[17:40:53.567] result() for ClusterFuture ... done
[17:40:53.568] signalConditions() ...
[17:40:53.568]  - include = ‘immediateCondition’
[17:40:53.568]  - exclude = 
[17:40:53.568]  - resignal = FALSE
[17:40:53.568]  - Number of conditions: 1
[17:40:53.568] signalConditions() ... done
[17:40:53.568] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:53.568] A MultisessionFuture was resolved
[17:40:53.568] getGlobalsAndPackages() ...
[17:40:53.568] Searching for globals...
[17:40:53.569] - globals found: [2] ‘list’, ‘stop’
[17:40:53.569] Searching for globals ... DONE
[17:40:53.569] Resolving globals: FALSE
[17:40:53.569] 
[17:40:53.570] 
[17:40:53.570] getGlobalsAndPackages() ... DONE
[17:40:53.570] run() for ‘Future’ ...
[17:40:53.570] - state: ‘created’
[17:40:53.570] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:53.584] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:53.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:53.584]   - Field: ‘node’
[17:40:53.584]   - Field: ‘label’
[17:40:53.584]   - Field: ‘local’
[17:40:53.584]   - Field: ‘owner’
[17:40:53.584]   - Field: ‘envir’
[17:40:53.585]   - Field: ‘workers’
[17:40:53.585]   - Field: ‘packages’
[17:40:53.585]   - Field: ‘gc’
[17:40:53.585]   - Field: ‘conditions’
[17:40:53.585]   - Field: ‘persistent’
[17:40:53.585]   - Field: ‘expr’
[17:40:53.585]   - Field: ‘uuid’
[17:40:53.585]   - Field: ‘seed’
[17:40:53.585]   - Field: ‘version’
[17:40:53.585]   - Field: ‘result’
[17:40:53.585]   - Field: ‘asynchronous’
[17:40:53.586]   - Field: ‘calls’
[17:40:53.586]   - Field: ‘globals’
[17:40:53.586]   - Field: ‘stdout’
[17:40:53.586]   - Field: ‘earlySignal’
[17:40:53.586]   - Field: ‘lazy’
[17:40:53.586]   - Field: ‘state’
[17:40:53.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:53.586] - Launch lazy future ...
[17:40:53.586] Packages needed by the future expression (n = 0): <none>
[17:40:53.587] Packages needed by future strategies (n = 0): <none>
[17:40:53.587] {
[17:40:53.587]     {
[17:40:53.587]         {
[17:40:53.587]             ...future.startTime <- base::Sys.time()
[17:40:53.587]             {
[17:40:53.587]                 {
[17:40:53.587]                   {
[17:40:53.587]                     {
[17:40:53.587]                       base::local({
[17:40:53.587]                         has_future <- base::requireNamespace("future", 
[17:40:53.587]                           quietly = TRUE)
[17:40:53.587]                         if (has_future) {
[17:40:53.587]                           ns <- base::getNamespace("future")
[17:40:53.587]                           version <- ns[[".package"]][["version"]]
[17:40:53.587]                           if (is.null(version)) 
[17:40:53.587]                             version <- utils::packageVersion("future")
[17:40:53.587]                         }
[17:40:53.587]                         else {
[17:40:53.587]                           version <- NULL
[17:40:53.587]                         }
[17:40:53.587]                         if (!has_future || version < "1.8.0") {
[17:40:53.587]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.587]                             "", base::R.version$version.string), 
[17:40:53.587]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.587]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.587]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.587]                               "release", "version")], collapse = " "), 
[17:40:53.587]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.587]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.587]                             info)
[17:40:53.587]                           info <- base::paste(info, collapse = "; ")
[17:40:53.587]                           if (!has_future) {
[17:40:53.587]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.587]                               info)
[17:40:53.587]                           }
[17:40:53.587]                           else {
[17:40:53.587]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.587]                               info, version)
[17:40:53.587]                           }
[17:40:53.587]                           base::stop(msg)
[17:40:53.587]                         }
[17:40:53.587]                       })
[17:40:53.587]                     }
[17:40:53.587]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:53.587]                     base::options(mc.cores = 1L)
[17:40:53.587]                   }
[17:40:53.587]                   ...future.strategy.old <- future::plan("list")
[17:40:53.587]                   options(future.plan = NULL)
[17:40:53.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.587]                 }
[17:40:53.587]                 ...future.workdir <- getwd()
[17:40:53.587]             }
[17:40:53.587]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.587]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.587]         }
[17:40:53.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:53.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.587]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.587]             base::names(...future.oldOptions))
[17:40:53.587]     }
[17:40:53.587]     if (FALSE) {
[17:40:53.587]     }
[17:40:53.587]     else {
[17:40:53.587]         if (TRUE) {
[17:40:53.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.587]                 open = "w")
[17:40:53.587]         }
[17:40:53.587]         else {
[17:40:53.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.587]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.587]         }
[17:40:53.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.587]             base::sink(type = "output", split = FALSE)
[17:40:53.587]             base::close(...future.stdout)
[17:40:53.587]         }, add = TRUE)
[17:40:53.587]     }
[17:40:53.587]     ...future.frame <- base::sys.nframe()
[17:40:53.587]     ...future.conditions <- base::list()
[17:40:53.587]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.587]     if (FALSE) {
[17:40:53.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.587]     }
[17:40:53.587]     ...future.result <- base::tryCatch({
[17:40:53.587]         base::withCallingHandlers({
[17:40:53.587]             ...future.value <- base::withVisible(base::local({
[17:40:53.587]                 ...future.makeSendCondition <- base::local({
[17:40:53.587]                   sendCondition <- NULL
[17:40:53.587]                   function(frame = 1L) {
[17:40:53.587]                     if (is.function(sendCondition)) 
[17:40:53.587]                       return(sendCondition)
[17:40:53.587]                     ns <- getNamespace("parallel")
[17:40:53.587]                     if (exists("sendData", mode = "function", 
[17:40:53.587]                       envir = ns)) {
[17:40:53.587]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:53.587]                         envir = ns)
[17:40:53.587]                       envir <- sys.frame(frame)
[17:40:53.587]                       master <- NULL
[17:40:53.587]                       while (!identical(envir, .GlobalEnv) && 
[17:40:53.587]                         !identical(envir, emptyenv())) {
[17:40:53.587]                         if (exists("master", mode = "list", envir = envir, 
[17:40:53.587]                           inherits = FALSE)) {
[17:40:53.587]                           master <- get("master", mode = "list", 
[17:40:53.587]                             envir = envir, inherits = FALSE)
[17:40:53.587]                           if (inherits(master, c("SOCKnode", 
[17:40:53.587]                             "SOCK0node"))) {
[17:40:53.587]                             sendCondition <<- function(cond) {
[17:40:53.587]                               data <- list(type = "VALUE", value = cond, 
[17:40:53.587]                                 success = TRUE)
[17:40:53.587]                               parallel_sendData(master, data)
[17:40:53.587]                             }
[17:40:53.587]                             return(sendCondition)
[17:40:53.587]                           }
[17:40:53.587]                         }
[17:40:53.587]                         frame <- frame + 1L
[17:40:53.587]                         envir <- sys.frame(frame)
[17:40:53.587]                       }
[17:40:53.587]                     }
[17:40:53.587]                     sendCondition <<- function(cond) NULL
[17:40:53.587]                   }
[17:40:53.587]                 })
[17:40:53.587]                 withCallingHandlers({
[17:40:53.587]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:53.587]                 }, immediateCondition = function(cond) {
[17:40:53.587]                   sendCondition <- ...future.makeSendCondition()
[17:40:53.587]                   sendCondition(cond)
[17:40:53.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.587]                   {
[17:40:53.587]                     inherits <- base::inherits
[17:40:53.587]                     invokeRestart <- base::invokeRestart
[17:40:53.587]                     is.null <- base::is.null
[17:40:53.587]                     muffled <- FALSE
[17:40:53.587]                     if (inherits(cond, "message")) {
[17:40:53.587]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:53.587]                       if (muffled) 
[17:40:53.587]                         invokeRestart("muffleMessage")
[17:40:53.587]                     }
[17:40:53.587]                     else if (inherits(cond, "warning")) {
[17:40:53.587]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:53.587]                       if (muffled) 
[17:40:53.587]                         invokeRestart("muffleWarning")
[17:40:53.587]                     }
[17:40:53.587]                     else if (inherits(cond, "condition")) {
[17:40:53.587]                       if (!is.null(pattern)) {
[17:40:53.587]                         computeRestarts <- base::computeRestarts
[17:40:53.587]                         grepl <- base::grepl
[17:40:53.587]                         restarts <- computeRestarts(cond)
[17:40:53.587]                         for (restart in restarts) {
[17:40:53.587]                           name <- restart$name
[17:40:53.587]                           if (is.null(name)) 
[17:40:53.587]                             next
[17:40:53.587]                           if (!grepl(pattern, name)) 
[17:40:53.587]                             next
[17:40:53.587]                           invokeRestart(restart)
[17:40:53.587]                           muffled <- TRUE
[17:40:53.587]                           break
[17:40:53.587]                         }
[17:40:53.587]                       }
[17:40:53.587]                     }
[17:40:53.587]                     invisible(muffled)
[17:40:53.587]                   }
[17:40:53.587]                   muffleCondition(cond)
[17:40:53.587]                 })
[17:40:53.587]             }))
[17:40:53.587]             future::FutureResult(value = ...future.value$value, 
[17:40:53.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.587]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.587]                     ...future.globalenv.names))
[17:40:53.587]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.587]         }, condition = base::local({
[17:40:53.587]             c <- base::c
[17:40:53.587]             inherits <- base::inherits
[17:40:53.587]             invokeRestart <- base::invokeRestart
[17:40:53.587]             length <- base::length
[17:40:53.587]             list <- base::list
[17:40:53.587]             seq.int <- base::seq.int
[17:40:53.587]             signalCondition <- base::signalCondition
[17:40:53.587]             sys.calls <- base::sys.calls
[17:40:53.587]             `[[` <- base::`[[`
[17:40:53.587]             `+` <- base::`+`
[17:40:53.587]             `<<-` <- base::`<<-`
[17:40:53.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.587]                   3L)]
[17:40:53.587]             }
[17:40:53.587]             function(cond) {
[17:40:53.587]                 is_error <- inherits(cond, "error")
[17:40:53.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.587]                   NULL)
[17:40:53.587]                 if (is_error) {
[17:40:53.587]                   sessionInformation <- function() {
[17:40:53.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.587]                       search = base::search(), system = base::Sys.info())
[17:40:53.587]                   }
[17:40:53.587]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.587]                     cond$call), session = sessionInformation(), 
[17:40:53.587]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.587]                   signalCondition(cond)
[17:40:53.587]                 }
[17:40:53.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.587]                 "immediateCondition"))) {
[17:40:53.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.587]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.587]                   if (TRUE && !signal) {
[17:40:53.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.587]                     {
[17:40:53.587]                       inherits <- base::inherits
[17:40:53.587]                       invokeRestart <- base::invokeRestart
[17:40:53.587]                       is.null <- base::is.null
[17:40:53.587]                       muffled <- FALSE
[17:40:53.587]                       if (inherits(cond, "message")) {
[17:40:53.587]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.587]                         if (muffled) 
[17:40:53.587]                           invokeRestart("muffleMessage")
[17:40:53.587]                       }
[17:40:53.587]                       else if (inherits(cond, "warning")) {
[17:40:53.587]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.587]                         if (muffled) 
[17:40:53.587]                           invokeRestart("muffleWarning")
[17:40:53.587]                       }
[17:40:53.587]                       else if (inherits(cond, "condition")) {
[17:40:53.587]                         if (!is.null(pattern)) {
[17:40:53.587]                           computeRestarts <- base::computeRestarts
[17:40:53.587]                           grepl <- base::grepl
[17:40:53.587]                           restarts <- computeRestarts(cond)
[17:40:53.587]                           for (restart in restarts) {
[17:40:53.587]                             name <- restart$name
[17:40:53.587]                             if (is.null(name)) 
[17:40:53.587]                               next
[17:40:53.587]                             if (!grepl(pattern, name)) 
[17:40:53.587]                               next
[17:40:53.587]                             invokeRestart(restart)
[17:40:53.587]                             muffled <- TRUE
[17:40:53.587]                             break
[17:40:53.587]                           }
[17:40:53.587]                         }
[17:40:53.587]                       }
[17:40:53.587]                       invisible(muffled)
[17:40:53.587]                     }
[17:40:53.587]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.587]                   }
[17:40:53.587]                 }
[17:40:53.587]                 else {
[17:40:53.587]                   if (TRUE) {
[17:40:53.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.587]                     {
[17:40:53.587]                       inherits <- base::inherits
[17:40:53.587]                       invokeRestart <- base::invokeRestart
[17:40:53.587]                       is.null <- base::is.null
[17:40:53.587]                       muffled <- FALSE
[17:40:53.587]                       if (inherits(cond, "message")) {
[17:40:53.587]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.587]                         if (muffled) 
[17:40:53.587]                           invokeRestart("muffleMessage")
[17:40:53.587]                       }
[17:40:53.587]                       else if (inherits(cond, "warning")) {
[17:40:53.587]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.587]                         if (muffled) 
[17:40:53.587]                           invokeRestart("muffleWarning")
[17:40:53.587]                       }
[17:40:53.587]                       else if (inherits(cond, "condition")) {
[17:40:53.587]                         if (!is.null(pattern)) {
[17:40:53.587]                           computeRestarts <- base::computeRestarts
[17:40:53.587]                           grepl <- base::grepl
[17:40:53.587]                           restarts <- computeRestarts(cond)
[17:40:53.587]                           for (restart in restarts) {
[17:40:53.587]                             name <- restart$name
[17:40:53.587]                             if (is.null(name)) 
[17:40:53.587]                               next
[17:40:53.587]                             if (!grepl(pattern, name)) 
[17:40:53.587]                               next
[17:40:53.587]                             invokeRestart(restart)
[17:40:53.587]                             muffled <- TRUE
[17:40:53.587]                             break
[17:40:53.587]                           }
[17:40:53.587]                         }
[17:40:53.587]                       }
[17:40:53.587]                       invisible(muffled)
[17:40:53.587]                     }
[17:40:53.587]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.587]                   }
[17:40:53.587]                 }
[17:40:53.587]             }
[17:40:53.587]         }))
[17:40:53.587]     }, error = function(ex) {
[17:40:53.587]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.587]                 ...future.rng), started = ...future.startTime, 
[17:40:53.587]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.587]             version = "1.8"), class = "FutureResult")
[17:40:53.587]     }, finally = {
[17:40:53.587]         if (!identical(...future.workdir, getwd())) 
[17:40:53.587]             setwd(...future.workdir)
[17:40:53.587]         {
[17:40:53.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.587]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.587]             }
[17:40:53.587]             base::options(...future.oldOptions)
[17:40:53.587]             if (.Platform$OS.type == "windows") {
[17:40:53.587]                 old_names <- names(...future.oldEnvVars)
[17:40:53.587]                 envs <- base::Sys.getenv()
[17:40:53.587]                 names <- names(envs)
[17:40:53.587]                 common <- intersect(names, old_names)
[17:40:53.587]                 added <- setdiff(names, old_names)
[17:40:53.587]                 removed <- setdiff(old_names, names)
[17:40:53.587]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.587]                   envs[common]]
[17:40:53.587]                 NAMES <- toupper(changed)
[17:40:53.587]                 args <- list()
[17:40:53.587]                 for (kk in seq_along(NAMES)) {
[17:40:53.587]                   name <- changed[[kk]]
[17:40:53.587]                   NAME <- NAMES[[kk]]
[17:40:53.587]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.587]                     next
[17:40:53.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.587]                 }
[17:40:53.587]                 NAMES <- toupper(added)
[17:40:53.587]                 for (kk in seq_along(NAMES)) {
[17:40:53.587]                   name <- added[[kk]]
[17:40:53.587]                   NAME <- NAMES[[kk]]
[17:40:53.587]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.587]                     next
[17:40:53.587]                   args[[name]] <- ""
[17:40:53.587]                 }
[17:40:53.587]                 NAMES <- toupper(removed)
[17:40:53.587]                 for (kk in seq_along(NAMES)) {
[17:40:53.587]                   name <- removed[[kk]]
[17:40:53.587]                   NAME <- NAMES[[kk]]
[17:40:53.587]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.587]                     next
[17:40:53.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.587]                 }
[17:40:53.587]                 if (length(args) > 0) 
[17:40:53.587]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.587]             }
[17:40:53.587]             else {
[17:40:53.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.587]             }
[17:40:53.587]             {
[17:40:53.587]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.587]                   0L) {
[17:40:53.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.587]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.587]                   base::options(opts)
[17:40:53.587]                 }
[17:40:53.587]                 {
[17:40:53.587]                   {
[17:40:53.587]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:53.587]                     NULL
[17:40:53.587]                   }
[17:40:53.587]                   options(future.plan = NULL)
[17:40:53.587]                   if (is.na(NA_character_)) 
[17:40:53.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.587]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:53.587]                     .init = FALSE)
[17:40:53.587]                 }
[17:40:53.587]             }
[17:40:53.587]         }
[17:40:53.587]     })
[17:40:53.587]     if (TRUE) {
[17:40:53.587]         base::sink(type = "output", split = FALSE)
[17:40:53.587]         if (TRUE) {
[17:40:53.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.587]         }
[17:40:53.587]         else {
[17:40:53.587]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.587]         }
[17:40:53.587]         base::close(...future.stdout)
[17:40:53.587]         ...future.stdout <- NULL
[17:40:53.587]     }
[17:40:53.587]     ...future.result$conditions <- ...future.conditions
[17:40:53.587]     ...future.result$finished <- base::Sys.time()
[17:40:53.587]     ...future.result
[17:40:53.587] }
[17:40:53.590] MultisessionFuture started
[17:40:53.590] - Launch lazy future ... done
[17:40:53.590] run() for ‘MultisessionFuture’ ... done
[17:40:53.591] receiveMessageFromWorker() for ClusterFuture ...
[17:40:53.592] - Validating connection of MultisessionFuture
[17:40:53.592] - received message: FutureResult
[17:40:53.592] - Received FutureResult
[17:40:53.592] - Erased future from FutureRegistry
[17:40:53.592] result() for ClusterFuture ...
[17:40:53.592] - result already collected: FutureResult
[17:40:53.592] result() for ClusterFuture ... done
[17:40:53.593] signalConditions() ...
[17:40:53.593]  - include = ‘immediateCondition’
[17:40:53.593]  - exclude = 
[17:40:53.593]  - resignal = FALSE
[17:40:53.593]  - Number of conditions: 1
[17:40:53.593] signalConditions() ... done
[17:40:53.593] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:53.593] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[17:40:53.593] getGlobalsAndPackages() ...
[17:40:53.593] Searching for globals...
[17:40:53.594] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:53.595] Searching for globals ... DONE
[17:40:53.595] Resolving globals: FALSE
[17:40:53.595] 
[17:40:53.595] 
[17:40:53.595] getGlobalsAndPackages() ... DONE
[17:40:53.595] run() for ‘Future’ ...
[17:40:53.595] - state: ‘created’
[17:40:53.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:53.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:53.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:53.609]   - Field: ‘node’
[17:40:53.610]   - Field: ‘label’
[17:40:53.610]   - Field: ‘local’
[17:40:53.610]   - Field: ‘owner’
[17:40:53.610]   - Field: ‘envir’
[17:40:53.610]   - Field: ‘workers’
[17:40:53.610]   - Field: ‘packages’
[17:40:53.610]   - Field: ‘gc’
[17:40:53.610]   - Field: ‘conditions’
[17:40:53.610]   - Field: ‘persistent’
[17:40:53.610]   - Field: ‘expr’
[17:40:53.610]   - Field: ‘uuid’
[17:40:53.611]   - Field: ‘seed’
[17:40:53.611]   - Field: ‘version’
[17:40:53.611]   - Field: ‘result’
[17:40:53.611]   - Field: ‘asynchronous’
[17:40:53.611]   - Field: ‘calls’
[17:40:53.611]   - Field: ‘globals’
[17:40:53.611]   - Field: ‘stdout’
[17:40:53.611]   - Field: ‘earlySignal’
[17:40:53.611]   - Field: ‘lazy’
[17:40:53.611]   - Field: ‘state’
[17:40:53.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:53.612] - Launch lazy future ...
[17:40:53.612] Packages needed by the future expression (n = 0): <none>
[17:40:53.612] Packages needed by future strategies (n = 0): <none>
[17:40:53.612] {
[17:40:53.612]     {
[17:40:53.612]         {
[17:40:53.612]             ...future.startTime <- base::Sys.time()
[17:40:53.612]             {
[17:40:53.612]                 {
[17:40:53.612]                   {
[17:40:53.612]                     {
[17:40:53.612]                       base::local({
[17:40:53.612]                         has_future <- base::requireNamespace("future", 
[17:40:53.612]                           quietly = TRUE)
[17:40:53.612]                         if (has_future) {
[17:40:53.612]                           ns <- base::getNamespace("future")
[17:40:53.612]                           version <- ns[[".package"]][["version"]]
[17:40:53.612]                           if (is.null(version)) 
[17:40:53.612]                             version <- utils::packageVersion("future")
[17:40:53.612]                         }
[17:40:53.612]                         else {
[17:40:53.612]                           version <- NULL
[17:40:53.612]                         }
[17:40:53.612]                         if (!has_future || version < "1.8.0") {
[17:40:53.612]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:53.612]                             "", base::R.version$version.string), 
[17:40:53.612]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:53.612]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:53.612]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:53.612]                               "release", "version")], collapse = " "), 
[17:40:53.612]                             hostname = base::Sys.info()[["nodename"]])
[17:40:53.612]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:53.612]                             info)
[17:40:53.612]                           info <- base::paste(info, collapse = "; ")
[17:40:53.612]                           if (!has_future) {
[17:40:53.612]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:53.612]                               info)
[17:40:53.612]                           }
[17:40:53.612]                           else {
[17:40:53.612]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:53.612]                               info, version)
[17:40:53.612]                           }
[17:40:53.612]                           base::stop(msg)
[17:40:53.612]                         }
[17:40:53.612]                       })
[17:40:53.612]                     }
[17:40:53.612]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:53.612]                     base::options(mc.cores = 1L)
[17:40:53.612]                   }
[17:40:53.612]                   ...future.strategy.old <- future::plan("list")
[17:40:53.612]                   options(future.plan = NULL)
[17:40:53.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:53.612]                 }
[17:40:53.612]                 ...future.workdir <- getwd()
[17:40:53.612]             }
[17:40:53.612]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:53.612]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:53.612]         }
[17:40:53.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:53.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:53.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:53.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:53.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:53.612]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:53.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:53.612]             base::names(...future.oldOptions))
[17:40:53.612]     }
[17:40:53.612]     if (FALSE) {
[17:40:53.612]     }
[17:40:53.612]     else {
[17:40:53.612]         if (TRUE) {
[17:40:53.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:53.612]                 open = "w")
[17:40:53.612]         }
[17:40:53.612]         else {
[17:40:53.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:53.612]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:53.612]         }
[17:40:53.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:53.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:53.612]             base::sink(type = "output", split = FALSE)
[17:40:53.612]             base::close(...future.stdout)
[17:40:53.612]         }, add = TRUE)
[17:40:53.612]     }
[17:40:53.612]     ...future.frame <- base::sys.nframe()
[17:40:53.612]     ...future.conditions <- base::list()
[17:40:53.612]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:53.612]     if (FALSE) {
[17:40:53.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:53.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:53.612]     }
[17:40:53.612]     ...future.result <- base::tryCatch({
[17:40:53.612]         base::withCallingHandlers({
[17:40:53.612]             ...future.value <- base::withVisible(base::local({
[17:40:53.612]                 ...future.makeSendCondition <- base::local({
[17:40:53.612]                   sendCondition <- NULL
[17:40:53.612]                   function(frame = 1L) {
[17:40:53.612]                     if (is.function(sendCondition)) 
[17:40:53.612]                       return(sendCondition)
[17:40:53.612]                     ns <- getNamespace("parallel")
[17:40:53.612]                     if (exists("sendData", mode = "function", 
[17:40:53.612]                       envir = ns)) {
[17:40:53.612]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:53.612]                         envir = ns)
[17:40:53.612]                       envir <- sys.frame(frame)
[17:40:53.612]                       master <- NULL
[17:40:53.612]                       while (!identical(envir, .GlobalEnv) && 
[17:40:53.612]                         !identical(envir, emptyenv())) {
[17:40:53.612]                         if (exists("master", mode = "list", envir = envir, 
[17:40:53.612]                           inherits = FALSE)) {
[17:40:53.612]                           master <- get("master", mode = "list", 
[17:40:53.612]                             envir = envir, inherits = FALSE)
[17:40:53.612]                           if (inherits(master, c("SOCKnode", 
[17:40:53.612]                             "SOCK0node"))) {
[17:40:53.612]                             sendCondition <<- function(cond) {
[17:40:53.612]                               data <- list(type = "VALUE", value = cond, 
[17:40:53.612]                                 success = TRUE)
[17:40:53.612]                               parallel_sendData(master, data)
[17:40:53.612]                             }
[17:40:53.612]                             return(sendCondition)
[17:40:53.612]                           }
[17:40:53.612]                         }
[17:40:53.612]                         frame <- frame + 1L
[17:40:53.612]                         envir <- sys.frame(frame)
[17:40:53.612]                       }
[17:40:53.612]                     }
[17:40:53.612]                     sendCondition <<- function(cond) NULL
[17:40:53.612]                   }
[17:40:53.612]                 })
[17:40:53.612]                 withCallingHandlers({
[17:40:53.612]                   {
[17:40:53.612]                     Sys.sleep(0.5)
[17:40:53.612]                     list(a = 1, b = 42L)
[17:40:53.612]                   }
[17:40:53.612]                 }, immediateCondition = function(cond) {
[17:40:53.612]                   sendCondition <- ...future.makeSendCondition()
[17:40:53.612]                   sendCondition(cond)
[17:40:53.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.612]                   {
[17:40:53.612]                     inherits <- base::inherits
[17:40:53.612]                     invokeRestart <- base::invokeRestart
[17:40:53.612]                     is.null <- base::is.null
[17:40:53.612]                     muffled <- FALSE
[17:40:53.612]                     if (inherits(cond, "message")) {
[17:40:53.612]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:53.612]                       if (muffled) 
[17:40:53.612]                         invokeRestart("muffleMessage")
[17:40:53.612]                     }
[17:40:53.612]                     else if (inherits(cond, "warning")) {
[17:40:53.612]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:53.612]                       if (muffled) 
[17:40:53.612]                         invokeRestart("muffleWarning")
[17:40:53.612]                     }
[17:40:53.612]                     else if (inherits(cond, "condition")) {
[17:40:53.612]                       if (!is.null(pattern)) {
[17:40:53.612]                         computeRestarts <- base::computeRestarts
[17:40:53.612]                         grepl <- base::grepl
[17:40:53.612]                         restarts <- computeRestarts(cond)
[17:40:53.612]                         for (restart in restarts) {
[17:40:53.612]                           name <- restart$name
[17:40:53.612]                           if (is.null(name)) 
[17:40:53.612]                             next
[17:40:53.612]                           if (!grepl(pattern, name)) 
[17:40:53.612]                             next
[17:40:53.612]                           invokeRestart(restart)
[17:40:53.612]                           muffled <- TRUE
[17:40:53.612]                           break
[17:40:53.612]                         }
[17:40:53.612]                       }
[17:40:53.612]                     }
[17:40:53.612]                     invisible(muffled)
[17:40:53.612]                   }
[17:40:53.612]                   muffleCondition(cond)
[17:40:53.612]                 })
[17:40:53.612]             }))
[17:40:53.612]             future::FutureResult(value = ...future.value$value, 
[17:40:53.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.612]                   ...future.rng), globalenv = if (FALSE) 
[17:40:53.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:53.612]                     ...future.globalenv.names))
[17:40:53.612]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:53.612]         }, condition = base::local({
[17:40:53.612]             c <- base::c
[17:40:53.612]             inherits <- base::inherits
[17:40:53.612]             invokeRestart <- base::invokeRestart
[17:40:53.612]             length <- base::length
[17:40:53.612]             list <- base::list
[17:40:53.612]             seq.int <- base::seq.int
[17:40:53.612]             signalCondition <- base::signalCondition
[17:40:53.612]             sys.calls <- base::sys.calls
[17:40:53.612]             `[[` <- base::`[[`
[17:40:53.612]             `+` <- base::`+`
[17:40:53.612]             `<<-` <- base::`<<-`
[17:40:53.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:53.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:53.612]                   3L)]
[17:40:53.612]             }
[17:40:53.612]             function(cond) {
[17:40:53.612]                 is_error <- inherits(cond, "error")
[17:40:53.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:53.612]                   NULL)
[17:40:53.612]                 if (is_error) {
[17:40:53.612]                   sessionInformation <- function() {
[17:40:53.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:53.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:53.612]                       search = base::search(), system = base::Sys.info())
[17:40:53.612]                   }
[17:40:53.612]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:53.612]                     cond$call), session = sessionInformation(), 
[17:40:53.612]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:53.612]                   signalCondition(cond)
[17:40:53.612]                 }
[17:40:53.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:53.612]                 "immediateCondition"))) {
[17:40:53.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:53.612]                   ...future.conditions[[length(...future.conditions) + 
[17:40:53.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:53.612]                   if (TRUE && !signal) {
[17:40:53.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.612]                     {
[17:40:53.612]                       inherits <- base::inherits
[17:40:53.612]                       invokeRestart <- base::invokeRestart
[17:40:53.612]                       is.null <- base::is.null
[17:40:53.612]                       muffled <- FALSE
[17:40:53.612]                       if (inherits(cond, "message")) {
[17:40:53.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.612]                         if (muffled) 
[17:40:53.612]                           invokeRestart("muffleMessage")
[17:40:53.612]                       }
[17:40:53.612]                       else if (inherits(cond, "warning")) {
[17:40:53.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.612]                         if (muffled) 
[17:40:53.612]                           invokeRestart("muffleWarning")
[17:40:53.612]                       }
[17:40:53.612]                       else if (inherits(cond, "condition")) {
[17:40:53.612]                         if (!is.null(pattern)) {
[17:40:53.612]                           computeRestarts <- base::computeRestarts
[17:40:53.612]                           grepl <- base::grepl
[17:40:53.612]                           restarts <- computeRestarts(cond)
[17:40:53.612]                           for (restart in restarts) {
[17:40:53.612]                             name <- restart$name
[17:40:53.612]                             if (is.null(name)) 
[17:40:53.612]                               next
[17:40:53.612]                             if (!grepl(pattern, name)) 
[17:40:53.612]                               next
[17:40:53.612]                             invokeRestart(restart)
[17:40:53.612]                             muffled <- TRUE
[17:40:53.612]                             break
[17:40:53.612]                           }
[17:40:53.612]                         }
[17:40:53.612]                       }
[17:40:53.612]                       invisible(muffled)
[17:40:53.612]                     }
[17:40:53.612]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.612]                   }
[17:40:53.612]                 }
[17:40:53.612]                 else {
[17:40:53.612]                   if (TRUE) {
[17:40:53.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:53.612]                     {
[17:40:53.612]                       inherits <- base::inherits
[17:40:53.612]                       invokeRestart <- base::invokeRestart
[17:40:53.612]                       is.null <- base::is.null
[17:40:53.612]                       muffled <- FALSE
[17:40:53.612]                       if (inherits(cond, "message")) {
[17:40:53.612]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:53.612]                         if (muffled) 
[17:40:53.612]                           invokeRestart("muffleMessage")
[17:40:53.612]                       }
[17:40:53.612]                       else if (inherits(cond, "warning")) {
[17:40:53.612]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:53.612]                         if (muffled) 
[17:40:53.612]                           invokeRestart("muffleWarning")
[17:40:53.612]                       }
[17:40:53.612]                       else if (inherits(cond, "condition")) {
[17:40:53.612]                         if (!is.null(pattern)) {
[17:40:53.612]                           computeRestarts <- base::computeRestarts
[17:40:53.612]                           grepl <- base::grepl
[17:40:53.612]                           restarts <- computeRestarts(cond)
[17:40:53.612]                           for (restart in restarts) {
[17:40:53.612]                             name <- restart$name
[17:40:53.612]                             if (is.null(name)) 
[17:40:53.612]                               next
[17:40:53.612]                             if (!grepl(pattern, name)) 
[17:40:53.612]                               next
[17:40:53.612]                             invokeRestart(restart)
[17:40:53.612]                             muffled <- TRUE
[17:40:53.612]                             break
[17:40:53.612]                           }
[17:40:53.612]                         }
[17:40:53.612]                       }
[17:40:53.612]                       invisible(muffled)
[17:40:53.612]                     }
[17:40:53.612]                     muffleCondition(cond, pattern = "^muffle")
[17:40:53.612]                   }
[17:40:53.612]                 }
[17:40:53.612]             }
[17:40:53.612]         }))
[17:40:53.612]     }, error = function(ex) {
[17:40:53.612]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:53.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:53.612]                 ...future.rng), started = ...future.startTime, 
[17:40:53.612]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:53.612]             version = "1.8"), class = "FutureResult")
[17:40:53.612]     }, finally = {
[17:40:53.612]         if (!identical(...future.workdir, getwd())) 
[17:40:53.612]             setwd(...future.workdir)
[17:40:53.612]         {
[17:40:53.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:53.612]                 ...future.oldOptions$nwarnings <- NULL
[17:40:53.612]             }
[17:40:53.612]             base::options(...future.oldOptions)
[17:40:53.612]             if (.Platform$OS.type == "windows") {
[17:40:53.612]                 old_names <- names(...future.oldEnvVars)
[17:40:53.612]                 envs <- base::Sys.getenv()
[17:40:53.612]                 names <- names(envs)
[17:40:53.612]                 common <- intersect(names, old_names)
[17:40:53.612]                 added <- setdiff(names, old_names)
[17:40:53.612]                 removed <- setdiff(old_names, names)
[17:40:53.612]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:53.612]                   envs[common]]
[17:40:53.612]                 NAMES <- toupper(changed)
[17:40:53.612]                 args <- list()
[17:40:53.612]                 for (kk in seq_along(NAMES)) {
[17:40:53.612]                   name <- changed[[kk]]
[17:40:53.612]                   NAME <- NAMES[[kk]]
[17:40:53.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.612]                     next
[17:40:53.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.612]                 }
[17:40:53.612]                 NAMES <- toupper(added)
[17:40:53.612]                 for (kk in seq_along(NAMES)) {
[17:40:53.612]                   name <- added[[kk]]
[17:40:53.612]                   NAME <- NAMES[[kk]]
[17:40:53.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.612]                     next
[17:40:53.612]                   args[[name]] <- ""
[17:40:53.612]                 }
[17:40:53.612]                 NAMES <- toupper(removed)
[17:40:53.612]                 for (kk in seq_along(NAMES)) {
[17:40:53.612]                   name <- removed[[kk]]
[17:40:53.612]                   NAME <- NAMES[[kk]]
[17:40:53.612]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:53.612]                     next
[17:40:53.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:53.612]                 }
[17:40:53.612]                 if (length(args) > 0) 
[17:40:53.612]                   base::do.call(base::Sys.setenv, args = args)
[17:40:53.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:53.612]             }
[17:40:53.612]             else {
[17:40:53.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:53.612]             }
[17:40:53.612]             {
[17:40:53.612]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:53.612]                   0L) {
[17:40:53.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:53.612]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:53.612]                   base::options(opts)
[17:40:53.612]                 }
[17:40:53.612]                 {
[17:40:53.612]                   {
[17:40:53.612]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:53.612]                     NULL
[17:40:53.612]                   }
[17:40:53.612]                   options(future.plan = NULL)
[17:40:53.612]                   if (is.na(NA_character_)) 
[17:40:53.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:53.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:53.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:53.612]                     .init = FALSE)
[17:40:53.612]                 }
[17:40:53.612]             }
[17:40:53.612]         }
[17:40:53.612]     })
[17:40:53.612]     if (TRUE) {
[17:40:53.612]         base::sink(type = "output", split = FALSE)
[17:40:53.612]         if (TRUE) {
[17:40:53.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:53.612]         }
[17:40:53.612]         else {
[17:40:53.612]             ...future.result["stdout"] <- base::list(NULL)
[17:40:53.612]         }
[17:40:53.612]         base::close(...future.stdout)
[17:40:53.612]         ...future.stdout <- NULL
[17:40:53.612]     }
[17:40:53.612]     ...future.result$conditions <- ...future.conditions
[17:40:53.612]     ...future.result$finished <- base::Sys.time()
[17:40:53.612]     ...future.result
[17:40:53.612] }
[17:40:53.615] MultisessionFuture started
[17:40:53.615] - Launch lazy future ... done
[17:40:53.615] run() for ‘MultisessionFuture’ ... done
[17:40:54.118] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.118] - Validating connection of MultisessionFuture
[17:40:54.118] - received message: FutureResult
[17:40:54.118] - Received FutureResult
[17:40:54.118] - Erased future from FutureRegistry
[17:40:54.118] result() for ClusterFuture ...
[17:40:54.119] - result already collected: FutureResult
[17:40:54.119] result() for ClusterFuture ... done
[17:40:54.119] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.119] resolve() on list ...
[17:40:54.119]  recursive: 98
[17:40:54.119]  length: 2
[17:40:54.119]  elements: ‘a’, ‘b’
[17:40:54.119]  length: 1 (resolved future 1)
[17:40:54.119]  length: 0 (resolved future 2)
[17:40:54.119] resolve() on list ... DONE
[17:40:54.120] A MultisessionFuture was resolved (and resolved itself)
[17:40:54.120] getGlobalsAndPackages() ...
[17:40:54.120] Searching for globals...
[17:40:54.121] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:54.121] Searching for globals ... DONE
[17:40:54.121] Resolving globals: FALSE
[17:40:54.121] 
[17:40:54.122] 
[17:40:54.122] getGlobalsAndPackages() ... DONE
[17:40:54.122] run() for ‘Future’ ...
[17:40:54.122] - state: ‘created’
[17:40:54.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.136] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.136]   - Field: ‘node’
[17:40:54.137]   - Field: ‘label’
[17:40:54.137]   - Field: ‘local’
[17:40:54.137]   - Field: ‘owner’
[17:40:54.137]   - Field: ‘envir’
[17:40:54.137]   - Field: ‘workers’
[17:40:54.137]   - Field: ‘packages’
[17:40:54.137]   - Field: ‘gc’
[17:40:54.137]   - Field: ‘conditions’
[17:40:54.137]   - Field: ‘persistent’
[17:40:54.138]   - Field: ‘expr’
[17:40:54.138]   - Field: ‘uuid’
[17:40:54.138]   - Field: ‘seed’
[17:40:54.138]   - Field: ‘version’
[17:40:54.138]   - Field: ‘result’
[17:40:54.138]   - Field: ‘asynchronous’
[17:40:54.138]   - Field: ‘calls’
[17:40:54.138]   - Field: ‘globals’
[17:40:54.138]   - Field: ‘stdout’
[17:40:54.138]   - Field: ‘earlySignal’
[17:40:54.138]   - Field: ‘lazy’
[17:40:54.139]   - Field: ‘state’
[17:40:54.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.139] - Launch lazy future ...
[17:40:54.139] Packages needed by the future expression (n = 0): <none>
[17:40:54.139] Packages needed by future strategies (n = 0): <none>
[17:40:54.140] {
[17:40:54.140]     {
[17:40:54.140]         {
[17:40:54.140]             ...future.startTime <- base::Sys.time()
[17:40:54.140]             {
[17:40:54.140]                 {
[17:40:54.140]                   {
[17:40:54.140]                     {
[17:40:54.140]                       base::local({
[17:40:54.140]                         has_future <- base::requireNamespace("future", 
[17:40:54.140]                           quietly = TRUE)
[17:40:54.140]                         if (has_future) {
[17:40:54.140]                           ns <- base::getNamespace("future")
[17:40:54.140]                           version <- ns[[".package"]][["version"]]
[17:40:54.140]                           if (is.null(version)) 
[17:40:54.140]                             version <- utils::packageVersion("future")
[17:40:54.140]                         }
[17:40:54.140]                         else {
[17:40:54.140]                           version <- NULL
[17:40:54.140]                         }
[17:40:54.140]                         if (!has_future || version < "1.8.0") {
[17:40:54.140]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.140]                             "", base::R.version$version.string), 
[17:40:54.140]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.140]                               "release", "version")], collapse = " "), 
[17:40:54.140]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.140]                             info)
[17:40:54.140]                           info <- base::paste(info, collapse = "; ")
[17:40:54.140]                           if (!has_future) {
[17:40:54.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.140]                               info)
[17:40:54.140]                           }
[17:40:54.140]                           else {
[17:40:54.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.140]                               info, version)
[17:40:54.140]                           }
[17:40:54.140]                           base::stop(msg)
[17:40:54.140]                         }
[17:40:54.140]                       })
[17:40:54.140]                     }
[17:40:54.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.140]                     base::options(mc.cores = 1L)
[17:40:54.140]                   }
[17:40:54.140]                   ...future.strategy.old <- future::plan("list")
[17:40:54.140]                   options(future.plan = NULL)
[17:40:54.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.140]                 }
[17:40:54.140]                 ...future.workdir <- getwd()
[17:40:54.140]             }
[17:40:54.140]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.140]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.140]         }
[17:40:54.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.140]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.140]             base::names(...future.oldOptions))
[17:40:54.140]     }
[17:40:54.140]     if (FALSE) {
[17:40:54.140]     }
[17:40:54.140]     else {
[17:40:54.140]         if (TRUE) {
[17:40:54.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.140]                 open = "w")
[17:40:54.140]         }
[17:40:54.140]         else {
[17:40:54.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.140]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.140]         }
[17:40:54.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.140]             base::sink(type = "output", split = FALSE)
[17:40:54.140]             base::close(...future.stdout)
[17:40:54.140]         }, add = TRUE)
[17:40:54.140]     }
[17:40:54.140]     ...future.frame <- base::sys.nframe()
[17:40:54.140]     ...future.conditions <- base::list()
[17:40:54.140]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.140]     if (FALSE) {
[17:40:54.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.140]     }
[17:40:54.140]     ...future.result <- base::tryCatch({
[17:40:54.140]         base::withCallingHandlers({
[17:40:54.140]             ...future.value <- base::withVisible(base::local({
[17:40:54.140]                 ...future.makeSendCondition <- base::local({
[17:40:54.140]                   sendCondition <- NULL
[17:40:54.140]                   function(frame = 1L) {
[17:40:54.140]                     if (is.function(sendCondition)) 
[17:40:54.140]                       return(sendCondition)
[17:40:54.140]                     ns <- getNamespace("parallel")
[17:40:54.140]                     if (exists("sendData", mode = "function", 
[17:40:54.140]                       envir = ns)) {
[17:40:54.140]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.140]                         envir = ns)
[17:40:54.140]                       envir <- sys.frame(frame)
[17:40:54.140]                       master <- NULL
[17:40:54.140]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.140]                         !identical(envir, emptyenv())) {
[17:40:54.140]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.140]                           inherits = FALSE)) {
[17:40:54.140]                           master <- get("master", mode = "list", 
[17:40:54.140]                             envir = envir, inherits = FALSE)
[17:40:54.140]                           if (inherits(master, c("SOCKnode", 
[17:40:54.140]                             "SOCK0node"))) {
[17:40:54.140]                             sendCondition <<- function(cond) {
[17:40:54.140]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.140]                                 success = TRUE)
[17:40:54.140]                               parallel_sendData(master, data)
[17:40:54.140]                             }
[17:40:54.140]                             return(sendCondition)
[17:40:54.140]                           }
[17:40:54.140]                         }
[17:40:54.140]                         frame <- frame + 1L
[17:40:54.140]                         envir <- sys.frame(frame)
[17:40:54.140]                       }
[17:40:54.140]                     }
[17:40:54.140]                     sendCondition <<- function(cond) NULL
[17:40:54.140]                   }
[17:40:54.140]                 })
[17:40:54.140]                 withCallingHandlers({
[17:40:54.140]                   {
[17:40:54.140]                     Sys.sleep(0.5)
[17:40:54.140]                     list(a = 1, b = 42L)
[17:40:54.140]                   }
[17:40:54.140]                 }, immediateCondition = function(cond) {
[17:40:54.140]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.140]                   sendCondition(cond)
[17:40:54.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.140]                   {
[17:40:54.140]                     inherits <- base::inherits
[17:40:54.140]                     invokeRestart <- base::invokeRestart
[17:40:54.140]                     is.null <- base::is.null
[17:40:54.140]                     muffled <- FALSE
[17:40:54.140]                     if (inherits(cond, "message")) {
[17:40:54.140]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.140]                       if (muffled) 
[17:40:54.140]                         invokeRestart("muffleMessage")
[17:40:54.140]                     }
[17:40:54.140]                     else if (inherits(cond, "warning")) {
[17:40:54.140]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.140]                       if (muffled) 
[17:40:54.140]                         invokeRestart("muffleWarning")
[17:40:54.140]                     }
[17:40:54.140]                     else if (inherits(cond, "condition")) {
[17:40:54.140]                       if (!is.null(pattern)) {
[17:40:54.140]                         computeRestarts <- base::computeRestarts
[17:40:54.140]                         grepl <- base::grepl
[17:40:54.140]                         restarts <- computeRestarts(cond)
[17:40:54.140]                         for (restart in restarts) {
[17:40:54.140]                           name <- restart$name
[17:40:54.140]                           if (is.null(name)) 
[17:40:54.140]                             next
[17:40:54.140]                           if (!grepl(pattern, name)) 
[17:40:54.140]                             next
[17:40:54.140]                           invokeRestart(restart)
[17:40:54.140]                           muffled <- TRUE
[17:40:54.140]                           break
[17:40:54.140]                         }
[17:40:54.140]                       }
[17:40:54.140]                     }
[17:40:54.140]                     invisible(muffled)
[17:40:54.140]                   }
[17:40:54.140]                   muffleCondition(cond)
[17:40:54.140]                 })
[17:40:54.140]             }))
[17:40:54.140]             future::FutureResult(value = ...future.value$value, 
[17:40:54.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.140]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.140]                     ...future.globalenv.names))
[17:40:54.140]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.140]         }, condition = base::local({
[17:40:54.140]             c <- base::c
[17:40:54.140]             inherits <- base::inherits
[17:40:54.140]             invokeRestart <- base::invokeRestart
[17:40:54.140]             length <- base::length
[17:40:54.140]             list <- base::list
[17:40:54.140]             seq.int <- base::seq.int
[17:40:54.140]             signalCondition <- base::signalCondition
[17:40:54.140]             sys.calls <- base::sys.calls
[17:40:54.140]             `[[` <- base::`[[`
[17:40:54.140]             `+` <- base::`+`
[17:40:54.140]             `<<-` <- base::`<<-`
[17:40:54.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.140]                   3L)]
[17:40:54.140]             }
[17:40:54.140]             function(cond) {
[17:40:54.140]                 is_error <- inherits(cond, "error")
[17:40:54.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.140]                   NULL)
[17:40:54.140]                 if (is_error) {
[17:40:54.140]                   sessionInformation <- function() {
[17:40:54.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.140]                       search = base::search(), system = base::Sys.info())
[17:40:54.140]                   }
[17:40:54.140]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.140]                     cond$call), session = sessionInformation(), 
[17:40:54.140]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.140]                   signalCondition(cond)
[17:40:54.140]                 }
[17:40:54.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.140]                 "immediateCondition"))) {
[17:40:54.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.140]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.140]                   if (TRUE && !signal) {
[17:40:54.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.140]                     {
[17:40:54.140]                       inherits <- base::inherits
[17:40:54.140]                       invokeRestart <- base::invokeRestart
[17:40:54.140]                       is.null <- base::is.null
[17:40:54.140]                       muffled <- FALSE
[17:40:54.140]                       if (inherits(cond, "message")) {
[17:40:54.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.140]                         if (muffled) 
[17:40:54.140]                           invokeRestart("muffleMessage")
[17:40:54.140]                       }
[17:40:54.140]                       else if (inherits(cond, "warning")) {
[17:40:54.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.140]                         if (muffled) 
[17:40:54.140]                           invokeRestart("muffleWarning")
[17:40:54.140]                       }
[17:40:54.140]                       else if (inherits(cond, "condition")) {
[17:40:54.140]                         if (!is.null(pattern)) {
[17:40:54.140]                           computeRestarts <- base::computeRestarts
[17:40:54.140]                           grepl <- base::grepl
[17:40:54.140]                           restarts <- computeRestarts(cond)
[17:40:54.140]                           for (restart in restarts) {
[17:40:54.140]                             name <- restart$name
[17:40:54.140]                             if (is.null(name)) 
[17:40:54.140]                               next
[17:40:54.140]                             if (!grepl(pattern, name)) 
[17:40:54.140]                               next
[17:40:54.140]                             invokeRestart(restart)
[17:40:54.140]                             muffled <- TRUE
[17:40:54.140]                             break
[17:40:54.140]                           }
[17:40:54.140]                         }
[17:40:54.140]                       }
[17:40:54.140]                       invisible(muffled)
[17:40:54.140]                     }
[17:40:54.140]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.140]                   }
[17:40:54.140]                 }
[17:40:54.140]                 else {
[17:40:54.140]                   if (TRUE) {
[17:40:54.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.140]                     {
[17:40:54.140]                       inherits <- base::inherits
[17:40:54.140]                       invokeRestart <- base::invokeRestart
[17:40:54.140]                       is.null <- base::is.null
[17:40:54.140]                       muffled <- FALSE
[17:40:54.140]                       if (inherits(cond, "message")) {
[17:40:54.140]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.140]                         if (muffled) 
[17:40:54.140]                           invokeRestart("muffleMessage")
[17:40:54.140]                       }
[17:40:54.140]                       else if (inherits(cond, "warning")) {
[17:40:54.140]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.140]                         if (muffled) 
[17:40:54.140]                           invokeRestart("muffleWarning")
[17:40:54.140]                       }
[17:40:54.140]                       else if (inherits(cond, "condition")) {
[17:40:54.140]                         if (!is.null(pattern)) {
[17:40:54.140]                           computeRestarts <- base::computeRestarts
[17:40:54.140]                           grepl <- base::grepl
[17:40:54.140]                           restarts <- computeRestarts(cond)
[17:40:54.140]                           for (restart in restarts) {
[17:40:54.140]                             name <- restart$name
[17:40:54.140]                             if (is.null(name)) 
[17:40:54.140]                               next
[17:40:54.140]                             if (!grepl(pattern, name)) 
[17:40:54.140]                               next
[17:40:54.140]                             invokeRestart(restart)
[17:40:54.140]                             muffled <- TRUE
[17:40:54.140]                             break
[17:40:54.140]                           }
[17:40:54.140]                         }
[17:40:54.140]                       }
[17:40:54.140]                       invisible(muffled)
[17:40:54.140]                     }
[17:40:54.140]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.140]                   }
[17:40:54.140]                 }
[17:40:54.140]             }
[17:40:54.140]         }))
[17:40:54.140]     }, error = function(ex) {
[17:40:54.140]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.140]                 ...future.rng), started = ...future.startTime, 
[17:40:54.140]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.140]             version = "1.8"), class = "FutureResult")
[17:40:54.140]     }, finally = {
[17:40:54.140]         if (!identical(...future.workdir, getwd())) 
[17:40:54.140]             setwd(...future.workdir)
[17:40:54.140]         {
[17:40:54.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.140]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.140]             }
[17:40:54.140]             base::options(...future.oldOptions)
[17:40:54.140]             if (.Platform$OS.type == "windows") {
[17:40:54.140]                 old_names <- names(...future.oldEnvVars)
[17:40:54.140]                 envs <- base::Sys.getenv()
[17:40:54.140]                 names <- names(envs)
[17:40:54.140]                 common <- intersect(names, old_names)
[17:40:54.140]                 added <- setdiff(names, old_names)
[17:40:54.140]                 removed <- setdiff(old_names, names)
[17:40:54.140]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.140]                   envs[common]]
[17:40:54.140]                 NAMES <- toupper(changed)
[17:40:54.140]                 args <- list()
[17:40:54.140]                 for (kk in seq_along(NAMES)) {
[17:40:54.140]                   name <- changed[[kk]]
[17:40:54.140]                   NAME <- NAMES[[kk]]
[17:40:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.140]                     next
[17:40:54.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.140]                 }
[17:40:54.140]                 NAMES <- toupper(added)
[17:40:54.140]                 for (kk in seq_along(NAMES)) {
[17:40:54.140]                   name <- added[[kk]]
[17:40:54.140]                   NAME <- NAMES[[kk]]
[17:40:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.140]                     next
[17:40:54.140]                   args[[name]] <- ""
[17:40:54.140]                 }
[17:40:54.140]                 NAMES <- toupper(removed)
[17:40:54.140]                 for (kk in seq_along(NAMES)) {
[17:40:54.140]                   name <- removed[[kk]]
[17:40:54.140]                   NAME <- NAMES[[kk]]
[17:40:54.140]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.140]                     next
[17:40:54.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.140]                 }
[17:40:54.140]                 if (length(args) > 0) 
[17:40:54.140]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.140]             }
[17:40:54.140]             else {
[17:40:54.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.140]             }
[17:40:54.140]             {
[17:40:54.140]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.140]                   0L) {
[17:40:54.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.140]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.140]                   base::options(opts)
[17:40:54.140]                 }
[17:40:54.140]                 {
[17:40:54.140]                   {
[17:40:54.140]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.140]                     NULL
[17:40:54.140]                   }
[17:40:54.140]                   options(future.plan = NULL)
[17:40:54.140]                   if (is.na(NA_character_)) 
[17:40:54.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.140]                     .init = FALSE)
[17:40:54.140]                 }
[17:40:54.140]             }
[17:40:54.140]         }
[17:40:54.140]     })
[17:40:54.140]     if (TRUE) {
[17:40:54.140]         base::sink(type = "output", split = FALSE)
[17:40:54.140]         if (TRUE) {
[17:40:54.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.140]         }
[17:40:54.140]         else {
[17:40:54.140]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.140]         }
[17:40:54.140]         base::close(...future.stdout)
[17:40:54.140]         ...future.stdout <- NULL
[17:40:54.140]     }
[17:40:54.140]     ...future.result$conditions <- ...future.conditions
[17:40:54.140]     ...future.result$finished <- base::Sys.time()
[17:40:54.140]     ...future.result
[17:40:54.140] }
[17:40:54.142] MultisessionFuture started
[17:40:54.143] - Launch lazy future ... done
[17:40:54.143] run() for ‘MultisessionFuture’ ... done
[17:40:54.645] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.645] - Validating connection of MultisessionFuture
[17:40:54.646] - received message: FutureResult
[17:40:54.646] - Received FutureResult
[17:40:54.646] - Erased future from FutureRegistry
[17:40:54.646] result() for ClusterFuture ...
[17:40:54.646] - result already collected: FutureResult
[17:40:54.646] result() for ClusterFuture ... done
[17:40:54.646] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.646] resolve() on list ...
[17:40:54.646]  recursive: 98
[17:40:54.647]  length: 2
[17:40:54.647]  elements: ‘a’, ‘b’
[17:40:54.647]  length: 1 (resolved future 1)
[17:40:54.647]  length: 0 (resolved future 2)
[17:40:54.647] resolve() on list ... DONE
[17:40:54.647] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:40:54.647] getGlobalsAndPackages() ...
[17:40:54.647] Searching for globals...
[17:40:54.648] - globals found: [2] ‘list’, ‘stop’
[17:40:54.648] Searching for globals ... DONE
[17:40:54.648] Resolving globals: FALSE
[17:40:54.649] 
[17:40:54.649] 
[17:40:54.649] getGlobalsAndPackages() ... DONE
[17:40:54.649] run() for ‘Future’ ...
[17:40:54.649] - state: ‘created’
[17:40:54.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.663]   - Field: ‘node’
[17:40:54.663]   - Field: ‘label’
[17:40:54.663]   - Field: ‘local’
[17:40:54.664]   - Field: ‘owner’
[17:40:54.664]   - Field: ‘envir’
[17:40:54.664]   - Field: ‘workers’
[17:40:54.664]   - Field: ‘packages’
[17:40:54.664]   - Field: ‘gc’
[17:40:54.664]   - Field: ‘conditions’
[17:40:54.664]   - Field: ‘persistent’
[17:40:54.664]   - Field: ‘expr’
[17:40:54.664]   - Field: ‘uuid’
[17:40:54.664]   - Field: ‘seed’
[17:40:54.665]   - Field: ‘version’
[17:40:54.665]   - Field: ‘result’
[17:40:54.665]   - Field: ‘asynchronous’
[17:40:54.665]   - Field: ‘calls’
[17:40:54.665]   - Field: ‘globals’
[17:40:54.665]   - Field: ‘stdout’
[17:40:54.665]   - Field: ‘earlySignal’
[17:40:54.665]   - Field: ‘lazy’
[17:40:54.665]   - Field: ‘state’
[17:40:54.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.665] - Launch lazy future ...
[17:40:54.666] Packages needed by the future expression (n = 0): <none>
[17:40:54.666] Packages needed by future strategies (n = 0): <none>
[17:40:54.666] {
[17:40:54.666]     {
[17:40:54.666]         {
[17:40:54.666]             ...future.startTime <- base::Sys.time()
[17:40:54.666]             {
[17:40:54.666]                 {
[17:40:54.666]                   {
[17:40:54.666]                     {
[17:40:54.666]                       base::local({
[17:40:54.666]                         has_future <- base::requireNamespace("future", 
[17:40:54.666]                           quietly = TRUE)
[17:40:54.666]                         if (has_future) {
[17:40:54.666]                           ns <- base::getNamespace("future")
[17:40:54.666]                           version <- ns[[".package"]][["version"]]
[17:40:54.666]                           if (is.null(version)) 
[17:40:54.666]                             version <- utils::packageVersion("future")
[17:40:54.666]                         }
[17:40:54.666]                         else {
[17:40:54.666]                           version <- NULL
[17:40:54.666]                         }
[17:40:54.666]                         if (!has_future || version < "1.8.0") {
[17:40:54.666]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.666]                             "", base::R.version$version.string), 
[17:40:54.666]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.666]                               "release", "version")], collapse = " "), 
[17:40:54.666]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.666]                             info)
[17:40:54.666]                           info <- base::paste(info, collapse = "; ")
[17:40:54.666]                           if (!has_future) {
[17:40:54.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.666]                               info)
[17:40:54.666]                           }
[17:40:54.666]                           else {
[17:40:54.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.666]                               info, version)
[17:40:54.666]                           }
[17:40:54.666]                           base::stop(msg)
[17:40:54.666]                         }
[17:40:54.666]                       })
[17:40:54.666]                     }
[17:40:54.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.666]                     base::options(mc.cores = 1L)
[17:40:54.666]                   }
[17:40:54.666]                   ...future.strategy.old <- future::plan("list")
[17:40:54.666]                   options(future.plan = NULL)
[17:40:54.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.666]                 }
[17:40:54.666]                 ...future.workdir <- getwd()
[17:40:54.666]             }
[17:40:54.666]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.666]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.666]         }
[17:40:54.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.666]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.666]             base::names(...future.oldOptions))
[17:40:54.666]     }
[17:40:54.666]     if (FALSE) {
[17:40:54.666]     }
[17:40:54.666]     else {
[17:40:54.666]         if (TRUE) {
[17:40:54.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.666]                 open = "w")
[17:40:54.666]         }
[17:40:54.666]         else {
[17:40:54.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.666]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.666]         }
[17:40:54.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.666]             base::sink(type = "output", split = FALSE)
[17:40:54.666]             base::close(...future.stdout)
[17:40:54.666]         }, add = TRUE)
[17:40:54.666]     }
[17:40:54.666]     ...future.frame <- base::sys.nframe()
[17:40:54.666]     ...future.conditions <- base::list()
[17:40:54.666]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.666]     if (FALSE) {
[17:40:54.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.666]     }
[17:40:54.666]     ...future.result <- base::tryCatch({
[17:40:54.666]         base::withCallingHandlers({
[17:40:54.666]             ...future.value <- base::withVisible(base::local({
[17:40:54.666]                 ...future.makeSendCondition <- base::local({
[17:40:54.666]                   sendCondition <- NULL
[17:40:54.666]                   function(frame = 1L) {
[17:40:54.666]                     if (is.function(sendCondition)) 
[17:40:54.666]                       return(sendCondition)
[17:40:54.666]                     ns <- getNamespace("parallel")
[17:40:54.666]                     if (exists("sendData", mode = "function", 
[17:40:54.666]                       envir = ns)) {
[17:40:54.666]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.666]                         envir = ns)
[17:40:54.666]                       envir <- sys.frame(frame)
[17:40:54.666]                       master <- NULL
[17:40:54.666]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.666]                         !identical(envir, emptyenv())) {
[17:40:54.666]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.666]                           inherits = FALSE)) {
[17:40:54.666]                           master <- get("master", mode = "list", 
[17:40:54.666]                             envir = envir, inherits = FALSE)
[17:40:54.666]                           if (inherits(master, c("SOCKnode", 
[17:40:54.666]                             "SOCK0node"))) {
[17:40:54.666]                             sendCondition <<- function(cond) {
[17:40:54.666]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.666]                                 success = TRUE)
[17:40:54.666]                               parallel_sendData(master, data)
[17:40:54.666]                             }
[17:40:54.666]                             return(sendCondition)
[17:40:54.666]                           }
[17:40:54.666]                         }
[17:40:54.666]                         frame <- frame + 1L
[17:40:54.666]                         envir <- sys.frame(frame)
[17:40:54.666]                       }
[17:40:54.666]                     }
[17:40:54.666]                     sendCondition <<- function(cond) NULL
[17:40:54.666]                   }
[17:40:54.666]                 })
[17:40:54.666]                 withCallingHandlers({
[17:40:54.666]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:54.666]                 }, immediateCondition = function(cond) {
[17:40:54.666]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.666]                   sendCondition(cond)
[17:40:54.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.666]                   {
[17:40:54.666]                     inherits <- base::inherits
[17:40:54.666]                     invokeRestart <- base::invokeRestart
[17:40:54.666]                     is.null <- base::is.null
[17:40:54.666]                     muffled <- FALSE
[17:40:54.666]                     if (inherits(cond, "message")) {
[17:40:54.666]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.666]                       if (muffled) 
[17:40:54.666]                         invokeRestart("muffleMessage")
[17:40:54.666]                     }
[17:40:54.666]                     else if (inherits(cond, "warning")) {
[17:40:54.666]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.666]                       if (muffled) 
[17:40:54.666]                         invokeRestart("muffleWarning")
[17:40:54.666]                     }
[17:40:54.666]                     else if (inherits(cond, "condition")) {
[17:40:54.666]                       if (!is.null(pattern)) {
[17:40:54.666]                         computeRestarts <- base::computeRestarts
[17:40:54.666]                         grepl <- base::grepl
[17:40:54.666]                         restarts <- computeRestarts(cond)
[17:40:54.666]                         for (restart in restarts) {
[17:40:54.666]                           name <- restart$name
[17:40:54.666]                           if (is.null(name)) 
[17:40:54.666]                             next
[17:40:54.666]                           if (!grepl(pattern, name)) 
[17:40:54.666]                             next
[17:40:54.666]                           invokeRestart(restart)
[17:40:54.666]                           muffled <- TRUE
[17:40:54.666]                           break
[17:40:54.666]                         }
[17:40:54.666]                       }
[17:40:54.666]                     }
[17:40:54.666]                     invisible(muffled)
[17:40:54.666]                   }
[17:40:54.666]                   muffleCondition(cond)
[17:40:54.666]                 })
[17:40:54.666]             }))
[17:40:54.666]             future::FutureResult(value = ...future.value$value, 
[17:40:54.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.666]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.666]                     ...future.globalenv.names))
[17:40:54.666]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.666]         }, condition = base::local({
[17:40:54.666]             c <- base::c
[17:40:54.666]             inherits <- base::inherits
[17:40:54.666]             invokeRestart <- base::invokeRestart
[17:40:54.666]             length <- base::length
[17:40:54.666]             list <- base::list
[17:40:54.666]             seq.int <- base::seq.int
[17:40:54.666]             signalCondition <- base::signalCondition
[17:40:54.666]             sys.calls <- base::sys.calls
[17:40:54.666]             `[[` <- base::`[[`
[17:40:54.666]             `+` <- base::`+`
[17:40:54.666]             `<<-` <- base::`<<-`
[17:40:54.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.666]                   3L)]
[17:40:54.666]             }
[17:40:54.666]             function(cond) {
[17:40:54.666]                 is_error <- inherits(cond, "error")
[17:40:54.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.666]                   NULL)
[17:40:54.666]                 if (is_error) {
[17:40:54.666]                   sessionInformation <- function() {
[17:40:54.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.666]                       search = base::search(), system = base::Sys.info())
[17:40:54.666]                   }
[17:40:54.666]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.666]                     cond$call), session = sessionInformation(), 
[17:40:54.666]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.666]                   signalCondition(cond)
[17:40:54.666]                 }
[17:40:54.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.666]                 "immediateCondition"))) {
[17:40:54.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.666]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.666]                   if (TRUE && !signal) {
[17:40:54.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.666]                     {
[17:40:54.666]                       inherits <- base::inherits
[17:40:54.666]                       invokeRestart <- base::invokeRestart
[17:40:54.666]                       is.null <- base::is.null
[17:40:54.666]                       muffled <- FALSE
[17:40:54.666]                       if (inherits(cond, "message")) {
[17:40:54.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.666]                         if (muffled) 
[17:40:54.666]                           invokeRestart("muffleMessage")
[17:40:54.666]                       }
[17:40:54.666]                       else if (inherits(cond, "warning")) {
[17:40:54.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.666]                         if (muffled) 
[17:40:54.666]                           invokeRestart("muffleWarning")
[17:40:54.666]                       }
[17:40:54.666]                       else if (inherits(cond, "condition")) {
[17:40:54.666]                         if (!is.null(pattern)) {
[17:40:54.666]                           computeRestarts <- base::computeRestarts
[17:40:54.666]                           grepl <- base::grepl
[17:40:54.666]                           restarts <- computeRestarts(cond)
[17:40:54.666]                           for (restart in restarts) {
[17:40:54.666]                             name <- restart$name
[17:40:54.666]                             if (is.null(name)) 
[17:40:54.666]                               next
[17:40:54.666]                             if (!grepl(pattern, name)) 
[17:40:54.666]                               next
[17:40:54.666]                             invokeRestart(restart)
[17:40:54.666]                             muffled <- TRUE
[17:40:54.666]                             break
[17:40:54.666]                           }
[17:40:54.666]                         }
[17:40:54.666]                       }
[17:40:54.666]                       invisible(muffled)
[17:40:54.666]                     }
[17:40:54.666]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.666]                   }
[17:40:54.666]                 }
[17:40:54.666]                 else {
[17:40:54.666]                   if (TRUE) {
[17:40:54.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.666]                     {
[17:40:54.666]                       inherits <- base::inherits
[17:40:54.666]                       invokeRestart <- base::invokeRestart
[17:40:54.666]                       is.null <- base::is.null
[17:40:54.666]                       muffled <- FALSE
[17:40:54.666]                       if (inherits(cond, "message")) {
[17:40:54.666]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.666]                         if (muffled) 
[17:40:54.666]                           invokeRestart("muffleMessage")
[17:40:54.666]                       }
[17:40:54.666]                       else if (inherits(cond, "warning")) {
[17:40:54.666]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.666]                         if (muffled) 
[17:40:54.666]                           invokeRestart("muffleWarning")
[17:40:54.666]                       }
[17:40:54.666]                       else if (inherits(cond, "condition")) {
[17:40:54.666]                         if (!is.null(pattern)) {
[17:40:54.666]                           computeRestarts <- base::computeRestarts
[17:40:54.666]                           grepl <- base::grepl
[17:40:54.666]                           restarts <- computeRestarts(cond)
[17:40:54.666]                           for (restart in restarts) {
[17:40:54.666]                             name <- restart$name
[17:40:54.666]                             if (is.null(name)) 
[17:40:54.666]                               next
[17:40:54.666]                             if (!grepl(pattern, name)) 
[17:40:54.666]                               next
[17:40:54.666]                             invokeRestart(restart)
[17:40:54.666]                             muffled <- TRUE
[17:40:54.666]                             break
[17:40:54.666]                           }
[17:40:54.666]                         }
[17:40:54.666]                       }
[17:40:54.666]                       invisible(muffled)
[17:40:54.666]                     }
[17:40:54.666]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.666]                   }
[17:40:54.666]                 }
[17:40:54.666]             }
[17:40:54.666]         }))
[17:40:54.666]     }, error = function(ex) {
[17:40:54.666]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.666]                 ...future.rng), started = ...future.startTime, 
[17:40:54.666]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.666]             version = "1.8"), class = "FutureResult")
[17:40:54.666]     }, finally = {
[17:40:54.666]         if (!identical(...future.workdir, getwd())) 
[17:40:54.666]             setwd(...future.workdir)
[17:40:54.666]         {
[17:40:54.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.666]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.666]             }
[17:40:54.666]             base::options(...future.oldOptions)
[17:40:54.666]             if (.Platform$OS.type == "windows") {
[17:40:54.666]                 old_names <- names(...future.oldEnvVars)
[17:40:54.666]                 envs <- base::Sys.getenv()
[17:40:54.666]                 names <- names(envs)
[17:40:54.666]                 common <- intersect(names, old_names)
[17:40:54.666]                 added <- setdiff(names, old_names)
[17:40:54.666]                 removed <- setdiff(old_names, names)
[17:40:54.666]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.666]                   envs[common]]
[17:40:54.666]                 NAMES <- toupper(changed)
[17:40:54.666]                 args <- list()
[17:40:54.666]                 for (kk in seq_along(NAMES)) {
[17:40:54.666]                   name <- changed[[kk]]
[17:40:54.666]                   NAME <- NAMES[[kk]]
[17:40:54.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.666]                     next
[17:40:54.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.666]                 }
[17:40:54.666]                 NAMES <- toupper(added)
[17:40:54.666]                 for (kk in seq_along(NAMES)) {
[17:40:54.666]                   name <- added[[kk]]
[17:40:54.666]                   NAME <- NAMES[[kk]]
[17:40:54.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.666]                     next
[17:40:54.666]                   args[[name]] <- ""
[17:40:54.666]                 }
[17:40:54.666]                 NAMES <- toupper(removed)
[17:40:54.666]                 for (kk in seq_along(NAMES)) {
[17:40:54.666]                   name <- removed[[kk]]
[17:40:54.666]                   NAME <- NAMES[[kk]]
[17:40:54.666]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.666]                     next
[17:40:54.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.666]                 }
[17:40:54.666]                 if (length(args) > 0) 
[17:40:54.666]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.666]             }
[17:40:54.666]             else {
[17:40:54.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.666]             }
[17:40:54.666]             {
[17:40:54.666]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.666]                   0L) {
[17:40:54.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.666]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.666]                   base::options(opts)
[17:40:54.666]                 }
[17:40:54.666]                 {
[17:40:54.666]                   {
[17:40:54.666]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.666]                     NULL
[17:40:54.666]                   }
[17:40:54.666]                   options(future.plan = NULL)
[17:40:54.666]                   if (is.na(NA_character_)) 
[17:40:54.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.666]                     .init = FALSE)
[17:40:54.666]                 }
[17:40:54.666]             }
[17:40:54.666]         }
[17:40:54.666]     })
[17:40:54.666]     if (TRUE) {
[17:40:54.666]         base::sink(type = "output", split = FALSE)
[17:40:54.666]         if (TRUE) {
[17:40:54.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.666]         }
[17:40:54.666]         else {
[17:40:54.666]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.666]         }
[17:40:54.666]         base::close(...future.stdout)
[17:40:54.666]         ...future.stdout <- NULL
[17:40:54.666]     }
[17:40:54.666]     ...future.result$conditions <- ...future.conditions
[17:40:54.666]     ...future.result$finished <- base::Sys.time()
[17:40:54.666]     ...future.result
[17:40:54.666] }
[17:40:54.669] MultisessionFuture started
[17:40:54.672] - Launch lazy future ... done
[17:40:54.672] run() for ‘MultisessionFuture’ ... done
[17:40:54.672] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.672] - Validating connection of MultisessionFuture
[17:40:54.673] - received message: FutureResult
[17:40:54.673] - Received FutureResult
[17:40:54.673] - Erased future from FutureRegistry
[17:40:54.673] result() for ClusterFuture ...
[17:40:54.673] - result already collected: FutureResult
[17:40:54.673] result() for ClusterFuture ... done
[17:40:54.673] signalConditions() ...
[17:40:54.673]  - include = ‘immediateCondition’
[17:40:54.673]  - exclude = 
[17:40:54.673]  - resignal = FALSE
[17:40:54.674]  - Number of conditions: 1
[17:40:54.674] signalConditions() ... done
[17:40:54.674] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.674] A MultisessionFuture was resolved (and resolved itself)
[17:40:54.674] getGlobalsAndPackages() ...
[17:40:54.674] Searching for globals...
[17:40:54.675] - globals found: [2] ‘list’, ‘stop’
[17:40:54.675] Searching for globals ... DONE
[17:40:54.675] Resolving globals: FALSE
[17:40:54.675] 
[17:40:54.675] 
[17:40:54.675] getGlobalsAndPackages() ... DONE
[17:40:54.675] run() for ‘Future’ ...
[17:40:54.676] - state: ‘created’
[17:40:54.676] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.689]   - Field: ‘node’
[17:40:54.689]   - Field: ‘label’
[17:40:54.690]   - Field: ‘local’
[17:40:54.690]   - Field: ‘owner’
[17:40:54.690]   - Field: ‘envir’
[17:40:54.690]   - Field: ‘workers’
[17:40:54.690]   - Field: ‘packages’
[17:40:54.690]   - Field: ‘gc’
[17:40:54.690]   - Field: ‘conditions’
[17:40:54.690]   - Field: ‘persistent’
[17:40:54.690]   - Field: ‘expr’
[17:40:54.690]   - Field: ‘uuid’
[17:40:54.690]   - Field: ‘seed’
[17:40:54.690]   - Field: ‘version’
[17:40:54.691]   - Field: ‘result’
[17:40:54.691]   - Field: ‘asynchronous’
[17:40:54.691]   - Field: ‘calls’
[17:40:54.691]   - Field: ‘globals’
[17:40:54.691]   - Field: ‘stdout’
[17:40:54.691]   - Field: ‘earlySignal’
[17:40:54.691]   - Field: ‘lazy’
[17:40:54.691]   - Field: ‘state’
[17:40:54.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.691] - Launch lazy future ...
[17:40:54.692] Packages needed by the future expression (n = 0): <none>
[17:40:54.692] Packages needed by future strategies (n = 0): <none>
[17:40:54.692] {
[17:40:54.692]     {
[17:40:54.692]         {
[17:40:54.692]             ...future.startTime <- base::Sys.time()
[17:40:54.692]             {
[17:40:54.692]                 {
[17:40:54.692]                   {
[17:40:54.692]                     {
[17:40:54.692]                       base::local({
[17:40:54.692]                         has_future <- base::requireNamespace("future", 
[17:40:54.692]                           quietly = TRUE)
[17:40:54.692]                         if (has_future) {
[17:40:54.692]                           ns <- base::getNamespace("future")
[17:40:54.692]                           version <- ns[[".package"]][["version"]]
[17:40:54.692]                           if (is.null(version)) 
[17:40:54.692]                             version <- utils::packageVersion("future")
[17:40:54.692]                         }
[17:40:54.692]                         else {
[17:40:54.692]                           version <- NULL
[17:40:54.692]                         }
[17:40:54.692]                         if (!has_future || version < "1.8.0") {
[17:40:54.692]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.692]                             "", base::R.version$version.string), 
[17:40:54.692]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.692]                               "release", "version")], collapse = " "), 
[17:40:54.692]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.692]                             info)
[17:40:54.692]                           info <- base::paste(info, collapse = "; ")
[17:40:54.692]                           if (!has_future) {
[17:40:54.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.692]                               info)
[17:40:54.692]                           }
[17:40:54.692]                           else {
[17:40:54.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.692]                               info, version)
[17:40:54.692]                           }
[17:40:54.692]                           base::stop(msg)
[17:40:54.692]                         }
[17:40:54.692]                       })
[17:40:54.692]                     }
[17:40:54.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.692]                     base::options(mc.cores = 1L)
[17:40:54.692]                   }
[17:40:54.692]                   ...future.strategy.old <- future::plan("list")
[17:40:54.692]                   options(future.plan = NULL)
[17:40:54.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.692]                 }
[17:40:54.692]                 ...future.workdir <- getwd()
[17:40:54.692]             }
[17:40:54.692]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.692]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.692]         }
[17:40:54.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.692]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.692]             base::names(...future.oldOptions))
[17:40:54.692]     }
[17:40:54.692]     if (FALSE) {
[17:40:54.692]     }
[17:40:54.692]     else {
[17:40:54.692]         if (TRUE) {
[17:40:54.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.692]                 open = "w")
[17:40:54.692]         }
[17:40:54.692]         else {
[17:40:54.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.692]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.692]         }
[17:40:54.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.692]             base::sink(type = "output", split = FALSE)
[17:40:54.692]             base::close(...future.stdout)
[17:40:54.692]         }, add = TRUE)
[17:40:54.692]     }
[17:40:54.692]     ...future.frame <- base::sys.nframe()
[17:40:54.692]     ...future.conditions <- base::list()
[17:40:54.692]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.692]     if (FALSE) {
[17:40:54.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.692]     }
[17:40:54.692]     ...future.result <- base::tryCatch({
[17:40:54.692]         base::withCallingHandlers({
[17:40:54.692]             ...future.value <- base::withVisible(base::local({
[17:40:54.692]                 ...future.makeSendCondition <- base::local({
[17:40:54.692]                   sendCondition <- NULL
[17:40:54.692]                   function(frame = 1L) {
[17:40:54.692]                     if (is.function(sendCondition)) 
[17:40:54.692]                       return(sendCondition)
[17:40:54.692]                     ns <- getNamespace("parallel")
[17:40:54.692]                     if (exists("sendData", mode = "function", 
[17:40:54.692]                       envir = ns)) {
[17:40:54.692]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.692]                         envir = ns)
[17:40:54.692]                       envir <- sys.frame(frame)
[17:40:54.692]                       master <- NULL
[17:40:54.692]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.692]                         !identical(envir, emptyenv())) {
[17:40:54.692]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.692]                           inherits = FALSE)) {
[17:40:54.692]                           master <- get("master", mode = "list", 
[17:40:54.692]                             envir = envir, inherits = FALSE)
[17:40:54.692]                           if (inherits(master, c("SOCKnode", 
[17:40:54.692]                             "SOCK0node"))) {
[17:40:54.692]                             sendCondition <<- function(cond) {
[17:40:54.692]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.692]                                 success = TRUE)
[17:40:54.692]                               parallel_sendData(master, data)
[17:40:54.692]                             }
[17:40:54.692]                             return(sendCondition)
[17:40:54.692]                           }
[17:40:54.692]                         }
[17:40:54.692]                         frame <- frame + 1L
[17:40:54.692]                         envir <- sys.frame(frame)
[17:40:54.692]                       }
[17:40:54.692]                     }
[17:40:54.692]                     sendCondition <<- function(cond) NULL
[17:40:54.692]                   }
[17:40:54.692]                 })
[17:40:54.692]                 withCallingHandlers({
[17:40:54.692]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:54.692]                 }, immediateCondition = function(cond) {
[17:40:54.692]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.692]                   sendCondition(cond)
[17:40:54.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.692]                   {
[17:40:54.692]                     inherits <- base::inherits
[17:40:54.692]                     invokeRestart <- base::invokeRestart
[17:40:54.692]                     is.null <- base::is.null
[17:40:54.692]                     muffled <- FALSE
[17:40:54.692]                     if (inherits(cond, "message")) {
[17:40:54.692]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.692]                       if (muffled) 
[17:40:54.692]                         invokeRestart("muffleMessage")
[17:40:54.692]                     }
[17:40:54.692]                     else if (inherits(cond, "warning")) {
[17:40:54.692]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.692]                       if (muffled) 
[17:40:54.692]                         invokeRestart("muffleWarning")
[17:40:54.692]                     }
[17:40:54.692]                     else if (inherits(cond, "condition")) {
[17:40:54.692]                       if (!is.null(pattern)) {
[17:40:54.692]                         computeRestarts <- base::computeRestarts
[17:40:54.692]                         grepl <- base::grepl
[17:40:54.692]                         restarts <- computeRestarts(cond)
[17:40:54.692]                         for (restart in restarts) {
[17:40:54.692]                           name <- restart$name
[17:40:54.692]                           if (is.null(name)) 
[17:40:54.692]                             next
[17:40:54.692]                           if (!grepl(pattern, name)) 
[17:40:54.692]                             next
[17:40:54.692]                           invokeRestart(restart)
[17:40:54.692]                           muffled <- TRUE
[17:40:54.692]                           break
[17:40:54.692]                         }
[17:40:54.692]                       }
[17:40:54.692]                     }
[17:40:54.692]                     invisible(muffled)
[17:40:54.692]                   }
[17:40:54.692]                   muffleCondition(cond)
[17:40:54.692]                 })
[17:40:54.692]             }))
[17:40:54.692]             future::FutureResult(value = ...future.value$value, 
[17:40:54.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.692]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.692]                     ...future.globalenv.names))
[17:40:54.692]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.692]         }, condition = base::local({
[17:40:54.692]             c <- base::c
[17:40:54.692]             inherits <- base::inherits
[17:40:54.692]             invokeRestart <- base::invokeRestart
[17:40:54.692]             length <- base::length
[17:40:54.692]             list <- base::list
[17:40:54.692]             seq.int <- base::seq.int
[17:40:54.692]             signalCondition <- base::signalCondition
[17:40:54.692]             sys.calls <- base::sys.calls
[17:40:54.692]             `[[` <- base::`[[`
[17:40:54.692]             `+` <- base::`+`
[17:40:54.692]             `<<-` <- base::`<<-`
[17:40:54.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.692]                   3L)]
[17:40:54.692]             }
[17:40:54.692]             function(cond) {
[17:40:54.692]                 is_error <- inherits(cond, "error")
[17:40:54.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.692]                   NULL)
[17:40:54.692]                 if (is_error) {
[17:40:54.692]                   sessionInformation <- function() {
[17:40:54.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.692]                       search = base::search(), system = base::Sys.info())
[17:40:54.692]                   }
[17:40:54.692]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.692]                     cond$call), session = sessionInformation(), 
[17:40:54.692]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.692]                   signalCondition(cond)
[17:40:54.692]                 }
[17:40:54.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.692]                 "immediateCondition"))) {
[17:40:54.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.692]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.692]                   if (TRUE && !signal) {
[17:40:54.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.692]                     {
[17:40:54.692]                       inherits <- base::inherits
[17:40:54.692]                       invokeRestart <- base::invokeRestart
[17:40:54.692]                       is.null <- base::is.null
[17:40:54.692]                       muffled <- FALSE
[17:40:54.692]                       if (inherits(cond, "message")) {
[17:40:54.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.692]                         if (muffled) 
[17:40:54.692]                           invokeRestart("muffleMessage")
[17:40:54.692]                       }
[17:40:54.692]                       else if (inherits(cond, "warning")) {
[17:40:54.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.692]                         if (muffled) 
[17:40:54.692]                           invokeRestart("muffleWarning")
[17:40:54.692]                       }
[17:40:54.692]                       else if (inherits(cond, "condition")) {
[17:40:54.692]                         if (!is.null(pattern)) {
[17:40:54.692]                           computeRestarts <- base::computeRestarts
[17:40:54.692]                           grepl <- base::grepl
[17:40:54.692]                           restarts <- computeRestarts(cond)
[17:40:54.692]                           for (restart in restarts) {
[17:40:54.692]                             name <- restart$name
[17:40:54.692]                             if (is.null(name)) 
[17:40:54.692]                               next
[17:40:54.692]                             if (!grepl(pattern, name)) 
[17:40:54.692]                               next
[17:40:54.692]                             invokeRestart(restart)
[17:40:54.692]                             muffled <- TRUE
[17:40:54.692]                             break
[17:40:54.692]                           }
[17:40:54.692]                         }
[17:40:54.692]                       }
[17:40:54.692]                       invisible(muffled)
[17:40:54.692]                     }
[17:40:54.692]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.692]                   }
[17:40:54.692]                 }
[17:40:54.692]                 else {
[17:40:54.692]                   if (TRUE) {
[17:40:54.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.692]                     {
[17:40:54.692]                       inherits <- base::inherits
[17:40:54.692]                       invokeRestart <- base::invokeRestart
[17:40:54.692]                       is.null <- base::is.null
[17:40:54.692]                       muffled <- FALSE
[17:40:54.692]                       if (inherits(cond, "message")) {
[17:40:54.692]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.692]                         if (muffled) 
[17:40:54.692]                           invokeRestart("muffleMessage")
[17:40:54.692]                       }
[17:40:54.692]                       else if (inherits(cond, "warning")) {
[17:40:54.692]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.692]                         if (muffled) 
[17:40:54.692]                           invokeRestart("muffleWarning")
[17:40:54.692]                       }
[17:40:54.692]                       else if (inherits(cond, "condition")) {
[17:40:54.692]                         if (!is.null(pattern)) {
[17:40:54.692]                           computeRestarts <- base::computeRestarts
[17:40:54.692]                           grepl <- base::grepl
[17:40:54.692]                           restarts <- computeRestarts(cond)
[17:40:54.692]                           for (restart in restarts) {
[17:40:54.692]                             name <- restart$name
[17:40:54.692]                             if (is.null(name)) 
[17:40:54.692]                               next
[17:40:54.692]                             if (!grepl(pattern, name)) 
[17:40:54.692]                               next
[17:40:54.692]                             invokeRestart(restart)
[17:40:54.692]                             muffled <- TRUE
[17:40:54.692]                             break
[17:40:54.692]                           }
[17:40:54.692]                         }
[17:40:54.692]                       }
[17:40:54.692]                       invisible(muffled)
[17:40:54.692]                     }
[17:40:54.692]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.692]                   }
[17:40:54.692]                 }
[17:40:54.692]             }
[17:40:54.692]         }))
[17:40:54.692]     }, error = function(ex) {
[17:40:54.692]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.692]                 ...future.rng), started = ...future.startTime, 
[17:40:54.692]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.692]             version = "1.8"), class = "FutureResult")
[17:40:54.692]     }, finally = {
[17:40:54.692]         if (!identical(...future.workdir, getwd())) 
[17:40:54.692]             setwd(...future.workdir)
[17:40:54.692]         {
[17:40:54.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.692]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.692]             }
[17:40:54.692]             base::options(...future.oldOptions)
[17:40:54.692]             if (.Platform$OS.type == "windows") {
[17:40:54.692]                 old_names <- names(...future.oldEnvVars)
[17:40:54.692]                 envs <- base::Sys.getenv()
[17:40:54.692]                 names <- names(envs)
[17:40:54.692]                 common <- intersect(names, old_names)
[17:40:54.692]                 added <- setdiff(names, old_names)
[17:40:54.692]                 removed <- setdiff(old_names, names)
[17:40:54.692]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.692]                   envs[common]]
[17:40:54.692]                 NAMES <- toupper(changed)
[17:40:54.692]                 args <- list()
[17:40:54.692]                 for (kk in seq_along(NAMES)) {
[17:40:54.692]                   name <- changed[[kk]]
[17:40:54.692]                   NAME <- NAMES[[kk]]
[17:40:54.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.692]                     next
[17:40:54.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.692]                 }
[17:40:54.692]                 NAMES <- toupper(added)
[17:40:54.692]                 for (kk in seq_along(NAMES)) {
[17:40:54.692]                   name <- added[[kk]]
[17:40:54.692]                   NAME <- NAMES[[kk]]
[17:40:54.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.692]                     next
[17:40:54.692]                   args[[name]] <- ""
[17:40:54.692]                 }
[17:40:54.692]                 NAMES <- toupper(removed)
[17:40:54.692]                 for (kk in seq_along(NAMES)) {
[17:40:54.692]                   name <- removed[[kk]]
[17:40:54.692]                   NAME <- NAMES[[kk]]
[17:40:54.692]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.692]                     next
[17:40:54.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.692]                 }
[17:40:54.692]                 if (length(args) > 0) 
[17:40:54.692]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.692]             }
[17:40:54.692]             else {
[17:40:54.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.692]             }
[17:40:54.692]             {
[17:40:54.692]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.692]                   0L) {
[17:40:54.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.692]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.692]                   base::options(opts)
[17:40:54.692]                 }
[17:40:54.692]                 {
[17:40:54.692]                   {
[17:40:54.692]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.692]                     NULL
[17:40:54.692]                   }
[17:40:54.692]                   options(future.plan = NULL)
[17:40:54.692]                   if (is.na(NA_character_)) 
[17:40:54.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.692]                     .init = FALSE)
[17:40:54.692]                 }
[17:40:54.692]             }
[17:40:54.692]         }
[17:40:54.692]     })
[17:40:54.692]     if (TRUE) {
[17:40:54.692]         base::sink(type = "output", split = FALSE)
[17:40:54.692]         if (TRUE) {
[17:40:54.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.692]         }
[17:40:54.692]         else {
[17:40:54.692]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.692]         }
[17:40:54.692]         base::close(...future.stdout)
[17:40:54.692]         ...future.stdout <- NULL
[17:40:54.692]     }
[17:40:54.692]     ...future.result$conditions <- ...future.conditions
[17:40:54.692]     ...future.result$finished <- base::Sys.time()
[17:40:54.692]     ...future.result
[17:40:54.692] }
[17:40:54.695] MultisessionFuture started
[17:40:54.695] - Launch lazy future ... done
[17:40:54.695] run() for ‘MultisessionFuture’ ... done
[17:40:54.697] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.697] - Validating connection of MultisessionFuture
[17:40:54.697] - received message: FutureResult
[17:40:54.697] - Received FutureResult
[17:40:54.698] - Erased future from FutureRegistry
[17:40:54.698] result() for ClusterFuture ...
[17:40:54.698] - result already collected: FutureResult
[17:40:54.698] result() for ClusterFuture ... done
[17:40:54.698] signalConditions() ...
[17:40:54.698]  - include = ‘immediateCondition’
[17:40:54.698]  - exclude = 
[17:40:54.698]  - resignal = FALSE
[17:40:54.698]  - Number of conditions: 1
[17:40:54.698] signalConditions() ... done
[17:40:54.698] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.698] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[17:40:54.699] getGlobalsAndPackages() ...
[17:40:54.699] Searching for globals...
[17:40:54.700] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:54.700] Searching for globals ... DONE
[17:40:54.700] Resolving globals: FALSE
[17:40:54.700] 
[17:40:54.700] 
[17:40:54.701] getGlobalsAndPackages() ... DONE
[17:40:54.701] run() for ‘Future’ ...
[17:40:54.701] - state: ‘created’
[17:40:54.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.714] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.714] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.714]   - Field: ‘node’
[17:40:54.715]   - Field: ‘label’
[17:40:54.715]   - Field: ‘local’
[17:40:54.715]   - Field: ‘owner’
[17:40:54.715]   - Field: ‘envir’
[17:40:54.715]   - Field: ‘workers’
[17:40:54.715]   - Field: ‘packages’
[17:40:54.715]   - Field: ‘gc’
[17:40:54.715]   - Field: ‘conditions’
[17:40:54.715]   - Field: ‘persistent’
[17:40:54.715]   - Field: ‘expr’
[17:40:54.715]   - Field: ‘uuid’
[17:40:54.716]   - Field: ‘seed’
[17:40:54.716]   - Field: ‘version’
[17:40:54.716]   - Field: ‘result’
[17:40:54.716]   - Field: ‘asynchronous’
[17:40:54.716]   - Field: ‘calls’
[17:40:54.716]   - Field: ‘globals’
[17:40:54.716]   - Field: ‘stdout’
[17:40:54.716]   - Field: ‘earlySignal’
[17:40:54.716]   - Field: ‘lazy’
[17:40:54.716]   - Field: ‘state’
[17:40:54.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.717] - Launch lazy future ...
[17:40:54.717] Packages needed by the future expression (n = 0): <none>
[17:40:54.717] Packages needed by future strategies (n = 0): <none>
[17:40:54.717] {
[17:40:54.717]     {
[17:40:54.717]         {
[17:40:54.717]             ...future.startTime <- base::Sys.time()
[17:40:54.717]             {
[17:40:54.717]                 {
[17:40:54.717]                   {
[17:40:54.717]                     {
[17:40:54.717]                       base::local({
[17:40:54.717]                         has_future <- base::requireNamespace("future", 
[17:40:54.717]                           quietly = TRUE)
[17:40:54.717]                         if (has_future) {
[17:40:54.717]                           ns <- base::getNamespace("future")
[17:40:54.717]                           version <- ns[[".package"]][["version"]]
[17:40:54.717]                           if (is.null(version)) 
[17:40:54.717]                             version <- utils::packageVersion("future")
[17:40:54.717]                         }
[17:40:54.717]                         else {
[17:40:54.717]                           version <- NULL
[17:40:54.717]                         }
[17:40:54.717]                         if (!has_future || version < "1.8.0") {
[17:40:54.717]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.717]                             "", base::R.version$version.string), 
[17:40:54.717]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.717]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.717]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.717]                               "release", "version")], collapse = " "), 
[17:40:54.717]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.717]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.717]                             info)
[17:40:54.717]                           info <- base::paste(info, collapse = "; ")
[17:40:54.717]                           if (!has_future) {
[17:40:54.717]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.717]                               info)
[17:40:54.717]                           }
[17:40:54.717]                           else {
[17:40:54.717]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.717]                               info, version)
[17:40:54.717]                           }
[17:40:54.717]                           base::stop(msg)
[17:40:54.717]                         }
[17:40:54.717]                       })
[17:40:54.717]                     }
[17:40:54.717]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.717]                     base::options(mc.cores = 1L)
[17:40:54.717]                   }
[17:40:54.717]                   ...future.strategy.old <- future::plan("list")
[17:40:54.717]                   options(future.plan = NULL)
[17:40:54.717]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.717]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.717]                 }
[17:40:54.717]                 ...future.workdir <- getwd()
[17:40:54.717]             }
[17:40:54.717]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.717]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.717]         }
[17:40:54.717]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.717]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.717]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.717]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.717]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.717]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.717]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.717]             base::names(...future.oldOptions))
[17:40:54.717]     }
[17:40:54.717]     if (FALSE) {
[17:40:54.717]     }
[17:40:54.717]     else {
[17:40:54.717]         if (TRUE) {
[17:40:54.717]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.717]                 open = "w")
[17:40:54.717]         }
[17:40:54.717]         else {
[17:40:54.717]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.717]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.717]         }
[17:40:54.717]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.717]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.717]             base::sink(type = "output", split = FALSE)
[17:40:54.717]             base::close(...future.stdout)
[17:40:54.717]         }, add = TRUE)
[17:40:54.717]     }
[17:40:54.717]     ...future.frame <- base::sys.nframe()
[17:40:54.717]     ...future.conditions <- base::list()
[17:40:54.717]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.717]     if (FALSE) {
[17:40:54.717]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.717]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.717]     }
[17:40:54.717]     ...future.result <- base::tryCatch({
[17:40:54.717]         base::withCallingHandlers({
[17:40:54.717]             ...future.value <- base::withVisible(base::local({
[17:40:54.717]                 ...future.makeSendCondition <- base::local({
[17:40:54.717]                   sendCondition <- NULL
[17:40:54.717]                   function(frame = 1L) {
[17:40:54.717]                     if (is.function(sendCondition)) 
[17:40:54.717]                       return(sendCondition)
[17:40:54.717]                     ns <- getNamespace("parallel")
[17:40:54.717]                     if (exists("sendData", mode = "function", 
[17:40:54.717]                       envir = ns)) {
[17:40:54.717]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.717]                         envir = ns)
[17:40:54.717]                       envir <- sys.frame(frame)
[17:40:54.717]                       master <- NULL
[17:40:54.717]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.717]                         !identical(envir, emptyenv())) {
[17:40:54.717]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.717]                           inherits = FALSE)) {
[17:40:54.717]                           master <- get("master", mode = "list", 
[17:40:54.717]                             envir = envir, inherits = FALSE)
[17:40:54.717]                           if (inherits(master, c("SOCKnode", 
[17:40:54.717]                             "SOCK0node"))) {
[17:40:54.717]                             sendCondition <<- function(cond) {
[17:40:54.717]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.717]                                 success = TRUE)
[17:40:54.717]                               parallel_sendData(master, data)
[17:40:54.717]                             }
[17:40:54.717]                             return(sendCondition)
[17:40:54.717]                           }
[17:40:54.717]                         }
[17:40:54.717]                         frame <- frame + 1L
[17:40:54.717]                         envir <- sys.frame(frame)
[17:40:54.717]                       }
[17:40:54.717]                     }
[17:40:54.717]                     sendCondition <<- function(cond) NULL
[17:40:54.717]                   }
[17:40:54.717]                 })
[17:40:54.717]                 withCallingHandlers({
[17:40:54.717]                   {
[17:40:54.717]                     Sys.sleep(0.5)
[17:40:54.717]                     list(a = 1, b = 42L)
[17:40:54.717]                   }
[17:40:54.717]                 }, immediateCondition = function(cond) {
[17:40:54.717]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.717]                   sendCondition(cond)
[17:40:54.717]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.717]                   {
[17:40:54.717]                     inherits <- base::inherits
[17:40:54.717]                     invokeRestart <- base::invokeRestart
[17:40:54.717]                     is.null <- base::is.null
[17:40:54.717]                     muffled <- FALSE
[17:40:54.717]                     if (inherits(cond, "message")) {
[17:40:54.717]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.717]                       if (muffled) 
[17:40:54.717]                         invokeRestart("muffleMessage")
[17:40:54.717]                     }
[17:40:54.717]                     else if (inherits(cond, "warning")) {
[17:40:54.717]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.717]                       if (muffled) 
[17:40:54.717]                         invokeRestart("muffleWarning")
[17:40:54.717]                     }
[17:40:54.717]                     else if (inherits(cond, "condition")) {
[17:40:54.717]                       if (!is.null(pattern)) {
[17:40:54.717]                         computeRestarts <- base::computeRestarts
[17:40:54.717]                         grepl <- base::grepl
[17:40:54.717]                         restarts <- computeRestarts(cond)
[17:40:54.717]                         for (restart in restarts) {
[17:40:54.717]                           name <- restart$name
[17:40:54.717]                           if (is.null(name)) 
[17:40:54.717]                             next
[17:40:54.717]                           if (!grepl(pattern, name)) 
[17:40:54.717]                             next
[17:40:54.717]                           invokeRestart(restart)
[17:40:54.717]                           muffled <- TRUE
[17:40:54.717]                           break
[17:40:54.717]                         }
[17:40:54.717]                       }
[17:40:54.717]                     }
[17:40:54.717]                     invisible(muffled)
[17:40:54.717]                   }
[17:40:54.717]                   muffleCondition(cond)
[17:40:54.717]                 })
[17:40:54.717]             }))
[17:40:54.717]             future::FutureResult(value = ...future.value$value, 
[17:40:54.717]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.717]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.717]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.717]                     ...future.globalenv.names))
[17:40:54.717]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.717]         }, condition = base::local({
[17:40:54.717]             c <- base::c
[17:40:54.717]             inherits <- base::inherits
[17:40:54.717]             invokeRestart <- base::invokeRestart
[17:40:54.717]             length <- base::length
[17:40:54.717]             list <- base::list
[17:40:54.717]             seq.int <- base::seq.int
[17:40:54.717]             signalCondition <- base::signalCondition
[17:40:54.717]             sys.calls <- base::sys.calls
[17:40:54.717]             `[[` <- base::`[[`
[17:40:54.717]             `+` <- base::`+`
[17:40:54.717]             `<<-` <- base::`<<-`
[17:40:54.717]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.717]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.717]                   3L)]
[17:40:54.717]             }
[17:40:54.717]             function(cond) {
[17:40:54.717]                 is_error <- inherits(cond, "error")
[17:40:54.717]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.717]                   NULL)
[17:40:54.717]                 if (is_error) {
[17:40:54.717]                   sessionInformation <- function() {
[17:40:54.717]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.717]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.717]                       search = base::search(), system = base::Sys.info())
[17:40:54.717]                   }
[17:40:54.717]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.717]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.717]                     cond$call), session = sessionInformation(), 
[17:40:54.717]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.717]                   signalCondition(cond)
[17:40:54.717]                 }
[17:40:54.717]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.717]                 "immediateCondition"))) {
[17:40:54.717]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.717]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.717]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.717]                   if (TRUE && !signal) {
[17:40:54.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.717]                     {
[17:40:54.717]                       inherits <- base::inherits
[17:40:54.717]                       invokeRestart <- base::invokeRestart
[17:40:54.717]                       is.null <- base::is.null
[17:40:54.717]                       muffled <- FALSE
[17:40:54.717]                       if (inherits(cond, "message")) {
[17:40:54.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.717]                         if (muffled) 
[17:40:54.717]                           invokeRestart("muffleMessage")
[17:40:54.717]                       }
[17:40:54.717]                       else if (inherits(cond, "warning")) {
[17:40:54.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.717]                         if (muffled) 
[17:40:54.717]                           invokeRestart("muffleWarning")
[17:40:54.717]                       }
[17:40:54.717]                       else if (inherits(cond, "condition")) {
[17:40:54.717]                         if (!is.null(pattern)) {
[17:40:54.717]                           computeRestarts <- base::computeRestarts
[17:40:54.717]                           grepl <- base::grepl
[17:40:54.717]                           restarts <- computeRestarts(cond)
[17:40:54.717]                           for (restart in restarts) {
[17:40:54.717]                             name <- restart$name
[17:40:54.717]                             if (is.null(name)) 
[17:40:54.717]                               next
[17:40:54.717]                             if (!grepl(pattern, name)) 
[17:40:54.717]                               next
[17:40:54.717]                             invokeRestart(restart)
[17:40:54.717]                             muffled <- TRUE
[17:40:54.717]                             break
[17:40:54.717]                           }
[17:40:54.717]                         }
[17:40:54.717]                       }
[17:40:54.717]                       invisible(muffled)
[17:40:54.717]                     }
[17:40:54.717]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.717]                   }
[17:40:54.717]                 }
[17:40:54.717]                 else {
[17:40:54.717]                   if (TRUE) {
[17:40:54.717]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.717]                     {
[17:40:54.717]                       inherits <- base::inherits
[17:40:54.717]                       invokeRestart <- base::invokeRestart
[17:40:54.717]                       is.null <- base::is.null
[17:40:54.717]                       muffled <- FALSE
[17:40:54.717]                       if (inherits(cond, "message")) {
[17:40:54.717]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.717]                         if (muffled) 
[17:40:54.717]                           invokeRestart("muffleMessage")
[17:40:54.717]                       }
[17:40:54.717]                       else if (inherits(cond, "warning")) {
[17:40:54.717]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.717]                         if (muffled) 
[17:40:54.717]                           invokeRestart("muffleWarning")
[17:40:54.717]                       }
[17:40:54.717]                       else if (inherits(cond, "condition")) {
[17:40:54.717]                         if (!is.null(pattern)) {
[17:40:54.717]                           computeRestarts <- base::computeRestarts
[17:40:54.717]                           grepl <- base::grepl
[17:40:54.717]                           restarts <- computeRestarts(cond)
[17:40:54.717]                           for (restart in restarts) {
[17:40:54.717]                             name <- restart$name
[17:40:54.717]                             if (is.null(name)) 
[17:40:54.717]                               next
[17:40:54.717]                             if (!grepl(pattern, name)) 
[17:40:54.717]                               next
[17:40:54.717]                             invokeRestart(restart)
[17:40:54.717]                             muffled <- TRUE
[17:40:54.717]                             break
[17:40:54.717]                           }
[17:40:54.717]                         }
[17:40:54.717]                       }
[17:40:54.717]                       invisible(muffled)
[17:40:54.717]                     }
[17:40:54.717]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.717]                   }
[17:40:54.717]                 }
[17:40:54.717]             }
[17:40:54.717]         }))
[17:40:54.717]     }, error = function(ex) {
[17:40:54.717]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.717]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.717]                 ...future.rng), started = ...future.startTime, 
[17:40:54.717]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.717]             version = "1.8"), class = "FutureResult")
[17:40:54.717]     }, finally = {
[17:40:54.717]         if (!identical(...future.workdir, getwd())) 
[17:40:54.717]             setwd(...future.workdir)
[17:40:54.717]         {
[17:40:54.717]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.717]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.717]             }
[17:40:54.717]             base::options(...future.oldOptions)
[17:40:54.717]             if (.Platform$OS.type == "windows") {
[17:40:54.717]                 old_names <- names(...future.oldEnvVars)
[17:40:54.717]                 envs <- base::Sys.getenv()
[17:40:54.717]                 names <- names(envs)
[17:40:54.717]                 common <- intersect(names, old_names)
[17:40:54.717]                 added <- setdiff(names, old_names)
[17:40:54.717]                 removed <- setdiff(old_names, names)
[17:40:54.717]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.717]                   envs[common]]
[17:40:54.717]                 NAMES <- toupper(changed)
[17:40:54.717]                 args <- list()
[17:40:54.717]                 for (kk in seq_along(NAMES)) {
[17:40:54.717]                   name <- changed[[kk]]
[17:40:54.717]                   NAME <- NAMES[[kk]]
[17:40:54.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.717]                     next
[17:40:54.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.717]                 }
[17:40:54.717]                 NAMES <- toupper(added)
[17:40:54.717]                 for (kk in seq_along(NAMES)) {
[17:40:54.717]                   name <- added[[kk]]
[17:40:54.717]                   NAME <- NAMES[[kk]]
[17:40:54.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.717]                     next
[17:40:54.717]                   args[[name]] <- ""
[17:40:54.717]                 }
[17:40:54.717]                 NAMES <- toupper(removed)
[17:40:54.717]                 for (kk in seq_along(NAMES)) {
[17:40:54.717]                   name <- removed[[kk]]
[17:40:54.717]                   NAME <- NAMES[[kk]]
[17:40:54.717]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.717]                     next
[17:40:54.717]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.717]                 }
[17:40:54.717]                 if (length(args) > 0) 
[17:40:54.717]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.717]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.717]             }
[17:40:54.717]             else {
[17:40:54.717]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.717]             }
[17:40:54.717]             {
[17:40:54.717]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.717]                   0L) {
[17:40:54.717]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.717]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.717]                   base::options(opts)
[17:40:54.717]                 }
[17:40:54.717]                 {
[17:40:54.717]                   {
[17:40:54.717]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.717]                     NULL
[17:40:54.717]                   }
[17:40:54.717]                   options(future.plan = NULL)
[17:40:54.717]                   if (is.na(NA_character_)) 
[17:40:54.717]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.717]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.717]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.717]                     .init = FALSE)
[17:40:54.717]                 }
[17:40:54.717]             }
[17:40:54.717]         }
[17:40:54.717]     })
[17:40:54.717]     if (TRUE) {
[17:40:54.717]         base::sink(type = "output", split = FALSE)
[17:40:54.717]         if (TRUE) {
[17:40:54.717]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.717]         }
[17:40:54.717]         else {
[17:40:54.717]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.717]         }
[17:40:54.717]         base::close(...future.stdout)
[17:40:54.717]         ...future.stdout <- NULL
[17:40:54.717]     }
[17:40:54.717]     ...future.result$conditions <- ...future.conditions
[17:40:54.717]     ...future.result$finished <- base::Sys.time()
[17:40:54.717]     ...future.result
[17:40:54.717] }
[17:40:54.720] MultisessionFuture started
[17:40:54.720] - Launch lazy future ... done
[17:40:54.720] run() for ‘MultisessionFuture’ ... done
[17:40:54.720] getGlobalsAndPackages() ...
[17:40:54.720] Searching for globals...
[17:40:54.721] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:54.722] Searching for globals ... DONE
[17:40:54.722] Resolving globals: FALSE
[17:40:54.722] 
[17:40:54.722] 
[17:40:54.722] getGlobalsAndPackages() ... DONE
- w/ exception ...
[17:40:54.722] getGlobalsAndPackages() ...
[17:40:54.723] Searching for globals...
[17:40:54.723] - globals found: [2] ‘list’, ‘stop’
[17:40:54.723] Searching for globals ... DONE
[17:40:54.723] Resolving globals: FALSE
[17:40:54.724] 
[17:40:54.724] 
[17:40:54.724] getGlobalsAndPackages() ... DONE
[17:40:54.724] run() for ‘Future’ ...
[17:40:54.724] - state: ‘created’
[17:40:54.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.738] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.738]   - Field: ‘node’
[17:40:54.738]   - Field: ‘label’
[17:40:54.738]   - Field: ‘local’
[17:40:54.738]   - Field: ‘owner’
[17:40:54.738]   - Field: ‘envir’
[17:40:54.738]   - Field: ‘workers’
[17:40:54.738]   - Field: ‘packages’
[17:40:54.738]   - Field: ‘gc’
[17:40:54.739]   - Field: ‘conditions’
[17:40:54.739]   - Field: ‘persistent’
[17:40:54.739]   - Field: ‘expr’
[17:40:54.739]   - Field: ‘uuid’
[17:40:54.739]   - Field: ‘seed’
[17:40:54.739]   - Field: ‘version’
[17:40:54.739]   - Field: ‘result’
[17:40:54.739]   - Field: ‘asynchronous’
[17:40:54.739]   - Field: ‘calls’
[17:40:54.739]   - Field: ‘globals’
[17:40:54.739]   - Field: ‘stdout’
[17:40:54.740]   - Field: ‘earlySignal’
[17:40:54.740]   - Field: ‘lazy’
[17:40:54.740]   - Field: ‘state’
[17:40:54.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.740] - Launch lazy future ...
[17:40:54.740] Packages needed by the future expression (n = 0): <none>
[17:40:54.740] Packages needed by future strategies (n = 0): <none>
[17:40:54.741] {
[17:40:54.741]     {
[17:40:54.741]         {
[17:40:54.741]             ...future.startTime <- base::Sys.time()
[17:40:54.741]             {
[17:40:54.741]                 {
[17:40:54.741]                   {
[17:40:54.741]                     {
[17:40:54.741]                       base::local({
[17:40:54.741]                         has_future <- base::requireNamespace("future", 
[17:40:54.741]                           quietly = TRUE)
[17:40:54.741]                         if (has_future) {
[17:40:54.741]                           ns <- base::getNamespace("future")
[17:40:54.741]                           version <- ns[[".package"]][["version"]]
[17:40:54.741]                           if (is.null(version)) 
[17:40:54.741]                             version <- utils::packageVersion("future")
[17:40:54.741]                         }
[17:40:54.741]                         else {
[17:40:54.741]                           version <- NULL
[17:40:54.741]                         }
[17:40:54.741]                         if (!has_future || version < "1.8.0") {
[17:40:54.741]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.741]                             "", base::R.version$version.string), 
[17:40:54.741]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.741]                               "release", "version")], collapse = " "), 
[17:40:54.741]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.741]                             info)
[17:40:54.741]                           info <- base::paste(info, collapse = "; ")
[17:40:54.741]                           if (!has_future) {
[17:40:54.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.741]                               info)
[17:40:54.741]                           }
[17:40:54.741]                           else {
[17:40:54.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.741]                               info, version)
[17:40:54.741]                           }
[17:40:54.741]                           base::stop(msg)
[17:40:54.741]                         }
[17:40:54.741]                       })
[17:40:54.741]                     }
[17:40:54.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.741]                     base::options(mc.cores = 1L)
[17:40:54.741]                   }
[17:40:54.741]                   ...future.strategy.old <- future::plan("list")
[17:40:54.741]                   options(future.plan = NULL)
[17:40:54.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.741]                 }
[17:40:54.741]                 ...future.workdir <- getwd()
[17:40:54.741]             }
[17:40:54.741]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.741]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.741]         }
[17:40:54.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.741]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.741]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.741]             base::names(...future.oldOptions))
[17:40:54.741]     }
[17:40:54.741]     if (FALSE) {
[17:40:54.741]     }
[17:40:54.741]     else {
[17:40:54.741]         if (TRUE) {
[17:40:54.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.741]                 open = "w")
[17:40:54.741]         }
[17:40:54.741]         else {
[17:40:54.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.741]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.741]         }
[17:40:54.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.741]             base::sink(type = "output", split = FALSE)
[17:40:54.741]             base::close(...future.stdout)
[17:40:54.741]         }, add = TRUE)
[17:40:54.741]     }
[17:40:54.741]     ...future.frame <- base::sys.nframe()
[17:40:54.741]     ...future.conditions <- base::list()
[17:40:54.741]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.741]     if (FALSE) {
[17:40:54.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.741]     }
[17:40:54.741]     ...future.result <- base::tryCatch({
[17:40:54.741]         base::withCallingHandlers({
[17:40:54.741]             ...future.value <- base::withVisible(base::local({
[17:40:54.741]                 ...future.makeSendCondition <- base::local({
[17:40:54.741]                   sendCondition <- NULL
[17:40:54.741]                   function(frame = 1L) {
[17:40:54.741]                     if (is.function(sendCondition)) 
[17:40:54.741]                       return(sendCondition)
[17:40:54.741]                     ns <- getNamespace("parallel")
[17:40:54.741]                     if (exists("sendData", mode = "function", 
[17:40:54.741]                       envir = ns)) {
[17:40:54.741]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.741]                         envir = ns)
[17:40:54.741]                       envir <- sys.frame(frame)
[17:40:54.741]                       master <- NULL
[17:40:54.741]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.741]                         !identical(envir, emptyenv())) {
[17:40:54.741]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.741]                           inherits = FALSE)) {
[17:40:54.741]                           master <- get("master", mode = "list", 
[17:40:54.741]                             envir = envir, inherits = FALSE)
[17:40:54.741]                           if (inherits(master, c("SOCKnode", 
[17:40:54.741]                             "SOCK0node"))) {
[17:40:54.741]                             sendCondition <<- function(cond) {
[17:40:54.741]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.741]                                 success = TRUE)
[17:40:54.741]                               parallel_sendData(master, data)
[17:40:54.741]                             }
[17:40:54.741]                             return(sendCondition)
[17:40:54.741]                           }
[17:40:54.741]                         }
[17:40:54.741]                         frame <- frame + 1L
[17:40:54.741]                         envir <- sys.frame(frame)
[17:40:54.741]                       }
[17:40:54.741]                     }
[17:40:54.741]                     sendCondition <<- function(cond) NULL
[17:40:54.741]                   }
[17:40:54.741]                 })
[17:40:54.741]                 withCallingHandlers({
[17:40:54.741]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:54.741]                 }, immediateCondition = function(cond) {
[17:40:54.741]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.741]                   sendCondition(cond)
[17:40:54.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.741]                   {
[17:40:54.741]                     inherits <- base::inherits
[17:40:54.741]                     invokeRestart <- base::invokeRestart
[17:40:54.741]                     is.null <- base::is.null
[17:40:54.741]                     muffled <- FALSE
[17:40:54.741]                     if (inherits(cond, "message")) {
[17:40:54.741]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.741]                       if (muffled) 
[17:40:54.741]                         invokeRestart("muffleMessage")
[17:40:54.741]                     }
[17:40:54.741]                     else if (inherits(cond, "warning")) {
[17:40:54.741]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.741]                       if (muffled) 
[17:40:54.741]                         invokeRestart("muffleWarning")
[17:40:54.741]                     }
[17:40:54.741]                     else if (inherits(cond, "condition")) {
[17:40:54.741]                       if (!is.null(pattern)) {
[17:40:54.741]                         computeRestarts <- base::computeRestarts
[17:40:54.741]                         grepl <- base::grepl
[17:40:54.741]                         restarts <- computeRestarts(cond)
[17:40:54.741]                         for (restart in restarts) {
[17:40:54.741]                           name <- restart$name
[17:40:54.741]                           if (is.null(name)) 
[17:40:54.741]                             next
[17:40:54.741]                           if (!grepl(pattern, name)) 
[17:40:54.741]                             next
[17:40:54.741]                           invokeRestart(restart)
[17:40:54.741]                           muffled <- TRUE
[17:40:54.741]                           break
[17:40:54.741]                         }
[17:40:54.741]                       }
[17:40:54.741]                     }
[17:40:54.741]                     invisible(muffled)
[17:40:54.741]                   }
[17:40:54.741]                   muffleCondition(cond)
[17:40:54.741]                 })
[17:40:54.741]             }))
[17:40:54.741]             future::FutureResult(value = ...future.value$value, 
[17:40:54.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.741]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.741]                     ...future.globalenv.names))
[17:40:54.741]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.741]         }, condition = base::local({
[17:40:54.741]             c <- base::c
[17:40:54.741]             inherits <- base::inherits
[17:40:54.741]             invokeRestart <- base::invokeRestart
[17:40:54.741]             length <- base::length
[17:40:54.741]             list <- base::list
[17:40:54.741]             seq.int <- base::seq.int
[17:40:54.741]             signalCondition <- base::signalCondition
[17:40:54.741]             sys.calls <- base::sys.calls
[17:40:54.741]             `[[` <- base::`[[`
[17:40:54.741]             `+` <- base::`+`
[17:40:54.741]             `<<-` <- base::`<<-`
[17:40:54.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.741]                   3L)]
[17:40:54.741]             }
[17:40:54.741]             function(cond) {
[17:40:54.741]                 is_error <- inherits(cond, "error")
[17:40:54.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.741]                   NULL)
[17:40:54.741]                 if (is_error) {
[17:40:54.741]                   sessionInformation <- function() {
[17:40:54.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.741]                       search = base::search(), system = base::Sys.info())
[17:40:54.741]                   }
[17:40:54.741]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.741]                     cond$call), session = sessionInformation(), 
[17:40:54.741]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.741]                   signalCondition(cond)
[17:40:54.741]                 }
[17:40:54.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.741]                 "immediateCondition"))) {
[17:40:54.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.741]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.741]                   if (TRUE && !signal) {
[17:40:54.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.741]                     {
[17:40:54.741]                       inherits <- base::inherits
[17:40:54.741]                       invokeRestart <- base::invokeRestart
[17:40:54.741]                       is.null <- base::is.null
[17:40:54.741]                       muffled <- FALSE
[17:40:54.741]                       if (inherits(cond, "message")) {
[17:40:54.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.741]                         if (muffled) 
[17:40:54.741]                           invokeRestart("muffleMessage")
[17:40:54.741]                       }
[17:40:54.741]                       else if (inherits(cond, "warning")) {
[17:40:54.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.741]                         if (muffled) 
[17:40:54.741]                           invokeRestart("muffleWarning")
[17:40:54.741]                       }
[17:40:54.741]                       else if (inherits(cond, "condition")) {
[17:40:54.741]                         if (!is.null(pattern)) {
[17:40:54.741]                           computeRestarts <- base::computeRestarts
[17:40:54.741]                           grepl <- base::grepl
[17:40:54.741]                           restarts <- computeRestarts(cond)
[17:40:54.741]                           for (restart in restarts) {
[17:40:54.741]                             name <- restart$name
[17:40:54.741]                             if (is.null(name)) 
[17:40:54.741]                               next
[17:40:54.741]                             if (!grepl(pattern, name)) 
[17:40:54.741]                               next
[17:40:54.741]                             invokeRestart(restart)
[17:40:54.741]                             muffled <- TRUE
[17:40:54.741]                             break
[17:40:54.741]                           }
[17:40:54.741]                         }
[17:40:54.741]                       }
[17:40:54.741]                       invisible(muffled)
[17:40:54.741]                     }
[17:40:54.741]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.741]                   }
[17:40:54.741]                 }
[17:40:54.741]                 else {
[17:40:54.741]                   if (TRUE) {
[17:40:54.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.741]                     {
[17:40:54.741]                       inherits <- base::inherits
[17:40:54.741]                       invokeRestart <- base::invokeRestart
[17:40:54.741]                       is.null <- base::is.null
[17:40:54.741]                       muffled <- FALSE
[17:40:54.741]                       if (inherits(cond, "message")) {
[17:40:54.741]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.741]                         if (muffled) 
[17:40:54.741]                           invokeRestart("muffleMessage")
[17:40:54.741]                       }
[17:40:54.741]                       else if (inherits(cond, "warning")) {
[17:40:54.741]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.741]                         if (muffled) 
[17:40:54.741]                           invokeRestart("muffleWarning")
[17:40:54.741]                       }
[17:40:54.741]                       else if (inherits(cond, "condition")) {
[17:40:54.741]                         if (!is.null(pattern)) {
[17:40:54.741]                           computeRestarts <- base::computeRestarts
[17:40:54.741]                           grepl <- base::grepl
[17:40:54.741]                           restarts <- computeRestarts(cond)
[17:40:54.741]                           for (restart in restarts) {
[17:40:54.741]                             name <- restart$name
[17:40:54.741]                             if (is.null(name)) 
[17:40:54.741]                               next
[17:40:54.741]                             if (!grepl(pattern, name)) 
[17:40:54.741]                               next
[17:40:54.741]                             invokeRestart(restart)
[17:40:54.741]                             muffled <- TRUE
[17:40:54.741]                             break
[17:40:54.741]                           }
[17:40:54.741]                         }
[17:40:54.741]                       }
[17:40:54.741]                       invisible(muffled)
[17:40:54.741]                     }
[17:40:54.741]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.741]                   }
[17:40:54.741]                 }
[17:40:54.741]             }
[17:40:54.741]         }))
[17:40:54.741]     }, error = function(ex) {
[17:40:54.741]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.741]                 ...future.rng), started = ...future.startTime, 
[17:40:54.741]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.741]             version = "1.8"), class = "FutureResult")
[17:40:54.741]     }, finally = {
[17:40:54.741]         if (!identical(...future.workdir, getwd())) 
[17:40:54.741]             setwd(...future.workdir)
[17:40:54.741]         {
[17:40:54.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.741]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.741]             }
[17:40:54.741]             base::options(...future.oldOptions)
[17:40:54.741]             if (.Platform$OS.type == "windows") {
[17:40:54.741]                 old_names <- names(...future.oldEnvVars)
[17:40:54.741]                 envs <- base::Sys.getenv()
[17:40:54.741]                 names <- names(envs)
[17:40:54.741]                 common <- intersect(names, old_names)
[17:40:54.741]                 added <- setdiff(names, old_names)
[17:40:54.741]                 removed <- setdiff(old_names, names)
[17:40:54.741]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.741]                   envs[common]]
[17:40:54.741]                 NAMES <- toupper(changed)
[17:40:54.741]                 args <- list()
[17:40:54.741]                 for (kk in seq_along(NAMES)) {
[17:40:54.741]                   name <- changed[[kk]]
[17:40:54.741]                   NAME <- NAMES[[kk]]
[17:40:54.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.741]                     next
[17:40:54.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.741]                 }
[17:40:54.741]                 NAMES <- toupper(added)
[17:40:54.741]                 for (kk in seq_along(NAMES)) {
[17:40:54.741]                   name <- added[[kk]]
[17:40:54.741]                   NAME <- NAMES[[kk]]
[17:40:54.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.741]                     next
[17:40:54.741]                   args[[name]] <- ""
[17:40:54.741]                 }
[17:40:54.741]                 NAMES <- toupper(removed)
[17:40:54.741]                 for (kk in seq_along(NAMES)) {
[17:40:54.741]                   name <- removed[[kk]]
[17:40:54.741]                   NAME <- NAMES[[kk]]
[17:40:54.741]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.741]                     next
[17:40:54.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.741]                 }
[17:40:54.741]                 if (length(args) > 0) 
[17:40:54.741]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.741]             }
[17:40:54.741]             else {
[17:40:54.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.741]             }
[17:40:54.741]             {
[17:40:54.741]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.741]                   0L) {
[17:40:54.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.741]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.741]                   base::options(opts)
[17:40:54.741]                 }
[17:40:54.741]                 {
[17:40:54.741]                   {
[17:40:54.741]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.741]                     NULL
[17:40:54.741]                   }
[17:40:54.741]                   options(future.plan = NULL)
[17:40:54.741]                   if (is.na(NA_character_)) 
[17:40:54.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.741]                     .init = FALSE)
[17:40:54.741]                 }
[17:40:54.741]             }
[17:40:54.741]         }
[17:40:54.741]     })
[17:40:54.741]     if (TRUE) {
[17:40:54.741]         base::sink(type = "output", split = FALSE)
[17:40:54.741]         if (TRUE) {
[17:40:54.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.741]         }
[17:40:54.741]         else {
[17:40:54.741]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.741]         }
[17:40:54.741]         base::close(...future.stdout)
[17:40:54.741]         ...future.stdout <- NULL
[17:40:54.741]     }
[17:40:54.741]     ...future.result$conditions <- ...future.conditions
[17:40:54.741]     ...future.result$finished <- base::Sys.time()
[17:40:54.741]     ...future.result
[17:40:54.741] }
[17:40:54.743] Poll #1 (0): usedNodes() = 2, workers = 2
[17:40:54.753] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.753] - Validating connection of MultisessionFuture
[17:40:54.754] - received message: FutureResult
[17:40:54.754] - Received FutureResult
[17:40:54.754] - Erased future from FutureRegistry
[17:40:54.754] result() for ClusterFuture ...
[17:40:54.754] - result already collected: FutureResult
[17:40:54.754] result() for ClusterFuture ... done
[17:40:54.754] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.754] result() for ClusterFuture ...
[17:40:54.754] - result already collected: FutureResult
[17:40:54.754] result() for ClusterFuture ... done
[17:40:54.755] result() for ClusterFuture ...
[17:40:54.755] - result already collected: FutureResult
[17:40:54.755] result() for ClusterFuture ... done
[17:40:54.756] MultisessionFuture started
[17:40:54.756] - Launch lazy future ... done
[17:40:54.756] run() for ‘MultisessionFuture’ ... done
[17:40:54.756] getGlobalsAndPackages() ...
[17:40:54.756] Searching for globals...
[17:40:54.757] - globals found: [2] ‘list’, ‘stop’
[17:40:54.757] Searching for globals ... DONE
[17:40:54.757] Resolving globals: FALSE
[17:40:54.757] 
[17:40:54.757] 
[17:40:54.757] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[17:40:54.758] getGlobalsAndPackages() ...
[17:40:54.758] Searching for globals...
[17:40:54.759] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:54.759] Searching for globals ... DONE
[17:40:54.759] Resolving globals: FALSE
[17:40:54.759] 
[17:40:54.759] 
[17:40:54.760] getGlobalsAndPackages() ... DONE
[17:40:54.760] run() for ‘Future’ ...
[17:40:54.760] - state: ‘created’
[17:40:54.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:54.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:54.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:54.774]   - Field: ‘node’
[17:40:54.774]   - Field: ‘label’
[17:40:54.774]   - Field: ‘local’
[17:40:54.774]   - Field: ‘owner’
[17:40:54.774]   - Field: ‘envir’
[17:40:54.774]   - Field: ‘workers’
[17:40:54.774]   - Field: ‘packages’
[17:40:54.774]   - Field: ‘gc’
[17:40:54.774]   - Field: ‘conditions’
[17:40:54.774]   - Field: ‘persistent’
[17:40:54.774]   - Field: ‘expr’
[17:40:54.775]   - Field: ‘uuid’
[17:40:54.775]   - Field: ‘seed’
[17:40:54.775]   - Field: ‘version’
[17:40:54.775]   - Field: ‘result’
[17:40:54.775]   - Field: ‘asynchronous’
[17:40:54.775]   - Field: ‘calls’
[17:40:54.775]   - Field: ‘globals’
[17:40:54.775]   - Field: ‘stdout’
[17:40:54.775]   - Field: ‘earlySignal’
[17:40:54.775]   - Field: ‘lazy’
[17:40:54.775]   - Field: ‘state’
[17:40:54.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:54.776] - Launch lazy future ...
[17:40:54.776] Packages needed by the future expression (n = 0): <none>
[17:40:54.776] Packages needed by future strategies (n = 0): <none>
[17:40:54.776] {
[17:40:54.776]     {
[17:40:54.776]         {
[17:40:54.776]             ...future.startTime <- base::Sys.time()
[17:40:54.776]             {
[17:40:54.776]                 {
[17:40:54.776]                   {
[17:40:54.776]                     {
[17:40:54.776]                       base::local({
[17:40:54.776]                         has_future <- base::requireNamespace("future", 
[17:40:54.776]                           quietly = TRUE)
[17:40:54.776]                         if (has_future) {
[17:40:54.776]                           ns <- base::getNamespace("future")
[17:40:54.776]                           version <- ns[[".package"]][["version"]]
[17:40:54.776]                           if (is.null(version)) 
[17:40:54.776]                             version <- utils::packageVersion("future")
[17:40:54.776]                         }
[17:40:54.776]                         else {
[17:40:54.776]                           version <- NULL
[17:40:54.776]                         }
[17:40:54.776]                         if (!has_future || version < "1.8.0") {
[17:40:54.776]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:54.776]                             "", base::R.version$version.string), 
[17:40:54.776]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:54.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:54.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:54.776]                               "release", "version")], collapse = " "), 
[17:40:54.776]                             hostname = base::Sys.info()[["nodename"]])
[17:40:54.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:54.776]                             info)
[17:40:54.776]                           info <- base::paste(info, collapse = "; ")
[17:40:54.776]                           if (!has_future) {
[17:40:54.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:54.776]                               info)
[17:40:54.776]                           }
[17:40:54.776]                           else {
[17:40:54.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:54.776]                               info, version)
[17:40:54.776]                           }
[17:40:54.776]                           base::stop(msg)
[17:40:54.776]                         }
[17:40:54.776]                       })
[17:40:54.776]                     }
[17:40:54.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:54.776]                     base::options(mc.cores = 1L)
[17:40:54.776]                   }
[17:40:54.776]                   ...future.strategy.old <- future::plan("list")
[17:40:54.776]                   options(future.plan = NULL)
[17:40:54.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:54.776]                 }
[17:40:54.776]                 ...future.workdir <- getwd()
[17:40:54.776]             }
[17:40:54.776]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:54.776]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:54.776]         }
[17:40:54.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:54.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:54.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:54.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:54.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:54.776]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:54.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:54.776]             base::names(...future.oldOptions))
[17:40:54.776]     }
[17:40:54.776]     if (FALSE) {
[17:40:54.776]     }
[17:40:54.776]     else {
[17:40:54.776]         if (TRUE) {
[17:40:54.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:54.776]                 open = "w")
[17:40:54.776]         }
[17:40:54.776]         else {
[17:40:54.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:54.776]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:54.776]         }
[17:40:54.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:54.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:54.776]             base::sink(type = "output", split = FALSE)
[17:40:54.776]             base::close(...future.stdout)
[17:40:54.776]         }, add = TRUE)
[17:40:54.776]     }
[17:40:54.776]     ...future.frame <- base::sys.nframe()
[17:40:54.776]     ...future.conditions <- base::list()
[17:40:54.776]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:54.776]     if (FALSE) {
[17:40:54.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:54.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:54.776]     }
[17:40:54.776]     ...future.result <- base::tryCatch({
[17:40:54.776]         base::withCallingHandlers({
[17:40:54.776]             ...future.value <- base::withVisible(base::local({
[17:40:54.776]                 ...future.makeSendCondition <- base::local({
[17:40:54.776]                   sendCondition <- NULL
[17:40:54.776]                   function(frame = 1L) {
[17:40:54.776]                     if (is.function(sendCondition)) 
[17:40:54.776]                       return(sendCondition)
[17:40:54.776]                     ns <- getNamespace("parallel")
[17:40:54.776]                     if (exists("sendData", mode = "function", 
[17:40:54.776]                       envir = ns)) {
[17:40:54.776]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:54.776]                         envir = ns)
[17:40:54.776]                       envir <- sys.frame(frame)
[17:40:54.776]                       master <- NULL
[17:40:54.776]                       while (!identical(envir, .GlobalEnv) && 
[17:40:54.776]                         !identical(envir, emptyenv())) {
[17:40:54.776]                         if (exists("master", mode = "list", envir = envir, 
[17:40:54.776]                           inherits = FALSE)) {
[17:40:54.776]                           master <- get("master", mode = "list", 
[17:40:54.776]                             envir = envir, inherits = FALSE)
[17:40:54.776]                           if (inherits(master, c("SOCKnode", 
[17:40:54.776]                             "SOCK0node"))) {
[17:40:54.776]                             sendCondition <<- function(cond) {
[17:40:54.776]                               data <- list(type = "VALUE", value = cond, 
[17:40:54.776]                                 success = TRUE)
[17:40:54.776]                               parallel_sendData(master, data)
[17:40:54.776]                             }
[17:40:54.776]                             return(sendCondition)
[17:40:54.776]                           }
[17:40:54.776]                         }
[17:40:54.776]                         frame <- frame + 1L
[17:40:54.776]                         envir <- sys.frame(frame)
[17:40:54.776]                       }
[17:40:54.776]                     }
[17:40:54.776]                     sendCondition <<- function(cond) NULL
[17:40:54.776]                   }
[17:40:54.776]                 })
[17:40:54.776]                 withCallingHandlers({
[17:40:54.776]                   {
[17:40:54.776]                     Sys.sleep(0.5)
[17:40:54.776]                     list(a = 1, b = 42L)
[17:40:54.776]                   }
[17:40:54.776]                 }, immediateCondition = function(cond) {
[17:40:54.776]                   sendCondition <- ...future.makeSendCondition()
[17:40:54.776]                   sendCondition(cond)
[17:40:54.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                   {
[17:40:54.776]                     inherits <- base::inherits
[17:40:54.776]                     invokeRestart <- base::invokeRestart
[17:40:54.776]                     is.null <- base::is.null
[17:40:54.776]                     muffled <- FALSE
[17:40:54.776]                     if (inherits(cond, "message")) {
[17:40:54.776]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                       if (muffled) 
[17:40:54.776]                         invokeRestart("muffleMessage")
[17:40:54.776]                     }
[17:40:54.776]                     else if (inherits(cond, "warning")) {
[17:40:54.776]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                       if (muffled) 
[17:40:54.776]                         invokeRestart("muffleWarning")
[17:40:54.776]                     }
[17:40:54.776]                     else if (inherits(cond, "condition")) {
[17:40:54.776]                       if (!is.null(pattern)) {
[17:40:54.776]                         computeRestarts <- base::computeRestarts
[17:40:54.776]                         grepl <- base::grepl
[17:40:54.776]                         restarts <- computeRestarts(cond)
[17:40:54.776]                         for (restart in restarts) {
[17:40:54.776]                           name <- restart$name
[17:40:54.776]                           if (is.null(name)) 
[17:40:54.776]                             next
[17:40:54.776]                           if (!grepl(pattern, name)) 
[17:40:54.776]                             next
[17:40:54.776]                           invokeRestart(restart)
[17:40:54.776]                           muffled <- TRUE
[17:40:54.776]                           break
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                     }
[17:40:54.776]                     invisible(muffled)
[17:40:54.776]                   }
[17:40:54.776]                   muffleCondition(cond)
[17:40:54.776]                 })
[17:40:54.776]             }))
[17:40:54.776]             future::FutureResult(value = ...future.value$value, 
[17:40:54.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.776]                   ...future.rng), globalenv = if (FALSE) 
[17:40:54.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:54.776]                     ...future.globalenv.names))
[17:40:54.776]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:54.776]         }, condition = base::local({
[17:40:54.776]             c <- base::c
[17:40:54.776]             inherits <- base::inherits
[17:40:54.776]             invokeRestart <- base::invokeRestart
[17:40:54.776]             length <- base::length
[17:40:54.776]             list <- base::list
[17:40:54.776]             seq.int <- base::seq.int
[17:40:54.776]             signalCondition <- base::signalCondition
[17:40:54.776]             sys.calls <- base::sys.calls
[17:40:54.776]             `[[` <- base::`[[`
[17:40:54.776]             `+` <- base::`+`
[17:40:54.776]             `<<-` <- base::`<<-`
[17:40:54.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:54.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:54.776]                   3L)]
[17:40:54.776]             }
[17:40:54.776]             function(cond) {
[17:40:54.776]                 is_error <- inherits(cond, "error")
[17:40:54.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:54.776]                   NULL)
[17:40:54.776]                 if (is_error) {
[17:40:54.776]                   sessionInformation <- function() {
[17:40:54.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:54.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:54.776]                       search = base::search(), system = base::Sys.info())
[17:40:54.776]                   }
[17:40:54.776]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:54.776]                     cond$call), session = sessionInformation(), 
[17:40:54.776]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:54.776]                   signalCondition(cond)
[17:40:54.776]                 }
[17:40:54.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:54.776]                 "immediateCondition"))) {
[17:40:54.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:54.776]                   ...future.conditions[[length(...future.conditions) + 
[17:40:54.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:54.776]                   if (TRUE && !signal) {
[17:40:54.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                     {
[17:40:54.776]                       inherits <- base::inherits
[17:40:54.776]                       invokeRestart <- base::invokeRestart
[17:40:54.776]                       is.null <- base::is.null
[17:40:54.776]                       muffled <- FALSE
[17:40:54.776]                       if (inherits(cond, "message")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleMessage")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "warning")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleWarning")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "condition")) {
[17:40:54.776]                         if (!is.null(pattern)) {
[17:40:54.776]                           computeRestarts <- base::computeRestarts
[17:40:54.776]                           grepl <- base::grepl
[17:40:54.776]                           restarts <- computeRestarts(cond)
[17:40:54.776]                           for (restart in restarts) {
[17:40:54.776]                             name <- restart$name
[17:40:54.776]                             if (is.null(name)) 
[17:40:54.776]                               next
[17:40:54.776]                             if (!grepl(pattern, name)) 
[17:40:54.776]                               next
[17:40:54.776]                             invokeRestart(restart)
[17:40:54.776]                             muffled <- TRUE
[17:40:54.776]                             break
[17:40:54.776]                           }
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                       invisible(muffled)
[17:40:54.776]                     }
[17:40:54.776]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.776]                   }
[17:40:54.776]                 }
[17:40:54.776]                 else {
[17:40:54.776]                   if (TRUE) {
[17:40:54.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:54.776]                     {
[17:40:54.776]                       inherits <- base::inherits
[17:40:54.776]                       invokeRestart <- base::invokeRestart
[17:40:54.776]                       is.null <- base::is.null
[17:40:54.776]                       muffled <- FALSE
[17:40:54.776]                       if (inherits(cond, "message")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleMessage")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "warning")) {
[17:40:54.776]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:54.776]                         if (muffled) 
[17:40:54.776]                           invokeRestart("muffleWarning")
[17:40:54.776]                       }
[17:40:54.776]                       else if (inherits(cond, "condition")) {
[17:40:54.776]                         if (!is.null(pattern)) {
[17:40:54.776]                           computeRestarts <- base::computeRestarts
[17:40:54.776]                           grepl <- base::grepl
[17:40:54.776]                           restarts <- computeRestarts(cond)
[17:40:54.776]                           for (restart in restarts) {
[17:40:54.776]                             name <- restart$name
[17:40:54.776]                             if (is.null(name)) 
[17:40:54.776]                               next
[17:40:54.776]                             if (!grepl(pattern, name)) 
[17:40:54.776]                               next
[17:40:54.776]                             invokeRestart(restart)
[17:40:54.776]                             muffled <- TRUE
[17:40:54.776]                             break
[17:40:54.776]                           }
[17:40:54.776]                         }
[17:40:54.776]                       }
[17:40:54.776]                       invisible(muffled)
[17:40:54.776]                     }
[17:40:54.776]                     muffleCondition(cond, pattern = "^muffle")
[17:40:54.776]                   }
[17:40:54.776]                 }
[17:40:54.776]             }
[17:40:54.776]         }))
[17:40:54.776]     }, error = function(ex) {
[17:40:54.776]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:54.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:54.776]                 ...future.rng), started = ...future.startTime, 
[17:40:54.776]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:54.776]             version = "1.8"), class = "FutureResult")
[17:40:54.776]     }, finally = {
[17:40:54.776]         if (!identical(...future.workdir, getwd())) 
[17:40:54.776]             setwd(...future.workdir)
[17:40:54.776]         {
[17:40:54.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:54.776]                 ...future.oldOptions$nwarnings <- NULL
[17:40:54.776]             }
[17:40:54.776]             base::options(...future.oldOptions)
[17:40:54.776]             if (.Platform$OS.type == "windows") {
[17:40:54.776]                 old_names <- names(...future.oldEnvVars)
[17:40:54.776]                 envs <- base::Sys.getenv()
[17:40:54.776]                 names <- names(envs)
[17:40:54.776]                 common <- intersect(names, old_names)
[17:40:54.776]                 added <- setdiff(names, old_names)
[17:40:54.776]                 removed <- setdiff(old_names, names)
[17:40:54.776]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:54.776]                   envs[common]]
[17:40:54.776]                 NAMES <- toupper(changed)
[17:40:54.776]                 args <- list()
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- changed[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.776]                 }
[17:40:54.776]                 NAMES <- toupper(added)
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- added[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ""
[17:40:54.776]                 }
[17:40:54.776]                 NAMES <- toupper(removed)
[17:40:54.776]                 for (kk in seq_along(NAMES)) {
[17:40:54.776]                   name <- removed[[kk]]
[17:40:54.776]                   NAME <- NAMES[[kk]]
[17:40:54.776]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:54.776]                     next
[17:40:54.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:54.776]                 }
[17:40:54.776]                 if (length(args) > 0) 
[17:40:54.776]                   base::do.call(base::Sys.setenv, args = args)
[17:40:54.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:54.776]             }
[17:40:54.776]             else {
[17:40:54.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:54.776]             }
[17:40:54.776]             {
[17:40:54.776]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:54.776]                   0L) {
[17:40:54.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:54.776]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:54.776]                   base::options(opts)
[17:40:54.776]                 }
[17:40:54.776]                 {
[17:40:54.776]                   {
[17:40:54.776]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:54.776]                     NULL
[17:40:54.776]                   }
[17:40:54.776]                   options(future.plan = NULL)
[17:40:54.776]                   if (is.na(NA_character_)) 
[17:40:54.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:54.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:54.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:54.776]                     .init = FALSE)
[17:40:54.776]                 }
[17:40:54.776]             }
[17:40:54.776]         }
[17:40:54.776]     })
[17:40:54.776]     if (TRUE) {
[17:40:54.776]         base::sink(type = "output", split = FALSE)
[17:40:54.776]         if (TRUE) {
[17:40:54.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:54.776]         }
[17:40:54.776]         else {
[17:40:54.776]             ...future.result["stdout"] <- base::list(NULL)
[17:40:54.776]         }
[17:40:54.776]         base::close(...future.stdout)
[17:40:54.776]         ...future.stdout <- NULL
[17:40:54.776]     }
[17:40:54.776]     ...future.result$conditions <- ...future.conditions
[17:40:54.776]     ...future.result$finished <- base::Sys.time()
[17:40:54.776]     ...future.result
[17:40:54.776] }
[17:40:54.778] Poll #1 (0): usedNodes() = 2, workers = 2
[17:40:54.800] receiveMessageFromWorker() for ClusterFuture ...
[17:40:54.800] - Validating connection of MultisessionFuture
[17:40:54.800] - received message: FutureResult
[17:40:54.800] - Received FutureResult
[17:40:54.801] - Erased future from FutureRegistry
[17:40:54.801] result() for ClusterFuture ...
[17:40:54.801] - result already collected: FutureResult
[17:40:54.801] result() for ClusterFuture ... done
[17:40:54.801] signalConditions() ...
[17:40:54.801]  - include = ‘immediateCondition’
[17:40:54.801]  - exclude = 
[17:40:54.801]  - resignal = FALSE
[17:40:54.801]  - Number of conditions: 1
[17:40:54.801] signalConditions() ... done
[17:40:54.801] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:54.801] result() for ClusterFuture ...
[17:40:54.802] - result already collected: FutureResult
[17:40:54.802] result() for ClusterFuture ... done
[17:40:54.802] result() for ClusterFuture ...
[17:40:54.802] - result already collected: FutureResult
[17:40:54.802] result() for ClusterFuture ... done
[17:40:54.802] signalConditions() ...
[17:40:54.802]  - include = ‘immediateCondition’
[17:40:54.802]  - exclude = 
[17:40:54.802]  - resignal = FALSE
[17:40:54.802]  - Number of conditions: 1
[17:40:54.802] signalConditions() ... done
[17:40:54.803] MultisessionFuture started
[17:40:54.803] - Launch lazy future ... done
[17:40:54.803] run() for ‘MultisessionFuture’ ... done
[17:40:55.306] receiveMessageFromWorker() for ClusterFuture ...
[17:40:55.306] - Validating connection of MultisessionFuture
[17:40:55.306] - received message: FutureResult
[17:40:55.306] - Received FutureResult
[17:40:55.306] - Erased future from FutureRegistry
[17:40:55.306] result() for ClusterFuture ...
[17:40:55.307] - result already collected: FutureResult
[17:40:55.307] result() for ClusterFuture ... done
[17:40:55.307] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:55.307] A MultisessionFuture was resolved
[17:40:55.307] getGlobalsAndPackages() ...
[17:40:55.307] Searching for globals...
[17:40:55.308] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:55.308] Searching for globals ... DONE
[17:40:55.308] Resolving globals: FALSE
[17:40:55.309] 
[17:40:55.309] 
[17:40:55.309] getGlobalsAndPackages() ... DONE
[17:40:55.309] run() for ‘Future’ ...
[17:40:55.309] - state: ‘created’
[17:40:55.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:55.324]   - Field: ‘node’
[17:40:55.324]   - Field: ‘label’
[17:40:55.324]   - Field: ‘local’
[17:40:55.325]   - Field: ‘owner’
[17:40:55.325]   - Field: ‘envir’
[17:40:55.325]   - Field: ‘workers’
[17:40:55.325]   - Field: ‘packages’
[17:40:55.325]   - Field: ‘gc’
[17:40:55.325]   - Field: ‘conditions’
[17:40:55.325]   - Field: ‘persistent’
[17:40:55.325]   - Field: ‘expr’
[17:40:55.325]   - Field: ‘uuid’
[17:40:55.325]   - Field: ‘seed’
[17:40:55.325]   - Field: ‘version’
[17:40:55.326]   - Field: ‘result’
[17:40:55.326]   - Field: ‘asynchronous’
[17:40:55.326]   - Field: ‘calls’
[17:40:55.326]   - Field: ‘globals’
[17:40:55.326]   - Field: ‘stdout’
[17:40:55.326]   - Field: ‘earlySignal’
[17:40:55.326]   - Field: ‘lazy’
[17:40:55.326]   - Field: ‘state’
[17:40:55.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:55.326] - Launch lazy future ...
[17:40:55.327] Packages needed by the future expression (n = 0): <none>
[17:40:55.327] Packages needed by future strategies (n = 0): <none>
[17:40:55.327] {
[17:40:55.327]     {
[17:40:55.327]         {
[17:40:55.327]             ...future.startTime <- base::Sys.time()
[17:40:55.327]             {
[17:40:55.327]                 {
[17:40:55.327]                   {
[17:40:55.327]                     {
[17:40:55.327]                       base::local({
[17:40:55.327]                         has_future <- base::requireNamespace("future", 
[17:40:55.327]                           quietly = TRUE)
[17:40:55.327]                         if (has_future) {
[17:40:55.327]                           ns <- base::getNamespace("future")
[17:40:55.327]                           version <- ns[[".package"]][["version"]]
[17:40:55.327]                           if (is.null(version)) 
[17:40:55.327]                             version <- utils::packageVersion("future")
[17:40:55.327]                         }
[17:40:55.327]                         else {
[17:40:55.327]                           version <- NULL
[17:40:55.327]                         }
[17:40:55.327]                         if (!has_future || version < "1.8.0") {
[17:40:55.327]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.327]                             "", base::R.version$version.string), 
[17:40:55.327]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:55.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:55.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.327]                               "release", "version")], collapse = " "), 
[17:40:55.327]                             hostname = base::Sys.info()[["nodename"]])
[17:40:55.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.327]                             info)
[17:40:55.327]                           info <- base::paste(info, collapse = "; ")
[17:40:55.327]                           if (!has_future) {
[17:40:55.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.327]                               info)
[17:40:55.327]                           }
[17:40:55.327]                           else {
[17:40:55.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.327]                               info, version)
[17:40:55.327]                           }
[17:40:55.327]                           base::stop(msg)
[17:40:55.327]                         }
[17:40:55.327]                       })
[17:40:55.327]                     }
[17:40:55.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.327]                     base::options(mc.cores = 1L)
[17:40:55.327]                   }
[17:40:55.327]                   ...future.strategy.old <- future::plan("list")
[17:40:55.327]                   options(future.plan = NULL)
[17:40:55.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.327]                 }
[17:40:55.327]                 ...future.workdir <- getwd()
[17:40:55.327]             }
[17:40:55.327]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.327]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.327]         }
[17:40:55.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:55.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.327]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.327]             base::names(...future.oldOptions))
[17:40:55.327]     }
[17:40:55.327]     if (FALSE) {
[17:40:55.327]     }
[17:40:55.327]     else {
[17:40:55.327]         if (TRUE) {
[17:40:55.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.327]                 open = "w")
[17:40:55.327]         }
[17:40:55.327]         else {
[17:40:55.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.327]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.327]         }
[17:40:55.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.327]             base::sink(type = "output", split = FALSE)
[17:40:55.327]             base::close(...future.stdout)
[17:40:55.327]         }, add = TRUE)
[17:40:55.327]     }
[17:40:55.327]     ...future.frame <- base::sys.nframe()
[17:40:55.327]     ...future.conditions <- base::list()
[17:40:55.327]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.327]     if (FALSE) {
[17:40:55.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.327]     }
[17:40:55.327]     ...future.result <- base::tryCatch({
[17:40:55.327]         base::withCallingHandlers({
[17:40:55.327]             ...future.value <- base::withVisible(base::local({
[17:40:55.327]                 ...future.makeSendCondition <- base::local({
[17:40:55.327]                   sendCondition <- NULL
[17:40:55.327]                   function(frame = 1L) {
[17:40:55.327]                     if (is.function(sendCondition)) 
[17:40:55.327]                       return(sendCondition)
[17:40:55.327]                     ns <- getNamespace("parallel")
[17:40:55.327]                     if (exists("sendData", mode = "function", 
[17:40:55.327]                       envir = ns)) {
[17:40:55.327]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:55.327]                         envir = ns)
[17:40:55.327]                       envir <- sys.frame(frame)
[17:40:55.327]                       master <- NULL
[17:40:55.327]                       while (!identical(envir, .GlobalEnv) && 
[17:40:55.327]                         !identical(envir, emptyenv())) {
[17:40:55.327]                         if (exists("master", mode = "list", envir = envir, 
[17:40:55.327]                           inherits = FALSE)) {
[17:40:55.327]                           master <- get("master", mode = "list", 
[17:40:55.327]                             envir = envir, inherits = FALSE)
[17:40:55.327]                           if (inherits(master, c("SOCKnode", 
[17:40:55.327]                             "SOCK0node"))) {
[17:40:55.327]                             sendCondition <<- function(cond) {
[17:40:55.327]                               data <- list(type = "VALUE", value = cond, 
[17:40:55.327]                                 success = TRUE)
[17:40:55.327]                               parallel_sendData(master, data)
[17:40:55.327]                             }
[17:40:55.327]                             return(sendCondition)
[17:40:55.327]                           }
[17:40:55.327]                         }
[17:40:55.327]                         frame <- frame + 1L
[17:40:55.327]                         envir <- sys.frame(frame)
[17:40:55.327]                       }
[17:40:55.327]                     }
[17:40:55.327]                     sendCondition <<- function(cond) NULL
[17:40:55.327]                   }
[17:40:55.327]                 })
[17:40:55.327]                 withCallingHandlers({
[17:40:55.327]                   {
[17:40:55.327]                     Sys.sleep(0.5)
[17:40:55.327]                     list(a = 1, b = 42L)
[17:40:55.327]                   }
[17:40:55.327]                 }, immediateCondition = function(cond) {
[17:40:55.327]                   sendCondition <- ...future.makeSendCondition()
[17:40:55.327]                   sendCondition(cond)
[17:40:55.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.327]                   {
[17:40:55.327]                     inherits <- base::inherits
[17:40:55.327]                     invokeRestart <- base::invokeRestart
[17:40:55.327]                     is.null <- base::is.null
[17:40:55.327]                     muffled <- FALSE
[17:40:55.327]                     if (inherits(cond, "message")) {
[17:40:55.327]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.327]                       if (muffled) 
[17:40:55.327]                         invokeRestart("muffleMessage")
[17:40:55.327]                     }
[17:40:55.327]                     else if (inherits(cond, "warning")) {
[17:40:55.327]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.327]                       if (muffled) 
[17:40:55.327]                         invokeRestart("muffleWarning")
[17:40:55.327]                     }
[17:40:55.327]                     else if (inherits(cond, "condition")) {
[17:40:55.327]                       if (!is.null(pattern)) {
[17:40:55.327]                         computeRestarts <- base::computeRestarts
[17:40:55.327]                         grepl <- base::grepl
[17:40:55.327]                         restarts <- computeRestarts(cond)
[17:40:55.327]                         for (restart in restarts) {
[17:40:55.327]                           name <- restart$name
[17:40:55.327]                           if (is.null(name)) 
[17:40:55.327]                             next
[17:40:55.327]                           if (!grepl(pattern, name)) 
[17:40:55.327]                             next
[17:40:55.327]                           invokeRestart(restart)
[17:40:55.327]                           muffled <- TRUE
[17:40:55.327]                           break
[17:40:55.327]                         }
[17:40:55.327]                       }
[17:40:55.327]                     }
[17:40:55.327]                     invisible(muffled)
[17:40:55.327]                   }
[17:40:55.327]                   muffleCondition(cond)
[17:40:55.327]                 })
[17:40:55.327]             }))
[17:40:55.327]             future::FutureResult(value = ...future.value$value, 
[17:40:55.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.327]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.327]                     ...future.globalenv.names))
[17:40:55.327]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.327]         }, condition = base::local({
[17:40:55.327]             c <- base::c
[17:40:55.327]             inherits <- base::inherits
[17:40:55.327]             invokeRestart <- base::invokeRestart
[17:40:55.327]             length <- base::length
[17:40:55.327]             list <- base::list
[17:40:55.327]             seq.int <- base::seq.int
[17:40:55.327]             signalCondition <- base::signalCondition
[17:40:55.327]             sys.calls <- base::sys.calls
[17:40:55.327]             `[[` <- base::`[[`
[17:40:55.327]             `+` <- base::`+`
[17:40:55.327]             `<<-` <- base::`<<-`
[17:40:55.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.327]                   3L)]
[17:40:55.327]             }
[17:40:55.327]             function(cond) {
[17:40:55.327]                 is_error <- inherits(cond, "error")
[17:40:55.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.327]                   NULL)
[17:40:55.327]                 if (is_error) {
[17:40:55.327]                   sessionInformation <- function() {
[17:40:55.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.327]                       search = base::search(), system = base::Sys.info())
[17:40:55.327]                   }
[17:40:55.327]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.327]                     cond$call), session = sessionInformation(), 
[17:40:55.327]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.327]                   signalCondition(cond)
[17:40:55.327]                 }
[17:40:55.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.327]                 "immediateCondition"))) {
[17:40:55.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.327]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.327]                   if (TRUE && !signal) {
[17:40:55.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.327]                     {
[17:40:55.327]                       inherits <- base::inherits
[17:40:55.327]                       invokeRestart <- base::invokeRestart
[17:40:55.327]                       is.null <- base::is.null
[17:40:55.327]                       muffled <- FALSE
[17:40:55.327]                       if (inherits(cond, "message")) {
[17:40:55.327]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.327]                         if (muffled) 
[17:40:55.327]                           invokeRestart("muffleMessage")
[17:40:55.327]                       }
[17:40:55.327]                       else if (inherits(cond, "warning")) {
[17:40:55.327]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.327]                         if (muffled) 
[17:40:55.327]                           invokeRestart("muffleWarning")
[17:40:55.327]                       }
[17:40:55.327]                       else if (inherits(cond, "condition")) {
[17:40:55.327]                         if (!is.null(pattern)) {
[17:40:55.327]                           computeRestarts <- base::computeRestarts
[17:40:55.327]                           grepl <- base::grepl
[17:40:55.327]                           restarts <- computeRestarts(cond)
[17:40:55.327]                           for (restart in restarts) {
[17:40:55.327]                             name <- restart$name
[17:40:55.327]                             if (is.null(name)) 
[17:40:55.327]                               next
[17:40:55.327]                             if (!grepl(pattern, name)) 
[17:40:55.327]                               next
[17:40:55.327]                             invokeRestart(restart)
[17:40:55.327]                             muffled <- TRUE
[17:40:55.327]                             break
[17:40:55.327]                           }
[17:40:55.327]                         }
[17:40:55.327]                       }
[17:40:55.327]                       invisible(muffled)
[17:40:55.327]                     }
[17:40:55.327]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.327]                   }
[17:40:55.327]                 }
[17:40:55.327]                 else {
[17:40:55.327]                   if (TRUE) {
[17:40:55.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.327]                     {
[17:40:55.327]                       inherits <- base::inherits
[17:40:55.327]                       invokeRestart <- base::invokeRestart
[17:40:55.327]                       is.null <- base::is.null
[17:40:55.327]                       muffled <- FALSE
[17:40:55.327]                       if (inherits(cond, "message")) {
[17:40:55.327]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.327]                         if (muffled) 
[17:40:55.327]                           invokeRestart("muffleMessage")
[17:40:55.327]                       }
[17:40:55.327]                       else if (inherits(cond, "warning")) {
[17:40:55.327]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.327]                         if (muffled) 
[17:40:55.327]                           invokeRestart("muffleWarning")
[17:40:55.327]                       }
[17:40:55.327]                       else if (inherits(cond, "condition")) {
[17:40:55.327]                         if (!is.null(pattern)) {
[17:40:55.327]                           computeRestarts <- base::computeRestarts
[17:40:55.327]                           grepl <- base::grepl
[17:40:55.327]                           restarts <- computeRestarts(cond)
[17:40:55.327]                           for (restart in restarts) {
[17:40:55.327]                             name <- restart$name
[17:40:55.327]                             if (is.null(name)) 
[17:40:55.327]                               next
[17:40:55.327]                             if (!grepl(pattern, name)) 
[17:40:55.327]                               next
[17:40:55.327]                             invokeRestart(restart)
[17:40:55.327]                             muffled <- TRUE
[17:40:55.327]                             break
[17:40:55.327]                           }
[17:40:55.327]                         }
[17:40:55.327]                       }
[17:40:55.327]                       invisible(muffled)
[17:40:55.327]                     }
[17:40:55.327]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.327]                   }
[17:40:55.327]                 }
[17:40:55.327]             }
[17:40:55.327]         }))
[17:40:55.327]     }, error = function(ex) {
[17:40:55.327]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.327]                 ...future.rng), started = ...future.startTime, 
[17:40:55.327]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.327]             version = "1.8"), class = "FutureResult")
[17:40:55.327]     }, finally = {
[17:40:55.327]         if (!identical(...future.workdir, getwd())) 
[17:40:55.327]             setwd(...future.workdir)
[17:40:55.327]         {
[17:40:55.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.327]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.327]             }
[17:40:55.327]             base::options(...future.oldOptions)
[17:40:55.327]             if (.Platform$OS.type == "windows") {
[17:40:55.327]                 old_names <- names(...future.oldEnvVars)
[17:40:55.327]                 envs <- base::Sys.getenv()
[17:40:55.327]                 names <- names(envs)
[17:40:55.327]                 common <- intersect(names, old_names)
[17:40:55.327]                 added <- setdiff(names, old_names)
[17:40:55.327]                 removed <- setdiff(old_names, names)
[17:40:55.327]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.327]                   envs[common]]
[17:40:55.327]                 NAMES <- toupper(changed)
[17:40:55.327]                 args <- list()
[17:40:55.327]                 for (kk in seq_along(NAMES)) {
[17:40:55.327]                   name <- changed[[kk]]
[17:40:55.327]                   NAME <- NAMES[[kk]]
[17:40:55.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.327]                     next
[17:40:55.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.327]                 }
[17:40:55.327]                 NAMES <- toupper(added)
[17:40:55.327]                 for (kk in seq_along(NAMES)) {
[17:40:55.327]                   name <- added[[kk]]
[17:40:55.327]                   NAME <- NAMES[[kk]]
[17:40:55.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.327]                     next
[17:40:55.327]                   args[[name]] <- ""
[17:40:55.327]                 }
[17:40:55.327]                 NAMES <- toupper(removed)
[17:40:55.327]                 for (kk in seq_along(NAMES)) {
[17:40:55.327]                   name <- removed[[kk]]
[17:40:55.327]                   NAME <- NAMES[[kk]]
[17:40:55.327]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.327]                     next
[17:40:55.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.327]                 }
[17:40:55.327]                 if (length(args) > 0) 
[17:40:55.327]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.327]             }
[17:40:55.327]             else {
[17:40:55.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.327]             }
[17:40:55.327]             {
[17:40:55.327]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.327]                   0L) {
[17:40:55.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.327]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.327]                   base::options(opts)
[17:40:55.327]                 }
[17:40:55.327]                 {
[17:40:55.327]                   {
[17:40:55.327]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.327]                     NULL
[17:40:55.327]                   }
[17:40:55.327]                   options(future.plan = NULL)
[17:40:55.327]                   if (is.na(NA_character_)) 
[17:40:55.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:55.327]                     .init = FALSE)
[17:40:55.327]                 }
[17:40:55.327]             }
[17:40:55.327]         }
[17:40:55.327]     })
[17:40:55.327]     if (TRUE) {
[17:40:55.327]         base::sink(type = "output", split = FALSE)
[17:40:55.327]         if (TRUE) {
[17:40:55.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.327]         }
[17:40:55.327]         else {
[17:40:55.327]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.327]         }
[17:40:55.327]         base::close(...future.stdout)
[17:40:55.327]         ...future.stdout <- NULL
[17:40:55.327]     }
[17:40:55.327]     ...future.result$conditions <- ...future.conditions
[17:40:55.327]     ...future.result$finished <- base::Sys.time()
[17:40:55.327]     ...future.result
[17:40:55.327] }
[17:40:55.330] MultisessionFuture started
[17:40:55.330] - Launch lazy future ... done
[17:40:55.330] run() for ‘MultisessionFuture’ ... done
[17:40:55.833] receiveMessageFromWorker() for ClusterFuture ...
[17:40:55.833] - Validating connection of MultisessionFuture
[17:40:55.833] - received message: FutureResult
[17:40:55.833] - Received FutureResult
[17:40:55.834] - Erased future from FutureRegistry
[17:40:55.834] result() for ClusterFuture ...
[17:40:55.834] - result already collected: FutureResult
[17:40:55.834] result() for ClusterFuture ... done
[17:40:55.834] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:55.834] A MultisessionFuture was resolved
- w/ exception ...
[17:40:55.834] getGlobalsAndPackages() ...
[17:40:55.834] Searching for globals...
[17:40:55.835] - globals found: [2] ‘list’, ‘stop’
[17:40:55.835] Searching for globals ... DONE
[17:40:55.835] Resolving globals: FALSE
[17:40:55.835] 
[17:40:55.836] 
[17:40:55.836] getGlobalsAndPackages() ... DONE
[17:40:55.836] run() for ‘Future’ ...
[17:40:55.836] - state: ‘created’
[17:40:55.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:55.850]   - Field: ‘node’
[17:40:55.851]   - Field: ‘label’
[17:40:55.851]   - Field: ‘local’
[17:40:55.851]   - Field: ‘owner’
[17:40:55.851]   - Field: ‘envir’
[17:40:55.851]   - Field: ‘workers’
[17:40:55.851]   - Field: ‘packages’
[17:40:55.851]   - Field: ‘gc’
[17:40:55.851]   - Field: ‘conditions’
[17:40:55.851]   - Field: ‘persistent’
[17:40:55.851]   - Field: ‘expr’
[17:40:55.851]   - Field: ‘uuid’
[17:40:55.852]   - Field: ‘seed’
[17:40:55.852]   - Field: ‘version’
[17:40:55.852]   - Field: ‘result’
[17:40:55.852]   - Field: ‘asynchronous’
[17:40:55.852]   - Field: ‘calls’
[17:40:55.852]   - Field: ‘globals’
[17:40:55.852]   - Field: ‘stdout’
[17:40:55.852]   - Field: ‘earlySignal’
[17:40:55.852]   - Field: ‘lazy’
[17:40:55.852]   - Field: ‘state’
[17:40:55.853] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:55.853] - Launch lazy future ...
[17:40:55.853] Packages needed by the future expression (n = 0): <none>
[17:40:55.853] Packages needed by future strategies (n = 0): <none>
[17:40:55.853] {
[17:40:55.853]     {
[17:40:55.853]         {
[17:40:55.853]             ...future.startTime <- base::Sys.time()
[17:40:55.853]             {
[17:40:55.853]                 {
[17:40:55.853]                   {
[17:40:55.853]                     {
[17:40:55.853]                       base::local({
[17:40:55.853]                         has_future <- base::requireNamespace("future", 
[17:40:55.853]                           quietly = TRUE)
[17:40:55.853]                         if (has_future) {
[17:40:55.853]                           ns <- base::getNamespace("future")
[17:40:55.853]                           version <- ns[[".package"]][["version"]]
[17:40:55.853]                           if (is.null(version)) 
[17:40:55.853]                             version <- utils::packageVersion("future")
[17:40:55.853]                         }
[17:40:55.853]                         else {
[17:40:55.853]                           version <- NULL
[17:40:55.853]                         }
[17:40:55.853]                         if (!has_future || version < "1.8.0") {
[17:40:55.853]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.853]                             "", base::R.version$version.string), 
[17:40:55.853]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:55.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:55.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.853]                               "release", "version")], collapse = " "), 
[17:40:55.853]                             hostname = base::Sys.info()[["nodename"]])
[17:40:55.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.853]                             info)
[17:40:55.853]                           info <- base::paste(info, collapse = "; ")
[17:40:55.853]                           if (!has_future) {
[17:40:55.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.853]                               info)
[17:40:55.853]                           }
[17:40:55.853]                           else {
[17:40:55.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.853]                               info, version)
[17:40:55.853]                           }
[17:40:55.853]                           base::stop(msg)
[17:40:55.853]                         }
[17:40:55.853]                       })
[17:40:55.853]                     }
[17:40:55.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.853]                     base::options(mc.cores = 1L)
[17:40:55.853]                   }
[17:40:55.853]                   ...future.strategy.old <- future::plan("list")
[17:40:55.853]                   options(future.plan = NULL)
[17:40:55.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.853]                 }
[17:40:55.853]                 ...future.workdir <- getwd()
[17:40:55.853]             }
[17:40:55.853]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.853]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.853]         }
[17:40:55.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:55.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.853]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.853]             base::names(...future.oldOptions))
[17:40:55.853]     }
[17:40:55.853]     if (FALSE) {
[17:40:55.853]     }
[17:40:55.853]     else {
[17:40:55.853]         if (TRUE) {
[17:40:55.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.853]                 open = "w")
[17:40:55.853]         }
[17:40:55.853]         else {
[17:40:55.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.853]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.853]         }
[17:40:55.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.853]             base::sink(type = "output", split = FALSE)
[17:40:55.853]             base::close(...future.stdout)
[17:40:55.853]         }, add = TRUE)
[17:40:55.853]     }
[17:40:55.853]     ...future.frame <- base::sys.nframe()
[17:40:55.853]     ...future.conditions <- base::list()
[17:40:55.853]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.853]     if (FALSE) {
[17:40:55.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.853]     }
[17:40:55.853]     ...future.result <- base::tryCatch({
[17:40:55.853]         base::withCallingHandlers({
[17:40:55.853]             ...future.value <- base::withVisible(base::local({
[17:40:55.853]                 ...future.makeSendCondition <- base::local({
[17:40:55.853]                   sendCondition <- NULL
[17:40:55.853]                   function(frame = 1L) {
[17:40:55.853]                     if (is.function(sendCondition)) 
[17:40:55.853]                       return(sendCondition)
[17:40:55.853]                     ns <- getNamespace("parallel")
[17:40:55.853]                     if (exists("sendData", mode = "function", 
[17:40:55.853]                       envir = ns)) {
[17:40:55.853]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:55.853]                         envir = ns)
[17:40:55.853]                       envir <- sys.frame(frame)
[17:40:55.853]                       master <- NULL
[17:40:55.853]                       while (!identical(envir, .GlobalEnv) && 
[17:40:55.853]                         !identical(envir, emptyenv())) {
[17:40:55.853]                         if (exists("master", mode = "list", envir = envir, 
[17:40:55.853]                           inherits = FALSE)) {
[17:40:55.853]                           master <- get("master", mode = "list", 
[17:40:55.853]                             envir = envir, inherits = FALSE)
[17:40:55.853]                           if (inherits(master, c("SOCKnode", 
[17:40:55.853]                             "SOCK0node"))) {
[17:40:55.853]                             sendCondition <<- function(cond) {
[17:40:55.853]                               data <- list(type = "VALUE", value = cond, 
[17:40:55.853]                                 success = TRUE)
[17:40:55.853]                               parallel_sendData(master, data)
[17:40:55.853]                             }
[17:40:55.853]                             return(sendCondition)
[17:40:55.853]                           }
[17:40:55.853]                         }
[17:40:55.853]                         frame <- frame + 1L
[17:40:55.853]                         envir <- sys.frame(frame)
[17:40:55.853]                       }
[17:40:55.853]                     }
[17:40:55.853]                     sendCondition <<- function(cond) NULL
[17:40:55.853]                   }
[17:40:55.853]                 })
[17:40:55.853]                 withCallingHandlers({
[17:40:55.853]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:55.853]                 }, immediateCondition = function(cond) {
[17:40:55.853]                   sendCondition <- ...future.makeSendCondition()
[17:40:55.853]                   sendCondition(cond)
[17:40:55.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.853]                   {
[17:40:55.853]                     inherits <- base::inherits
[17:40:55.853]                     invokeRestart <- base::invokeRestart
[17:40:55.853]                     is.null <- base::is.null
[17:40:55.853]                     muffled <- FALSE
[17:40:55.853]                     if (inherits(cond, "message")) {
[17:40:55.853]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.853]                       if (muffled) 
[17:40:55.853]                         invokeRestart("muffleMessage")
[17:40:55.853]                     }
[17:40:55.853]                     else if (inherits(cond, "warning")) {
[17:40:55.853]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.853]                       if (muffled) 
[17:40:55.853]                         invokeRestart("muffleWarning")
[17:40:55.853]                     }
[17:40:55.853]                     else if (inherits(cond, "condition")) {
[17:40:55.853]                       if (!is.null(pattern)) {
[17:40:55.853]                         computeRestarts <- base::computeRestarts
[17:40:55.853]                         grepl <- base::grepl
[17:40:55.853]                         restarts <- computeRestarts(cond)
[17:40:55.853]                         for (restart in restarts) {
[17:40:55.853]                           name <- restart$name
[17:40:55.853]                           if (is.null(name)) 
[17:40:55.853]                             next
[17:40:55.853]                           if (!grepl(pattern, name)) 
[17:40:55.853]                             next
[17:40:55.853]                           invokeRestart(restart)
[17:40:55.853]                           muffled <- TRUE
[17:40:55.853]                           break
[17:40:55.853]                         }
[17:40:55.853]                       }
[17:40:55.853]                     }
[17:40:55.853]                     invisible(muffled)
[17:40:55.853]                   }
[17:40:55.853]                   muffleCondition(cond)
[17:40:55.853]                 })
[17:40:55.853]             }))
[17:40:55.853]             future::FutureResult(value = ...future.value$value, 
[17:40:55.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.853]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.853]                     ...future.globalenv.names))
[17:40:55.853]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.853]         }, condition = base::local({
[17:40:55.853]             c <- base::c
[17:40:55.853]             inherits <- base::inherits
[17:40:55.853]             invokeRestart <- base::invokeRestart
[17:40:55.853]             length <- base::length
[17:40:55.853]             list <- base::list
[17:40:55.853]             seq.int <- base::seq.int
[17:40:55.853]             signalCondition <- base::signalCondition
[17:40:55.853]             sys.calls <- base::sys.calls
[17:40:55.853]             `[[` <- base::`[[`
[17:40:55.853]             `+` <- base::`+`
[17:40:55.853]             `<<-` <- base::`<<-`
[17:40:55.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.853]                   3L)]
[17:40:55.853]             }
[17:40:55.853]             function(cond) {
[17:40:55.853]                 is_error <- inherits(cond, "error")
[17:40:55.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.853]                   NULL)
[17:40:55.853]                 if (is_error) {
[17:40:55.853]                   sessionInformation <- function() {
[17:40:55.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.853]                       search = base::search(), system = base::Sys.info())
[17:40:55.853]                   }
[17:40:55.853]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.853]                     cond$call), session = sessionInformation(), 
[17:40:55.853]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.853]                   signalCondition(cond)
[17:40:55.853]                 }
[17:40:55.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.853]                 "immediateCondition"))) {
[17:40:55.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.853]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.853]                   if (TRUE && !signal) {
[17:40:55.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.853]                     {
[17:40:55.853]                       inherits <- base::inherits
[17:40:55.853]                       invokeRestart <- base::invokeRestart
[17:40:55.853]                       is.null <- base::is.null
[17:40:55.853]                       muffled <- FALSE
[17:40:55.853]                       if (inherits(cond, "message")) {
[17:40:55.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.853]                         if (muffled) 
[17:40:55.853]                           invokeRestart("muffleMessage")
[17:40:55.853]                       }
[17:40:55.853]                       else if (inherits(cond, "warning")) {
[17:40:55.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.853]                         if (muffled) 
[17:40:55.853]                           invokeRestart("muffleWarning")
[17:40:55.853]                       }
[17:40:55.853]                       else if (inherits(cond, "condition")) {
[17:40:55.853]                         if (!is.null(pattern)) {
[17:40:55.853]                           computeRestarts <- base::computeRestarts
[17:40:55.853]                           grepl <- base::grepl
[17:40:55.853]                           restarts <- computeRestarts(cond)
[17:40:55.853]                           for (restart in restarts) {
[17:40:55.853]                             name <- restart$name
[17:40:55.853]                             if (is.null(name)) 
[17:40:55.853]                               next
[17:40:55.853]                             if (!grepl(pattern, name)) 
[17:40:55.853]                               next
[17:40:55.853]                             invokeRestart(restart)
[17:40:55.853]                             muffled <- TRUE
[17:40:55.853]                             break
[17:40:55.853]                           }
[17:40:55.853]                         }
[17:40:55.853]                       }
[17:40:55.853]                       invisible(muffled)
[17:40:55.853]                     }
[17:40:55.853]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.853]                   }
[17:40:55.853]                 }
[17:40:55.853]                 else {
[17:40:55.853]                   if (TRUE) {
[17:40:55.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.853]                     {
[17:40:55.853]                       inherits <- base::inherits
[17:40:55.853]                       invokeRestart <- base::invokeRestart
[17:40:55.853]                       is.null <- base::is.null
[17:40:55.853]                       muffled <- FALSE
[17:40:55.853]                       if (inherits(cond, "message")) {
[17:40:55.853]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.853]                         if (muffled) 
[17:40:55.853]                           invokeRestart("muffleMessage")
[17:40:55.853]                       }
[17:40:55.853]                       else if (inherits(cond, "warning")) {
[17:40:55.853]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.853]                         if (muffled) 
[17:40:55.853]                           invokeRestart("muffleWarning")
[17:40:55.853]                       }
[17:40:55.853]                       else if (inherits(cond, "condition")) {
[17:40:55.853]                         if (!is.null(pattern)) {
[17:40:55.853]                           computeRestarts <- base::computeRestarts
[17:40:55.853]                           grepl <- base::grepl
[17:40:55.853]                           restarts <- computeRestarts(cond)
[17:40:55.853]                           for (restart in restarts) {
[17:40:55.853]                             name <- restart$name
[17:40:55.853]                             if (is.null(name)) 
[17:40:55.853]                               next
[17:40:55.853]                             if (!grepl(pattern, name)) 
[17:40:55.853]                               next
[17:40:55.853]                             invokeRestart(restart)
[17:40:55.853]                             muffled <- TRUE
[17:40:55.853]                             break
[17:40:55.853]                           }
[17:40:55.853]                         }
[17:40:55.853]                       }
[17:40:55.853]                       invisible(muffled)
[17:40:55.853]                     }
[17:40:55.853]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.853]                   }
[17:40:55.853]                 }
[17:40:55.853]             }
[17:40:55.853]         }))
[17:40:55.853]     }, error = function(ex) {
[17:40:55.853]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.853]                 ...future.rng), started = ...future.startTime, 
[17:40:55.853]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.853]             version = "1.8"), class = "FutureResult")
[17:40:55.853]     }, finally = {
[17:40:55.853]         if (!identical(...future.workdir, getwd())) 
[17:40:55.853]             setwd(...future.workdir)
[17:40:55.853]         {
[17:40:55.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.853]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.853]             }
[17:40:55.853]             base::options(...future.oldOptions)
[17:40:55.853]             if (.Platform$OS.type == "windows") {
[17:40:55.853]                 old_names <- names(...future.oldEnvVars)
[17:40:55.853]                 envs <- base::Sys.getenv()
[17:40:55.853]                 names <- names(envs)
[17:40:55.853]                 common <- intersect(names, old_names)
[17:40:55.853]                 added <- setdiff(names, old_names)
[17:40:55.853]                 removed <- setdiff(old_names, names)
[17:40:55.853]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.853]                   envs[common]]
[17:40:55.853]                 NAMES <- toupper(changed)
[17:40:55.853]                 args <- list()
[17:40:55.853]                 for (kk in seq_along(NAMES)) {
[17:40:55.853]                   name <- changed[[kk]]
[17:40:55.853]                   NAME <- NAMES[[kk]]
[17:40:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.853]                     next
[17:40:55.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.853]                 }
[17:40:55.853]                 NAMES <- toupper(added)
[17:40:55.853]                 for (kk in seq_along(NAMES)) {
[17:40:55.853]                   name <- added[[kk]]
[17:40:55.853]                   NAME <- NAMES[[kk]]
[17:40:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.853]                     next
[17:40:55.853]                   args[[name]] <- ""
[17:40:55.853]                 }
[17:40:55.853]                 NAMES <- toupper(removed)
[17:40:55.853]                 for (kk in seq_along(NAMES)) {
[17:40:55.853]                   name <- removed[[kk]]
[17:40:55.853]                   NAME <- NAMES[[kk]]
[17:40:55.853]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.853]                     next
[17:40:55.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.853]                 }
[17:40:55.853]                 if (length(args) > 0) 
[17:40:55.853]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.853]             }
[17:40:55.853]             else {
[17:40:55.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.853]             }
[17:40:55.853]             {
[17:40:55.853]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.853]                   0L) {
[17:40:55.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.853]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.853]                   base::options(opts)
[17:40:55.853]                 }
[17:40:55.853]                 {
[17:40:55.853]                   {
[17:40:55.853]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.853]                     NULL
[17:40:55.853]                   }
[17:40:55.853]                   options(future.plan = NULL)
[17:40:55.853]                   if (is.na(NA_character_)) 
[17:40:55.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:55.853]                     .init = FALSE)
[17:40:55.853]                 }
[17:40:55.853]             }
[17:40:55.853]         }
[17:40:55.853]     })
[17:40:55.853]     if (TRUE) {
[17:40:55.853]         base::sink(type = "output", split = FALSE)
[17:40:55.853]         if (TRUE) {
[17:40:55.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.853]         }
[17:40:55.853]         else {
[17:40:55.853]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.853]         }
[17:40:55.853]         base::close(...future.stdout)
[17:40:55.853]         ...future.stdout <- NULL
[17:40:55.853]     }
[17:40:55.853]     ...future.result$conditions <- ...future.conditions
[17:40:55.853]     ...future.result$finished <- base::Sys.time()
[17:40:55.853]     ...future.result
[17:40:55.853] }
[17:40:55.857] MultisessionFuture started
[17:40:55.857] - Launch lazy future ... done
[17:40:55.857] run() for ‘MultisessionFuture’ ... done
[17:40:55.859] receiveMessageFromWorker() for ClusterFuture ...
[17:40:55.859] - Validating connection of MultisessionFuture
[17:40:55.859] - received message: FutureResult
[17:40:55.860] - Received FutureResult
[17:40:55.860] - Erased future from FutureRegistry
[17:40:55.860] result() for ClusterFuture ...
[17:40:55.860] - result already collected: FutureResult
[17:40:55.860] result() for ClusterFuture ... done
[17:40:55.860] signalConditions() ...
[17:40:55.860]  - include = ‘immediateCondition’
[17:40:55.860]  - exclude = 
[17:40:55.861]  - resignal = FALSE
[17:40:55.861]  - Number of conditions: 1
[17:40:55.861] signalConditions() ... done
[17:40:55.861] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:55.861] A MultisessionFuture was resolved
[17:40:55.861] getGlobalsAndPackages() ...
[17:40:55.861] Searching for globals...
[17:40:55.862] - globals found: [2] ‘list’, ‘stop’
[17:40:55.862] Searching for globals ... DONE
[17:40:55.862] Resolving globals: FALSE
[17:40:55.863] 
[17:40:55.863] 
[17:40:55.863] getGlobalsAndPackages() ... DONE
[17:40:55.864] run() for ‘Future’ ...
[17:40:55.864] - state: ‘created’
[17:40:55.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.879] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:55.879]   - Field: ‘node’
[17:40:55.879]   - Field: ‘label’
[17:40:55.879]   - Field: ‘local’
[17:40:55.880]   - Field: ‘owner’
[17:40:55.880]   - Field: ‘envir’
[17:40:55.880]   - Field: ‘workers’
[17:40:55.880]   - Field: ‘packages’
[17:40:55.880]   - Field: ‘gc’
[17:40:55.880]   - Field: ‘conditions’
[17:40:55.880]   - Field: ‘persistent’
[17:40:55.880]   - Field: ‘expr’
[17:40:55.880]   - Field: ‘uuid’
[17:40:55.880]   - Field: ‘seed’
[17:40:55.881]   - Field: ‘version’
[17:40:55.881]   - Field: ‘result’
[17:40:55.881]   - Field: ‘asynchronous’
[17:40:55.881]   - Field: ‘calls’
[17:40:55.881]   - Field: ‘globals’
[17:40:55.881]   - Field: ‘stdout’
[17:40:55.881]   - Field: ‘earlySignal’
[17:40:55.881]   - Field: ‘lazy’
[17:40:55.881]   - Field: ‘state’
[17:40:55.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:55.881] - Launch lazy future ...
[17:40:55.882] Packages needed by the future expression (n = 0): <none>
[17:40:55.882] Packages needed by future strategies (n = 0): <none>
[17:40:55.882] {
[17:40:55.882]     {
[17:40:55.882]         {
[17:40:55.882]             ...future.startTime <- base::Sys.time()
[17:40:55.882]             {
[17:40:55.882]                 {
[17:40:55.882]                   {
[17:40:55.882]                     {
[17:40:55.882]                       base::local({
[17:40:55.882]                         has_future <- base::requireNamespace("future", 
[17:40:55.882]                           quietly = TRUE)
[17:40:55.882]                         if (has_future) {
[17:40:55.882]                           ns <- base::getNamespace("future")
[17:40:55.882]                           version <- ns[[".package"]][["version"]]
[17:40:55.882]                           if (is.null(version)) 
[17:40:55.882]                             version <- utils::packageVersion("future")
[17:40:55.882]                         }
[17:40:55.882]                         else {
[17:40:55.882]                           version <- NULL
[17:40:55.882]                         }
[17:40:55.882]                         if (!has_future || version < "1.8.0") {
[17:40:55.882]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.882]                             "", base::R.version$version.string), 
[17:40:55.882]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:55.882]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:55.882]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.882]                               "release", "version")], collapse = " "), 
[17:40:55.882]                             hostname = base::Sys.info()[["nodename"]])
[17:40:55.882]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.882]                             info)
[17:40:55.882]                           info <- base::paste(info, collapse = "; ")
[17:40:55.882]                           if (!has_future) {
[17:40:55.882]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.882]                               info)
[17:40:55.882]                           }
[17:40:55.882]                           else {
[17:40:55.882]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.882]                               info, version)
[17:40:55.882]                           }
[17:40:55.882]                           base::stop(msg)
[17:40:55.882]                         }
[17:40:55.882]                       })
[17:40:55.882]                     }
[17:40:55.882]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.882]                     base::options(mc.cores = 1L)
[17:40:55.882]                   }
[17:40:55.882]                   ...future.strategy.old <- future::plan("list")
[17:40:55.882]                   options(future.plan = NULL)
[17:40:55.882]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.882]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.882]                 }
[17:40:55.882]                 ...future.workdir <- getwd()
[17:40:55.882]             }
[17:40:55.882]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.882]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.882]         }
[17:40:55.882]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.882]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:55.882]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.882]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.882]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.882]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.882]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.882]             base::names(...future.oldOptions))
[17:40:55.882]     }
[17:40:55.882]     if (FALSE) {
[17:40:55.882]     }
[17:40:55.882]     else {
[17:40:55.882]         if (TRUE) {
[17:40:55.882]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.882]                 open = "w")
[17:40:55.882]         }
[17:40:55.882]         else {
[17:40:55.882]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.882]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.882]         }
[17:40:55.882]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.882]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.882]             base::sink(type = "output", split = FALSE)
[17:40:55.882]             base::close(...future.stdout)
[17:40:55.882]         }, add = TRUE)
[17:40:55.882]     }
[17:40:55.882]     ...future.frame <- base::sys.nframe()
[17:40:55.882]     ...future.conditions <- base::list()
[17:40:55.882]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.882]     if (FALSE) {
[17:40:55.882]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.882]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.882]     }
[17:40:55.882]     ...future.result <- base::tryCatch({
[17:40:55.882]         base::withCallingHandlers({
[17:40:55.882]             ...future.value <- base::withVisible(base::local({
[17:40:55.882]                 ...future.makeSendCondition <- base::local({
[17:40:55.882]                   sendCondition <- NULL
[17:40:55.882]                   function(frame = 1L) {
[17:40:55.882]                     if (is.function(sendCondition)) 
[17:40:55.882]                       return(sendCondition)
[17:40:55.882]                     ns <- getNamespace("parallel")
[17:40:55.882]                     if (exists("sendData", mode = "function", 
[17:40:55.882]                       envir = ns)) {
[17:40:55.882]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:55.882]                         envir = ns)
[17:40:55.882]                       envir <- sys.frame(frame)
[17:40:55.882]                       master <- NULL
[17:40:55.882]                       while (!identical(envir, .GlobalEnv) && 
[17:40:55.882]                         !identical(envir, emptyenv())) {
[17:40:55.882]                         if (exists("master", mode = "list", envir = envir, 
[17:40:55.882]                           inherits = FALSE)) {
[17:40:55.882]                           master <- get("master", mode = "list", 
[17:40:55.882]                             envir = envir, inherits = FALSE)
[17:40:55.882]                           if (inherits(master, c("SOCKnode", 
[17:40:55.882]                             "SOCK0node"))) {
[17:40:55.882]                             sendCondition <<- function(cond) {
[17:40:55.882]                               data <- list(type = "VALUE", value = cond, 
[17:40:55.882]                                 success = TRUE)
[17:40:55.882]                               parallel_sendData(master, data)
[17:40:55.882]                             }
[17:40:55.882]                             return(sendCondition)
[17:40:55.882]                           }
[17:40:55.882]                         }
[17:40:55.882]                         frame <- frame + 1L
[17:40:55.882]                         envir <- sys.frame(frame)
[17:40:55.882]                       }
[17:40:55.882]                     }
[17:40:55.882]                     sendCondition <<- function(cond) NULL
[17:40:55.882]                   }
[17:40:55.882]                 })
[17:40:55.882]                 withCallingHandlers({
[17:40:55.882]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:55.882]                 }, immediateCondition = function(cond) {
[17:40:55.882]                   sendCondition <- ...future.makeSendCondition()
[17:40:55.882]                   sendCondition(cond)
[17:40:55.882]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.882]                   {
[17:40:55.882]                     inherits <- base::inherits
[17:40:55.882]                     invokeRestart <- base::invokeRestart
[17:40:55.882]                     is.null <- base::is.null
[17:40:55.882]                     muffled <- FALSE
[17:40:55.882]                     if (inherits(cond, "message")) {
[17:40:55.882]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.882]                       if (muffled) 
[17:40:55.882]                         invokeRestart("muffleMessage")
[17:40:55.882]                     }
[17:40:55.882]                     else if (inherits(cond, "warning")) {
[17:40:55.882]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.882]                       if (muffled) 
[17:40:55.882]                         invokeRestart("muffleWarning")
[17:40:55.882]                     }
[17:40:55.882]                     else if (inherits(cond, "condition")) {
[17:40:55.882]                       if (!is.null(pattern)) {
[17:40:55.882]                         computeRestarts <- base::computeRestarts
[17:40:55.882]                         grepl <- base::grepl
[17:40:55.882]                         restarts <- computeRestarts(cond)
[17:40:55.882]                         for (restart in restarts) {
[17:40:55.882]                           name <- restart$name
[17:40:55.882]                           if (is.null(name)) 
[17:40:55.882]                             next
[17:40:55.882]                           if (!grepl(pattern, name)) 
[17:40:55.882]                             next
[17:40:55.882]                           invokeRestart(restart)
[17:40:55.882]                           muffled <- TRUE
[17:40:55.882]                           break
[17:40:55.882]                         }
[17:40:55.882]                       }
[17:40:55.882]                     }
[17:40:55.882]                     invisible(muffled)
[17:40:55.882]                   }
[17:40:55.882]                   muffleCondition(cond)
[17:40:55.882]                 })
[17:40:55.882]             }))
[17:40:55.882]             future::FutureResult(value = ...future.value$value, 
[17:40:55.882]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.882]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.882]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.882]                     ...future.globalenv.names))
[17:40:55.882]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.882]         }, condition = base::local({
[17:40:55.882]             c <- base::c
[17:40:55.882]             inherits <- base::inherits
[17:40:55.882]             invokeRestart <- base::invokeRestart
[17:40:55.882]             length <- base::length
[17:40:55.882]             list <- base::list
[17:40:55.882]             seq.int <- base::seq.int
[17:40:55.882]             signalCondition <- base::signalCondition
[17:40:55.882]             sys.calls <- base::sys.calls
[17:40:55.882]             `[[` <- base::`[[`
[17:40:55.882]             `+` <- base::`+`
[17:40:55.882]             `<<-` <- base::`<<-`
[17:40:55.882]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.882]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.882]                   3L)]
[17:40:55.882]             }
[17:40:55.882]             function(cond) {
[17:40:55.882]                 is_error <- inherits(cond, "error")
[17:40:55.882]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.882]                   NULL)
[17:40:55.882]                 if (is_error) {
[17:40:55.882]                   sessionInformation <- function() {
[17:40:55.882]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.882]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.882]                       search = base::search(), system = base::Sys.info())
[17:40:55.882]                   }
[17:40:55.882]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.882]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.882]                     cond$call), session = sessionInformation(), 
[17:40:55.882]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.882]                   signalCondition(cond)
[17:40:55.882]                 }
[17:40:55.882]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.882]                 "immediateCondition"))) {
[17:40:55.882]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.882]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.882]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.882]                   if (TRUE && !signal) {
[17:40:55.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.882]                     {
[17:40:55.882]                       inherits <- base::inherits
[17:40:55.882]                       invokeRestart <- base::invokeRestart
[17:40:55.882]                       is.null <- base::is.null
[17:40:55.882]                       muffled <- FALSE
[17:40:55.882]                       if (inherits(cond, "message")) {
[17:40:55.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.882]                         if (muffled) 
[17:40:55.882]                           invokeRestart("muffleMessage")
[17:40:55.882]                       }
[17:40:55.882]                       else if (inherits(cond, "warning")) {
[17:40:55.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.882]                         if (muffled) 
[17:40:55.882]                           invokeRestart("muffleWarning")
[17:40:55.882]                       }
[17:40:55.882]                       else if (inherits(cond, "condition")) {
[17:40:55.882]                         if (!is.null(pattern)) {
[17:40:55.882]                           computeRestarts <- base::computeRestarts
[17:40:55.882]                           grepl <- base::grepl
[17:40:55.882]                           restarts <- computeRestarts(cond)
[17:40:55.882]                           for (restart in restarts) {
[17:40:55.882]                             name <- restart$name
[17:40:55.882]                             if (is.null(name)) 
[17:40:55.882]                               next
[17:40:55.882]                             if (!grepl(pattern, name)) 
[17:40:55.882]                               next
[17:40:55.882]                             invokeRestart(restart)
[17:40:55.882]                             muffled <- TRUE
[17:40:55.882]                             break
[17:40:55.882]                           }
[17:40:55.882]                         }
[17:40:55.882]                       }
[17:40:55.882]                       invisible(muffled)
[17:40:55.882]                     }
[17:40:55.882]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.882]                   }
[17:40:55.882]                 }
[17:40:55.882]                 else {
[17:40:55.882]                   if (TRUE) {
[17:40:55.882]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.882]                     {
[17:40:55.882]                       inherits <- base::inherits
[17:40:55.882]                       invokeRestart <- base::invokeRestart
[17:40:55.882]                       is.null <- base::is.null
[17:40:55.882]                       muffled <- FALSE
[17:40:55.882]                       if (inherits(cond, "message")) {
[17:40:55.882]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.882]                         if (muffled) 
[17:40:55.882]                           invokeRestart("muffleMessage")
[17:40:55.882]                       }
[17:40:55.882]                       else if (inherits(cond, "warning")) {
[17:40:55.882]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.882]                         if (muffled) 
[17:40:55.882]                           invokeRestart("muffleWarning")
[17:40:55.882]                       }
[17:40:55.882]                       else if (inherits(cond, "condition")) {
[17:40:55.882]                         if (!is.null(pattern)) {
[17:40:55.882]                           computeRestarts <- base::computeRestarts
[17:40:55.882]                           grepl <- base::grepl
[17:40:55.882]                           restarts <- computeRestarts(cond)
[17:40:55.882]                           for (restart in restarts) {
[17:40:55.882]                             name <- restart$name
[17:40:55.882]                             if (is.null(name)) 
[17:40:55.882]                               next
[17:40:55.882]                             if (!grepl(pattern, name)) 
[17:40:55.882]                               next
[17:40:55.882]                             invokeRestart(restart)
[17:40:55.882]                             muffled <- TRUE
[17:40:55.882]                             break
[17:40:55.882]                           }
[17:40:55.882]                         }
[17:40:55.882]                       }
[17:40:55.882]                       invisible(muffled)
[17:40:55.882]                     }
[17:40:55.882]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.882]                   }
[17:40:55.882]                 }
[17:40:55.882]             }
[17:40:55.882]         }))
[17:40:55.882]     }, error = function(ex) {
[17:40:55.882]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.882]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.882]                 ...future.rng), started = ...future.startTime, 
[17:40:55.882]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.882]             version = "1.8"), class = "FutureResult")
[17:40:55.882]     }, finally = {
[17:40:55.882]         if (!identical(...future.workdir, getwd())) 
[17:40:55.882]             setwd(...future.workdir)
[17:40:55.882]         {
[17:40:55.882]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.882]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.882]             }
[17:40:55.882]             base::options(...future.oldOptions)
[17:40:55.882]             if (.Platform$OS.type == "windows") {
[17:40:55.882]                 old_names <- names(...future.oldEnvVars)
[17:40:55.882]                 envs <- base::Sys.getenv()
[17:40:55.882]                 names <- names(envs)
[17:40:55.882]                 common <- intersect(names, old_names)
[17:40:55.882]                 added <- setdiff(names, old_names)
[17:40:55.882]                 removed <- setdiff(old_names, names)
[17:40:55.882]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.882]                   envs[common]]
[17:40:55.882]                 NAMES <- toupper(changed)
[17:40:55.882]                 args <- list()
[17:40:55.882]                 for (kk in seq_along(NAMES)) {
[17:40:55.882]                   name <- changed[[kk]]
[17:40:55.882]                   NAME <- NAMES[[kk]]
[17:40:55.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.882]                     next
[17:40:55.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.882]                 }
[17:40:55.882]                 NAMES <- toupper(added)
[17:40:55.882]                 for (kk in seq_along(NAMES)) {
[17:40:55.882]                   name <- added[[kk]]
[17:40:55.882]                   NAME <- NAMES[[kk]]
[17:40:55.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.882]                     next
[17:40:55.882]                   args[[name]] <- ""
[17:40:55.882]                 }
[17:40:55.882]                 NAMES <- toupper(removed)
[17:40:55.882]                 for (kk in seq_along(NAMES)) {
[17:40:55.882]                   name <- removed[[kk]]
[17:40:55.882]                   NAME <- NAMES[[kk]]
[17:40:55.882]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.882]                     next
[17:40:55.882]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.882]                 }
[17:40:55.882]                 if (length(args) > 0) 
[17:40:55.882]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.882]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.882]             }
[17:40:55.882]             else {
[17:40:55.882]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.882]             }
[17:40:55.882]             {
[17:40:55.882]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.882]                   0L) {
[17:40:55.882]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.882]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.882]                   base::options(opts)
[17:40:55.882]                 }
[17:40:55.882]                 {
[17:40:55.882]                   {
[17:40:55.882]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.882]                     NULL
[17:40:55.882]                   }
[17:40:55.882]                   options(future.plan = NULL)
[17:40:55.882]                   if (is.na(NA_character_)) 
[17:40:55.882]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.882]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.882]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:55.882]                     .init = FALSE)
[17:40:55.882]                 }
[17:40:55.882]             }
[17:40:55.882]         }
[17:40:55.882]     })
[17:40:55.882]     if (TRUE) {
[17:40:55.882]         base::sink(type = "output", split = FALSE)
[17:40:55.882]         if (TRUE) {
[17:40:55.882]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.882]         }
[17:40:55.882]         else {
[17:40:55.882]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.882]         }
[17:40:55.882]         base::close(...future.stdout)
[17:40:55.882]         ...future.stdout <- NULL
[17:40:55.882]     }
[17:40:55.882]     ...future.result$conditions <- ...future.conditions
[17:40:55.882]     ...future.result$finished <- base::Sys.time()
[17:40:55.882]     ...future.result
[17:40:55.882] }
[17:40:55.885] MultisessionFuture started
[17:40:55.885] - Launch lazy future ... done
[17:40:55.885] run() for ‘MultisessionFuture’ ... done
[17:40:55.887] receiveMessageFromWorker() for ClusterFuture ...
[17:40:55.887] - Validating connection of MultisessionFuture
[17:40:55.888] - received message: FutureResult
[17:40:55.888] - Received FutureResult
[17:40:55.888] - Erased future from FutureRegistry
[17:40:55.888] result() for ClusterFuture ...
[17:40:55.888] - result already collected: FutureResult
[17:40:55.888] result() for ClusterFuture ... done
[17:40:55.888] signalConditions() ...
[17:40:55.888]  - include = ‘immediateCondition’
[17:40:55.888]  - exclude = 
[17:40:55.889]  - resignal = FALSE
[17:40:55.889]  - Number of conditions: 1
[17:40:55.889] signalConditions() ... done
[17:40:55.889] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:55.889] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[17:40:55.889] getGlobalsAndPackages() ...
[17:40:55.889] Searching for globals...
[17:40:55.890] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:55.890] Searching for globals ... DONE
[17:40:55.891] Resolving globals: FALSE
[17:40:55.891] 
[17:40:55.891] 
[17:40:55.891] getGlobalsAndPackages() ... DONE
[17:40:55.891] run() for ‘Future’ ...
[17:40:55.891] - state: ‘created’
[17:40:55.891] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:55.905] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:55.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:55.905]   - Field: ‘node’
[17:40:55.905]   - Field: ‘label’
[17:40:55.905]   - Field: ‘local’
[17:40:55.905]   - Field: ‘owner’
[17:40:55.905]   - Field: ‘envir’
[17:40:55.905]   - Field: ‘workers’
[17:40:55.905]   - Field: ‘packages’
[17:40:55.905]   - Field: ‘gc’
[17:40:55.906]   - Field: ‘conditions’
[17:40:55.906]   - Field: ‘persistent’
[17:40:55.906]   - Field: ‘expr’
[17:40:55.906]   - Field: ‘uuid’
[17:40:55.906]   - Field: ‘seed’
[17:40:55.906]   - Field: ‘version’
[17:40:55.906]   - Field: ‘result’
[17:40:55.906]   - Field: ‘asynchronous’
[17:40:55.906]   - Field: ‘calls’
[17:40:55.906]   - Field: ‘globals’
[17:40:55.906]   - Field: ‘stdout’
[17:40:55.907]   - Field: ‘earlySignal’
[17:40:55.907]   - Field: ‘lazy’
[17:40:55.907]   - Field: ‘state’
[17:40:55.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:55.907] - Launch lazy future ...
[17:40:55.907] Packages needed by the future expression (n = 0): <none>
[17:40:55.907] Packages needed by future strategies (n = 0): <none>
[17:40:55.908] {
[17:40:55.908]     {
[17:40:55.908]         {
[17:40:55.908]             ...future.startTime <- base::Sys.time()
[17:40:55.908]             {
[17:40:55.908]                 {
[17:40:55.908]                   {
[17:40:55.908]                     {
[17:40:55.908]                       base::local({
[17:40:55.908]                         has_future <- base::requireNamespace("future", 
[17:40:55.908]                           quietly = TRUE)
[17:40:55.908]                         if (has_future) {
[17:40:55.908]                           ns <- base::getNamespace("future")
[17:40:55.908]                           version <- ns[[".package"]][["version"]]
[17:40:55.908]                           if (is.null(version)) 
[17:40:55.908]                             version <- utils::packageVersion("future")
[17:40:55.908]                         }
[17:40:55.908]                         else {
[17:40:55.908]                           version <- NULL
[17:40:55.908]                         }
[17:40:55.908]                         if (!has_future || version < "1.8.0") {
[17:40:55.908]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:55.908]                             "", base::R.version$version.string), 
[17:40:55.908]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:55.908]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:55.908]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:55.908]                               "release", "version")], collapse = " "), 
[17:40:55.908]                             hostname = base::Sys.info()[["nodename"]])
[17:40:55.908]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:55.908]                             info)
[17:40:55.908]                           info <- base::paste(info, collapse = "; ")
[17:40:55.908]                           if (!has_future) {
[17:40:55.908]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:55.908]                               info)
[17:40:55.908]                           }
[17:40:55.908]                           else {
[17:40:55.908]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:55.908]                               info, version)
[17:40:55.908]                           }
[17:40:55.908]                           base::stop(msg)
[17:40:55.908]                         }
[17:40:55.908]                       })
[17:40:55.908]                     }
[17:40:55.908]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:55.908]                     base::options(mc.cores = 1L)
[17:40:55.908]                   }
[17:40:55.908]                   ...future.strategy.old <- future::plan("list")
[17:40:55.908]                   options(future.plan = NULL)
[17:40:55.908]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.908]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:55.908]                 }
[17:40:55.908]                 ...future.workdir <- getwd()
[17:40:55.908]             }
[17:40:55.908]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:55.908]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:55.908]         }
[17:40:55.908]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:55.908]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:55.908]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:55.908]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:55.908]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:55.908]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:55.908]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:55.908]             base::names(...future.oldOptions))
[17:40:55.908]     }
[17:40:55.908]     if (FALSE) {
[17:40:55.908]     }
[17:40:55.908]     else {
[17:40:55.908]         if (TRUE) {
[17:40:55.908]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:55.908]                 open = "w")
[17:40:55.908]         }
[17:40:55.908]         else {
[17:40:55.908]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:55.908]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:55.908]         }
[17:40:55.908]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:55.908]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:55.908]             base::sink(type = "output", split = FALSE)
[17:40:55.908]             base::close(...future.stdout)
[17:40:55.908]         }, add = TRUE)
[17:40:55.908]     }
[17:40:55.908]     ...future.frame <- base::sys.nframe()
[17:40:55.908]     ...future.conditions <- base::list()
[17:40:55.908]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:55.908]     if (FALSE) {
[17:40:55.908]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:55.908]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:55.908]     }
[17:40:55.908]     ...future.result <- base::tryCatch({
[17:40:55.908]         base::withCallingHandlers({
[17:40:55.908]             ...future.value <- base::withVisible(base::local({
[17:40:55.908]                 ...future.makeSendCondition <- base::local({
[17:40:55.908]                   sendCondition <- NULL
[17:40:55.908]                   function(frame = 1L) {
[17:40:55.908]                     if (is.function(sendCondition)) 
[17:40:55.908]                       return(sendCondition)
[17:40:55.908]                     ns <- getNamespace("parallel")
[17:40:55.908]                     if (exists("sendData", mode = "function", 
[17:40:55.908]                       envir = ns)) {
[17:40:55.908]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:55.908]                         envir = ns)
[17:40:55.908]                       envir <- sys.frame(frame)
[17:40:55.908]                       master <- NULL
[17:40:55.908]                       while (!identical(envir, .GlobalEnv) && 
[17:40:55.908]                         !identical(envir, emptyenv())) {
[17:40:55.908]                         if (exists("master", mode = "list", envir = envir, 
[17:40:55.908]                           inherits = FALSE)) {
[17:40:55.908]                           master <- get("master", mode = "list", 
[17:40:55.908]                             envir = envir, inherits = FALSE)
[17:40:55.908]                           if (inherits(master, c("SOCKnode", 
[17:40:55.908]                             "SOCK0node"))) {
[17:40:55.908]                             sendCondition <<- function(cond) {
[17:40:55.908]                               data <- list(type = "VALUE", value = cond, 
[17:40:55.908]                                 success = TRUE)
[17:40:55.908]                               parallel_sendData(master, data)
[17:40:55.908]                             }
[17:40:55.908]                             return(sendCondition)
[17:40:55.908]                           }
[17:40:55.908]                         }
[17:40:55.908]                         frame <- frame + 1L
[17:40:55.908]                         envir <- sys.frame(frame)
[17:40:55.908]                       }
[17:40:55.908]                     }
[17:40:55.908]                     sendCondition <<- function(cond) NULL
[17:40:55.908]                   }
[17:40:55.908]                 })
[17:40:55.908]                 withCallingHandlers({
[17:40:55.908]                   {
[17:40:55.908]                     Sys.sleep(0.5)
[17:40:55.908]                     list(a = 1, b = 42L)
[17:40:55.908]                   }
[17:40:55.908]                 }, immediateCondition = function(cond) {
[17:40:55.908]                   sendCondition <- ...future.makeSendCondition()
[17:40:55.908]                   sendCondition(cond)
[17:40:55.908]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.908]                   {
[17:40:55.908]                     inherits <- base::inherits
[17:40:55.908]                     invokeRestart <- base::invokeRestart
[17:40:55.908]                     is.null <- base::is.null
[17:40:55.908]                     muffled <- FALSE
[17:40:55.908]                     if (inherits(cond, "message")) {
[17:40:55.908]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:55.908]                       if (muffled) 
[17:40:55.908]                         invokeRestart("muffleMessage")
[17:40:55.908]                     }
[17:40:55.908]                     else if (inherits(cond, "warning")) {
[17:40:55.908]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:55.908]                       if (muffled) 
[17:40:55.908]                         invokeRestart("muffleWarning")
[17:40:55.908]                     }
[17:40:55.908]                     else if (inherits(cond, "condition")) {
[17:40:55.908]                       if (!is.null(pattern)) {
[17:40:55.908]                         computeRestarts <- base::computeRestarts
[17:40:55.908]                         grepl <- base::grepl
[17:40:55.908]                         restarts <- computeRestarts(cond)
[17:40:55.908]                         for (restart in restarts) {
[17:40:55.908]                           name <- restart$name
[17:40:55.908]                           if (is.null(name)) 
[17:40:55.908]                             next
[17:40:55.908]                           if (!grepl(pattern, name)) 
[17:40:55.908]                             next
[17:40:55.908]                           invokeRestart(restart)
[17:40:55.908]                           muffled <- TRUE
[17:40:55.908]                           break
[17:40:55.908]                         }
[17:40:55.908]                       }
[17:40:55.908]                     }
[17:40:55.908]                     invisible(muffled)
[17:40:55.908]                   }
[17:40:55.908]                   muffleCondition(cond)
[17:40:55.908]                 })
[17:40:55.908]             }))
[17:40:55.908]             future::FutureResult(value = ...future.value$value, 
[17:40:55.908]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.908]                   ...future.rng), globalenv = if (FALSE) 
[17:40:55.908]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:55.908]                     ...future.globalenv.names))
[17:40:55.908]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:55.908]         }, condition = base::local({
[17:40:55.908]             c <- base::c
[17:40:55.908]             inherits <- base::inherits
[17:40:55.908]             invokeRestart <- base::invokeRestart
[17:40:55.908]             length <- base::length
[17:40:55.908]             list <- base::list
[17:40:55.908]             seq.int <- base::seq.int
[17:40:55.908]             signalCondition <- base::signalCondition
[17:40:55.908]             sys.calls <- base::sys.calls
[17:40:55.908]             `[[` <- base::`[[`
[17:40:55.908]             `+` <- base::`+`
[17:40:55.908]             `<<-` <- base::`<<-`
[17:40:55.908]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:55.908]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:55.908]                   3L)]
[17:40:55.908]             }
[17:40:55.908]             function(cond) {
[17:40:55.908]                 is_error <- inherits(cond, "error")
[17:40:55.908]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:55.908]                   NULL)
[17:40:55.908]                 if (is_error) {
[17:40:55.908]                   sessionInformation <- function() {
[17:40:55.908]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:55.908]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:55.908]                       search = base::search(), system = base::Sys.info())
[17:40:55.908]                   }
[17:40:55.908]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.908]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:55.908]                     cond$call), session = sessionInformation(), 
[17:40:55.908]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:55.908]                   signalCondition(cond)
[17:40:55.908]                 }
[17:40:55.908]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:55.908]                 "immediateCondition"))) {
[17:40:55.908]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:55.908]                   ...future.conditions[[length(...future.conditions) + 
[17:40:55.908]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:55.908]                   if (TRUE && !signal) {
[17:40:55.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.908]                     {
[17:40:55.908]                       inherits <- base::inherits
[17:40:55.908]                       invokeRestart <- base::invokeRestart
[17:40:55.908]                       is.null <- base::is.null
[17:40:55.908]                       muffled <- FALSE
[17:40:55.908]                       if (inherits(cond, "message")) {
[17:40:55.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.908]                         if (muffled) 
[17:40:55.908]                           invokeRestart("muffleMessage")
[17:40:55.908]                       }
[17:40:55.908]                       else if (inherits(cond, "warning")) {
[17:40:55.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.908]                         if (muffled) 
[17:40:55.908]                           invokeRestart("muffleWarning")
[17:40:55.908]                       }
[17:40:55.908]                       else if (inherits(cond, "condition")) {
[17:40:55.908]                         if (!is.null(pattern)) {
[17:40:55.908]                           computeRestarts <- base::computeRestarts
[17:40:55.908]                           grepl <- base::grepl
[17:40:55.908]                           restarts <- computeRestarts(cond)
[17:40:55.908]                           for (restart in restarts) {
[17:40:55.908]                             name <- restart$name
[17:40:55.908]                             if (is.null(name)) 
[17:40:55.908]                               next
[17:40:55.908]                             if (!grepl(pattern, name)) 
[17:40:55.908]                               next
[17:40:55.908]                             invokeRestart(restart)
[17:40:55.908]                             muffled <- TRUE
[17:40:55.908]                             break
[17:40:55.908]                           }
[17:40:55.908]                         }
[17:40:55.908]                       }
[17:40:55.908]                       invisible(muffled)
[17:40:55.908]                     }
[17:40:55.908]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.908]                   }
[17:40:55.908]                 }
[17:40:55.908]                 else {
[17:40:55.908]                   if (TRUE) {
[17:40:55.908]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:55.908]                     {
[17:40:55.908]                       inherits <- base::inherits
[17:40:55.908]                       invokeRestart <- base::invokeRestart
[17:40:55.908]                       is.null <- base::is.null
[17:40:55.908]                       muffled <- FALSE
[17:40:55.908]                       if (inherits(cond, "message")) {
[17:40:55.908]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:55.908]                         if (muffled) 
[17:40:55.908]                           invokeRestart("muffleMessage")
[17:40:55.908]                       }
[17:40:55.908]                       else if (inherits(cond, "warning")) {
[17:40:55.908]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:55.908]                         if (muffled) 
[17:40:55.908]                           invokeRestart("muffleWarning")
[17:40:55.908]                       }
[17:40:55.908]                       else if (inherits(cond, "condition")) {
[17:40:55.908]                         if (!is.null(pattern)) {
[17:40:55.908]                           computeRestarts <- base::computeRestarts
[17:40:55.908]                           grepl <- base::grepl
[17:40:55.908]                           restarts <- computeRestarts(cond)
[17:40:55.908]                           for (restart in restarts) {
[17:40:55.908]                             name <- restart$name
[17:40:55.908]                             if (is.null(name)) 
[17:40:55.908]                               next
[17:40:55.908]                             if (!grepl(pattern, name)) 
[17:40:55.908]                               next
[17:40:55.908]                             invokeRestart(restart)
[17:40:55.908]                             muffled <- TRUE
[17:40:55.908]                             break
[17:40:55.908]                           }
[17:40:55.908]                         }
[17:40:55.908]                       }
[17:40:55.908]                       invisible(muffled)
[17:40:55.908]                     }
[17:40:55.908]                     muffleCondition(cond, pattern = "^muffle")
[17:40:55.908]                   }
[17:40:55.908]                 }
[17:40:55.908]             }
[17:40:55.908]         }))
[17:40:55.908]     }, error = function(ex) {
[17:40:55.908]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:55.908]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:55.908]                 ...future.rng), started = ...future.startTime, 
[17:40:55.908]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:55.908]             version = "1.8"), class = "FutureResult")
[17:40:55.908]     }, finally = {
[17:40:55.908]         if (!identical(...future.workdir, getwd())) 
[17:40:55.908]             setwd(...future.workdir)
[17:40:55.908]         {
[17:40:55.908]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:55.908]                 ...future.oldOptions$nwarnings <- NULL
[17:40:55.908]             }
[17:40:55.908]             base::options(...future.oldOptions)
[17:40:55.908]             if (.Platform$OS.type == "windows") {
[17:40:55.908]                 old_names <- names(...future.oldEnvVars)
[17:40:55.908]                 envs <- base::Sys.getenv()
[17:40:55.908]                 names <- names(envs)
[17:40:55.908]                 common <- intersect(names, old_names)
[17:40:55.908]                 added <- setdiff(names, old_names)
[17:40:55.908]                 removed <- setdiff(old_names, names)
[17:40:55.908]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:55.908]                   envs[common]]
[17:40:55.908]                 NAMES <- toupper(changed)
[17:40:55.908]                 args <- list()
[17:40:55.908]                 for (kk in seq_along(NAMES)) {
[17:40:55.908]                   name <- changed[[kk]]
[17:40:55.908]                   NAME <- NAMES[[kk]]
[17:40:55.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.908]                     next
[17:40:55.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.908]                 }
[17:40:55.908]                 NAMES <- toupper(added)
[17:40:55.908]                 for (kk in seq_along(NAMES)) {
[17:40:55.908]                   name <- added[[kk]]
[17:40:55.908]                   NAME <- NAMES[[kk]]
[17:40:55.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.908]                     next
[17:40:55.908]                   args[[name]] <- ""
[17:40:55.908]                 }
[17:40:55.908]                 NAMES <- toupper(removed)
[17:40:55.908]                 for (kk in seq_along(NAMES)) {
[17:40:55.908]                   name <- removed[[kk]]
[17:40:55.908]                   NAME <- NAMES[[kk]]
[17:40:55.908]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:55.908]                     next
[17:40:55.908]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:55.908]                 }
[17:40:55.908]                 if (length(args) > 0) 
[17:40:55.908]                   base::do.call(base::Sys.setenv, args = args)
[17:40:55.908]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:55.908]             }
[17:40:55.908]             else {
[17:40:55.908]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:55.908]             }
[17:40:55.908]             {
[17:40:55.908]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:55.908]                   0L) {
[17:40:55.908]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:55.908]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:55.908]                   base::options(opts)
[17:40:55.908]                 }
[17:40:55.908]                 {
[17:40:55.908]                   {
[17:40:55.908]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:55.908]                     NULL
[17:40:55.908]                   }
[17:40:55.908]                   options(future.plan = NULL)
[17:40:55.908]                   if (is.na(NA_character_)) 
[17:40:55.908]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:55.908]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:55.908]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:55.908]                     .init = FALSE)
[17:40:55.908]                 }
[17:40:55.908]             }
[17:40:55.908]         }
[17:40:55.908]     })
[17:40:55.908]     if (TRUE) {
[17:40:55.908]         base::sink(type = "output", split = FALSE)
[17:40:55.908]         if (TRUE) {
[17:40:55.908]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:55.908]         }
[17:40:55.908]         else {
[17:40:55.908]             ...future.result["stdout"] <- base::list(NULL)
[17:40:55.908]         }
[17:40:55.908]         base::close(...future.stdout)
[17:40:55.908]         ...future.stdout <- NULL
[17:40:55.908]     }
[17:40:55.908]     ...future.result$conditions <- ...future.conditions
[17:40:55.908]     ...future.result$finished <- base::Sys.time()
[17:40:55.908]     ...future.result
[17:40:55.908] }
[17:40:55.910] MultisessionFuture started
[17:40:55.911] - Launch lazy future ... done
[17:40:55.911] run() for ‘MultisessionFuture’ ... done
[17:40:56.413] receiveMessageFromWorker() for ClusterFuture ...
[17:40:56.413] - Validating connection of MultisessionFuture
[17:40:56.414] - received message: FutureResult
[17:40:56.414] - Received FutureResult
[17:40:56.414] - Erased future from FutureRegistry
[17:40:56.414] result() for ClusterFuture ...
[17:40:56.414] - result already collected: FutureResult
[17:40:56.414] result() for ClusterFuture ... done
[17:40:56.414] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:56.414] resolve() on list ...
[17:40:56.415]  recursive: 0
[17:40:56.415]  length: 2
[17:40:56.415]  elements: ‘a’, ‘b’
[17:40:56.415]  length: 1 (resolved future 1)
[17:40:56.415]  length: 0 (resolved future 2)
[17:40:56.415] resolve() on list ... DONE
[17:40:56.415] A MultisessionFuture was resolved (and resolved itself)
[17:40:56.415] getGlobalsAndPackages() ...
[17:40:56.415] Searching for globals...
[17:40:56.416] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:56.417] Searching for globals ... DONE
[17:40:56.417] Resolving globals: FALSE
[17:40:56.417] 
[17:40:56.417] 
[17:40:56.417] getGlobalsAndPackages() ... DONE
[17:40:56.417] run() for ‘Future’ ...
[17:40:56.418] - state: ‘created’
[17:40:56.418] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:56.432]   - Field: ‘node’
[17:40:56.432]   - Field: ‘label’
[17:40:56.432]   - Field: ‘local’
[17:40:56.433]   - Field: ‘owner’
[17:40:56.433]   - Field: ‘envir’
[17:40:56.433]   - Field: ‘workers’
[17:40:56.433]   - Field: ‘packages’
[17:40:56.433]   - Field: ‘gc’
[17:40:56.433]   - Field: ‘conditions’
[17:40:56.433]   - Field: ‘persistent’
[17:40:56.433]   - Field: ‘expr’
[17:40:56.433]   - Field: ‘uuid’
[17:40:56.433]   - Field: ‘seed’
[17:40:56.433]   - Field: ‘version’
[17:40:56.434]   - Field: ‘result’
[17:40:56.434]   - Field: ‘asynchronous’
[17:40:56.434]   - Field: ‘calls’
[17:40:56.434]   - Field: ‘globals’
[17:40:56.434]   - Field: ‘stdout’
[17:40:56.434]   - Field: ‘earlySignal’
[17:40:56.434]   - Field: ‘lazy’
[17:40:56.434]   - Field: ‘state’
[17:40:56.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:56.434] - Launch lazy future ...
[17:40:56.435] Packages needed by the future expression (n = 0): <none>
[17:40:56.435] Packages needed by future strategies (n = 0): <none>
[17:40:56.435] {
[17:40:56.435]     {
[17:40:56.435]         {
[17:40:56.435]             ...future.startTime <- base::Sys.time()
[17:40:56.435]             {
[17:40:56.435]                 {
[17:40:56.435]                   {
[17:40:56.435]                     {
[17:40:56.435]                       base::local({
[17:40:56.435]                         has_future <- base::requireNamespace("future", 
[17:40:56.435]                           quietly = TRUE)
[17:40:56.435]                         if (has_future) {
[17:40:56.435]                           ns <- base::getNamespace("future")
[17:40:56.435]                           version <- ns[[".package"]][["version"]]
[17:40:56.435]                           if (is.null(version)) 
[17:40:56.435]                             version <- utils::packageVersion("future")
[17:40:56.435]                         }
[17:40:56.435]                         else {
[17:40:56.435]                           version <- NULL
[17:40:56.435]                         }
[17:40:56.435]                         if (!has_future || version < "1.8.0") {
[17:40:56.435]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.435]                             "", base::R.version$version.string), 
[17:40:56.435]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:56.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:56.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.435]                               "release", "version")], collapse = " "), 
[17:40:56.435]                             hostname = base::Sys.info()[["nodename"]])
[17:40:56.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.435]                             info)
[17:40:56.435]                           info <- base::paste(info, collapse = "; ")
[17:40:56.435]                           if (!has_future) {
[17:40:56.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.435]                               info)
[17:40:56.435]                           }
[17:40:56.435]                           else {
[17:40:56.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.435]                               info, version)
[17:40:56.435]                           }
[17:40:56.435]                           base::stop(msg)
[17:40:56.435]                         }
[17:40:56.435]                       })
[17:40:56.435]                     }
[17:40:56.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.435]                     base::options(mc.cores = 1L)
[17:40:56.435]                   }
[17:40:56.435]                   ...future.strategy.old <- future::plan("list")
[17:40:56.435]                   options(future.plan = NULL)
[17:40:56.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.435]                 }
[17:40:56.435]                 ...future.workdir <- getwd()
[17:40:56.435]             }
[17:40:56.435]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.435]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.435]         }
[17:40:56.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:56.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.435]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.435]             base::names(...future.oldOptions))
[17:40:56.435]     }
[17:40:56.435]     if (FALSE) {
[17:40:56.435]     }
[17:40:56.435]     else {
[17:40:56.435]         if (TRUE) {
[17:40:56.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.435]                 open = "w")
[17:40:56.435]         }
[17:40:56.435]         else {
[17:40:56.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.435]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.435]         }
[17:40:56.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.435]             base::sink(type = "output", split = FALSE)
[17:40:56.435]             base::close(...future.stdout)
[17:40:56.435]         }, add = TRUE)
[17:40:56.435]     }
[17:40:56.435]     ...future.frame <- base::sys.nframe()
[17:40:56.435]     ...future.conditions <- base::list()
[17:40:56.435]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.435]     if (FALSE) {
[17:40:56.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.435]     }
[17:40:56.435]     ...future.result <- base::tryCatch({
[17:40:56.435]         base::withCallingHandlers({
[17:40:56.435]             ...future.value <- base::withVisible(base::local({
[17:40:56.435]                 ...future.makeSendCondition <- base::local({
[17:40:56.435]                   sendCondition <- NULL
[17:40:56.435]                   function(frame = 1L) {
[17:40:56.435]                     if (is.function(sendCondition)) 
[17:40:56.435]                       return(sendCondition)
[17:40:56.435]                     ns <- getNamespace("parallel")
[17:40:56.435]                     if (exists("sendData", mode = "function", 
[17:40:56.435]                       envir = ns)) {
[17:40:56.435]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:56.435]                         envir = ns)
[17:40:56.435]                       envir <- sys.frame(frame)
[17:40:56.435]                       master <- NULL
[17:40:56.435]                       while (!identical(envir, .GlobalEnv) && 
[17:40:56.435]                         !identical(envir, emptyenv())) {
[17:40:56.435]                         if (exists("master", mode = "list", envir = envir, 
[17:40:56.435]                           inherits = FALSE)) {
[17:40:56.435]                           master <- get("master", mode = "list", 
[17:40:56.435]                             envir = envir, inherits = FALSE)
[17:40:56.435]                           if (inherits(master, c("SOCKnode", 
[17:40:56.435]                             "SOCK0node"))) {
[17:40:56.435]                             sendCondition <<- function(cond) {
[17:40:56.435]                               data <- list(type = "VALUE", value = cond, 
[17:40:56.435]                                 success = TRUE)
[17:40:56.435]                               parallel_sendData(master, data)
[17:40:56.435]                             }
[17:40:56.435]                             return(sendCondition)
[17:40:56.435]                           }
[17:40:56.435]                         }
[17:40:56.435]                         frame <- frame + 1L
[17:40:56.435]                         envir <- sys.frame(frame)
[17:40:56.435]                       }
[17:40:56.435]                     }
[17:40:56.435]                     sendCondition <<- function(cond) NULL
[17:40:56.435]                   }
[17:40:56.435]                 })
[17:40:56.435]                 withCallingHandlers({
[17:40:56.435]                   {
[17:40:56.435]                     Sys.sleep(0.5)
[17:40:56.435]                     list(a = 1, b = 42L)
[17:40:56.435]                   }
[17:40:56.435]                 }, immediateCondition = function(cond) {
[17:40:56.435]                   sendCondition <- ...future.makeSendCondition()
[17:40:56.435]                   sendCondition(cond)
[17:40:56.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.435]                   {
[17:40:56.435]                     inherits <- base::inherits
[17:40:56.435]                     invokeRestart <- base::invokeRestart
[17:40:56.435]                     is.null <- base::is.null
[17:40:56.435]                     muffled <- FALSE
[17:40:56.435]                     if (inherits(cond, "message")) {
[17:40:56.435]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.435]                       if (muffled) 
[17:40:56.435]                         invokeRestart("muffleMessage")
[17:40:56.435]                     }
[17:40:56.435]                     else if (inherits(cond, "warning")) {
[17:40:56.435]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.435]                       if (muffled) 
[17:40:56.435]                         invokeRestart("muffleWarning")
[17:40:56.435]                     }
[17:40:56.435]                     else if (inherits(cond, "condition")) {
[17:40:56.435]                       if (!is.null(pattern)) {
[17:40:56.435]                         computeRestarts <- base::computeRestarts
[17:40:56.435]                         grepl <- base::grepl
[17:40:56.435]                         restarts <- computeRestarts(cond)
[17:40:56.435]                         for (restart in restarts) {
[17:40:56.435]                           name <- restart$name
[17:40:56.435]                           if (is.null(name)) 
[17:40:56.435]                             next
[17:40:56.435]                           if (!grepl(pattern, name)) 
[17:40:56.435]                             next
[17:40:56.435]                           invokeRestart(restart)
[17:40:56.435]                           muffled <- TRUE
[17:40:56.435]                           break
[17:40:56.435]                         }
[17:40:56.435]                       }
[17:40:56.435]                     }
[17:40:56.435]                     invisible(muffled)
[17:40:56.435]                   }
[17:40:56.435]                   muffleCondition(cond)
[17:40:56.435]                 })
[17:40:56.435]             }))
[17:40:56.435]             future::FutureResult(value = ...future.value$value, 
[17:40:56.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.435]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.435]                     ...future.globalenv.names))
[17:40:56.435]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.435]         }, condition = base::local({
[17:40:56.435]             c <- base::c
[17:40:56.435]             inherits <- base::inherits
[17:40:56.435]             invokeRestart <- base::invokeRestart
[17:40:56.435]             length <- base::length
[17:40:56.435]             list <- base::list
[17:40:56.435]             seq.int <- base::seq.int
[17:40:56.435]             signalCondition <- base::signalCondition
[17:40:56.435]             sys.calls <- base::sys.calls
[17:40:56.435]             `[[` <- base::`[[`
[17:40:56.435]             `+` <- base::`+`
[17:40:56.435]             `<<-` <- base::`<<-`
[17:40:56.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.435]                   3L)]
[17:40:56.435]             }
[17:40:56.435]             function(cond) {
[17:40:56.435]                 is_error <- inherits(cond, "error")
[17:40:56.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.435]                   NULL)
[17:40:56.435]                 if (is_error) {
[17:40:56.435]                   sessionInformation <- function() {
[17:40:56.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.435]                       search = base::search(), system = base::Sys.info())
[17:40:56.435]                   }
[17:40:56.435]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.435]                     cond$call), session = sessionInformation(), 
[17:40:56.435]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.435]                   signalCondition(cond)
[17:40:56.435]                 }
[17:40:56.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.435]                 "immediateCondition"))) {
[17:40:56.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.435]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.435]                   if (TRUE && !signal) {
[17:40:56.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.435]                     {
[17:40:56.435]                       inherits <- base::inherits
[17:40:56.435]                       invokeRestart <- base::invokeRestart
[17:40:56.435]                       is.null <- base::is.null
[17:40:56.435]                       muffled <- FALSE
[17:40:56.435]                       if (inherits(cond, "message")) {
[17:40:56.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.435]                         if (muffled) 
[17:40:56.435]                           invokeRestart("muffleMessage")
[17:40:56.435]                       }
[17:40:56.435]                       else if (inherits(cond, "warning")) {
[17:40:56.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.435]                         if (muffled) 
[17:40:56.435]                           invokeRestart("muffleWarning")
[17:40:56.435]                       }
[17:40:56.435]                       else if (inherits(cond, "condition")) {
[17:40:56.435]                         if (!is.null(pattern)) {
[17:40:56.435]                           computeRestarts <- base::computeRestarts
[17:40:56.435]                           grepl <- base::grepl
[17:40:56.435]                           restarts <- computeRestarts(cond)
[17:40:56.435]                           for (restart in restarts) {
[17:40:56.435]                             name <- restart$name
[17:40:56.435]                             if (is.null(name)) 
[17:40:56.435]                               next
[17:40:56.435]                             if (!grepl(pattern, name)) 
[17:40:56.435]                               next
[17:40:56.435]                             invokeRestart(restart)
[17:40:56.435]                             muffled <- TRUE
[17:40:56.435]                             break
[17:40:56.435]                           }
[17:40:56.435]                         }
[17:40:56.435]                       }
[17:40:56.435]                       invisible(muffled)
[17:40:56.435]                     }
[17:40:56.435]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.435]                   }
[17:40:56.435]                 }
[17:40:56.435]                 else {
[17:40:56.435]                   if (TRUE) {
[17:40:56.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.435]                     {
[17:40:56.435]                       inherits <- base::inherits
[17:40:56.435]                       invokeRestart <- base::invokeRestart
[17:40:56.435]                       is.null <- base::is.null
[17:40:56.435]                       muffled <- FALSE
[17:40:56.435]                       if (inherits(cond, "message")) {
[17:40:56.435]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.435]                         if (muffled) 
[17:40:56.435]                           invokeRestart("muffleMessage")
[17:40:56.435]                       }
[17:40:56.435]                       else if (inherits(cond, "warning")) {
[17:40:56.435]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.435]                         if (muffled) 
[17:40:56.435]                           invokeRestart("muffleWarning")
[17:40:56.435]                       }
[17:40:56.435]                       else if (inherits(cond, "condition")) {
[17:40:56.435]                         if (!is.null(pattern)) {
[17:40:56.435]                           computeRestarts <- base::computeRestarts
[17:40:56.435]                           grepl <- base::grepl
[17:40:56.435]                           restarts <- computeRestarts(cond)
[17:40:56.435]                           for (restart in restarts) {
[17:40:56.435]                             name <- restart$name
[17:40:56.435]                             if (is.null(name)) 
[17:40:56.435]                               next
[17:40:56.435]                             if (!grepl(pattern, name)) 
[17:40:56.435]                               next
[17:40:56.435]                             invokeRestart(restart)
[17:40:56.435]                             muffled <- TRUE
[17:40:56.435]                             break
[17:40:56.435]                           }
[17:40:56.435]                         }
[17:40:56.435]                       }
[17:40:56.435]                       invisible(muffled)
[17:40:56.435]                     }
[17:40:56.435]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.435]                   }
[17:40:56.435]                 }
[17:40:56.435]             }
[17:40:56.435]         }))
[17:40:56.435]     }, error = function(ex) {
[17:40:56.435]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.435]                 ...future.rng), started = ...future.startTime, 
[17:40:56.435]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.435]             version = "1.8"), class = "FutureResult")
[17:40:56.435]     }, finally = {
[17:40:56.435]         if (!identical(...future.workdir, getwd())) 
[17:40:56.435]             setwd(...future.workdir)
[17:40:56.435]         {
[17:40:56.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.435]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.435]             }
[17:40:56.435]             base::options(...future.oldOptions)
[17:40:56.435]             if (.Platform$OS.type == "windows") {
[17:40:56.435]                 old_names <- names(...future.oldEnvVars)
[17:40:56.435]                 envs <- base::Sys.getenv()
[17:40:56.435]                 names <- names(envs)
[17:40:56.435]                 common <- intersect(names, old_names)
[17:40:56.435]                 added <- setdiff(names, old_names)
[17:40:56.435]                 removed <- setdiff(old_names, names)
[17:40:56.435]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.435]                   envs[common]]
[17:40:56.435]                 NAMES <- toupper(changed)
[17:40:56.435]                 args <- list()
[17:40:56.435]                 for (kk in seq_along(NAMES)) {
[17:40:56.435]                   name <- changed[[kk]]
[17:40:56.435]                   NAME <- NAMES[[kk]]
[17:40:56.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.435]                     next
[17:40:56.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.435]                 }
[17:40:56.435]                 NAMES <- toupper(added)
[17:40:56.435]                 for (kk in seq_along(NAMES)) {
[17:40:56.435]                   name <- added[[kk]]
[17:40:56.435]                   NAME <- NAMES[[kk]]
[17:40:56.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.435]                     next
[17:40:56.435]                   args[[name]] <- ""
[17:40:56.435]                 }
[17:40:56.435]                 NAMES <- toupper(removed)
[17:40:56.435]                 for (kk in seq_along(NAMES)) {
[17:40:56.435]                   name <- removed[[kk]]
[17:40:56.435]                   NAME <- NAMES[[kk]]
[17:40:56.435]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.435]                     next
[17:40:56.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.435]                 }
[17:40:56.435]                 if (length(args) > 0) 
[17:40:56.435]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.435]             }
[17:40:56.435]             else {
[17:40:56.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.435]             }
[17:40:56.435]             {
[17:40:56.435]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.435]                   0L) {
[17:40:56.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.435]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.435]                   base::options(opts)
[17:40:56.435]                 }
[17:40:56.435]                 {
[17:40:56.435]                   {
[17:40:56.435]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.435]                     NULL
[17:40:56.435]                   }
[17:40:56.435]                   options(future.plan = NULL)
[17:40:56.435]                   if (is.na(NA_character_)) 
[17:40:56.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:56.435]                     .init = FALSE)
[17:40:56.435]                 }
[17:40:56.435]             }
[17:40:56.435]         }
[17:40:56.435]     })
[17:40:56.435]     if (TRUE) {
[17:40:56.435]         base::sink(type = "output", split = FALSE)
[17:40:56.435]         if (TRUE) {
[17:40:56.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.435]         }
[17:40:56.435]         else {
[17:40:56.435]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.435]         }
[17:40:56.435]         base::close(...future.stdout)
[17:40:56.435]         ...future.stdout <- NULL
[17:40:56.435]     }
[17:40:56.435]     ...future.result$conditions <- ...future.conditions
[17:40:56.435]     ...future.result$finished <- base::Sys.time()
[17:40:56.435]     ...future.result
[17:40:56.435] }
[17:40:56.438] MultisessionFuture started
[17:40:56.438] - Launch lazy future ... done
[17:40:56.438] run() for ‘MultisessionFuture’ ... done
[17:40:56.941] receiveMessageFromWorker() for ClusterFuture ...
[17:40:56.941] - Validating connection of MultisessionFuture
[17:40:56.941] - received message: FutureResult
[17:40:56.941] - Received FutureResult
[17:40:56.942] - Erased future from FutureRegistry
[17:40:56.942] result() for ClusterFuture ...
[17:40:56.942] - result already collected: FutureResult
[17:40:56.942] result() for ClusterFuture ... done
[17:40:56.942] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:56.942] resolve() on list ...
[17:40:56.942]  recursive: 0
[17:40:56.942]  length: 2
[17:40:56.942]  elements: ‘a’, ‘b’
[17:40:56.942]  length: 1 (resolved future 1)
[17:40:56.943]  length: 0 (resolved future 2)
[17:40:56.943] resolve() on list ... DONE
[17:40:56.943] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:40:56.943] getGlobalsAndPackages() ...
[17:40:56.943] Searching for globals...
[17:40:56.944] - globals found: [2] ‘list’, ‘stop’
[17:40:56.944] Searching for globals ... DONE
[17:40:56.944] Resolving globals: FALSE
[17:40:56.944] 
[17:40:56.944] 
[17:40:56.944] getGlobalsAndPackages() ... DONE
[17:40:56.945] run() for ‘Future’ ...
[17:40:56.945] - state: ‘created’
[17:40:56.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:56.964]   - Field: ‘node’
[17:40:56.964]   - Field: ‘label’
[17:40:56.964]   - Field: ‘local’
[17:40:56.964]   - Field: ‘owner’
[17:40:56.965]   - Field: ‘envir’
[17:40:56.965]   - Field: ‘workers’
[17:40:56.965]   - Field: ‘packages’
[17:40:56.965]   - Field: ‘gc’
[17:40:56.965]   - Field: ‘conditions’
[17:40:56.965]   - Field: ‘persistent’
[17:40:56.965]   - Field: ‘expr’
[17:40:56.965]   - Field: ‘uuid’
[17:40:56.965]   - Field: ‘seed’
[17:40:56.965]   - Field: ‘version’
[17:40:56.965]   - Field: ‘result’
[17:40:56.966]   - Field: ‘asynchronous’
[17:40:56.966]   - Field: ‘calls’
[17:40:56.966]   - Field: ‘globals’
[17:40:56.966]   - Field: ‘stdout’
[17:40:56.966]   - Field: ‘earlySignal’
[17:40:56.966]   - Field: ‘lazy’
[17:40:56.966]   - Field: ‘state’
[17:40:56.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:56.966] - Launch lazy future ...
[17:40:56.967] Packages needed by the future expression (n = 0): <none>
[17:40:56.967] Packages needed by future strategies (n = 0): <none>
[17:40:56.967] {
[17:40:56.967]     {
[17:40:56.967]         {
[17:40:56.967]             ...future.startTime <- base::Sys.time()
[17:40:56.967]             {
[17:40:56.967]                 {
[17:40:56.967]                   {
[17:40:56.967]                     {
[17:40:56.967]                       base::local({
[17:40:56.967]                         has_future <- base::requireNamespace("future", 
[17:40:56.967]                           quietly = TRUE)
[17:40:56.967]                         if (has_future) {
[17:40:56.967]                           ns <- base::getNamespace("future")
[17:40:56.967]                           version <- ns[[".package"]][["version"]]
[17:40:56.967]                           if (is.null(version)) 
[17:40:56.967]                             version <- utils::packageVersion("future")
[17:40:56.967]                         }
[17:40:56.967]                         else {
[17:40:56.967]                           version <- NULL
[17:40:56.967]                         }
[17:40:56.967]                         if (!has_future || version < "1.8.0") {
[17:40:56.967]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.967]                             "", base::R.version$version.string), 
[17:40:56.967]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:56.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:56.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.967]                               "release", "version")], collapse = " "), 
[17:40:56.967]                             hostname = base::Sys.info()[["nodename"]])
[17:40:56.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.967]                             info)
[17:40:56.967]                           info <- base::paste(info, collapse = "; ")
[17:40:56.967]                           if (!has_future) {
[17:40:56.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.967]                               info)
[17:40:56.967]                           }
[17:40:56.967]                           else {
[17:40:56.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.967]                               info, version)
[17:40:56.967]                           }
[17:40:56.967]                           base::stop(msg)
[17:40:56.967]                         }
[17:40:56.967]                       })
[17:40:56.967]                     }
[17:40:56.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.967]                     base::options(mc.cores = 1L)
[17:40:56.967]                   }
[17:40:56.967]                   ...future.strategy.old <- future::plan("list")
[17:40:56.967]                   options(future.plan = NULL)
[17:40:56.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.967]                 }
[17:40:56.967]                 ...future.workdir <- getwd()
[17:40:56.967]             }
[17:40:56.967]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.967]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.967]         }
[17:40:56.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:56.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.967]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.967]             base::names(...future.oldOptions))
[17:40:56.967]     }
[17:40:56.967]     if (FALSE) {
[17:40:56.967]     }
[17:40:56.967]     else {
[17:40:56.967]         if (TRUE) {
[17:40:56.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.967]                 open = "w")
[17:40:56.967]         }
[17:40:56.967]         else {
[17:40:56.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.967]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.967]         }
[17:40:56.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.967]             base::sink(type = "output", split = FALSE)
[17:40:56.967]             base::close(...future.stdout)
[17:40:56.967]         }, add = TRUE)
[17:40:56.967]     }
[17:40:56.967]     ...future.frame <- base::sys.nframe()
[17:40:56.967]     ...future.conditions <- base::list()
[17:40:56.967]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.967]     if (FALSE) {
[17:40:56.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.967]     }
[17:40:56.967]     ...future.result <- base::tryCatch({
[17:40:56.967]         base::withCallingHandlers({
[17:40:56.967]             ...future.value <- base::withVisible(base::local({
[17:40:56.967]                 ...future.makeSendCondition <- base::local({
[17:40:56.967]                   sendCondition <- NULL
[17:40:56.967]                   function(frame = 1L) {
[17:40:56.967]                     if (is.function(sendCondition)) 
[17:40:56.967]                       return(sendCondition)
[17:40:56.967]                     ns <- getNamespace("parallel")
[17:40:56.967]                     if (exists("sendData", mode = "function", 
[17:40:56.967]                       envir = ns)) {
[17:40:56.967]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:56.967]                         envir = ns)
[17:40:56.967]                       envir <- sys.frame(frame)
[17:40:56.967]                       master <- NULL
[17:40:56.967]                       while (!identical(envir, .GlobalEnv) && 
[17:40:56.967]                         !identical(envir, emptyenv())) {
[17:40:56.967]                         if (exists("master", mode = "list", envir = envir, 
[17:40:56.967]                           inherits = FALSE)) {
[17:40:56.967]                           master <- get("master", mode = "list", 
[17:40:56.967]                             envir = envir, inherits = FALSE)
[17:40:56.967]                           if (inherits(master, c("SOCKnode", 
[17:40:56.967]                             "SOCK0node"))) {
[17:40:56.967]                             sendCondition <<- function(cond) {
[17:40:56.967]                               data <- list(type = "VALUE", value = cond, 
[17:40:56.967]                                 success = TRUE)
[17:40:56.967]                               parallel_sendData(master, data)
[17:40:56.967]                             }
[17:40:56.967]                             return(sendCondition)
[17:40:56.967]                           }
[17:40:56.967]                         }
[17:40:56.967]                         frame <- frame + 1L
[17:40:56.967]                         envir <- sys.frame(frame)
[17:40:56.967]                       }
[17:40:56.967]                     }
[17:40:56.967]                     sendCondition <<- function(cond) NULL
[17:40:56.967]                   }
[17:40:56.967]                 })
[17:40:56.967]                 withCallingHandlers({
[17:40:56.967]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:56.967]                 }, immediateCondition = function(cond) {
[17:40:56.967]                   sendCondition <- ...future.makeSendCondition()
[17:40:56.967]                   sendCondition(cond)
[17:40:56.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.967]                   {
[17:40:56.967]                     inherits <- base::inherits
[17:40:56.967]                     invokeRestart <- base::invokeRestart
[17:40:56.967]                     is.null <- base::is.null
[17:40:56.967]                     muffled <- FALSE
[17:40:56.967]                     if (inherits(cond, "message")) {
[17:40:56.967]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.967]                       if (muffled) 
[17:40:56.967]                         invokeRestart("muffleMessage")
[17:40:56.967]                     }
[17:40:56.967]                     else if (inherits(cond, "warning")) {
[17:40:56.967]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.967]                       if (muffled) 
[17:40:56.967]                         invokeRestart("muffleWarning")
[17:40:56.967]                     }
[17:40:56.967]                     else if (inherits(cond, "condition")) {
[17:40:56.967]                       if (!is.null(pattern)) {
[17:40:56.967]                         computeRestarts <- base::computeRestarts
[17:40:56.967]                         grepl <- base::grepl
[17:40:56.967]                         restarts <- computeRestarts(cond)
[17:40:56.967]                         for (restart in restarts) {
[17:40:56.967]                           name <- restart$name
[17:40:56.967]                           if (is.null(name)) 
[17:40:56.967]                             next
[17:40:56.967]                           if (!grepl(pattern, name)) 
[17:40:56.967]                             next
[17:40:56.967]                           invokeRestart(restart)
[17:40:56.967]                           muffled <- TRUE
[17:40:56.967]                           break
[17:40:56.967]                         }
[17:40:56.967]                       }
[17:40:56.967]                     }
[17:40:56.967]                     invisible(muffled)
[17:40:56.967]                   }
[17:40:56.967]                   muffleCondition(cond)
[17:40:56.967]                 })
[17:40:56.967]             }))
[17:40:56.967]             future::FutureResult(value = ...future.value$value, 
[17:40:56.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.967]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.967]                     ...future.globalenv.names))
[17:40:56.967]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.967]         }, condition = base::local({
[17:40:56.967]             c <- base::c
[17:40:56.967]             inherits <- base::inherits
[17:40:56.967]             invokeRestart <- base::invokeRestart
[17:40:56.967]             length <- base::length
[17:40:56.967]             list <- base::list
[17:40:56.967]             seq.int <- base::seq.int
[17:40:56.967]             signalCondition <- base::signalCondition
[17:40:56.967]             sys.calls <- base::sys.calls
[17:40:56.967]             `[[` <- base::`[[`
[17:40:56.967]             `+` <- base::`+`
[17:40:56.967]             `<<-` <- base::`<<-`
[17:40:56.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.967]                   3L)]
[17:40:56.967]             }
[17:40:56.967]             function(cond) {
[17:40:56.967]                 is_error <- inherits(cond, "error")
[17:40:56.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.967]                   NULL)
[17:40:56.967]                 if (is_error) {
[17:40:56.967]                   sessionInformation <- function() {
[17:40:56.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.967]                       search = base::search(), system = base::Sys.info())
[17:40:56.967]                   }
[17:40:56.967]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.967]                     cond$call), session = sessionInformation(), 
[17:40:56.967]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.967]                   signalCondition(cond)
[17:40:56.967]                 }
[17:40:56.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.967]                 "immediateCondition"))) {
[17:40:56.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.967]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.967]                   if (TRUE && !signal) {
[17:40:56.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.967]                     {
[17:40:56.967]                       inherits <- base::inherits
[17:40:56.967]                       invokeRestart <- base::invokeRestart
[17:40:56.967]                       is.null <- base::is.null
[17:40:56.967]                       muffled <- FALSE
[17:40:56.967]                       if (inherits(cond, "message")) {
[17:40:56.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.967]                         if (muffled) 
[17:40:56.967]                           invokeRestart("muffleMessage")
[17:40:56.967]                       }
[17:40:56.967]                       else if (inherits(cond, "warning")) {
[17:40:56.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.967]                         if (muffled) 
[17:40:56.967]                           invokeRestart("muffleWarning")
[17:40:56.967]                       }
[17:40:56.967]                       else if (inherits(cond, "condition")) {
[17:40:56.967]                         if (!is.null(pattern)) {
[17:40:56.967]                           computeRestarts <- base::computeRestarts
[17:40:56.967]                           grepl <- base::grepl
[17:40:56.967]                           restarts <- computeRestarts(cond)
[17:40:56.967]                           for (restart in restarts) {
[17:40:56.967]                             name <- restart$name
[17:40:56.967]                             if (is.null(name)) 
[17:40:56.967]                               next
[17:40:56.967]                             if (!grepl(pattern, name)) 
[17:40:56.967]                               next
[17:40:56.967]                             invokeRestart(restart)
[17:40:56.967]                             muffled <- TRUE
[17:40:56.967]                             break
[17:40:56.967]                           }
[17:40:56.967]                         }
[17:40:56.967]                       }
[17:40:56.967]                       invisible(muffled)
[17:40:56.967]                     }
[17:40:56.967]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.967]                   }
[17:40:56.967]                 }
[17:40:56.967]                 else {
[17:40:56.967]                   if (TRUE) {
[17:40:56.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.967]                     {
[17:40:56.967]                       inherits <- base::inherits
[17:40:56.967]                       invokeRestart <- base::invokeRestart
[17:40:56.967]                       is.null <- base::is.null
[17:40:56.967]                       muffled <- FALSE
[17:40:56.967]                       if (inherits(cond, "message")) {
[17:40:56.967]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.967]                         if (muffled) 
[17:40:56.967]                           invokeRestart("muffleMessage")
[17:40:56.967]                       }
[17:40:56.967]                       else if (inherits(cond, "warning")) {
[17:40:56.967]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.967]                         if (muffled) 
[17:40:56.967]                           invokeRestart("muffleWarning")
[17:40:56.967]                       }
[17:40:56.967]                       else if (inherits(cond, "condition")) {
[17:40:56.967]                         if (!is.null(pattern)) {
[17:40:56.967]                           computeRestarts <- base::computeRestarts
[17:40:56.967]                           grepl <- base::grepl
[17:40:56.967]                           restarts <- computeRestarts(cond)
[17:40:56.967]                           for (restart in restarts) {
[17:40:56.967]                             name <- restart$name
[17:40:56.967]                             if (is.null(name)) 
[17:40:56.967]                               next
[17:40:56.967]                             if (!grepl(pattern, name)) 
[17:40:56.967]                               next
[17:40:56.967]                             invokeRestart(restart)
[17:40:56.967]                             muffled <- TRUE
[17:40:56.967]                             break
[17:40:56.967]                           }
[17:40:56.967]                         }
[17:40:56.967]                       }
[17:40:56.967]                       invisible(muffled)
[17:40:56.967]                     }
[17:40:56.967]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.967]                   }
[17:40:56.967]                 }
[17:40:56.967]             }
[17:40:56.967]         }))
[17:40:56.967]     }, error = function(ex) {
[17:40:56.967]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.967]                 ...future.rng), started = ...future.startTime, 
[17:40:56.967]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.967]             version = "1.8"), class = "FutureResult")
[17:40:56.967]     }, finally = {
[17:40:56.967]         if (!identical(...future.workdir, getwd())) 
[17:40:56.967]             setwd(...future.workdir)
[17:40:56.967]         {
[17:40:56.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.967]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.967]             }
[17:40:56.967]             base::options(...future.oldOptions)
[17:40:56.967]             if (.Platform$OS.type == "windows") {
[17:40:56.967]                 old_names <- names(...future.oldEnvVars)
[17:40:56.967]                 envs <- base::Sys.getenv()
[17:40:56.967]                 names <- names(envs)
[17:40:56.967]                 common <- intersect(names, old_names)
[17:40:56.967]                 added <- setdiff(names, old_names)
[17:40:56.967]                 removed <- setdiff(old_names, names)
[17:40:56.967]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.967]                   envs[common]]
[17:40:56.967]                 NAMES <- toupper(changed)
[17:40:56.967]                 args <- list()
[17:40:56.967]                 for (kk in seq_along(NAMES)) {
[17:40:56.967]                   name <- changed[[kk]]
[17:40:56.967]                   NAME <- NAMES[[kk]]
[17:40:56.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.967]                     next
[17:40:56.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.967]                 }
[17:40:56.967]                 NAMES <- toupper(added)
[17:40:56.967]                 for (kk in seq_along(NAMES)) {
[17:40:56.967]                   name <- added[[kk]]
[17:40:56.967]                   NAME <- NAMES[[kk]]
[17:40:56.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.967]                     next
[17:40:56.967]                   args[[name]] <- ""
[17:40:56.967]                 }
[17:40:56.967]                 NAMES <- toupper(removed)
[17:40:56.967]                 for (kk in seq_along(NAMES)) {
[17:40:56.967]                   name <- removed[[kk]]
[17:40:56.967]                   NAME <- NAMES[[kk]]
[17:40:56.967]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.967]                     next
[17:40:56.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.967]                 }
[17:40:56.967]                 if (length(args) > 0) 
[17:40:56.967]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.967]             }
[17:40:56.967]             else {
[17:40:56.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.967]             }
[17:40:56.967]             {
[17:40:56.967]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.967]                   0L) {
[17:40:56.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.967]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.967]                   base::options(opts)
[17:40:56.967]                 }
[17:40:56.967]                 {
[17:40:56.967]                   {
[17:40:56.967]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.967]                     NULL
[17:40:56.967]                   }
[17:40:56.967]                   options(future.plan = NULL)
[17:40:56.967]                   if (is.na(NA_character_)) 
[17:40:56.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:56.967]                     .init = FALSE)
[17:40:56.967]                 }
[17:40:56.967]             }
[17:40:56.967]         }
[17:40:56.967]     })
[17:40:56.967]     if (TRUE) {
[17:40:56.967]         base::sink(type = "output", split = FALSE)
[17:40:56.967]         if (TRUE) {
[17:40:56.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.967]         }
[17:40:56.967]         else {
[17:40:56.967]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.967]         }
[17:40:56.967]         base::close(...future.stdout)
[17:40:56.967]         ...future.stdout <- NULL
[17:40:56.967]     }
[17:40:56.967]     ...future.result$conditions <- ...future.conditions
[17:40:56.967]     ...future.result$finished <- base::Sys.time()
[17:40:56.967]     ...future.result
[17:40:56.967] }
[17:40:56.970] MultisessionFuture started
[17:40:56.970] - Launch lazy future ... done
[17:40:56.970] run() for ‘MultisessionFuture’ ... done
[17:40:56.972] receiveMessageFromWorker() for ClusterFuture ...
[17:40:56.972] - Validating connection of MultisessionFuture
[17:40:56.972] - received message: FutureResult
[17:40:56.972] - Received FutureResult
[17:40:56.972] - Erased future from FutureRegistry
[17:40:56.972] result() for ClusterFuture ...
[17:40:56.973] - result already collected: FutureResult
[17:40:56.973] result() for ClusterFuture ... done
[17:40:56.973] signalConditions() ...
[17:40:56.973]  - include = ‘immediateCondition’
[17:40:56.973]  - exclude = 
[17:40:56.973]  - resignal = FALSE
[17:40:56.973]  - Number of conditions: 1
[17:40:56.973] signalConditions() ... done
[17:40:56.973] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:56.973] A MultisessionFuture was resolved (and resolved itself)
[17:40:56.973] getGlobalsAndPackages() ...
[17:40:56.973] Searching for globals...
[17:40:56.974] - globals found: [2] ‘list’, ‘stop’
[17:40:56.974] Searching for globals ... DONE
[17:40:56.974] Resolving globals: FALSE
[17:40:56.975] 
[17:40:56.975] 
[17:40:56.975] getGlobalsAndPackages() ... DONE
[17:40:56.975] run() for ‘Future’ ...
[17:40:56.975] - state: ‘created’
[17:40:56.975] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:56.988] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:56.988] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:56.989]   - Field: ‘node’
[17:40:56.989]   - Field: ‘label’
[17:40:56.989]   - Field: ‘local’
[17:40:56.989]   - Field: ‘owner’
[17:40:56.989]   - Field: ‘envir’
[17:40:56.989]   - Field: ‘workers’
[17:40:56.989]   - Field: ‘packages’
[17:40:56.989]   - Field: ‘gc’
[17:40:56.989]   - Field: ‘conditions’
[17:40:56.989]   - Field: ‘persistent’
[17:40:56.989]   - Field: ‘expr’
[17:40:56.990]   - Field: ‘uuid’
[17:40:56.990]   - Field: ‘seed’
[17:40:56.990]   - Field: ‘version’
[17:40:56.990]   - Field: ‘result’
[17:40:56.990]   - Field: ‘asynchronous’
[17:40:56.990]   - Field: ‘calls’
[17:40:56.990]   - Field: ‘globals’
[17:40:56.990]   - Field: ‘stdout’
[17:40:56.990]   - Field: ‘earlySignal’
[17:40:56.990]   - Field: ‘lazy’
[17:40:56.990]   - Field: ‘state’
[17:40:56.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:56.991] - Launch lazy future ...
[17:40:56.991] Packages needed by the future expression (n = 0): <none>
[17:40:56.991] Packages needed by future strategies (n = 0): <none>
[17:40:56.991] {
[17:40:56.991]     {
[17:40:56.991]         {
[17:40:56.991]             ...future.startTime <- base::Sys.time()
[17:40:56.991]             {
[17:40:56.991]                 {
[17:40:56.991]                   {
[17:40:56.991]                     {
[17:40:56.991]                       base::local({
[17:40:56.991]                         has_future <- base::requireNamespace("future", 
[17:40:56.991]                           quietly = TRUE)
[17:40:56.991]                         if (has_future) {
[17:40:56.991]                           ns <- base::getNamespace("future")
[17:40:56.991]                           version <- ns[[".package"]][["version"]]
[17:40:56.991]                           if (is.null(version)) 
[17:40:56.991]                             version <- utils::packageVersion("future")
[17:40:56.991]                         }
[17:40:56.991]                         else {
[17:40:56.991]                           version <- NULL
[17:40:56.991]                         }
[17:40:56.991]                         if (!has_future || version < "1.8.0") {
[17:40:56.991]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:56.991]                             "", base::R.version$version.string), 
[17:40:56.991]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:56.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:56.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:56.991]                               "release", "version")], collapse = " "), 
[17:40:56.991]                             hostname = base::Sys.info()[["nodename"]])
[17:40:56.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:56.991]                             info)
[17:40:56.991]                           info <- base::paste(info, collapse = "; ")
[17:40:56.991]                           if (!has_future) {
[17:40:56.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:56.991]                               info)
[17:40:56.991]                           }
[17:40:56.991]                           else {
[17:40:56.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:56.991]                               info, version)
[17:40:56.991]                           }
[17:40:56.991]                           base::stop(msg)
[17:40:56.991]                         }
[17:40:56.991]                       })
[17:40:56.991]                     }
[17:40:56.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:56.991]                     base::options(mc.cores = 1L)
[17:40:56.991]                   }
[17:40:56.991]                   ...future.strategy.old <- future::plan("list")
[17:40:56.991]                   options(future.plan = NULL)
[17:40:56.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:56.991]                 }
[17:40:56.991]                 ...future.workdir <- getwd()
[17:40:56.991]             }
[17:40:56.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:56.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:56.991]         }
[17:40:56.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:56.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:56.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:56.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:56.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:56.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:56.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:56.991]             base::names(...future.oldOptions))
[17:40:56.991]     }
[17:40:56.991]     if (FALSE) {
[17:40:56.991]     }
[17:40:56.991]     else {
[17:40:56.991]         if (TRUE) {
[17:40:56.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:56.991]                 open = "w")
[17:40:56.991]         }
[17:40:56.991]         else {
[17:40:56.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:56.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:56.991]         }
[17:40:56.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:56.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:56.991]             base::sink(type = "output", split = FALSE)
[17:40:56.991]             base::close(...future.stdout)
[17:40:56.991]         }, add = TRUE)
[17:40:56.991]     }
[17:40:56.991]     ...future.frame <- base::sys.nframe()
[17:40:56.991]     ...future.conditions <- base::list()
[17:40:56.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:56.991]     if (FALSE) {
[17:40:56.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:56.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:56.991]     }
[17:40:56.991]     ...future.result <- base::tryCatch({
[17:40:56.991]         base::withCallingHandlers({
[17:40:56.991]             ...future.value <- base::withVisible(base::local({
[17:40:56.991]                 ...future.makeSendCondition <- base::local({
[17:40:56.991]                   sendCondition <- NULL
[17:40:56.991]                   function(frame = 1L) {
[17:40:56.991]                     if (is.function(sendCondition)) 
[17:40:56.991]                       return(sendCondition)
[17:40:56.991]                     ns <- getNamespace("parallel")
[17:40:56.991]                     if (exists("sendData", mode = "function", 
[17:40:56.991]                       envir = ns)) {
[17:40:56.991]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:56.991]                         envir = ns)
[17:40:56.991]                       envir <- sys.frame(frame)
[17:40:56.991]                       master <- NULL
[17:40:56.991]                       while (!identical(envir, .GlobalEnv) && 
[17:40:56.991]                         !identical(envir, emptyenv())) {
[17:40:56.991]                         if (exists("master", mode = "list", envir = envir, 
[17:40:56.991]                           inherits = FALSE)) {
[17:40:56.991]                           master <- get("master", mode = "list", 
[17:40:56.991]                             envir = envir, inherits = FALSE)
[17:40:56.991]                           if (inherits(master, c("SOCKnode", 
[17:40:56.991]                             "SOCK0node"))) {
[17:40:56.991]                             sendCondition <<- function(cond) {
[17:40:56.991]                               data <- list(type = "VALUE", value = cond, 
[17:40:56.991]                                 success = TRUE)
[17:40:56.991]                               parallel_sendData(master, data)
[17:40:56.991]                             }
[17:40:56.991]                             return(sendCondition)
[17:40:56.991]                           }
[17:40:56.991]                         }
[17:40:56.991]                         frame <- frame + 1L
[17:40:56.991]                         envir <- sys.frame(frame)
[17:40:56.991]                       }
[17:40:56.991]                     }
[17:40:56.991]                     sendCondition <<- function(cond) NULL
[17:40:56.991]                   }
[17:40:56.991]                 })
[17:40:56.991]                 withCallingHandlers({
[17:40:56.991]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:56.991]                 }, immediateCondition = function(cond) {
[17:40:56.991]                   sendCondition <- ...future.makeSendCondition()
[17:40:56.991]                   sendCondition(cond)
[17:40:56.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.991]                   {
[17:40:56.991]                     inherits <- base::inherits
[17:40:56.991]                     invokeRestart <- base::invokeRestart
[17:40:56.991]                     is.null <- base::is.null
[17:40:56.991]                     muffled <- FALSE
[17:40:56.991]                     if (inherits(cond, "message")) {
[17:40:56.991]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:56.991]                       if (muffled) 
[17:40:56.991]                         invokeRestart("muffleMessage")
[17:40:56.991]                     }
[17:40:56.991]                     else if (inherits(cond, "warning")) {
[17:40:56.991]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:56.991]                       if (muffled) 
[17:40:56.991]                         invokeRestart("muffleWarning")
[17:40:56.991]                     }
[17:40:56.991]                     else if (inherits(cond, "condition")) {
[17:40:56.991]                       if (!is.null(pattern)) {
[17:40:56.991]                         computeRestarts <- base::computeRestarts
[17:40:56.991]                         grepl <- base::grepl
[17:40:56.991]                         restarts <- computeRestarts(cond)
[17:40:56.991]                         for (restart in restarts) {
[17:40:56.991]                           name <- restart$name
[17:40:56.991]                           if (is.null(name)) 
[17:40:56.991]                             next
[17:40:56.991]                           if (!grepl(pattern, name)) 
[17:40:56.991]                             next
[17:40:56.991]                           invokeRestart(restart)
[17:40:56.991]                           muffled <- TRUE
[17:40:56.991]                           break
[17:40:56.991]                         }
[17:40:56.991]                       }
[17:40:56.991]                     }
[17:40:56.991]                     invisible(muffled)
[17:40:56.991]                   }
[17:40:56.991]                   muffleCondition(cond)
[17:40:56.991]                 })
[17:40:56.991]             }))
[17:40:56.991]             future::FutureResult(value = ...future.value$value, 
[17:40:56.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.991]                   ...future.rng), globalenv = if (FALSE) 
[17:40:56.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:56.991]                     ...future.globalenv.names))
[17:40:56.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:56.991]         }, condition = base::local({
[17:40:56.991]             c <- base::c
[17:40:56.991]             inherits <- base::inherits
[17:40:56.991]             invokeRestart <- base::invokeRestart
[17:40:56.991]             length <- base::length
[17:40:56.991]             list <- base::list
[17:40:56.991]             seq.int <- base::seq.int
[17:40:56.991]             signalCondition <- base::signalCondition
[17:40:56.991]             sys.calls <- base::sys.calls
[17:40:56.991]             `[[` <- base::`[[`
[17:40:56.991]             `+` <- base::`+`
[17:40:56.991]             `<<-` <- base::`<<-`
[17:40:56.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:56.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:56.991]                   3L)]
[17:40:56.991]             }
[17:40:56.991]             function(cond) {
[17:40:56.991]                 is_error <- inherits(cond, "error")
[17:40:56.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:56.991]                   NULL)
[17:40:56.991]                 if (is_error) {
[17:40:56.991]                   sessionInformation <- function() {
[17:40:56.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:56.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:56.991]                       search = base::search(), system = base::Sys.info())
[17:40:56.991]                   }
[17:40:56.991]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:56.991]                     cond$call), session = sessionInformation(), 
[17:40:56.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:56.991]                   signalCondition(cond)
[17:40:56.991]                 }
[17:40:56.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:56.991]                 "immediateCondition"))) {
[17:40:56.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:56.991]                   ...future.conditions[[length(...future.conditions) + 
[17:40:56.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:56.991]                   if (TRUE && !signal) {
[17:40:56.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.991]                     {
[17:40:56.991]                       inherits <- base::inherits
[17:40:56.991]                       invokeRestart <- base::invokeRestart
[17:40:56.991]                       is.null <- base::is.null
[17:40:56.991]                       muffled <- FALSE
[17:40:56.991]                       if (inherits(cond, "message")) {
[17:40:56.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.991]                         if (muffled) 
[17:40:56.991]                           invokeRestart("muffleMessage")
[17:40:56.991]                       }
[17:40:56.991]                       else if (inherits(cond, "warning")) {
[17:40:56.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.991]                         if (muffled) 
[17:40:56.991]                           invokeRestart("muffleWarning")
[17:40:56.991]                       }
[17:40:56.991]                       else if (inherits(cond, "condition")) {
[17:40:56.991]                         if (!is.null(pattern)) {
[17:40:56.991]                           computeRestarts <- base::computeRestarts
[17:40:56.991]                           grepl <- base::grepl
[17:40:56.991]                           restarts <- computeRestarts(cond)
[17:40:56.991]                           for (restart in restarts) {
[17:40:56.991]                             name <- restart$name
[17:40:56.991]                             if (is.null(name)) 
[17:40:56.991]                               next
[17:40:56.991]                             if (!grepl(pattern, name)) 
[17:40:56.991]                               next
[17:40:56.991]                             invokeRestart(restart)
[17:40:56.991]                             muffled <- TRUE
[17:40:56.991]                             break
[17:40:56.991]                           }
[17:40:56.991]                         }
[17:40:56.991]                       }
[17:40:56.991]                       invisible(muffled)
[17:40:56.991]                     }
[17:40:56.991]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.991]                   }
[17:40:56.991]                 }
[17:40:56.991]                 else {
[17:40:56.991]                   if (TRUE) {
[17:40:56.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:56.991]                     {
[17:40:56.991]                       inherits <- base::inherits
[17:40:56.991]                       invokeRestart <- base::invokeRestart
[17:40:56.991]                       is.null <- base::is.null
[17:40:56.991]                       muffled <- FALSE
[17:40:56.991]                       if (inherits(cond, "message")) {
[17:40:56.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:56.991]                         if (muffled) 
[17:40:56.991]                           invokeRestart("muffleMessage")
[17:40:56.991]                       }
[17:40:56.991]                       else if (inherits(cond, "warning")) {
[17:40:56.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:56.991]                         if (muffled) 
[17:40:56.991]                           invokeRestart("muffleWarning")
[17:40:56.991]                       }
[17:40:56.991]                       else if (inherits(cond, "condition")) {
[17:40:56.991]                         if (!is.null(pattern)) {
[17:40:56.991]                           computeRestarts <- base::computeRestarts
[17:40:56.991]                           grepl <- base::grepl
[17:40:56.991]                           restarts <- computeRestarts(cond)
[17:40:56.991]                           for (restart in restarts) {
[17:40:56.991]                             name <- restart$name
[17:40:56.991]                             if (is.null(name)) 
[17:40:56.991]                               next
[17:40:56.991]                             if (!grepl(pattern, name)) 
[17:40:56.991]                               next
[17:40:56.991]                             invokeRestart(restart)
[17:40:56.991]                             muffled <- TRUE
[17:40:56.991]                             break
[17:40:56.991]                           }
[17:40:56.991]                         }
[17:40:56.991]                       }
[17:40:56.991]                       invisible(muffled)
[17:40:56.991]                     }
[17:40:56.991]                     muffleCondition(cond, pattern = "^muffle")
[17:40:56.991]                   }
[17:40:56.991]                 }
[17:40:56.991]             }
[17:40:56.991]         }))
[17:40:56.991]     }, error = function(ex) {
[17:40:56.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:56.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:56.991]                 ...future.rng), started = ...future.startTime, 
[17:40:56.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:56.991]             version = "1.8"), class = "FutureResult")
[17:40:56.991]     }, finally = {
[17:40:56.991]         if (!identical(...future.workdir, getwd())) 
[17:40:56.991]             setwd(...future.workdir)
[17:40:56.991]         {
[17:40:56.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:56.991]                 ...future.oldOptions$nwarnings <- NULL
[17:40:56.991]             }
[17:40:56.991]             base::options(...future.oldOptions)
[17:40:56.991]             if (.Platform$OS.type == "windows") {
[17:40:56.991]                 old_names <- names(...future.oldEnvVars)
[17:40:56.991]                 envs <- base::Sys.getenv()
[17:40:56.991]                 names <- names(envs)
[17:40:56.991]                 common <- intersect(names, old_names)
[17:40:56.991]                 added <- setdiff(names, old_names)
[17:40:56.991]                 removed <- setdiff(old_names, names)
[17:40:56.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:56.991]                   envs[common]]
[17:40:56.991]                 NAMES <- toupper(changed)
[17:40:56.991]                 args <- list()
[17:40:56.991]                 for (kk in seq_along(NAMES)) {
[17:40:56.991]                   name <- changed[[kk]]
[17:40:56.991]                   NAME <- NAMES[[kk]]
[17:40:56.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.991]                     next
[17:40:56.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.991]                 }
[17:40:56.991]                 NAMES <- toupper(added)
[17:40:56.991]                 for (kk in seq_along(NAMES)) {
[17:40:56.991]                   name <- added[[kk]]
[17:40:56.991]                   NAME <- NAMES[[kk]]
[17:40:56.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.991]                     next
[17:40:56.991]                   args[[name]] <- ""
[17:40:56.991]                 }
[17:40:56.991]                 NAMES <- toupper(removed)
[17:40:56.991]                 for (kk in seq_along(NAMES)) {
[17:40:56.991]                   name <- removed[[kk]]
[17:40:56.991]                   NAME <- NAMES[[kk]]
[17:40:56.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:56.991]                     next
[17:40:56.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:56.991]                 }
[17:40:56.991]                 if (length(args) > 0) 
[17:40:56.991]                   base::do.call(base::Sys.setenv, args = args)
[17:40:56.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:56.991]             }
[17:40:56.991]             else {
[17:40:56.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:56.991]             }
[17:40:56.991]             {
[17:40:56.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:56.991]                   0L) {
[17:40:56.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:56.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:56.991]                   base::options(opts)
[17:40:56.991]                 }
[17:40:56.991]                 {
[17:40:56.991]                   {
[17:40:56.991]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:56.991]                     NULL
[17:40:56.991]                   }
[17:40:56.991]                   options(future.plan = NULL)
[17:40:56.991]                   if (is.na(NA_character_)) 
[17:40:56.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:56.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:56.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:56.991]                     .init = FALSE)
[17:40:56.991]                 }
[17:40:56.991]             }
[17:40:56.991]         }
[17:40:56.991]     })
[17:40:56.991]     if (TRUE) {
[17:40:56.991]         base::sink(type = "output", split = FALSE)
[17:40:56.991]         if (TRUE) {
[17:40:56.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:56.991]         }
[17:40:56.991]         else {
[17:40:56.991]             ...future.result["stdout"] <- base::list(NULL)
[17:40:56.991]         }
[17:40:56.991]         base::close(...future.stdout)
[17:40:56.991]         ...future.stdout <- NULL
[17:40:56.991]     }
[17:40:56.991]     ...future.result$conditions <- ...future.conditions
[17:40:56.991]     ...future.result$finished <- base::Sys.time()
[17:40:56.991]     ...future.result
[17:40:56.991] }
[17:40:56.994] MultisessionFuture started
[17:40:56.994] - Launch lazy future ... done
[17:40:56.994] run() for ‘MultisessionFuture’ ... done
[17:40:56.996] receiveMessageFromWorker() for ClusterFuture ...
[17:40:56.996] - Validating connection of MultisessionFuture
[17:40:56.996] - received message: FutureResult
[17:40:56.996] - Received FutureResult
[17:40:56.996] - Erased future from FutureRegistry
[17:40:56.996] result() for ClusterFuture ...
[17:40:56.997] - result already collected: FutureResult
[17:40:56.997] result() for ClusterFuture ... done
[17:40:56.997] signalConditions() ...
[17:40:56.997]  - include = ‘immediateCondition’
[17:40:56.997]  - exclude = 
[17:40:56.997]  - resignal = FALSE
[17:40:56.997]  - Number of conditions: 1
[17:40:56.997] signalConditions() ... done
[17:40:56.997] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:56.997] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[17:40:56.997] getGlobalsAndPackages() ...
[17:40:56.998] Searching for globals...
[17:40:56.999] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:56.999] Searching for globals ... DONE
[17:40:56.999] Resolving globals: FALSE
[17:40:56.999] 
[17:40:56.999] 
[17:40:56.999] getGlobalsAndPackages() ... DONE
[17:40:56.999] run() for ‘Future’ ...
[17:40:57.000] - state: ‘created’
[17:40:57.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:57.013] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:57.014]   - Field: ‘node’
[17:40:57.014]   - Field: ‘label’
[17:40:57.014]   - Field: ‘local’
[17:40:57.014]   - Field: ‘owner’
[17:40:57.014]   - Field: ‘envir’
[17:40:57.014]   - Field: ‘workers’
[17:40:57.014]   - Field: ‘packages’
[17:40:57.014]   - Field: ‘gc’
[17:40:57.014]   - Field: ‘conditions’
[17:40:57.015]   - Field: ‘persistent’
[17:40:57.015]   - Field: ‘expr’
[17:40:57.015]   - Field: ‘uuid’
[17:40:57.015]   - Field: ‘seed’
[17:40:57.015]   - Field: ‘version’
[17:40:57.015]   - Field: ‘result’
[17:40:57.015]   - Field: ‘asynchronous’
[17:40:57.015]   - Field: ‘calls’
[17:40:57.015]   - Field: ‘globals’
[17:40:57.015]   - Field: ‘stdout’
[17:40:57.015]   - Field: ‘earlySignal’
[17:40:57.016]   - Field: ‘lazy’
[17:40:57.016]   - Field: ‘state’
[17:40:57.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:57.016] - Launch lazy future ...
[17:40:57.016] Packages needed by the future expression (n = 0): <none>
[17:40:57.016] Packages needed by future strategies (n = 0): <none>
[17:40:57.017] {
[17:40:57.017]     {
[17:40:57.017]         {
[17:40:57.017]             ...future.startTime <- base::Sys.time()
[17:40:57.017]             {
[17:40:57.017]                 {
[17:40:57.017]                   {
[17:40:57.017]                     {
[17:40:57.017]                       base::local({
[17:40:57.017]                         has_future <- base::requireNamespace("future", 
[17:40:57.017]                           quietly = TRUE)
[17:40:57.017]                         if (has_future) {
[17:40:57.017]                           ns <- base::getNamespace("future")
[17:40:57.017]                           version <- ns[[".package"]][["version"]]
[17:40:57.017]                           if (is.null(version)) 
[17:40:57.017]                             version <- utils::packageVersion("future")
[17:40:57.017]                         }
[17:40:57.017]                         else {
[17:40:57.017]                           version <- NULL
[17:40:57.017]                         }
[17:40:57.017]                         if (!has_future || version < "1.8.0") {
[17:40:57.017]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.017]                             "", base::R.version$version.string), 
[17:40:57.017]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:57.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:57.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.017]                               "release", "version")], collapse = " "), 
[17:40:57.017]                             hostname = base::Sys.info()[["nodename"]])
[17:40:57.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.017]                             info)
[17:40:57.017]                           info <- base::paste(info, collapse = "; ")
[17:40:57.017]                           if (!has_future) {
[17:40:57.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.017]                               info)
[17:40:57.017]                           }
[17:40:57.017]                           else {
[17:40:57.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.017]                               info, version)
[17:40:57.017]                           }
[17:40:57.017]                           base::stop(msg)
[17:40:57.017]                         }
[17:40:57.017]                       })
[17:40:57.017]                     }
[17:40:57.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.017]                     base::options(mc.cores = 1L)
[17:40:57.017]                   }
[17:40:57.017]                   ...future.strategy.old <- future::plan("list")
[17:40:57.017]                   options(future.plan = NULL)
[17:40:57.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.017]                 }
[17:40:57.017]                 ...future.workdir <- getwd()
[17:40:57.017]             }
[17:40:57.017]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.017]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.017]         }
[17:40:57.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:57.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.017]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.017]             base::names(...future.oldOptions))
[17:40:57.017]     }
[17:40:57.017]     if (FALSE) {
[17:40:57.017]     }
[17:40:57.017]     else {
[17:40:57.017]         if (TRUE) {
[17:40:57.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.017]                 open = "w")
[17:40:57.017]         }
[17:40:57.017]         else {
[17:40:57.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.017]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.017]         }
[17:40:57.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.017]             base::sink(type = "output", split = FALSE)
[17:40:57.017]             base::close(...future.stdout)
[17:40:57.017]         }, add = TRUE)
[17:40:57.017]     }
[17:40:57.017]     ...future.frame <- base::sys.nframe()
[17:40:57.017]     ...future.conditions <- base::list()
[17:40:57.017]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.017]     if (FALSE) {
[17:40:57.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.017]     }
[17:40:57.017]     ...future.result <- base::tryCatch({
[17:40:57.017]         base::withCallingHandlers({
[17:40:57.017]             ...future.value <- base::withVisible(base::local({
[17:40:57.017]                 ...future.makeSendCondition <- base::local({
[17:40:57.017]                   sendCondition <- NULL
[17:40:57.017]                   function(frame = 1L) {
[17:40:57.017]                     if (is.function(sendCondition)) 
[17:40:57.017]                       return(sendCondition)
[17:40:57.017]                     ns <- getNamespace("parallel")
[17:40:57.017]                     if (exists("sendData", mode = "function", 
[17:40:57.017]                       envir = ns)) {
[17:40:57.017]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.017]                         envir = ns)
[17:40:57.017]                       envir <- sys.frame(frame)
[17:40:57.017]                       master <- NULL
[17:40:57.017]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.017]                         !identical(envir, emptyenv())) {
[17:40:57.017]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.017]                           inherits = FALSE)) {
[17:40:57.017]                           master <- get("master", mode = "list", 
[17:40:57.017]                             envir = envir, inherits = FALSE)
[17:40:57.017]                           if (inherits(master, c("SOCKnode", 
[17:40:57.017]                             "SOCK0node"))) {
[17:40:57.017]                             sendCondition <<- function(cond) {
[17:40:57.017]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.017]                                 success = TRUE)
[17:40:57.017]                               parallel_sendData(master, data)
[17:40:57.017]                             }
[17:40:57.017]                             return(sendCondition)
[17:40:57.017]                           }
[17:40:57.017]                         }
[17:40:57.017]                         frame <- frame + 1L
[17:40:57.017]                         envir <- sys.frame(frame)
[17:40:57.017]                       }
[17:40:57.017]                     }
[17:40:57.017]                     sendCondition <<- function(cond) NULL
[17:40:57.017]                   }
[17:40:57.017]                 })
[17:40:57.017]                 withCallingHandlers({
[17:40:57.017]                   {
[17:40:57.017]                     Sys.sleep(0.5)
[17:40:57.017]                     list(a = 1, b = 42L)
[17:40:57.017]                   }
[17:40:57.017]                 }, immediateCondition = function(cond) {
[17:40:57.017]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.017]                   sendCondition(cond)
[17:40:57.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.017]                   {
[17:40:57.017]                     inherits <- base::inherits
[17:40:57.017]                     invokeRestart <- base::invokeRestart
[17:40:57.017]                     is.null <- base::is.null
[17:40:57.017]                     muffled <- FALSE
[17:40:57.017]                     if (inherits(cond, "message")) {
[17:40:57.017]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.017]                       if (muffled) 
[17:40:57.017]                         invokeRestart("muffleMessage")
[17:40:57.017]                     }
[17:40:57.017]                     else if (inherits(cond, "warning")) {
[17:40:57.017]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.017]                       if (muffled) 
[17:40:57.017]                         invokeRestart("muffleWarning")
[17:40:57.017]                     }
[17:40:57.017]                     else if (inherits(cond, "condition")) {
[17:40:57.017]                       if (!is.null(pattern)) {
[17:40:57.017]                         computeRestarts <- base::computeRestarts
[17:40:57.017]                         grepl <- base::grepl
[17:40:57.017]                         restarts <- computeRestarts(cond)
[17:40:57.017]                         for (restart in restarts) {
[17:40:57.017]                           name <- restart$name
[17:40:57.017]                           if (is.null(name)) 
[17:40:57.017]                             next
[17:40:57.017]                           if (!grepl(pattern, name)) 
[17:40:57.017]                             next
[17:40:57.017]                           invokeRestart(restart)
[17:40:57.017]                           muffled <- TRUE
[17:40:57.017]                           break
[17:40:57.017]                         }
[17:40:57.017]                       }
[17:40:57.017]                     }
[17:40:57.017]                     invisible(muffled)
[17:40:57.017]                   }
[17:40:57.017]                   muffleCondition(cond)
[17:40:57.017]                 })
[17:40:57.017]             }))
[17:40:57.017]             future::FutureResult(value = ...future.value$value, 
[17:40:57.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.017]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.017]                     ...future.globalenv.names))
[17:40:57.017]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.017]         }, condition = base::local({
[17:40:57.017]             c <- base::c
[17:40:57.017]             inherits <- base::inherits
[17:40:57.017]             invokeRestart <- base::invokeRestart
[17:40:57.017]             length <- base::length
[17:40:57.017]             list <- base::list
[17:40:57.017]             seq.int <- base::seq.int
[17:40:57.017]             signalCondition <- base::signalCondition
[17:40:57.017]             sys.calls <- base::sys.calls
[17:40:57.017]             `[[` <- base::`[[`
[17:40:57.017]             `+` <- base::`+`
[17:40:57.017]             `<<-` <- base::`<<-`
[17:40:57.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.017]                   3L)]
[17:40:57.017]             }
[17:40:57.017]             function(cond) {
[17:40:57.017]                 is_error <- inherits(cond, "error")
[17:40:57.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.017]                   NULL)
[17:40:57.017]                 if (is_error) {
[17:40:57.017]                   sessionInformation <- function() {
[17:40:57.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.017]                       search = base::search(), system = base::Sys.info())
[17:40:57.017]                   }
[17:40:57.017]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.017]                     cond$call), session = sessionInformation(), 
[17:40:57.017]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.017]                   signalCondition(cond)
[17:40:57.017]                 }
[17:40:57.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.017]                 "immediateCondition"))) {
[17:40:57.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.017]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.017]                   if (TRUE && !signal) {
[17:40:57.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.017]                     {
[17:40:57.017]                       inherits <- base::inherits
[17:40:57.017]                       invokeRestart <- base::invokeRestart
[17:40:57.017]                       is.null <- base::is.null
[17:40:57.017]                       muffled <- FALSE
[17:40:57.017]                       if (inherits(cond, "message")) {
[17:40:57.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.017]                         if (muffled) 
[17:40:57.017]                           invokeRestart("muffleMessage")
[17:40:57.017]                       }
[17:40:57.017]                       else if (inherits(cond, "warning")) {
[17:40:57.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.017]                         if (muffled) 
[17:40:57.017]                           invokeRestart("muffleWarning")
[17:40:57.017]                       }
[17:40:57.017]                       else if (inherits(cond, "condition")) {
[17:40:57.017]                         if (!is.null(pattern)) {
[17:40:57.017]                           computeRestarts <- base::computeRestarts
[17:40:57.017]                           grepl <- base::grepl
[17:40:57.017]                           restarts <- computeRestarts(cond)
[17:40:57.017]                           for (restart in restarts) {
[17:40:57.017]                             name <- restart$name
[17:40:57.017]                             if (is.null(name)) 
[17:40:57.017]                               next
[17:40:57.017]                             if (!grepl(pattern, name)) 
[17:40:57.017]                               next
[17:40:57.017]                             invokeRestart(restart)
[17:40:57.017]                             muffled <- TRUE
[17:40:57.017]                             break
[17:40:57.017]                           }
[17:40:57.017]                         }
[17:40:57.017]                       }
[17:40:57.017]                       invisible(muffled)
[17:40:57.017]                     }
[17:40:57.017]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.017]                   }
[17:40:57.017]                 }
[17:40:57.017]                 else {
[17:40:57.017]                   if (TRUE) {
[17:40:57.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.017]                     {
[17:40:57.017]                       inherits <- base::inherits
[17:40:57.017]                       invokeRestart <- base::invokeRestart
[17:40:57.017]                       is.null <- base::is.null
[17:40:57.017]                       muffled <- FALSE
[17:40:57.017]                       if (inherits(cond, "message")) {
[17:40:57.017]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.017]                         if (muffled) 
[17:40:57.017]                           invokeRestart("muffleMessage")
[17:40:57.017]                       }
[17:40:57.017]                       else if (inherits(cond, "warning")) {
[17:40:57.017]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.017]                         if (muffled) 
[17:40:57.017]                           invokeRestart("muffleWarning")
[17:40:57.017]                       }
[17:40:57.017]                       else if (inherits(cond, "condition")) {
[17:40:57.017]                         if (!is.null(pattern)) {
[17:40:57.017]                           computeRestarts <- base::computeRestarts
[17:40:57.017]                           grepl <- base::grepl
[17:40:57.017]                           restarts <- computeRestarts(cond)
[17:40:57.017]                           for (restart in restarts) {
[17:40:57.017]                             name <- restart$name
[17:40:57.017]                             if (is.null(name)) 
[17:40:57.017]                               next
[17:40:57.017]                             if (!grepl(pattern, name)) 
[17:40:57.017]                               next
[17:40:57.017]                             invokeRestart(restart)
[17:40:57.017]                             muffled <- TRUE
[17:40:57.017]                             break
[17:40:57.017]                           }
[17:40:57.017]                         }
[17:40:57.017]                       }
[17:40:57.017]                       invisible(muffled)
[17:40:57.017]                     }
[17:40:57.017]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.017]                   }
[17:40:57.017]                 }
[17:40:57.017]             }
[17:40:57.017]         }))
[17:40:57.017]     }, error = function(ex) {
[17:40:57.017]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.017]                 ...future.rng), started = ...future.startTime, 
[17:40:57.017]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.017]             version = "1.8"), class = "FutureResult")
[17:40:57.017]     }, finally = {
[17:40:57.017]         if (!identical(...future.workdir, getwd())) 
[17:40:57.017]             setwd(...future.workdir)
[17:40:57.017]         {
[17:40:57.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.017]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.017]             }
[17:40:57.017]             base::options(...future.oldOptions)
[17:40:57.017]             if (.Platform$OS.type == "windows") {
[17:40:57.017]                 old_names <- names(...future.oldEnvVars)
[17:40:57.017]                 envs <- base::Sys.getenv()
[17:40:57.017]                 names <- names(envs)
[17:40:57.017]                 common <- intersect(names, old_names)
[17:40:57.017]                 added <- setdiff(names, old_names)
[17:40:57.017]                 removed <- setdiff(old_names, names)
[17:40:57.017]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.017]                   envs[common]]
[17:40:57.017]                 NAMES <- toupper(changed)
[17:40:57.017]                 args <- list()
[17:40:57.017]                 for (kk in seq_along(NAMES)) {
[17:40:57.017]                   name <- changed[[kk]]
[17:40:57.017]                   NAME <- NAMES[[kk]]
[17:40:57.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.017]                     next
[17:40:57.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.017]                 }
[17:40:57.017]                 NAMES <- toupper(added)
[17:40:57.017]                 for (kk in seq_along(NAMES)) {
[17:40:57.017]                   name <- added[[kk]]
[17:40:57.017]                   NAME <- NAMES[[kk]]
[17:40:57.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.017]                     next
[17:40:57.017]                   args[[name]] <- ""
[17:40:57.017]                 }
[17:40:57.017]                 NAMES <- toupper(removed)
[17:40:57.017]                 for (kk in seq_along(NAMES)) {
[17:40:57.017]                   name <- removed[[kk]]
[17:40:57.017]                   NAME <- NAMES[[kk]]
[17:40:57.017]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.017]                     next
[17:40:57.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.017]                 }
[17:40:57.017]                 if (length(args) > 0) 
[17:40:57.017]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.017]             }
[17:40:57.017]             else {
[17:40:57.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.017]             }
[17:40:57.017]             {
[17:40:57.017]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.017]                   0L) {
[17:40:57.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.017]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.017]                   base::options(opts)
[17:40:57.017]                 }
[17:40:57.017]                 {
[17:40:57.017]                   {
[17:40:57.017]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.017]                     NULL
[17:40:57.017]                   }
[17:40:57.017]                   options(future.plan = NULL)
[17:40:57.017]                   if (is.na(NA_character_)) 
[17:40:57.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:57.017]                     .init = FALSE)
[17:40:57.017]                 }
[17:40:57.017]             }
[17:40:57.017]         }
[17:40:57.017]     })
[17:40:57.017]     if (TRUE) {
[17:40:57.017]         base::sink(type = "output", split = FALSE)
[17:40:57.017]         if (TRUE) {
[17:40:57.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.017]         }
[17:40:57.017]         else {
[17:40:57.017]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.017]         }
[17:40:57.017]         base::close(...future.stdout)
[17:40:57.017]         ...future.stdout <- NULL
[17:40:57.017]     }
[17:40:57.017]     ...future.result$conditions <- ...future.conditions
[17:40:57.017]     ...future.result$finished <- base::Sys.time()
[17:40:57.017]     ...future.result
[17:40:57.017] }
[17:40:57.019] MultisessionFuture started
[17:40:57.019] - Launch lazy future ... done
[17:40:57.019] run() for ‘MultisessionFuture’ ... done
[17:40:57.522] receiveMessageFromWorker() for ClusterFuture ...
[17:40:57.522] - Validating connection of MultisessionFuture
[17:40:57.522] - received message: FutureResult
[17:40:57.522] - Received FutureResult
[17:40:57.522] - Erased future from FutureRegistry
[17:40:57.523] result() for ClusterFuture ...
[17:40:57.523] - result already collected: FutureResult
[17:40:57.523] result() for ClusterFuture ... done
[17:40:57.523] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:57.523] resolve() on list ...
[17:40:57.523]  recursive: 1
[17:40:57.523]  length: 2
[17:40:57.523]  elements: ‘a’, ‘b’
[17:40:57.523]  length: 1 (resolved future 1)
[17:40:57.523]  length: 0 (resolved future 2)
[17:40:57.524] resolve() on list ... DONE
[17:40:57.524] A MultisessionFuture was resolved (and resolved itself)
[17:40:57.524] getGlobalsAndPackages() ...
[17:40:57.524] Searching for globals...
[17:40:57.525] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:57.525] Searching for globals ... DONE
[17:40:57.525] Resolving globals: FALSE
[17:40:57.526] 
[17:40:57.526] 
[17:40:57.526] getGlobalsAndPackages() ... DONE
[17:40:57.526] run() for ‘Future’ ...
[17:40:57.526] - state: ‘created’
[17:40:57.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:57.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:57.541] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:57.541]   - Field: ‘node’
[17:40:57.541]   - Field: ‘label’
[17:40:57.541]   - Field: ‘local’
[17:40:57.541]   - Field: ‘owner’
[17:40:57.541]   - Field: ‘envir’
[17:40:57.541]   - Field: ‘workers’
[17:40:57.541]   - Field: ‘packages’
[17:40:57.541]   - Field: ‘gc’
[17:40:57.541]   - Field: ‘conditions’
[17:40:57.542]   - Field: ‘persistent’
[17:40:57.542]   - Field: ‘expr’
[17:40:57.542]   - Field: ‘uuid’
[17:40:57.542]   - Field: ‘seed’
[17:40:57.542]   - Field: ‘version’
[17:40:57.542]   - Field: ‘result’
[17:40:57.542]   - Field: ‘asynchronous’
[17:40:57.542]   - Field: ‘calls’
[17:40:57.542]   - Field: ‘globals’
[17:40:57.542]   - Field: ‘stdout’
[17:40:57.542]   - Field: ‘earlySignal’
[17:40:57.543]   - Field: ‘lazy’
[17:40:57.543]   - Field: ‘state’
[17:40:57.543] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:57.543] - Launch lazy future ...
[17:40:57.543] Packages needed by the future expression (n = 0): <none>
[17:40:57.543] Packages needed by future strategies (n = 0): <none>
[17:40:57.544] {
[17:40:57.544]     {
[17:40:57.544]         {
[17:40:57.544]             ...future.startTime <- base::Sys.time()
[17:40:57.544]             {
[17:40:57.544]                 {
[17:40:57.544]                   {
[17:40:57.544]                     {
[17:40:57.544]                       base::local({
[17:40:57.544]                         has_future <- base::requireNamespace("future", 
[17:40:57.544]                           quietly = TRUE)
[17:40:57.544]                         if (has_future) {
[17:40:57.544]                           ns <- base::getNamespace("future")
[17:40:57.544]                           version <- ns[[".package"]][["version"]]
[17:40:57.544]                           if (is.null(version)) 
[17:40:57.544]                             version <- utils::packageVersion("future")
[17:40:57.544]                         }
[17:40:57.544]                         else {
[17:40:57.544]                           version <- NULL
[17:40:57.544]                         }
[17:40:57.544]                         if (!has_future || version < "1.8.0") {
[17:40:57.544]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:57.544]                             "", base::R.version$version.string), 
[17:40:57.544]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:57.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:57.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:57.544]                               "release", "version")], collapse = " "), 
[17:40:57.544]                             hostname = base::Sys.info()[["nodename"]])
[17:40:57.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:57.544]                             info)
[17:40:57.544]                           info <- base::paste(info, collapse = "; ")
[17:40:57.544]                           if (!has_future) {
[17:40:57.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:57.544]                               info)
[17:40:57.544]                           }
[17:40:57.544]                           else {
[17:40:57.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:57.544]                               info, version)
[17:40:57.544]                           }
[17:40:57.544]                           base::stop(msg)
[17:40:57.544]                         }
[17:40:57.544]                       })
[17:40:57.544]                     }
[17:40:57.544]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:57.544]                     base::options(mc.cores = 1L)
[17:40:57.544]                   }
[17:40:57.544]                   ...future.strategy.old <- future::plan("list")
[17:40:57.544]                   options(future.plan = NULL)
[17:40:57.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.544]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:57.544]                 }
[17:40:57.544]                 ...future.workdir <- getwd()
[17:40:57.544]             }
[17:40:57.544]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:57.544]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:57.544]         }
[17:40:57.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:57.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:57.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:57.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:57.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:57.544]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:57.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:57.544]             base::names(...future.oldOptions))
[17:40:57.544]     }
[17:40:57.544]     if (FALSE) {
[17:40:57.544]     }
[17:40:57.544]     else {
[17:40:57.544]         if (TRUE) {
[17:40:57.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:57.544]                 open = "w")
[17:40:57.544]         }
[17:40:57.544]         else {
[17:40:57.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:57.544]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:57.544]         }
[17:40:57.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:57.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:57.544]             base::sink(type = "output", split = FALSE)
[17:40:57.544]             base::close(...future.stdout)
[17:40:57.544]         }, add = TRUE)
[17:40:57.544]     }
[17:40:57.544]     ...future.frame <- base::sys.nframe()
[17:40:57.544]     ...future.conditions <- base::list()
[17:40:57.544]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:57.544]     if (FALSE) {
[17:40:57.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:57.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:57.544]     }
[17:40:57.544]     ...future.result <- base::tryCatch({
[17:40:57.544]         base::withCallingHandlers({
[17:40:57.544]             ...future.value <- base::withVisible(base::local({
[17:40:57.544]                 ...future.makeSendCondition <- base::local({
[17:40:57.544]                   sendCondition <- NULL
[17:40:57.544]                   function(frame = 1L) {
[17:40:57.544]                     if (is.function(sendCondition)) 
[17:40:57.544]                       return(sendCondition)
[17:40:57.544]                     ns <- getNamespace("parallel")
[17:40:57.544]                     if (exists("sendData", mode = "function", 
[17:40:57.544]                       envir = ns)) {
[17:40:57.544]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:57.544]                         envir = ns)
[17:40:57.544]                       envir <- sys.frame(frame)
[17:40:57.544]                       master <- NULL
[17:40:57.544]                       while (!identical(envir, .GlobalEnv) && 
[17:40:57.544]                         !identical(envir, emptyenv())) {
[17:40:57.544]                         if (exists("master", mode = "list", envir = envir, 
[17:40:57.544]                           inherits = FALSE)) {
[17:40:57.544]                           master <- get("master", mode = "list", 
[17:40:57.544]                             envir = envir, inherits = FALSE)
[17:40:57.544]                           if (inherits(master, c("SOCKnode", 
[17:40:57.544]                             "SOCK0node"))) {
[17:40:57.544]                             sendCondition <<- function(cond) {
[17:40:57.544]                               data <- list(type = "VALUE", value = cond, 
[17:40:57.544]                                 success = TRUE)
[17:40:57.544]                               parallel_sendData(master, data)
[17:40:57.544]                             }
[17:40:57.544]                             return(sendCondition)
[17:40:57.544]                           }
[17:40:57.544]                         }
[17:40:57.544]                         frame <- frame + 1L
[17:40:57.544]                         envir <- sys.frame(frame)
[17:40:57.544]                       }
[17:40:57.544]                     }
[17:40:57.544]                     sendCondition <<- function(cond) NULL
[17:40:57.544]                   }
[17:40:57.544]                 })
[17:40:57.544]                 withCallingHandlers({
[17:40:57.544]                   {
[17:40:57.544]                     Sys.sleep(0.5)
[17:40:57.544]                     list(a = 1, b = 42L)
[17:40:57.544]                   }
[17:40:57.544]                 }, immediateCondition = function(cond) {
[17:40:57.544]                   sendCondition <- ...future.makeSendCondition()
[17:40:57.544]                   sendCondition(cond)
[17:40:57.544]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.544]                   {
[17:40:57.544]                     inherits <- base::inherits
[17:40:57.544]                     invokeRestart <- base::invokeRestart
[17:40:57.544]                     is.null <- base::is.null
[17:40:57.544]                     muffled <- FALSE
[17:40:57.544]                     if (inherits(cond, "message")) {
[17:40:57.544]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:57.544]                       if (muffled) 
[17:40:57.544]                         invokeRestart("muffleMessage")
[17:40:57.544]                     }
[17:40:57.544]                     else if (inherits(cond, "warning")) {
[17:40:57.544]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:57.544]                       if (muffled) 
[17:40:57.544]                         invokeRestart("muffleWarning")
[17:40:57.544]                     }
[17:40:57.544]                     else if (inherits(cond, "condition")) {
[17:40:57.544]                       if (!is.null(pattern)) {
[17:40:57.544]                         computeRestarts <- base::computeRestarts
[17:40:57.544]                         grepl <- base::grepl
[17:40:57.544]                         restarts <- computeRestarts(cond)
[17:40:57.544]                         for (restart in restarts) {
[17:40:57.544]                           name <- restart$name
[17:40:57.544]                           if (is.null(name)) 
[17:40:57.544]                             next
[17:40:57.544]                           if (!grepl(pattern, name)) 
[17:40:57.544]                             next
[17:40:57.544]                           invokeRestart(restart)
[17:40:57.544]                           muffled <- TRUE
[17:40:57.544]                           break
[17:40:57.544]                         }
[17:40:57.544]                       }
[17:40:57.544]                     }
[17:40:57.544]                     invisible(muffled)
[17:40:57.544]                   }
[17:40:57.544]                   muffleCondition(cond)
[17:40:57.544]                 })
[17:40:57.544]             }))
[17:40:57.544]             future::FutureResult(value = ...future.value$value, 
[17:40:57.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.544]                   ...future.rng), globalenv = if (FALSE) 
[17:40:57.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:57.544]                     ...future.globalenv.names))
[17:40:57.544]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:57.544]         }, condition = base::local({
[17:40:57.544]             c <- base::c
[17:40:57.544]             inherits <- base::inherits
[17:40:57.544]             invokeRestart <- base::invokeRestart
[17:40:57.544]             length <- base::length
[17:40:57.544]             list <- base::list
[17:40:57.544]             seq.int <- base::seq.int
[17:40:57.544]             signalCondition <- base::signalCondition
[17:40:57.544]             sys.calls <- base::sys.calls
[17:40:57.544]             `[[` <- base::`[[`
[17:40:57.544]             `+` <- base::`+`
[17:40:57.544]             `<<-` <- base::`<<-`
[17:40:57.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:57.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:57.544]                   3L)]
[17:40:57.544]             }
[17:40:57.544]             function(cond) {
[17:40:57.544]                 is_error <- inherits(cond, "error")
[17:40:57.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:57.544]                   NULL)
[17:40:57.544]                 if (is_error) {
[17:40:57.544]                   sessionInformation <- function() {
[17:40:57.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:57.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:57.544]                       search = base::search(), system = base::Sys.info())
[17:40:57.544]                   }
[17:40:57.544]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:57.544]                     cond$call), session = sessionInformation(), 
[17:40:57.544]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:57.544]                   signalCondition(cond)
[17:40:57.544]                 }
[17:40:57.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:57.544]                 "immediateCondition"))) {
[17:40:57.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:57.544]                   ...future.conditions[[length(...future.conditions) + 
[17:40:57.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:57.544]                   if (TRUE && !signal) {
[17:40:57.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.544]                     {
[17:40:57.544]                       inherits <- base::inherits
[17:40:57.544]                       invokeRestart <- base::invokeRestart
[17:40:57.544]                       is.null <- base::is.null
[17:40:57.544]                       muffled <- FALSE
[17:40:57.544]                       if (inherits(cond, "message")) {
[17:40:57.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.544]                         if (muffled) 
[17:40:57.544]                           invokeRestart("muffleMessage")
[17:40:57.544]                       }
[17:40:57.544]                       else if (inherits(cond, "warning")) {
[17:40:57.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.544]                         if (muffled) 
[17:40:57.544]                           invokeRestart("muffleWarning")
[17:40:57.544]                       }
[17:40:57.544]                       else if (inherits(cond, "condition")) {
[17:40:57.544]                         if (!is.null(pattern)) {
[17:40:57.544]                           computeRestarts <- base::computeRestarts
[17:40:57.544]                           grepl <- base::grepl
[17:40:57.544]                           restarts <- computeRestarts(cond)
[17:40:57.544]                           for (restart in restarts) {
[17:40:57.544]                             name <- restart$name
[17:40:57.544]                             if (is.null(name)) 
[17:40:57.544]                               next
[17:40:57.544]                             if (!grepl(pattern, name)) 
[17:40:57.544]                               next
[17:40:57.544]                             invokeRestart(restart)
[17:40:57.544]                             muffled <- TRUE
[17:40:57.544]                             break
[17:40:57.544]                           }
[17:40:57.544]                         }
[17:40:57.544]                       }
[17:40:57.544]                       invisible(muffled)
[17:40:57.544]                     }
[17:40:57.544]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.544]                   }
[17:40:57.544]                 }
[17:40:57.544]                 else {
[17:40:57.544]                   if (TRUE) {
[17:40:57.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:57.544]                     {
[17:40:57.544]                       inherits <- base::inherits
[17:40:57.544]                       invokeRestart <- base::invokeRestart
[17:40:57.544]                       is.null <- base::is.null
[17:40:57.544]                       muffled <- FALSE
[17:40:57.544]                       if (inherits(cond, "message")) {
[17:40:57.544]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:57.544]                         if (muffled) 
[17:40:57.544]                           invokeRestart("muffleMessage")
[17:40:57.544]                       }
[17:40:57.544]                       else if (inherits(cond, "warning")) {
[17:40:57.544]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:57.544]                         if (muffled) 
[17:40:57.544]                           invokeRestart("muffleWarning")
[17:40:57.544]                       }
[17:40:57.544]                       else if (inherits(cond, "condition")) {
[17:40:57.544]                         if (!is.null(pattern)) {
[17:40:57.544]                           computeRestarts <- base::computeRestarts
[17:40:57.544]                           grepl <- base::grepl
[17:40:57.544]                           restarts <- computeRestarts(cond)
[17:40:57.544]                           for (restart in restarts) {
[17:40:57.544]                             name <- restart$name
[17:40:57.544]                             if (is.null(name)) 
[17:40:57.544]                               next
[17:40:57.544]                             if (!grepl(pattern, name)) 
[17:40:57.544]                               next
[17:40:57.544]                             invokeRestart(restart)
[17:40:57.544]                             muffled <- TRUE
[17:40:57.544]                             break
[17:40:57.544]                           }
[17:40:57.544]                         }
[17:40:57.544]                       }
[17:40:57.544]                       invisible(muffled)
[17:40:57.544]                     }
[17:40:57.544]                     muffleCondition(cond, pattern = "^muffle")
[17:40:57.544]                   }
[17:40:57.544]                 }
[17:40:57.544]             }
[17:40:57.544]         }))
[17:40:57.544]     }, error = function(ex) {
[17:40:57.544]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:57.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:57.544]                 ...future.rng), started = ...future.startTime, 
[17:40:57.544]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:57.544]             version = "1.8"), class = "FutureResult")
[17:40:57.544]     }, finally = {
[17:40:57.544]         if (!identical(...future.workdir, getwd())) 
[17:40:57.544]             setwd(...future.workdir)
[17:40:57.544]         {
[17:40:57.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:57.544]                 ...future.oldOptions$nwarnings <- NULL
[17:40:57.544]             }
[17:40:57.544]             base::options(...future.oldOptions)
[17:40:57.544]             if (.Platform$OS.type == "windows") {
[17:40:57.544]                 old_names <- names(...future.oldEnvVars)
[17:40:57.544]                 envs <- base::Sys.getenv()
[17:40:57.544]                 names <- names(envs)
[17:40:57.544]                 common <- intersect(names, old_names)
[17:40:57.544]                 added <- setdiff(names, old_names)
[17:40:57.544]                 removed <- setdiff(old_names, names)
[17:40:57.544]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:57.544]                   envs[common]]
[17:40:57.544]                 NAMES <- toupper(changed)
[17:40:57.544]                 args <- list()
[17:40:57.544]                 for (kk in seq_along(NAMES)) {
[17:40:57.544]                   name <- changed[[kk]]
[17:40:57.544]                   NAME <- NAMES[[kk]]
[17:40:57.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.544]                     next
[17:40:57.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.544]                 }
[17:40:57.544]                 NAMES <- toupper(added)
[17:40:57.544]                 for (kk in seq_along(NAMES)) {
[17:40:57.544]                   name <- added[[kk]]
[17:40:57.544]                   NAME <- NAMES[[kk]]
[17:40:57.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.544]                     next
[17:40:57.544]                   args[[name]] <- ""
[17:40:57.544]                 }
[17:40:57.544]                 NAMES <- toupper(removed)
[17:40:57.544]                 for (kk in seq_along(NAMES)) {
[17:40:57.544]                   name <- removed[[kk]]
[17:40:57.544]                   NAME <- NAMES[[kk]]
[17:40:57.544]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:57.544]                     next
[17:40:57.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:57.544]                 }
[17:40:57.544]                 if (length(args) > 0) 
[17:40:57.544]                   base::do.call(base::Sys.setenv, args = args)
[17:40:57.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:57.544]             }
[17:40:57.544]             else {
[17:40:57.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:57.544]             }
[17:40:57.544]             {
[17:40:57.544]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:57.544]                   0L) {
[17:40:57.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:57.544]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:57.544]                   base::options(opts)
[17:40:57.544]                 }
[17:40:57.544]                 {
[17:40:57.544]                   {
[17:40:57.544]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:57.544]                     NULL
[17:40:57.544]                   }
[17:40:57.544]                   options(future.plan = NULL)
[17:40:57.544]                   if (is.na(NA_character_)) 
[17:40:57.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:57.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:57.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:57.544]                     .init = FALSE)
[17:40:57.544]                 }
[17:40:57.544]             }
[17:40:57.544]         }
[17:40:57.544]     })
[17:40:57.544]     if (TRUE) {
[17:40:57.544]         base::sink(type = "output", split = FALSE)
[17:40:57.544]         if (TRUE) {
[17:40:57.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:57.544]         }
[17:40:57.544]         else {
[17:40:57.544]             ...future.result["stdout"] <- base::list(NULL)
[17:40:57.544]         }
[17:40:57.544]         base::close(...future.stdout)
[17:40:57.544]         ...future.stdout <- NULL
[17:40:57.544]     }
[17:40:57.544]     ...future.result$conditions <- ...future.conditions
[17:40:57.544]     ...future.result$finished <- base::Sys.time()
[17:40:57.544]     ...future.result
[17:40:57.544] }
[17:40:57.547] MultisessionFuture started
[17:40:57.547] - Launch lazy future ... done
[17:40:57.547] run() for ‘MultisessionFuture’ ... done
[17:40:58.049] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.049] - Validating connection of MultisessionFuture
[17:40:58.050] - received message: FutureResult
[17:40:58.050] - Received FutureResult
[17:40:58.050] - Erased future from FutureRegistry
[17:40:58.050] result() for ClusterFuture ...
[17:40:58.050] - result already collected: FutureResult
[17:40:58.050] result() for ClusterFuture ... done
[17:40:58.050] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.050] resolve() on list ...
[17:40:58.050]  recursive: 1
[17:40:58.051]  length: 2
[17:40:58.051]  elements: ‘a’, ‘b’
[17:40:58.051]  length: 1 (resolved future 1)
[17:40:58.051]  length: 0 (resolved future 2)
[17:40:58.051] resolve() on list ... DONE
[17:40:58.051] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:40:58.051] getGlobalsAndPackages() ...
[17:40:58.051] Searching for globals...
[17:40:58.052] - globals found: [2] ‘list’, ‘stop’
[17:40:58.052] Searching for globals ... DONE
[17:40:58.052] Resolving globals: FALSE
[17:40:58.053] 
[17:40:58.053] 
[17:40:58.053] getGlobalsAndPackages() ... DONE
[17:40:58.053] run() for ‘Future’ ...
[17:40:58.053] - state: ‘created’
[17:40:58.053] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.068]   - Field: ‘node’
[17:40:58.069]   - Field: ‘label’
[17:40:58.069]   - Field: ‘local’
[17:40:58.069]   - Field: ‘owner’
[17:40:58.069]   - Field: ‘envir’
[17:40:58.069]   - Field: ‘workers’
[17:40:58.069]   - Field: ‘packages’
[17:40:58.069]   - Field: ‘gc’
[17:40:58.069]   - Field: ‘conditions’
[17:40:58.069]   - Field: ‘persistent’
[17:40:58.069]   - Field: ‘expr’
[17:40:58.069]   - Field: ‘uuid’
[17:40:58.069]   - Field: ‘seed’
[17:40:58.070]   - Field: ‘version’
[17:40:58.070]   - Field: ‘result’
[17:40:58.070]   - Field: ‘asynchronous’
[17:40:58.070]   - Field: ‘calls’
[17:40:58.070]   - Field: ‘globals’
[17:40:58.070]   - Field: ‘stdout’
[17:40:58.070]   - Field: ‘earlySignal’
[17:40:58.070]   - Field: ‘lazy’
[17:40:58.070]   - Field: ‘state’
[17:40:58.070] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.070] - Launch lazy future ...
[17:40:58.071] Packages needed by the future expression (n = 0): <none>
[17:40:58.071] Packages needed by future strategies (n = 0): <none>
[17:40:58.071] {
[17:40:58.071]     {
[17:40:58.071]         {
[17:40:58.071]             ...future.startTime <- base::Sys.time()
[17:40:58.071]             {
[17:40:58.071]                 {
[17:40:58.071]                   {
[17:40:58.071]                     {
[17:40:58.071]                       base::local({
[17:40:58.071]                         has_future <- base::requireNamespace("future", 
[17:40:58.071]                           quietly = TRUE)
[17:40:58.071]                         if (has_future) {
[17:40:58.071]                           ns <- base::getNamespace("future")
[17:40:58.071]                           version <- ns[[".package"]][["version"]]
[17:40:58.071]                           if (is.null(version)) 
[17:40:58.071]                             version <- utils::packageVersion("future")
[17:40:58.071]                         }
[17:40:58.071]                         else {
[17:40:58.071]                           version <- NULL
[17:40:58.071]                         }
[17:40:58.071]                         if (!has_future || version < "1.8.0") {
[17:40:58.071]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.071]                             "", base::R.version$version.string), 
[17:40:58.071]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:58.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:58.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.071]                               "release", "version")], collapse = " "), 
[17:40:58.071]                             hostname = base::Sys.info()[["nodename"]])
[17:40:58.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.071]                             info)
[17:40:58.071]                           info <- base::paste(info, collapse = "; ")
[17:40:58.071]                           if (!has_future) {
[17:40:58.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.071]                               info)
[17:40:58.071]                           }
[17:40:58.071]                           else {
[17:40:58.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.071]                               info, version)
[17:40:58.071]                           }
[17:40:58.071]                           base::stop(msg)
[17:40:58.071]                         }
[17:40:58.071]                       })
[17:40:58.071]                     }
[17:40:58.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.071]                     base::options(mc.cores = 1L)
[17:40:58.071]                   }
[17:40:58.071]                   ...future.strategy.old <- future::plan("list")
[17:40:58.071]                   options(future.plan = NULL)
[17:40:58.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.071]                 }
[17:40:58.071]                 ...future.workdir <- getwd()
[17:40:58.071]             }
[17:40:58.071]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.071]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.071]         }
[17:40:58.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.071]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:58.071]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.071]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.071]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.071]             base::names(...future.oldOptions))
[17:40:58.071]     }
[17:40:58.071]     if (FALSE) {
[17:40:58.071]     }
[17:40:58.071]     else {
[17:40:58.071]         if (TRUE) {
[17:40:58.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.071]                 open = "w")
[17:40:58.071]         }
[17:40:58.071]         else {
[17:40:58.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.071]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.071]         }
[17:40:58.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.071]             base::sink(type = "output", split = FALSE)
[17:40:58.071]             base::close(...future.stdout)
[17:40:58.071]         }, add = TRUE)
[17:40:58.071]     }
[17:40:58.071]     ...future.frame <- base::sys.nframe()
[17:40:58.071]     ...future.conditions <- base::list()
[17:40:58.071]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.071]     if (FALSE) {
[17:40:58.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.071]     }
[17:40:58.071]     ...future.result <- base::tryCatch({
[17:40:58.071]         base::withCallingHandlers({
[17:40:58.071]             ...future.value <- base::withVisible(base::local({
[17:40:58.071]                 ...future.makeSendCondition <- base::local({
[17:40:58.071]                   sendCondition <- NULL
[17:40:58.071]                   function(frame = 1L) {
[17:40:58.071]                     if (is.function(sendCondition)) 
[17:40:58.071]                       return(sendCondition)
[17:40:58.071]                     ns <- getNamespace("parallel")
[17:40:58.071]                     if (exists("sendData", mode = "function", 
[17:40:58.071]                       envir = ns)) {
[17:40:58.071]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.071]                         envir = ns)
[17:40:58.071]                       envir <- sys.frame(frame)
[17:40:58.071]                       master <- NULL
[17:40:58.071]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.071]                         !identical(envir, emptyenv())) {
[17:40:58.071]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.071]                           inherits = FALSE)) {
[17:40:58.071]                           master <- get("master", mode = "list", 
[17:40:58.071]                             envir = envir, inherits = FALSE)
[17:40:58.071]                           if (inherits(master, c("SOCKnode", 
[17:40:58.071]                             "SOCK0node"))) {
[17:40:58.071]                             sendCondition <<- function(cond) {
[17:40:58.071]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.071]                                 success = TRUE)
[17:40:58.071]                               parallel_sendData(master, data)
[17:40:58.071]                             }
[17:40:58.071]                             return(sendCondition)
[17:40:58.071]                           }
[17:40:58.071]                         }
[17:40:58.071]                         frame <- frame + 1L
[17:40:58.071]                         envir <- sys.frame(frame)
[17:40:58.071]                       }
[17:40:58.071]                     }
[17:40:58.071]                     sendCondition <<- function(cond) NULL
[17:40:58.071]                   }
[17:40:58.071]                 })
[17:40:58.071]                 withCallingHandlers({
[17:40:58.071]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:58.071]                 }, immediateCondition = function(cond) {
[17:40:58.071]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.071]                   sendCondition(cond)
[17:40:58.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.071]                   {
[17:40:58.071]                     inherits <- base::inherits
[17:40:58.071]                     invokeRestart <- base::invokeRestart
[17:40:58.071]                     is.null <- base::is.null
[17:40:58.071]                     muffled <- FALSE
[17:40:58.071]                     if (inherits(cond, "message")) {
[17:40:58.071]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.071]                       if (muffled) 
[17:40:58.071]                         invokeRestart("muffleMessage")
[17:40:58.071]                     }
[17:40:58.071]                     else if (inherits(cond, "warning")) {
[17:40:58.071]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.071]                       if (muffled) 
[17:40:58.071]                         invokeRestart("muffleWarning")
[17:40:58.071]                     }
[17:40:58.071]                     else if (inherits(cond, "condition")) {
[17:40:58.071]                       if (!is.null(pattern)) {
[17:40:58.071]                         computeRestarts <- base::computeRestarts
[17:40:58.071]                         grepl <- base::grepl
[17:40:58.071]                         restarts <- computeRestarts(cond)
[17:40:58.071]                         for (restart in restarts) {
[17:40:58.071]                           name <- restart$name
[17:40:58.071]                           if (is.null(name)) 
[17:40:58.071]                             next
[17:40:58.071]                           if (!grepl(pattern, name)) 
[17:40:58.071]                             next
[17:40:58.071]                           invokeRestart(restart)
[17:40:58.071]                           muffled <- TRUE
[17:40:58.071]                           break
[17:40:58.071]                         }
[17:40:58.071]                       }
[17:40:58.071]                     }
[17:40:58.071]                     invisible(muffled)
[17:40:58.071]                   }
[17:40:58.071]                   muffleCondition(cond)
[17:40:58.071]                 })
[17:40:58.071]             }))
[17:40:58.071]             future::FutureResult(value = ...future.value$value, 
[17:40:58.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.071]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.071]                     ...future.globalenv.names))
[17:40:58.071]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.071]         }, condition = base::local({
[17:40:58.071]             c <- base::c
[17:40:58.071]             inherits <- base::inherits
[17:40:58.071]             invokeRestart <- base::invokeRestart
[17:40:58.071]             length <- base::length
[17:40:58.071]             list <- base::list
[17:40:58.071]             seq.int <- base::seq.int
[17:40:58.071]             signalCondition <- base::signalCondition
[17:40:58.071]             sys.calls <- base::sys.calls
[17:40:58.071]             `[[` <- base::`[[`
[17:40:58.071]             `+` <- base::`+`
[17:40:58.071]             `<<-` <- base::`<<-`
[17:40:58.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.071]                   3L)]
[17:40:58.071]             }
[17:40:58.071]             function(cond) {
[17:40:58.071]                 is_error <- inherits(cond, "error")
[17:40:58.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.071]                   NULL)
[17:40:58.071]                 if (is_error) {
[17:40:58.071]                   sessionInformation <- function() {
[17:40:58.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.071]                       search = base::search(), system = base::Sys.info())
[17:40:58.071]                   }
[17:40:58.071]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.071]                     cond$call), session = sessionInformation(), 
[17:40:58.071]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.071]                   signalCondition(cond)
[17:40:58.071]                 }
[17:40:58.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.071]                 "immediateCondition"))) {
[17:40:58.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.071]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.071]                   if (TRUE && !signal) {
[17:40:58.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.071]                     {
[17:40:58.071]                       inherits <- base::inherits
[17:40:58.071]                       invokeRestart <- base::invokeRestart
[17:40:58.071]                       is.null <- base::is.null
[17:40:58.071]                       muffled <- FALSE
[17:40:58.071]                       if (inherits(cond, "message")) {
[17:40:58.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.071]                         if (muffled) 
[17:40:58.071]                           invokeRestart("muffleMessage")
[17:40:58.071]                       }
[17:40:58.071]                       else if (inherits(cond, "warning")) {
[17:40:58.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.071]                         if (muffled) 
[17:40:58.071]                           invokeRestart("muffleWarning")
[17:40:58.071]                       }
[17:40:58.071]                       else if (inherits(cond, "condition")) {
[17:40:58.071]                         if (!is.null(pattern)) {
[17:40:58.071]                           computeRestarts <- base::computeRestarts
[17:40:58.071]                           grepl <- base::grepl
[17:40:58.071]                           restarts <- computeRestarts(cond)
[17:40:58.071]                           for (restart in restarts) {
[17:40:58.071]                             name <- restart$name
[17:40:58.071]                             if (is.null(name)) 
[17:40:58.071]                               next
[17:40:58.071]                             if (!grepl(pattern, name)) 
[17:40:58.071]                               next
[17:40:58.071]                             invokeRestart(restart)
[17:40:58.071]                             muffled <- TRUE
[17:40:58.071]                             break
[17:40:58.071]                           }
[17:40:58.071]                         }
[17:40:58.071]                       }
[17:40:58.071]                       invisible(muffled)
[17:40:58.071]                     }
[17:40:58.071]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.071]                   }
[17:40:58.071]                 }
[17:40:58.071]                 else {
[17:40:58.071]                   if (TRUE) {
[17:40:58.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.071]                     {
[17:40:58.071]                       inherits <- base::inherits
[17:40:58.071]                       invokeRestart <- base::invokeRestart
[17:40:58.071]                       is.null <- base::is.null
[17:40:58.071]                       muffled <- FALSE
[17:40:58.071]                       if (inherits(cond, "message")) {
[17:40:58.071]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.071]                         if (muffled) 
[17:40:58.071]                           invokeRestart("muffleMessage")
[17:40:58.071]                       }
[17:40:58.071]                       else if (inherits(cond, "warning")) {
[17:40:58.071]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.071]                         if (muffled) 
[17:40:58.071]                           invokeRestart("muffleWarning")
[17:40:58.071]                       }
[17:40:58.071]                       else if (inherits(cond, "condition")) {
[17:40:58.071]                         if (!is.null(pattern)) {
[17:40:58.071]                           computeRestarts <- base::computeRestarts
[17:40:58.071]                           grepl <- base::grepl
[17:40:58.071]                           restarts <- computeRestarts(cond)
[17:40:58.071]                           for (restart in restarts) {
[17:40:58.071]                             name <- restart$name
[17:40:58.071]                             if (is.null(name)) 
[17:40:58.071]                               next
[17:40:58.071]                             if (!grepl(pattern, name)) 
[17:40:58.071]                               next
[17:40:58.071]                             invokeRestart(restart)
[17:40:58.071]                             muffled <- TRUE
[17:40:58.071]                             break
[17:40:58.071]                           }
[17:40:58.071]                         }
[17:40:58.071]                       }
[17:40:58.071]                       invisible(muffled)
[17:40:58.071]                     }
[17:40:58.071]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.071]                   }
[17:40:58.071]                 }
[17:40:58.071]             }
[17:40:58.071]         }))
[17:40:58.071]     }, error = function(ex) {
[17:40:58.071]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.071]                 ...future.rng), started = ...future.startTime, 
[17:40:58.071]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.071]             version = "1.8"), class = "FutureResult")
[17:40:58.071]     }, finally = {
[17:40:58.071]         if (!identical(...future.workdir, getwd())) 
[17:40:58.071]             setwd(...future.workdir)
[17:40:58.071]         {
[17:40:58.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.071]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.071]             }
[17:40:58.071]             base::options(...future.oldOptions)
[17:40:58.071]             if (.Platform$OS.type == "windows") {
[17:40:58.071]                 old_names <- names(...future.oldEnvVars)
[17:40:58.071]                 envs <- base::Sys.getenv()
[17:40:58.071]                 names <- names(envs)
[17:40:58.071]                 common <- intersect(names, old_names)
[17:40:58.071]                 added <- setdiff(names, old_names)
[17:40:58.071]                 removed <- setdiff(old_names, names)
[17:40:58.071]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.071]                   envs[common]]
[17:40:58.071]                 NAMES <- toupper(changed)
[17:40:58.071]                 args <- list()
[17:40:58.071]                 for (kk in seq_along(NAMES)) {
[17:40:58.071]                   name <- changed[[kk]]
[17:40:58.071]                   NAME <- NAMES[[kk]]
[17:40:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.071]                     next
[17:40:58.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.071]                 }
[17:40:58.071]                 NAMES <- toupper(added)
[17:40:58.071]                 for (kk in seq_along(NAMES)) {
[17:40:58.071]                   name <- added[[kk]]
[17:40:58.071]                   NAME <- NAMES[[kk]]
[17:40:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.071]                     next
[17:40:58.071]                   args[[name]] <- ""
[17:40:58.071]                 }
[17:40:58.071]                 NAMES <- toupper(removed)
[17:40:58.071]                 for (kk in seq_along(NAMES)) {
[17:40:58.071]                   name <- removed[[kk]]
[17:40:58.071]                   NAME <- NAMES[[kk]]
[17:40:58.071]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.071]                     next
[17:40:58.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.071]                 }
[17:40:58.071]                 if (length(args) > 0) 
[17:40:58.071]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.071]             }
[17:40:58.071]             else {
[17:40:58.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.071]             }
[17:40:58.071]             {
[17:40:58.071]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.071]                   0L) {
[17:40:58.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.071]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.071]                   base::options(opts)
[17:40:58.071]                 }
[17:40:58.071]                 {
[17:40:58.071]                   {
[17:40:58.071]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.071]                     NULL
[17:40:58.071]                   }
[17:40:58.071]                   options(future.plan = NULL)
[17:40:58.071]                   if (is.na(NA_character_)) 
[17:40:58.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:58.071]                     .init = FALSE)
[17:40:58.071]                 }
[17:40:58.071]             }
[17:40:58.071]         }
[17:40:58.071]     })
[17:40:58.071]     if (TRUE) {
[17:40:58.071]         base::sink(type = "output", split = FALSE)
[17:40:58.071]         if (TRUE) {
[17:40:58.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.071]         }
[17:40:58.071]         else {
[17:40:58.071]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.071]         }
[17:40:58.071]         base::close(...future.stdout)
[17:40:58.071]         ...future.stdout <- NULL
[17:40:58.071]     }
[17:40:58.071]     ...future.result$conditions <- ...future.conditions
[17:40:58.071]     ...future.result$finished <- base::Sys.time()
[17:40:58.071]     ...future.result
[17:40:58.071] }
[17:40:58.074] MultisessionFuture started
[17:40:58.074] - Launch lazy future ... done
[17:40:58.074] run() for ‘MultisessionFuture’ ... done
[17:40:58.076] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.076] - Validating connection of MultisessionFuture
[17:40:58.076] - received message: FutureResult
[17:40:58.077] - Received FutureResult
[17:40:58.077] - Erased future from FutureRegistry
[17:40:58.077] result() for ClusterFuture ...
[17:40:58.077] - result already collected: FutureResult
[17:40:58.077] result() for ClusterFuture ... done
[17:40:58.077] signalConditions() ...
[17:40:58.077]  - include = ‘immediateCondition’
[17:40:58.077]  - exclude = 
[17:40:58.077]  - resignal = FALSE
[17:40:58.077]  - Number of conditions: 1
[17:40:58.077] signalConditions() ... done
[17:40:58.077] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.078] A MultisessionFuture was resolved (and resolved itself)
[17:40:58.078] getGlobalsAndPackages() ...
[17:40:58.078] Searching for globals...
[17:40:58.078] - globals found: [2] ‘list’, ‘stop’
[17:40:58.079] Searching for globals ... DONE
[17:40:58.079] Resolving globals: FALSE
[17:40:58.079] 
[17:40:58.079] 
[17:40:58.079] getGlobalsAndPackages() ... DONE
[17:40:58.079] run() for ‘Future’ ...
[17:40:58.079] - state: ‘created’
[17:40:58.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.093] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.093]   - Field: ‘node’
[17:40:58.093]   - Field: ‘label’
[17:40:58.093]   - Field: ‘local’
[17:40:58.094]   - Field: ‘owner’
[17:40:58.094]   - Field: ‘envir’
[17:40:58.094]   - Field: ‘workers’
[17:40:58.094]   - Field: ‘packages’
[17:40:58.094]   - Field: ‘gc’
[17:40:58.094]   - Field: ‘conditions’
[17:40:58.094]   - Field: ‘persistent’
[17:40:58.094]   - Field: ‘expr’
[17:40:58.094]   - Field: ‘uuid’
[17:40:58.094]   - Field: ‘seed’
[17:40:58.094]   - Field: ‘version’
[17:40:58.094]   - Field: ‘result’
[17:40:58.095]   - Field: ‘asynchronous’
[17:40:58.095]   - Field: ‘calls’
[17:40:58.095]   - Field: ‘globals’
[17:40:58.095]   - Field: ‘stdout’
[17:40:58.097]   - Field: ‘earlySignal’
[17:40:58.097]   - Field: ‘lazy’
[17:40:58.097]   - Field: ‘state’
[17:40:58.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.098] - Launch lazy future ...
[17:40:58.098] Packages needed by the future expression (n = 0): <none>
[17:40:58.098] Packages needed by future strategies (n = 0): <none>
[17:40:58.099] {
[17:40:58.099]     {
[17:40:58.099]         {
[17:40:58.099]             ...future.startTime <- base::Sys.time()
[17:40:58.099]             {
[17:40:58.099]                 {
[17:40:58.099]                   {
[17:40:58.099]                     {
[17:40:58.099]                       base::local({
[17:40:58.099]                         has_future <- base::requireNamespace("future", 
[17:40:58.099]                           quietly = TRUE)
[17:40:58.099]                         if (has_future) {
[17:40:58.099]                           ns <- base::getNamespace("future")
[17:40:58.099]                           version <- ns[[".package"]][["version"]]
[17:40:58.099]                           if (is.null(version)) 
[17:40:58.099]                             version <- utils::packageVersion("future")
[17:40:58.099]                         }
[17:40:58.099]                         else {
[17:40:58.099]                           version <- NULL
[17:40:58.099]                         }
[17:40:58.099]                         if (!has_future || version < "1.8.0") {
[17:40:58.099]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.099]                             "", base::R.version$version.string), 
[17:40:58.099]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:58.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:58.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.099]                               "release", "version")], collapse = " "), 
[17:40:58.099]                             hostname = base::Sys.info()[["nodename"]])
[17:40:58.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.099]                             info)
[17:40:58.099]                           info <- base::paste(info, collapse = "; ")
[17:40:58.099]                           if (!has_future) {
[17:40:58.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.099]                               info)
[17:40:58.099]                           }
[17:40:58.099]                           else {
[17:40:58.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.099]                               info, version)
[17:40:58.099]                           }
[17:40:58.099]                           base::stop(msg)
[17:40:58.099]                         }
[17:40:58.099]                       })
[17:40:58.099]                     }
[17:40:58.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.099]                     base::options(mc.cores = 1L)
[17:40:58.099]                   }
[17:40:58.099]                   ...future.strategy.old <- future::plan("list")
[17:40:58.099]                   options(future.plan = NULL)
[17:40:58.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.099]                 }
[17:40:58.099]                 ...future.workdir <- getwd()
[17:40:58.099]             }
[17:40:58.099]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.099]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.099]         }
[17:40:58.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:58.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.099]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.099]             base::names(...future.oldOptions))
[17:40:58.099]     }
[17:40:58.099]     if (FALSE) {
[17:40:58.099]     }
[17:40:58.099]     else {
[17:40:58.099]         if (TRUE) {
[17:40:58.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.099]                 open = "w")
[17:40:58.099]         }
[17:40:58.099]         else {
[17:40:58.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.099]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.099]         }
[17:40:58.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.099]             base::sink(type = "output", split = FALSE)
[17:40:58.099]             base::close(...future.stdout)
[17:40:58.099]         }, add = TRUE)
[17:40:58.099]     }
[17:40:58.099]     ...future.frame <- base::sys.nframe()
[17:40:58.099]     ...future.conditions <- base::list()
[17:40:58.099]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.099]     if (FALSE) {
[17:40:58.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.099]     }
[17:40:58.099]     ...future.result <- base::tryCatch({
[17:40:58.099]         base::withCallingHandlers({
[17:40:58.099]             ...future.value <- base::withVisible(base::local({
[17:40:58.099]                 ...future.makeSendCondition <- base::local({
[17:40:58.099]                   sendCondition <- NULL
[17:40:58.099]                   function(frame = 1L) {
[17:40:58.099]                     if (is.function(sendCondition)) 
[17:40:58.099]                       return(sendCondition)
[17:40:58.099]                     ns <- getNamespace("parallel")
[17:40:58.099]                     if (exists("sendData", mode = "function", 
[17:40:58.099]                       envir = ns)) {
[17:40:58.099]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.099]                         envir = ns)
[17:40:58.099]                       envir <- sys.frame(frame)
[17:40:58.099]                       master <- NULL
[17:40:58.099]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.099]                         !identical(envir, emptyenv())) {
[17:40:58.099]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.099]                           inherits = FALSE)) {
[17:40:58.099]                           master <- get("master", mode = "list", 
[17:40:58.099]                             envir = envir, inherits = FALSE)
[17:40:58.099]                           if (inherits(master, c("SOCKnode", 
[17:40:58.099]                             "SOCK0node"))) {
[17:40:58.099]                             sendCondition <<- function(cond) {
[17:40:58.099]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.099]                                 success = TRUE)
[17:40:58.099]                               parallel_sendData(master, data)
[17:40:58.099]                             }
[17:40:58.099]                             return(sendCondition)
[17:40:58.099]                           }
[17:40:58.099]                         }
[17:40:58.099]                         frame <- frame + 1L
[17:40:58.099]                         envir <- sys.frame(frame)
[17:40:58.099]                       }
[17:40:58.099]                     }
[17:40:58.099]                     sendCondition <<- function(cond) NULL
[17:40:58.099]                   }
[17:40:58.099]                 })
[17:40:58.099]                 withCallingHandlers({
[17:40:58.099]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:58.099]                 }, immediateCondition = function(cond) {
[17:40:58.099]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.099]                   sendCondition(cond)
[17:40:58.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.099]                   {
[17:40:58.099]                     inherits <- base::inherits
[17:40:58.099]                     invokeRestart <- base::invokeRestart
[17:40:58.099]                     is.null <- base::is.null
[17:40:58.099]                     muffled <- FALSE
[17:40:58.099]                     if (inherits(cond, "message")) {
[17:40:58.099]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.099]                       if (muffled) 
[17:40:58.099]                         invokeRestart("muffleMessage")
[17:40:58.099]                     }
[17:40:58.099]                     else if (inherits(cond, "warning")) {
[17:40:58.099]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.099]                       if (muffled) 
[17:40:58.099]                         invokeRestart("muffleWarning")
[17:40:58.099]                     }
[17:40:58.099]                     else if (inherits(cond, "condition")) {
[17:40:58.099]                       if (!is.null(pattern)) {
[17:40:58.099]                         computeRestarts <- base::computeRestarts
[17:40:58.099]                         grepl <- base::grepl
[17:40:58.099]                         restarts <- computeRestarts(cond)
[17:40:58.099]                         for (restart in restarts) {
[17:40:58.099]                           name <- restart$name
[17:40:58.099]                           if (is.null(name)) 
[17:40:58.099]                             next
[17:40:58.099]                           if (!grepl(pattern, name)) 
[17:40:58.099]                             next
[17:40:58.099]                           invokeRestart(restart)
[17:40:58.099]                           muffled <- TRUE
[17:40:58.099]                           break
[17:40:58.099]                         }
[17:40:58.099]                       }
[17:40:58.099]                     }
[17:40:58.099]                     invisible(muffled)
[17:40:58.099]                   }
[17:40:58.099]                   muffleCondition(cond)
[17:40:58.099]                 })
[17:40:58.099]             }))
[17:40:58.099]             future::FutureResult(value = ...future.value$value, 
[17:40:58.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.099]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.099]                     ...future.globalenv.names))
[17:40:58.099]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.099]         }, condition = base::local({
[17:40:58.099]             c <- base::c
[17:40:58.099]             inherits <- base::inherits
[17:40:58.099]             invokeRestart <- base::invokeRestart
[17:40:58.099]             length <- base::length
[17:40:58.099]             list <- base::list
[17:40:58.099]             seq.int <- base::seq.int
[17:40:58.099]             signalCondition <- base::signalCondition
[17:40:58.099]             sys.calls <- base::sys.calls
[17:40:58.099]             `[[` <- base::`[[`
[17:40:58.099]             `+` <- base::`+`
[17:40:58.099]             `<<-` <- base::`<<-`
[17:40:58.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.099]                   3L)]
[17:40:58.099]             }
[17:40:58.099]             function(cond) {
[17:40:58.099]                 is_error <- inherits(cond, "error")
[17:40:58.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.099]                   NULL)
[17:40:58.099]                 if (is_error) {
[17:40:58.099]                   sessionInformation <- function() {
[17:40:58.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.099]                       search = base::search(), system = base::Sys.info())
[17:40:58.099]                   }
[17:40:58.099]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.099]                     cond$call), session = sessionInformation(), 
[17:40:58.099]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.099]                   signalCondition(cond)
[17:40:58.099]                 }
[17:40:58.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.099]                 "immediateCondition"))) {
[17:40:58.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.099]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.099]                   if (TRUE && !signal) {
[17:40:58.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.099]                     {
[17:40:58.099]                       inherits <- base::inherits
[17:40:58.099]                       invokeRestart <- base::invokeRestart
[17:40:58.099]                       is.null <- base::is.null
[17:40:58.099]                       muffled <- FALSE
[17:40:58.099]                       if (inherits(cond, "message")) {
[17:40:58.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.099]                         if (muffled) 
[17:40:58.099]                           invokeRestart("muffleMessage")
[17:40:58.099]                       }
[17:40:58.099]                       else if (inherits(cond, "warning")) {
[17:40:58.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.099]                         if (muffled) 
[17:40:58.099]                           invokeRestart("muffleWarning")
[17:40:58.099]                       }
[17:40:58.099]                       else if (inherits(cond, "condition")) {
[17:40:58.099]                         if (!is.null(pattern)) {
[17:40:58.099]                           computeRestarts <- base::computeRestarts
[17:40:58.099]                           grepl <- base::grepl
[17:40:58.099]                           restarts <- computeRestarts(cond)
[17:40:58.099]                           for (restart in restarts) {
[17:40:58.099]                             name <- restart$name
[17:40:58.099]                             if (is.null(name)) 
[17:40:58.099]                               next
[17:40:58.099]                             if (!grepl(pattern, name)) 
[17:40:58.099]                               next
[17:40:58.099]                             invokeRestart(restart)
[17:40:58.099]                             muffled <- TRUE
[17:40:58.099]                             break
[17:40:58.099]                           }
[17:40:58.099]                         }
[17:40:58.099]                       }
[17:40:58.099]                       invisible(muffled)
[17:40:58.099]                     }
[17:40:58.099]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.099]                   }
[17:40:58.099]                 }
[17:40:58.099]                 else {
[17:40:58.099]                   if (TRUE) {
[17:40:58.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.099]                     {
[17:40:58.099]                       inherits <- base::inherits
[17:40:58.099]                       invokeRestart <- base::invokeRestart
[17:40:58.099]                       is.null <- base::is.null
[17:40:58.099]                       muffled <- FALSE
[17:40:58.099]                       if (inherits(cond, "message")) {
[17:40:58.099]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.099]                         if (muffled) 
[17:40:58.099]                           invokeRestart("muffleMessage")
[17:40:58.099]                       }
[17:40:58.099]                       else if (inherits(cond, "warning")) {
[17:40:58.099]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.099]                         if (muffled) 
[17:40:58.099]                           invokeRestart("muffleWarning")
[17:40:58.099]                       }
[17:40:58.099]                       else if (inherits(cond, "condition")) {
[17:40:58.099]                         if (!is.null(pattern)) {
[17:40:58.099]                           computeRestarts <- base::computeRestarts
[17:40:58.099]                           grepl <- base::grepl
[17:40:58.099]                           restarts <- computeRestarts(cond)
[17:40:58.099]                           for (restart in restarts) {
[17:40:58.099]                             name <- restart$name
[17:40:58.099]                             if (is.null(name)) 
[17:40:58.099]                               next
[17:40:58.099]                             if (!grepl(pattern, name)) 
[17:40:58.099]                               next
[17:40:58.099]                             invokeRestart(restart)
[17:40:58.099]                             muffled <- TRUE
[17:40:58.099]                             break
[17:40:58.099]                           }
[17:40:58.099]                         }
[17:40:58.099]                       }
[17:40:58.099]                       invisible(muffled)
[17:40:58.099]                     }
[17:40:58.099]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.099]                   }
[17:40:58.099]                 }
[17:40:58.099]             }
[17:40:58.099]         }))
[17:40:58.099]     }, error = function(ex) {
[17:40:58.099]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.099]                 ...future.rng), started = ...future.startTime, 
[17:40:58.099]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.099]             version = "1.8"), class = "FutureResult")
[17:40:58.099]     }, finally = {
[17:40:58.099]         if (!identical(...future.workdir, getwd())) 
[17:40:58.099]             setwd(...future.workdir)
[17:40:58.099]         {
[17:40:58.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.099]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.099]             }
[17:40:58.099]             base::options(...future.oldOptions)
[17:40:58.099]             if (.Platform$OS.type == "windows") {
[17:40:58.099]                 old_names <- names(...future.oldEnvVars)
[17:40:58.099]                 envs <- base::Sys.getenv()
[17:40:58.099]                 names <- names(envs)
[17:40:58.099]                 common <- intersect(names, old_names)
[17:40:58.099]                 added <- setdiff(names, old_names)
[17:40:58.099]                 removed <- setdiff(old_names, names)
[17:40:58.099]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.099]                   envs[common]]
[17:40:58.099]                 NAMES <- toupper(changed)
[17:40:58.099]                 args <- list()
[17:40:58.099]                 for (kk in seq_along(NAMES)) {
[17:40:58.099]                   name <- changed[[kk]]
[17:40:58.099]                   NAME <- NAMES[[kk]]
[17:40:58.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.099]                     next
[17:40:58.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.099]                 }
[17:40:58.099]                 NAMES <- toupper(added)
[17:40:58.099]                 for (kk in seq_along(NAMES)) {
[17:40:58.099]                   name <- added[[kk]]
[17:40:58.099]                   NAME <- NAMES[[kk]]
[17:40:58.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.099]                     next
[17:40:58.099]                   args[[name]] <- ""
[17:40:58.099]                 }
[17:40:58.099]                 NAMES <- toupper(removed)
[17:40:58.099]                 for (kk in seq_along(NAMES)) {
[17:40:58.099]                   name <- removed[[kk]]
[17:40:58.099]                   NAME <- NAMES[[kk]]
[17:40:58.099]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.099]                     next
[17:40:58.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.099]                 }
[17:40:58.099]                 if (length(args) > 0) 
[17:40:58.099]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.099]             }
[17:40:58.099]             else {
[17:40:58.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.099]             }
[17:40:58.099]             {
[17:40:58.099]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.099]                   0L) {
[17:40:58.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.099]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.099]                   base::options(opts)
[17:40:58.099]                 }
[17:40:58.099]                 {
[17:40:58.099]                   {
[17:40:58.099]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.099]                     NULL
[17:40:58.099]                   }
[17:40:58.099]                   options(future.plan = NULL)
[17:40:58.099]                   if (is.na(NA_character_)) 
[17:40:58.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:58.099]                     .init = FALSE)
[17:40:58.099]                 }
[17:40:58.099]             }
[17:40:58.099]         }
[17:40:58.099]     })
[17:40:58.099]     if (TRUE) {
[17:40:58.099]         base::sink(type = "output", split = FALSE)
[17:40:58.099]         if (TRUE) {
[17:40:58.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.099]         }
[17:40:58.099]         else {
[17:40:58.099]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.099]         }
[17:40:58.099]         base::close(...future.stdout)
[17:40:58.099]         ...future.stdout <- NULL
[17:40:58.099]     }
[17:40:58.099]     ...future.result$conditions <- ...future.conditions
[17:40:58.099]     ...future.result$finished <- base::Sys.time()
[17:40:58.099]     ...future.result
[17:40:58.099] }
[17:40:58.101] MultisessionFuture started
[17:40:58.102] - Launch lazy future ... done
[17:40:58.102] run() for ‘MultisessionFuture’ ... done
[17:40:58.103] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.103] - Validating connection of MultisessionFuture
[17:40:58.104] - received message: FutureResult
[17:40:58.104] - Received FutureResult
[17:40:58.104] - Erased future from FutureRegistry
[17:40:58.104] result() for ClusterFuture ...
[17:40:58.104] - result already collected: FutureResult
[17:40:58.104] result() for ClusterFuture ... done
[17:40:58.104] signalConditions() ...
[17:40:58.104]  - include = ‘immediateCondition’
[17:40:58.104]  - exclude = 
[17:40:58.104]  - resignal = FALSE
[17:40:58.104]  - Number of conditions: 1
[17:40:58.105] signalConditions() ... done
[17:40:58.105] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.105] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[17:40:58.105] getGlobalsAndPackages() ...
[17:40:58.105] Searching for globals...
[17:40:58.106] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:58.106] Searching for globals ... DONE
[17:40:58.106] Resolving globals: FALSE
[17:40:58.107] 
[17:40:58.107] 
[17:40:58.107] getGlobalsAndPackages() ... DONE
[17:40:58.107] run() for ‘Future’ ...
[17:40:58.107] - state: ‘created’
[17:40:58.107] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.121] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.121]   - Field: ‘node’
[17:40:58.121]   - Field: ‘label’
[17:40:58.121]   - Field: ‘local’
[17:40:58.121]   - Field: ‘owner’
[17:40:58.121]   - Field: ‘envir’
[17:40:58.121]   - Field: ‘workers’
[17:40:58.121]   - Field: ‘packages’
[17:40:58.121]   - Field: ‘gc’
[17:40:58.121]   - Field: ‘conditions’
[17:40:58.122]   - Field: ‘persistent’
[17:40:58.122]   - Field: ‘expr’
[17:40:58.122]   - Field: ‘uuid’
[17:40:58.122]   - Field: ‘seed’
[17:40:58.122]   - Field: ‘version’
[17:40:58.122]   - Field: ‘result’
[17:40:58.122]   - Field: ‘asynchronous’
[17:40:58.122]   - Field: ‘calls’
[17:40:58.122]   - Field: ‘globals’
[17:40:58.122]   - Field: ‘stdout’
[17:40:58.122]   - Field: ‘earlySignal’
[17:40:58.122]   - Field: ‘lazy’
[17:40:58.123]   - Field: ‘state’
[17:40:58.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.123] - Launch lazy future ...
[17:40:58.123] Packages needed by the future expression (n = 0): <none>
[17:40:58.123] Packages needed by future strategies (n = 0): <none>
[17:40:58.123] {
[17:40:58.123]     {
[17:40:58.123]         {
[17:40:58.123]             ...future.startTime <- base::Sys.time()
[17:40:58.123]             {
[17:40:58.123]                 {
[17:40:58.123]                   {
[17:40:58.123]                     {
[17:40:58.123]                       base::local({
[17:40:58.123]                         has_future <- base::requireNamespace("future", 
[17:40:58.123]                           quietly = TRUE)
[17:40:58.123]                         if (has_future) {
[17:40:58.123]                           ns <- base::getNamespace("future")
[17:40:58.123]                           version <- ns[[".package"]][["version"]]
[17:40:58.123]                           if (is.null(version)) 
[17:40:58.123]                             version <- utils::packageVersion("future")
[17:40:58.123]                         }
[17:40:58.123]                         else {
[17:40:58.123]                           version <- NULL
[17:40:58.123]                         }
[17:40:58.123]                         if (!has_future || version < "1.8.0") {
[17:40:58.123]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.123]                             "", base::R.version$version.string), 
[17:40:58.123]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:58.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:58.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.123]                               "release", "version")], collapse = " "), 
[17:40:58.123]                             hostname = base::Sys.info()[["nodename"]])
[17:40:58.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.123]                             info)
[17:40:58.123]                           info <- base::paste(info, collapse = "; ")
[17:40:58.123]                           if (!has_future) {
[17:40:58.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.123]                               info)
[17:40:58.123]                           }
[17:40:58.123]                           else {
[17:40:58.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.123]                               info, version)
[17:40:58.123]                           }
[17:40:58.123]                           base::stop(msg)
[17:40:58.123]                         }
[17:40:58.123]                       })
[17:40:58.123]                     }
[17:40:58.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.123]                     base::options(mc.cores = 1L)
[17:40:58.123]                   }
[17:40:58.123]                   ...future.strategy.old <- future::plan("list")
[17:40:58.123]                   options(future.plan = NULL)
[17:40:58.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.123]                 }
[17:40:58.123]                 ...future.workdir <- getwd()
[17:40:58.123]             }
[17:40:58.123]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.123]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.123]         }
[17:40:58.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:58.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.123]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.123]             base::names(...future.oldOptions))
[17:40:58.123]     }
[17:40:58.123]     if (FALSE) {
[17:40:58.123]     }
[17:40:58.123]     else {
[17:40:58.123]         if (TRUE) {
[17:40:58.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.123]                 open = "w")
[17:40:58.123]         }
[17:40:58.123]         else {
[17:40:58.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.123]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.123]         }
[17:40:58.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.123]             base::sink(type = "output", split = FALSE)
[17:40:58.123]             base::close(...future.stdout)
[17:40:58.123]         }, add = TRUE)
[17:40:58.123]     }
[17:40:58.123]     ...future.frame <- base::sys.nframe()
[17:40:58.123]     ...future.conditions <- base::list()
[17:40:58.123]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.123]     if (FALSE) {
[17:40:58.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.123]     }
[17:40:58.123]     ...future.result <- base::tryCatch({
[17:40:58.123]         base::withCallingHandlers({
[17:40:58.123]             ...future.value <- base::withVisible(base::local({
[17:40:58.123]                 ...future.makeSendCondition <- base::local({
[17:40:58.123]                   sendCondition <- NULL
[17:40:58.123]                   function(frame = 1L) {
[17:40:58.123]                     if (is.function(sendCondition)) 
[17:40:58.123]                       return(sendCondition)
[17:40:58.123]                     ns <- getNamespace("parallel")
[17:40:58.123]                     if (exists("sendData", mode = "function", 
[17:40:58.123]                       envir = ns)) {
[17:40:58.123]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.123]                         envir = ns)
[17:40:58.123]                       envir <- sys.frame(frame)
[17:40:58.123]                       master <- NULL
[17:40:58.123]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.123]                         !identical(envir, emptyenv())) {
[17:40:58.123]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.123]                           inherits = FALSE)) {
[17:40:58.123]                           master <- get("master", mode = "list", 
[17:40:58.123]                             envir = envir, inherits = FALSE)
[17:40:58.123]                           if (inherits(master, c("SOCKnode", 
[17:40:58.123]                             "SOCK0node"))) {
[17:40:58.123]                             sendCondition <<- function(cond) {
[17:40:58.123]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.123]                                 success = TRUE)
[17:40:58.123]                               parallel_sendData(master, data)
[17:40:58.123]                             }
[17:40:58.123]                             return(sendCondition)
[17:40:58.123]                           }
[17:40:58.123]                         }
[17:40:58.123]                         frame <- frame + 1L
[17:40:58.123]                         envir <- sys.frame(frame)
[17:40:58.123]                       }
[17:40:58.123]                     }
[17:40:58.123]                     sendCondition <<- function(cond) NULL
[17:40:58.123]                   }
[17:40:58.123]                 })
[17:40:58.123]                 withCallingHandlers({
[17:40:58.123]                   {
[17:40:58.123]                     Sys.sleep(0.5)
[17:40:58.123]                     list(a = 1, b = 42L)
[17:40:58.123]                   }
[17:40:58.123]                 }, immediateCondition = function(cond) {
[17:40:58.123]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.123]                   sendCondition(cond)
[17:40:58.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.123]                   {
[17:40:58.123]                     inherits <- base::inherits
[17:40:58.123]                     invokeRestart <- base::invokeRestart
[17:40:58.123]                     is.null <- base::is.null
[17:40:58.123]                     muffled <- FALSE
[17:40:58.123]                     if (inherits(cond, "message")) {
[17:40:58.123]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.123]                       if (muffled) 
[17:40:58.123]                         invokeRestart("muffleMessage")
[17:40:58.123]                     }
[17:40:58.123]                     else if (inherits(cond, "warning")) {
[17:40:58.123]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.123]                       if (muffled) 
[17:40:58.123]                         invokeRestart("muffleWarning")
[17:40:58.123]                     }
[17:40:58.123]                     else if (inherits(cond, "condition")) {
[17:40:58.123]                       if (!is.null(pattern)) {
[17:40:58.123]                         computeRestarts <- base::computeRestarts
[17:40:58.123]                         grepl <- base::grepl
[17:40:58.123]                         restarts <- computeRestarts(cond)
[17:40:58.123]                         for (restart in restarts) {
[17:40:58.123]                           name <- restart$name
[17:40:58.123]                           if (is.null(name)) 
[17:40:58.123]                             next
[17:40:58.123]                           if (!grepl(pattern, name)) 
[17:40:58.123]                             next
[17:40:58.123]                           invokeRestart(restart)
[17:40:58.123]                           muffled <- TRUE
[17:40:58.123]                           break
[17:40:58.123]                         }
[17:40:58.123]                       }
[17:40:58.123]                     }
[17:40:58.123]                     invisible(muffled)
[17:40:58.123]                   }
[17:40:58.123]                   muffleCondition(cond)
[17:40:58.123]                 })
[17:40:58.123]             }))
[17:40:58.123]             future::FutureResult(value = ...future.value$value, 
[17:40:58.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.123]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.123]                     ...future.globalenv.names))
[17:40:58.123]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.123]         }, condition = base::local({
[17:40:58.123]             c <- base::c
[17:40:58.123]             inherits <- base::inherits
[17:40:58.123]             invokeRestart <- base::invokeRestart
[17:40:58.123]             length <- base::length
[17:40:58.123]             list <- base::list
[17:40:58.123]             seq.int <- base::seq.int
[17:40:58.123]             signalCondition <- base::signalCondition
[17:40:58.123]             sys.calls <- base::sys.calls
[17:40:58.123]             `[[` <- base::`[[`
[17:40:58.123]             `+` <- base::`+`
[17:40:58.123]             `<<-` <- base::`<<-`
[17:40:58.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.123]                   3L)]
[17:40:58.123]             }
[17:40:58.123]             function(cond) {
[17:40:58.123]                 is_error <- inherits(cond, "error")
[17:40:58.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.123]                   NULL)
[17:40:58.123]                 if (is_error) {
[17:40:58.123]                   sessionInformation <- function() {
[17:40:58.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.123]                       search = base::search(), system = base::Sys.info())
[17:40:58.123]                   }
[17:40:58.123]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.123]                     cond$call), session = sessionInformation(), 
[17:40:58.123]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.123]                   signalCondition(cond)
[17:40:58.123]                 }
[17:40:58.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.123]                 "immediateCondition"))) {
[17:40:58.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.123]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.123]                   if (TRUE && !signal) {
[17:40:58.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.123]                     {
[17:40:58.123]                       inherits <- base::inherits
[17:40:58.123]                       invokeRestart <- base::invokeRestart
[17:40:58.123]                       is.null <- base::is.null
[17:40:58.123]                       muffled <- FALSE
[17:40:58.123]                       if (inherits(cond, "message")) {
[17:40:58.123]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.123]                         if (muffled) 
[17:40:58.123]                           invokeRestart("muffleMessage")
[17:40:58.123]                       }
[17:40:58.123]                       else if (inherits(cond, "warning")) {
[17:40:58.123]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.123]                         if (muffled) 
[17:40:58.123]                           invokeRestart("muffleWarning")
[17:40:58.123]                       }
[17:40:58.123]                       else if (inherits(cond, "condition")) {
[17:40:58.123]                         if (!is.null(pattern)) {
[17:40:58.123]                           computeRestarts <- base::computeRestarts
[17:40:58.123]                           grepl <- base::grepl
[17:40:58.123]                           restarts <- computeRestarts(cond)
[17:40:58.123]                           for (restart in restarts) {
[17:40:58.123]                             name <- restart$name
[17:40:58.123]                             if (is.null(name)) 
[17:40:58.123]                               next
[17:40:58.123]                             if (!grepl(pattern, name)) 
[17:40:58.123]                               next
[17:40:58.123]                             invokeRestart(restart)
[17:40:58.123]                             muffled <- TRUE
[17:40:58.123]                             break
[17:40:58.123]                           }
[17:40:58.123]                         }
[17:40:58.123]                       }
[17:40:58.123]                       invisible(muffled)
[17:40:58.123]                     }
[17:40:58.123]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.123]                   }
[17:40:58.123]                 }
[17:40:58.123]                 else {
[17:40:58.123]                   if (TRUE) {
[17:40:58.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.123]                     {
[17:40:58.123]                       inherits <- base::inherits
[17:40:58.123]                       invokeRestart <- base::invokeRestart
[17:40:58.123]                       is.null <- base::is.null
[17:40:58.123]                       muffled <- FALSE
[17:40:58.123]                       if (inherits(cond, "message")) {
[17:40:58.123]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.123]                         if (muffled) 
[17:40:58.123]                           invokeRestart("muffleMessage")
[17:40:58.123]                       }
[17:40:58.123]                       else if (inherits(cond, "warning")) {
[17:40:58.123]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.123]                         if (muffled) 
[17:40:58.123]                           invokeRestart("muffleWarning")
[17:40:58.123]                       }
[17:40:58.123]                       else if (inherits(cond, "condition")) {
[17:40:58.123]                         if (!is.null(pattern)) {
[17:40:58.123]                           computeRestarts <- base::computeRestarts
[17:40:58.123]                           grepl <- base::grepl
[17:40:58.123]                           restarts <- computeRestarts(cond)
[17:40:58.123]                           for (restart in restarts) {
[17:40:58.123]                             name <- restart$name
[17:40:58.123]                             if (is.null(name)) 
[17:40:58.123]                               next
[17:40:58.123]                             if (!grepl(pattern, name)) 
[17:40:58.123]                               next
[17:40:58.123]                             invokeRestart(restart)
[17:40:58.123]                             muffled <- TRUE
[17:40:58.123]                             break
[17:40:58.123]                           }
[17:40:58.123]                         }
[17:40:58.123]                       }
[17:40:58.123]                       invisible(muffled)
[17:40:58.123]                     }
[17:40:58.123]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.123]                   }
[17:40:58.123]                 }
[17:40:58.123]             }
[17:40:58.123]         }))
[17:40:58.123]     }, error = function(ex) {
[17:40:58.123]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.123]                 ...future.rng), started = ...future.startTime, 
[17:40:58.123]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.123]             version = "1.8"), class = "FutureResult")
[17:40:58.123]     }, finally = {
[17:40:58.123]         if (!identical(...future.workdir, getwd())) 
[17:40:58.123]             setwd(...future.workdir)
[17:40:58.123]         {
[17:40:58.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.123]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.123]             }
[17:40:58.123]             base::options(...future.oldOptions)
[17:40:58.123]             if (.Platform$OS.type == "windows") {
[17:40:58.123]                 old_names <- names(...future.oldEnvVars)
[17:40:58.123]                 envs <- base::Sys.getenv()
[17:40:58.123]                 names <- names(envs)
[17:40:58.123]                 common <- intersect(names, old_names)
[17:40:58.123]                 added <- setdiff(names, old_names)
[17:40:58.123]                 removed <- setdiff(old_names, names)
[17:40:58.123]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.123]                   envs[common]]
[17:40:58.123]                 NAMES <- toupper(changed)
[17:40:58.123]                 args <- list()
[17:40:58.123]                 for (kk in seq_along(NAMES)) {
[17:40:58.123]                   name <- changed[[kk]]
[17:40:58.123]                   NAME <- NAMES[[kk]]
[17:40:58.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.123]                     next
[17:40:58.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.123]                 }
[17:40:58.123]                 NAMES <- toupper(added)
[17:40:58.123]                 for (kk in seq_along(NAMES)) {
[17:40:58.123]                   name <- added[[kk]]
[17:40:58.123]                   NAME <- NAMES[[kk]]
[17:40:58.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.123]                     next
[17:40:58.123]                   args[[name]] <- ""
[17:40:58.123]                 }
[17:40:58.123]                 NAMES <- toupper(removed)
[17:40:58.123]                 for (kk in seq_along(NAMES)) {
[17:40:58.123]                   name <- removed[[kk]]
[17:40:58.123]                   NAME <- NAMES[[kk]]
[17:40:58.123]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.123]                     next
[17:40:58.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.123]                 }
[17:40:58.123]                 if (length(args) > 0) 
[17:40:58.123]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.123]             }
[17:40:58.123]             else {
[17:40:58.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.123]             }
[17:40:58.123]             {
[17:40:58.123]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.123]                   0L) {
[17:40:58.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.123]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.123]                   base::options(opts)
[17:40:58.123]                 }
[17:40:58.123]                 {
[17:40:58.123]                   {
[17:40:58.123]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.123]                     NULL
[17:40:58.123]                   }
[17:40:58.123]                   options(future.plan = NULL)
[17:40:58.123]                   if (is.na(NA_character_)) 
[17:40:58.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:58.123]                     .init = FALSE)
[17:40:58.123]                 }
[17:40:58.123]             }
[17:40:58.123]         }
[17:40:58.123]     })
[17:40:58.123]     if (TRUE) {
[17:40:58.123]         base::sink(type = "output", split = FALSE)
[17:40:58.123]         if (TRUE) {
[17:40:58.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.123]         }
[17:40:58.123]         else {
[17:40:58.123]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.123]         }
[17:40:58.123]         base::close(...future.stdout)
[17:40:58.123]         ...future.stdout <- NULL
[17:40:58.123]     }
[17:40:58.123]     ...future.result$conditions <- ...future.conditions
[17:40:58.123]     ...future.result$finished <- base::Sys.time()
[17:40:58.123]     ...future.result
[17:40:58.123] }
[17:40:58.126] MultisessionFuture started
[17:40:58.126] - Launch lazy future ... done
[17:40:58.126] run() for ‘MultisessionFuture’ ... done
[17:40:58.629] receiveMessageFromWorker() for ClusterFuture ...
[17:40:58.629] - Validating connection of MultisessionFuture
[17:40:58.629] - received message: FutureResult
[17:40:58.629] - Received FutureResult
[17:40:58.629] - Erased future from FutureRegistry
[17:40:58.630] result() for ClusterFuture ...
[17:40:58.630] - result already collected: FutureResult
[17:40:58.630] result() for ClusterFuture ... done
[17:40:58.630] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:58.630] resolve() on list ...
[17:40:58.630]  recursive: Inf
[17:40:58.630]  length: 2
[17:40:58.630]  elements: ‘a’, ‘b’
[17:40:58.630]  length: 1 (resolved future 1)
[17:40:58.630]  length: 0 (resolved future 2)
[17:40:58.631] resolve() on list ... DONE
[17:40:58.631] A MultisessionFuture was resolved (and resolved itself)
[17:40:58.631] getGlobalsAndPackages() ...
[17:40:58.631] Searching for globals...
[17:40:58.632] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[17:40:58.632] Searching for globals ... DONE
[17:40:58.632] Resolving globals: FALSE
[17:40:58.633] 
[17:40:58.633] 
[17:40:58.633] getGlobalsAndPackages() ... DONE
[17:40:58.633] run() for ‘Future’ ...
[17:40:58.633] - state: ‘created’
[17:40:58.633] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:58.648] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:58.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:58.648]   - Field: ‘node’
[17:40:58.649]   - Field: ‘label’
[17:40:58.649]   - Field: ‘local’
[17:40:58.649]   - Field: ‘owner’
[17:40:58.649]   - Field: ‘envir’
[17:40:58.649]   - Field: ‘workers’
[17:40:58.649]   - Field: ‘packages’
[17:40:58.649]   - Field: ‘gc’
[17:40:58.649]   - Field: ‘conditions’
[17:40:58.649]   - Field: ‘persistent’
[17:40:58.649]   - Field: ‘expr’
[17:40:58.649]   - Field: ‘uuid’
[17:40:58.649]   - Field: ‘seed’
[17:40:58.650]   - Field: ‘version’
[17:40:58.650]   - Field: ‘result’
[17:40:58.650]   - Field: ‘asynchronous’
[17:40:58.650]   - Field: ‘calls’
[17:40:58.650]   - Field: ‘globals’
[17:40:58.650]   - Field: ‘stdout’
[17:40:58.650]   - Field: ‘earlySignal’
[17:40:58.650]   - Field: ‘lazy’
[17:40:58.650]   - Field: ‘state’
[17:40:58.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:58.650] - Launch lazy future ...
[17:40:58.651] Packages needed by the future expression (n = 0): <none>
[17:40:58.651] Packages needed by future strategies (n = 0): <none>
[17:40:58.651] {
[17:40:58.651]     {
[17:40:58.651]         {
[17:40:58.651]             ...future.startTime <- base::Sys.time()
[17:40:58.651]             {
[17:40:58.651]                 {
[17:40:58.651]                   {
[17:40:58.651]                     {
[17:40:58.651]                       base::local({
[17:40:58.651]                         has_future <- base::requireNamespace("future", 
[17:40:58.651]                           quietly = TRUE)
[17:40:58.651]                         if (has_future) {
[17:40:58.651]                           ns <- base::getNamespace("future")
[17:40:58.651]                           version <- ns[[".package"]][["version"]]
[17:40:58.651]                           if (is.null(version)) 
[17:40:58.651]                             version <- utils::packageVersion("future")
[17:40:58.651]                         }
[17:40:58.651]                         else {
[17:40:58.651]                           version <- NULL
[17:40:58.651]                         }
[17:40:58.651]                         if (!has_future || version < "1.8.0") {
[17:40:58.651]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:58.651]                             "", base::R.version$version.string), 
[17:40:58.651]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:58.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:58.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:58.651]                               "release", "version")], collapse = " "), 
[17:40:58.651]                             hostname = base::Sys.info()[["nodename"]])
[17:40:58.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:58.651]                             info)
[17:40:58.651]                           info <- base::paste(info, collapse = "; ")
[17:40:58.651]                           if (!has_future) {
[17:40:58.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:58.651]                               info)
[17:40:58.651]                           }
[17:40:58.651]                           else {
[17:40:58.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:58.651]                               info, version)
[17:40:58.651]                           }
[17:40:58.651]                           base::stop(msg)
[17:40:58.651]                         }
[17:40:58.651]                       })
[17:40:58.651]                     }
[17:40:58.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:58.651]                     base::options(mc.cores = 1L)
[17:40:58.651]                   }
[17:40:58.651]                   ...future.strategy.old <- future::plan("list")
[17:40:58.651]                   options(future.plan = NULL)
[17:40:58.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:58.651]                 }
[17:40:58.651]                 ...future.workdir <- getwd()
[17:40:58.651]             }
[17:40:58.651]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:58.651]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:58.651]         }
[17:40:58.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:58.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:58.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:58.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:58.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:58.651]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:58.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:58.651]             base::names(...future.oldOptions))
[17:40:58.651]     }
[17:40:58.651]     if (FALSE) {
[17:40:58.651]     }
[17:40:58.651]     else {
[17:40:58.651]         if (TRUE) {
[17:40:58.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:58.651]                 open = "w")
[17:40:58.651]         }
[17:40:58.651]         else {
[17:40:58.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:58.651]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:58.651]         }
[17:40:58.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:58.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:58.651]             base::sink(type = "output", split = FALSE)
[17:40:58.651]             base::close(...future.stdout)
[17:40:58.651]         }, add = TRUE)
[17:40:58.651]     }
[17:40:58.651]     ...future.frame <- base::sys.nframe()
[17:40:58.651]     ...future.conditions <- base::list()
[17:40:58.651]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:58.651]     if (FALSE) {
[17:40:58.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:58.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:58.651]     }
[17:40:58.651]     ...future.result <- base::tryCatch({
[17:40:58.651]         base::withCallingHandlers({
[17:40:58.651]             ...future.value <- base::withVisible(base::local({
[17:40:58.651]                 ...future.makeSendCondition <- base::local({
[17:40:58.651]                   sendCondition <- NULL
[17:40:58.651]                   function(frame = 1L) {
[17:40:58.651]                     if (is.function(sendCondition)) 
[17:40:58.651]                       return(sendCondition)
[17:40:58.651]                     ns <- getNamespace("parallel")
[17:40:58.651]                     if (exists("sendData", mode = "function", 
[17:40:58.651]                       envir = ns)) {
[17:40:58.651]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:58.651]                         envir = ns)
[17:40:58.651]                       envir <- sys.frame(frame)
[17:40:58.651]                       master <- NULL
[17:40:58.651]                       while (!identical(envir, .GlobalEnv) && 
[17:40:58.651]                         !identical(envir, emptyenv())) {
[17:40:58.651]                         if (exists("master", mode = "list", envir = envir, 
[17:40:58.651]                           inherits = FALSE)) {
[17:40:58.651]                           master <- get("master", mode = "list", 
[17:40:58.651]                             envir = envir, inherits = FALSE)
[17:40:58.651]                           if (inherits(master, c("SOCKnode", 
[17:40:58.651]                             "SOCK0node"))) {
[17:40:58.651]                             sendCondition <<- function(cond) {
[17:40:58.651]                               data <- list(type = "VALUE", value = cond, 
[17:40:58.651]                                 success = TRUE)
[17:40:58.651]                               parallel_sendData(master, data)
[17:40:58.651]                             }
[17:40:58.651]                             return(sendCondition)
[17:40:58.651]                           }
[17:40:58.651]                         }
[17:40:58.651]                         frame <- frame + 1L
[17:40:58.651]                         envir <- sys.frame(frame)
[17:40:58.651]                       }
[17:40:58.651]                     }
[17:40:58.651]                     sendCondition <<- function(cond) NULL
[17:40:58.651]                   }
[17:40:58.651]                 })
[17:40:58.651]                 withCallingHandlers({
[17:40:58.651]                   {
[17:40:58.651]                     Sys.sleep(0.5)
[17:40:58.651]                     list(a = 1, b = 42L)
[17:40:58.651]                   }
[17:40:58.651]                 }, immediateCondition = function(cond) {
[17:40:58.651]                   sendCondition <- ...future.makeSendCondition()
[17:40:58.651]                   sendCondition(cond)
[17:40:58.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.651]                   {
[17:40:58.651]                     inherits <- base::inherits
[17:40:58.651]                     invokeRestart <- base::invokeRestart
[17:40:58.651]                     is.null <- base::is.null
[17:40:58.651]                     muffled <- FALSE
[17:40:58.651]                     if (inherits(cond, "message")) {
[17:40:58.651]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:58.651]                       if (muffled) 
[17:40:58.651]                         invokeRestart("muffleMessage")
[17:40:58.651]                     }
[17:40:58.651]                     else if (inherits(cond, "warning")) {
[17:40:58.651]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:58.651]                       if (muffled) 
[17:40:58.651]                         invokeRestart("muffleWarning")
[17:40:58.651]                     }
[17:40:58.651]                     else if (inherits(cond, "condition")) {
[17:40:58.651]                       if (!is.null(pattern)) {
[17:40:58.651]                         computeRestarts <- base::computeRestarts
[17:40:58.651]                         grepl <- base::grepl
[17:40:58.651]                         restarts <- computeRestarts(cond)
[17:40:58.651]                         for (restart in restarts) {
[17:40:58.651]                           name <- restart$name
[17:40:58.651]                           if (is.null(name)) 
[17:40:58.651]                             next
[17:40:58.651]                           if (!grepl(pattern, name)) 
[17:40:58.651]                             next
[17:40:58.651]                           invokeRestart(restart)
[17:40:58.651]                           muffled <- TRUE
[17:40:58.651]                           break
[17:40:58.651]                         }
[17:40:58.651]                       }
[17:40:58.651]                     }
[17:40:58.651]                     invisible(muffled)
[17:40:58.651]                   }
[17:40:58.651]                   muffleCondition(cond)
[17:40:58.651]                 })
[17:40:58.651]             }))
[17:40:58.651]             future::FutureResult(value = ...future.value$value, 
[17:40:58.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.651]                   ...future.rng), globalenv = if (FALSE) 
[17:40:58.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:58.651]                     ...future.globalenv.names))
[17:40:58.651]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:58.651]         }, condition = base::local({
[17:40:58.651]             c <- base::c
[17:40:58.651]             inherits <- base::inherits
[17:40:58.651]             invokeRestart <- base::invokeRestart
[17:40:58.651]             length <- base::length
[17:40:58.651]             list <- base::list
[17:40:58.651]             seq.int <- base::seq.int
[17:40:58.651]             signalCondition <- base::signalCondition
[17:40:58.651]             sys.calls <- base::sys.calls
[17:40:58.651]             `[[` <- base::`[[`
[17:40:58.651]             `+` <- base::`+`
[17:40:58.651]             `<<-` <- base::`<<-`
[17:40:58.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:58.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:58.651]                   3L)]
[17:40:58.651]             }
[17:40:58.651]             function(cond) {
[17:40:58.651]                 is_error <- inherits(cond, "error")
[17:40:58.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:58.651]                   NULL)
[17:40:58.651]                 if (is_error) {
[17:40:58.651]                   sessionInformation <- function() {
[17:40:58.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:58.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:58.651]                       search = base::search(), system = base::Sys.info())
[17:40:58.651]                   }
[17:40:58.651]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:58.651]                     cond$call), session = sessionInformation(), 
[17:40:58.651]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:58.651]                   signalCondition(cond)
[17:40:58.651]                 }
[17:40:58.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:58.651]                 "immediateCondition"))) {
[17:40:58.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:58.651]                   ...future.conditions[[length(...future.conditions) + 
[17:40:58.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:58.651]                   if (TRUE && !signal) {
[17:40:58.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.651]                     {
[17:40:58.651]                       inherits <- base::inherits
[17:40:58.651]                       invokeRestart <- base::invokeRestart
[17:40:58.651]                       is.null <- base::is.null
[17:40:58.651]                       muffled <- FALSE
[17:40:58.651]                       if (inherits(cond, "message")) {
[17:40:58.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.651]                         if (muffled) 
[17:40:58.651]                           invokeRestart("muffleMessage")
[17:40:58.651]                       }
[17:40:58.651]                       else if (inherits(cond, "warning")) {
[17:40:58.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.651]                         if (muffled) 
[17:40:58.651]                           invokeRestart("muffleWarning")
[17:40:58.651]                       }
[17:40:58.651]                       else if (inherits(cond, "condition")) {
[17:40:58.651]                         if (!is.null(pattern)) {
[17:40:58.651]                           computeRestarts <- base::computeRestarts
[17:40:58.651]                           grepl <- base::grepl
[17:40:58.651]                           restarts <- computeRestarts(cond)
[17:40:58.651]                           for (restart in restarts) {
[17:40:58.651]                             name <- restart$name
[17:40:58.651]                             if (is.null(name)) 
[17:40:58.651]                               next
[17:40:58.651]                             if (!grepl(pattern, name)) 
[17:40:58.651]                               next
[17:40:58.651]                             invokeRestart(restart)
[17:40:58.651]                             muffled <- TRUE
[17:40:58.651]                             break
[17:40:58.651]                           }
[17:40:58.651]                         }
[17:40:58.651]                       }
[17:40:58.651]                       invisible(muffled)
[17:40:58.651]                     }
[17:40:58.651]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.651]                   }
[17:40:58.651]                 }
[17:40:58.651]                 else {
[17:40:58.651]                   if (TRUE) {
[17:40:58.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:58.651]                     {
[17:40:58.651]                       inherits <- base::inherits
[17:40:58.651]                       invokeRestart <- base::invokeRestart
[17:40:58.651]                       is.null <- base::is.null
[17:40:58.651]                       muffled <- FALSE
[17:40:58.651]                       if (inherits(cond, "message")) {
[17:40:58.651]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:58.651]                         if (muffled) 
[17:40:58.651]                           invokeRestart("muffleMessage")
[17:40:58.651]                       }
[17:40:58.651]                       else if (inherits(cond, "warning")) {
[17:40:58.651]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:58.651]                         if (muffled) 
[17:40:58.651]                           invokeRestart("muffleWarning")
[17:40:58.651]                       }
[17:40:58.651]                       else if (inherits(cond, "condition")) {
[17:40:58.651]                         if (!is.null(pattern)) {
[17:40:58.651]                           computeRestarts <- base::computeRestarts
[17:40:58.651]                           grepl <- base::grepl
[17:40:58.651]                           restarts <- computeRestarts(cond)
[17:40:58.651]                           for (restart in restarts) {
[17:40:58.651]                             name <- restart$name
[17:40:58.651]                             if (is.null(name)) 
[17:40:58.651]                               next
[17:40:58.651]                             if (!grepl(pattern, name)) 
[17:40:58.651]                               next
[17:40:58.651]                             invokeRestart(restart)
[17:40:58.651]                             muffled <- TRUE
[17:40:58.651]                             break
[17:40:58.651]                           }
[17:40:58.651]                         }
[17:40:58.651]                       }
[17:40:58.651]                       invisible(muffled)
[17:40:58.651]                     }
[17:40:58.651]                     muffleCondition(cond, pattern = "^muffle")
[17:40:58.651]                   }
[17:40:58.651]                 }
[17:40:58.651]             }
[17:40:58.651]         }))
[17:40:58.651]     }, error = function(ex) {
[17:40:58.651]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:58.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:58.651]                 ...future.rng), started = ...future.startTime, 
[17:40:58.651]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:58.651]             version = "1.8"), class = "FutureResult")
[17:40:58.651]     }, finally = {
[17:40:58.651]         if (!identical(...future.workdir, getwd())) 
[17:40:58.651]             setwd(...future.workdir)
[17:40:58.651]         {
[17:40:58.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:58.651]                 ...future.oldOptions$nwarnings <- NULL
[17:40:58.651]             }
[17:40:58.651]             base::options(...future.oldOptions)
[17:40:58.651]             if (.Platform$OS.type == "windows") {
[17:40:58.651]                 old_names <- names(...future.oldEnvVars)
[17:40:58.651]                 envs <- base::Sys.getenv()
[17:40:58.651]                 names <- names(envs)
[17:40:58.651]                 common <- intersect(names, old_names)
[17:40:58.651]                 added <- setdiff(names, old_names)
[17:40:58.651]                 removed <- setdiff(old_names, names)
[17:40:58.651]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:58.651]                   envs[common]]
[17:40:58.651]                 NAMES <- toupper(changed)
[17:40:58.651]                 args <- list()
[17:40:58.651]                 for (kk in seq_along(NAMES)) {
[17:40:58.651]                   name <- changed[[kk]]
[17:40:58.651]                   NAME <- NAMES[[kk]]
[17:40:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.651]                     next
[17:40:58.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.651]                 }
[17:40:58.651]                 NAMES <- toupper(added)
[17:40:58.651]                 for (kk in seq_along(NAMES)) {
[17:40:58.651]                   name <- added[[kk]]
[17:40:58.651]                   NAME <- NAMES[[kk]]
[17:40:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.651]                     next
[17:40:58.651]                   args[[name]] <- ""
[17:40:58.651]                 }
[17:40:58.651]                 NAMES <- toupper(removed)
[17:40:58.651]                 for (kk in seq_along(NAMES)) {
[17:40:58.651]                   name <- removed[[kk]]
[17:40:58.651]                   NAME <- NAMES[[kk]]
[17:40:58.651]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:58.651]                     next
[17:40:58.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:58.651]                 }
[17:40:58.651]                 if (length(args) > 0) 
[17:40:58.651]                   base::do.call(base::Sys.setenv, args = args)
[17:40:58.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:58.651]             }
[17:40:58.651]             else {
[17:40:58.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:58.651]             }
[17:40:58.651]             {
[17:40:58.651]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:58.651]                   0L) {
[17:40:58.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:58.651]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:58.651]                   base::options(opts)
[17:40:58.651]                 }
[17:40:58.651]                 {
[17:40:58.651]                   {
[17:40:58.651]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:58.651]                     NULL
[17:40:58.651]                   }
[17:40:58.651]                   options(future.plan = NULL)
[17:40:58.651]                   if (is.na(NA_character_)) 
[17:40:58.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:58.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:58.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:58.651]                     .init = FALSE)
[17:40:58.651]                 }
[17:40:58.651]             }
[17:40:58.651]         }
[17:40:58.651]     })
[17:40:58.651]     if (TRUE) {
[17:40:58.651]         base::sink(type = "output", split = FALSE)
[17:40:58.651]         if (TRUE) {
[17:40:58.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:58.651]         }
[17:40:58.651]         else {
[17:40:58.651]             ...future.result["stdout"] <- base::list(NULL)
[17:40:58.651]         }
[17:40:58.651]         base::close(...future.stdout)
[17:40:58.651]         ...future.stdout <- NULL
[17:40:58.651]     }
[17:40:58.651]     ...future.result$conditions <- ...future.conditions
[17:40:58.651]     ...future.result$finished <- base::Sys.time()
[17:40:58.651]     ...future.result
[17:40:58.651] }
[17:40:58.654] MultisessionFuture started
[17:40:58.654] - Launch lazy future ... done
[17:40:58.654] run() for ‘MultisessionFuture’ ... done
[17:40:59.157] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.157] - Validating connection of MultisessionFuture
[17:40:59.157] - received message: FutureResult
[17:40:59.157] - Received FutureResult
[17:40:59.158] - Erased future from FutureRegistry
[17:40:59.158] result() for ClusterFuture ...
[17:40:59.158] - result already collected: FutureResult
[17:40:59.158] result() for ClusterFuture ... done
[17:40:59.158] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.158] resolve() on list ...
[17:40:59.158]  recursive: Inf
[17:40:59.158]  length: 2
[17:40:59.158]  elements: ‘a’, ‘b’
[17:40:59.158]  length: 1 (resolved future 1)
[17:40:59.158]  length: 0 (resolved future 2)
[17:40:59.159] resolve() on list ... DONE
[17:40:59.159] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[17:40:59.159] getGlobalsAndPackages() ...
[17:40:59.159] Searching for globals...
[17:40:59.160] - globals found: [2] ‘list’, ‘stop’
[17:40:59.160] Searching for globals ... DONE
[17:40:59.160] Resolving globals: FALSE
[17:40:59.160] 
[17:40:59.160] 
[17:40:59.160] getGlobalsAndPackages() ... DONE
[17:40:59.161] run() for ‘Future’ ...
[17:40:59.161] - state: ‘created’
[17:40:59.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.175]   - Field: ‘node’
[17:40:59.175]   - Field: ‘label’
[17:40:59.175]   - Field: ‘local’
[17:40:59.175]   - Field: ‘owner’
[17:40:59.175]   - Field: ‘envir’
[17:40:59.175]   - Field: ‘workers’
[17:40:59.175]   - Field: ‘packages’
[17:40:59.176]   - Field: ‘gc’
[17:40:59.176]   - Field: ‘conditions’
[17:40:59.176]   - Field: ‘persistent’
[17:40:59.176]   - Field: ‘expr’
[17:40:59.176]   - Field: ‘uuid’
[17:40:59.176]   - Field: ‘seed’
[17:40:59.176]   - Field: ‘version’
[17:40:59.176]   - Field: ‘result’
[17:40:59.176]   - Field: ‘asynchronous’
[17:40:59.176]   - Field: ‘calls’
[17:40:59.177]   - Field: ‘globals’
[17:40:59.177]   - Field: ‘stdout’
[17:40:59.177]   - Field: ‘earlySignal’
[17:40:59.177]   - Field: ‘lazy’
[17:40:59.177]   - Field: ‘state’
[17:40:59.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.177] - Launch lazy future ...
[17:40:59.177] Packages needed by the future expression (n = 0): <none>
[17:40:59.177] Packages needed by future strategies (n = 0): <none>
[17:40:59.178] {
[17:40:59.178]     {
[17:40:59.178]         {
[17:40:59.178]             ...future.startTime <- base::Sys.time()
[17:40:59.178]             {
[17:40:59.178]                 {
[17:40:59.178]                   {
[17:40:59.178]                     {
[17:40:59.178]                       base::local({
[17:40:59.178]                         has_future <- base::requireNamespace("future", 
[17:40:59.178]                           quietly = TRUE)
[17:40:59.178]                         if (has_future) {
[17:40:59.178]                           ns <- base::getNamespace("future")
[17:40:59.178]                           version <- ns[[".package"]][["version"]]
[17:40:59.178]                           if (is.null(version)) 
[17:40:59.178]                             version <- utils::packageVersion("future")
[17:40:59.178]                         }
[17:40:59.178]                         else {
[17:40:59.178]                           version <- NULL
[17:40:59.178]                         }
[17:40:59.178]                         if (!has_future || version < "1.8.0") {
[17:40:59.178]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.178]                             "", base::R.version$version.string), 
[17:40:59.178]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.178]                               "release", "version")], collapse = " "), 
[17:40:59.178]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.178]                             info)
[17:40:59.178]                           info <- base::paste(info, collapse = "; ")
[17:40:59.178]                           if (!has_future) {
[17:40:59.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.178]                               info)
[17:40:59.178]                           }
[17:40:59.178]                           else {
[17:40:59.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.178]                               info, version)
[17:40:59.178]                           }
[17:40:59.178]                           base::stop(msg)
[17:40:59.178]                         }
[17:40:59.178]                       })
[17:40:59.178]                     }
[17:40:59.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.178]                     base::options(mc.cores = 1L)
[17:40:59.178]                   }
[17:40:59.178]                   ...future.strategy.old <- future::plan("list")
[17:40:59.178]                   options(future.plan = NULL)
[17:40:59.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.178]                 }
[17:40:59.178]                 ...future.workdir <- getwd()
[17:40:59.178]             }
[17:40:59.178]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.178]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.178]         }
[17:40:59.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.178]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.178]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.178]             base::names(...future.oldOptions))
[17:40:59.178]     }
[17:40:59.178]     if (FALSE) {
[17:40:59.178]     }
[17:40:59.178]     else {
[17:40:59.178]         if (TRUE) {
[17:40:59.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.178]                 open = "w")
[17:40:59.178]         }
[17:40:59.178]         else {
[17:40:59.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.178]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.178]         }
[17:40:59.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.178]             base::sink(type = "output", split = FALSE)
[17:40:59.178]             base::close(...future.stdout)
[17:40:59.178]         }, add = TRUE)
[17:40:59.178]     }
[17:40:59.178]     ...future.frame <- base::sys.nframe()
[17:40:59.178]     ...future.conditions <- base::list()
[17:40:59.178]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.178]     if (FALSE) {
[17:40:59.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.178]     }
[17:40:59.178]     ...future.result <- base::tryCatch({
[17:40:59.178]         base::withCallingHandlers({
[17:40:59.178]             ...future.value <- base::withVisible(base::local({
[17:40:59.178]                 ...future.makeSendCondition <- base::local({
[17:40:59.178]                   sendCondition <- NULL
[17:40:59.178]                   function(frame = 1L) {
[17:40:59.178]                     if (is.function(sendCondition)) 
[17:40:59.178]                       return(sendCondition)
[17:40:59.178]                     ns <- getNamespace("parallel")
[17:40:59.178]                     if (exists("sendData", mode = "function", 
[17:40:59.178]                       envir = ns)) {
[17:40:59.178]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.178]                         envir = ns)
[17:40:59.178]                       envir <- sys.frame(frame)
[17:40:59.178]                       master <- NULL
[17:40:59.178]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.178]                         !identical(envir, emptyenv())) {
[17:40:59.178]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.178]                           inherits = FALSE)) {
[17:40:59.178]                           master <- get("master", mode = "list", 
[17:40:59.178]                             envir = envir, inherits = FALSE)
[17:40:59.178]                           if (inherits(master, c("SOCKnode", 
[17:40:59.178]                             "SOCK0node"))) {
[17:40:59.178]                             sendCondition <<- function(cond) {
[17:40:59.178]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.178]                                 success = TRUE)
[17:40:59.178]                               parallel_sendData(master, data)
[17:40:59.178]                             }
[17:40:59.178]                             return(sendCondition)
[17:40:59.178]                           }
[17:40:59.178]                         }
[17:40:59.178]                         frame <- frame + 1L
[17:40:59.178]                         envir <- sys.frame(frame)
[17:40:59.178]                       }
[17:40:59.178]                     }
[17:40:59.178]                     sendCondition <<- function(cond) NULL
[17:40:59.178]                   }
[17:40:59.178]                 })
[17:40:59.178]                 withCallingHandlers({
[17:40:59.178]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:59.178]                 }, immediateCondition = function(cond) {
[17:40:59.178]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.178]                   sendCondition(cond)
[17:40:59.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.178]                   {
[17:40:59.178]                     inherits <- base::inherits
[17:40:59.178]                     invokeRestart <- base::invokeRestart
[17:40:59.178]                     is.null <- base::is.null
[17:40:59.178]                     muffled <- FALSE
[17:40:59.178]                     if (inherits(cond, "message")) {
[17:40:59.178]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.178]                       if (muffled) 
[17:40:59.178]                         invokeRestart("muffleMessage")
[17:40:59.178]                     }
[17:40:59.178]                     else if (inherits(cond, "warning")) {
[17:40:59.178]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.178]                       if (muffled) 
[17:40:59.178]                         invokeRestart("muffleWarning")
[17:40:59.178]                     }
[17:40:59.178]                     else if (inherits(cond, "condition")) {
[17:40:59.178]                       if (!is.null(pattern)) {
[17:40:59.178]                         computeRestarts <- base::computeRestarts
[17:40:59.178]                         grepl <- base::grepl
[17:40:59.178]                         restarts <- computeRestarts(cond)
[17:40:59.178]                         for (restart in restarts) {
[17:40:59.178]                           name <- restart$name
[17:40:59.178]                           if (is.null(name)) 
[17:40:59.178]                             next
[17:40:59.178]                           if (!grepl(pattern, name)) 
[17:40:59.178]                             next
[17:40:59.178]                           invokeRestart(restart)
[17:40:59.178]                           muffled <- TRUE
[17:40:59.178]                           break
[17:40:59.178]                         }
[17:40:59.178]                       }
[17:40:59.178]                     }
[17:40:59.178]                     invisible(muffled)
[17:40:59.178]                   }
[17:40:59.178]                   muffleCondition(cond)
[17:40:59.178]                 })
[17:40:59.178]             }))
[17:40:59.178]             future::FutureResult(value = ...future.value$value, 
[17:40:59.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.178]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.178]                     ...future.globalenv.names))
[17:40:59.178]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.178]         }, condition = base::local({
[17:40:59.178]             c <- base::c
[17:40:59.178]             inherits <- base::inherits
[17:40:59.178]             invokeRestart <- base::invokeRestart
[17:40:59.178]             length <- base::length
[17:40:59.178]             list <- base::list
[17:40:59.178]             seq.int <- base::seq.int
[17:40:59.178]             signalCondition <- base::signalCondition
[17:40:59.178]             sys.calls <- base::sys.calls
[17:40:59.178]             `[[` <- base::`[[`
[17:40:59.178]             `+` <- base::`+`
[17:40:59.178]             `<<-` <- base::`<<-`
[17:40:59.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.178]                   3L)]
[17:40:59.178]             }
[17:40:59.178]             function(cond) {
[17:40:59.178]                 is_error <- inherits(cond, "error")
[17:40:59.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.178]                   NULL)
[17:40:59.178]                 if (is_error) {
[17:40:59.178]                   sessionInformation <- function() {
[17:40:59.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.178]                       search = base::search(), system = base::Sys.info())
[17:40:59.178]                   }
[17:40:59.178]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.178]                     cond$call), session = sessionInformation(), 
[17:40:59.178]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.178]                   signalCondition(cond)
[17:40:59.178]                 }
[17:40:59.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.178]                 "immediateCondition"))) {
[17:40:59.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.178]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.178]                   if (TRUE && !signal) {
[17:40:59.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.178]                     {
[17:40:59.178]                       inherits <- base::inherits
[17:40:59.178]                       invokeRestart <- base::invokeRestart
[17:40:59.178]                       is.null <- base::is.null
[17:40:59.178]                       muffled <- FALSE
[17:40:59.178]                       if (inherits(cond, "message")) {
[17:40:59.178]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.178]                         if (muffled) 
[17:40:59.178]                           invokeRestart("muffleMessage")
[17:40:59.178]                       }
[17:40:59.178]                       else if (inherits(cond, "warning")) {
[17:40:59.178]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.178]                         if (muffled) 
[17:40:59.178]                           invokeRestart("muffleWarning")
[17:40:59.178]                       }
[17:40:59.178]                       else if (inherits(cond, "condition")) {
[17:40:59.178]                         if (!is.null(pattern)) {
[17:40:59.178]                           computeRestarts <- base::computeRestarts
[17:40:59.178]                           grepl <- base::grepl
[17:40:59.178]                           restarts <- computeRestarts(cond)
[17:40:59.178]                           for (restart in restarts) {
[17:40:59.178]                             name <- restart$name
[17:40:59.178]                             if (is.null(name)) 
[17:40:59.178]                               next
[17:40:59.178]                             if (!grepl(pattern, name)) 
[17:40:59.178]                               next
[17:40:59.178]                             invokeRestart(restart)
[17:40:59.178]                             muffled <- TRUE
[17:40:59.178]                             break
[17:40:59.178]                           }
[17:40:59.178]                         }
[17:40:59.178]                       }
[17:40:59.178]                       invisible(muffled)
[17:40:59.178]                     }
[17:40:59.178]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.178]                   }
[17:40:59.178]                 }
[17:40:59.178]                 else {
[17:40:59.178]                   if (TRUE) {
[17:40:59.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.178]                     {
[17:40:59.178]                       inherits <- base::inherits
[17:40:59.178]                       invokeRestart <- base::invokeRestart
[17:40:59.178]                       is.null <- base::is.null
[17:40:59.178]                       muffled <- FALSE
[17:40:59.178]                       if (inherits(cond, "message")) {
[17:40:59.178]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.178]                         if (muffled) 
[17:40:59.178]                           invokeRestart("muffleMessage")
[17:40:59.178]                       }
[17:40:59.178]                       else if (inherits(cond, "warning")) {
[17:40:59.178]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.178]                         if (muffled) 
[17:40:59.178]                           invokeRestart("muffleWarning")
[17:40:59.178]                       }
[17:40:59.178]                       else if (inherits(cond, "condition")) {
[17:40:59.178]                         if (!is.null(pattern)) {
[17:40:59.178]                           computeRestarts <- base::computeRestarts
[17:40:59.178]                           grepl <- base::grepl
[17:40:59.178]                           restarts <- computeRestarts(cond)
[17:40:59.178]                           for (restart in restarts) {
[17:40:59.178]                             name <- restart$name
[17:40:59.178]                             if (is.null(name)) 
[17:40:59.178]                               next
[17:40:59.178]                             if (!grepl(pattern, name)) 
[17:40:59.178]                               next
[17:40:59.178]                             invokeRestart(restart)
[17:40:59.178]                             muffled <- TRUE
[17:40:59.178]                             break
[17:40:59.178]                           }
[17:40:59.178]                         }
[17:40:59.178]                       }
[17:40:59.178]                       invisible(muffled)
[17:40:59.178]                     }
[17:40:59.178]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.178]                   }
[17:40:59.178]                 }
[17:40:59.178]             }
[17:40:59.178]         }))
[17:40:59.178]     }, error = function(ex) {
[17:40:59.178]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.178]                 ...future.rng), started = ...future.startTime, 
[17:40:59.178]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.178]             version = "1.8"), class = "FutureResult")
[17:40:59.178]     }, finally = {
[17:40:59.178]         if (!identical(...future.workdir, getwd())) 
[17:40:59.178]             setwd(...future.workdir)
[17:40:59.178]         {
[17:40:59.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.178]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.178]             }
[17:40:59.178]             base::options(...future.oldOptions)
[17:40:59.178]             if (.Platform$OS.type == "windows") {
[17:40:59.178]                 old_names <- names(...future.oldEnvVars)
[17:40:59.178]                 envs <- base::Sys.getenv()
[17:40:59.178]                 names <- names(envs)
[17:40:59.178]                 common <- intersect(names, old_names)
[17:40:59.178]                 added <- setdiff(names, old_names)
[17:40:59.178]                 removed <- setdiff(old_names, names)
[17:40:59.178]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.178]                   envs[common]]
[17:40:59.178]                 NAMES <- toupper(changed)
[17:40:59.178]                 args <- list()
[17:40:59.178]                 for (kk in seq_along(NAMES)) {
[17:40:59.178]                   name <- changed[[kk]]
[17:40:59.178]                   NAME <- NAMES[[kk]]
[17:40:59.178]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.178]                     next
[17:40:59.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.178]                 }
[17:40:59.178]                 NAMES <- toupper(added)
[17:40:59.178]                 for (kk in seq_along(NAMES)) {
[17:40:59.178]                   name <- added[[kk]]
[17:40:59.178]                   NAME <- NAMES[[kk]]
[17:40:59.178]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.178]                     next
[17:40:59.178]                   args[[name]] <- ""
[17:40:59.178]                 }
[17:40:59.178]                 NAMES <- toupper(removed)
[17:40:59.178]                 for (kk in seq_along(NAMES)) {
[17:40:59.178]                   name <- removed[[kk]]
[17:40:59.178]                   NAME <- NAMES[[kk]]
[17:40:59.178]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.178]                     next
[17:40:59.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.178]                 }
[17:40:59.178]                 if (length(args) > 0) 
[17:40:59.178]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.178]             }
[17:40:59.178]             else {
[17:40:59.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.178]             }
[17:40:59.178]             {
[17:40:59.178]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.178]                   0L) {
[17:40:59.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.178]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.178]                   base::options(opts)
[17:40:59.178]                 }
[17:40:59.178]                 {
[17:40:59.178]                   {
[17:40:59.178]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.178]                     NULL
[17:40:59.178]                   }
[17:40:59.178]                   options(future.plan = NULL)
[17:40:59.178]                   if (is.na(NA_character_)) 
[17:40:59.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.178]                     .init = FALSE)
[17:40:59.178]                 }
[17:40:59.178]             }
[17:40:59.178]         }
[17:40:59.178]     })
[17:40:59.178]     if (TRUE) {
[17:40:59.178]         base::sink(type = "output", split = FALSE)
[17:40:59.178]         if (TRUE) {
[17:40:59.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.178]         }
[17:40:59.178]         else {
[17:40:59.178]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.178]         }
[17:40:59.178]         base::close(...future.stdout)
[17:40:59.178]         ...future.stdout <- NULL
[17:40:59.178]     }
[17:40:59.178]     ...future.result$conditions <- ...future.conditions
[17:40:59.178]     ...future.result$finished <- base::Sys.time()
[17:40:59.178]     ...future.result
[17:40:59.178] }
[17:40:59.181] MultisessionFuture started
[17:40:59.181] - Launch lazy future ... done
[17:40:59.181] run() for ‘MultisessionFuture’ ... done
[17:40:59.183] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.183] - Validating connection of MultisessionFuture
[17:40:59.183] - received message: FutureResult
[17:40:59.183] - Received FutureResult
[17:40:59.183] - Erased future from FutureRegistry
[17:40:59.183] result() for ClusterFuture ...
[17:40:59.184] - result already collected: FutureResult
[17:40:59.184] result() for ClusterFuture ... done
[17:40:59.184] signalConditions() ...
[17:40:59.184]  - include = ‘immediateCondition’
[17:40:59.184]  - exclude = 
[17:40:59.184]  - resignal = FALSE
[17:40:59.184]  - Number of conditions: 1
[17:40:59.184] signalConditions() ... done
[17:40:59.184] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.184] A MultisessionFuture was resolved (and resolved itself)
[17:40:59.184] getGlobalsAndPackages() ...
[17:40:59.185] Searching for globals...
[17:40:59.185] - globals found: [2] ‘list’, ‘stop’
[17:40:59.185] Searching for globals ... DONE
[17:40:59.185] Resolving globals: FALSE
[17:40:59.186] 
[17:40:59.186] 
[17:40:59.186] getGlobalsAndPackages() ... DONE
[17:40:59.186] run() for ‘Future’ ...
[17:40:59.186] - state: ‘created’
[17:40:59.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.199] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.200] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.200]   - Field: ‘node’
[17:40:59.200]   - Field: ‘label’
[17:40:59.200]   - Field: ‘local’
[17:40:59.200]   - Field: ‘owner’
[17:40:59.200]   - Field: ‘envir’
[17:40:59.200]   - Field: ‘workers’
[17:40:59.200]   - Field: ‘packages’
[17:40:59.200]   - Field: ‘gc’
[17:40:59.201]   - Field: ‘conditions’
[17:40:59.201]   - Field: ‘persistent’
[17:40:59.201]   - Field: ‘expr’
[17:40:59.201]   - Field: ‘uuid’
[17:40:59.201]   - Field: ‘seed’
[17:40:59.201]   - Field: ‘version’
[17:40:59.201]   - Field: ‘result’
[17:40:59.201]   - Field: ‘asynchronous’
[17:40:59.201]   - Field: ‘calls’
[17:40:59.201]   - Field: ‘globals’
[17:40:59.201]   - Field: ‘stdout’
[17:40:59.201]   - Field: ‘earlySignal’
[17:40:59.202]   - Field: ‘lazy’
[17:40:59.202]   - Field: ‘state’
[17:40:59.202] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.202] - Launch lazy future ...
[17:40:59.202] Packages needed by the future expression (n = 0): <none>
[17:40:59.202] Packages needed by future strategies (n = 0): <none>
[17:40:59.203] {
[17:40:59.203]     {
[17:40:59.203]         {
[17:40:59.203]             ...future.startTime <- base::Sys.time()
[17:40:59.203]             {
[17:40:59.203]                 {
[17:40:59.203]                   {
[17:40:59.203]                     {
[17:40:59.203]                       base::local({
[17:40:59.203]                         has_future <- base::requireNamespace("future", 
[17:40:59.203]                           quietly = TRUE)
[17:40:59.203]                         if (has_future) {
[17:40:59.203]                           ns <- base::getNamespace("future")
[17:40:59.203]                           version <- ns[[".package"]][["version"]]
[17:40:59.203]                           if (is.null(version)) 
[17:40:59.203]                             version <- utils::packageVersion("future")
[17:40:59.203]                         }
[17:40:59.203]                         else {
[17:40:59.203]                           version <- NULL
[17:40:59.203]                         }
[17:40:59.203]                         if (!has_future || version < "1.8.0") {
[17:40:59.203]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.203]                             "", base::R.version$version.string), 
[17:40:59.203]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.203]                               "release", "version")], collapse = " "), 
[17:40:59.203]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.203]                             info)
[17:40:59.203]                           info <- base::paste(info, collapse = "; ")
[17:40:59.203]                           if (!has_future) {
[17:40:59.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.203]                               info)
[17:40:59.203]                           }
[17:40:59.203]                           else {
[17:40:59.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.203]                               info, version)
[17:40:59.203]                           }
[17:40:59.203]                           base::stop(msg)
[17:40:59.203]                         }
[17:40:59.203]                       })
[17:40:59.203]                     }
[17:40:59.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.203]                     base::options(mc.cores = 1L)
[17:40:59.203]                   }
[17:40:59.203]                   ...future.strategy.old <- future::plan("list")
[17:40:59.203]                   options(future.plan = NULL)
[17:40:59.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.203]                 }
[17:40:59.203]                 ...future.workdir <- getwd()
[17:40:59.203]             }
[17:40:59.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.203]         }
[17:40:59.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.203]             base::names(...future.oldOptions))
[17:40:59.203]     }
[17:40:59.203]     if (FALSE) {
[17:40:59.203]     }
[17:40:59.203]     else {
[17:40:59.203]         if (TRUE) {
[17:40:59.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.203]                 open = "w")
[17:40:59.203]         }
[17:40:59.203]         else {
[17:40:59.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.203]         }
[17:40:59.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.203]             base::sink(type = "output", split = FALSE)
[17:40:59.203]             base::close(...future.stdout)
[17:40:59.203]         }, add = TRUE)
[17:40:59.203]     }
[17:40:59.203]     ...future.frame <- base::sys.nframe()
[17:40:59.203]     ...future.conditions <- base::list()
[17:40:59.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.203]     if (FALSE) {
[17:40:59.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.203]     }
[17:40:59.203]     ...future.result <- base::tryCatch({
[17:40:59.203]         base::withCallingHandlers({
[17:40:59.203]             ...future.value <- base::withVisible(base::local({
[17:40:59.203]                 ...future.makeSendCondition <- base::local({
[17:40:59.203]                   sendCondition <- NULL
[17:40:59.203]                   function(frame = 1L) {
[17:40:59.203]                     if (is.function(sendCondition)) 
[17:40:59.203]                       return(sendCondition)
[17:40:59.203]                     ns <- getNamespace("parallel")
[17:40:59.203]                     if (exists("sendData", mode = "function", 
[17:40:59.203]                       envir = ns)) {
[17:40:59.203]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.203]                         envir = ns)
[17:40:59.203]                       envir <- sys.frame(frame)
[17:40:59.203]                       master <- NULL
[17:40:59.203]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.203]                         !identical(envir, emptyenv())) {
[17:40:59.203]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.203]                           inherits = FALSE)) {
[17:40:59.203]                           master <- get("master", mode = "list", 
[17:40:59.203]                             envir = envir, inherits = FALSE)
[17:40:59.203]                           if (inherits(master, c("SOCKnode", 
[17:40:59.203]                             "SOCK0node"))) {
[17:40:59.203]                             sendCondition <<- function(cond) {
[17:40:59.203]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.203]                                 success = TRUE)
[17:40:59.203]                               parallel_sendData(master, data)
[17:40:59.203]                             }
[17:40:59.203]                             return(sendCondition)
[17:40:59.203]                           }
[17:40:59.203]                         }
[17:40:59.203]                         frame <- frame + 1L
[17:40:59.203]                         envir <- sys.frame(frame)
[17:40:59.203]                       }
[17:40:59.203]                     }
[17:40:59.203]                     sendCondition <<- function(cond) NULL
[17:40:59.203]                   }
[17:40:59.203]                 })
[17:40:59.203]                 withCallingHandlers({
[17:40:59.203]                   list(a = 1, b = 42L, c = stop("Nah!"))
[17:40:59.203]                 }, immediateCondition = function(cond) {
[17:40:59.203]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.203]                   sendCondition(cond)
[17:40:59.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.203]                   {
[17:40:59.203]                     inherits <- base::inherits
[17:40:59.203]                     invokeRestart <- base::invokeRestart
[17:40:59.203]                     is.null <- base::is.null
[17:40:59.203]                     muffled <- FALSE
[17:40:59.203]                     if (inherits(cond, "message")) {
[17:40:59.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.203]                       if (muffled) 
[17:40:59.203]                         invokeRestart("muffleMessage")
[17:40:59.203]                     }
[17:40:59.203]                     else if (inherits(cond, "warning")) {
[17:40:59.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.203]                       if (muffled) 
[17:40:59.203]                         invokeRestart("muffleWarning")
[17:40:59.203]                     }
[17:40:59.203]                     else if (inherits(cond, "condition")) {
[17:40:59.203]                       if (!is.null(pattern)) {
[17:40:59.203]                         computeRestarts <- base::computeRestarts
[17:40:59.203]                         grepl <- base::grepl
[17:40:59.203]                         restarts <- computeRestarts(cond)
[17:40:59.203]                         for (restart in restarts) {
[17:40:59.203]                           name <- restart$name
[17:40:59.203]                           if (is.null(name)) 
[17:40:59.203]                             next
[17:40:59.203]                           if (!grepl(pattern, name)) 
[17:40:59.203]                             next
[17:40:59.203]                           invokeRestart(restart)
[17:40:59.203]                           muffled <- TRUE
[17:40:59.203]                           break
[17:40:59.203]                         }
[17:40:59.203]                       }
[17:40:59.203]                     }
[17:40:59.203]                     invisible(muffled)
[17:40:59.203]                   }
[17:40:59.203]                   muffleCondition(cond)
[17:40:59.203]                 })
[17:40:59.203]             }))
[17:40:59.203]             future::FutureResult(value = ...future.value$value, 
[17:40:59.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.203]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.203]                     ...future.globalenv.names))
[17:40:59.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.203]         }, condition = base::local({
[17:40:59.203]             c <- base::c
[17:40:59.203]             inherits <- base::inherits
[17:40:59.203]             invokeRestart <- base::invokeRestart
[17:40:59.203]             length <- base::length
[17:40:59.203]             list <- base::list
[17:40:59.203]             seq.int <- base::seq.int
[17:40:59.203]             signalCondition <- base::signalCondition
[17:40:59.203]             sys.calls <- base::sys.calls
[17:40:59.203]             `[[` <- base::`[[`
[17:40:59.203]             `+` <- base::`+`
[17:40:59.203]             `<<-` <- base::`<<-`
[17:40:59.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.203]                   3L)]
[17:40:59.203]             }
[17:40:59.203]             function(cond) {
[17:40:59.203]                 is_error <- inherits(cond, "error")
[17:40:59.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.203]                   NULL)
[17:40:59.203]                 if (is_error) {
[17:40:59.203]                   sessionInformation <- function() {
[17:40:59.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.203]                       search = base::search(), system = base::Sys.info())
[17:40:59.203]                   }
[17:40:59.203]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.203]                     cond$call), session = sessionInformation(), 
[17:40:59.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.203]                   signalCondition(cond)
[17:40:59.203]                 }
[17:40:59.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.203]                 "immediateCondition"))) {
[17:40:59.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.203]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.203]                   if (TRUE && !signal) {
[17:40:59.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.203]                     {
[17:40:59.203]                       inherits <- base::inherits
[17:40:59.203]                       invokeRestart <- base::invokeRestart
[17:40:59.203]                       is.null <- base::is.null
[17:40:59.203]                       muffled <- FALSE
[17:40:59.203]                       if (inherits(cond, "message")) {
[17:40:59.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.203]                         if (muffled) 
[17:40:59.203]                           invokeRestart("muffleMessage")
[17:40:59.203]                       }
[17:40:59.203]                       else if (inherits(cond, "warning")) {
[17:40:59.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.203]                         if (muffled) 
[17:40:59.203]                           invokeRestart("muffleWarning")
[17:40:59.203]                       }
[17:40:59.203]                       else if (inherits(cond, "condition")) {
[17:40:59.203]                         if (!is.null(pattern)) {
[17:40:59.203]                           computeRestarts <- base::computeRestarts
[17:40:59.203]                           grepl <- base::grepl
[17:40:59.203]                           restarts <- computeRestarts(cond)
[17:40:59.203]                           for (restart in restarts) {
[17:40:59.203]                             name <- restart$name
[17:40:59.203]                             if (is.null(name)) 
[17:40:59.203]                               next
[17:40:59.203]                             if (!grepl(pattern, name)) 
[17:40:59.203]                               next
[17:40:59.203]                             invokeRestart(restart)
[17:40:59.203]                             muffled <- TRUE
[17:40:59.203]                             break
[17:40:59.203]                           }
[17:40:59.203]                         }
[17:40:59.203]                       }
[17:40:59.203]                       invisible(muffled)
[17:40:59.203]                     }
[17:40:59.203]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.203]                   }
[17:40:59.203]                 }
[17:40:59.203]                 else {
[17:40:59.203]                   if (TRUE) {
[17:40:59.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.203]                     {
[17:40:59.203]                       inherits <- base::inherits
[17:40:59.203]                       invokeRestart <- base::invokeRestart
[17:40:59.203]                       is.null <- base::is.null
[17:40:59.203]                       muffled <- FALSE
[17:40:59.203]                       if (inherits(cond, "message")) {
[17:40:59.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.203]                         if (muffled) 
[17:40:59.203]                           invokeRestart("muffleMessage")
[17:40:59.203]                       }
[17:40:59.203]                       else if (inherits(cond, "warning")) {
[17:40:59.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.203]                         if (muffled) 
[17:40:59.203]                           invokeRestart("muffleWarning")
[17:40:59.203]                       }
[17:40:59.203]                       else if (inherits(cond, "condition")) {
[17:40:59.203]                         if (!is.null(pattern)) {
[17:40:59.203]                           computeRestarts <- base::computeRestarts
[17:40:59.203]                           grepl <- base::grepl
[17:40:59.203]                           restarts <- computeRestarts(cond)
[17:40:59.203]                           for (restart in restarts) {
[17:40:59.203]                             name <- restart$name
[17:40:59.203]                             if (is.null(name)) 
[17:40:59.203]                               next
[17:40:59.203]                             if (!grepl(pattern, name)) 
[17:40:59.203]                               next
[17:40:59.203]                             invokeRestart(restart)
[17:40:59.203]                             muffled <- TRUE
[17:40:59.203]                             break
[17:40:59.203]                           }
[17:40:59.203]                         }
[17:40:59.203]                       }
[17:40:59.203]                       invisible(muffled)
[17:40:59.203]                     }
[17:40:59.203]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.203]                   }
[17:40:59.203]                 }
[17:40:59.203]             }
[17:40:59.203]         }))
[17:40:59.203]     }, error = function(ex) {
[17:40:59.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.203]                 ...future.rng), started = ...future.startTime, 
[17:40:59.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.203]             version = "1.8"), class = "FutureResult")
[17:40:59.203]     }, finally = {
[17:40:59.203]         if (!identical(...future.workdir, getwd())) 
[17:40:59.203]             setwd(...future.workdir)
[17:40:59.203]         {
[17:40:59.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.203]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.203]             }
[17:40:59.203]             base::options(...future.oldOptions)
[17:40:59.203]             if (.Platform$OS.type == "windows") {
[17:40:59.203]                 old_names <- names(...future.oldEnvVars)
[17:40:59.203]                 envs <- base::Sys.getenv()
[17:40:59.203]                 names <- names(envs)
[17:40:59.203]                 common <- intersect(names, old_names)
[17:40:59.203]                 added <- setdiff(names, old_names)
[17:40:59.203]                 removed <- setdiff(old_names, names)
[17:40:59.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.203]                   envs[common]]
[17:40:59.203]                 NAMES <- toupper(changed)
[17:40:59.203]                 args <- list()
[17:40:59.203]                 for (kk in seq_along(NAMES)) {
[17:40:59.203]                   name <- changed[[kk]]
[17:40:59.203]                   NAME <- NAMES[[kk]]
[17:40:59.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.203]                     next
[17:40:59.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.203]                 }
[17:40:59.203]                 NAMES <- toupper(added)
[17:40:59.203]                 for (kk in seq_along(NAMES)) {
[17:40:59.203]                   name <- added[[kk]]
[17:40:59.203]                   NAME <- NAMES[[kk]]
[17:40:59.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.203]                     next
[17:40:59.203]                   args[[name]] <- ""
[17:40:59.203]                 }
[17:40:59.203]                 NAMES <- toupper(removed)
[17:40:59.203]                 for (kk in seq_along(NAMES)) {
[17:40:59.203]                   name <- removed[[kk]]
[17:40:59.203]                   NAME <- NAMES[[kk]]
[17:40:59.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.203]                     next
[17:40:59.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.203]                 }
[17:40:59.203]                 if (length(args) > 0) 
[17:40:59.203]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.203]             }
[17:40:59.203]             else {
[17:40:59.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.203]             }
[17:40:59.203]             {
[17:40:59.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.203]                   0L) {
[17:40:59.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.203]                   base::options(opts)
[17:40:59.203]                 }
[17:40:59.203]                 {
[17:40:59.203]                   {
[17:40:59.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.203]                     NULL
[17:40:59.203]                   }
[17:40:59.203]                   options(future.plan = NULL)
[17:40:59.203]                   if (is.na(NA_character_)) 
[17:40:59.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.203]                     .init = FALSE)
[17:40:59.203]                 }
[17:40:59.203]             }
[17:40:59.203]         }
[17:40:59.203]     })
[17:40:59.203]     if (TRUE) {
[17:40:59.203]         base::sink(type = "output", split = FALSE)
[17:40:59.203]         if (TRUE) {
[17:40:59.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.203]         }
[17:40:59.203]         else {
[17:40:59.203]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.203]         }
[17:40:59.203]         base::close(...future.stdout)
[17:40:59.203]         ...future.stdout <- NULL
[17:40:59.203]     }
[17:40:59.203]     ...future.result$conditions <- ...future.conditions
[17:40:59.203]     ...future.result$finished <- base::Sys.time()
[17:40:59.203]     ...future.result
[17:40:59.203] }
[17:40:59.205] MultisessionFuture started
[17:40:59.205] - Launch lazy future ... done
[17:40:59.206] run() for ‘MultisessionFuture’ ... done
[17:40:59.207] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.207] - Validating connection of MultisessionFuture
[17:40:59.207] - received message: FutureResult
[17:40:59.208] - Received FutureResult
[17:40:59.208] - Erased future from FutureRegistry
[17:40:59.208] result() for ClusterFuture ...
[17:40:59.208] - result already collected: FutureResult
[17:40:59.208] result() for ClusterFuture ... done
[17:40:59.208] signalConditions() ...
[17:40:59.208]  - include = ‘immediateCondition’
[17:40:59.208]  - exclude = 
[17:40:59.208]  - resignal = FALSE
[17:40:59.208]  - Number of conditions: 1
[17:40:59.208] signalConditions() ... done
[17:40:59.209] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.209] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[17:40:59.209] resolve() on list ...
[17:40:59.209]  recursive: 0
[17:40:59.209]  length: 2
[17:40:59.209]  elements: ‘a’, ‘b’
[17:40:59.209]  length: 1 (resolved future 1)
[17:40:59.209]  length: 0 (resolved future 2)
[17:40:59.210] resolve() on list ... DONE
[17:40:59.210] getGlobalsAndPackages() ...
[17:40:59.210] Searching for globals...
[17:40:59.210] 
[17:40:59.210] Searching for globals ... DONE
[17:40:59.210] - globals: [0] <none>
[17:40:59.210] getGlobalsAndPackages() ... DONE
[17:40:59.210] run() for ‘Future’ ...
[17:40:59.211] - state: ‘created’
[17:40:59.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.224]   - Field: ‘node’
[17:40:59.224]   - Field: ‘label’
[17:40:59.224]   - Field: ‘local’
[17:40:59.225]   - Field: ‘owner’
[17:40:59.225]   - Field: ‘envir’
[17:40:59.225]   - Field: ‘workers’
[17:40:59.225]   - Field: ‘packages’
[17:40:59.225]   - Field: ‘gc’
[17:40:59.225]   - Field: ‘conditions’
[17:40:59.225]   - Field: ‘persistent’
[17:40:59.225]   - Field: ‘expr’
[17:40:59.225]   - Field: ‘uuid’
[17:40:59.225]   - Field: ‘seed’
[17:40:59.225]   - Field: ‘version’
[17:40:59.225]   - Field: ‘result’
[17:40:59.226]   - Field: ‘asynchronous’
[17:40:59.226]   - Field: ‘calls’
[17:40:59.226]   - Field: ‘globals’
[17:40:59.226]   - Field: ‘stdout’
[17:40:59.226]   - Field: ‘earlySignal’
[17:40:59.226]   - Field: ‘lazy’
[17:40:59.226]   - Field: ‘state’
[17:40:59.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.226] - Launch lazy future ...
[17:40:59.227] Packages needed by the future expression (n = 0): <none>
[17:40:59.227] Packages needed by future strategies (n = 0): <none>
[17:40:59.227] {
[17:40:59.227]     {
[17:40:59.227]         {
[17:40:59.227]             ...future.startTime <- base::Sys.time()
[17:40:59.227]             {
[17:40:59.227]                 {
[17:40:59.227]                   {
[17:40:59.227]                     {
[17:40:59.227]                       base::local({
[17:40:59.227]                         has_future <- base::requireNamespace("future", 
[17:40:59.227]                           quietly = TRUE)
[17:40:59.227]                         if (has_future) {
[17:40:59.227]                           ns <- base::getNamespace("future")
[17:40:59.227]                           version <- ns[[".package"]][["version"]]
[17:40:59.227]                           if (is.null(version)) 
[17:40:59.227]                             version <- utils::packageVersion("future")
[17:40:59.227]                         }
[17:40:59.227]                         else {
[17:40:59.227]                           version <- NULL
[17:40:59.227]                         }
[17:40:59.227]                         if (!has_future || version < "1.8.0") {
[17:40:59.227]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.227]                             "", base::R.version$version.string), 
[17:40:59.227]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.227]                               "release", "version")], collapse = " "), 
[17:40:59.227]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.227]                             info)
[17:40:59.227]                           info <- base::paste(info, collapse = "; ")
[17:40:59.227]                           if (!has_future) {
[17:40:59.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.227]                               info)
[17:40:59.227]                           }
[17:40:59.227]                           else {
[17:40:59.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.227]                               info, version)
[17:40:59.227]                           }
[17:40:59.227]                           base::stop(msg)
[17:40:59.227]                         }
[17:40:59.227]                       })
[17:40:59.227]                     }
[17:40:59.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.227]                     base::options(mc.cores = 1L)
[17:40:59.227]                   }
[17:40:59.227]                   ...future.strategy.old <- future::plan("list")
[17:40:59.227]                   options(future.plan = NULL)
[17:40:59.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.227]                 }
[17:40:59.227]                 ...future.workdir <- getwd()
[17:40:59.227]             }
[17:40:59.227]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.227]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.227]         }
[17:40:59.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.227]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.227]             base::names(...future.oldOptions))
[17:40:59.227]     }
[17:40:59.227]     if (FALSE) {
[17:40:59.227]     }
[17:40:59.227]     else {
[17:40:59.227]         if (TRUE) {
[17:40:59.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.227]                 open = "w")
[17:40:59.227]         }
[17:40:59.227]         else {
[17:40:59.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.227]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.227]         }
[17:40:59.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.227]             base::sink(type = "output", split = FALSE)
[17:40:59.227]             base::close(...future.stdout)
[17:40:59.227]         }, add = TRUE)
[17:40:59.227]     }
[17:40:59.227]     ...future.frame <- base::sys.nframe()
[17:40:59.227]     ...future.conditions <- base::list()
[17:40:59.227]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.227]     if (FALSE) {
[17:40:59.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.227]     }
[17:40:59.227]     ...future.result <- base::tryCatch({
[17:40:59.227]         base::withCallingHandlers({
[17:40:59.227]             ...future.value <- base::withVisible(base::local({
[17:40:59.227]                 ...future.makeSendCondition <- base::local({
[17:40:59.227]                   sendCondition <- NULL
[17:40:59.227]                   function(frame = 1L) {
[17:40:59.227]                     if (is.function(sendCondition)) 
[17:40:59.227]                       return(sendCondition)
[17:40:59.227]                     ns <- getNamespace("parallel")
[17:40:59.227]                     if (exists("sendData", mode = "function", 
[17:40:59.227]                       envir = ns)) {
[17:40:59.227]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.227]                         envir = ns)
[17:40:59.227]                       envir <- sys.frame(frame)
[17:40:59.227]                       master <- NULL
[17:40:59.227]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.227]                         !identical(envir, emptyenv())) {
[17:40:59.227]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.227]                           inherits = FALSE)) {
[17:40:59.227]                           master <- get("master", mode = "list", 
[17:40:59.227]                             envir = envir, inherits = FALSE)
[17:40:59.227]                           if (inherits(master, c("SOCKnode", 
[17:40:59.227]                             "SOCK0node"))) {
[17:40:59.227]                             sendCondition <<- function(cond) {
[17:40:59.227]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.227]                                 success = TRUE)
[17:40:59.227]                               parallel_sendData(master, data)
[17:40:59.227]                             }
[17:40:59.227]                             return(sendCondition)
[17:40:59.227]                           }
[17:40:59.227]                         }
[17:40:59.227]                         frame <- frame + 1L
[17:40:59.227]                         envir <- sys.frame(frame)
[17:40:59.227]                       }
[17:40:59.227]                     }
[17:40:59.227]                     sendCondition <<- function(cond) NULL
[17:40:59.227]                   }
[17:40:59.227]                 })
[17:40:59.227]                 withCallingHandlers({
[17:40:59.227]                   1
[17:40:59.227]                 }, immediateCondition = function(cond) {
[17:40:59.227]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.227]                   sendCondition(cond)
[17:40:59.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.227]                   {
[17:40:59.227]                     inherits <- base::inherits
[17:40:59.227]                     invokeRestart <- base::invokeRestart
[17:40:59.227]                     is.null <- base::is.null
[17:40:59.227]                     muffled <- FALSE
[17:40:59.227]                     if (inherits(cond, "message")) {
[17:40:59.227]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.227]                       if (muffled) 
[17:40:59.227]                         invokeRestart("muffleMessage")
[17:40:59.227]                     }
[17:40:59.227]                     else if (inherits(cond, "warning")) {
[17:40:59.227]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.227]                       if (muffled) 
[17:40:59.227]                         invokeRestart("muffleWarning")
[17:40:59.227]                     }
[17:40:59.227]                     else if (inherits(cond, "condition")) {
[17:40:59.227]                       if (!is.null(pattern)) {
[17:40:59.227]                         computeRestarts <- base::computeRestarts
[17:40:59.227]                         grepl <- base::grepl
[17:40:59.227]                         restarts <- computeRestarts(cond)
[17:40:59.227]                         for (restart in restarts) {
[17:40:59.227]                           name <- restart$name
[17:40:59.227]                           if (is.null(name)) 
[17:40:59.227]                             next
[17:40:59.227]                           if (!grepl(pattern, name)) 
[17:40:59.227]                             next
[17:40:59.227]                           invokeRestart(restart)
[17:40:59.227]                           muffled <- TRUE
[17:40:59.227]                           break
[17:40:59.227]                         }
[17:40:59.227]                       }
[17:40:59.227]                     }
[17:40:59.227]                     invisible(muffled)
[17:40:59.227]                   }
[17:40:59.227]                   muffleCondition(cond)
[17:40:59.227]                 })
[17:40:59.227]             }))
[17:40:59.227]             future::FutureResult(value = ...future.value$value, 
[17:40:59.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.227]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.227]                     ...future.globalenv.names))
[17:40:59.227]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.227]         }, condition = base::local({
[17:40:59.227]             c <- base::c
[17:40:59.227]             inherits <- base::inherits
[17:40:59.227]             invokeRestart <- base::invokeRestart
[17:40:59.227]             length <- base::length
[17:40:59.227]             list <- base::list
[17:40:59.227]             seq.int <- base::seq.int
[17:40:59.227]             signalCondition <- base::signalCondition
[17:40:59.227]             sys.calls <- base::sys.calls
[17:40:59.227]             `[[` <- base::`[[`
[17:40:59.227]             `+` <- base::`+`
[17:40:59.227]             `<<-` <- base::`<<-`
[17:40:59.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.227]                   3L)]
[17:40:59.227]             }
[17:40:59.227]             function(cond) {
[17:40:59.227]                 is_error <- inherits(cond, "error")
[17:40:59.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.227]                   NULL)
[17:40:59.227]                 if (is_error) {
[17:40:59.227]                   sessionInformation <- function() {
[17:40:59.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.227]                       search = base::search(), system = base::Sys.info())
[17:40:59.227]                   }
[17:40:59.227]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.227]                     cond$call), session = sessionInformation(), 
[17:40:59.227]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.227]                   signalCondition(cond)
[17:40:59.227]                 }
[17:40:59.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.227]                 "immediateCondition"))) {
[17:40:59.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.227]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.227]                   if (TRUE && !signal) {
[17:40:59.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.227]                     {
[17:40:59.227]                       inherits <- base::inherits
[17:40:59.227]                       invokeRestart <- base::invokeRestart
[17:40:59.227]                       is.null <- base::is.null
[17:40:59.227]                       muffled <- FALSE
[17:40:59.227]                       if (inherits(cond, "message")) {
[17:40:59.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.227]                         if (muffled) 
[17:40:59.227]                           invokeRestart("muffleMessage")
[17:40:59.227]                       }
[17:40:59.227]                       else if (inherits(cond, "warning")) {
[17:40:59.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.227]                         if (muffled) 
[17:40:59.227]                           invokeRestart("muffleWarning")
[17:40:59.227]                       }
[17:40:59.227]                       else if (inherits(cond, "condition")) {
[17:40:59.227]                         if (!is.null(pattern)) {
[17:40:59.227]                           computeRestarts <- base::computeRestarts
[17:40:59.227]                           grepl <- base::grepl
[17:40:59.227]                           restarts <- computeRestarts(cond)
[17:40:59.227]                           for (restart in restarts) {
[17:40:59.227]                             name <- restart$name
[17:40:59.227]                             if (is.null(name)) 
[17:40:59.227]                               next
[17:40:59.227]                             if (!grepl(pattern, name)) 
[17:40:59.227]                               next
[17:40:59.227]                             invokeRestart(restart)
[17:40:59.227]                             muffled <- TRUE
[17:40:59.227]                             break
[17:40:59.227]                           }
[17:40:59.227]                         }
[17:40:59.227]                       }
[17:40:59.227]                       invisible(muffled)
[17:40:59.227]                     }
[17:40:59.227]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.227]                   }
[17:40:59.227]                 }
[17:40:59.227]                 else {
[17:40:59.227]                   if (TRUE) {
[17:40:59.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.227]                     {
[17:40:59.227]                       inherits <- base::inherits
[17:40:59.227]                       invokeRestart <- base::invokeRestart
[17:40:59.227]                       is.null <- base::is.null
[17:40:59.227]                       muffled <- FALSE
[17:40:59.227]                       if (inherits(cond, "message")) {
[17:40:59.227]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.227]                         if (muffled) 
[17:40:59.227]                           invokeRestart("muffleMessage")
[17:40:59.227]                       }
[17:40:59.227]                       else if (inherits(cond, "warning")) {
[17:40:59.227]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.227]                         if (muffled) 
[17:40:59.227]                           invokeRestart("muffleWarning")
[17:40:59.227]                       }
[17:40:59.227]                       else if (inherits(cond, "condition")) {
[17:40:59.227]                         if (!is.null(pattern)) {
[17:40:59.227]                           computeRestarts <- base::computeRestarts
[17:40:59.227]                           grepl <- base::grepl
[17:40:59.227]                           restarts <- computeRestarts(cond)
[17:40:59.227]                           for (restart in restarts) {
[17:40:59.227]                             name <- restart$name
[17:40:59.227]                             if (is.null(name)) 
[17:40:59.227]                               next
[17:40:59.227]                             if (!grepl(pattern, name)) 
[17:40:59.227]                               next
[17:40:59.227]                             invokeRestart(restart)
[17:40:59.227]                             muffled <- TRUE
[17:40:59.227]                             break
[17:40:59.227]                           }
[17:40:59.227]                         }
[17:40:59.227]                       }
[17:40:59.227]                       invisible(muffled)
[17:40:59.227]                     }
[17:40:59.227]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.227]                   }
[17:40:59.227]                 }
[17:40:59.227]             }
[17:40:59.227]         }))
[17:40:59.227]     }, error = function(ex) {
[17:40:59.227]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.227]                 ...future.rng), started = ...future.startTime, 
[17:40:59.227]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.227]             version = "1.8"), class = "FutureResult")
[17:40:59.227]     }, finally = {
[17:40:59.227]         if (!identical(...future.workdir, getwd())) 
[17:40:59.227]             setwd(...future.workdir)
[17:40:59.227]         {
[17:40:59.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.227]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.227]             }
[17:40:59.227]             base::options(...future.oldOptions)
[17:40:59.227]             if (.Platform$OS.type == "windows") {
[17:40:59.227]                 old_names <- names(...future.oldEnvVars)
[17:40:59.227]                 envs <- base::Sys.getenv()
[17:40:59.227]                 names <- names(envs)
[17:40:59.227]                 common <- intersect(names, old_names)
[17:40:59.227]                 added <- setdiff(names, old_names)
[17:40:59.227]                 removed <- setdiff(old_names, names)
[17:40:59.227]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.227]                   envs[common]]
[17:40:59.227]                 NAMES <- toupper(changed)
[17:40:59.227]                 args <- list()
[17:40:59.227]                 for (kk in seq_along(NAMES)) {
[17:40:59.227]                   name <- changed[[kk]]
[17:40:59.227]                   NAME <- NAMES[[kk]]
[17:40:59.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.227]                     next
[17:40:59.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.227]                 }
[17:40:59.227]                 NAMES <- toupper(added)
[17:40:59.227]                 for (kk in seq_along(NAMES)) {
[17:40:59.227]                   name <- added[[kk]]
[17:40:59.227]                   NAME <- NAMES[[kk]]
[17:40:59.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.227]                     next
[17:40:59.227]                   args[[name]] <- ""
[17:40:59.227]                 }
[17:40:59.227]                 NAMES <- toupper(removed)
[17:40:59.227]                 for (kk in seq_along(NAMES)) {
[17:40:59.227]                   name <- removed[[kk]]
[17:40:59.227]                   NAME <- NAMES[[kk]]
[17:40:59.227]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.227]                     next
[17:40:59.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.227]                 }
[17:40:59.227]                 if (length(args) > 0) 
[17:40:59.227]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.227]             }
[17:40:59.227]             else {
[17:40:59.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.227]             }
[17:40:59.227]             {
[17:40:59.227]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.227]                   0L) {
[17:40:59.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.227]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.227]                   base::options(opts)
[17:40:59.227]                 }
[17:40:59.227]                 {
[17:40:59.227]                   {
[17:40:59.227]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.227]                     NULL
[17:40:59.227]                   }
[17:40:59.227]                   options(future.plan = NULL)
[17:40:59.227]                   if (is.na(NA_character_)) 
[17:40:59.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.227]                     .init = FALSE)
[17:40:59.227]                 }
[17:40:59.227]             }
[17:40:59.227]         }
[17:40:59.227]     })
[17:40:59.227]     if (TRUE) {
[17:40:59.227]         base::sink(type = "output", split = FALSE)
[17:40:59.227]         if (TRUE) {
[17:40:59.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.227]         }
[17:40:59.227]         else {
[17:40:59.227]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.227]         }
[17:40:59.227]         base::close(...future.stdout)
[17:40:59.227]         ...future.stdout <- NULL
[17:40:59.227]     }
[17:40:59.227]     ...future.result$conditions <- ...future.conditions
[17:40:59.227]     ...future.result$finished <- base::Sys.time()
[17:40:59.227]     ...future.result
[17:40:59.227] }
[17:40:59.232] MultisessionFuture started
[17:40:59.232] - Launch lazy future ... done
[17:40:59.233] run() for ‘MultisessionFuture’ ... done
[17:40:59.233] getGlobalsAndPackages() ...
[17:40:59.233] Searching for globals...
[17:40:59.233] 
[17:40:59.233] Searching for globals ... DONE
[17:40:59.233] - globals: [0] <none>
[17:40:59.234] getGlobalsAndPackages() ... DONE
[17:40:59.234] run() for ‘Future’ ...
[17:40:59.234] - state: ‘created’
[17:40:59.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.248]   - Field: ‘node’
[17:40:59.248]   - Field: ‘label’
[17:40:59.248]   - Field: ‘local’
[17:40:59.248]   - Field: ‘owner’
[17:40:59.248]   - Field: ‘envir’
[17:40:59.248]   - Field: ‘workers’
[17:40:59.248]   - Field: ‘packages’
[17:40:59.248]   - Field: ‘gc’
[17:40:59.248]   - Field: ‘conditions’
[17:40:59.248]   - Field: ‘persistent’
[17:40:59.248]   - Field: ‘expr’
[17:40:59.249]   - Field: ‘uuid’
[17:40:59.249]   - Field: ‘seed’
[17:40:59.249]   - Field: ‘version’
[17:40:59.249]   - Field: ‘result’
[17:40:59.249]   - Field: ‘asynchronous’
[17:40:59.249]   - Field: ‘calls’
[17:40:59.249]   - Field: ‘globals’
[17:40:59.249]   - Field: ‘stdout’
[17:40:59.249]   - Field: ‘earlySignal’
[17:40:59.249]   - Field: ‘lazy’
[17:40:59.249]   - Field: ‘state’
[17:40:59.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.250] - Launch lazy future ...
[17:40:59.250] Packages needed by the future expression (n = 0): <none>
[17:40:59.250] Packages needed by future strategies (n = 0): <none>
[17:40:59.250] {
[17:40:59.250]     {
[17:40:59.250]         {
[17:40:59.250]             ...future.startTime <- base::Sys.time()
[17:40:59.250]             {
[17:40:59.250]                 {
[17:40:59.250]                   {
[17:40:59.250]                     {
[17:40:59.250]                       base::local({
[17:40:59.250]                         has_future <- base::requireNamespace("future", 
[17:40:59.250]                           quietly = TRUE)
[17:40:59.250]                         if (has_future) {
[17:40:59.250]                           ns <- base::getNamespace("future")
[17:40:59.250]                           version <- ns[[".package"]][["version"]]
[17:40:59.250]                           if (is.null(version)) 
[17:40:59.250]                             version <- utils::packageVersion("future")
[17:40:59.250]                         }
[17:40:59.250]                         else {
[17:40:59.250]                           version <- NULL
[17:40:59.250]                         }
[17:40:59.250]                         if (!has_future || version < "1.8.0") {
[17:40:59.250]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.250]                             "", base::R.version$version.string), 
[17:40:59.250]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.250]                               "release", "version")], collapse = " "), 
[17:40:59.250]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.250]                             info)
[17:40:59.250]                           info <- base::paste(info, collapse = "; ")
[17:40:59.250]                           if (!has_future) {
[17:40:59.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.250]                               info)
[17:40:59.250]                           }
[17:40:59.250]                           else {
[17:40:59.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.250]                               info, version)
[17:40:59.250]                           }
[17:40:59.250]                           base::stop(msg)
[17:40:59.250]                         }
[17:40:59.250]                       })
[17:40:59.250]                     }
[17:40:59.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.250]                     base::options(mc.cores = 1L)
[17:40:59.250]                   }
[17:40:59.250]                   ...future.strategy.old <- future::plan("list")
[17:40:59.250]                   options(future.plan = NULL)
[17:40:59.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.250]                 }
[17:40:59.250]                 ...future.workdir <- getwd()
[17:40:59.250]             }
[17:40:59.250]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.250]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.250]         }
[17:40:59.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.250]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.250]             base::names(...future.oldOptions))
[17:40:59.250]     }
[17:40:59.250]     if (FALSE) {
[17:40:59.250]     }
[17:40:59.250]     else {
[17:40:59.250]         if (TRUE) {
[17:40:59.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.250]                 open = "w")
[17:40:59.250]         }
[17:40:59.250]         else {
[17:40:59.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.250]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.250]         }
[17:40:59.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.250]             base::sink(type = "output", split = FALSE)
[17:40:59.250]             base::close(...future.stdout)
[17:40:59.250]         }, add = TRUE)
[17:40:59.250]     }
[17:40:59.250]     ...future.frame <- base::sys.nframe()
[17:40:59.250]     ...future.conditions <- base::list()
[17:40:59.250]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.250]     if (FALSE) {
[17:40:59.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.250]     }
[17:40:59.250]     ...future.result <- base::tryCatch({
[17:40:59.250]         base::withCallingHandlers({
[17:40:59.250]             ...future.value <- base::withVisible(base::local({
[17:40:59.250]                 ...future.makeSendCondition <- base::local({
[17:40:59.250]                   sendCondition <- NULL
[17:40:59.250]                   function(frame = 1L) {
[17:40:59.250]                     if (is.function(sendCondition)) 
[17:40:59.250]                       return(sendCondition)
[17:40:59.250]                     ns <- getNamespace("parallel")
[17:40:59.250]                     if (exists("sendData", mode = "function", 
[17:40:59.250]                       envir = ns)) {
[17:40:59.250]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.250]                         envir = ns)
[17:40:59.250]                       envir <- sys.frame(frame)
[17:40:59.250]                       master <- NULL
[17:40:59.250]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.250]                         !identical(envir, emptyenv())) {
[17:40:59.250]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.250]                           inherits = FALSE)) {
[17:40:59.250]                           master <- get("master", mode = "list", 
[17:40:59.250]                             envir = envir, inherits = FALSE)
[17:40:59.250]                           if (inherits(master, c("SOCKnode", 
[17:40:59.250]                             "SOCK0node"))) {
[17:40:59.250]                             sendCondition <<- function(cond) {
[17:40:59.250]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.250]                                 success = TRUE)
[17:40:59.250]                               parallel_sendData(master, data)
[17:40:59.250]                             }
[17:40:59.250]                             return(sendCondition)
[17:40:59.250]                           }
[17:40:59.250]                         }
[17:40:59.250]                         frame <- frame + 1L
[17:40:59.250]                         envir <- sys.frame(frame)
[17:40:59.250]                       }
[17:40:59.250]                     }
[17:40:59.250]                     sendCondition <<- function(cond) NULL
[17:40:59.250]                   }
[17:40:59.250]                 })
[17:40:59.250]                 withCallingHandlers({
[17:40:59.250]                   2
[17:40:59.250]                 }, immediateCondition = function(cond) {
[17:40:59.250]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.250]                   sendCondition(cond)
[17:40:59.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.250]                   {
[17:40:59.250]                     inherits <- base::inherits
[17:40:59.250]                     invokeRestart <- base::invokeRestart
[17:40:59.250]                     is.null <- base::is.null
[17:40:59.250]                     muffled <- FALSE
[17:40:59.250]                     if (inherits(cond, "message")) {
[17:40:59.250]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.250]                       if (muffled) 
[17:40:59.250]                         invokeRestart("muffleMessage")
[17:40:59.250]                     }
[17:40:59.250]                     else if (inherits(cond, "warning")) {
[17:40:59.250]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.250]                       if (muffled) 
[17:40:59.250]                         invokeRestart("muffleWarning")
[17:40:59.250]                     }
[17:40:59.250]                     else if (inherits(cond, "condition")) {
[17:40:59.250]                       if (!is.null(pattern)) {
[17:40:59.250]                         computeRestarts <- base::computeRestarts
[17:40:59.250]                         grepl <- base::grepl
[17:40:59.250]                         restarts <- computeRestarts(cond)
[17:40:59.250]                         for (restart in restarts) {
[17:40:59.250]                           name <- restart$name
[17:40:59.250]                           if (is.null(name)) 
[17:40:59.250]                             next
[17:40:59.250]                           if (!grepl(pattern, name)) 
[17:40:59.250]                             next
[17:40:59.250]                           invokeRestart(restart)
[17:40:59.250]                           muffled <- TRUE
[17:40:59.250]                           break
[17:40:59.250]                         }
[17:40:59.250]                       }
[17:40:59.250]                     }
[17:40:59.250]                     invisible(muffled)
[17:40:59.250]                   }
[17:40:59.250]                   muffleCondition(cond)
[17:40:59.250]                 })
[17:40:59.250]             }))
[17:40:59.250]             future::FutureResult(value = ...future.value$value, 
[17:40:59.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.250]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.250]                     ...future.globalenv.names))
[17:40:59.250]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.250]         }, condition = base::local({
[17:40:59.250]             c <- base::c
[17:40:59.250]             inherits <- base::inherits
[17:40:59.250]             invokeRestart <- base::invokeRestart
[17:40:59.250]             length <- base::length
[17:40:59.250]             list <- base::list
[17:40:59.250]             seq.int <- base::seq.int
[17:40:59.250]             signalCondition <- base::signalCondition
[17:40:59.250]             sys.calls <- base::sys.calls
[17:40:59.250]             `[[` <- base::`[[`
[17:40:59.250]             `+` <- base::`+`
[17:40:59.250]             `<<-` <- base::`<<-`
[17:40:59.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.250]                   3L)]
[17:40:59.250]             }
[17:40:59.250]             function(cond) {
[17:40:59.250]                 is_error <- inherits(cond, "error")
[17:40:59.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.250]                   NULL)
[17:40:59.250]                 if (is_error) {
[17:40:59.250]                   sessionInformation <- function() {
[17:40:59.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.250]                       search = base::search(), system = base::Sys.info())
[17:40:59.250]                   }
[17:40:59.250]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.250]                     cond$call), session = sessionInformation(), 
[17:40:59.250]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.250]                   signalCondition(cond)
[17:40:59.250]                 }
[17:40:59.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.250]                 "immediateCondition"))) {
[17:40:59.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.250]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.250]                   if (TRUE && !signal) {
[17:40:59.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.250]                     {
[17:40:59.250]                       inherits <- base::inherits
[17:40:59.250]                       invokeRestart <- base::invokeRestart
[17:40:59.250]                       is.null <- base::is.null
[17:40:59.250]                       muffled <- FALSE
[17:40:59.250]                       if (inherits(cond, "message")) {
[17:40:59.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.250]                         if (muffled) 
[17:40:59.250]                           invokeRestart("muffleMessage")
[17:40:59.250]                       }
[17:40:59.250]                       else if (inherits(cond, "warning")) {
[17:40:59.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.250]                         if (muffled) 
[17:40:59.250]                           invokeRestart("muffleWarning")
[17:40:59.250]                       }
[17:40:59.250]                       else if (inherits(cond, "condition")) {
[17:40:59.250]                         if (!is.null(pattern)) {
[17:40:59.250]                           computeRestarts <- base::computeRestarts
[17:40:59.250]                           grepl <- base::grepl
[17:40:59.250]                           restarts <- computeRestarts(cond)
[17:40:59.250]                           for (restart in restarts) {
[17:40:59.250]                             name <- restart$name
[17:40:59.250]                             if (is.null(name)) 
[17:40:59.250]                               next
[17:40:59.250]                             if (!grepl(pattern, name)) 
[17:40:59.250]                               next
[17:40:59.250]                             invokeRestart(restart)
[17:40:59.250]                             muffled <- TRUE
[17:40:59.250]                             break
[17:40:59.250]                           }
[17:40:59.250]                         }
[17:40:59.250]                       }
[17:40:59.250]                       invisible(muffled)
[17:40:59.250]                     }
[17:40:59.250]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.250]                   }
[17:40:59.250]                 }
[17:40:59.250]                 else {
[17:40:59.250]                   if (TRUE) {
[17:40:59.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.250]                     {
[17:40:59.250]                       inherits <- base::inherits
[17:40:59.250]                       invokeRestart <- base::invokeRestart
[17:40:59.250]                       is.null <- base::is.null
[17:40:59.250]                       muffled <- FALSE
[17:40:59.250]                       if (inherits(cond, "message")) {
[17:40:59.250]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.250]                         if (muffled) 
[17:40:59.250]                           invokeRestart("muffleMessage")
[17:40:59.250]                       }
[17:40:59.250]                       else if (inherits(cond, "warning")) {
[17:40:59.250]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.250]                         if (muffled) 
[17:40:59.250]                           invokeRestart("muffleWarning")
[17:40:59.250]                       }
[17:40:59.250]                       else if (inherits(cond, "condition")) {
[17:40:59.250]                         if (!is.null(pattern)) {
[17:40:59.250]                           computeRestarts <- base::computeRestarts
[17:40:59.250]                           grepl <- base::grepl
[17:40:59.250]                           restarts <- computeRestarts(cond)
[17:40:59.250]                           for (restart in restarts) {
[17:40:59.250]                             name <- restart$name
[17:40:59.250]                             if (is.null(name)) 
[17:40:59.250]                               next
[17:40:59.250]                             if (!grepl(pattern, name)) 
[17:40:59.250]                               next
[17:40:59.250]                             invokeRestart(restart)
[17:40:59.250]                             muffled <- TRUE
[17:40:59.250]                             break
[17:40:59.250]                           }
[17:40:59.250]                         }
[17:40:59.250]                       }
[17:40:59.250]                       invisible(muffled)
[17:40:59.250]                     }
[17:40:59.250]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.250]                   }
[17:40:59.250]                 }
[17:40:59.250]             }
[17:40:59.250]         }))
[17:40:59.250]     }, error = function(ex) {
[17:40:59.250]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.250]                 ...future.rng), started = ...future.startTime, 
[17:40:59.250]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.250]             version = "1.8"), class = "FutureResult")
[17:40:59.250]     }, finally = {
[17:40:59.250]         if (!identical(...future.workdir, getwd())) 
[17:40:59.250]             setwd(...future.workdir)
[17:40:59.250]         {
[17:40:59.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.250]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.250]             }
[17:40:59.250]             base::options(...future.oldOptions)
[17:40:59.250]             if (.Platform$OS.type == "windows") {
[17:40:59.250]                 old_names <- names(...future.oldEnvVars)
[17:40:59.250]                 envs <- base::Sys.getenv()
[17:40:59.250]                 names <- names(envs)
[17:40:59.250]                 common <- intersect(names, old_names)
[17:40:59.250]                 added <- setdiff(names, old_names)
[17:40:59.250]                 removed <- setdiff(old_names, names)
[17:40:59.250]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.250]                   envs[common]]
[17:40:59.250]                 NAMES <- toupper(changed)
[17:40:59.250]                 args <- list()
[17:40:59.250]                 for (kk in seq_along(NAMES)) {
[17:40:59.250]                   name <- changed[[kk]]
[17:40:59.250]                   NAME <- NAMES[[kk]]
[17:40:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.250]                     next
[17:40:59.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.250]                 }
[17:40:59.250]                 NAMES <- toupper(added)
[17:40:59.250]                 for (kk in seq_along(NAMES)) {
[17:40:59.250]                   name <- added[[kk]]
[17:40:59.250]                   NAME <- NAMES[[kk]]
[17:40:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.250]                     next
[17:40:59.250]                   args[[name]] <- ""
[17:40:59.250]                 }
[17:40:59.250]                 NAMES <- toupper(removed)
[17:40:59.250]                 for (kk in seq_along(NAMES)) {
[17:40:59.250]                   name <- removed[[kk]]
[17:40:59.250]                   NAME <- NAMES[[kk]]
[17:40:59.250]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.250]                     next
[17:40:59.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.250]                 }
[17:40:59.250]                 if (length(args) > 0) 
[17:40:59.250]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.250]             }
[17:40:59.250]             else {
[17:40:59.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.250]             }
[17:40:59.250]             {
[17:40:59.250]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.250]                   0L) {
[17:40:59.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.250]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.250]                   base::options(opts)
[17:40:59.250]                 }
[17:40:59.250]                 {
[17:40:59.250]                   {
[17:40:59.250]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.250]                     NULL
[17:40:59.250]                   }
[17:40:59.250]                   options(future.plan = NULL)
[17:40:59.250]                   if (is.na(NA_character_)) 
[17:40:59.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.250]                     .init = FALSE)
[17:40:59.250]                 }
[17:40:59.250]             }
[17:40:59.250]         }
[17:40:59.250]     })
[17:40:59.250]     if (TRUE) {
[17:40:59.250]         base::sink(type = "output", split = FALSE)
[17:40:59.250]         if (TRUE) {
[17:40:59.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.250]         }
[17:40:59.250]         else {
[17:40:59.250]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.250]         }
[17:40:59.250]         base::close(...future.stdout)
[17:40:59.250]         ...future.stdout <- NULL
[17:40:59.250]     }
[17:40:59.250]     ...future.result$conditions <- ...future.conditions
[17:40:59.250]     ...future.result$finished <- base::Sys.time()
[17:40:59.250]     ...future.result
[17:40:59.250] }
[17:40:59.252] Poll #1 (0): usedNodes() = 2, workers = 2
[17:40:59.263] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.263] - Validating connection of MultisessionFuture
[17:40:59.263] - received message: FutureResult
[17:40:59.264] - Received FutureResult
[17:40:59.264] - Erased future from FutureRegistry
[17:40:59.264] result() for ClusterFuture ...
[17:40:59.264] - result already collected: FutureResult
[17:40:59.264] result() for ClusterFuture ... done
[17:40:59.264] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.264] result() for ClusterFuture ...
[17:40:59.264] - result already collected: FutureResult
[17:40:59.264] result() for ClusterFuture ... done
[17:40:59.264] result() for ClusterFuture ...
[17:40:59.265] - result already collected: FutureResult
[17:40:59.265] result() for ClusterFuture ... done
[17:40:59.266] MultisessionFuture started
[17:40:59.266] - Launch lazy future ... done
[17:40:59.266] run() for ‘MultisessionFuture’ ... done
[17:40:59.266] resolve() on list ...
[17:40:59.266]  recursive: 0
[17:40:59.266]  length: 3
[17:40:59.267]  elements: ‘a’, ‘b’, ‘’
[17:40:59.267] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.267] - Validating connection of MultisessionFuture
[17:40:59.268] - received message: FutureResult
[17:40:59.268] - Received FutureResult
[17:40:59.268] - Erased future from FutureRegistry
[17:40:59.268] result() for ClusterFuture ...
[17:40:59.268] - result already collected: FutureResult
[17:40:59.268] result() for ClusterFuture ... done
[17:40:59.268] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.269] Future #1
[17:40:59.269]  length: 2 (resolved future 1)
[17:40:59.269] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.269] - Validating connection of MultisessionFuture
[17:40:59.269] - received message: FutureResult
[17:40:59.269] - Received FutureResult
[17:40:59.270] - Erased future from FutureRegistry
[17:40:59.270] result() for ClusterFuture ...
[17:40:59.270] - result already collected: FutureResult
[17:40:59.270] result() for ClusterFuture ... done
[17:40:59.270] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.270] Future #2
[17:40:59.270]  length: 1 (resolved future 2)
[17:40:59.270]  length: 0 (resolved future 3)
[17:40:59.270] resolve() on list ... DONE
[17:40:59.270] getGlobalsAndPackages() ...
[17:40:59.270] Searching for globals...
[17:40:59.271] 
[17:40:59.271] Searching for globals ... DONE
[17:40:59.271] - globals: [0] <none>
[17:40:59.271] getGlobalsAndPackages() ... DONE
[17:40:59.271] getGlobalsAndPackages() ...
[17:40:59.271] Searching for globals...
[17:40:59.272] 
[17:40:59.272] Searching for globals ... DONE
[17:40:59.272] - globals: [0] <none>
[17:40:59.272] getGlobalsAndPackages() ... DONE
[17:40:59.272] run() for ‘Future’ ...
[17:40:59.272] - state: ‘created’
[17:40:59.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.285]   - Field: ‘node’
[17:40:59.286]   - Field: ‘label’
[17:40:59.286]   - Field: ‘local’
[17:40:59.286]   - Field: ‘owner’
[17:40:59.286]   - Field: ‘envir’
[17:40:59.286]   - Field: ‘workers’
[17:40:59.286]   - Field: ‘packages’
[17:40:59.286]   - Field: ‘gc’
[17:40:59.286]   - Field: ‘conditions’
[17:40:59.286]   - Field: ‘persistent’
[17:40:59.286]   - Field: ‘expr’
[17:40:59.286]   - Field: ‘uuid’
[17:40:59.287]   - Field: ‘seed’
[17:40:59.287]   - Field: ‘version’
[17:40:59.287]   - Field: ‘result’
[17:40:59.287]   - Field: ‘asynchronous’
[17:40:59.287]   - Field: ‘calls’
[17:40:59.287]   - Field: ‘globals’
[17:40:59.287]   - Field: ‘stdout’
[17:40:59.287]   - Field: ‘earlySignal’
[17:40:59.287]   - Field: ‘lazy’
[17:40:59.287]   - Field: ‘state’
[17:40:59.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.287] - Launch lazy future ...
[17:40:59.288] Packages needed by the future expression (n = 0): <none>
[17:40:59.288] Packages needed by future strategies (n = 0): <none>
[17:40:59.288] {
[17:40:59.288]     {
[17:40:59.288]         {
[17:40:59.288]             ...future.startTime <- base::Sys.time()
[17:40:59.288]             {
[17:40:59.288]                 {
[17:40:59.288]                   {
[17:40:59.288]                     {
[17:40:59.288]                       base::local({
[17:40:59.288]                         has_future <- base::requireNamespace("future", 
[17:40:59.288]                           quietly = TRUE)
[17:40:59.288]                         if (has_future) {
[17:40:59.288]                           ns <- base::getNamespace("future")
[17:40:59.288]                           version <- ns[[".package"]][["version"]]
[17:40:59.288]                           if (is.null(version)) 
[17:40:59.288]                             version <- utils::packageVersion("future")
[17:40:59.288]                         }
[17:40:59.288]                         else {
[17:40:59.288]                           version <- NULL
[17:40:59.288]                         }
[17:40:59.288]                         if (!has_future || version < "1.8.0") {
[17:40:59.288]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.288]                             "", base::R.version$version.string), 
[17:40:59.288]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.288]                               "release", "version")], collapse = " "), 
[17:40:59.288]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.288]                             info)
[17:40:59.288]                           info <- base::paste(info, collapse = "; ")
[17:40:59.288]                           if (!has_future) {
[17:40:59.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.288]                               info)
[17:40:59.288]                           }
[17:40:59.288]                           else {
[17:40:59.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.288]                               info, version)
[17:40:59.288]                           }
[17:40:59.288]                           base::stop(msg)
[17:40:59.288]                         }
[17:40:59.288]                       })
[17:40:59.288]                     }
[17:40:59.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.288]                     base::options(mc.cores = 1L)
[17:40:59.288]                   }
[17:40:59.288]                   ...future.strategy.old <- future::plan("list")
[17:40:59.288]                   options(future.plan = NULL)
[17:40:59.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.288]                 }
[17:40:59.288]                 ...future.workdir <- getwd()
[17:40:59.288]             }
[17:40:59.288]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.288]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.288]         }
[17:40:59.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.288]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.288]             base::names(...future.oldOptions))
[17:40:59.288]     }
[17:40:59.288]     if (FALSE) {
[17:40:59.288]     }
[17:40:59.288]     else {
[17:40:59.288]         if (TRUE) {
[17:40:59.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.288]                 open = "w")
[17:40:59.288]         }
[17:40:59.288]         else {
[17:40:59.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.288]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.288]         }
[17:40:59.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.288]             base::sink(type = "output", split = FALSE)
[17:40:59.288]             base::close(...future.stdout)
[17:40:59.288]         }, add = TRUE)
[17:40:59.288]     }
[17:40:59.288]     ...future.frame <- base::sys.nframe()
[17:40:59.288]     ...future.conditions <- base::list()
[17:40:59.288]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.288]     if (FALSE) {
[17:40:59.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.288]     }
[17:40:59.288]     ...future.result <- base::tryCatch({
[17:40:59.288]         base::withCallingHandlers({
[17:40:59.288]             ...future.value <- base::withVisible(base::local({
[17:40:59.288]                 ...future.makeSendCondition <- base::local({
[17:40:59.288]                   sendCondition <- NULL
[17:40:59.288]                   function(frame = 1L) {
[17:40:59.288]                     if (is.function(sendCondition)) 
[17:40:59.288]                       return(sendCondition)
[17:40:59.288]                     ns <- getNamespace("parallel")
[17:40:59.288]                     if (exists("sendData", mode = "function", 
[17:40:59.288]                       envir = ns)) {
[17:40:59.288]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.288]                         envir = ns)
[17:40:59.288]                       envir <- sys.frame(frame)
[17:40:59.288]                       master <- NULL
[17:40:59.288]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.288]                         !identical(envir, emptyenv())) {
[17:40:59.288]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.288]                           inherits = FALSE)) {
[17:40:59.288]                           master <- get("master", mode = "list", 
[17:40:59.288]                             envir = envir, inherits = FALSE)
[17:40:59.288]                           if (inherits(master, c("SOCKnode", 
[17:40:59.288]                             "SOCK0node"))) {
[17:40:59.288]                             sendCondition <<- function(cond) {
[17:40:59.288]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.288]                                 success = TRUE)
[17:40:59.288]                               parallel_sendData(master, data)
[17:40:59.288]                             }
[17:40:59.288]                             return(sendCondition)
[17:40:59.288]                           }
[17:40:59.288]                         }
[17:40:59.288]                         frame <- frame + 1L
[17:40:59.288]                         envir <- sys.frame(frame)
[17:40:59.288]                       }
[17:40:59.288]                     }
[17:40:59.288]                     sendCondition <<- function(cond) NULL
[17:40:59.288]                   }
[17:40:59.288]                 })
[17:40:59.288]                 withCallingHandlers({
[17:40:59.288]                   2
[17:40:59.288]                 }, immediateCondition = function(cond) {
[17:40:59.288]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.288]                   sendCondition(cond)
[17:40:59.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.288]                   {
[17:40:59.288]                     inherits <- base::inherits
[17:40:59.288]                     invokeRestart <- base::invokeRestart
[17:40:59.288]                     is.null <- base::is.null
[17:40:59.288]                     muffled <- FALSE
[17:40:59.288]                     if (inherits(cond, "message")) {
[17:40:59.288]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.288]                       if (muffled) 
[17:40:59.288]                         invokeRestart("muffleMessage")
[17:40:59.288]                     }
[17:40:59.288]                     else if (inherits(cond, "warning")) {
[17:40:59.288]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.288]                       if (muffled) 
[17:40:59.288]                         invokeRestart("muffleWarning")
[17:40:59.288]                     }
[17:40:59.288]                     else if (inherits(cond, "condition")) {
[17:40:59.288]                       if (!is.null(pattern)) {
[17:40:59.288]                         computeRestarts <- base::computeRestarts
[17:40:59.288]                         grepl <- base::grepl
[17:40:59.288]                         restarts <- computeRestarts(cond)
[17:40:59.288]                         for (restart in restarts) {
[17:40:59.288]                           name <- restart$name
[17:40:59.288]                           if (is.null(name)) 
[17:40:59.288]                             next
[17:40:59.288]                           if (!grepl(pattern, name)) 
[17:40:59.288]                             next
[17:40:59.288]                           invokeRestart(restart)
[17:40:59.288]                           muffled <- TRUE
[17:40:59.288]                           break
[17:40:59.288]                         }
[17:40:59.288]                       }
[17:40:59.288]                     }
[17:40:59.288]                     invisible(muffled)
[17:40:59.288]                   }
[17:40:59.288]                   muffleCondition(cond)
[17:40:59.288]                 })
[17:40:59.288]             }))
[17:40:59.288]             future::FutureResult(value = ...future.value$value, 
[17:40:59.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.288]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.288]                     ...future.globalenv.names))
[17:40:59.288]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.288]         }, condition = base::local({
[17:40:59.288]             c <- base::c
[17:40:59.288]             inherits <- base::inherits
[17:40:59.288]             invokeRestart <- base::invokeRestart
[17:40:59.288]             length <- base::length
[17:40:59.288]             list <- base::list
[17:40:59.288]             seq.int <- base::seq.int
[17:40:59.288]             signalCondition <- base::signalCondition
[17:40:59.288]             sys.calls <- base::sys.calls
[17:40:59.288]             `[[` <- base::`[[`
[17:40:59.288]             `+` <- base::`+`
[17:40:59.288]             `<<-` <- base::`<<-`
[17:40:59.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.288]                   3L)]
[17:40:59.288]             }
[17:40:59.288]             function(cond) {
[17:40:59.288]                 is_error <- inherits(cond, "error")
[17:40:59.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.288]                   NULL)
[17:40:59.288]                 if (is_error) {
[17:40:59.288]                   sessionInformation <- function() {
[17:40:59.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.288]                       search = base::search(), system = base::Sys.info())
[17:40:59.288]                   }
[17:40:59.288]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.288]                     cond$call), session = sessionInformation(), 
[17:40:59.288]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.288]                   signalCondition(cond)
[17:40:59.288]                 }
[17:40:59.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.288]                 "immediateCondition"))) {
[17:40:59.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.288]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.288]                   if (TRUE && !signal) {
[17:40:59.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.288]                     {
[17:40:59.288]                       inherits <- base::inherits
[17:40:59.288]                       invokeRestart <- base::invokeRestart
[17:40:59.288]                       is.null <- base::is.null
[17:40:59.288]                       muffled <- FALSE
[17:40:59.288]                       if (inherits(cond, "message")) {
[17:40:59.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.288]                         if (muffled) 
[17:40:59.288]                           invokeRestart("muffleMessage")
[17:40:59.288]                       }
[17:40:59.288]                       else if (inherits(cond, "warning")) {
[17:40:59.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.288]                         if (muffled) 
[17:40:59.288]                           invokeRestart("muffleWarning")
[17:40:59.288]                       }
[17:40:59.288]                       else if (inherits(cond, "condition")) {
[17:40:59.288]                         if (!is.null(pattern)) {
[17:40:59.288]                           computeRestarts <- base::computeRestarts
[17:40:59.288]                           grepl <- base::grepl
[17:40:59.288]                           restarts <- computeRestarts(cond)
[17:40:59.288]                           for (restart in restarts) {
[17:40:59.288]                             name <- restart$name
[17:40:59.288]                             if (is.null(name)) 
[17:40:59.288]                               next
[17:40:59.288]                             if (!grepl(pattern, name)) 
[17:40:59.288]                               next
[17:40:59.288]                             invokeRestart(restart)
[17:40:59.288]                             muffled <- TRUE
[17:40:59.288]                             break
[17:40:59.288]                           }
[17:40:59.288]                         }
[17:40:59.288]                       }
[17:40:59.288]                       invisible(muffled)
[17:40:59.288]                     }
[17:40:59.288]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.288]                   }
[17:40:59.288]                 }
[17:40:59.288]                 else {
[17:40:59.288]                   if (TRUE) {
[17:40:59.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.288]                     {
[17:40:59.288]                       inherits <- base::inherits
[17:40:59.288]                       invokeRestart <- base::invokeRestart
[17:40:59.288]                       is.null <- base::is.null
[17:40:59.288]                       muffled <- FALSE
[17:40:59.288]                       if (inherits(cond, "message")) {
[17:40:59.288]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.288]                         if (muffled) 
[17:40:59.288]                           invokeRestart("muffleMessage")
[17:40:59.288]                       }
[17:40:59.288]                       else if (inherits(cond, "warning")) {
[17:40:59.288]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.288]                         if (muffled) 
[17:40:59.288]                           invokeRestart("muffleWarning")
[17:40:59.288]                       }
[17:40:59.288]                       else if (inherits(cond, "condition")) {
[17:40:59.288]                         if (!is.null(pattern)) {
[17:40:59.288]                           computeRestarts <- base::computeRestarts
[17:40:59.288]                           grepl <- base::grepl
[17:40:59.288]                           restarts <- computeRestarts(cond)
[17:40:59.288]                           for (restart in restarts) {
[17:40:59.288]                             name <- restart$name
[17:40:59.288]                             if (is.null(name)) 
[17:40:59.288]                               next
[17:40:59.288]                             if (!grepl(pattern, name)) 
[17:40:59.288]                               next
[17:40:59.288]                             invokeRestart(restart)
[17:40:59.288]                             muffled <- TRUE
[17:40:59.288]                             break
[17:40:59.288]                           }
[17:40:59.288]                         }
[17:40:59.288]                       }
[17:40:59.288]                       invisible(muffled)
[17:40:59.288]                     }
[17:40:59.288]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.288]                   }
[17:40:59.288]                 }
[17:40:59.288]             }
[17:40:59.288]         }))
[17:40:59.288]     }, error = function(ex) {
[17:40:59.288]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.288]                 ...future.rng), started = ...future.startTime, 
[17:40:59.288]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.288]             version = "1.8"), class = "FutureResult")
[17:40:59.288]     }, finally = {
[17:40:59.288]         if (!identical(...future.workdir, getwd())) 
[17:40:59.288]             setwd(...future.workdir)
[17:40:59.288]         {
[17:40:59.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.288]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.288]             }
[17:40:59.288]             base::options(...future.oldOptions)
[17:40:59.288]             if (.Platform$OS.type == "windows") {
[17:40:59.288]                 old_names <- names(...future.oldEnvVars)
[17:40:59.288]                 envs <- base::Sys.getenv()
[17:40:59.288]                 names <- names(envs)
[17:40:59.288]                 common <- intersect(names, old_names)
[17:40:59.288]                 added <- setdiff(names, old_names)
[17:40:59.288]                 removed <- setdiff(old_names, names)
[17:40:59.288]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.288]                   envs[common]]
[17:40:59.288]                 NAMES <- toupper(changed)
[17:40:59.288]                 args <- list()
[17:40:59.288]                 for (kk in seq_along(NAMES)) {
[17:40:59.288]                   name <- changed[[kk]]
[17:40:59.288]                   NAME <- NAMES[[kk]]
[17:40:59.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.288]                     next
[17:40:59.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.288]                 }
[17:40:59.288]                 NAMES <- toupper(added)
[17:40:59.288]                 for (kk in seq_along(NAMES)) {
[17:40:59.288]                   name <- added[[kk]]
[17:40:59.288]                   NAME <- NAMES[[kk]]
[17:40:59.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.288]                     next
[17:40:59.288]                   args[[name]] <- ""
[17:40:59.288]                 }
[17:40:59.288]                 NAMES <- toupper(removed)
[17:40:59.288]                 for (kk in seq_along(NAMES)) {
[17:40:59.288]                   name <- removed[[kk]]
[17:40:59.288]                   NAME <- NAMES[[kk]]
[17:40:59.288]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.288]                     next
[17:40:59.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.288]                 }
[17:40:59.288]                 if (length(args) > 0) 
[17:40:59.288]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.288]             }
[17:40:59.288]             else {
[17:40:59.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.288]             }
[17:40:59.288]             {
[17:40:59.288]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.288]                   0L) {
[17:40:59.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.288]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.288]                   base::options(opts)
[17:40:59.288]                 }
[17:40:59.288]                 {
[17:40:59.288]                   {
[17:40:59.288]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.288]                     NULL
[17:40:59.288]                   }
[17:40:59.288]                   options(future.plan = NULL)
[17:40:59.288]                   if (is.na(NA_character_)) 
[17:40:59.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.288]                     .init = FALSE)
[17:40:59.288]                 }
[17:40:59.288]             }
[17:40:59.288]         }
[17:40:59.288]     })
[17:40:59.288]     if (TRUE) {
[17:40:59.288]         base::sink(type = "output", split = FALSE)
[17:40:59.288]         if (TRUE) {
[17:40:59.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.288]         }
[17:40:59.288]         else {
[17:40:59.288]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.288]         }
[17:40:59.288]         base::close(...future.stdout)
[17:40:59.288]         ...future.stdout <- NULL
[17:40:59.288]     }
[17:40:59.288]     ...future.result$conditions <- ...future.conditions
[17:40:59.288]     ...future.result$finished <- base::Sys.time()
[17:40:59.288]     ...future.result
[17:40:59.288] }
[17:40:59.291] MultisessionFuture started
[17:40:59.291] - Launch lazy future ... done
[17:40:59.291] run() for ‘MultisessionFuture’ ... done
[17:40:59.291] resolve() on list ...
[17:40:59.291]  recursive: 0
[17:40:59.292]  length: 3
[17:40:59.292]  elements: ‘a’, ‘b’, ‘’
[17:40:59.292] run() for ‘Future’ ...
[17:40:59.292] - state: ‘created’
[17:40:59.292] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.305] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.306] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.306]   - Field: ‘node’
[17:40:59.306]   - Field: ‘label’
[17:40:59.306]   - Field: ‘local’
[17:40:59.306]   - Field: ‘owner’
[17:40:59.306]   - Field: ‘envir’
[17:40:59.306]   - Field: ‘workers’
[17:40:59.306]   - Field: ‘packages’
[17:40:59.306]   - Field: ‘gc’
[17:40:59.306]   - Field: ‘conditions’
[17:40:59.307]   - Field: ‘persistent’
[17:40:59.307]   - Field: ‘expr’
[17:40:59.307]   - Field: ‘uuid’
[17:40:59.307]   - Field: ‘seed’
[17:40:59.307]   - Field: ‘version’
[17:40:59.307]   - Field: ‘result’
[17:40:59.307]   - Field: ‘asynchronous’
[17:40:59.307]   - Field: ‘calls’
[17:40:59.307]   - Field: ‘globals’
[17:40:59.307]   - Field: ‘stdout’
[17:40:59.307]   - Field: ‘earlySignal’
[17:40:59.307]   - Field: ‘lazy’
[17:40:59.308]   - Field: ‘state’
[17:40:59.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.308] - Launch lazy future ...
[17:40:59.308] Packages needed by the future expression (n = 0): <none>
[17:40:59.308] Packages needed by future strategies (n = 0): <none>
[17:40:59.309] {
[17:40:59.309]     {
[17:40:59.309]         {
[17:40:59.309]             ...future.startTime <- base::Sys.time()
[17:40:59.309]             {
[17:40:59.309]                 {
[17:40:59.309]                   {
[17:40:59.309]                     {
[17:40:59.309]                       base::local({
[17:40:59.309]                         has_future <- base::requireNamespace("future", 
[17:40:59.309]                           quietly = TRUE)
[17:40:59.309]                         if (has_future) {
[17:40:59.309]                           ns <- base::getNamespace("future")
[17:40:59.309]                           version <- ns[[".package"]][["version"]]
[17:40:59.309]                           if (is.null(version)) 
[17:40:59.309]                             version <- utils::packageVersion("future")
[17:40:59.309]                         }
[17:40:59.309]                         else {
[17:40:59.309]                           version <- NULL
[17:40:59.309]                         }
[17:40:59.309]                         if (!has_future || version < "1.8.0") {
[17:40:59.309]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.309]                             "", base::R.version$version.string), 
[17:40:59.309]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.309]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.309]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.309]                               "release", "version")], collapse = " "), 
[17:40:59.309]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.309]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.309]                             info)
[17:40:59.309]                           info <- base::paste(info, collapse = "; ")
[17:40:59.309]                           if (!has_future) {
[17:40:59.309]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.309]                               info)
[17:40:59.309]                           }
[17:40:59.309]                           else {
[17:40:59.309]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.309]                               info, version)
[17:40:59.309]                           }
[17:40:59.309]                           base::stop(msg)
[17:40:59.309]                         }
[17:40:59.309]                       })
[17:40:59.309]                     }
[17:40:59.309]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.309]                     base::options(mc.cores = 1L)
[17:40:59.309]                   }
[17:40:59.309]                   ...future.strategy.old <- future::plan("list")
[17:40:59.309]                   options(future.plan = NULL)
[17:40:59.309]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.309]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.309]                 }
[17:40:59.309]                 ...future.workdir <- getwd()
[17:40:59.309]             }
[17:40:59.309]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.309]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.309]         }
[17:40:59.309]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.309]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.309]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.309]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.309]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.309]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.309]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.309]             base::names(...future.oldOptions))
[17:40:59.309]     }
[17:40:59.309]     if (FALSE) {
[17:40:59.309]     }
[17:40:59.309]     else {
[17:40:59.309]         if (TRUE) {
[17:40:59.309]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.309]                 open = "w")
[17:40:59.309]         }
[17:40:59.309]         else {
[17:40:59.309]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.309]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.309]         }
[17:40:59.309]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.309]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.309]             base::sink(type = "output", split = FALSE)
[17:40:59.309]             base::close(...future.stdout)
[17:40:59.309]         }, add = TRUE)
[17:40:59.309]     }
[17:40:59.309]     ...future.frame <- base::sys.nframe()
[17:40:59.309]     ...future.conditions <- base::list()
[17:40:59.309]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.309]     if (FALSE) {
[17:40:59.309]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.309]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.309]     }
[17:40:59.309]     ...future.result <- base::tryCatch({
[17:40:59.309]         base::withCallingHandlers({
[17:40:59.309]             ...future.value <- base::withVisible(base::local({
[17:40:59.309]                 ...future.makeSendCondition <- base::local({
[17:40:59.309]                   sendCondition <- NULL
[17:40:59.309]                   function(frame = 1L) {
[17:40:59.309]                     if (is.function(sendCondition)) 
[17:40:59.309]                       return(sendCondition)
[17:40:59.309]                     ns <- getNamespace("parallel")
[17:40:59.309]                     if (exists("sendData", mode = "function", 
[17:40:59.309]                       envir = ns)) {
[17:40:59.309]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.309]                         envir = ns)
[17:40:59.309]                       envir <- sys.frame(frame)
[17:40:59.309]                       master <- NULL
[17:40:59.309]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.309]                         !identical(envir, emptyenv())) {
[17:40:59.309]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.309]                           inherits = FALSE)) {
[17:40:59.309]                           master <- get("master", mode = "list", 
[17:40:59.309]                             envir = envir, inherits = FALSE)
[17:40:59.309]                           if (inherits(master, c("SOCKnode", 
[17:40:59.309]                             "SOCK0node"))) {
[17:40:59.309]                             sendCondition <<- function(cond) {
[17:40:59.309]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.309]                                 success = TRUE)
[17:40:59.309]                               parallel_sendData(master, data)
[17:40:59.309]                             }
[17:40:59.309]                             return(sendCondition)
[17:40:59.309]                           }
[17:40:59.309]                         }
[17:40:59.309]                         frame <- frame + 1L
[17:40:59.309]                         envir <- sys.frame(frame)
[17:40:59.309]                       }
[17:40:59.309]                     }
[17:40:59.309]                     sendCondition <<- function(cond) NULL
[17:40:59.309]                   }
[17:40:59.309]                 })
[17:40:59.309]                 withCallingHandlers({
[17:40:59.309]                   1
[17:40:59.309]                 }, immediateCondition = function(cond) {
[17:40:59.309]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.309]                   sendCondition(cond)
[17:40:59.309]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.309]                   {
[17:40:59.309]                     inherits <- base::inherits
[17:40:59.309]                     invokeRestart <- base::invokeRestart
[17:40:59.309]                     is.null <- base::is.null
[17:40:59.309]                     muffled <- FALSE
[17:40:59.309]                     if (inherits(cond, "message")) {
[17:40:59.309]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.309]                       if (muffled) 
[17:40:59.309]                         invokeRestart("muffleMessage")
[17:40:59.309]                     }
[17:40:59.309]                     else if (inherits(cond, "warning")) {
[17:40:59.309]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.309]                       if (muffled) 
[17:40:59.309]                         invokeRestart("muffleWarning")
[17:40:59.309]                     }
[17:40:59.309]                     else if (inherits(cond, "condition")) {
[17:40:59.309]                       if (!is.null(pattern)) {
[17:40:59.309]                         computeRestarts <- base::computeRestarts
[17:40:59.309]                         grepl <- base::grepl
[17:40:59.309]                         restarts <- computeRestarts(cond)
[17:40:59.309]                         for (restart in restarts) {
[17:40:59.309]                           name <- restart$name
[17:40:59.309]                           if (is.null(name)) 
[17:40:59.309]                             next
[17:40:59.309]                           if (!grepl(pattern, name)) 
[17:40:59.309]                             next
[17:40:59.309]                           invokeRestart(restart)
[17:40:59.309]                           muffled <- TRUE
[17:40:59.309]                           break
[17:40:59.309]                         }
[17:40:59.309]                       }
[17:40:59.309]                     }
[17:40:59.309]                     invisible(muffled)
[17:40:59.309]                   }
[17:40:59.309]                   muffleCondition(cond)
[17:40:59.309]                 })
[17:40:59.309]             }))
[17:40:59.309]             future::FutureResult(value = ...future.value$value, 
[17:40:59.309]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.309]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.309]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.309]                     ...future.globalenv.names))
[17:40:59.309]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.309]         }, condition = base::local({
[17:40:59.309]             c <- base::c
[17:40:59.309]             inherits <- base::inherits
[17:40:59.309]             invokeRestart <- base::invokeRestart
[17:40:59.309]             length <- base::length
[17:40:59.309]             list <- base::list
[17:40:59.309]             seq.int <- base::seq.int
[17:40:59.309]             signalCondition <- base::signalCondition
[17:40:59.309]             sys.calls <- base::sys.calls
[17:40:59.309]             `[[` <- base::`[[`
[17:40:59.309]             `+` <- base::`+`
[17:40:59.309]             `<<-` <- base::`<<-`
[17:40:59.309]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.309]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.309]                   3L)]
[17:40:59.309]             }
[17:40:59.309]             function(cond) {
[17:40:59.309]                 is_error <- inherits(cond, "error")
[17:40:59.309]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.309]                   NULL)
[17:40:59.309]                 if (is_error) {
[17:40:59.309]                   sessionInformation <- function() {
[17:40:59.309]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.309]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.309]                       search = base::search(), system = base::Sys.info())
[17:40:59.309]                   }
[17:40:59.309]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.309]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.309]                     cond$call), session = sessionInformation(), 
[17:40:59.309]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.309]                   signalCondition(cond)
[17:40:59.309]                 }
[17:40:59.309]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.309]                 "immediateCondition"))) {
[17:40:59.309]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.309]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.309]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.309]                   if (TRUE && !signal) {
[17:40:59.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.309]                     {
[17:40:59.309]                       inherits <- base::inherits
[17:40:59.309]                       invokeRestart <- base::invokeRestart
[17:40:59.309]                       is.null <- base::is.null
[17:40:59.309]                       muffled <- FALSE
[17:40:59.309]                       if (inherits(cond, "message")) {
[17:40:59.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.309]                         if (muffled) 
[17:40:59.309]                           invokeRestart("muffleMessage")
[17:40:59.309]                       }
[17:40:59.309]                       else if (inherits(cond, "warning")) {
[17:40:59.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.309]                         if (muffled) 
[17:40:59.309]                           invokeRestart("muffleWarning")
[17:40:59.309]                       }
[17:40:59.309]                       else if (inherits(cond, "condition")) {
[17:40:59.309]                         if (!is.null(pattern)) {
[17:40:59.309]                           computeRestarts <- base::computeRestarts
[17:40:59.309]                           grepl <- base::grepl
[17:40:59.309]                           restarts <- computeRestarts(cond)
[17:40:59.309]                           for (restart in restarts) {
[17:40:59.309]                             name <- restart$name
[17:40:59.309]                             if (is.null(name)) 
[17:40:59.309]                               next
[17:40:59.309]                             if (!grepl(pattern, name)) 
[17:40:59.309]                               next
[17:40:59.309]                             invokeRestart(restart)
[17:40:59.309]                             muffled <- TRUE
[17:40:59.309]                             break
[17:40:59.309]                           }
[17:40:59.309]                         }
[17:40:59.309]                       }
[17:40:59.309]                       invisible(muffled)
[17:40:59.309]                     }
[17:40:59.309]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.309]                   }
[17:40:59.309]                 }
[17:40:59.309]                 else {
[17:40:59.309]                   if (TRUE) {
[17:40:59.309]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.309]                     {
[17:40:59.309]                       inherits <- base::inherits
[17:40:59.309]                       invokeRestart <- base::invokeRestart
[17:40:59.309]                       is.null <- base::is.null
[17:40:59.309]                       muffled <- FALSE
[17:40:59.309]                       if (inherits(cond, "message")) {
[17:40:59.309]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.309]                         if (muffled) 
[17:40:59.309]                           invokeRestart("muffleMessage")
[17:40:59.309]                       }
[17:40:59.309]                       else if (inherits(cond, "warning")) {
[17:40:59.309]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.309]                         if (muffled) 
[17:40:59.309]                           invokeRestart("muffleWarning")
[17:40:59.309]                       }
[17:40:59.309]                       else if (inherits(cond, "condition")) {
[17:40:59.309]                         if (!is.null(pattern)) {
[17:40:59.309]                           computeRestarts <- base::computeRestarts
[17:40:59.309]                           grepl <- base::grepl
[17:40:59.309]                           restarts <- computeRestarts(cond)
[17:40:59.309]                           for (restart in restarts) {
[17:40:59.309]                             name <- restart$name
[17:40:59.309]                             if (is.null(name)) 
[17:40:59.309]                               next
[17:40:59.309]                             if (!grepl(pattern, name)) 
[17:40:59.309]                               next
[17:40:59.309]                             invokeRestart(restart)
[17:40:59.309]                             muffled <- TRUE
[17:40:59.309]                             break
[17:40:59.309]                           }
[17:40:59.309]                         }
[17:40:59.309]                       }
[17:40:59.309]                       invisible(muffled)
[17:40:59.309]                     }
[17:40:59.309]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.309]                   }
[17:40:59.309]                 }
[17:40:59.309]             }
[17:40:59.309]         }))
[17:40:59.309]     }, error = function(ex) {
[17:40:59.309]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.309]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.309]                 ...future.rng), started = ...future.startTime, 
[17:40:59.309]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.309]             version = "1.8"), class = "FutureResult")
[17:40:59.309]     }, finally = {
[17:40:59.309]         if (!identical(...future.workdir, getwd())) 
[17:40:59.309]             setwd(...future.workdir)
[17:40:59.309]         {
[17:40:59.309]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.309]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.309]             }
[17:40:59.309]             base::options(...future.oldOptions)
[17:40:59.309]             if (.Platform$OS.type == "windows") {
[17:40:59.309]                 old_names <- names(...future.oldEnvVars)
[17:40:59.309]                 envs <- base::Sys.getenv()
[17:40:59.309]                 names <- names(envs)
[17:40:59.309]                 common <- intersect(names, old_names)
[17:40:59.309]                 added <- setdiff(names, old_names)
[17:40:59.309]                 removed <- setdiff(old_names, names)
[17:40:59.309]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.309]                   envs[common]]
[17:40:59.309]                 NAMES <- toupper(changed)
[17:40:59.309]                 args <- list()
[17:40:59.309]                 for (kk in seq_along(NAMES)) {
[17:40:59.309]                   name <- changed[[kk]]
[17:40:59.309]                   NAME <- NAMES[[kk]]
[17:40:59.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.309]                     next
[17:40:59.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.309]                 }
[17:40:59.309]                 NAMES <- toupper(added)
[17:40:59.309]                 for (kk in seq_along(NAMES)) {
[17:40:59.309]                   name <- added[[kk]]
[17:40:59.309]                   NAME <- NAMES[[kk]]
[17:40:59.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.309]                     next
[17:40:59.309]                   args[[name]] <- ""
[17:40:59.309]                 }
[17:40:59.309]                 NAMES <- toupper(removed)
[17:40:59.309]                 for (kk in seq_along(NAMES)) {
[17:40:59.309]                   name <- removed[[kk]]
[17:40:59.309]                   NAME <- NAMES[[kk]]
[17:40:59.309]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.309]                     next
[17:40:59.309]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.309]                 }
[17:40:59.309]                 if (length(args) > 0) 
[17:40:59.309]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.309]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.309]             }
[17:40:59.309]             else {
[17:40:59.309]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.309]             }
[17:40:59.309]             {
[17:40:59.309]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.309]                   0L) {
[17:40:59.309]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.309]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.309]                   base::options(opts)
[17:40:59.309]                 }
[17:40:59.309]                 {
[17:40:59.309]                   {
[17:40:59.309]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.309]                     NULL
[17:40:59.309]                   }
[17:40:59.309]                   options(future.plan = NULL)
[17:40:59.309]                   if (is.na(NA_character_)) 
[17:40:59.309]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.309]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.309]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.309]                     .init = FALSE)
[17:40:59.309]                 }
[17:40:59.309]             }
[17:40:59.309]         }
[17:40:59.309]     })
[17:40:59.309]     if (TRUE) {
[17:40:59.309]         base::sink(type = "output", split = FALSE)
[17:40:59.309]         if (TRUE) {
[17:40:59.309]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.309]         }
[17:40:59.309]         else {
[17:40:59.309]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.309]         }
[17:40:59.309]         base::close(...future.stdout)
[17:40:59.309]         ...future.stdout <- NULL
[17:40:59.309]     }
[17:40:59.309]     ...future.result$conditions <- ...future.conditions
[17:40:59.309]     ...future.result$finished <- base::Sys.time()
[17:40:59.309]     ...future.result
[17:40:59.309] }
[17:40:59.311] MultisessionFuture started
[17:40:59.312] - Launch lazy future ... done
[17:40:59.312] run() for ‘MultisessionFuture’ ... done
[17:40:59.313] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.313] - Validating connection of MultisessionFuture
[17:40:59.314] - received message: FutureResult
[17:40:59.314] - Received FutureResult
[17:40:59.314] - Erased future from FutureRegistry
[17:40:59.314] result() for ClusterFuture ...
[17:40:59.314] - result already collected: FutureResult
[17:40:59.314] result() for ClusterFuture ... done
[17:40:59.314] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.314] Future #1
[17:40:59.314]  length: 2 (resolved future 1)
[17:40:59.315] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.315] - Validating connection of MultisessionFuture
[17:40:59.315] - received message: FutureResult
[17:40:59.315] - Received FutureResult
[17:40:59.315] - Erased future from FutureRegistry
[17:40:59.315] result() for ClusterFuture ...
[17:40:59.315] - result already collected: FutureResult
[17:40:59.316] result() for ClusterFuture ... done
[17:40:59.316] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.316] Future #2
[17:40:59.316]  length: 1 (resolved future 2)
[17:40:59.316]  length: 0 (resolved future 3)
[17:40:59.316] resolve() on list ... DONE
[17:40:59.316] getGlobalsAndPackages() ...
[17:40:59.316] Searching for globals...
[17:40:59.316] 
[17:40:59.317] Searching for globals ... DONE
[17:40:59.317] - globals: [0] <none>
[17:40:59.317] getGlobalsAndPackages() ... DONE
[17:40:59.317] getGlobalsAndPackages() ...
[17:40:59.317] Searching for globals...
[17:40:59.317] 
[17:40:59.317] Searching for globals ... DONE
[17:40:59.318] - globals: [0] <none>
[17:40:59.318] getGlobalsAndPackages() ... DONE
[17:40:59.318] resolve() on list ...
[17:40:59.318]  recursive: 0
[17:40:59.318]  length: 3
[17:40:59.318]  elements: ‘a’, ‘b’, ‘’
[17:40:59.318] run() for ‘Future’ ...
[17:40:59.318] - state: ‘created’
[17:40:59.318] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.332]   - Field: ‘node’
[17:40:59.332]   - Field: ‘label’
[17:40:59.332]   - Field: ‘local’
[17:40:59.332]   - Field: ‘owner’
[17:40:59.332]   - Field: ‘envir’
[17:40:59.332]   - Field: ‘workers’
[17:40:59.332]   - Field: ‘packages’
[17:40:59.332]   - Field: ‘gc’
[17:40:59.333]   - Field: ‘conditions’
[17:40:59.333]   - Field: ‘persistent’
[17:40:59.333]   - Field: ‘expr’
[17:40:59.333]   - Field: ‘uuid’
[17:40:59.333]   - Field: ‘seed’
[17:40:59.333]   - Field: ‘version’
[17:40:59.333]   - Field: ‘result’
[17:40:59.333]   - Field: ‘asynchronous’
[17:40:59.333]   - Field: ‘calls’
[17:40:59.333]   - Field: ‘globals’
[17:40:59.333]   - Field: ‘stdout’
[17:40:59.334]   - Field: ‘earlySignal’
[17:40:59.334]   - Field: ‘lazy’
[17:40:59.334]   - Field: ‘state’
[17:40:59.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.334] - Launch lazy future ...
[17:40:59.334] Packages needed by the future expression (n = 0): <none>
[17:40:59.334] Packages needed by future strategies (n = 0): <none>
[17:40:59.335] {
[17:40:59.335]     {
[17:40:59.335]         {
[17:40:59.335]             ...future.startTime <- base::Sys.time()
[17:40:59.335]             {
[17:40:59.335]                 {
[17:40:59.335]                   {
[17:40:59.335]                     {
[17:40:59.335]                       base::local({
[17:40:59.335]                         has_future <- base::requireNamespace("future", 
[17:40:59.335]                           quietly = TRUE)
[17:40:59.335]                         if (has_future) {
[17:40:59.335]                           ns <- base::getNamespace("future")
[17:40:59.335]                           version <- ns[[".package"]][["version"]]
[17:40:59.335]                           if (is.null(version)) 
[17:40:59.335]                             version <- utils::packageVersion("future")
[17:40:59.335]                         }
[17:40:59.335]                         else {
[17:40:59.335]                           version <- NULL
[17:40:59.335]                         }
[17:40:59.335]                         if (!has_future || version < "1.8.0") {
[17:40:59.335]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.335]                             "", base::R.version$version.string), 
[17:40:59.335]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.335]                               "release", "version")], collapse = " "), 
[17:40:59.335]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.335]                             info)
[17:40:59.335]                           info <- base::paste(info, collapse = "; ")
[17:40:59.335]                           if (!has_future) {
[17:40:59.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.335]                               info)
[17:40:59.335]                           }
[17:40:59.335]                           else {
[17:40:59.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.335]                               info, version)
[17:40:59.335]                           }
[17:40:59.335]                           base::stop(msg)
[17:40:59.335]                         }
[17:40:59.335]                       })
[17:40:59.335]                     }
[17:40:59.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.335]                     base::options(mc.cores = 1L)
[17:40:59.335]                   }
[17:40:59.335]                   ...future.strategy.old <- future::plan("list")
[17:40:59.335]                   options(future.plan = NULL)
[17:40:59.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.335]                 }
[17:40:59.335]                 ...future.workdir <- getwd()
[17:40:59.335]             }
[17:40:59.335]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.335]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.335]         }
[17:40:59.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.335]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.335]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.335]             base::names(...future.oldOptions))
[17:40:59.335]     }
[17:40:59.335]     if (FALSE) {
[17:40:59.335]     }
[17:40:59.335]     else {
[17:40:59.335]         if (TRUE) {
[17:40:59.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.335]                 open = "w")
[17:40:59.335]         }
[17:40:59.335]         else {
[17:40:59.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.335]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.335]         }
[17:40:59.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.335]             base::sink(type = "output", split = FALSE)
[17:40:59.335]             base::close(...future.stdout)
[17:40:59.335]         }, add = TRUE)
[17:40:59.335]     }
[17:40:59.335]     ...future.frame <- base::sys.nframe()
[17:40:59.335]     ...future.conditions <- base::list()
[17:40:59.335]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.335]     if (FALSE) {
[17:40:59.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.335]     }
[17:40:59.335]     ...future.result <- base::tryCatch({
[17:40:59.335]         base::withCallingHandlers({
[17:40:59.335]             ...future.value <- base::withVisible(base::local({
[17:40:59.335]                 ...future.makeSendCondition <- base::local({
[17:40:59.335]                   sendCondition <- NULL
[17:40:59.335]                   function(frame = 1L) {
[17:40:59.335]                     if (is.function(sendCondition)) 
[17:40:59.335]                       return(sendCondition)
[17:40:59.335]                     ns <- getNamespace("parallel")
[17:40:59.335]                     if (exists("sendData", mode = "function", 
[17:40:59.335]                       envir = ns)) {
[17:40:59.335]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.335]                         envir = ns)
[17:40:59.335]                       envir <- sys.frame(frame)
[17:40:59.335]                       master <- NULL
[17:40:59.335]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.335]                         !identical(envir, emptyenv())) {
[17:40:59.335]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.335]                           inherits = FALSE)) {
[17:40:59.335]                           master <- get("master", mode = "list", 
[17:40:59.335]                             envir = envir, inherits = FALSE)
[17:40:59.335]                           if (inherits(master, c("SOCKnode", 
[17:40:59.335]                             "SOCK0node"))) {
[17:40:59.335]                             sendCondition <<- function(cond) {
[17:40:59.335]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.335]                                 success = TRUE)
[17:40:59.335]                               parallel_sendData(master, data)
[17:40:59.335]                             }
[17:40:59.335]                             return(sendCondition)
[17:40:59.335]                           }
[17:40:59.335]                         }
[17:40:59.335]                         frame <- frame + 1L
[17:40:59.335]                         envir <- sys.frame(frame)
[17:40:59.335]                       }
[17:40:59.335]                     }
[17:40:59.335]                     sendCondition <<- function(cond) NULL
[17:40:59.335]                   }
[17:40:59.335]                 })
[17:40:59.335]                 withCallingHandlers({
[17:40:59.335]                   1
[17:40:59.335]                 }, immediateCondition = function(cond) {
[17:40:59.335]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.335]                   sendCondition(cond)
[17:40:59.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.335]                   {
[17:40:59.335]                     inherits <- base::inherits
[17:40:59.335]                     invokeRestart <- base::invokeRestart
[17:40:59.335]                     is.null <- base::is.null
[17:40:59.335]                     muffled <- FALSE
[17:40:59.335]                     if (inherits(cond, "message")) {
[17:40:59.335]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.335]                       if (muffled) 
[17:40:59.335]                         invokeRestart("muffleMessage")
[17:40:59.335]                     }
[17:40:59.335]                     else if (inherits(cond, "warning")) {
[17:40:59.335]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.335]                       if (muffled) 
[17:40:59.335]                         invokeRestart("muffleWarning")
[17:40:59.335]                     }
[17:40:59.335]                     else if (inherits(cond, "condition")) {
[17:40:59.335]                       if (!is.null(pattern)) {
[17:40:59.335]                         computeRestarts <- base::computeRestarts
[17:40:59.335]                         grepl <- base::grepl
[17:40:59.335]                         restarts <- computeRestarts(cond)
[17:40:59.335]                         for (restart in restarts) {
[17:40:59.335]                           name <- restart$name
[17:40:59.335]                           if (is.null(name)) 
[17:40:59.335]                             next
[17:40:59.335]                           if (!grepl(pattern, name)) 
[17:40:59.335]                             next
[17:40:59.335]                           invokeRestart(restart)
[17:40:59.335]                           muffled <- TRUE
[17:40:59.335]                           break
[17:40:59.335]                         }
[17:40:59.335]                       }
[17:40:59.335]                     }
[17:40:59.335]                     invisible(muffled)
[17:40:59.335]                   }
[17:40:59.335]                   muffleCondition(cond)
[17:40:59.335]                 })
[17:40:59.335]             }))
[17:40:59.335]             future::FutureResult(value = ...future.value$value, 
[17:40:59.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.335]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.335]                     ...future.globalenv.names))
[17:40:59.335]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.335]         }, condition = base::local({
[17:40:59.335]             c <- base::c
[17:40:59.335]             inherits <- base::inherits
[17:40:59.335]             invokeRestart <- base::invokeRestart
[17:40:59.335]             length <- base::length
[17:40:59.335]             list <- base::list
[17:40:59.335]             seq.int <- base::seq.int
[17:40:59.335]             signalCondition <- base::signalCondition
[17:40:59.335]             sys.calls <- base::sys.calls
[17:40:59.335]             `[[` <- base::`[[`
[17:40:59.335]             `+` <- base::`+`
[17:40:59.335]             `<<-` <- base::`<<-`
[17:40:59.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.335]                   3L)]
[17:40:59.335]             }
[17:40:59.335]             function(cond) {
[17:40:59.335]                 is_error <- inherits(cond, "error")
[17:40:59.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.335]                   NULL)
[17:40:59.335]                 if (is_error) {
[17:40:59.335]                   sessionInformation <- function() {
[17:40:59.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.335]                       search = base::search(), system = base::Sys.info())
[17:40:59.335]                   }
[17:40:59.335]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.335]                     cond$call), session = sessionInformation(), 
[17:40:59.335]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.335]                   signalCondition(cond)
[17:40:59.335]                 }
[17:40:59.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.335]                 "immediateCondition"))) {
[17:40:59.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.335]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.335]                   if (TRUE && !signal) {
[17:40:59.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.335]                     {
[17:40:59.335]                       inherits <- base::inherits
[17:40:59.335]                       invokeRestart <- base::invokeRestart
[17:40:59.335]                       is.null <- base::is.null
[17:40:59.335]                       muffled <- FALSE
[17:40:59.335]                       if (inherits(cond, "message")) {
[17:40:59.335]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.335]                         if (muffled) 
[17:40:59.335]                           invokeRestart("muffleMessage")
[17:40:59.335]                       }
[17:40:59.335]                       else if (inherits(cond, "warning")) {
[17:40:59.335]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.335]                         if (muffled) 
[17:40:59.335]                           invokeRestart("muffleWarning")
[17:40:59.335]                       }
[17:40:59.335]                       else if (inherits(cond, "condition")) {
[17:40:59.335]                         if (!is.null(pattern)) {
[17:40:59.335]                           computeRestarts <- base::computeRestarts
[17:40:59.335]                           grepl <- base::grepl
[17:40:59.335]                           restarts <- computeRestarts(cond)
[17:40:59.335]                           for (restart in restarts) {
[17:40:59.335]                             name <- restart$name
[17:40:59.335]                             if (is.null(name)) 
[17:40:59.335]                               next
[17:40:59.335]                             if (!grepl(pattern, name)) 
[17:40:59.335]                               next
[17:40:59.335]                             invokeRestart(restart)
[17:40:59.335]                             muffled <- TRUE
[17:40:59.335]                             break
[17:40:59.335]                           }
[17:40:59.335]                         }
[17:40:59.335]                       }
[17:40:59.335]                       invisible(muffled)
[17:40:59.335]                     }
[17:40:59.335]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.335]                   }
[17:40:59.335]                 }
[17:40:59.335]                 else {
[17:40:59.335]                   if (TRUE) {
[17:40:59.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.335]                     {
[17:40:59.335]                       inherits <- base::inherits
[17:40:59.335]                       invokeRestart <- base::invokeRestart
[17:40:59.335]                       is.null <- base::is.null
[17:40:59.335]                       muffled <- FALSE
[17:40:59.335]                       if (inherits(cond, "message")) {
[17:40:59.335]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.335]                         if (muffled) 
[17:40:59.335]                           invokeRestart("muffleMessage")
[17:40:59.335]                       }
[17:40:59.335]                       else if (inherits(cond, "warning")) {
[17:40:59.335]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.335]                         if (muffled) 
[17:40:59.335]                           invokeRestart("muffleWarning")
[17:40:59.335]                       }
[17:40:59.335]                       else if (inherits(cond, "condition")) {
[17:40:59.335]                         if (!is.null(pattern)) {
[17:40:59.335]                           computeRestarts <- base::computeRestarts
[17:40:59.335]                           grepl <- base::grepl
[17:40:59.335]                           restarts <- computeRestarts(cond)
[17:40:59.335]                           for (restart in restarts) {
[17:40:59.335]                             name <- restart$name
[17:40:59.335]                             if (is.null(name)) 
[17:40:59.335]                               next
[17:40:59.335]                             if (!grepl(pattern, name)) 
[17:40:59.335]                               next
[17:40:59.335]                             invokeRestart(restart)
[17:40:59.335]                             muffled <- TRUE
[17:40:59.335]                             break
[17:40:59.335]                           }
[17:40:59.335]                         }
[17:40:59.335]                       }
[17:40:59.335]                       invisible(muffled)
[17:40:59.335]                     }
[17:40:59.335]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.335]                   }
[17:40:59.335]                 }
[17:40:59.335]             }
[17:40:59.335]         }))
[17:40:59.335]     }, error = function(ex) {
[17:40:59.335]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.335]                 ...future.rng), started = ...future.startTime, 
[17:40:59.335]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.335]             version = "1.8"), class = "FutureResult")
[17:40:59.335]     }, finally = {
[17:40:59.335]         if (!identical(...future.workdir, getwd())) 
[17:40:59.335]             setwd(...future.workdir)
[17:40:59.335]         {
[17:40:59.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.335]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.335]             }
[17:40:59.335]             base::options(...future.oldOptions)
[17:40:59.335]             if (.Platform$OS.type == "windows") {
[17:40:59.335]                 old_names <- names(...future.oldEnvVars)
[17:40:59.335]                 envs <- base::Sys.getenv()
[17:40:59.335]                 names <- names(envs)
[17:40:59.335]                 common <- intersect(names, old_names)
[17:40:59.335]                 added <- setdiff(names, old_names)
[17:40:59.335]                 removed <- setdiff(old_names, names)
[17:40:59.335]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.335]                   envs[common]]
[17:40:59.335]                 NAMES <- toupper(changed)
[17:40:59.335]                 args <- list()
[17:40:59.335]                 for (kk in seq_along(NAMES)) {
[17:40:59.335]                   name <- changed[[kk]]
[17:40:59.335]                   NAME <- NAMES[[kk]]
[17:40:59.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.335]                     next
[17:40:59.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.335]                 }
[17:40:59.335]                 NAMES <- toupper(added)
[17:40:59.335]                 for (kk in seq_along(NAMES)) {
[17:40:59.335]                   name <- added[[kk]]
[17:40:59.335]                   NAME <- NAMES[[kk]]
[17:40:59.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.335]                     next
[17:40:59.335]                   args[[name]] <- ""
[17:40:59.335]                 }
[17:40:59.335]                 NAMES <- toupper(removed)
[17:40:59.335]                 for (kk in seq_along(NAMES)) {
[17:40:59.335]                   name <- removed[[kk]]
[17:40:59.335]                   NAME <- NAMES[[kk]]
[17:40:59.335]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.335]                     next
[17:40:59.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.335]                 }
[17:40:59.335]                 if (length(args) > 0) 
[17:40:59.335]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.335]             }
[17:40:59.335]             else {
[17:40:59.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.335]             }
[17:40:59.335]             {
[17:40:59.335]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.335]                   0L) {
[17:40:59.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.335]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.335]                   base::options(opts)
[17:40:59.335]                 }
[17:40:59.335]                 {
[17:40:59.335]                   {
[17:40:59.335]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.335]                     NULL
[17:40:59.335]                   }
[17:40:59.335]                   options(future.plan = NULL)
[17:40:59.335]                   if (is.na(NA_character_)) 
[17:40:59.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.335]                     .init = FALSE)
[17:40:59.335]                 }
[17:40:59.335]             }
[17:40:59.335]         }
[17:40:59.335]     })
[17:40:59.335]     if (TRUE) {
[17:40:59.335]         base::sink(type = "output", split = FALSE)
[17:40:59.335]         if (TRUE) {
[17:40:59.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.335]         }
[17:40:59.335]         else {
[17:40:59.335]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.335]         }
[17:40:59.335]         base::close(...future.stdout)
[17:40:59.335]         ...future.stdout <- NULL
[17:40:59.335]     }
[17:40:59.335]     ...future.result$conditions <- ...future.conditions
[17:40:59.335]     ...future.result$finished <- base::Sys.time()
[17:40:59.335]     ...future.result
[17:40:59.335] }
[17:40:59.337] MultisessionFuture started
[17:40:59.337] - Launch lazy future ... done
[17:40:59.338] run() for ‘MultisessionFuture’ ... done
[17:40:59.339] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.339] - Validating connection of MultisessionFuture
[17:40:59.339] - received message: FutureResult
[17:40:59.339] - Received FutureResult
[17:40:59.339] - Erased future from FutureRegistry
[17:40:59.339] result() for ClusterFuture ...
[17:40:59.339] - result already collected: FutureResult
[17:40:59.339] result() for ClusterFuture ... done
[17:40:59.340] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.340] Future #1
[17:40:59.340]  length: 2 (resolved future 1)
[17:40:59.340] run() for ‘Future’ ...
[17:40:59.340] - state: ‘created’
[17:40:59.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.353] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.353] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.353]   - Field: ‘node’
[17:40:59.354]   - Field: ‘label’
[17:40:59.354]   - Field: ‘local’
[17:40:59.354]   - Field: ‘owner’
[17:40:59.354]   - Field: ‘envir’
[17:40:59.354]   - Field: ‘workers’
[17:40:59.354]   - Field: ‘packages’
[17:40:59.354]   - Field: ‘gc’
[17:40:59.354]   - Field: ‘conditions’
[17:40:59.354]   - Field: ‘persistent’
[17:40:59.354]   - Field: ‘expr’
[17:40:59.354]   - Field: ‘uuid’
[17:40:59.355]   - Field: ‘seed’
[17:40:59.355]   - Field: ‘version’
[17:40:59.355]   - Field: ‘result’
[17:40:59.355]   - Field: ‘asynchronous’
[17:40:59.355]   - Field: ‘calls’
[17:40:59.355]   - Field: ‘globals’
[17:40:59.355]   - Field: ‘stdout’
[17:40:59.355]   - Field: ‘earlySignal’
[17:40:59.355]   - Field: ‘lazy’
[17:40:59.355]   - Field: ‘state’
[17:40:59.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.356] - Launch lazy future ...
[17:40:59.356] Packages needed by the future expression (n = 0): <none>
[17:40:59.356] Packages needed by future strategies (n = 0): <none>
[17:40:59.356] {
[17:40:59.356]     {
[17:40:59.356]         {
[17:40:59.356]             ...future.startTime <- base::Sys.time()
[17:40:59.356]             {
[17:40:59.356]                 {
[17:40:59.356]                   {
[17:40:59.356]                     {
[17:40:59.356]                       base::local({
[17:40:59.356]                         has_future <- base::requireNamespace("future", 
[17:40:59.356]                           quietly = TRUE)
[17:40:59.356]                         if (has_future) {
[17:40:59.356]                           ns <- base::getNamespace("future")
[17:40:59.356]                           version <- ns[[".package"]][["version"]]
[17:40:59.356]                           if (is.null(version)) 
[17:40:59.356]                             version <- utils::packageVersion("future")
[17:40:59.356]                         }
[17:40:59.356]                         else {
[17:40:59.356]                           version <- NULL
[17:40:59.356]                         }
[17:40:59.356]                         if (!has_future || version < "1.8.0") {
[17:40:59.356]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.356]                             "", base::R.version$version.string), 
[17:40:59.356]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.356]                               "release", "version")], collapse = " "), 
[17:40:59.356]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.356]                             info)
[17:40:59.356]                           info <- base::paste(info, collapse = "; ")
[17:40:59.356]                           if (!has_future) {
[17:40:59.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.356]                               info)
[17:40:59.356]                           }
[17:40:59.356]                           else {
[17:40:59.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.356]                               info, version)
[17:40:59.356]                           }
[17:40:59.356]                           base::stop(msg)
[17:40:59.356]                         }
[17:40:59.356]                       })
[17:40:59.356]                     }
[17:40:59.356]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.356]                     base::options(mc.cores = 1L)
[17:40:59.356]                   }
[17:40:59.356]                   ...future.strategy.old <- future::plan("list")
[17:40:59.356]                   options(future.plan = NULL)
[17:40:59.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.356]                 }
[17:40:59.356]                 ...future.workdir <- getwd()
[17:40:59.356]             }
[17:40:59.356]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.356]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.356]         }
[17:40:59.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.356]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.356]             base::names(...future.oldOptions))
[17:40:59.356]     }
[17:40:59.356]     if (FALSE) {
[17:40:59.356]     }
[17:40:59.356]     else {
[17:40:59.356]         if (TRUE) {
[17:40:59.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.356]                 open = "w")
[17:40:59.356]         }
[17:40:59.356]         else {
[17:40:59.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.356]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.356]         }
[17:40:59.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.356]             base::sink(type = "output", split = FALSE)
[17:40:59.356]             base::close(...future.stdout)
[17:40:59.356]         }, add = TRUE)
[17:40:59.356]     }
[17:40:59.356]     ...future.frame <- base::sys.nframe()
[17:40:59.356]     ...future.conditions <- base::list()
[17:40:59.356]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.356]     if (FALSE) {
[17:40:59.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.356]     }
[17:40:59.356]     ...future.result <- base::tryCatch({
[17:40:59.356]         base::withCallingHandlers({
[17:40:59.356]             ...future.value <- base::withVisible(base::local({
[17:40:59.356]                 ...future.makeSendCondition <- base::local({
[17:40:59.356]                   sendCondition <- NULL
[17:40:59.356]                   function(frame = 1L) {
[17:40:59.356]                     if (is.function(sendCondition)) 
[17:40:59.356]                       return(sendCondition)
[17:40:59.356]                     ns <- getNamespace("parallel")
[17:40:59.356]                     if (exists("sendData", mode = "function", 
[17:40:59.356]                       envir = ns)) {
[17:40:59.356]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.356]                         envir = ns)
[17:40:59.356]                       envir <- sys.frame(frame)
[17:40:59.356]                       master <- NULL
[17:40:59.356]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.356]                         !identical(envir, emptyenv())) {
[17:40:59.356]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.356]                           inherits = FALSE)) {
[17:40:59.356]                           master <- get("master", mode = "list", 
[17:40:59.356]                             envir = envir, inherits = FALSE)
[17:40:59.356]                           if (inherits(master, c("SOCKnode", 
[17:40:59.356]                             "SOCK0node"))) {
[17:40:59.356]                             sendCondition <<- function(cond) {
[17:40:59.356]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.356]                                 success = TRUE)
[17:40:59.356]                               parallel_sendData(master, data)
[17:40:59.356]                             }
[17:40:59.356]                             return(sendCondition)
[17:40:59.356]                           }
[17:40:59.356]                         }
[17:40:59.356]                         frame <- frame + 1L
[17:40:59.356]                         envir <- sys.frame(frame)
[17:40:59.356]                       }
[17:40:59.356]                     }
[17:40:59.356]                     sendCondition <<- function(cond) NULL
[17:40:59.356]                   }
[17:40:59.356]                 })
[17:40:59.356]                 withCallingHandlers({
[17:40:59.356]                   2
[17:40:59.356]                 }, immediateCondition = function(cond) {
[17:40:59.356]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.356]                   sendCondition(cond)
[17:40:59.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.356]                   {
[17:40:59.356]                     inherits <- base::inherits
[17:40:59.356]                     invokeRestart <- base::invokeRestart
[17:40:59.356]                     is.null <- base::is.null
[17:40:59.356]                     muffled <- FALSE
[17:40:59.356]                     if (inherits(cond, "message")) {
[17:40:59.356]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.356]                       if (muffled) 
[17:40:59.356]                         invokeRestart("muffleMessage")
[17:40:59.356]                     }
[17:40:59.356]                     else if (inherits(cond, "warning")) {
[17:40:59.356]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.356]                       if (muffled) 
[17:40:59.356]                         invokeRestart("muffleWarning")
[17:40:59.356]                     }
[17:40:59.356]                     else if (inherits(cond, "condition")) {
[17:40:59.356]                       if (!is.null(pattern)) {
[17:40:59.356]                         computeRestarts <- base::computeRestarts
[17:40:59.356]                         grepl <- base::grepl
[17:40:59.356]                         restarts <- computeRestarts(cond)
[17:40:59.356]                         for (restart in restarts) {
[17:40:59.356]                           name <- restart$name
[17:40:59.356]                           if (is.null(name)) 
[17:40:59.356]                             next
[17:40:59.356]                           if (!grepl(pattern, name)) 
[17:40:59.356]                             next
[17:40:59.356]                           invokeRestart(restart)
[17:40:59.356]                           muffled <- TRUE
[17:40:59.356]                           break
[17:40:59.356]                         }
[17:40:59.356]                       }
[17:40:59.356]                     }
[17:40:59.356]                     invisible(muffled)
[17:40:59.356]                   }
[17:40:59.356]                   muffleCondition(cond)
[17:40:59.356]                 })
[17:40:59.356]             }))
[17:40:59.356]             future::FutureResult(value = ...future.value$value, 
[17:40:59.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.356]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.356]                     ...future.globalenv.names))
[17:40:59.356]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.356]         }, condition = base::local({
[17:40:59.356]             c <- base::c
[17:40:59.356]             inherits <- base::inherits
[17:40:59.356]             invokeRestart <- base::invokeRestart
[17:40:59.356]             length <- base::length
[17:40:59.356]             list <- base::list
[17:40:59.356]             seq.int <- base::seq.int
[17:40:59.356]             signalCondition <- base::signalCondition
[17:40:59.356]             sys.calls <- base::sys.calls
[17:40:59.356]             `[[` <- base::`[[`
[17:40:59.356]             `+` <- base::`+`
[17:40:59.356]             `<<-` <- base::`<<-`
[17:40:59.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.356]                   3L)]
[17:40:59.356]             }
[17:40:59.356]             function(cond) {
[17:40:59.356]                 is_error <- inherits(cond, "error")
[17:40:59.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.356]                   NULL)
[17:40:59.356]                 if (is_error) {
[17:40:59.356]                   sessionInformation <- function() {
[17:40:59.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.356]                       search = base::search(), system = base::Sys.info())
[17:40:59.356]                   }
[17:40:59.356]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.356]                     cond$call), session = sessionInformation(), 
[17:40:59.356]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.356]                   signalCondition(cond)
[17:40:59.356]                 }
[17:40:59.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.356]                 "immediateCondition"))) {
[17:40:59.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.356]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.356]                   if (TRUE && !signal) {
[17:40:59.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.356]                     {
[17:40:59.356]                       inherits <- base::inherits
[17:40:59.356]                       invokeRestart <- base::invokeRestart
[17:40:59.356]                       is.null <- base::is.null
[17:40:59.356]                       muffled <- FALSE
[17:40:59.356]                       if (inherits(cond, "message")) {
[17:40:59.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.356]                         if (muffled) 
[17:40:59.356]                           invokeRestart("muffleMessage")
[17:40:59.356]                       }
[17:40:59.356]                       else if (inherits(cond, "warning")) {
[17:40:59.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.356]                         if (muffled) 
[17:40:59.356]                           invokeRestart("muffleWarning")
[17:40:59.356]                       }
[17:40:59.356]                       else if (inherits(cond, "condition")) {
[17:40:59.356]                         if (!is.null(pattern)) {
[17:40:59.356]                           computeRestarts <- base::computeRestarts
[17:40:59.356]                           grepl <- base::grepl
[17:40:59.356]                           restarts <- computeRestarts(cond)
[17:40:59.356]                           for (restart in restarts) {
[17:40:59.356]                             name <- restart$name
[17:40:59.356]                             if (is.null(name)) 
[17:40:59.356]                               next
[17:40:59.356]                             if (!grepl(pattern, name)) 
[17:40:59.356]                               next
[17:40:59.356]                             invokeRestart(restart)
[17:40:59.356]                             muffled <- TRUE
[17:40:59.356]                             break
[17:40:59.356]                           }
[17:40:59.356]                         }
[17:40:59.356]                       }
[17:40:59.356]                       invisible(muffled)
[17:40:59.356]                     }
[17:40:59.356]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.356]                   }
[17:40:59.356]                 }
[17:40:59.356]                 else {
[17:40:59.356]                   if (TRUE) {
[17:40:59.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.356]                     {
[17:40:59.356]                       inherits <- base::inherits
[17:40:59.356]                       invokeRestart <- base::invokeRestart
[17:40:59.356]                       is.null <- base::is.null
[17:40:59.356]                       muffled <- FALSE
[17:40:59.356]                       if (inherits(cond, "message")) {
[17:40:59.356]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.356]                         if (muffled) 
[17:40:59.356]                           invokeRestart("muffleMessage")
[17:40:59.356]                       }
[17:40:59.356]                       else if (inherits(cond, "warning")) {
[17:40:59.356]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.356]                         if (muffled) 
[17:40:59.356]                           invokeRestart("muffleWarning")
[17:40:59.356]                       }
[17:40:59.356]                       else if (inherits(cond, "condition")) {
[17:40:59.356]                         if (!is.null(pattern)) {
[17:40:59.356]                           computeRestarts <- base::computeRestarts
[17:40:59.356]                           grepl <- base::grepl
[17:40:59.356]                           restarts <- computeRestarts(cond)
[17:40:59.356]                           for (restart in restarts) {
[17:40:59.356]                             name <- restart$name
[17:40:59.356]                             if (is.null(name)) 
[17:40:59.356]                               next
[17:40:59.356]                             if (!grepl(pattern, name)) 
[17:40:59.356]                               next
[17:40:59.356]                             invokeRestart(restart)
[17:40:59.356]                             muffled <- TRUE
[17:40:59.356]                             break
[17:40:59.356]                           }
[17:40:59.356]                         }
[17:40:59.356]                       }
[17:40:59.356]                       invisible(muffled)
[17:40:59.356]                     }
[17:40:59.356]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.356]                   }
[17:40:59.356]                 }
[17:40:59.356]             }
[17:40:59.356]         }))
[17:40:59.356]     }, error = function(ex) {
[17:40:59.356]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.356]                 ...future.rng), started = ...future.startTime, 
[17:40:59.356]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.356]             version = "1.8"), class = "FutureResult")
[17:40:59.356]     }, finally = {
[17:40:59.356]         if (!identical(...future.workdir, getwd())) 
[17:40:59.356]             setwd(...future.workdir)
[17:40:59.356]         {
[17:40:59.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.356]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.356]             }
[17:40:59.356]             base::options(...future.oldOptions)
[17:40:59.356]             if (.Platform$OS.type == "windows") {
[17:40:59.356]                 old_names <- names(...future.oldEnvVars)
[17:40:59.356]                 envs <- base::Sys.getenv()
[17:40:59.356]                 names <- names(envs)
[17:40:59.356]                 common <- intersect(names, old_names)
[17:40:59.356]                 added <- setdiff(names, old_names)
[17:40:59.356]                 removed <- setdiff(old_names, names)
[17:40:59.356]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.356]                   envs[common]]
[17:40:59.356]                 NAMES <- toupper(changed)
[17:40:59.356]                 args <- list()
[17:40:59.356]                 for (kk in seq_along(NAMES)) {
[17:40:59.356]                   name <- changed[[kk]]
[17:40:59.356]                   NAME <- NAMES[[kk]]
[17:40:59.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.356]                     next
[17:40:59.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.356]                 }
[17:40:59.356]                 NAMES <- toupper(added)
[17:40:59.356]                 for (kk in seq_along(NAMES)) {
[17:40:59.356]                   name <- added[[kk]]
[17:40:59.356]                   NAME <- NAMES[[kk]]
[17:40:59.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.356]                     next
[17:40:59.356]                   args[[name]] <- ""
[17:40:59.356]                 }
[17:40:59.356]                 NAMES <- toupper(removed)
[17:40:59.356]                 for (kk in seq_along(NAMES)) {
[17:40:59.356]                   name <- removed[[kk]]
[17:40:59.356]                   NAME <- NAMES[[kk]]
[17:40:59.356]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.356]                     next
[17:40:59.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.356]                 }
[17:40:59.356]                 if (length(args) > 0) 
[17:40:59.356]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.356]             }
[17:40:59.356]             else {
[17:40:59.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.356]             }
[17:40:59.356]             {
[17:40:59.356]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.356]                   0L) {
[17:40:59.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.356]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.356]                   base::options(opts)
[17:40:59.356]                 }
[17:40:59.356]                 {
[17:40:59.356]                   {
[17:40:59.356]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.356]                     NULL
[17:40:59.356]                   }
[17:40:59.356]                   options(future.plan = NULL)
[17:40:59.356]                   if (is.na(NA_character_)) 
[17:40:59.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.356]                     .init = FALSE)
[17:40:59.356]                 }
[17:40:59.356]             }
[17:40:59.356]         }
[17:40:59.356]     })
[17:40:59.356]     if (TRUE) {
[17:40:59.356]         base::sink(type = "output", split = FALSE)
[17:40:59.356]         if (TRUE) {
[17:40:59.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.356]         }
[17:40:59.356]         else {
[17:40:59.356]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.356]         }
[17:40:59.356]         base::close(...future.stdout)
[17:40:59.356]         ...future.stdout <- NULL
[17:40:59.356]     }
[17:40:59.356]     ...future.result$conditions <- ...future.conditions
[17:40:59.356]     ...future.result$finished <- base::Sys.time()
[17:40:59.356]     ...future.result
[17:40:59.356] }
[17:40:59.359] MultisessionFuture started
[17:40:59.359] - Launch lazy future ... done
[17:40:59.359] run() for ‘MultisessionFuture’ ... done
[17:40:59.360] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.361] - Validating connection of MultisessionFuture
[17:40:59.361] - received message: FutureResult
[17:40:59.361] - Received FutureResult
[17:40:59.361] - Erased future from FutureRegistry
[17:40:59.361] result() for ClusterFuture ...
[17:40:59.361] - result already collected: FutureResult
[17:40:59.361] result() for ClusterFuture ... done
[17:40:59.361] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.361] Future #2
[17:40:59.361]  length: 1 (resolved future 2)
[17:40:59.362]  length: 0 (resolved future 3)
[17:40:59.362] resolve() on list ... DONE
[17:40:59.362] getGlobalsAndPackages() ...
[17:40:59.362] Searching for globals...
[17:40:59.362] 
[17:40:59.362] Searching for globals ... DONE
[17:40:59.362] - globals: [0] <none>
[17:40:59.362] getGlobalsAndPackages() ... DONE
[17:40:59.363] run() for ‘Future’ ...
[17:40:59.363] - state: ‘created’
[17:40:59.363] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.376] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.377]   - Field: ‘node’
[17:40:59.377]   - Field: ‘label’
[17:40:59.377]   - Field: ‘local’
[17:40:59.377]   - Field: ‘owner’
[17:40:59.377]   - Field: ‘envir’
[17:40:59.377]   - Field: ‘workers’
[17:40:59.377]   - Field: ‘packages’
[17:40:59.377]   - Field: ‘gc’
[17:40:59.377]   - Field: ‘conditions’
[17:40:59.377]   - Field: ‘persistent’
[17:40:59.377]   - Field: ‘expr’
[17:40:59.378]   - Field: ‘uuid’
[17:40:59.378]   - Field: ‘seed’
[17:40:59.378]   - Field: ‘version’
[17:40:59.378]   - Field: ‘result’
[17:40:59.378]   - Field: ‘asynchronous’
[17:40:59.378]   - Field: ‘calls’
[17:40:59.378]   - Field: ‘globals’
[17:40:59.378]   - Field: ‘stdout’
[17:40:59.378]   - Field: ‘earlySignal’
[17:40:59.378]   - Field: ‘lazy’
[17:40:59.378]   - Field: ‘state’
[17:40:59.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.379] - Launch lazy future ...
[17:40:59.379] Packages needed by the future expression (n = 0): <none>
[17:40:59.379] Packages needed by future strategies (n = 0): <none>
[17:40:59.379] {
[17:40:59.379]     {
[17:40:59.379]         {
[17:40:59.379]             ...future.startTime <- base::Sys.time()
[17:40:59.379]             {
[17:40:59.379]                 {
[17:40:59.379]                   {
[17:40:59.379]                     {
[17:40:59.379]                       base::local({
[17:40:59.379]                         has_future <- base::requireNamespace("future", 
[17:40:59.379]                           quietly = TRUE)
[17:40:59.379]                         if (has_future) {
[17:40:59.379]                           ns <- base::getNamespace("future")
[17:40:59.379]                           version <- ns[[".package"]][["version"]]
[17:40:59.379]                           if (is.null(version)) 
[17:40:59.379]                             version <- utils::packageVersion("future")
[17:40:59.379]                         }
[17:40:59.379]                         else {
[17:40:59.379]                           version <- NULL
[17:40:59.379]                         }
[17:40:59.379]                         if (!has_future || version < "1.8.0") {
[17:40:59.379]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.379]                             "", base::R.version$version.string), 
[17:40:59.379]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.379]                               "release", "version")], collapse = " "), 
[17:40:59.379]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.379]                             info)
[17:40:59.379]                           info <- base::paste(info, collapse = "; ")
[17:40:59.379]                           if (!has_future) {
[17:40:59.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.379]                               info)
[17:40:59.379]                           }
[17:40:59.379]                           else {
[17:40:59.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.379]                               info, version)
[17:40:59.379]                           }
[17:40:59.379]                           base::stop(msg)
[17:40:59.379]                         }
[17:40:59.379]                       })
[17:40:59.379]                     }
[17:40:59.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.379]                     base::options(mc.cores = 1L)
[17:40:59.379]                   }
[17:40:59.379]                   ...future.strategy.old <- future::plan("list")
[17:40:59.379]                   options(future.plan = NULL)
[17:40:59.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.379]                 }
[17:40:59.379]                 ...future.workdir <- getwd()
[17:40:59.379]             }
[17:40:59.379]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.379]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.379]         }
[17:40:59.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.379]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.379]             base::names(...future.oldOptions))
[17:40:59.379]     }
[17:40:59.379]     if (FALSE) {
[17:40:59.379]     }
[17:40:59.379]     else {
[17:40:59.379]         if (TRUE) {
[17:40:59.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.379]                 open = "w")
[17:40:59.379]         }
[17:40:59.379]         else {
[17:40:59.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.379]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.379]         }
[17:40:59.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.379]             base::sink(type = "output", split = FALSE)
[17:40:59.379]             base::close(...future.stdout)
[17:40:59.379]         }, add = TRUE)
[17:40:59.379]     }
[17:40:59.379]     ...future.frame <- base::sys.nframe()
[17:40:59.379]     ...future.conditions <- base::list()
[17:40:59.379]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.379]     if (FALSE) {
[17:40:59.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.379]     }
[17:40:59.379]     ...future.result <- base::tryCatch({
[17:40:59.379]         base::withCallingHandlers({
[17:40:59.379]             ...future.value <- base::withVisible(base::local({
[17:40:59.379]                 ...future.makeSendCondition <- base::local({
[17:40:59.379]                   sendCondition <- NULL
[17:40:59.379]                   function(frame = 1L) {
[17:40:59.379]                     if (is.function(sendCondition)) 
[17:40:59.379]                       return(sendCondition)
[17:40:59.379]                     ns <- getNamespace("parallel")
[17:40:59.379]                     if (exists("sendData", mode = "function", 
[17:40:59.379]                       envir = ns)) {
[17:40:59.379]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.379]                         envir = ns)
[17:40:59.379]                       envir <- sys.frame(frame)
[17:40:59.379]                       master <- NULL
[17:40:59.379]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.379]                         !identical(envir, emptyenv())) {
[17:40:59.379]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.379]                           inherits = FALSE)) {
[17:40:59.379]                           master <- get("master", mode = "list", 
[17:40:59.379]                             envir = envir, inherits = FALSE)
[17:40:59.379]                           if (inherits(master, c("SOCKnode", 
[17:40:59.379]                             "SOCK0node"))) {
[17:40:59.379]                             sendCondition <<- function(cond) {
[17:40:59.379]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.379]                                 success = TRUE)
[17:40:59.379]                               parallel_sendData(master, data)
[17:40:59.379]                             }
[17:40:59.379]                             return(sendCondition)
[17:40:59.379]                           }
[17:40:59.379]                         }
[17:40:59.379]                         frame <- frame + 1L
[17:40:59.379]                         envir <- sys.frame(frame)
[17:40:59.379]                       }
[17:40:59.379]                     }
[17:40:59.379]                     sendCondition <<- function(cond) NULL
[17:40:59.379]                   }
[17:40:59.379]                 })
[17:40:59.379]                 withCallingHandlers({
[17:40:59.379]                   1
[17:40:59.379]                 }, immediateCondition = function(cond) {
[17:40:59.379]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.379]                   sendCondition(cond)
[17:40:59.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.379]                   {
[17:40:59.379]                     inherits <- base::inherits
[17:40:59.379]                     invokeRestart <- base::invokeRestart
[17:40:59.379]                     is.null <- base::is.null
[17:40:59.379]                     muffled <- FALSE
[17:40:59.379]                     if (inherits(cond, "message")) {
[17:40:59.379]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.379]                       if (muffled) 
[17:40:59.379]                         invokeRestart("muffleMessage")
[17:40:59.379]                     }
[17:40:59.379]                     else if (inherits(cond, "warning")) {
[17:40:59.379]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.379]                       if (muffled) 
[17:40:59.379]                         invokeRestart("muffleWarning")
[17:40:59.379]                     }
[17:40:59.379]                     else if (inherits(cond, "condition")) {
[17:40:59.379]                       if (!is.null(pattern)) {
[17:40:59.379]                         computeRestarts <- base::computeRestarts
[17:40:59.379]                         grepl <- base::grepl
[17:40:59.379]                         restarts <- computeRestarts(cond)
[17:40:59.379]                         for (restart in restarts) {
[17:40:59.379]                           name <- restart$name
[17:40:59.379]                           if (is.null(name)) 
[17:40:59.379]                             next
[17:40:59.379]                           if (!grepl(pattern, name)) 
[17:40:59.379]                             next
[17:40:59.379]                           invokeRestart(restart)
[17:40:59.379]                           muffled <- TRUE
[17:40:59.379]                           break
[17:40:59.379]                         }
[17:40:59.379]                       }
[17:40:59.379]                     }
[17:40:59.379]                     invisible(muffled)
[17:40:59.379]                   }
[17:40:59.379]                   muffleCondition(cond)
[17:40:59.379]                 })
[17:40:59.379]             }))
[17:40:59.379]             future::FutureResult(value = ...future.value$value, 
[17:40:59.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.379]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.379]                     ...future.globalenv.names))
[17:40:59.379]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.379]         }, condition = base::local({
[17:40:59.379]             c <- base::c
[17:40:59.379]             inherits <- base::inherits
[17:40:59.379]             invokeRestart <- base::invokeRestart
[17:40:59.379]             length <- base::length
[17:40:59.379]             list <- base::list
[17:40:59.379]             seq.int <- base::seq.int
[17:40:59.379]             signalCondition <- base::signalCondition
[17:40:59.379]             sys.calls <- base::sys.calls
[17:40:59.379]             `[[` <- base::`[[`
[17:40:59.379]             `+` <- base::`+`
[17:40:59.379]             `<<-` <- base::`<<-`
[17:40:59.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.379]                   3L)]
[17:40:59.379]             }
[17:40:59.379]             function(cond) {
[17:40:59.379]                 is_error <- inherits(cond, "error")
[17:40:59.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.379]                   NULL)
[17:40:59.379]                 if (is_error) {
[17:40:59.379]                   sessionInformation <- function() {
[17:40:59.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.379]                       search = base::search(), system = base::Sys.info())
[17:40:59.379]                   }
[17:40:59.379]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.379]                     cond$call), session = sessionInformation(), 
[17:40:59.379]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.379]                   signalCondition(cond)
[17:40:59.379]                 }
[17:40:59.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.379]                 "immediateCondition"))) {
[17:40:59.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.379]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.379]                   if (TRUE && !signal) {
[17:40:59.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.379]                     {
[17:40:59.379]                       inherits <- base::inherits
[17:40:59.379]                       invokeRestart <- base::invokeRestart
[17:40:59.379]                       is.null <- base::is.null
[17:40:59.379]                       muffled <- FALSE
[17:40:59.379]                       if (inherits(cond, "message")) {
[17:40:59.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.379]                         if (muffled) 
[17:40:59.379]                           invokeRestart("muffleMessage")
[17:40:59.379]                       }
[17:40:59.379]                       else if (inherits(cond, "warning")) {
[17:40:59.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.379]                         if (muffled) 
[17:40:59.379]                           invokeRestart("muffleWarning")
[17:40:59.379]                       }
[17:40:59.379]                       else if (inherits(cond, "condition")) {
[17:40:59.379]                         if (!is.null(pattern)) {
[17:40:59.379]                           computeRestarts <- base::computeRestarts
[17:40:59.379]                           grepl <- base::grepl
[17:40:59.379]                           restarts <- computeRestarts(cond)
[17:40:59.379]                           for (restart in restarts) {
[17:40:59.379]                             name <- restart$name
[17:40:59.379]                             if (is.null(name)) 
[17:40:59.379]                               next
[17:40:59.379]                             if (!grepl(pattern, name)) 
[17:40:59.379]                               next
[17:40:59.379]                             invokeRestart(restart)
[17:40:59.379]                             muffled <- TRUE
[17:40:59.379]                             break
[17:40:59.379]                           }
[17:40:59.379]                         }
[17:40:59.379]                       }
[17:40:59.379]                       invisible(muffled)
[17:40:59.379]                     }
[17:40:59.379]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.379]                   }
[17:40:59.379]                 }
[17:40:59.379]                 else {
[17:40:59.379]                   if (TRUE) {
[17:40:59.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.379]                     {
[17:40:59.379]                       inherits <- base::inherits
[17:40:59.379]                       invokeRestart <- base::invokeRestart
[17:40:59.379]                       is.null <- base::is.null
[17:40:59.379]                       muffled <- FALSE
[17:40:59.379]                       if (inherits(cond, "message")) {
[17:40:59.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.379]                         if (muffled) 
[17:40:59.379]                           invokeRestart("muffleMessage")
[17:40:59.379]                       }
[17:40:59.379]                       else if (inherits(cond, "warning")) {
[17:40:59.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.379]                         if (muffled) 
[17:40:59.379]                           invokeRestart("muffleWarning")
[17:40:59.379]                       }
[17:40:59.379]                       else if (inherits(cond, "condition")) {
[17:40:59.379]                         if (!is.null(pattern)) {
[17:40:59.379]                           computeRestarts <- base::computeRestarts
[17:40:59.379]                           grepl <- base::grepl
[17:40:59.379]                           restarts <- computeRestarts(cond)
[17:40:59.379]                           for (restart in restarts) {
[17:40:59.379]                             name <- restart$name
[17:40:59.379]                             if (is.null(name)) 
[17:40:59.379]                               next
[17:40:59.379]                             if (!grepl(pattern, name)) 
[17:40:59.379]                               next
[17:40:59.379]                             invokeRestart(restart)
[17:40:59.379]                             muffled <- TRUE
[17:40:59.379]                             break
[17:40:59.379]                           }
[17:40:59.379]                         }
[17:40:59.379]                       }
[17:40:59.379]                       invisible(muffled)
[17:40:59.379]                     }
[17:40:59.379]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.379]                   }
[17:40:59.379]                 }
[17:40:59.379]             }
[17:40:59.379]         }))
[17:40:59.379]     }, error = function(ex) {
[17:40:59.379]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.379]                 ...future.rng), started = ...future.startTime, 
[17:40:59.379]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.379]             version = "1.8"), class = "FutureResult")
[17:40:59.379]     }, finally = {
[17:40:59.379]         if (!identical(...future.workdir, getwd())) 
[17:40:59.379]             setwd(...future.workdir)
[17:40:59.379]         {
[17:40:59.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.379]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.379]             }
[17:40:59.379]             base::options(...future.oldOptions)
[17:40:59.379]             if (.Platform$OS.type == "windows") {
[17:40:59.379]                 old_names <- names(...future.oldEnvVars)
[17:40:59.379]                 envs <- base::Sys.getenv()
[17:40:59.379]                 names <- names(envs)
[17:40:59.379]                 common <- intersect(names, old_names)
[17:40:59.379]                 added <- setdiff(names, old_names)
[17:40:59.379]                 removed <- setdiff(old_names, names)
[17:40:59.379]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.379]                   envs[common]]
[17:40:59.379]                 NAMES <- toupper(changed)
[17:40:59.379]                 args <- list()
[17:40:59.379]                 for (kk in seq_along(NAMES)) {
[17:40:59.379]                   name <- changed[[kk]]
[17:40:59.379]                   NAME <- NAMES[[kk]]
[17:40:59.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.379]                     next
[17:40:59.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.379]                 }
[17:40:59.379]                 NAMES <- toupper(added)
[17:40:59.379]                 for (kk in seq_along(NAMES)) {
[17:40:59.379]                   name <- added[[kk]]
[17:40:59.379]                   NAME <- NAMES[[kk]]
[17:40:59.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.379]                     next
[17:40:59.379]                   args[[name]] <- ""
[17:40:59.379]                 }
[17:40:59.379]                 NAMES <- toupper(removed)
[17:40:59.379]                 for (kk in seq_along(NAMES)) {
[17:40:59.379]                   name <- removed[[kk]]
[17:40:59.379]                   NAME <- NAMES[[kk]]
[17:40:59.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.379]                     next
[17:40:59.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.379]                 }
[17:40:59.379]                 if (length(args) > 0) 
[17:40:59.379]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.379]             }
[17:40:59.379]             else {
[17:40:59.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.379]             }
[17:40:59.379]             {
[17:40:59.379]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.379]                   0L) {
[17:40:59.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.379]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.379]                   base::options(opts)
[17:40:59.379]                 }
[17:40:59.379]                 {
[17:40:59.379]                   {
[17:40:59.379]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.379]                     NULL
[17:40:59.379]                   }
[17:40:59.379]                   options(future.plan = NULL)
[17:40:59.379]                   if (is.na(NA_character_)) 
[17:40:59.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.379]                     .init = FALSE)
[17:40:59.379]                 }
[17:40:59.379]             }
[17:40:59.379]         }
[17:40:59.379]     })
[17:40:59.379]     if (TRUE) {
[17:40:59.379]         base::sink(type = "output", split = FALSE)
[17:40:59.379]         if (TRUE) {
[17:40:59.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.379]         }
[17:40:59.379]         else {
[17:40:59.379]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.379]         }
[17:40:59.379]         base::close(...future.stdout)
[17:40:59.379]         ...future.stdout <- NULL
[17:40:59.379]     }
[17:40:59.379]     ...future.result$conditions <- ...future.conditions
[17:40:59.379]     ...future.result$finished <- base::Sys.time()
[17:40:59.379]     ...future.result
[17:40:59.379] }
[17:40:59.382] MultisessionFuture started
[17:40:59.382] - Launch lazy future ... done
[17:40:59.383] run() for ‘MultisessionFuture’ ... done
[17:40:59.383] getGlobalsAndPackages() ...
[17:40:59.383] Searching for globals...
[17:40:59.384] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:40:59.384] Searching for globals ... DONE
[17:40:59.384] Resolving globals: FALSE
[17:40:59.384] 
[17:40:59.384] 
[17:40:59.384] getGlobalsAndPackages() ... DONE
[17:40:59.385] run() for ‘Future’ ...
[17:40:59.385] - state: ‘created’
[17:40:59.385] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.398] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.399]   - Field: ‘node’
[17:40:59.399]   - Field: ‘label’
[17:40:59.399]   - Field: ‘local’
[17:40:59.399]   - Field: ‘owner’
[17:40:59.399]   - Field: ‘envir’
[17:40:59.399]   - Field: ‘workers’
[17:40:59.399]   - Field: ‘packages’
[17:40:59.399]   - Field: ‘gc’
[17:40:59.399]   - Field: ‘conditions’
[17:40:59.399]   - Field: ‘persistent’
[17:40:59.400]   - Field: ‘expr’
[17:40:59.400]   - Field: ‘uuid’
[17:40:59.400]   - Field: ‘seed’
[17:40:59.400]   - Field: ‘version’
[17:40:59.400]   - Field: ‘result’
[17:40:59.400]   - Field: ‘asynchronous’
[17:40:59.400]   - Field: ‘calls’
[17:40:59.400]   - Field: ‘globals’
[17:40:59.400]   - Field: ‘stdout’
[17:40:59.400]   - Field: ‘earlySignal’
[17:40:59.400]   - Field: ‘lazy’
[17:40:59.401]   - Field: ‘state’
[17:40:59.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.401] - Launch lazy future ...
[17:40:59.403] Packages needed by the future expression (n = 0): <none>
[17:40:59.404] Packages needed by future strategies (n = 0): <none>
[17:40:59.404] {
[17:40:59.404]     {
[17:40:59.404]         {
[17:40:59.404]             ...future.startTime <- base::Sys.time()
[17:40:59.404]             {
[17:40:59.404]                 {
[17:40:59.404]                   {
[17:40:59.404]                     {
[17:40:59.404]                       base::local({
[17:40:59.404]                         has_future <- base::requireNamespace("future", 
[17:40:59.404]                           quietly = TRUE)
[17:40:59.404]                         if (has_future) {
[17:40:59.404]                           ns <- base::getNamespace("future")
[17:40:59.404]                           version <- ns[[".package"]][["version"]]
[17:40:59.404]                           if (is.null(version)) 
[17:40:59.404]                             version <- utils::packageVersion("future")
[17:40:59.404]                         }
[17:40:59.404]                         else {
[17:40:59.404]                           version <- NULL
[17:40:59.404]                         }
[17:40:59.404]                         if (!has_future || version < "1.8.0") {
[17:40:59.404]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.404]                             "", base::R.version$version.string), 
[17:40:59.404]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.404]                               "release", "version")], collapse = " "), 
[17:40:59.404]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.404]                             info)
[17:40:59.404]                           info <- base::paste(info, collapse = "; ")
[17:40:59.404]                           if (!has_future) {
[17:40:59.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.404]                               info)
[17:40:59.404]                           }
[17:40:59.404]                           else {
[17:40:59.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.404]                               info, version)
[17:40:59.404]                           }
[17:40:59.404]                           base::stop(msg)
[17:40:59.404]                         }
[17:40:59.404]                       })
[17:40:59.404]                     }
[17:40:59.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.404]                     base::options(mc.cores = 1L)
[17:40:59.404]                   }
[17:40:59.404]                   ...future.strategy.old <- future::plan("list")
[17:40:59.404]                   options(future.plan = NULL)
[17:40:59.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.404]                 }
[17:40:59.404]                 ...future.workdir <- getwd()
[17:40:59.404]             }
[17:40:59.404]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.404]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.404]         }
[17:40:59.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.404]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.404]             base::names(...future.oldOptions))
[17:40:59.404]     }
[17:40:59.404]     if (FALSE) {
[17:40:59.404]     }
[17:40:59.404]     else {
[17:40:59.404]         if (TRUE) {
[17:40:59.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.404]                 open = "w")
[17:40:59.404]         }
[17:40:59.404]         else {
[17:40:59.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.404]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.404]         }
[17:40:59.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.404]             base::sink(type = "output", split = FALSE)
[17:40:59.404]             base::close(...future.stdout)
[17:40:59.404]         }, add = TRUE)
[17:40:59.404]     }
[17:40:59.404]     ...future.frame <- base::sys.nframe()
[17:40:59.404]     ...future.conditions <- base::list()
[17:40:59.404]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.404]     if (FALSE) {
[17:40:59.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.404]     }
[17:40:59.404]     ...future.result <- base::tryCatch({
[17:40:59.404]         base::withCallingHandlers({
[17:40:59.404]             ...future.value <- base::withVisible(base::local({
[17:40:59.404]                 ...future.makeSendCondition <- base::local({
[17:40:59.404]                   sendCondition <- NULL
[17:40:59.404]                   function(frame = 1L) {
[17:40:59.404]                     if (is.function(sendCondition)) 
[17:40:59.404]                       return(sendCondition)
[17:40:59.404]                     ns <- getNamespace("parallel")
[17:40:59.404]                     if (exists("sendData", mode = "function", 
[17:40:59.404]                       envir = ns)) {
[17:40:59.404]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.404]                         envir = ns)
[17:40:59.404]                       envir <- sys.frame(frame)
[17:40:59.404]                       master <- NULL
[17:40:59.404]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.404]                         !identical(envir, emptyenv())) {
[17:40:59.404]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.404]                           inherits = FALSE)) {
[17:40:59.404]                           master <- get("master", mode = "list", 
[17:40:59.404]                             envir = envir, inherits = FALSE)
[17:40:59.404]                           if (inherits(master, c("SOCKnode", 
[17:40:59.404]                             "SOCK0node"))) {
[17:40:59.404]                             sendCondition <<- function(cond) {
[17:40:59.404]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.404]                                 success = TRUE)
[17:40:59.404]                               parallel_sendData(master, data)
[17:40:59.404]                             }
[17:40:59.404]                             return(sendCondition)
[17:40:59.404]                           }
[17:40:59.404]                         }
[17:40:59.404]                         frame <- frame + 1L
[17:40:59.404]                         envir <- sys.frame(frame)
[17:40:59.404]                       }
[17:40:59.404]                     }
[17:40:59.404]                     sendCondition <<- function(cond) NULL
[17:40:59.404]                   }
[17:40:59.404]                 })
[17:40:59.404]                 withCallingHandlers({
[17:40:59.404]                   {
[17:40:59.404]                     Sys.sleep(0.5)
[17:40:59.404]                     2
[17:40:59.404]                   }
[17:40:59.404]                 }, immediateCondition = function(cond) {
[17:40:59.404]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.404]                   sendCondition(cond)
[17:40:59.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.404]                   {
[17:40:59.404]                     inherits <- base::inherits
[17:40:59.404]                     invokeRestart <- base::invokeRestart
[17:40:59.404]                     is.null <- base::is.null
[17:40:59.404]                     muffled <- FALSE
[17:40:59.404]                     if (inherits(cond, "message")) {
[17:40:59.404]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.404]                       if (muffled) 
[17:40:59.404]                         invokeRestart("muffleMessage")
[17:40:59.404]                     }
[17:40:59.404]                     else if (inherits(cond, "warning")) {
[17:40:59.404]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.404]                       if (muffled) 
[17:40:59.404]                         invokeRestart("muffleWarning")
[17:40:59.404]                     }
[17:40:59.404]                     else if (inherits(cond, "condition")) {
[17:40:59.404]                       if (!is.null(pattern)) {
[17:40:59.404]                         computeRestarts <- base::computeRestarts
[17:40:59.404]                         grepl <- base::grepl
[17:40:59.404]                         restarts <- computeRestarts(cond)
[17:40:59.404]                         for (restart in restarts) {
[17:40:59.404]                           name <- restart$name
[17:40:59.404]                           if (is.null(name)) 
[17:40:59.404]                             next
[17:40:59.404]                           if (!grepl(pattern, name)) 
[17:40:59.404]                             next
[17:40:59.404]                           invokeRestart(restart)
[17:40:59.404]                           muffled <- TRUE
[17:40:59.404]                           break
[17:40:59.404]                         }
[17:40:59.404]                       }
[17:40:59.404]                     }
[17:40:59.404]                     invisible(muffled)
[17:40:59.404]                   }
[17:40:59.404]                   muffleCondition(cond)
[17:40:59.404]                 })
[17:40:59.404]             }))
[17:40:59.404]             future::FutureResult(value = ...future.value$value, 
[17:40:59.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.404]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.404]                     ...future.globalenv.names))
[17:40:59.404]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.404]         }, condition = base::local({
[17:40:59.404]             c <- base::c
[17:40:59.404]             inherits <- base::inherits
[17:40:59.404]             invokeRestart <- base::invokeRestart
[17:40:59.404]             length <- base::length
[17:40:59.404]             list <- base::list
[17:40:59.404]             seq.int <- base::seq.int
[17:40:59.404]             signalCondition <- base::signalCondition
[17:40:59.404]             sys.calls <- base::sys.calls
[17:40:59.404]             `[[` <- base::`[[`
[17:40:59.404]             `+` <- base::`+`
[17:40:59.404]             `<<-` <- base::`<<-`
[17:40:59.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.404]                   3L)]
[17:40:59.404]             }
[17:40:59.404]             function(cond) {
[17:40:59.404]                 is_error <- inherits(cond, "error")
[17:40:59.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.404]                   NULL)
[17:40:59.404]                 if (is_error) {
[17:40:59.404]                   sessionInformation <- function() {
[17:40:59.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.404]                       search = base::search(), system = base::Sys.info())
[17:40:59.404]                   }
[17:40:59.404]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.404]                     cond$call), session = sessionInformation(), 
[17:40:59.404]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.404]                   signalCondition(cond)
[17:40:59.404]                 }
[17:40:59.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.404]                 "immediateCondition"))) {
[17:40:59.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.404]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.404]                   if (TRUE && !signal) {
[17:40:59.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.404]                     {
[17:40:59.404]                       inherits <- base::inherits
[17:40:59.404]                       invokeRestart <- base::invokeRestart
[17:40:59.404]                       is.null <- base::is.null
[17:40:59.404]                       muffled <- FALSE
[17:40:59.404]                       if (inherits(cond, "message")) {
[17:40:59.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.404]                         if (muffled) 
[17:40:59.404]                           invokeRestart("muffleMessage")
[17:40:59.404]                       }
[17:40:59.404]                       else if (inherits(cond, "warning")) {
[17:40:59.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.404]                         if (muffled) 
[17:40:59.404]                           invokeRestart("muffleWarning")
[17:40:59.404]                       }
[17:40:59.404]                       else if (inherits(cond, "condition")) {
[17:40:59.404]                         if (!is.null(pattern)) {
[17:40:59.404]                           computeRestarts <- base::computeRestarts
[17:40:59.404]                           grepl <- base::grepl
[17:40:59.404]                           restarts <- computeRestarts(cond)
[17:40:59.404]                           for (restart in restarts) {
[17:40:59.404]                             name <- restart$name
[17:40:59.404]                             if (is.null(name)) 
[17:40:59.404]                               next
[17:40:59.404]                             if (!grepl(pattern, name)) 
[17:40:59.404]                               next
[17:40:59.404]                             invokeRestart(restart)
[17:40:59.404]                             muffled <- TRUE
[17:40:59.404]                             break
[17:40:59.404]                           }
[17:40:59.404]                         }
[17:40:59.404]                       }
[17:40:59.404]                       invisible(muffled)
[17:40:59.404]                     }
[17:40:59.404]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.404]                   }
[17:40:59.404]                 }
[17:40:59.404]                 else {
[17:40:59.404]                   if (TRUE) {
[17:40:59.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.404]                     {
[17:40:59.404]                       inherits <- base::inherits
[17:40:59.404]                       invokeRestart <- base::invokeRestart
[17:40:59.404]                       is.null <- base::is.null
[17:40:59.404]                       muffled <- FALSE
[17:40:59.404]                       if (inherits(cond, "message")) {
[17:40:59.404]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.404]                         if (muffled) 
[17:40:59.404]                           invokeRestart("muffleMessage")
[17:40:59.404]                       }
[17:40:59.404]                       else if (inherits(cond, "warning")) {
[17:40:59.404]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.404]                         if (muffled) 
[17:40:59.404]                           invokeRestart("muffleWarning")
[17:40:59.404]                       }
[17:40:59.404]                       else if (inherits(cond, "condition")) {
[17:40:59.404]                         if (!is.null(pattern)) {
[17:40:59.404]                           computeRestarts <- base::computeRestarts
[17:40:59.404]                           grepl <- base::grepl
[17:40:59.404]                           restarts <- computeRestarts(cond)
[17:40:59.404]                           for (restart in restarts) {
[17:40:59.404]                             name <- restart$name
[17:40:59.404]                             if (is.null(name)) 
[17:40:59.404]                               next
[17:40:59.404]                             if (!grepl(pattern, name)) 
[17:40:59.404]                               next
[17:40:59.404]                             invokeRestart(restart)
[17:40:59.404]                             muffled <- TRUE
[17:40:59.404]                             break
[17:40:59.404]                           }
[17:40:59.404]                         }
[17:40:59.404]                       }
[17:40:59.404]                       invisible(muffled)
[17:40:59.404]                     }
[17:40:59.404]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.404]                   }
[17:40:59.404]                 }
[17:40:59.404]             }
[17:40:59.404]         }))
[17:40:59.404]     }, error = function(ex) {
[17:40:59.404]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.404]                 ...future.rng), started = ...future.startTime, 
[17:40:59.404]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.404]             version = "1.8"), class = "FutureResult")
[17:40:59.404]     }, finally = {
[17:40:59.404]         if (!identical(...future.workdir, getwd())) 
[17:40:59.404]             setwd(...future.workdir)
[17:40:59.404]         {
[17:40:59.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.404]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.404]             }
[17:40:59.404]             base::options(...future.oldOptions)
[17:40:59.404]             if (.Platform$OS.type == "windows") {
[17:40:59.404]                 old_names <- names(...future.oldEnvVars)
[17:40:59.404]                 envs <- base::Sys.getenv()
[17:40:59.404]                 names <- names(envs)
[17:40:59.404]                 common <- intersect(names, old_names)
[17:40:59.404]                 added <- setdiff(names, old_names)
[17:40:59.404]                 removed <- setdiff(old_names, names)
[17:40:59.404]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.404]                   envs[common]]
[17:40:59.404]                 NAMES <- toupper(changed)
[17:40:59.404]                 args <- list()
[17:40:59.404]                 for (kk in seq_along(NAMES)) {
[17:40:59.404]                   name <- changed[[kk]]
[17:40:59.404]                   NAME <- NAMES[[kk]]
[17:40:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.404]                     next
[17:40:59.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.404]                 }
[17:40:59.404]                 NAMES <- toupper(added)
[17:40:59.404]                 for (kk in seq_along(NAMES)) {
[17:40:59.404]                   name <- added[[kk]]
[17:40:59.404]                   NAME <- NAMES[[kk]]
[17:40:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.404]                     next
[17:40:59.404]                   args[[name]] <- ""
[17:40:59.404]                 }
[17:40:59.404]                 NAMES <- toupper(removed)
[17:40:59.404]                 for (kk in seq_along(NAMES)) {
[17:40:59.404]                   name <- removed[[kk]]
[17:40:59.404]                   NAME <- NAMES[[kk]]
[17:40:59.404]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.404]                     next
[17:40:59.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.404]                 }
[17:40:59.404]                 if (length(args) > 0) 
[17:40:59.404]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.404]             }
[17:40:59.404]             else {
[17:40:59.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.404]             }
[17:40:59.404]             {
[17:40:59.404]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.404]                   0L) {
[17:40:59.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.404]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.404]                   base::options(opts)
[17:40:59.404]                 }
[17:40:59.404]                 {
[17:40:59.404]                   {
[17:40:59.404]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.404]                     NULL
[17:40:59.404]                   }
[17:40:59.404]                   options(future.plan = NULL)
[17:40:59.404]                   if (is.na(NA_character_)) 
[17:40:59.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.404]                     .init = FALSE)
[17:40:59.404]                 }
[17:40:59.404]             }
[17:40:59.404]         }
[17:40:59.404]     })
[17:40:59.404]     if (TRUE) {
[17:40:59.404]         base::sink(type = "output", split = FALSE)
[17:40:59.404]         if (TRUE) {
[17:40:59.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.404]         }
[17:40:59.404]         else {
[17:40:59.404]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.404]         }
[17:40:59.404]         base::close(...future.stdout)
[17:40:59.404]         ...future.stdout <- NULL
[17:40:59.404]     }
[17:40:59.404]     ...future.result$conditions <- ...future.conditions
[17:40:59.404]     ...future.result$finished <- base::Sys.time()
[17:40:59.404]     ...future.result
[17:40:59.404] }
[17:40:59.407] MultisessionFuture started
[17:40:59.407] - Launch lazy future ... done
[17:40:59.407] run() for ‘MultisessionFuture’ ... done
[17:40:59.408] resolve() on list ...
[17:40:59.408]  recursive: 0
[17:40:59.408]  length: 1
[17:40:59.408] 
[17:40:59.408] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.408] - Validating connection of MultisessionFuture
[17:40:59.409] - received message: FutureResult
[17:40:59.409] - Received FutureResult
[17:40:59.409] - Erased future from FutureRegistry
[17:40:59.409] result() for ClusterFuture ...
[17:40:59.409] - result already collected: FutureResult
[17:40:59.409] result() for ClusterFuture ... done
[17:40:59.409] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.409] Future #1
[17:40:59.409]  length: 0 (resolved future 1)
[17:40:59.409] resolve() on list ... DONE
[17:40:59.410] resolve() on list ...
[17:40:59.410]  recursive: 0
[17:40:59.410]  length: 1
[17:40:59.410] 
[17:40:59.910] receiveMessageFromWorker() for ClusterFuture ...
[17:40:59.910] - Validating connection of MultisessionFuture
[17:40:59.910] - received message: FutureResult
[17:40:59.910] - Received FutureResult
[17:40:59.910] - Erased future from FutureRegistry
[17:40:59.910] result() for ClusterFuture ...
[17:40:59.910] - result already collected: FutureResult
[17:40:59.911] result() for ClusterFuture ... done
[17:40:59.911] receiveMessageFromWorker() for ClusterFuture ... done
[17:40:59.911] Future #1
[17:40:59.911]  length: 0 (resolved future 1)
[17:40:59.911] resolve() on list ... DONE
[17:40:59.911] resolve() on list ...
[17:40:59.911]  recursive: 0
[17:40:59.911]  length: 1
[17:40:59.911] 
[17:40:59.911]  length: 0 (resolved future 1)
[17:40:59.912] resolve() on list ... DONE
[17:40:59.912] resolve() on list ...
[17:40:59.912]  recursive: 0
[17:40:59.912]  length: 4
[17:40:59.912] 
[17:40:59.912] Future #1
[17:40:59.912]  length: 3 (resolved future 1)
[17:40:59.912] Future #2
[17:40:59.912]  length: 2 (resolved future 2)
[17:40:59.913]  length: 1 (resolved future 3)
[17:40:59.913]  length: 0 (resolved future 4)
[17:40:59.913] resolve() on list ... DONE
[17:40:59.913] resolve() on list ...
[17:40:59.913]  recursive: 0
[17:40:59.913]  length: 4
[17:40:59.913] 
[17:40:59.913] Future #1
[17:40:59.913]  length: 3 (resolved future 1)
[17:40:59.913] Future #2
[17:40:59.914]  length: 2 (resolved future 2)
[17:40:59.914]  length: 1 (resolved future 3)
[17:40:59.914]  length: 0 (resolved future 4)
[17:40:59.914] resolve() on list ... DONE
[17:40:59.914] resolve() on list ...
[17:40:59.914]  recursive: 0
[17:40:59.914]  length: 1
[17:40:59.914] 
[17:40:59.914]  length: 0 (resolved future 1)
[17:40:59.914] resolve() on list ... DONE
[17:40:59.914] getGlobalsAndPackages() ...
[17:40:59.915] Searching for globals...
[17:40:59.916] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:59.916] Searching for globals ... DONE
[17:40:59.916] Resolving globals: FALSE
[17:40:59.916] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:59.917] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:59.917] - globals: [1] ‘kk’
[17:40:59.917] 
[17:40:59.917] getGlobalsAndPackages() ... DONE
[17:40:59.917] run() for ‘Future’ ...
[17:40:59.917] - state: ‘created’
[17:40:59.917] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.931] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.931] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.931]   - Field: ‘node’
[17:40:59.931]   - Field: ‘label’
[17:40:59.931]   - Field: ‘local’
[17:40:59.932]   - Field: ‘owner’
[17:40:59.932]   - Field: ‘envir’
[17:40:59.932]   - Field: ‘workers’
[17:40:59.932]   - Field: ‘packages’
[17:40:59.932]   - Field: ‘gc’
[17:40:59.932]   - Field: ‘conditions’
[17:40:59.932]   - Field: ‘persistent’
[17:40:59.932]   - Field: ‘expr’
[17:40:59.932]   - Field: ‘uuid’
[17:40:59.932]   - Field: ‘seed’
[17:40:59.933]   - Field: ‘version’
[17:40:59.933]   - Field: ‘result’
[17:40:59.933]   - Field: ‘asynchronous’
[17:40:59.933]   - Field: ‘calls’
[17:40:59.933]   - Field: ‘globals’
[17:40:59.933]   - Field: ‘stdout’
[17:40:59.933]   - Field: ‘earlySignal’
[17:40:59.933]   - Field: ‘lazy’
[17:40:59.933]   - Field: ‘state’
[17:40:59.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.933] - Launch lazy future ...
[17:40:59.934] Packages needed by the future expression (n = 0): <none>
[17:40:59.934] Packages needed by future strategies (n = 0): <none>
[17:40:59.934] {
[17:40:59.934]     {
[17:40:59.934]         {
[17:40:59.934]             ...future.startTime <- base::Sys.time()
[17:40:59.934]             {
[17:40:59.934]                 {
[17:40:59.934]                   {
[17:40:59.934]                     {
[17:40:59.934]                       base::local({
[17:40:59.934]                         has_future <- base::requireNamespace("future", 
[17:40:59.934]                           quietly = TRUE)
[17:40:59.934]                         if (has_future) {
[17:40:59.934]                           ns <- base::getNamespace("future")
[17:40:59.934]                           version <- ns[[".package"]][["version"]]
[17:40:59.934]                           if (is.null(version)) 
[17:40:59.934]                             version <- utils::packageVersion("future")
[17:40:59.934]                         }
[17:40:59.934]                         else {
[17:40:59.934]                           version <- NULL
[17:40:59.934]                         }
[17:40:59.934]                         if (!has_future || version < "1.8.0") {
[17:40:59.934]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.934]                             "", base::R.version$version.string), 
[17:40:59.934]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.934]                               "release", "version")], collapse = " "), 
[17:40:59.934]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.934]                             info)
[17:40:59.934]                           info <- base::paste(info, collapse = "; ")
[17:40:59.934]                           if (!has_future) {
[17:40:59.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.934]                               info)
[17:40:59.934]                           }
[17:40:59.934]                           else {
[17:40:59.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.934]                               info, version)
[17:40:59.934]                           }
[17:40:59.934]                           base::stop(msg)
[17:40:59.934]                         }
[17:40:59.934]                       })
[17:40:59.934]                     }
[17:40:59.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.934]                     base::options(mc.cores = 1L)
[17:40:59.934]                   }
[17:40:59.934]                   ...future.strategy.old <- future::plan("list")
[17:40:59.934]                   options(future.plan = NULL)
[17:40:59.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.934]                 }
[17:40:59.934]                 ...future.workdir <- getwd()
[17:40:59.934]             }
[17:40:59.934]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.934]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.934]         }
[17:40:59.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.934]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.934]             base::names(...future.oldOptions))
[17:40:59.934]     }
[17:40:59.934]     if (FALSE) {
[17:40:59.934]     }
[17:40:59.934]     else {
[17:40:59.934]         if (TRUE) {
[17:40:59.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.934]                 open = "w")
[17:40:59.934]         }
[17:40:59.934]         else {
[17:40:59.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.934]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.934]         }
[17:40:59.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.934]             base::sink(type = "output", split = FALSE)
[17:40:59.934]             base::close(...future.stdout)
[17:40:59.934]         }, add = TRUE)
[17:40:59.934]     }
[17:40:59.934]     ...future.frame <- base::sys.nframe()
[17:40:59.934]     ...future.conditions <- base::list()
[17:40:59.934]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.934]     if (FALSE) {
[17:40:59.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.934]     }
[17:40:59.934]     ...future.result <- base::tryCatch({
[17:40:59.934]         base::withCallingHandlers({
[17:40:59.934]             ...future.value <- base::withVisible(base::local({
[17:40:59.934]                 ...future.makeSendCondition <- base::local({
[17:40:59.934]                   sendCondition <- NULL
[17:40:59.934]                   function(frame = 1L) {
[17:40:59.934]                     if (is.function(sendCondition)) 
[17:40:59.934]                       return(sendCondition)
[17:40:59.934]                     ns <- getNamespace("parallel")
[17:40:59.934]                     if (exists("sendData", mode = "function", 
[17:40:59.934]                       envir = ns)) {
[17:40:59.934]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.934]                         envir = ns)
[17:40:59.934]                       envir <- sys.frame(frame)
[17:40:59.934]                       master <- NULL
[17:40:59.934]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.934]                         !identical(envir, emptyenv())) {
[17:40:59.934]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.934]                           inherits = FALSE)) {
[17:40:59.934]                           master <- get("master", mode = "list", 
[17:40:59.934]                             envir = envir, inherits = FALSE)
[17:40:59.934]                           if (inherits(master, c("SOCKnode", 
[17:40:59.934]                             "SOCK0node"))) {
[17:40:59.934]                             sendCondition <<- function(cond) {
[17:40:59.934]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.934]                                 success = TRUE)
[17:40:59.934]                               parallel_sendData(master, data)
[17:40:59.934]                             }
[17:40:59.934]                             return(sendCondition)
[17:40:59.934]                           }
[17:40:59.934]                         }
[17:40:59.934]                         frame <- frame + 1L
[17:40:59.934]                         envir <- sys.frame(frame)
[17:40:59.934]                       }
[17:40:59.934]                     }
[17:40:59.934]                     sendCondition <<- function(cond) NULL
[17:40:59.934]                   }
[17:40:59.934]                 })
[17:40:59.934]                 withCallingHandlers({
[17:40:59.934]                   {
[17:40:59.934]                     Sys.sleep(0.1)
[17:40:59.934]                     kk
[17:40:59.934]                   }
[17:40:59.934]                 }, immediateCondition = function(cond) {
[17:40:59.934]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.934]                   sendCondition(cond)
[17:40:59.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.934]                   {
[17:40:59.934]                     inherits <- base::inherits
[17:40:59.934]                     invokeRestart <- base::invokeRestart
[17:40:59.934]                     is.null <- base::is.null
[17:40:59.934]                     muffled <- FALSE
[17:40:59.934]                     if (inherits(cond, "message")) {
[17:40:59.934]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.934]                       if (muffled) 
[17:40:59.934]                         invokeRestart("muffleMessage")
[17:40:59.934]                     }
[17:40:59.934]                     else if (inherits(cond, "warning")) {
[17:40:59.934]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.934]                       if (muffled) 
[17:40:59.934]                         invokeRestart("muffleWarning")
[17:40:59.934]                     }
[17:40:59.934]                     else if (inherits(cond, "condition")) {
[17:40:59.934]                       if (!is.null(pattern)) {
[17:40:59.934]                         computeRestarts <- base::computeRestarts
[17:40:59.934]                         grepl <- base::grepl
[17:40:59.934]                         restarts <- computeRestarts(cond)
[17:40:59.934]                         for (restart in restarts) {
[17:40:59.934]                           name <- restart$name
[17:40:59.934]                           if (is.null(name)) 
[17:40:59.934]                             next
[17:40:59.934]                           if (!grepl(pattern, name)) 
[17:40:59.934]                             next
[17:40:59.934]                           invokeRestart(restart)
[17:40:59.934]                           muffled <- TRUE
[17:40:59.934]                           break
[17:40:59.934]                         }
[17:40:59.934]                       }
[17:40:59.934]                     }
[17:40:59.934]                     invisible(muffled)
[17:40:59.934]                   }
[17:40:59.934]                   muffleCondition(cond)
[17:40:59.934]                 })
[17:40:59.934]             }))
[17:40:59.934]             future::FutureResult(value = ...future.value$value, 
[17:40:59.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.934]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.934]                     ...future.globalenv.names))
[17:40:59.934]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.934]         }, condition = base::local({
[17:40:59.934]             c <- base::c
[17:40:59.934]             inherits <- base::inherits
[17:40:59.934]             invokeRestart <- base::invokeRestart
[17:40:59.934]             length <- base::length
[17:40:59.934]             list <- base::list
[17:40:59.934]             seq.int <- base::seq.int
[17:40:59.934]             signalCondition <- base::signalCondition
[17:40:59.934]             sys.calls <- base::sys.calls
[17:40:59.934]             `[[` <- base::`[[`
[17:40:59.934]             `+` <- base::`+`
[17:40:59.934]             `<<-` <- base::`<<-`
[17:40:59.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.934]                   3L)]
[17:40:59.934]             }
[17:40:59.934]             function(cond) {
[17:40:59.934]                 is_error <- inherits(cond, "error")
[17:40:59.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.934]                   NULL)
[17:40:59.934]                 if (is_error) {
[17:40:59.934]                   sessionInformation <- function() {
[17:40:59.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.934]                       search = base::search(), system = base::Sys.info())
[17:40:59.934]                   }
[17:40:59.934]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.934]                     cond$call), session = sessionInformation(), 
[17:40:59.934]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.934]                   signalCondition(cond)
[17:40:59.934]                 }
[17:40:59.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.934]                 "immediateCondition"))) {
[17:40:59.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.934]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.934]                   if (TRUE && !signal) {
[17:40:59.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.934]                     {
[17:40:59.934]                       inherits <- base::inherits
[17:40:59.934]                       invokeRestart <- base::invokeRestart
[17:40:59.934]                       is.null <- base::is.null
[17:40:59.934]                       muffled <- FALSE
[17:40:59.934]                       if (inherits(cond, "message")) {
[17:40:59.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.934]                         if (muffled) 
[17:40:59.934]                           invokeRestart("muffleMessage")
[17:40:59.934]                       }
[17:40:59.934]                       else if (inherits(cond, "warning")) {
[17:40:59.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.934]                         if (muffled) 
[17:40:59.934]                           invokeRestart("muffleWarning")
[17:40:59.934]                       }
[17:40:59.934]                       else if (inherits(cond, "condition")) {
[17:40:59.934]                         if (!is.null(pattern)) {
[17:40:59.934]                           computeRestarts <- base::computeRestarts
[17:40:59.934]                           grepl <- base::grepl
[17:40:59.934]                           restarts <- computeRestarts(cond)
[17:40:59.934]                           for (restart in restarts) {
[17:40:59.934]                             name <- restart$name
[17:40:59.934]                             if (is.null(name)) 
[17:40:59.934]                               next
[17:40:59.934]                             if (!grepl(pattern, name)) 
[17:40:59.934]                               next
[17:40:59.934]                             invokeRestart(restart)
[17:40:59.934]                             muffled <- TRUE
[17:40:59.934]                             break
[17:40:59.934]                           }
[17:40:59.934]                         }
[17:40:59.934]                       }
[17:40:59.934]                       invisible(muffled)
[17:40:59.934]                     }
[17:40:59.934]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.934]                   }
[17:40:59.934]                 }
[17:40:59.934]                 else {
[17:40:59.934]                   if (TRUE) {
[17:40:59.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.934]                     {
[17:40:59.934]                       inherits <- base::inherits
[17:40:59.934]                       invokeRestart <- base::invokeRestart
[17:40:59.934]                       is.null <- base::is.null
[17:40:59.934]                       muffled <- FALSE
[17:40:59.934]                       if (inherits(cond, "message")) {
[17:40:59.934]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.934]                         if (muffled) 
[17:40:59.934]                           invokeRestart("muffleMessage")
[17:40:59.934]                       }
[17:40:59.934]                       else if (inherits(cond, "warning")) {
[17:40:59.934]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.934]                         if (muffled) 
[17:40:59.934]                           invokeRestart("muffleWarning")
[17:40:59.934]                       }
[17:40:59.934]                       else if (inherits(cond, "condition")) {
[17:40:59.934]                         if (!is.null(pattern)) {
[17:40:59.934]                           computeRestarts <- base::computeRestarts
[17:40:59.934]                           grepl <- base::grepl
[17:40:59.934]                           restarts <- computeRestarts(cond)
[17:40:59.934]                           for (restart in restarts) {
[17:40:59.934]                             name <- restart$name
[17:40:59.934]                             if (is.null(name)) 
[17:40:59.934]                               next
[17:40:59.934]                             if (!grepl(pattern, name)) 
[17:40:59.934]                               next
[17:40:59.934]                             invokeRestart(restart)
[17:40:59.934]                             muffled <- TRUE
[17:40:59.934]                             break
[17:40:59.934]                           }
[17:40:59.934]                         }
[17:40:59.934]                       }
[17:40:59.934]                       invisible(muffled)
[17:40:59.934]                     }
[17:40:59.934]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.934]                   }
[17:40:59.934]                 }
[17:40:59.934]             }
[17:40:59.934]         }))
[17:40:59.934]     }, error = function(ex) {
[17:40:59.934]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.934]                 ...future.rng), started = ...future.startTime, 
[17:40:59.934]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.934]             version = "1.8"), class = "FutureResult")
[17:40:59.934]     }, finally = {
[17:40:59.934]         if (!identical(...future.workdir, getwd())) 
[17:40:59.934]             setwd(...future.workdir)
[17:40:59.934]         {
[17:40:59.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.934]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.934]             }
[17:40:59.934]             base::options(...future.oldOptions)
[17:40:59.934]             if (.Platform$OS.type == "windows") {
[17:40:59.934]                 old_names <- names(...future.oldEnvVars)
[17:40:59.934]                 envs <- base::Sys.getenv()
[17:40:59.934]                 names <- names(envs)
[17:40:59.934]                 common <- intersect(names, old_names)
[17:40:59.934]                 added <- setdiff(names, old_names)
[17:40:59.934]                 removed <- setdiff(old_names, names)
[17:40:59.934]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.934]                   envs[common]]
[17:40:59.934]                 NAMES <- toupper(changed)
[17:40:59.934]                 args <- list()
[17:40:59.934]                 for (kk in seq_along(NAMES)) {
[17:40:59.934]                   name <- changed[[kk]]
[17:40:59.934]                   NAME <- NAMES[[kk]]
[17:40:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.934]                     next
[17:40:59.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.934]                 }
[17:40:59.934]                 NAMES <- toupper(added)
[17:40:59.934]                 for (kk in seq_along(NAMES)) {
[17:40:59.934]                   name <- added[[kk]]
[17:40:59.934]                   NAME <- NAMES[[kk]]
[17:40:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.934]                     next
[17:40:59.934]                   args[[name]] <- ""
[17:40:59.934]                 }
[17:40:59.934]                 NAMES <- toupper(removed)
[17:40:59.934]                 for (kk in seq_along(NAMES)) {
[17:40:59.934]                   name <- removed[[kk]]
[17:40:59.934]                   NAME <- NAMES[[kk]]
[17:40:59.934]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.934]                     next
[17:40:59.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.934]                 }
[17:40:59.934]                 if (length(args) > 0) 
[17:40:59.934]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.934]             }
[17:40:59.934]             else {
[17:40:59.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.934]             }
[17:40:59.934]             {
[17:40:59.934]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.934]                   0L) {
[17:40:59.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.934]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.934]                   base::options(opts)
[17:40:59.934]                 }
[17:40:59.934]                 {
[17:40:59.934]                   {
[17:40:59.934]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.934]                     NULL
[17:40:59.934]                   }
[17:40:59.934]                   options(future.plan = NULL)
[17:40:59.934]                   if (is.na(NA_character_)) 
[17:40:59.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.934]                     .init = FALSE)
[17:40:59.934]                 }
[17:40:59.934]             }
[17:40:59.934]         }
[17:40:59.934]     })
[17:40:59.934]     if (TRUE) {
[17:40:59.934]         base::sink(type = "output", split = FALSE)
[17:40:59.934]         if (TRUE) {
[17:40:59.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.934]         }
[17:40:59.934]         else {
[17:40:59.934]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.934]         }
[17:40:59.934]         base::close(...future.stdout)
[17:40:59.934]         ...future.stdout <- NULL
[17:40:59.934]     }
[17:40:59.934]     ...future.result$conditions <- ...future.conditions
[17:40:59.934]     ...future.result$finished <- base::Sys.time()
[17:40:59.934]     ...future.result
[17:40:59.934] }
[17:40:59.937] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:40:59.937] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:40:59.937] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:40:59.937] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:40:59.938] MultisessionFuture started
[17:40:59.938] - Launch lazy future ... done
[17:40:59.938] run() for ‘MultisessionFuture’ ... done
[17:40:59.938] getGlobalsAndPackages() ...
[17:40:59.938] Searching for globals...
[17:40:59.939] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:59.939] Searching for globals ... DONE
[17:40:59.939] Resolving globals: FALSE
[17:40:59.940] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:59.940] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:59.940] - globals: [1] ‘kk’
[17:40:59.940] 
[17:40:59.941] getGlobalsAndPackages() ... DONE
[17:40:59.941] run() for ‘Future’ ...
[17:40:59.941] - state: ‘created’
[17:40:59.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.954]   - Field: ‘node’
[17:40:59.955]   - Field: ‘label’
[17:40:59.955]   - Field: ‘local’
[17:40:59.955]   - Field: ‘owner’
[17:40:59.955]   - Field: ‘envir’
[17:40:59.955]   - Field: ‘workers’
[17:40:59.955]   - Field: ‘packages’
[17:40:59.955]   - Field: ‘gc’
[17:40:59.955]   - Field: ‘conditions’
[17:40:59.955]   - Field: ‘persistent’
[17:40:59.955]   - Field: ‘expr’
[17:40:59.955]   - Field: ‘uuid’
[17:40:59.956]   - Field: ‘seed’
[17:40:59.956]   - Field: ‘version’
[17:40:59.956]   - Field: ‘result’
[17:40:59.956]   - Field: ‘asynchronous’
[17:40:59.956]   - Field: ‘calls’
[17:40:59.956]   - Field: ‘globals’
[17:40:59.956]   - Field: ‘stdout’
[17:40:59.956]   - Field: ‘earlySignal’
[17:40:59.956]   - Field: ‘lazy’
[17:40:59.956]   - Field: ‘state’
[17:40:59.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.957] - Launch lazy future ...
[17:40:59.957] Packages needed by the future expression (n = 0): <none>
[17:40:59.957] Packages needed by future strategies (n = 0): <none>
[17:40:59.957] {
[17:40:59.957]     {
[17:40:59.957]         {
[17:40:59.957]             ...future.startTime <- base::Sys.time()
[17:40:59.957]             {
[17:40:59.957]                 {
[17:40:59.957]                   {
[17:40:59.957]                     {
[17:40:59.957]                       base::local({
[17:40:59.957]                         has_future <- base::requireNamespace("future", 
[17:40:59.957]                           quietly = TRUE)
[17:40:59.957]                         if (has_future) {
[17:40:59.957]                           ns <- base::getNamespace("future")
[17:40:59.957]                           version <- ns[[".package"]][["version"]]
[17:40:59.957]                           if (is.null(version)) 
[17:40:59.957]                             version <- utils::packageVersion("future")
[17:40:59.957]                         }
[17:40:59.957]                         else {
[17:40:59.957]                           version <- NULL
[17:40:59.957]                         }
[17:40:59.957]                         if (!has_future || version < "1.8.0") {
[17:40:59.957]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.957]                             "", base::R.version$version.string), 
[17:40:59.957]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.957]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.957]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.957]                               "release", "version")], collapse = " "), 
[17:40:59.957]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.957]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.957]                             info)
[17:40:59.957]                           info <- base::paste(info, collapse = "; ")
[17:40:59.957]                           if (!has_future) {
[17:40:59.957]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.957]                               info)
[17:40:59.957]                           }
[17:40:59.957]                           else {
[17:40:59.957]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.957]                               info, version)
[17:40:59.957]                           }
[17:40:59.957]                           base::stop(msg)
[17:40:59.957]                         }
[17:40:59.957]                       })
[17:40:59.957]                     }
[17:40:59.957]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.957]                     base::options(mc.cores = 1L)
[17:40:59.957]                   }
[17:40:59.957]                   ...future.strategy.old <- future::plan("list")
[17:40:59.957]                   options(future.plan = NULL)
[17:40:59.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.957]                 }
[17:40:59.957]                 ...future.workdir <- getwd()
[17:40:59.957]             }
[17:40:59.957]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.957]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.957]         }
[17:40:59.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.957]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.957]             base::names(...future.oldOptions))
[17:40:59.957]     }
[17:40:59.957]     if (FALSE) {
[17:40:59.957]     }
[17:40:59.957]     else {
[17:40:59.957]         if (TRUE) {
[17:40:59.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.957]                 open = "w")
[17:40:59.957]         }
[17:40:59.957]         else {
[17:40:59.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.957]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.957]         }
[17:40:59.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.957]             base::sink(type = "output", split = FALSE)
[17:40:59.957]             base::close(...future.stdout)
[17:40:59.957]         }, add = TRUE)
[17:40:59.957]     }
[17:40:59.957]     ...future.frame <- base::sys.nframe()
[17:40:59.957]     ...future.conditions <- base::list()
[17:40:59.957]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.957]     if (FALSE) {
[17:40:59.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.957]     }
[17:40:59.957]     ...future.result <- base::tryCatch({
[17:40:59.957]         base::withCallingHandlers({
[17:40:59.957]             ...future.value <- base::withVisible(base::local({
[17:40:59.957]                 ...future.makeSendCondition <- base::local({
[17:40:59.957]                   sendCondition <- NULL
[17:40:59.957]                   function(frame = 1L) {
[17:40:59.957]                     if (is.function(sendCondition)) 
[17:40:59.957]                       return(sendCondition)
[17:40:59.957]                     ns <- getNamespace("parallel")
[17:40:59.957]                     if (exists("sendData", mode = "function", 
[17:40:59.957]                       envir = ns)) {
[17:40:59.957]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.957]                         envir = ns)
[17:40:59.957]                       envir <- sys.frame(frame)
[17:40:59.957]                       master <- NULL
[17:40:59.957]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.957]                         !identical(envir, emptyenv())) {
[17:40:59.957]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.957]                           inherits = FALSE)) {
[17:40:59.957]                           master <- get("master", mode = "list", 
[17:40:59.957]                             envir = envir, inherits = FALSE)
[17:40:59.957]                           if (inherits(master, c("SOCKnode", 
[17:40:59.957]                             "SOCK0node"))) {
[17:40:59.957]                             sendCondition <<- function(cond) {
[17:40:59.957]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.957]                                 success = TRUE)
[17:40:59.957]                               parallel_sendData(master, data)
[17:40:59.957]                             }
[17:40:59.957]                             return(sendCondition)
[17:40:59.957]                           }
[17:40:59.957]                         }
[17:40:59.957]                         frame <- frame + 1L
[17:40:59.957]                         envir <- sys.frame(frame)
[17:40:59.957]                       }
[17:40:59.957]                     }
[17:40:59.957]                     sendCondition <<- function(cond) NULL
[17:40:59.957]                   }
[17:40:59.957]                 })
[17:40:59.957]                 withCallingHandlers({
[17:40:59.957]                   {
[17:40:59.957]                     Sys.sleep(0.1)
[17:40:59.957]                     kk
[17:40:59.957]                   }
[17:40:59.957]                 }, immediateCondition = function(cond) {
[17:40:59.957]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.957]                   sendCondition(cond)
[17:40:59.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.957]                   {
[17:40:59.957]                     inherits <- base::inherits
[17:40:59.957]                     invokeRestart <- base::invokeRestart
[17:40:59.957]                     is.null <- base::is.null
[17:40:59.957]                     muffled <- FALSE
[17:40:59.957]                     if (inherits(cond, "message")) {
[17:40:59.957]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.957]                       if (muffled) 
[17:40:59.957]                         invokeRestart("muffleMessage")
[17:40:59.957]                     }
[17:40:59.957]                     else if (inherits(cond, "warning")) {
[17:40:59.957]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.957]                       if (muffled) 
[17:40:59.957]                         invokeRestart("muffleWarning")
[17:40:59.957]                     }
[17:40:59.957]                     else if (inherits(cond, "condition")) {
[17:40:59.957]                       if (!is.null(pattern)) {
[17:40:59.957]                         computeRestarts <- base::computeRestarts
[17:40:59.957]                         grepl <- base::grepl
[17:40:59.957]                         restarts <- computeRestarts(cond)
[17:40:59.957]                         for (restart in restarts) {
[17:40:59.957]                           name <- restart$name
[17:40:59.957]                           if (is.null(name)) 
[17:40:59.957]                             next
[17:40:59.957]                           if (!grepl(pattern, name)) 
[17:40:59.957]                             next
[17:40:59.957]                           invokeRestart(restart)
[17:40:59.957]                           muffled <- TRUE
[17:40:59.957]                           break
[17:40:59.957]                         }
[17:40:59.957]                       }
[17:40:59.957]                     }
[17:40:59.957]                     invisible(muffled)
[17:40:59.957]                   }
[17:40:59.957]                   muffleCondition(cond)
[17:40:59.957]                 })
[17:40:59.957]             }))
[17:40:59.957]             future::FutureResult(value = ...future.value$value, 
[17:40:59.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.957]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.957]                     ...future.globalenv.names))
[17:40:59.957]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.957]         }, condition = base::local({
[17:40:59.957]             c <- base::c
[17:40:59.957]             inherits <- base::inherits
[17:40:59.957]             invokeRestart <- base::invokeRestart
[17:40:59.957]             length <- base::length
[17:40:59.957]             list <- base::list
[17:40:59.957]             seq.int <- base::seq.int
[17:40:59.957]             signalCondition <- base::signalCondition
[17:40:59.957]             sys.calls <- base::sys.calls
[17:40:59.957]             `[[` <- base::`[[`
[17:40:59.957]             `+` <- base::`+`
[17:40:59.957]             `<<-` <- base::`<<-`
[17:40:59.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.957]                   3L)]
[17:40:59.957]             }
[17:40:59.957]             function(cond) {
[17:40:59.957]                 is_error <- inherits(cond, "error")
[17:40:59.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.957]                   NULL)
[17:40:59.957]                 if (is_error) {
[17:40:59.957]                   sessionInformation <- function() {
[17:40:59.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.957]                       search = base::search(), system = base::Sys.info())
[17:40:59.957]                   }
[17:40:59.957]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.957]                     cond$call), session = sessionInformation(), 
[17:40:59.957]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.957]                   signalCondition(cond)
[17:40:59.957]                 }
[17:40:59.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.957]                 "immediateCondition"))) {
[17:40:59.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.957]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.957]                   if (TRUE && !signal) {
[17:40:59.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.957]                     {
[17:40:59.957]                       inherits <- base::inherits
[17:40:59.957]                       invokeRestart <- base::invokeRestart
[17:40:59.957]                       is.null <- base::is.null
[17:40:59.957]                       muffled <- FALSE
[17:40:59.957]                       if (inherits(cond, "message")) {
[17:40:59.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.957]                         if (muffled) 
[17:40:59.957]                           invokeRestart("muffleMessage")
[17:40:59.957]                       }
[17:40:59.957]                       else if (inherits(cond, "warning")) {
[17:40:59.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.957]                         if (muffled) 
[17:40:59.957]                           invokeRestart("muffleWarning")
[17:40:59.957]                       }
[17:40:59.957]                       else if (inherits(cond, "condition")) {
[17:40:59.957]                         if (!is.null(pattern)) {
[17:40:59.957]                           computeRestarts <- base::computeRestarts
[17:40:59.957]                           grepl <- base::grepl
[17:40:59.957]                           restarts <- computeRestarts(cond)
[17:40:59.957]                           for (restart in restarts) {
[17:40:59.957]                             name <- restart$name
[17:40:59.957]                             if (is.null(name)) 
[17:40:59.957]                               next
[17:40:59.957]                             if (!grepl(pattern, name)) 
[17:40:59.957]                               next
[17:40:59.957]                             invokeRestart(restart)
[17:40:59.957]                             muffled <- TRUE
[17:40:59.957]                             break
[17:40:59.957]                           }
[17:40:59.957]                         }
[17:40:59.957]                       }
[17:40:59.957]                       invisible(muffled)
[17:40:59.957]                     }
[17:40:59.957]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.957]                   }
[17:40:59.957]                 }
[17:40:59.957]                 else {
[17:40:59.957]                   if (TRUE) {
[17:40:59.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.957]                     {
[17:40:59.957]                       inherits <- base::inherits
[17:40:59.957]                       invokeRestart <- base::invokeRestart
[17:40:59.957]                       is.null <- base::is.null
[17:40:59.957]                       muffled <- FALSE
[17:40:59.957]                       if (inherits(cond, "message")) {
[17:40:59.957]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.957]                         if (muffled) 
[17:40:59.957]                           invokeRestart("muffleMessage")
[17:40:59.957]                       }
[17:40:59.957]                       else if (inherits(cond, "warning")) {
[17:40:59.957]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.957]                         if (muffled) 
[17:40:59.957]                           invokeRestart("muffleWarning")
[17:40:59.957]                       }
[17:40:59.957]                       else if (inherits(cond, "condition")) {
[17:40:59.957]                         if (!is.null(pattern)) {
[17:40:59.957]                           computeRestarts <- base::computeRestarts
[17:40:59.957]                           grepl <- base::grepl
[17:40:59.957]                           restarts <- computeRestarts(cond)
[17:40:59.957]                           for (restart in restarts) {
[17:40:59.957]                             name <- restart$name
[17:40:59.957]                             if (is.null(name)) 
[17:40:59.957]                               next
[17:40:59.957]                             if (!grepl(pattern, name)) 
[17:40:59.957]                               next
[17:40:59.957]                             invokeRestart(restart)
[17:40:59.957]                             muffled <- TRUE
[17:40:59.957]                             break
[17:40:59.957]                           }
[17:40:59.957]                         }
[17:40:59.957]                       }
[17:40:59.957]                       invisible(muffled)
[17:40:59.957]                     }
[17:40:59.957]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.957]                   }
[17:40:59.957]                 }
[17:40:59.957]             }
[17:40:59.957]         }))
[17:40:59.957]     }, error = function(ex) {
[17:40:59.957]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.957]                 ...future.rng), started = ...future.startTime, 
[17:40:59.957]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.957]             version = "1.8"), class = "FutureResult")
[17:40:59.957]     }, finally = {
[17:40:59.957]         if (!identical(...future.workdir, getwd())) 
[17:40:59.957]             setwd(...future.workdir)
[17:40:59.957]         {
[17:40:59.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.957]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.957]             }
[17:40:59.957]             base::options(...future.oldOptions)
[17:40:59.957]             if (.Platform$OS.type == "windows") {
[17:40:59.957]                 old_names <- names(...future.oldEnvVars)
[17:40:59.957]                 envs <- base::Sys.getenv()
[17:40:59.957]                 names <- names(envs)
[17:40:59.957]                 common <- intersect(names, old_names)
[17:40:59.957]                 added <- setdiff(names, old_names)
[17:40:59.957]                 removed <- setdiff(old_names, names)
[17:40:59.957]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.957]                   envs[common]]
[17:40:59.957]                 NAMES <- toupper(changed)
[17:40:59.957]                 args <- list()
[17:40:59.957]                 for (kk in seq_along(NAMES)) {
[17:40:59.957]                   name <- changed[[kk]]
[17:40:59.957]                   NAME <- NAMES[[kk]]
[17:40:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.957]                     next
[17:40:59.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.957]                 }
[17:40:59.957]                 NAMES <- toupper(added)
[17:40:59.957]                 for (kk in seq_along(NAMES)) {
[17:40:59.957]                   name <- added[[kk]]
[17:40:59.957]                   NAME <- NAMES[[kk]]
[17:40:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.957]                     next
[17:40:59.957]                   args[[name]] <- ""
[17:40:59.957]                 }
[17:40:59.957]                 NAMES <- toupper(removed)
[17:40:59.957]                 for (kk in seq_along(NAMES)) {
[17:40:59.957]                   name <- removed[[kk]]
[17:40:59.957]                   NAME <- NAMES[[kk]]
[17:40:59.957]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.957]                     next
[17:40:59.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.957]                 }
[17:40:59.957]                 if (length(args) > 0) 
[17:40:59.957]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.957]             }
[17:40:59.957]             else {
[17:40:59.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.957]             }
[17:40:59.957]             {
[17:40:59.957]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.957]                   0L) {
[17:40:59.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.957]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.957]                   base::options(opts)
[17:40:59.957]                 }
[17:40:59.957]                 {
[17:40:59.957]                   {
[17:40:59.957]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.957]                     NULL
[17:40:59.957]                   }
[17:40:59.957]                   options(future.plan = NULL)
[17:40:59.957]                   if (is.na(NA_character_)) 
[17:40:59.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.957]                     .init = FALSE)
[17:40:59.957]                 }
[17:40:59.957]             }
[17:40:59.957]         }
[17:40:59.957]     })
[17:40:59.957]     if (TRUE) {
[17:40:59.957]         base::sink(type = "output", split = FALSE)
[17:40:59.957]         if (TRUE) {
[17:40:59.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.957]         }
[17:40:59.957]         else {
[17:40:59.957]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.957]         }
[17:40:59.957]         base::close(...future.stdout)
[17:40:59.957]         ...future.stdout <- NULL
[17:40:59.957]     }
[17:40:59.957]     ...future.result$conditions <- ...future.conditions
[17:40:59.957]     ...future.result$finished <- base::Sys.time()
[17:40:59.957]     ...future.result
[17:40:59.957] }
[17:40:59.960] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:40:59.960] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:40:59.960] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:40:59.960] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:40:59.961] MultisessionFuture started
[17:40:59.961] - Launch lazy future ... done
[17:40:59.961] run() for ‘MultisessionFuture’ ... done
[17:40:59.961] getGlobalsAndPackages() ...
[17:40:59.961] Searching for globals...
[17:40:59.962] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:40:59.962] Searching for globals ... DONE
[17:40:59.962] Resolving globals: FALSE
[17:40:59.963] The total size of the 1 globals is 56 bytes (56 bytes)
[17:40:59.963] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:40:59.963] - globals: [1] ‘kk’
[17:40:59.963] 
[17:40:59.963] getGlobalsAndPackages() ... DONE
[17:40:59.964] run() for ‘Future’ ...
[17:40:59.964] - state: ‘created’
[17:40:59.964] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:40:59.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:40:59.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:40:59.978]   - Field: ‘node’
[17:40:59.978]   - Field: ‘label’
[17:40:59.978]   - Field: ‘local’
[17:40:59.978]   - Field: ‘owner’
[17:40:59.978]   - Field: ‘envir’
[17:40:59.978]   - Field: ‘workers’
[17:40:59.978]   - Field: ‘packages’
[17:40:59.978]   - Field: ‘gc’
[17:40:59.978]   - Field: ‘conditions’
[17:40:59.978]   - Field: ‘persistent’
[17:40:59.978]   - Field: ‘expr’
[17:40:59.979]   - Field: ‘uuid’
[17:40:59.979]   - Field: ‘seed’
[17:40:59.979]   - Field: ‘version’
[17:40:59.979]   - Field: ‘result’
[17:40:59.979]   - Field: ‘asynchronous’
[17:40:59.979]   - Field: ‘calls’
[17:40:59.979]   - Field: ‘globals’
[17:40:59.979]   - Field: ‘stdout’
[17:40:59.979]   - Field: ‘earlySignal’
[17:40:59.979]   - Field: ‘lazy’
[17:40:59.979]   - Field: ‘state’
[17:40:59.980] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:40:59.980] - Launch lazy future ...
[17:40:59.980] Packages needed by the future expression (n = 0): <none>
[17:40:59.980] Packages needed by future strategies (n = 0): <none>
[17:40:59.980] {
[17:40:59.980]     {
[17:40:59.980]         {
[17:40:59.980]             ...future.startTime <- base::Sys.time()
[17:40:59.980]             {
[17:40:59.980]                 {
[17:40:59.980]                   {
[17:40:59.980]                     {
[17:40:59.980]                       base::local({
[17:40:59.980]                         has_future <- base::requireNamespace("future", 
[17:40:59.980]                           quietly = TRUE)
[17:40:59.980]                         if (has_future) {
[17:40:59.980]                           ns <- base::getNamespace("future")
[17:40:59.980]                           version <- ns[[".package"]][["version"]]
[17:40:59.980]                           if (is.null(version)) 
[17:40:59.980]                             version <- utils::packageVersion("future")
[17:40:59.980]                         }
[17:40:59.980]                         else {
[17:40:59.980]                           version <- NULL
[17:40:59.980]                         }
[17:40:59.980]                         if (!has_future || version < "1.8.0") {
[17:40:59.980]                           info <- base::c(r_version = base::gsub("R version ", 
[17:40:59.980]                             "", base::R.version$version.string), 
[17:40:59.980]                             platform = base::sprintf("%s (%s-bit)", 
[17:40:59.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:40:59.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:40:59.980]                               "release", "version")], collapse = " "), 
[17:40:59.980]                             hostname = base::Sys.info()[["nodename"]])
[17:40:59.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:40:59.980]                             info)
[17:40:59.980]                           info <- base::paste(info, collapse = "; ")
[17:40:59.980]                           if (!has_future) {
[17:40:59.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:40:59.980]                               info)
[17:40:59.980]                           }
[17:40:59.980]                           else {
[17:40:59.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:40:59.980]                               info, version)
[17:40:59.980]                           }
[17:40:59.980]                           base::stop(msg)
[17:40:59.980]                         }
[17:40:59.980]                       })
[17:40:59.980]                     }
[17:40:59.980]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:40:59.980]                     base::options(mc.cores = 1L)
[17:40:59.980]                   }
[17:40:59.980]                   ...future.strategy.old <- future::plan("list")
[17:40:59.980]                   options(future.plan = NULL)
[17:40:59.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:40:59.980]                 }
[17:40:59.980]                 ...future.workdir <- getwd()
[17:40:59.980]             }
[17:40:59.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:40:59.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:40:59.980]         }
[17:40:59.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:40:59.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:40:59.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:40:59.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:40:59.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:40:59.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:40:59.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:40:59.980]             base::names(...future.oldOptions))
[17:40:59.980]     }
[17:40:59.980]     if (FALSE) {
[17:40:59.980]     }
[17:40:59.980]     else {
[17:40:59.980]         if (TRUE) {
[17:40:59.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:40:59.980]                 open = "w")
[17:40:59.980]         }
[17:40:59.980]         else {
[17:40:59.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:40:59.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:40:59.980]         }
[17:40:59.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:40:59.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:40:59.980]             base::sink(type = "output", split = FALSE)
[17:40:59.980]             base::close(...future.stdout)
[17:40:59.980]         }, add = TRUE)
[17:40:59.980]     }
[17:40:59.980]     ...future.frame <- base::sys.nframe()
[17:40:59.980]     ...future.conditions <- base::list()
[17:40:59.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:40:59.980]     if (FALSE) {
[17:40:59.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:40:59.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:40:59.980]     }
[17:40:59.980]     ...future.result <- base::tryCatch({
[17:40:59.980]         base::withCallingHandlers({
[17:40:59.980]             ...future.value <- base::withVisible(base::local({
[17:40:59.980]                 ...future.makeSendCondition <- base::local({
[17:40:59.980]                   sendCondition <- NULL
[17:40:59.980]                   function(frame = 1L) {
[17:40:59.980]                     if (is.function(sendCondition)) 
[17:40:59.980]                       return(sendCondition)
[17:40:59.980]                     ns <- getNamespace("parallel")
[17:40:59.980]                     if (exists("sendData", mode = "function", 
[17:40:59.980]                       envir = ns)) {
[17:40:59.980]                       parallel_sendData <- get("sendData", mode = "function", 
[17:40:59.980]                         envir = ns)
[17:40:59.980]                       envir <- sys.frame(frame)
[17:40:59.980]                       master <- NULL
[17:40:59.980]                       while (!identical(envir, .GlobalEnv) && 
[17:40:59.980]                         !identical(envir, emptyenv())) {
[17:40:59.980]                         if (exists("master", mode = "list", envir = envir, 
[17:40:59.980]                           inherits = FALSE)) {
[17:40:59.980]                           master <- get("master", mode = "list", 
[17:40:59.980]                             envir = envir, inherits = FALSE)
[17:40:59.980]                           if (inherits(master, c("SOCKnode", 
[17:40:59.980]                             "SOCK0node"))) {
[17:40:59.980]                             sendCondition <<- function(cond) {
[17:40:59.980]                               data <- list(type = "VALUE", value = cond, 
[17:40:59.980]                                 success = TRUE)
[17:40:59.980]                               parallel_sendData(master, data)
[17:40:59.980]                             }
[17:40:59.980]                             return(sendCondition)
[17:40:59.980]                           }
[17:40:59.980]                         }
[17:40:59.980]                         frame <- frame + 1L
[17:40:59.980]                         envir <- sys.frame(frame)
[17:40:59.980]                       }
[17:40:59.980]                     }
[17:40:59.980]                     sendCondition <<- function(cond) NULL
[17:40:59.980]                   }
[17:40:59.980]                 })
[17:40:59.980]                 withCallingHandlers({
[17:40:59.980]                   {
[17:40:59.980]                     Sys.sleep(0.1)
[17:40:59.980]                     kk
[17:40:59.980]                   }
[17:40:59.980]                 }, immediateCondition = function(cond) {
[17:40:59.980]                   sendCondition <- ...future.makeSendCondition()
[17:40:59.980]                   sendCondition(cond)
[17:40:59.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.980]                   {
[17:40:59.980]                     inherits <- base::inherits
[17:40:59.980]                     invokeRestart <- base::invokeRestart
[17:40:59.980]                     is.null <- base::is.null
[17:40:59.980]                     muffled <- FALSE
[17:40:59.980]                     if (inherits(cond, "message")) {
[17:40:59.980]                       muffled <- grepl(pattern, "muffleMessage")
[17:40:59.980]                       if (muffled) 
[17:40:59.980]                         invokeRestart("muffleMessage")
[17:40:59.980]                     }
[17:40:59.980]                     else if (inherits(cond, "warning")) {
[17:40:59.980]                       muffled <- grepl(pattern, "muffleWarning")
[17:40:59.980]                       if (muffled) 
[17:40:59.980]                         invokeRestart("muffleWarning")
[17:40:59.980]                     }
[17:40:59.980]                     else if (inherits(cond, "condition")) {
[17:40:59.980]                       if (!is.null(pattern)) {
[17:40:59.980]                         computeRestarts <- base::computeRestarts
[17:40:59.980]                         grepl <- base::grepl
[17:40:59.980]                         restarts <- computeRestarts(cond)
[17:40:59.980]                         for (restart in restarts) {
[17:40:59.980]                           name <- restart$name
[17:40:59.980]                           if (is.null(name)) 
[17:40:59.980]                             next
[17:40:59.980]                           if (!grepl(pattern, name)) 
[17:40:59.980]                             next
[17:40:59.980]                           invokeRestart(restart)
[17:40:59.980]                           muffled <- TRUE
[17:40:59.980]                           break
[17:40:59.980]                         }
[17:40:59.980]                       }
[17:40:59.980]                     }
[17:40:59.980]                     invisible(muffled)
[17:40:59.980]                   }
[17:40:59.980]                   muffleCondition(cond)
[17:40:59.980]                 })
[17:40:59.980]             }))
[17:40:59.980]             future::FutureResult(value = ...future.value$value, 
[17:40:59.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.980]                   ...future.rng), globalenv = if (FALSE) 
[17:40:59.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:40:59.980]                     ...future.globalenv.names))
[17:40:59.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:40:59.980]         }, condition = base::local({
[17:40:59.980]             c <- base::c
[17:40:59.980]             inherits <- base::inherits
[17:40:59.980]             invokeRestart <- base::invokeRestart
[17:40:59.980]             length <- base::length
[17:40:59.980]             list <- base::list
[17:40:59.980]             seq.int <- base::seq.int
[17:40:59.980]             signalCondition <- base::signalCondition
[17:40:59.980]             sys.calls <- base::sys.calls
[17:40:59.980]             `[[` <- base::`[[`
[17:40:59.980]             `+` <- base::`+`
[17:40:59.980]             `<<-` <- base::`<<-`
[17:40:59.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:40:59.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:40:59.980]                   3L)]
[17:40:59.980]             }
[17:40:59.980]             function(cond) {
[17:40:59.980]                 is_error <- inherits(cond, "error")
[17:40:59.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:40:59.980]                   NULL)
[17:40:59.980]                 if (is_error) {
[17:40:59.980]                   sessionInformation <- function() {
[17:40:59.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:40:59.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:40:59.980]                       search = base::search(), system = base::Sys.info())
[17:40:59.980]                   }
[17:40:59.980]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:40:59.980]                     cond$call), session = sessionInformation(), 
[17:40:59.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:40:59.980]                   signalCondition(cond)
[17:40:59.980]                 }
[17:40:59.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:40:59.980]                 "immediateCondition"))) {
[17:40:59.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:40:59.980]                   ...future.conditions[[length(...future.conditions) + 
[17:40:59.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:40:59.980]                   if (TRUE && !signal) {
[17:40:59.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.980]                     {
[17:40:59.980]                       inherits <- base::inherits
[17:40:59.980]                       invokeRestart <- base::invokeRestart
[17:40:59.980]                       is.null <- base::is.null
[17:40:59.980]                       muffled <- FALSE
[17:40:59.980]                       if (inherits(cond, "message")) {
[17:40:59.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.980]                         if (muffled) 
[17:40:59.980]                           invokeRestart("muffleMessage")
[17:40:59.980]                       }
[17:40:59.980]                       else if (inherits(cond, "warning")) {
[17:40:59.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.980]                         if (muffled) 
[17:40:59.980]                           invokeRestart("muffleWarning")
[17:40:59.980]                       }
[17:40:59.980]                       else if (inherits(cond, "condition")) {
[17:40:59.980]                         if (!is.null(pattern)) {
[17:40:59.980]                           computeRestarts <- base::computeRestarts
[17:40:59.980]                           grepl <- base::grepl
[17:40:59.980]                           restarts <- computeRestarts(cond)
[17:40:59.980]                           for (restart in restarts) {
[17:40:59.980]                             name <- restart$name
[17:40:59.980]                             if (is.null(name)) 
[17:40:59.980]                               next
[17:40:59.980]                             if (!grepl(pattern, name)) 
[17:40:59.980]                               next
[17:40:59.980]                             invokeRestart(restart)
[17:40:59.980]                             muffled <- TRUE
[17:40:59.980]                             break
[17:40:59.980]                           }
[17:40:59.980]                         }
[17:40:59.980]                       }
[17:40:59.980]                       invisible(muffled)
[17:40:59.980]                     }
[17:40:59.980]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.980]                   }
[17:40:59.980]                 }
[17:40:59.980]                 else {
[17:40:59.980]                   if (TRUE) {
[17:40:59.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:40:59.980]                     {
[17:40:59.980]                       inherits <- base::inherits
[17:40:59.980]                       invokeRestart <- base::invokeRestart
[17:40:59.980]                       is.null <- base::is.null
[17:40:59.980]                       muffled <- FALSE
[17:40:59.980]                       if (inherits(cond, "message")) {
[17:40:59.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:40:59.980]                         if (muffled) 
[17:40:59.980]                           invokeRestart("muffleMessage")
[17:40:59.980]                       }
[17:40:59.980]                       else if (inherits(cond, "warning")) {
[17:40:59.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:40:59.980]                         if (muffled) 
[17:40:59.980]                           invokeRestart("muffleWarning")
[17:40:59.980]                       }
[17:40:59.980]                       else if (inherits(cond, "condition")) {
[17:40:59.980]                         if (!is.null(pattern)) {
[17:40:59.980]                           computeRestarts <- base::computeRestarts
[17:40:59.980]                           grepl <- base::grepl
[17:40:59.980]                           restarts <- computeRestarts(cond)
[17:40:59.980]                           for (restart in restarts) {
[17:40:59.980]                             name <- restart$name
[17:40:59.980]                             if (is.null(name)) 
[17:40:59.980]                               next
[17:40:59.980]                             if (!grepl(pattern, name)) 
[17:40:59.980]                               next
[17:40:59.980]                             invokeRestart(restart)
[17:40:59.980]                             muffled <- TRUE
[17:40:59.980]                             break
[17:40:59.980]                           }
[17:40:59.980]                         }
[17:40:59.980]                       }
[17:40:59.980]                       invisible(muffled)
[17:40:59.980]                     }
[17:40:59.980]                     muffleCondition(cond, pattern = "^muffle")
[17:40:59.980]                   }
[17:40:59.980]                 }
[17:40:59.980]             }
[17:40:59.980]         }))
[17:40:59.980]     }, error = function(ex) {
[17:40:59.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:40:59.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:40:59.980]                 ...future.rng), started = ...future.startTime, 
[17:40:59.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:40:59.980]             version = "1.8"), class = "FutureResult")
[17:40:59.980]     }, finally = {
[17:40:59.980]         if (!identical(...future.workdir, getwd())) 
[17:40:59.980]             setwd(...future.workdir)
[17:40:59.980]         {
[17:40:59.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:40:59.980]                 ...future.oldOptions$nwarnings <- NULL
[17:40:59.980]             }
[17:40:59.980]             base::options(...future.oldOptions)
[17:40:59.980]             if (.Platform$OS.type == "windows") {
[17:40:59.980]                 old_names <- names(...future.oldEnvVars)
[17:40:59.980]                 envs <- base::Sys.getenv()
[17:40:59.980]                 names <- names(envs)
[17:40:59.980]                 common <- intersect(names, old_names)
[17:40:59.980]                 added <- setdiff(names, old_names)
[17:40:59.980]                 removed <- setdiff(old_names, names)
[17:40:59.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:40:59.980]                   envs[common]]
[17:40:59.980]                 NAMES <- toupper(changed)
[17:40:59.980]                 args <- list()
[17:40:59.980]                 for (kk in seq_along(NAMES)) {
[17:40:59.980]                   name <- changed[[kk]]
[17:40:59.980]                   NAME <- NAMES[[kk]]
[17:40:59.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.980]                     next
[17:40:59.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.980]                 }
[17:40:59.980]                 NAMES <- toupper(added)
[17:40:59.980]                 for (kk in seq_along(NAMES)) {
[17:40:59.980]                   name <- added[[kk]]
[17:40:59.980]                   NAME <- NAMES[[kk]]
[17:40:59.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.980]                     next
[17:40:59.980]                   args[[name]] <- ""
[17:40:59.980]                 }
[17:40:59.980]                 NAMES <- toupper(removed)
[17:40:59.980]                 for (kk in seq_along(NAMES)) {
[17:40:59.980]                   name <- removed[[kk]]
[17:40:59.980]                   NAME <- NAMES[[kk]]
[17:40:59.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:40:59.980]                     next
[17:40:59.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:40:59.980]                 }
[17:40:59.980]                 if (length(args) > 0) 
[17:40:59.980]                   base::do.call(base::Sys.setenv, args = args)
[17:40:59.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:40:59.980]             }
[17:40:59.980]             else {
[17:40:59.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:40:59.980]             }
[17:40:59.980]             {
[17:40:59.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:40:59.980]                   0L) {
[17:40:59.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:40:59.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:40:59.980]                   base::options(opts)
[17:40:59.980]                 }
[17:40:59.980]                 {
[17:40:59.980]                   {
[17:40:59.980]                     base::options(mc.cores = ...future.mc.cores.old)
[17:40:59.980]                     NULL
[17:40:59.980]                   }
[17:40:59.980]                   options(future.plan = NULL)
[17:40:59.980]                   if (is.na(NA_character_)) 
[17:40:59.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:40:59.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:40:59.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:40:59.980]                     .init = FALSE)
[17:40:59.980]                 }
[17:40:59.980]             }
[17:40:59.980]         }
[17:40:59.980]     })
[17:40:59.980]     if (TRUE) {
[17:40:59.980]         base::sink(type = "output", split = FALSE)
[17:40:59.980]         if (TRUE) {
[17:40:59.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:40:59.980]         }
[17:40:59.980]         else {
[17:40:59.980]             ...future.result["stdout"] <- base::list(NULL)
[17:40:59.980]         }
[17:40:59.980]         base::close(...future.stdout)
[17:40:59.980]         ...future.stdout <- NULL
[17:40:59.980]     }
[17:40:59.980]     ...future.result$conditions <- ...future.conditions
[17:40:59.980]     ...future.result$finished <- base::Sys.time()
[17:40:59.980]     ...future.result
[17:40:59.980] }
[17:40:59.983] Poll #1 (0): usedNodes() = 2, workers = 2
[17:41:00.014] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:41:00.045] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[17:41:00.056] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.056] - Validating connection of MultisessionFuture
[17:41:00.057] - received message: FutureResult
[17:41:00.057] - Received FutureResult
[17:41:00.057] - Erased future from FutureRegistry
[17:41:00.057] result() for ClusterFuture ...
[17:41:00.057] - result already collected: FutureResult
[17:41:00.057] result() for ClusterFuture ... done
[17:41:00.057] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.057] result() for ClusterFuture ...
[17:41:00.057] - result already collected: FutureResult
[17:41:00.057] result() for ClusterFuture ... done
[17:41:00.057] result() for ClusterFuture ...
[17:41:00.058] - result already collected: FutureResult
[17:41:00.058] result() for ClusterFuture ... done
[17:41:00.058] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:41:00.058] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:41:00.059] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.059] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:41:00.059] MultisessionFuture started
[17:41:00.059] - Launch lazy future ... done
[17:41:00.060] run() for ‘MultisessionFuture’ ... done
[17:41:00.060] resolve() on list ...
[17:41:00.060]  recursive: 0
[17:41:00.060]  length: 3
[17:41:00.060] 
[17:41:00.060] Future #1
[17:41:00.060]  length: 2 (resolved future 1)
[17:41:00.063] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.063] - Validating connection of MultisessionFuture
[17:41:00.063] - received message: FutureResult
[17:41:00.063] - Received FutureResult
[17:41:00.063] - Erased future from FutureRegistry
[17:41:00.064] result() for ClusterFuture ...
[17:41:00.064] - result already collected: FutureResult
[17:41:00.064] result() for ClusterFuture ... done
[17:41:00.064] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.064] Future #2
[17:41:00.064]  length: 1 (resolved future 2)
[17:41:00.167] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.168] - Validating connection of MultisessionFuture
[17:41:00.168] - received message: FutureResult
[17:41:00.168] - Received FutureResult
[17:41:00.168] - Erased future from FutureRegistry
[17:41:00.168] result() for ClusterFuture ...
[17:41:00.169] - result already collected: FutureResult
[17:41:00.169] result() for ClusterFuture ... done
[17:41:00.169] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.169] Future #3
[17:41:00.169]  length: 0 (resolved future 3)
[17:41:00.169] resolve() on list ... DONE
[17:41:00.170] getGlobalsAndPackages() ...
[17:41:00.170] Searching for globals...
[17:41:00.171] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:41:00.171] Searching for globals ... DONE
[17:41:00.172] Resolving globals: FALSE
[17:41:00.172] The total size of the 1 globals is 56 bytes (56 bytes)
[17:41:00.173] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:41:00.173] - globals: [1] ‘kk’
[17:41:00.173] 
[17:41:00.173] getGlobalsAndPackages() ... DONE
[17:41:00.174] getGlobalsAndPackages() ...
[17:41:00.174] Searching for globals...
[17:41:00.175] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:41:00.175] Searching for globals ... DONE
[17:41:00.175] Resolving globals: FALSE
[17:41:00.176] The total size of the 1 globals is 56 bytes (56 bytes)
[17:41:00.176] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:41:00.176] - globals: [1] ‘kk’
[17:41:00.177] 
[17:41:00.177] getGlobalsAndPackages() ... DONE
[17:41:00.177] getGlobalsAndPackages() ...
[17:41:00.177] Searching for globals...
[17:41:00.179] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[17:41:00.179] Searching for globals ... DONE
[17:41:00.179] Resolving globals: FALSE
[17:41:00.180] The total size of the 1 globals is 56 bytes (56 bytes)
[17:41:00.180] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[17:41:00.180] - globals: [1] ‘kk’
[17:41:00.180] 
[17:41:00.180] getGlobalsAndPackages() ... DONE
[17:41:00.181] resolve() on list ...
[17:41:00.181]  recursive: 0
[17:41:00.181]  length: 3
[17:41:00.181] 
[17:41:00.181] run() for ‘Future’ ...
[17:41:00.181] - state: ‘created’
[17:41:00.182] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.195] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.196]   - Field: ‘node’
[17:41:00.196]   - Field: ‘label’
[17:41:00.196]   - Field: ‘local’
[17:41:00.196]   - Field: ‘owner’
[17:41:00.196]   - Field: ‘envir’
[17:41:00.196]   - Field: ‘workers’
[17:41:00.196]   - Field: ‘packages’
[17:41:00.196]   - Field: ‘gc’
[17:41:00.196]   - Field: ‘conditions’
[17:41:00.196]   - Field: ‘persistent’
[17:41:00.196]   - Field: ‘expr’
[17:41:00.197]   - Field: ‘uuid’
[17:41:00.197]   - Field: ‘seed’
[17:41:00.197]   - Field: ‘version’
[17:41:00.197]   - Field: ‘result’
[17:41:00.197]   - Field: ‘asynchronous’
[17:41:00.197]   - Field: ‘calls’
[17:41:00.197]   - Field: ‘globals’
[17:41:00.197]   - Field: ‘stdout’
[17:41:00.197]   - Field: ‘earlySignal’
[17:41:00.197]   - Field: ‘lazy’
[17:41:00.197]   - Field: ‘state’
[17:41:00.198] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.198] - Launch lazy future ...
[17:41:00.201] Packages needed by the future expression (n = 0): <none>
[17:41:00.201] Packages needed by future strategies (n = 0): <none>
[17:41:00.201] {
[17:41:00.201]     {
[17:41:00.201]         {
[17:41:00.201]             ...future.startTime <- base::Sys.time()
[17:41:00.201]             {
[17:41:00.201]                 {
[17:41:00.201]                   {
[17:41:00.201]                     {
[17:41:00.201]                       base::local({
[17:41:00.201]                         has_future <- base::requireNamespace("future", 
[17:41:00.201]                           quietly = TRUE)
[17:41:00.201]                         if (has_future) {
[17:41:00.201]                           ns <- base::getNamespace("future")
[17:41:00.201]                           version <- ns[[".package"]][["version"]]
[17:41:00.201]                           if (is.null(version)) 
[17:41:00.201]                             version <- utils::packageVersion("future")
[17:41:00.201]                         }
[17:41:00.201]                         else {
[17:41:00.201]                           version <- NULL
[17:41:00.201]                         }
[17:41:00.201]                         if (!has_future || version < "1.8.0") {
[17:41:00.201]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.201]                             "", base::R.version$version.string), 
[17:41:00.201]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.201]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.201]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.201]                               "release", "version")], collapse = " "), 
[17:41:00.201]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.201]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.201]                             info)
[17:41:00.201]                           info <- base::paste(info, collapse = "; ")
[17:41:00.201]                           if (!has_future) {
[17:41:00.201]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.201]                               info)
[17:41:00.201]                           }
[17:41:00.201]                           else {
[17:41:00.201]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.201]                               info, version)
[17:41:00.201]                           }
[17:41:00.201]                           base::stop(msg)
[17:41:00.201]                         }
[17:41:00.201]                       })
[17:41:00.201]                     }
[17:41:00.201]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.201]                     base::options(mc.cores = 1L)
[17:41:00.201]                   }
[17:41:00.201]                   ...future.strategy.old <- future::plan("list")
[17:41:00.201]                   options(future.plan = NULL)
[17:41:00.201]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.201]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.201]                 }
[17:41:00.201]                 ...future.workdir <- getwd()
[17:41:00.201]             }
[17:41:00.201]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.201]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.201]         }
[17:41:00.201]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.201]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.201]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.201]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.201]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.201]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.201]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.201]             base::names(...future.oldOptions))
[17:41:00.201]     }
[17:41:00.201]     if (FALSE) {
[17:41:00.201]     }
[17:41:00.201]     else {
[17:41:00.201]         if (TRUE) {
[17:41:00.201]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.201]                 open = "w")
[17:41:00.201]         }
[17:41:00.201]         else {
[17:41:00.201]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.201]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.201]         }
[17:41:00.201]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.201]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.201]             base::sink(type = "output", split = FALSE)
[17:41:00.201]             base::close(...future.stdout)
[17:41:00.201]         }, add = TRUE)
[17:41:00.201]     }
[17:41:00.201]     ...future.frame <- base::sys.nframe()
[17:41:00.201]     ...future.conditions <- base::list()
[17:41:00.201]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.201]     if (FALSE) {
[17:41:00.201]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.201]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.201]     }
[17:41:00.201]     ...future.result <- base::tryCatch({
[17:41:00.201]         base::withCallingHandlers({
[17:41:00.201]             ...future.value <- base::withVisible(base::local({
[17:41:00.201]                 ...future.makeSendCondition <- base::local({
[17:41:00.201]                   sendCondition <- NULL
[17:41:00.201]                   function(frame = 1L) {
[17:41:00.201]                     if (is.function(sendCondition)) 
[17:41:00.201]                       return(sendCondition)
[17:41:00.201]                     ns <- getNamespace("parallel")
[17:41:00.201]                     if (exists("sendData", mode = "function", 
[17:41:00.201]                       envir = ns)) {
[17:41:00.201]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.201]                         envir = ns)
[17:41:00.201]                       envir <- sys.frame(frame)
[17:41:00.201]                       master <- NULL
[17:41:00.201]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.201]                         !identical(envir, emptyenv())) {
[17:41:00.201]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.201]                           inherits = FALSE)) {
[17:41:00.201]                           master <- get("master", mode = "list", 
[17:41:00.201]                             envir = envir, inherits = FALSE)
[17:41:00.201]                           if (inherits(master, c("SOCKnode", 
[17:41:00.201]                             "SOCK0node"))) {
[17:41:00.201]                             sendCondition <<- function(cond) {
[17:41:00.201]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.201]                                 success = TRUE)
[17:41:00.201]                               parallel_sendData(master, data)
[17:41:00.201]                             }
[17:41:00.201]                             return(sendCondition)
[17:41:00.201]                           }
[17:41:00.201]                         }
[17:41:00.201]                         frame <- frame + 1L
[17:41:00.201]                         envir <- sys.frame(frame)
[17:41:00.201]                       }
[17:41:00.201]                     }
[17:41:00.201]                     sendCondition <<- function(cond) NULL
[17:41:00.201]                   }
[17:41:00.201]                 })
[17:41:00.201]                 withCallingHandlers({
[17:41:00.201]                   {
[17:41:00.201]                     Sys.sleep(0.1)
[17:41:00.201]                     kk
[17:41:00.201]                   }
[17:41:00.201]                 }, immediateCondition = function(cond) {
[17:41:00.201]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.201]                   sendCondition(cond)
[17:41:00.201]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.201]                   {
[17:41:00.201]                     inherits <- base::inherits
[17:41:00.201]                     invokeRestart <- base::invokeRestart
[17:41:00.201]                     is.null <- base::is.null
[17:41:00.201]                     muffled <- FALSE
[17:41:00.201]                     if (inherits(cond, "message")) {
[17:41:00.201]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.201]                       if (muffled) 
[17:41:00.201]                         invokeRestart("muffleMessage")
[17:41:00.201]                     }
[17:41:00.201]                     else if (inherits(cond, "warning")) {
[17:41:00.201]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.201]                       if (muffled) 
[17:41:00.201]                         invokeRestart("muffleWarning")
[17:41:00.201]                     }
[17:41:00.201]                     else if (inherits(cond, "condition")) {
[17:41:00.201]                       if (!is.null(pattern)) {
[17:41:00.201]                         computeRestarts <- base::computeRestarts
[17:41:00.201]                         grepl <- base::grepl
[17:41:00.201]                         restarts <- computeRestarts(cond)
[17:41:00.201]                         for (restart in restarts) {
[17:41:00.201]                           name <- restart$name
[17:41:00.201]                           if (is.null(name)) 
[17:41:00.201]                             next
[17:41:00.201]                           if (!grepl(pattern, name)) 
[17:41:00.201]                             next
[17:41:00.201]                           invokeRestart(restart)
[17:41:00.201]                           muffled <- TRUE
[17:41:00.201]                           break
[17:41:00.201]                         }
[17:41:00.201]                       }
[17:41:00.201]                     }
[17:41:00.201]                     invisible(muffled)
[17:41:00.201]                   }
[17:41:00.201]                   muffleCondition(cond)
[17:41:00.201]                 })
[17:41:00.201]             }))
[17:41:00.201]             future::FutureResult(value = ...future.value$value, 
[17:41:00.201]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.201]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.201]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.201]                     ...future.globalenv.names))
[17:41:00.201]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.201]         }, condition = base::local({
[17:41:00.201]             c <- base::c
[17:41:00.201]             inherits <- base::inherits
[17:41:00.201]             invokeRestart <- base::invokeRestart
[17:41:00.201]             length <- base::length
[17:41:00.201]             list <- base::list
[17:41:00.201]             seq.int <- base::seq.int
[17:41:00.201]             signalCondition <- base::signalCondition
[17:41:00.201]             sys.calls <- base::sys.calls
[17:41:00.201]             `[[` <- base::`[[`
[17:41:00.201]             `+` <- base::`+`
[17:41:00.201]             `<<-` <- base::`<<-`
[17:41:00.201]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.201]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.201]                   3L)]
[17:41:00.201]             }
[17:41:00.201]             function(cond) {
[17:41:00.201]                 is_error <- inherits(cond, "error")
[17:41:00.201]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.201]                   NULL)
[17:41:00.201]                 if (is_error) {
[17:41:00.201]                   sessionInformation <- function() {
[17:41:00.201]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.201]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.201]                       search = base::search(), system = base::Sys.info())
[17:41:00.201]                   }
[17:41:00.201]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.201]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.201]                     cond$call), session = sessionInformation(), 
[17:41:00.201]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.201]                   signalCondition(cond)
[17:41:00.201]                 }
[17:41:00.201]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.201]                 "immediateCondition"))) {
[17:41:00.201]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.201]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.201]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.201]                   if (TRUE && !signal) {
[17:41:00.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.201]                     {
[17:41:00.201]                       inherits <- base::inherits
[17:41:00.201]                       invokeRestart <- base::invokeRestart
[17:41:00.201]                       is.null <- base::is.null
[17:41:00.201]                       muffled <- FALSE
[17:41:00.201]                       if (inherits(cond, "message")) {
[17:41:00.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.201]                         if (muffled) 
[17:41:00.201]                           invokeRestart("muffleMessage")
[17:41:00.201]                       }
[17:41:00.201]                       else if (inherits(cond, "warning")) {
[17:41:00.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.201]                         if (muffled) 
[17:41:00.201]                           invokeRestart("muffleWarning")
[17:41:00.201]                       }
[17:41:00.201]                       else if (inherits(cond, "condition")) {
[17:41:00.201]                         if (!is.null(pattern)) {
[17:41:00.201]                           computeRestarts <- base::computeRestarts
[17:41:00.201]                           grepl <- base::grepl
[17:41:00.201]                           restarts <- computeRestarts(cond)
[17:41:00.201]                           for (restart in restarts) {
[17:41:00.201]                             name <- restart$name
[17:41:00.201]                             if (is.null(name)) 
[17:41:00.201]                               next
[17:41:00.201]                             if (!grepl(pattern, name)) 
[17:41:00.201]                               next
[17:41:00.201]                             invokeRestart(restart)
[17:41:00.201]                             muffled <- TRUE
[17:41:00.201]                             break
[17:41:00.201]                           }
[17:41:00.201]                         }
[17:41:00.201]                       }
[17:41:00.201]                       invisible(muffled)
[17:41:00.201]                     }
[17:41:00.201]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.201]                   }
[17:41:00.201]                 }
[17:41:00.201]                 else {
[17:41:00.201]                   if (TRUE) {
[17:41:00.201]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.201]                     {
[17:41:00.201]                       inherits <- base::inherits
[17:41:00.201]                       invokeRestart <- base::invokeRestart
[17:41:00.201]                       is.null <- base::is.null
[17:41:00.201]                       muffled <- FALSE
[17:41:00.201]                       if (inherits(cond, "message")) {
[17:41:00.201]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.201]                         if (muffled) 
[17:41:00.201]                           invokeRestart("muffleMessage")
[17:41:00.201]                       }
[17:41:00.201]                       else if (inherits(cond, "warning")) {
[17:41:00.201]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.201]                         if (muffled) 
[17:41:00.201]                           invokeRestart("muffleWarning")
[17:41:00.201]                       }
[17:41:00.201]                       else if (inherits(cond, "condition")) {
[17:41:00.201]                         if (!is.null(pattern)) {
[17:41:00.201]                           computeRestarts <- base::computeRestarts
[17:41:00.201]                           grepl <- base::grepl
[17:41:00.201]                           restarts <- computeRestarts(cond)
[17:41:00.201]                           for (restart in restarts) {
[17:41:00.201]                             name <- restart$name
[17:41:00.201]                             if (is.null(name)) 
[17:41:00.201]                               next
[17:41:00.201]                             if (!grepl(pattern, name)) 
[17:41:00.201]                               next
[17:41:00.201]                             invokeRestart(restart)
[17:41:00.201]                             muffled <- TRUE
[17:41:00.201]                             break
[17:41:00.201]                           }
[17:41:00.201]                         }
[17:41:00.201]                       }
[17:41:00.201]                       invisible(muffled)
[17:41:00.201]                     }
[17:41:00.201]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.201]                   }
[17:41:00.201]                 }
[17:41:00.201]             }
[17:41:00.201]         }))
[17:41:00.201]     }, error = function(ex) {
[17:41:00.201]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.201]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.201]                 ...future.rng), started = ...future.startTime, 
[17:41:00.201]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.201]             version = "1.8"), class = "FutureResult")
[17:41:00.201]     }, finally = {
[17:41:00.201]         if (!identical(...future.workdir, getwd())) 
[17:41:00.201]             setwd(...future.workdir)
[17:41:00.201]         {
[17:41:00.201]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.201]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.201]             }
[17:41:00.201]             base::options(...future.oldOptions)
[17:41:00.201]             if (.Platform$OS.type == "windows") {
[17:41:00.201]                 old_names <- names(...future.oldEnvVars)
[17:41:00.201]                 envs <- base::Sys.getenv()
[17:41:00.201]                 names <- names(envs)
[17:41:00.201]                 common <- intersect(names, old_names)
[17:41:00.201]                 added <- setdiff(names, old_names)
[17:41:00.201]                 removed <- setdiff(old_names, names)
[17:41:00.201]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.201]                   envs[common]]
[17:41:00.201]                 NAMES <- toupper(changed)
[17:41:00.201]                 args <- list()
[17:41:00.201]                 for (kk in seq_along(NAMES)) {
[17:41:00.201]                   name <- changed[[kk]]
[17:41:00.201]                   NAME <- NAMES[[kk]]
[17:41:00.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.201]                     next
[17:41:00.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.201]                 }
[17:41:00.201]                 NAMES <- toupper(added)
[17:41:00.201]                 for (kk in seq_along(NAMES)) {
[17:41:00.201]                   name <- added[[kk]]
[17:41:00.201]                   NAME <- NAMES[[kk]]
[17:41:00.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.201]                     next
[17:41:00.201]                   args[[name]] <- ""
[17:41:00.201]                 }
[17:41:00.201]                 NAMES <- toupper(removed)
[17:41:00.201]                 for (kk in seq_along(NAMES)) {
[17:41:00.201]                   name <- removed[[kk]]
[17:41:00.201]                   NAME <- NAMES[[kk]]
[17:41:00.201]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.201]                     next
[17:41:00.201]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.201]                 }
[17:41:00.201]                 if (length(args) > 0) 
[17:41:00.201]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.201]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.201]             }
[17:41:00.201]             else {
[17:41:00.201]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.201]             }
[17:41:00.201]             {
[17:41:00.201]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.201]                   0L) {
[17:41:00.201]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.201]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.201]                   base::options(opts)
[17:41:00.201]                 }
[17:41:00.201]                 {
[17:41:00.201]                   {
[17:41:00.201]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.201]                     NULL
[17:41:00.201]                   }
[17:41:00.201]                   options(future.plan = NULL)
[17:41:00.201]                   if (is.na(NA_character_)) 
[17:41:00.201]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.201]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.201]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.201]                     .init = FALSE)
[17:41:00.201]                 }
[17:41:00.201]             }
[17:41:00.201]         }
[17:41:00.201]     })
[17:41:00.201]     if (TRUE) {
[17:41:00.201]         base::sink(type = "output", split = FALSE)
[17:41:00.201]         if (TRUE) {
[17:41:00.201]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.201]         }
[17:41:00.201]         else {
[17:41:00.201]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.201]         }
[17:41:00.201]         base::close(...future.stdout)
[17:41:00.201]         ...future.stdout <- NULL
[17:41:00.201]     }
[17:41:00.201]     ...future.result$conditions <- ...future.conditions
[17:41:00.201]     ...future.result$finished <- base::Sys.time()
[17:41:00.201]     ...future.result
[17:41:00.201] }
[17:41:00.204] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:41:00.204] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:41:00.205] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.205] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:41:00.205] MultisessionFuture started
[17:41:00.205] - Launch lazy future ... done
[17:41:00.205] run() for ‘MultisessionFuture’ ... done
[17:41:00.216] run() for ‘Future’ ...
[17:41:00.216] - state: ‘created’
[17:41:00.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.230]   - Field: ‘node’
[17:41:00.230]   - Field: ‘label’
[17:41:00.230]   - Field: ‘local’
[17:41:00.230]   - Field: ‘owner’
[17:41:00.230]   - Field: ‘envir’
[17:41:00.230]   - Field: ‘workers’
[17:41:00.230]   - Field: ‘packages’
[17:41:00.231]   - Field: ‘gc’
[17:41:00.231]   - Field: ‘conditions’
[17:41:00.231]   - Field: ‘persistent’
[17:41:00.231]   - Field: ‘expr’
[17:41:00.231]   - Field: ‘uuid’
[17:41:00.231]   - Field: ‘seed’
[17:41:00.231]   - Field: ‘version’
[17:41:00.231]   - Field: ‘result’
[17:41:00.231]   - Field: ‘asynchronous’
[17:41:00.231]   - Field: ‘calls’
[17:41:00.231]   - Field: ‘globals’
[17:41:00.232]   - Field: ‘stdout’
[17:41:00.232]   - Field: ‘earlySignal’
[17:41:00.232]   - Field: ‘lazy’
[17:41:00.232]   - Field: ‘state’
[17:41:00.232] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.232] - Launch lazy future ...
[17:41:00.232] Packages needed by the future expression (n = 0): <none>
[17:41:00.232] Packages needed by future strategies (n = 0): <none>
[17:41:00.233] {
[17:41:00.233]     {
[17:41:00.233]         {
[17:41:00.233]             ...future.startTime <- base::Sys.time()
[17:41:00.233]             {
[17:41:00.233]                 {
[17:41:00.233]                   {
[17:41:00.233]                     {
[17:41:00.233]                       base::local({
[17:41:00.233]                         has_future <- base::requireNamespace("future", 
[17:41:00.233]                           quietly = TRUE)
[17:41:00.233]                         if (has_future) {
[17:41:00.233]                           ns <- base::getNamespace("future")
[17:41:00.233]                           version <- ns[[".package"]][["version"]]
[17:41:00.233]                           if (is.null(version)) 
[17:41:00.233]                             version <- utils::packageVersion("future")
[17:41:00.233]                         }
[17:41:00.233]                         else {
[17:41:00.233]                           version <- NULL
[17:41:00.233]                         }
[17:41:00.233]                         if (!has_future || version < "1.8.0") {
[17:41:00.233]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.233]                             "", base::R.version$version.string), 
[17:41:00.233]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.233]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.233]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.233]                               "release", "version")], collapse = " "), 
[17:41:00.233]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.233]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.233]                             info)
[17:41:00.233]                           info <- base::paste(info, collapse = "; ")
[17:41:00.233]                           if (!has_future) {
[17:41:00.233]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.233]                               info)
[17:41:00.233]                           }
[17:41:00.233]                           else {
[17:41:00.233]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.233]                               info, version)
[17:41:00.233]                           }
[17:41:00.233]                           base::stop(msg)
[17:41:00.233]                         }
[17:41:00.233]                       })
[17:41:00.233]                     }
[17:41:00.233]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.233]                     base::options(mc.cores = 1L)
[17:41:00.233]                   }
[17:41:00.233]                   ...future.strategy.old <- future::plan("list")
[17:41:00.233]                   options(future.plan = NULL)
[17:41:00.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.233]                 }
[17:41:00.233]                 ...future.workdir <- getwd()
[17:41:00.233]             }
[17:41:00.233]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.233]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.233]         }
[17:41:00.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.233]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.233]             base::names(...future.oldOptions))
[17:41:00.233]     }
[17:41:00.233]     if (FALSE) {
[17:41:00.233]     }
[17:41:00.233]     else {
[17:41:00.233]         if (TRUE) {
[17:41:00.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.233]                 open = "w")
[17:41:00.233]         }
[17:41:00.233]         else {
[17:41:00.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.233]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.233]         }
[17:41:00.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.233]             base::sink(type = "output", split = FALSE)
[17:41:00.233]             base::close(...future.stdout)
[17:41:00.233]         }, add = TRUE)
[17:41:00.233]     }
[17:41:00.233]     ...future.frame <- base::sys.nframe()
[17:41:00.233]     ...future.conditions <- base::list()
[17:41:00.233]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.233]     if (FALSE) {
[17:41:00.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.233]     }
[17:41:00.233]     ...future.result <- base::tryCatch({
[17:41:00.233]         base::withCallingHandlers({
[17:41:00.233]             ...future.value <- base::withVisible(base::local({
[17:41:00.233]                 ...future.makeSendCondition <- base::local({
[17:41:00.233]                   sendCondition <- NULL
[17:41:00.233]                   function(frame = 1L) {
[17:41:00.233]                     if (is.function(sendCondition)) 
[17:41:00.233]                       return(sendCondition)
[17:41:00.233]                     ns <- getNamespace("parallel")
[17:41:00.233]                     if (exists("sendData", mode = "function", 
[17:41:00.233]                       envir = ns)) {
[17:41:00.233]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.233]                         envir = ns)
[17:41:00.233]                       envir <- sys.frame(frame)
[17:41:00.233]                       master <- NULL
[17:41:00.233]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.233]                         !identical(envir, emptyenv())) {
[17:41:00.233]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.233]                           inherits = FALSE)) {
[17:41:00.233]                           master <- get("master", mode = "list", 
[17:41:00.233]                             envir = envir, inherits = FALSE)
[17:41:00.233]                           if (inherits(master, c("SOCKnode", 
[17:41:00.233]                             "SOCK0node"))) {
[17:41:00.233]                             sendCondition <<- function(cond) {
[17:41:00.233]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.233]                                 success = TRUE)
[17:41:00.233]                               parallel_sendData(master, data)
[17:41:00.233]                             }
[17:41:00.233]                             return(sendCondition)
[17:41:00.233]                           }
[17:41:00.233]                         }
[17:41:00.233]                         frame <- frame + 1L
[17:41:00.233]                         envir <- sys.frame(frame)
[17:41:00.233]                       }
[17:41:00.233]                     }
[17:41:00.233]                     sendCondition <<- function(cond) NULL
[17:41:00.233]                   }
[17:41:00.233]                 })
[17:41:00.233]                 withCallingHandlers({
[17:41:00.233]                   {
[17:41:00.233]                     Sys.sleep(0.1)
[17:41:00.233]                     kk
[17:41:00.233]                   }
[17:41:00.233]                 }, immediateCondition = function(cond) {
[17:41:00.233]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.233]                   sendCondition(cond)
[17:41:00.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.233]                   {
[17:41:00.233]                     inherits <- base::inherits
[17:41:00.233]                     invokeRestart <- base::invokeRestart
[17:41:00.233]                     is.null <- base::is.null
[17:41:00.233]                     muffled <- FALSE
[17:41:00.233]                     if (inherits(cond, "message")) {
[17:41:00.233]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.233]                       if (muffled) 
[17:41:00.233]                         invokeRestart("muffleMessage")
[17:41:00.233]                     }
[17:41:00.233]                     else if (inherits(cond, "warning")) {
[17:41:00.233]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.233]                       if (muffled) 
[17:41:00.233]                         invokeRestart("muffleWarning")
[17:41:00.233]                     }
[17:41:00.233]                     else if (inherits(cond, "condition")) {
[17:41:00.233]                       if (!is.null(pattern)) {
[17:41:00.233]                         computeRestarts <- base::computeRestarts
[17:41:00.233]                         grepl <- base::grepl
[17:41:00.233]                         restarts <- computeRestarts(cond)
[17:41:00.233]                         for (restart in restarts) {
[17:41:00.233]                           name <- restart$name
[17:41:00.233]                           if (is.null(name)) 
[17:41:00.233]                             next
[17:41:00.233]                           if (!grepl(pattern, name)) 
[17:41:00.233]                             next
[17:41:00.233]                           invokeRestart(restart)
[17:41:00.233]                           muffled <- TRUE
[17:41:00.233]                           break
[17:41:00.233]                         }
[17:41:00.233]                       }
[17:41:00.233]                     }
[17:41:00.233]                     invisible(muffled)
[17:41:00.233]                   }
[17:41:00.233]                   muffleCondition(cond)
[17:41:00.233]                 })
[17:41:00.233]             }))
[17:41:00.233]             future::FutureResult(value = ...future.value$value, 
[17:41:00.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.233]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.233]                     ...future.globalenv.names))
[17:41:00.233]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.233]         }, condition = base::local({
[17:41:00.233]             c <- base::c
[17:41:00.233]             inherits <- base::inherits
[17:41:00.233]             invokeRestart <- base::invokeRestart
[17:41:00.233]             length <- base::length
[17:41:00.233]             list <- base::list
[17:41:00.233]             seq.int <- base::seq.int
[17:41:00.233]             signalCondition <- base::signalCondition
[17:41:00.233]             sys.calls <- base::sys.calls
[17:41:00.233]             `[[` <- base::`[[`
[17:41:00.233]             `+` <- base::`+`
[17:41:00.233]             `<<-` <- base::`<<-`
[17:41:00.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.233]                   3L)]
[17:41:00.233]             }
[17:41:00.233]             function(cond) {
[17:41:00.233]                 is_error <- inherits(cond, "error")
[17:41:00.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.233]                   NULL)
[17:41:00.233]                 if (is_error) {
[17:41:00.233]                   sessionInformation <- function() {
[17:41:00.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.233]                       search = base::search(), system = base::Sys.info())
[17:41:00.233]                   }
[17:41:00.233]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.233]                     cond$call), session = sessionInformation(), 
[17:41:00.233]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.233]                   signalCondition(cond)
[17:41:00.233]                 }
[17:41:00.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.233]                 "immediateCondition"))) {
[17:41:00.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.233]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.233]                   if (TRUE && !signal) {
[17:41:00.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.233]                     {
[17:41:00.233]                       inherits <- base::inherits
[17:41:00.233]                       invokeRestart <- base::invokeRestart
[17:41:00.233]                       is.null <- base::is.null
[17:41:00.233]                       muffled <- FALSE
[17:41:00.233]                       if (inherits(cond, "message")) {
[17:41:00.233]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.233]                         if (muffled) 
[17:41:00.233]                           invokeRestart("muffleMessage")
[17:41:00.233]                       }
[17:41:00.233]                       else if (inherits(cond, "warning")) {
[17:41:00.233]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.233]                         if (muffled) 
[17:41:00.233]                           invokeRestart("muffleWarning")
[17:41:00.233]                       }
[17:41:00.233]                       else if (inherits(cond, "condition")) {
[17:41:00.233]                         if (!is.null(pattern)) {
[17:41:00.233]                           computeRestarts <- base::computeRestarts
[17:41:00.233]                           grepl <- base::grepl
[17:41:00.233]                           restarts <- computeRestarts(cond)
[17:41:00.233]                           for (restart in restarts) {
[17:41:00.233]                             name <- restart$name
[17:41:00.233]                             if (is.null(name)) 
[17:41:00.233]                               next
[17:41:00.233]                             if (!grepl(pattern, name)) 
[17:41:00.233]                               next
[17:41:00.233]                             invokeRestart(restart)
[17:41:00.233]                             muffled <- TRUE
[17:41:00.233]                             break
[17:41:00.233]                           }
[17:41:00.233]                         }
[17:41:00.233]                       }
[17:41:00.233]                       invisible(muffled)
[17:41:00.233]                     }
[17:41:00.233]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.233]                   }
[17:41:00.233]                 }
[17:41:00.233]                 else {
[17:41:00.233]                   if (TRUE) {
[17:41:00.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.233]                     {
[17:41:00.233]                       inherits <- base::inherits
[17:41:00.233]                       invokeRestart <- base::invokeRestart
[17:41:00.233]                       is.null <- base::is.null
[17:41:00.233]                       muffled <- FALSE
[17:41:00.233]                       if (inherits(cond, "message")) {
[17:41:00.233]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.233]                         if (muffled) 
[17:41:00.233]                           invokeRestart("muffleMessage")
[17:41:00.233]                       }
[17:41:00.233]                       else if (inherits(cond, "warning")) {
[17:41:00.233]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.233]                         if (muffled) 
[17:41:00.233]                           invokeRestart("muffleWarning")
[17:41:00.233]                       }
[17:41:00.233]                       else if (inherits(cond, "condition")) {
[17:41:00.233]                         if (!is.null(pattern)) {
[17:41:00.233]                           computeRestarts <- base::computeRestarts
[17:41:00.233]                           grepl <- base::grepl
[17:41:00.233]                           restarts <- computeRestarts(cond)
[17:41:00.233]                           for (restart in restarts) {
[17:41:00.233]                             name <- restart$name
[17:41:00.233]                             if (is.null(name)) 
[17:41:00.233]                               next
[17:41:00.233]                             if (!grepl(pattern, name)) 
[17:41:00.233]                               next
[17:41:00.233]                             invokeRestart(restart)
[17:41:00.233]                             muffled <- TRUE
[17:41:00.233]                             break
[17:41:00.233]                           }
[17:41:00.233]                         }
[17:41:00.233]                       }
[17:41:00.233]                       invisible(muffled)
[17:41:00.233]                     }
[17:41:00.233]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.233]                   }
[17:41:00.233]                 }
[17:41:00.233]             }
[17:41:00.233]         }))
[17:41:00.233]     }, error = function(ex) {
[17:41:00.233]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.233]                 ...future.rng), started = ...future.startTime, 
[17:41:00.233]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.233]             version = "1.8"), class = "FutureResult")
[17:41:00.233]     }, finally = {
[17:41:00.233]         if (!identical(...future.workdir, getwd())) 
[17:41:00.233]             setwd(...future.workdir)
[17:41:00.233]         {
[17:41:00.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.233]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.233]             }
[17:41:00.233]             base::options(...future.oldOptions)
[17:41:00.233]             if (.Platform$OS.type == "windows") {
[17:41:00.233]                 old_names <- names(...future.oldEnvVars)
[17:41:00.233]                 envs <- base::Sys.getenv()
[17:41:00.233]                 names <- names(envs)
[17:41:00.233]                 common <- intersect(names, old_names)
[17:41:00.233]                 added <- setdiff(names, old_names)
[17:41:00.233]                 removed <- setdiff(old_names, names)
[17:41:00.233]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.233]                   envs[common]]
[17:41:00.233]                 NAMES <- toupper(changed)
[17:41:00.233]                 args <- list()
[17:41:00.233]                 for (kk in seq_along(NAMES)) {
[17:41:00.233]                   name <- changed[[kk]]
[17:41:00.233]                   NAME <- NAMES[[kk]]
[17:41:00.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.233]                     next
[17:41:00.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.233]                 }
[17:41:00.233]                 NAMES <- toupper(added)
[17:41:00.233]                 for (kk in seq_along(NAMES)) {
[17:41:00.233]                   name <- added[[kk]]
[17:41:00.233]                   NAME <- NAMES[[kk]]
[17:41:00.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.233]                     next
[17:41:00.233]                   args[[name]] <- ""
[17:41:00.233]                 }
[17:41:00.233]                 NAMES <- toupper(removed)
[17:41:00.233]                 for (kk in seq_along(NAMES)) {
[17:41:00.233]                   name <- removed[[kk]]
[17:41:00.233]                   NAME <- NAMES[[kk]]
[17:41:00.233]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.233]                     next
[17:41:00.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.233]                 }
[17:41:00.233]                 if (length(args) > 0) 
[17:41:00.233]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.233]             }
[17:41:00.233]             else {
[17:41:00.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.233]             }
[17:41:00.233]             {
[17:41:00.233]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.233]                   0L) {
[17:41:00.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.233]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.233]                   base::options(opts)
[17:41:00.233]                 }
[17:41:00.233]                 {
[17:41:00.233]                   {
[17:41:00.233]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.233]                     NULL
[17:41:00.233]                   }
[17:41:00.233]                   options(future.plan = NULL)
[17:41:00.233]                   if (is.na(NA_character_)) 
[17:41:00.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.233]                     .init = FALSE)
[17:41:00.233]                 }
[17:41:00.233]             }
[17:41:00.233]         }
[17:41:00.233]     })
[17:41:00.233]     if (TRUE) {
[17:41:00.233]         base::sink(type = "output", split = FALSE)
[17:41:00.233]         if (TRUE) {
[17:41:00.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.233]         }
[17:41:00.233]         else {
[17:41:00.233]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.233]         }
[17:41:00.233]         base::close(...future.stdout)
[17:41:00.233]         ...future.stdout <- NULL
[17:41:00.233]     }
[17:41:00.233]     ...future.result$conditions <- ...future.conditions
[17:41:00.233]     ...future.result$finished <- base::Sys.time()
[17:41:00.233]     ...future.result
[17:41:00.233] }
[17:41:00.235] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[17:41:00.235] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[17:41:00.236] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[17:41:00.236] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[17:41:00.236] MultisessionFuture started
[17:41:00.236] - Launch lazy future ... done
[17:41:00.236] run() for ‘MultisessionFuture’ ... done
[17:41:00.247] run() for ‘Future’ ...
[17:41:00.247] - state: ‘created’
[17:41:00.247] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.261]   - Field: ‘node’
[17:41:00.261]   - Field: ‘label’
[17:41:00.261]   - Field: ‘local’
[17:41:00.261]   - Field: ‘owner’
[17:41:00.261]   - Field: ‘envir’
[17:41:00.261]   - Field: ‘workers’
[17:41:00.261]   - Field: ‘packages’
[17:41:00.261]   - Field: ‘gc’
[17:41:00.261]   - Field: ‘conditions’
[17:41:00.262]   - Field: ‘persistent’
[17:41:00.262]   - Field: ‘expr’
[17:41:00.262]   - Field: ‘uuid’
[17:41:00.262]   - Field: ‘seed’
[17:41:00.262]   - Field: ‘version’
[17:41:00.262]   - Field: ‘result’
[17:41:00.262]   - Field: ‘asynchronous’
[17:41:00.262]   - Field: ‘calls’
[17:41:00.262]   - Field: ‘globals’
[17:41:00.262]   - Field: ‘stdout’
[17:41:00.262]   - Field: ‘earlySignal’
[17:41:00.263]   - Field: ‘lazy’
[17:41:00.263]   - Field: ‘state’
[17:41:00.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.263] - Launch lazy future ...
[17:41:00.263] Packages needed by the future expression (n = 0): <none>
[17:41:00.263] Packages needed by future strategies (n = 0): <none>
[17:41:00.264] {
[17:41:00.264]     {
[17:41:00.264]         {
[17:41:00.264]             ...future.startTime <- base::Sys.time()
[17:41:00.264]             {
[17:41:00.264]                 {
[17:41:00.264]                   {
[17:41:00.264]                     {
[17:41:00.264]                       base::local({
[17:41:00.264]                         has_future <- base::requireNamespace("future", 
[17:41:00.264]                           quietly = TRUE)
[17:41:00.264]                         if (has_future) {
[17:41:00.264]                           ns <- base::getNamespace("future")
[17:41:00.264]                           version <- ns[[".package"]][["version"]]
[17:41:00.264]                           if (is.null(version)) 
[17:41:00.264]                             version <- utils::packageVersion("future")
[17:41:00.264]                         }
[17:41:00.264]                         else {
[17:41:00.264]                           version <- NULL
[17:41:00.264]                         }
[17:41:00.264]                         if (!has_future || version < "1.8.0") {
[17:41:00.264]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.264]                             "", base::R.version$version.string), 
[17:41:00.264]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.264]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.264]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.264]                               "release", "version")], collapse = " "), 
[17:41:00.264]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.264]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.264]                             info)
[17:41:00.264]                           info <- base::paste(info, collapse = "; ")
[17:41:00.264]                           if (!has_future) {
[17:41:00.264]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.264]                               info)
[17:41:00.264]                           }
[17:41:00.264]                           else {
[17:41:00.264]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.264]                               info, version)
[17:41:00.264]                           }
[17:41:00.264]                           base::stop(msg)
[17:41:00.264]                         }
[17:41:00.264]                       })
[17:41:00.264]                     }
[17:41:00.264]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.264]                     base::options(mc.cores = 1L)
[17:41:00.264]                   }
[17:41:00.264]                   ...future.strategy.old <- future::plan("list")
[17:41:00.264]                   options(future.plan = NULL)
[17:41:00.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.264]                 }
[17:41:00.264]                 ...future.workdir <- getwd()
[17:41:00.264]             }
[17:41:00.264]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.264]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.264]         }
[17:41:00.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.264]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.264]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.264]             base::names(...future.oldOptions))
[17:41:00.264]     }
[17:41:00.264]     if (FALSE) {
[17:41:00.264]     }
[17:41:00.264]     else {
[17:41:00.264]         if (TRUE) {
[17:41:00.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.264]                 open = "w")
[17:41:00.264]         }
[17:41:00.264]         else {
[17:41:00.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.264]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.264]         }
[17:41:00.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.264]             base::sink(type = "output", split = FALSE)
[17:41:00.264]             base::close(...future.stdout)
[17:41:00.264]         }, add = TRUE)
[17:41:00.264]     }
[17:41:00.264]     ...future.frame <- base::sys.nframe()
[17:41:00.264]     ...future.conditions <- base::list()
[17:41:00.264]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.264]     if (FALSE) {
[17:41:00.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.264]     }
[17:41:00.264]     ...future.result <- base::tryCatch({
[17:41:00.264]         base::withCallingHandlers({
[17:41:00.264]             ...future.value <- base::withVisible(base::local({
[17:41:00.264]                 ...future.makeSendCondition <- base::local({
[17:41:00.264]                   sendCondition <- NULL
[17:41:00.264]                   function(frame = 1L) {
[17:41:00.264]                     if (is.function(sendCondition)) 
[17:41:00.264]                       return(sendCondition)
[17:41:00.264]                     ns <- getNamespace("parallel")
[17:41:00.264]                     if (exists("sendData", mode = "function", 
[17:41:00.264]                       envir = ns)) {
[17:41:00.264]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.264]                         envir = ns)
[17:41:00.264]                       envir <- sys.frame(frame)
[17:41:00.264]                       master <- NULL
[17:41:00.264]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.264]                         !identical(envir, emptyenv())) {
[17:41:00.264]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.264]                           inherits = FALSE)) {
[17:41:00.264]                           master <- get("master", mode = "list", 
[17:41:00.264]                             envir = envir, inherits = FALSE)
[17:41:00.264]                           if (inherits(master, c("SOCKnode", 
[17:41:00.264]                             "SOCK0node"))) {
[17:41:00.264]                             sendCondition <<- function(cond) {
[17:41:00.264]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.264]                                 success = TRUE)
[17:41:00.264]                               parallel_sendData(master, data)
[17:41:00.264]                             }
[17:41:00.264]                             return(sendCondition)
[17:41:00.264]                           }
[17:41:00.264]                         }
[17:41:00.264]                         frame <- frame + 1L
[17:41:00.264]                         envir <- sys.frame(frame)
[17:41:00.264]                       }
[17:41:00.264]                     }
[17:41:00.264]                     sendCondition <<- function(cond) NULL
[17:41:00.264]                   }
[17:41:00.264]                 })
[17:41:00.264]                 withCallingHandlers({
[17:41:00.264]                   {
[17:41:00.264]                     Sys.sleep(0.1)
[17:41:00.264]                     kk
[17:41:00.264]                   }
[17:41:00.264]                 }, immediateCondition = function(cond) {
[17:41:00.264]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.264]                   sendCondition(cond)
[17:41:00.264]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.264]                   {
[17:41:00.264]                     inherits <- base::inherits
[17:41:00.264]                     invokeRestart <- base::invokeRestart
[17:41:00.264]                     is.null <- base::is.null
[17:41:00.264]                     muffled <- FALSE
[17:41:00.264]                     if (inherits(cond, "message")) {
[17:41:00.264]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.264]                       if (muffled) 
[17:41:00.264]                         invokeRestart("muffleMessage")
[17:41:00.264]                     }
[17:41:00.264]                     else if (inherits(cond, "warning")) {
[17:41:00.264]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.264]                       if (muffled) 
[17:41:00.264]                         invokeRestart("muffleWarning")
[17:41:00.264]                     }
[17:41:00.264]                     else if (inherits(cond, "condition")) {
[17:41:00.264]                       if (!is.null(pattern)) {
[17:41:00.264]                         computeRestarts <- base::computeRestarts
[17:41:00.264]                         grepl <- base::grepl
[17:41:00.264]                         restarts <- computeRestarts(cond)
[17:41:00.264]                         for (restart in restarts) {
[17:41:00.264]                           name <- restart$name
[17:41:00.264]                           if (is.null(name)) 
[17:41:00.264]                             next
[17:41:00.264]                           if (!grepl(pattern, name)) 
[17:41:00.264]                             next
[17:41:00.264]                           invokeRestart(restart)
[17:41:00.264]                           muffled <- TRUE
[17:41:00.264]                           break
[17:41:00.264]                         }
[17:41:00.264]                       }
[17:41:00.264]                     }
[17:41:00.264]                     invisible(muffled)
[17:41:00.264]                   }
[17:41:00.264]                   muffleCondition(cond)
[17:41:00.264]                 })
[17:41:00.264]             }))
[17:41:00.264]             future::FutureResult(value = ...future.value$value, 
[17:41:00.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.264]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.264]                     ...future.globalenv.names))
[17:41:00.264]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.264]         }, condition = base::local({
[17:41:00.264]             c <- base::c
[17:41:00.264]             inherits <- base::inherits
[17:41:00.264]             invokeRestart <- base::invokeRestart
[17:41:00.264]             length <- base::length
[17:41:00.264]             list <- base::list
[17:41:00.264]             seq.int <- base::seq.int
[17:41:00.264]             signalCondition <- base::signalCondition
[17:41:00.264]             sys.calls <- base::sys.calls
[17:41:00.264]             `[[` <- base::`[[`
[17:41:00.264]             `+` <- base::`+`
[17:41:00.264]             `<<-` <- base::`<<-`
[17:41:00.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.264]                   3L)]
[17:41:00.264]             }
[17:41:00.264]             function(cond) {
[17:41:00.264]                 is_error <- inherits(cond, "error")
[17:41:00.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.264]                   NULL)
[17:41:00.264]                 if (is_error) {
[17:41:00.264]                   sessionInformation <- function() {
[17:41:00.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.264]                       search = base::search(), system = base::Sys.info())
[17:41:00.264]                   }
[17:41:00.264]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.264]                     cond$call), session = sessionInformation(), 
[17:41:00.264]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.264]                   signalCondition(cond)
[17:41:00.264]                 }
[17:41:00.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.264]                 "immediateCondition"))) {
[17:41:00.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.264]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.264]                   if (TRUE && !signal) {
[17:41:00.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.264]                     {
[17:41:00.264]                       inherits <- base::inherits
[17:41:00.264]                       invokeRestart <- base::invokeRestart
[17:41:00.264]                       is.null <- base::is.null
[17:41:00.264]                       muffled <- FALSE
[17:41:00.264]                       if (inherits(cond, "message")) {
[17:41:00.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.264]                         if (muffled) 
[17:41:00.264]                           invokeRestart("muffleMessage")
[17:41:00.264]                       }
[17:41:00.264]                       else if (inherits(cond, "warning")) {
[17:41:00.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.264]                         if (muffled) 
[17:41:00.264]                           invokeRestart("muffleWarning")
[17:41:00.264]                       }
[17:41:00.264]                       else if (inherits(cond, "condition")) {
[17:41:00.264]                         if (!is.null(pattern)) {
[17:41:00.264]                           computeRestarts <- base::computeRestarts
[17:41:00.264]                           grepl <- base::grepl
[17:41:00.264]                           restarts <- computeRestarts(cond)
[17:41:00.264]                           for (restart in restarts) {
[17:41:00.264]                             name <- restart$name
[17:41:00.264]                             if (is.null(name)) 
[17:41:00.264]                               next
[17:41:00.264]                             if (!grepl(pattern, name)) 
[17:41:00.264]                               next
[17:41:00.264]                             invokeRestart(restart)
[17:41:00.264]                             muffled <- TRUE
[17:41:00.264]                             break
[17:41:00.264]                           }
[17:41:00.264]                         }
[17:41:00.264]                       }
[17:41:00.264]                       invisible(muffled)
[17:41:00.264]                     }
[17:41:00.264]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.264]                   }
[17:41:00.264]                 }
[17:41:00.264]                 else {
[17:41:00.264]                   if (TRUE) {
[17:41:00.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.264]                     {
[17:41:00.264]                       inherits <- base::inherits
[17:41:00.264]                       invokeRestart <- base::invokeRestart
[17:41:00.264]                       is.null <- base::is.null
[17:41:00.264]                       muffled <- FALSE
[17:41:00.264]                       if (inherits(cond, "message")) {
[17:41:00.264]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.264]                         if (muffled) 
[17:41:00.264]                           invokeRestart("muffleMessage")
[17:41:00.264]                       }
[17:41:00.264]                       else if (inherits(cond, "warning")) {
[17:41:00.264]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.264]                         if (muffled) 
[17:41:00.264]                           invokeRestart("muffleWarning")
[17:41:00.264]                       }
[17:41:00.264]                       else if (inherits(cond, "condition")) {
[17:41:00.264]                         if (!is.null(pattern)) {
[17:41:00.264]                           computeRestarts <- base::computeRestarts
[17:41:00.264]                           grepl <- base::grepl
[17:41:00.264]                           restarts <- computeRestarts(cond)
[17:41:00.264]                           for (restart in restarts) {
[17:41:00.264]                             name <- restart$name
[17:41:00.264]                             if (is.null(name)) 
[17:41:00.264]                               next
[17:41:00.264]                             if (!grepl(pattern, name)) 
[17:41:00.264]                               next
[17:41:00.264]                             invokeRestart(restart)
[17:41:00.264]                             muffled <- TRUE
[17:41:00.264]                             break
[17:41:00.264]                           }
[17:41:00.264]                         }
[17:41:00.264]                       }
[17:41:00.264]                       invisible(muffled)
[17:41:00.264]                     }
[17:41:00.264]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.264]                   }
[17:41:00.264]                 }
[17:41:00.264]             }
[17:41:00.264]         }))
[17:41:00.264]     }, error = function(ex) {
[17:41:00.264]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.264]                 ...future.rng), started = ...future.startTime, 
[17:41:00.264]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.264]             version = "1.8"), class = "FutureResult")
[17:41:00.264]     }, finally = {
[17:41:00.264]         if (!identical(...future.workdir, getwd())) 
[17:41:00.264]             setwd(...future.workdir)
[17:41:00.264]         {
[17:41:00.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.264]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.264]             }
[17:41:00.264]             base::options(...future.oldOptions)
[17:41:00.264]             if (.Platform$OS.type == "windows") {
[17:41:00.264]                 old_names <- names(...future.oldEnvVars)
[17:41:00.264]                 envs <- base::Sys.getenv()
[17:41:00.264]                 names <- names(envs)
[17:41:00.264]                 common <- intersect(names, old_names)
[17:41:00.264]                 added <- setdiff(names, old_names)
[17:41:00.264]                 removed <- setdiff(old_names, names)
[17:41:00.264]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.264]                   envs[common]]
[17:41:00.264]                 NAMES <- toupper(changed)
[17:41:00.264]                 args <- list()
[17:41:00.264]                 for (kk in seq_along(NAMES)) {
[17:41:00.264]                   name <- changed[[kk]]
[17:41:00.264]                   NAME <- NAMES[[kk]]
[17:41:00.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.264]                     next
[17:41:00.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.264]                 }
[17:41:00.264]                 NAMES <- toupper(added)
[17:41:00.264]                 for (kk in seq_along(NAMES)) {
[17:41:00.264]                   name <- added[[kk]]
[17:41:00.264]                   NAME <- NAMES[[kk]]
[17:41:00.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.264]                     next
[17:41:00.264]                   args[[name]] <- ""
[17:41:00.264]                 }
[17:41:00.264]                 NAMES <- toupper(removed)
[17:41:00.264]                 for (kk in seq_along(NAMES)) {
[17:41:00.264]                   name <- removed[[kk]]
[17:41:00.264]                   NAME <- NAMES[[kk]]
[17:41:00.264]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.264]                     next
[17:41:00.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.264]                 }
[17:41:00.264]                 if (length(args) > 0) 
[17:41:00.264]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.264]             }
[17:41:00.264]             else {
[17:41:00.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.264]             }
[17:41:00.264]             {
[17:41:00.264]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.264]                   0L) {
[17:41:00.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.264]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.264]                   base::options(opts)
[17:41:00.264]                 }
[17:41:00.264]                 {
[17:41:00.264]                   {
[17:41:00.264]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.264]                     NULL
[17:41:00.264]                   }
[17:41:00.264]                   options(future.plan = NULL)
[17:41:00.264]                   if (is.na(NA_character_)) 
[17:41:00.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.264]                     .init = FALSE)
[17:41:00.264]                 }
[17:41:00.264]             }
[17:41:00.264]         }
[17:41:00.264]     })
[17:41:00.264]     if (TRUE) {
[17:41:00.264]         base::sink(type = "output", split = FALSE)
[17:41:00.264]         if (TRUE) {
[17:41:00.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.264]         }
[17:41:00.264]         else {
[17:41:00.264]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.264]         }
[17:41:00.264]         base::close(...future.stdout)
[17:41:00.264]         ...future.stdout <- NULL
[17:41:00.264]     }
[17:41:00.264]     ...future.result$conditions <- ...future.conditions
[17:41:00.264]     ...future.result$finished <- base::Sys.time()
[17:41:00.264]     ...future.result
[17:41:00.264] }
[17:41:00.266] Poll #1 (0): usedNodes() = 2, workers = 2
[17:41:00.297] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[17:41:00.308] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.308] - Validating connection of MultisessionFuture
[17:41:00.308] - received message: FutureResult
[17:41:00.308] - Received FutureResult
[17:41:00.308] - Erased future from FutureRegistry
[17:41:00.308] result() for ClusterFuture ...
[17:41:00.308] - result already collected: FutureResult
[17:41:00.309] result() for ClusterFuture ... done
[17:41:00.309] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.309] result() for ClusterFuture ...
[17:41:00.309] - result already collected: FutureResult
[17:41:00.309] result() for ClusterFuture ... done
[17:41:00.309] result() for ClusterFuture ...
[17:41:00.309] - result already collected: FutureResult
[17:41:00.309] result() for ClusterFuture ... done
[17:41:00.310] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[17:41:00.310] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[17:41:00.310] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[17:41:00.310] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[17:41:00.311] MultisessionFuture started
[17:41:00.311] - Launch lazy future ... done
[17:41:00.311] run() for ‘MultisessionFuture’ ... done
[17:41:00.332] Future #1
[17:41:00.332]  length: 2 (resolved future 1)
[17:41:00.338] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.338] - Validating connection of MultisessionFuture
[17:41:00.339] - received message: FutureResult
[17:41:00.339] - Received FutureResult
[17:41:00.339] - Erased future from FutureRegistry
[17:41:00.339] result() for ClusterFuture ...
[17:41:00.339] - result already collected: FutureResult
[17:41:00.339] result() for ClusterFuture ... done
[17:41:00.339] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.339] Future #2
[17:41:00.339]  length: 1 (resolved future 2)
[17:41:00.422] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.422] - Validating connection of MultisessionFuture
[17:41:00.422] - received message: FutureResult
[17:41:00.423] - Received FutureResult
[17:41:00.423] - Erased future from FutureRegistry
[17:41:00.423] result() for ClusterFuture ...
[17:41:00.423] - result already collected: FutureResult
[17:41:00.423] result() for ClusterFuture ... done
[17:41:00.423] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.423] Future #3
[17:41:00.423]  length: 0 (resolved future 3)
[17:41:00.423] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[17:41:00.424] resolve() on environment ...
[17:41:00.424]  recursive: 0
[17:41:00.425]  elements: [2] ‘a’, ‘b’
[17:41:00.425]  length: 1 (resolved future 1)
[17:41:00.425]  length: 0 (resolved future 2)
[17:41:00.425] resolve() on environment ... DONE
[17:41:00.425] getGlobalsAndPackages() ...
[17:41:00.425] Searching for globals...
[17:41:00.426] 
[17:41:00.426] Searching for globals ... DONE
[17:41:00.426] - globals: [0] <none>
[17:41:00.426] getGlobalsAndPackages() ... DONE
[17:41:00.426] run() for ‘Future’ ...
[17:41:00.426] - state: ‘created’
[17:41:00.426] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.441]   - Field: ‘node’
[17:41:00.441]   - Field: ‘label’
[17:41:00.441]   - Field: ‘local’
[17:41:00.441]   - Field: ‘owner’
[17:41:00.441]   - Field: ‘envir’
[17:41:00.441]   - Field: ‘workers’
[17:41:00.441]   - Field: ‘packages’
[17:41:00.441]   - Field: ‘gc’
[17:41:00.441]   - Field: ‘conditions’
[17:41:00.441]   - Field: ‘persistent’
[17:41:00.442]   - Field: ‘expr’
[17:41:00.442]   - Field: ‘uuid’
[17:41:00.442]   - Field: ‘seed’
[17:41:00.442]   - Field: ‘version’
[17:41:00.442]   - Field: ‘result’
[17:41:00.442]   - Field: ‘asynchronous’
[17:41:00.442]   - Field: ‘calls’
[17:41:00.442]   - Field: ‘globals’
[17:41:00.442]   - Field: ‘stdout’
[17:41:00.442]   - Field: ‘earlySignal’
[17:41:00.442]   - Field: ‘lazy’
[17:41:00.443]   - Field: ‘state’
[17:41:00.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.443] - Launch lazy future ...
[17:41:00.443] Packages needed by the future expression (n = 0): <none>
[17:41:00.443] Packages needed by future strategies (n = 0): <none>
[17:41:00.444] {
[17:41:00.444]     {
[17:41:00.444]         {
[17:41:00.444]             ...future.startTime <- base::Sys.time()
[17:41:00.444]             {
[17:41:00.444]                 {
[17:41:00.444]                   {
[17:41:00.444]                     {
[17:41:00.444]                       base::local({
[17:41:00.444]                         has_future <- base::requireNamespace("future", 
[17:41:00.444]                           quietly = TRUE)
[17:41:00.444]                         if (has_future) {
[17:41:00.444]                           ns <- base::getNamespace("future")
[17:41:00.444]                           version <- ns[[".package"]][["version"]]
[17:41:00.444]                           if (is.null(version)) 
[17:41:00.444]                             version <- utils::packageVersion("future")
[17:41:00.444]                         }
[17:41:00.444]                         else {
[17:41:00.444]                           version <- NULL
[17:41:00.444]                         }
[17:41:00.444]                         if (!has_future || version < "1.8.0") {
[17:41:00.444]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.444]                             "", base::R.version$version.string), 
[17:41:00.444]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.444]                               "release", "version")], collapse = " "), 
[17:41:00.444]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.444]                             info)
[17:41:00.444]                           info <- base::paste(info, collapse = "; ")
[17:41:00.444]                           if (!has_future) {
[17:41:00.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.444]                               info)
[17:41:00.444]                           }
[17:41:00.444]                           else {
[17:41:00.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.444]                               info, version)
[17:41:00.444]                           }
[17:41:00.444]                           base::stop(msg)
[17:41:00.444]                         }
[17:41:00.444]                       })
[17:41:00.444]                     }
[17:41:00.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.444]                     base::options(mc.cores = 1L)
[17:41:00.444]                   }
[17:41:00.444]                   ...future.strategy.old <- future::plan("list")
[17:41:00.444]                   options(future.plan = NULL)
[17:41:00.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.444]                 }
[17:41:00.444]                 ...future.workdir <- getwd()
[17:41:00.444]             }
[17:41:00.444]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.444]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.444]         }
[17:41:00.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.444]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.444]             base::names(...future.oldOptions))
[17:41:00.444]     }
[17:41:00.444]     if (FALSE) {
[17:41:00.444]     }
[17:41:00.444]     else {
[17:41:00.444]         if (TRUE) {
[17:41:00.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.444]                 open = "w")
[17:41:00.444]         }
[17:41:00.444]         else {
[17:41:00.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.444]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.444]         }
[17:41:00.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.444]             base::sink(type = "output", split = FALSE)
[17:41:00.444]             base::close(...future.stdout)
[17:41:00.444]         }, add = TRUE)
[17:41:00.444]     }
[17:41:00.444]     ...future.frame <- base::sys.nframe()
[17:41:00.444]     ...future.conditions <- base::list()
[17:41:00.444]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.444]     if (FALSE) {
[17:41:00.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.444]     }
[17:41:00.444]     ...future.result <- base::tryCatch({
[17:41:00.444]         base::withCallingHandlers({
[17:41:00.444]             ...future.value <- base::withVisible(base::local({
[17:41:00.444]                 ...future.makeSendCondition <- base::local({
[17:41:00.444]                   sendCondition <- NULL
[17:41:00.444]                   function(frame = 1L) {
[17:41:00.444]                     if (is.function(sendCondition)) 
[17:41:00.444]                       return(sendCondition)
[17:41:00.444]                     ns <- getNamespace("parallel")
[17:41:00.444]                     if (exists("sendData", mode = "function", 
[17:41:00.444]                       envir = ns)) {
[17:41:00.444]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.444]                         envir = ns)
[17:41:00.444]                       envir <- sys.frame(frame)
[17:41:00.444]                       master <- NULL
[17:41:00.444]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.444]                         !identical(envir, emptyenv())) {
[17:41:00.444]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.444]                           inherits = FALSE)) {
[17:41:00.444]                           master <- get("master", mode = "list", 
[17:41:00.444]                             envir = envir, inherits = FALSE)
[17:41:00.444]                           if (inherits(master, c("SOCKnode", 
[17:41:00.444]                             "SOCK0node"))) {
[17:41:00.444]                             sendCondition <<- function(cond) {
[17:41:00.444]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.444]                                 success = TRUE)
[17:41:00.444]                               parallel_sendData(master, data)
[17:41:00.444]                             }
[17:41:00.444]                             return(sendCondition)
[17:41:00.444]                           }
[17:41:00.444]                         }
[17:41:00.444]                         frame <- frame + 1L
[17:41:00.444]                         envir <- sys.frame(frame)
[17:41:00.444]                       }
[17:41:00.444]                     }
[17:41:00.444]                     sendCondition <<- function(cond) NULL
[17:41:00.444]                   }
[17:41:00.444]                 })
[17:41:00.444]                 withCallingHandlers({
[17:41:00.444]                   1
[17:41:00.444]                 }, immediateCondition = function(cond) {
[17:41:00.444]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.444]                   sendCondition(cond)
[17:41:00.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.444]                   {
[17:41:00.444]                     inherits <- base::inherits
[17:41:00.444]                     invokeRestart <- base::invokeRestart
[17:41:00.444]                     is.null <- base::is.null
[17:41:00.444]                     muffled <- FALSE
[17:41:00.444]                     if (inherits(cond, "message")) {
[17:41:00.444]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.444]                       if (muffled) 
[17:41:00.444]                         invokeRestart("muffleMessage")
[17:41:00.444]                     }
[17:41:00.444]                     else if (inherits(cond, "warning")) {
[17:41:00.444]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.444]                       if (muffled) 
[17:41:00.444]                         invokeRestart("muffleWarning")
[17:41:00.444]                     }
[17:41:00.444]                     else if (inherits(cond, "condition")) {
[17:41:00.444]                       if (!is.null(pattern)) {
[17:41:00.444]                         computeRestarts <- base::computeRestarts
[17:41:00.444]                         grepl <- base::grepl
[17:41:00.444]                         restarts <- computeRestarts(cond)
[17:41:00.444]                         for (restart in restarts) {
[17:41:00.444]                           name <- restart$name
[17:41:00.444]                           if (is.null(name)) 
[17:41:00.444]                             next
[17:41:00.444]                           if (!grepl(pattern, name)) 
[17:41:00.444]                             next
[17:41:00.444]                           invokeRestart(restart)
[17:41:00.444]                           muffled <- TRUE
[17:41:00.444]                           break
[17:41:00.444]                         }
[17:41:00.444]                       }
[17:41:00.444]                     }
[17:41:00.444]                     invisible(muffled)
[17:41:00.444]                   }
[17:41:00.444]                   muffleCondition(cond)
[17:41:00.444]                 })
[17:41:00.444]             }))
[17:41:00.444]             future::FutureResult(value = ...future.value$value, 
[17:41:00.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.444]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.444]                     ...future.globalenv.names))
[17:41:00.444]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.444]         }, condition = base::local({
[17:41:00.444]             c <- base::c
[17:41:00.444]             inherits <- base::inherits
[17:41:00.444]             invokeRestart <- base::invokeRestart
[17:41:00.444]             length <- base::length
[17:41:00.444]             list <- base::list
[17:41:00.444]             seq.int <- base::seq.int
[17:41:00.444]             signalCondition <- base::signalCondition
[17:41:00.444]             sys.calls <- base::sys.calls
[17:41:00.444]             `[[` <- base::`[[`
[17:41:00.444]             `+` <- base::`+`
[17:41:00.444]             `<<-` <- base::`<<-`
[17:41:00.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.444]                   3L)]
[17:41:00.444]             }
[17:41:00.444]             function(cond) {
[17:41:00.444]                 is_error <- inherits(cond, "error")
[17:41:00.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.444]                   NULL)
[17:41:00.444]                 if (is_error) {
[17:41:00.444]                   sessionInformation <- function() {
[17:41:00.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.444]                       search = base::search(), system = base::Sys.info())
[17:41:00.444]                   }
[17:41:00.444]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.444]                     cond$call), session = sessionInformation(), 
[17:41:00.444]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.444]                   signalCondition(cond)
[17:41:00.444]                 }
[17:41:00.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.444]                 "immediateCondition"))) {
[17:41:00.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.444]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.444]                   if (TRUE && !signal) {
[17:41:00.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.444]                     {
[17:41:00.444]                       inherits <- base::inherits
[17:41:00.444]                       invokeRestart <- base::invokeRestart
[17:41:00.444]                       is.null <- base::is.null
[17:41:00.444]                       muffled <- FALSE
[17:41:00.444]                       if (inherits(cond, "message")) {
[17:41:00.444]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.444]                         if (muffled) 
[17:41:00.444]                           invokeRestart("muffleMessage")
[17:41:00.444]                       }
[17:41:00.444]                       else if (inherits(cond, "warning")) {
[17:41:00.444]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.444]                         if (muffled) 
[17:41:00.444]                           invokeRestart("muffleWarning")
[17:41:00.444]                       }
[17:41:00.444]                       else if (inherits(cond, "condition")) {
[17:41:00.444]                         if (!is.null(pattern)) {
[17:41:00.444]                           computeRestarts <- base::computeRestarts
[17:41:00.444]                           grepl <- base::grepl
[17:41:00.444]                           restarts <- computeRestarts(cond)
[17:41:00.444]                           for (restart in restarts) {
[17:41:00.444]                             name <- restart$name
[17:41:00.444]                             if (is.null(name)) 
[17:41:00.444]                               next
[17:41:00.444]                             if (!grepl(pattern, name)) 
[17:41:00.444]                               next
[17:41:00.444]                             invokeRestart(restart)
[17:41:00.444]                             muffled <- TRUE
[17:41:00.444]                             break
[17:41:00.444]                           }
[17:41:00.444]                         }
[17:41:00.444]                       }
[17:41:00.444]                       invisible(muffled)
[17:41:00.444]                     }
[17:41:00.444]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.444]                   }
[17:41:00.444]                 }
[17:41:00.444]                 else {
[17:41:00.444]                   if (TRUE) {
[17:41:00.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.444]                     {
[17:41:00.444]                       inherits <- base::inherits
[17:41:00.444]                       invokeRestart <- base::invokeRestart
[17:41:00.444]                       is.null <- base::is.null
[17:41:00.444]                       muffled <- FALSE
[17:41:00.444]                       if (inherits(cond, "message")) {
[17:41:00.444]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.444]                         if (muffled) 
[17:41:00.444]                           invokeRestart("muffleMessage")
[17:41:00.444]                       }
[17:41:00.444]                       else if (inherits(cond, "warning")) {
[17:41:00.444]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.444]                         if (muffled) 
[17:41:00.444]                           invokeRestart("muffleWarning")
[17:41:00.444]                       }
[17:41:00.444]                       else if (inherits(cond, "condition")) {
[17:41:00.444]                         if (!is.null(pattern)) {
[17:41:00.444]                           computeRestarts <- base::computeRestarts
[17:41:00.444]                           grepl <- base::grepl
[17:41:00.444]                           restarts <- computeRestarts(cond)
[17:41:00.444]                           for (restart in restarts) {
[17:41:00.444]                             name <- restart$name
[17:41:00.444]                             if (is.null(name)) 
[17:41:00.444]                               next
[17:41:00.444]                             if (!grepl(pattern, name)) 
[17:41:00.444]                               next
[17:41:00.444]                             invokeRestart(restart)
[17:41:00.444]                             muffled <- TRUE
[17:41:00.444]                             break
[17:41:00.444]                           }
[17:41:00.444]                         }
[17:41:00.444]                       }
[17:41:00.444]                       invisible(muffled)
[17:41:00.444]                     }
[17:41:00.444]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.444]                   }
[17:41:00.444]                 }
[17:41:00.444]             }
[17:41:00.444]         }))
[17:41:00.444]     }, error = function(ex) {
[17:41:00.444]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.444]                 ...future.rng), started = ...future.startTime, 
[17:41:00.444]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.444]             version = "1.8"), class = "FutureResult")
[17:41:00.444]     }, finally = {
[17:41:00.444]         if (!identical(...future.workdir, getwd())) 
[17:41:00.444]             setwd(...future.workdir)
[17:41:00.444]         {
[17:41:00.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.444]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.444]             }
[17:41:00.444]             base::options(...future.oldOptions)
[17:41:00.444]             if (.Platform$OS.type == "windows") {
[17:41:00.444]                 old_names <- names(...future.oldEnvVars)
[17:41:00.444]                 envs <- base::Sys.getenv()
[17:41:00.444]                 names <- names(envs)
[17:41:00.444]                 common <- intersect(names, old_names)
[17:41:00.444]                 added <- setdiff(names, old_names)
[17:41:00.444]                 removed <- setdiff(old_names, names)
[17:41:00.444]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.444]                   envs[common]]
[17:41:00.444]                 NAMES <- toupper(changed)
[17:41:00.444]                 args <- list()
[17:41:00.444]                 for (kk in seq_along(NAMES)) {
[17:41:00.444]                   name <- changed[[kk]]
[17:41:00.444]                   NAME <- NAMES[[kk]]
[17:41:00.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.444]                     next
[17:41:00.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.444]                 }
[17:41:00.444]                 NAMES <- toupper(added)
[17:41:00.444]                 for (kk in seq_along(NAMES)) {
[17:41:00.444]                   name <- added[[kk]]
[17:41:00.444]                   NAME <- NAMES[[kk]]
[17:41:00.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.444]                     next
[17:41:00.444]                   args[[name]] <- ""
[17:41:00.444]                 }
[17:41:00.444]                 NAMES <- toupper(removed)
[17:41:00.444]                 for (kk in seq_along(NAMES)) {
[17:41:00.444]                   name <- removed[[kk]]
[17:41:00.444]                   NAME <- NAMES[[kk]]
[17:41:00.444]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.444]                     next
[17:41:00.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.444]                 }
[17:41:00.444]                 if (length(args) > 0) 
[17:41:00.444]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.444]             }
[17:41:00.444]             else {
[17:41:00.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.444]             }
[17:41:00.444]             {
[17:41:00.444]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.444]                   0L) {
[17:41:00.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.444]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.444]                   base::options(opts)
[17:41:00.444]                 }
[17:41:00.444]                 {
[17:41:00.444]                   {
[17:41:00.444]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.444]                     NULL
[17:41:00.444]                   }
[17:41:00.444]                   options(future.plan = NULL)
[17:41:00.444]                   if (is.na(NA_character_)) 
[17:41:00.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.444]                     .init = FALSE)
[17:41:00.444]                 }
[17:41:00.444]             }
[17:41:00.444]         }
[17:41:00.444]     })
[17:41:00.444]     if (TRUE) {
[17:41:00.444]         base::sink(type = "output", split = FALSE)
[17:41:00.444]         if (TRUE) {
[17:41:00.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.444]         }
[17:41:00.444]         else {
[17:41:00.444]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.444]         }
[17:41:00.444]         base::close(...future.stdout)
[17:41:00.444]         ...future.stdout <- NULL
[17:41:00.444]     }
[17:41:00.444]     ...future.result$conditions <- ...future.conditions
[17:41:00.444]     ...future.result$finished <- base::Sys.time()
[17:41:00.444]     ...future.result
[17:41:00.444] }
[17:41:00.447] MultisessionFuture started
[17:41:00.447] - Launch lazy future ... done
[17:41:00.447] run() for ‘MultisessionFuture’ ... done
[17:41:00.447] getGlobalsAndPackages() ...
[17:41:00.447] Searching for globals...
[17:41:00.447] 
[17:41:00.447] Searching for globals ... DONE
[17:41:00.447] - globals: [0] <none>
[17:41:00.448] getGlobalsAndPackages() ... DONE
[17:41:00.448] run() for ‘Future’ ...
[17:41:00.448] - state: ‘created’
[17:41:00.448] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.462]   - Field: ‘node’
[17:41:00.462]   - Field: ‘label’
[17:41:00.462]   - Field: ‘local’
[17:41:00.462]   - Field: ‘owner’
[17:41:00.462]   - Field: ‘envir’
[17:41:00.462]   - Field: ‘workers’
[17:41:00.462]   - Field: ‘packages’
[17:41:00.462]   - Field: ‘gc’
[17:41:00.462]   - Field: ‘conditions’
[17:41:00.462]   - Field: ‘persistent’
[17:41:00.462]   - Field: ‘expr’
[17:41:00.463]   - Field: ‘uuid’
[17:41:00.463]   - Field: ‘seed’
[17:41:00.463]   - Field: ‘version’
[17:41:00.463]   - Field: ‘result’
[17:41:00.463]   - Field: ‘asynchronous’
[17:41:00.463]   - Field: ‘calls’
[17:41:00.463]   - Field: ‘globals’
[17:41:00.463]   - Field: ‘stdout’
[17:41:00.463]   - Field: ‘earlySignal’
[17:41:00.463]   - Field: ‘lazy’
[17:41:00.463]   - Field: ‘state’
[17:41:00.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.464] - Launch lazy future ...
[17:41:00.464] Packages needed by the future expression (n = 0): <none>
[17:41:00.464] Packages needed by future strategies (n = 0): <none>
[17:41:00.464] {
[17:41:00.464]     {
[17:41:00.464]         {
[17:41:00.464]             ...future.startTime <- base::Sys.time()
[17:41:00.464]             {
[17:41:00.464]                 {
[17:41:00.464]                   {
[17:41:00.464]                     {
[17:41:00.464]                       base::local({
[17:41:00.464]                         has_future <- base::requireNamespace("future", 
[17:41:00.464]                           quietly = TRUE)
[17:41:00.464]                         if (has_future) {
[17:41:00.464]                           ns <- base::getNamespace("future")
[17:41:00.464]                           version <- ns[[".package"]][["version"]]
[17:41:00.464]                           if (is.null(version)) 
[17:41:00.464]                             version <- utils::packageVersion("future")
[17:41:00.464]                         }
[17:41:00.464]                         else {
[17:41:00.464]                           version <- NULL
[17:41:00.464]                         }
[17:41:00.464]                         if (!has_future || version < "1.8.0") {
[17:41:00.464]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.464]                             "", base::R.version$version.string), 
[17:41:00.464]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.464]                               "release", "version")], collapse = " "), 
[17:41:00.464]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.464]                             info)
[17:41:00.464]                           info <- base::paste(info, collapse = "; ")
[17:41:00.464]                           if (!has_future) {
[17:41:00.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.464]                               info)
[17:41:00.464]                           }
[17:41:00.464]                           else {
[17:41:00.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.464]                               info, version)
[17:41:00.464]                           }
[17:41:00.464]                           base::stop(msg)
[17:41:00.464]                         }
[17:41:00.464]                       })
[17:41:00.464]                     }
[17:41:00.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.464]                     base::options(mc.cores = 1L)
[17:41:00.464]                   }
[17:41:00.464]                   ...future.strategy.old <- future::plan("list")
[17:41:00.464]                   options(future.plan = NULL)
[17:41:00.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.464]                 }
[17:41:00.464]                 ...future.workdir <- getwd()
[17:41:00.464]             }
[17:41:00.464]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.464]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.464]         }
[17:41:00.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.464]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.464]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.464]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.464]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.464]             base::names(...future.oldOptions))
[17:41:00.464]     }
[17:41:00.464]     if (FALSE) {
[17:41:00.464]     }
[17:41:00.464]     else {
[17:41:00.464]         if (TRUE) {
[17:41:00.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.464]                 open = "w")
[17:41:00.464]         }
[17:41:00.464]         else {
[17:41:00.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.464]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.464]         }
[17:41:00.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.464]             base::sink(type = "output", split = FALSE)
[17:41:00.464]             base::close(...future.stdout)
[17:41:00.464]         }, add = TRUE)
[17:41:00.464]     }
[17:41:00.464]     ...future.frame <- base::sys.nframe()
[17:41:00.464]     ...future.conditions <- base::list()
[17:41:00.464]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.464]     if (FALSE) {
[17:41:00.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.464]     }
[17:41:00.464]     ...future.result <- base::tryCatch({
[17:41:00.464]         base::withCallingHandlers({
[17:41:00.464]             ...future.value <- base::withVisible(base::local({
[17:41:00.464]                 ...future.makeSendCondition <- base::local({
[17:41:00.464]                   sendCondition <- NULL
[17:41:00.464]                   function(frame = 1L) {
[17:41:00.464]                     if (is.function(sendCondition)) 
[17:41:00.464]                       return(sendCondition)
[17:41:00.464]                     ns <- getNamespace("parallel")
[17:41:00.464]                     if (exists("sendData", mode = "function", 
[17:41:00.464]                       envir = ns)) {
[17:41:00.464]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.464]                         envir = ns)
[17:41:00.464]                       envir <- sys.frame(frame)
[17:41:00.464]                       master <- NULL
[17:41:00.464]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.464]                         !identical(envir, emptyenv())) {
[17:41:00.464]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.464]                           inherits = FALSE)) {
[17:41:00.464]                           master <- get("master", mode = "list", 
[17:41:00.464]                             envir = envir, inherits = FALSE)
[17:41:00.464]                           if (inherits(master, c("SOCKnode", 
[17:41:00.464]                             "SOCK0node"))) {
[17:41:00.464]                             sendCondition <<- function(cond) {
[17:41:00.464]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.464]                                 success = TRUE)
[17:41:00.464]                               parallel_sendData(master, data)
[17:41:00.464]                             }
[17:41:00.464]                             return(sendCondition)
[17:41:00.464]                           }
[17:41:00.464]                         }
[17:41:00.464]                         frame <- frame + 1L
[17:41:00.464]                         envir <- sys.frame(frame)
[17:41:00.464]                       }
[17:41:00.464]                     }
[17:41:00.464]                     sendCondition <<- function(cond) NULL
[17:41:00.464]                   }
[17:41:00.464]                 })
[17:41:00.464]                 withCallingHandlers({
[17:41:00.464]                   2
[17:41:00.464]                 }, immediateCondition = function(cond) {
[17:41:00.464]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.464]                   sendCondition(cond)
[17:41:00.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.464]                   {
[17:41:00.464]                     inherits <- base::inherits
[17:41:00.464]                     invokeRestart <- base::invokeRestart
[17:41:00.464]                     is.null <- base::is.null
[17:41:00.464]                     muffled <- FALSE
[17:41:00.464]                     if (inherits(cond, "message")) {
[17:41:00.464]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.464]                       if (muffled) 
[17:41:00.464]                         invokeRestart("muffleMessage")
[17:41:00.464]                     }
[17:41:00.464]                     else if (inherits(cond, "warning")) {
[17:41:00.464]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.464]                       if (muffled) 
[17:41:00.464]                         invokeRestart("muffleWarning")
[17:41:00.464]                     }
[17:41:00.464]                     else if (inherits(cond, "condition")) {
[17:41:00.464]                       if (!is.null(pattern)) {
[17:41:00.464]                         computeRestarts <- base::computeRestarts
[17:41:00.464]                         grepl <- base::grepl
[17:41:00.464]                         restarts <- computeRestarts(cond)
[17:41:00.464]                         for (restart in restarts) {
[17:41:00.464]                           name <- restart$name
[17:41:00.464]                           if (is.null(name)) 
[17:41:00.464]                             next
[17:41:00.464]                           if (!grepl(pattern, name)) 
[17:41:00.464]                             next
[17:41:00.464]                           invokeRestart(restart)
[17:41:00.464]                           muffled <- TRUE
[17:41:00.464]                           break
[17:41:00.464]                         }
[17:41:00.464]                       }
[17:41:00.464]                     }
[17:41:00.464]                     invisible(muffled)
[17:41:00.464]                   }
[17:41:00.464]                   muffleCondition(cond)
[17:41:00.464]                 })
[17:41:00.464]             }))
[17:41:00.464]             future::FutureResult(value = ...future.value$value, 
[17:41:00.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.464]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.464]                     ...future.globalenv.names))
[17:41:00.464]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.464]         }, condition = base::local({
[17:41:00.464]             c <- base::c
[17:41:00.464]             inherits <- base::inherits
[17:41:00.464]             invokeRestart <- base::invokeRestart
[17:41:00.464]             length <- base::length
[17:41:00.464]             list <- base::list
[17:41:00.464]             seq.int <- base::seq.int
[17:41:00.464]             signalCondition <- base::signalCondition
[17:41:00.464]             sys.calls <- base::sys.calls
[17:41:00.464]             `[[` <- base::`[[`
[17:41:00.464]             `+` <- base::`+`
[17:41:00.464]             `<<-` <- base::`<<-`
[17:41:00.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.464]                   3L)]
[17:41:00.464]             }
[17:41:00.464]             function(cond) {
[17:41:00.464]                 is_error <- inherits(cond, "error")
[17:41:00.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.464]                   NULL)
[17:41:00.464]                 if (is_error) {
[17:41:00.464]                   sessionInformation <- function() {
[17:41:00.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.464]                       search = base::search(), system = base::Sys.info())
[17:41:00.464]                   }
[17:41:00.464]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.464]                     cond$call), session = sessionInformation(), 
[17:41:00.464]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.464]                   signalCondition(cond)
[17:41:00.464]                 }
[17:41:00.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.464]                 "immediateCondition"))) {
[17:41:00.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.464]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.464]                   if (TRUE && !signal) {
[17:41:00.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.464]                     {
[17:41:00.464]                       inherits <- base::inherits
[17:41:00.464]                       invokeRestart <- base::invokeRestart
[17:41:00.464]                       is.null <- base::is.null
[17:41:00.464]                       muffled <- FALSE
[17:41:00.464]                       if (inherits(cond, "message")) {
[17:41:00.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.464]                         if (muffled) 
[17:41:00.464]                           invokeRestart("muffleMessage")
[17:41:00.464]                       }
[17:41:00.464]                       else if (inherits(cond, "warning")) {
[17:41:00.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.464]                         if (muffled) 
[17:41:00.464]                           invokeRestart("muffleWarning")
[17:41:00.464]                       }
[17:41:00.464]                       else if (inherits(cond, "condition")) {
[17:41:00.464]                         if (!is.null(pattern)) {
[17:41:00.464]                           computeRestarts <- base::computeRestarts
[17:41:00.464]                           grepl <- base::grepl
[17:41:00.464]                           restarts <- computeRestarts(cond)
[17:41:00.464]                           for (restart in restarts) {
[17:41:00.464]                             name <- restart$name
[17:41:00.464]                             if (is.null(name)) 
[17:41:00.464]                               next
[17:41:00.464]                             if (!grepl(pattern, name)) 
[17:41:00.464]                               next
[17:41:00.464]                             invokeRestart(restart)
[17:41:00.464]                             muffled <- TRUE
[17:41:00.464]                             break
[17:41:00.464]                           }
[17:41:00.464]                         }
[17:41:00.464]                       }
[17:41:00.464]                       invisible(muffled)
[17:41:00.464]                     }
[17:41:00.464]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.464]                   }
[17:41:00.464]                 }
[17:41:00.464]                 else {
[17:41:00.464]                   if (TRUE) {
[17:41:00.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.464]                     {
[17:41:00.464]                       inherits <- base::inherits
[17:41:00.464]                       invokeRestart <- base::invokeRestart
[17:41:00.464]                       is.null <- base::is.null
[17:41:00.464]                       muffled <- FALSE
[17:41:00.464]                       if (inherits(cond, "message")) {
[17:41:00.464]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.464]                         if (muffled) 
[17:41:00.464]                           invokeRestart("muffleMessage")
[17:41:00.464]                       }
[17:41:00.464]                       else if (inherits(cond, "warning")) {
[17:41:00.464]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.464]                         if (muffled) 
[17:41:00.464]                           invokeRestart("muffleWarning")
[17:41:00.464]                       }
[17:41:00.464]                       else if (inherits(cond, "condition")) {
[17:41:00.464]                         if (!is.null(pattern)) {
[17:41:00.464]                           computeRestarts <- base::computeRestarts
[17:41:00.464]                           grepl <- base::grepl
[17:41:00.464]                           restarts <- computeRestarts(cond)
[17:41:00.464]                           for (restart in restarts) {
[17:41:00.464]                             name <- restart$name
[17:41:00.464]                             if (is.null(name)) 
[17:41:00.464]                               next
[17:41:00.464]                             if (!grepl(pattern, name)) 
[17:41:00.464]                               next
[17:41:00.464]                             invokeRestart(restart)
[17:41:00.464]                             muffled <- TRUE
[17:41:00.464]                             break
[17:41:00.464]                           }
[17:41:00.464]                         }
[17:41:00.464]                       }
[17:41:00.464]                       invisible(muffled)
[17:41:00.464]                     }
[17:41:00.464]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.464]                   }
[17:41:00.464]                 }
[17:41:00.464]             }
[17:41:00.464]         }))
[17:41:00.464]     }, error = function(ex) {
[17:41:00.464]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.464]                 ...future.rng), started = ...future.startTime, 
[17:41:00.464]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.464]             version = "1.8"), class = "FutureResult")
[17:41:00.464]     }, finally = {
[17:41:00.464]         if (!identical(...future.workdir, getwd())) 
[17:41:00.464]             setwd(...future.workdir)
[17:41:00.464]         {
[17:41:00.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.464]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.464]             }
[17:41:00.464]             base::options(...future.oldOptions)
[17:41:00.464]             if (.Platform$OS.type == "windows") {
[17:41:00.464]                 old_names <- names(...future.oldEnvVars)
[17:41:00.464]                 envs <- base::Sys.getenv()
[17:41:00.464]                 names <- names(envs)
[17:41:00.464]                 common <- intersect(names, old_names)
[17:41:00.464]                 added <- setdiff(names, old_names)
[17:41:00.464]                 removed <- setdiff(old_names, names)
[17:41:00.464]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.464]                   envs[common]]
[17:41:00.464]                 NAMES <- toupper(changed)
[17:41:00.464]                 args <- list()
[17:41:00.464]                 for (kk in seq_along(NAMES)) {
[17:41:00.464]                   name <- changed[[kk]]
[17:41:00.464]                   NAME <- NAMES[[kk]]
[17:41:00.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.464]                     next
[17:41:00.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.464]                 }
[17:41:00.464]                 NAMES <- toupper(added)
[17:41:00.464]                 for (kk in seq_along(NAMES)) {
[17:41:00.464]                   name <- added[[kk]]
[17:41:00.464]                   NAME <- NAMES[[kk]]
[17:41:00.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.464]                     next
[17:41:00.464]                   args[[name]] <- ""
[17:41:00.464]                 }
[17:41:00.464]                 NAMES <- toupper(removed)
[17:41:00.464]                 for (kk in seq_along(NAMES)) {
[17:41:00.464]                   name <- removed[[kk]]
[17:41:00.464]                   NAME <- NAMES[[kk]]
[17:41:00.464]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.464]                     next
[17:41:00.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.464]                 }
[17:41:00.464]                 if (length(args) > 0) 
[17:41:00.464]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.464]             }
[17:41:00.464]             else {
[17:41:00.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.464]             }
[17:41:00.464]             {
[17:41:00.464]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.464]                   0L) {
[17:41:00.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.464]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.464]                   base::options(opts)
[17:41:00.464]                 }
[17:41:00.464]                 {
[17:41:00.464]                   {
[17:41:00.464]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.464]                     NULL
[17:41:00.464]                   }
[17:41:00.464]                   options(future.plan = NULL)
[17:41:00.464]                   if (is.na(NA_character_)) 
[17:41:00.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.464]                     .init = FALSE)
[17:41:00.464]                 }
[17:41:00.464]             }
[17:41:00.464]         }
[17:41:00.464]     })
[17:41:00.464]     if (TRUE) {
[17:41:00.464]         base::sink(type = "output", split = FALSE)
[17:41:00.464]         if (TRUE) {
[17:41:00.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.464]         }
[17:41:00.464]         else {
[17:41:00.464]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.464]         }
[17:41:00.464]         base::close(...future.stdout)
[17:41:00.464]         ...future.stdout <- NULL
[17:41:00.464]     }
[17:41:00.464]     ...future.result$conditions <- ...future.conditions
[17:41:00.464]     ...future.result$finished <- base::Sys.time()
[17:41:00.464]     ...future.result
[17:41:00.464] }
[17:41:00.467] MultisessionFuture started
[17:41:00.467] - Launch lazy future ... done
[17:41:00.468] run() for ‘MultisessionFuture’ ... done
[17:41:00.468] resolve() on environment ...
[17:41:00.468]  recursive: 0
[17:41:00.469]  elements: [3] ‘a’, ‘b’, ‘c’
[17:41:00.469] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.469] - Validating connection of MultisessionFuture
[17:41:00.469] - received message: FutureResult
[17:41:00.470] - Received FutureResult
[17:41:00.470] - Erased future from FutureRegistry
[17:41:00.470] result() for ClusterFuture ...
[17:41:00.470] - result already collected: FutureResult
[17:41:00.470] result() for ClusterFuture ... done
[17:41:00.470] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.470] Future #1
[17:41:00.470]  length: 2 (resolved future 1)
[17:41:00.471] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.471] - Validating connection of MultisessionFuture
[17:41:00.471] - received message: FutureResult
[17:41:00.471] - Received FutureResult
[17:41:00.471] - Erased future from FutureRegistry
[17:41:00.471] result() for ClusterFuture ...
[17:41:00.471] - result already collected: FutureResult
[17:41:00.471] result() for ClusterFuture ... done
[17:41:00.472] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.472] Future #2
[17:41:00.472]  length: 1 (resolved future 2)
[17:41:00.472]  length: 0 (resolved future 3)
[17:41:00.472] resolve() on environment ... DONE
[17:41:00.473] getGlobalsAndPackages() ...
[17:41:00.473] Searching for globals...
[17:41:00.473] - globals found: [1] ‘{’
[17:41:00.473] Searching for globals ... DONE
[17:41:00.473] Resolving globals: FALSE
[17:41:00.474] 
[17:41:00.474] 
[17:41:00.474] getGlobalsAndPackages() ... DONE
[17:41:00.474] run() for ‘Future’ ...
[17:41:00.474] - state: ‘created’
[17:41:00.474] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.488] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.488]   - Field: ‘node’
[17:41:00.488]   - Field: ‘label’
[17:41:00.488]   - Field: ‘local’
[17:41:00.488]   - Field: ‘owner’
[17:41:00.488]   - Field: ‘envir’
[17:41:00.489]   - Field: ‘workers’
[17:41:00.489]   - Field: ‘packages’
[17:41:00.489]   - Field: ‘gc’
[17:41:00.489]   - Field: ‘conditions’
[17:41:00.489]   - Field: ‘persistent’
[17:41:00.489]   - Field: ‘expr’
[17:41:00.489]   - Field: ‘uuid’
[17:41:00.489]   - Field: ‘seed’
[17:41:00.489]   - Field: ‘version’
[17:41:00.489]   - Field: ‘result’
[17:41:00.489]   - Field: ‘asynchronous’
[17:41:00.490]   - Field: ‘calls’
[17:41:00.490]   - Field: ‘globals’
[17:41:00.490]   - Field: ‘stdout’
[17:41:00.490]   - Field: ‘earlySignal’
[17:41:00.490]   - Field: ‘lazy’
[17:41:00.490]   - Field: ‘state’
[17:41:00.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.490] - Launch lazy future ...
[17:41:00.491] Packages needed by the future expression (n = 0): <none>
[17:41:00.491] Packages needed by future strategies (n = 0): <none>
[17:41:00.491] {
[17:41:00.491]     {
[17:41:00.491]         {
[17:41:00.491]             ...future.startTime <- base::Sys.time()
[17:41:00.491]             {
[17:41:00.491]                 {
[17:41:00.491]                   {
[17:41:00.491]                     {
[17:41:00.491]                       base::local({
[17:41:00.491]                         has_future <- base::requireNamespace("future", 
[17:41:00.491]                           quietly = TRUE)
[17:41:00.491]                         if (has_future) {
[17:41:00.491]                           ns <- base::getNamespace("future")
[17:41:00.491]                           version <- ns[[".package"]][["version"]]
[17:41:00.491]                           if (is.null(version)) 
[17:41:00.491]                             version <- utils::packageVersion("future")
[17:41:00.491]                         }
[17:41:00.491]                         else {
[17:41:00.491]                           version <- NULL
[17:41:00.491]                         }
[17:41:00.491]                         if (!has_future || version < "1.8.0") {
[17:41:00.491]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.491]                             "", base::R.version$version.string), 
[17:41:00.491]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.491]                               "release", "version")], collapse = " "), 
[17:41:00.491]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.491]                             info)
[17:41:00.491]                           info <- base::paste(info, collapse = "; ")
[17:41:00.491]                           if (!has_future) {
[17:41:00.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.491]                               info)
[17:41:00.491]                           }
[17:41:00.491]                           else {
[17:41:00.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.491]                               info, version)
[17:41:00.491]                           }
[17:41:00.491]                           base::stop(msg)
[17:41:00.491]                         }
[17:41:00.491]                       })
[17:41:00.491]                     }
[17:41:00.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.491]                     base::options(mc.cores = 1L)
[17:41:00.491]                   }
[17:41:00.491]                   ...future.strategy.old <- future::plan("list")
[17:41:00.491]                   options(future.plan = NULL)
[17:41:00.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.491]                 }
[17:41:00.491]                 ...future.workdir <- getwd()
[17:41:00.491]             }
[17:41:00.491]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.491]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.491]         }
[17:41:00.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.491]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.491]             base::names(...future.oldOptions))
[17:41:00.491]     }
[17:41:00.491]     if (FALSE) {
[17:41:00.491]     }
[17:41:00.491]     else {
[17:41:00.491]         if (TRUE) {
[17:41:00.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.491]                 open = "w")
[17:41:00.491]         }
[17:41:00.491]         else {
[17:41:00.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.491]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.491]         }
[17:41:00.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.491]             base::sink(type = "output", split = FALSE)
[17:41:00.491]             base::close(...future.stdout)
[17:41:00.491]         }, add = TRUE)
[17:41:00.491]     }
[17:41:00.491]     ...future.frame <- base::sys.nframe()
[17:41:00.491]     ...future.conditions <- base::list()
[17:41:00.491]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.491]     if (FALSE) {
[17:41:00.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.491]     }
[17:41:00.491]     ...future.result <- base::tryCatch({
[17:41:00.491]         base::withCallingHandlers({
[17:41:00.491]             ...future.value <- base::withVisible(base::local({
[17:41:00.491]                 ...future.makeSendCondition <- base::local({
[17:41:00.491]                   sendCondition <- NULL
[17:41:00.491]                   function(frame = 1L) {
[17:41:00.491]                     if (is.function(sendCondition)) 
[17:41:00.491]                       return(sendCondition)
[17:41:00.491]                     ns <- getNamespace("parallel")
[17:41:00.491]                     if (exists("sendData", mode = "function", 
[17:41:00.491]                       envir = ns)) {
[17:41:00.491]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.491]                         envir = ns)
[17:41:00.491]                       envir <- sys.frame(frame)
[17:41:00.491]                       master <- NULL
[17:41:00.491]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.491]                         !identical(envir, emptyenv())) {
[17:41:00.491]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.491]                           inherits = FALSE)) {
[17:41:00.491]                           master <- get("master", mode = "list", 
[17:41:00.491]                             envir = envir, inherits = FALSE)
[17:41:00.491]                           if (inherits(master, c("SOCKnode", 
[17:41:00.491]                             "SOCK0node"))) {
[17:41:00.491]                             sendCondition <<- function(cond) {
[17:41:00.491]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.491]                                 success = TRUE)
[17:41:00.491]                               parallel_sendData(master, data)
[17:41:00.491]                             }
[17:41:00.491]                             return(sendCondition)
[17:41:00.491]                           }
[17:41:00.491]                         }
[17:41:00.491]                         frame <- frame + 1L
[17:41:00.491]                         envir <- sys.frame(frame)
[17:41:00.491]                       }
[17:41:00.491]                     }
[17:41:00.491]                     sendCondition <<- function(cond) NULL
[17:41:00.491]                   }
[17:41:00.491]                 })
[17:41:00.491]                 withCallingHandlers({
[17:41:00.491]                   {
[17:41:00.491]                     1
[17:41:00.491]                   }
[17:41:00.491]                 }, immediateCondition = function(cond) {
[17:41:00.491]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.491]                   sendCondition(cond)
[17:41:00.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.491]                   {
[17:41:00.491]                     inherits <- base::inherits
[17:41:00.491]                     invokeRestart <- base::invokeRestart
[17:41:00.491]                     is.null <- base::is.null
[17:41:00.491]                     muffled <- FALSE
[17:41:00.491]                     if (inherits(cond, "message")) {
[17:41:00.491]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.491]                       if (muffled) 
[17:41:00.491]                         invokeRestart("muffleMessage")
[17:41:00.491]                     }
[17:41:00.491]                     else if (inherits(cond, "warning")) {
[17:41:00.491]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.491]                       if (muffled) 
[17:41:00.491]                         invokeRestart("muffleWarning")
[17:41:00.491]                     }
[17:41:00.491]                     else if (inherits(cond, "condition")) {
[17:41:00.491]                       if (!is.null(pattern)) {
[17:41:00.491]                         computeRestarts <- base::computeRestarts
[17:41:00.491]                         grepl <- base::grepl
[17:41:00.491]                         restarts <- computeRestarts(cond)
[17:41:00.491]                         for (restart in restarts) {
[17:41:00.491]                           name <- restart$name
[17:41:00.491]                           if (is.null(name)) 
[17:41:00.491]                             next
[17:41:00.491]                           if (!grepl(pattern, name)) 
[17:41:00.491]                             next
[17:41:00.491]                           invokeRestart(restart)
[17:41:00.491]                           muffled <- TRUE
[17:41:00.491]                           break
[17:41:00.491]                         }
[17:41:00.491]                       }
[17:41:00.491]                     }
[17:41:00.491]                     invisible(muffled)
[17:41:00.491]                   }
[17:41:00.491]                   muffleCondition(cond)
[17:41:00.491]                 })
[17:41:00.491]             }))
[17:41:00.491]             future::FutureResult(value = ...future.value$value, 
[17:41:00.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.491]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.491]                     ...future.globalenv.names))
[17:41:00.491]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.491]         }, condition = base::local({
[17:41:00.491]             c <- base::c
[17:41:00.491]             inherits <- base::inherits
[17:41:00.491]             invokeRestart <- base::invokeRestart
[17:41:00.491]             length <- base::length
[17:41:00.491]             list <- base::list
[17:41:00.491]             seq.int <- base::seq.int
[17:41:00.491]             signalCondition <- base::signalCondition
[17:41:00.491]             sys.calls <- base::sys.calls
[17:41:00.491]             `[[` <- base::`[[`
[17:41:00.491]             `+` <- base::`+`
[17:41:00.491]             `<<-` <- base::`<<-`
[17:41:00.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.491]                   3L)]
[17:41:00.491]             }
[17:41:00.491]             function(cond) {
[17:41:00.491]                 is_error <- inherits(cond, "error")
[17:41:00.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.491]                   NULL)
[17:41:00.491]                 if (is_error) {
[17:41:00.491]                   sessionInformation <- function() {
[17:41:00.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.491]                       search = base::search(), system = base::Sys.info())
[17:41:00.491]                   }
[17:41:00.491]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.491]                     cond$call), session = sessionInformation(), 
[17:41:00.491]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.491]                   signalCondition(cond)
[17:41:00.491]                 }
[17:41:00.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.491]                 "immediateCondition"))) {
[17:41:00.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.491]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.491]                   if (TRUE && !signal) {
[17:41:00.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.491]                     {
[17:41:00.491]                       inherits <- base::inherits
[17:41:00.491]                       invokeRestart <- base::invokeRestart
[17:41:00.491]                       is.null <- base::is.null
[17:41:00.491]                       muffled <- FALSE
[17:41:00.491]                       if (inherits(cond, "message")) {
[17:41:00.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.491]                         if (muffled) 
[17:41:00.491]                           invokeRestart("muffleMessage")
[17:41:00.491]                       }
[17:41:00.491]                       else if (inherits(cond, "warning")) {
[17:41:00.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.491]                         if (muffled) 
[17:41:00.491]                           invokeRestart("muffleWarning")
[17:41:00.491]                       }
[17:41:00.491]                       else if (inherits(cond, "condition")) {
[17:41:00.491]                         if (!is.null(pattern)) {
[17:41:00.491]                           computeRestarts <- base::computeRestarts
[17:41:00.491]                           grepl <- base::grepl
[17:41:00.491]                           restarts <- computeRestarts(cond)
[17:41:00.491]                           for (restart in restarts) {
[17:41:00.491]                             name <- restart$name
[17:41:00.491]                             if (is.null(name)) 
[17:41:00.491]                               next
[17:41:00.491]                             if (!grepl(pattern, name)) 
[17:41:00.491]                               next
[17:41:00.491]                             invokeRestart(restart)
[17:41:00.491]                             muffled <- TRUE
[17:41:00.491]                             break
[17:41:00.491]                           }
[17:41:00.491]                         }
[17:41:00.491]                       }
[17:41:00.491]                       invisible(muffled)
[17:41:00.491]                     }
[17:41:00.491]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.491]                   }
[17:41:00.491]                 }
[17:41:00.491]                 else {
[17:41:00.491]                   if (TRUE) {
[17:41:00.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.491]                     {
[17:41:00.491]                       inherits <- base::inherits
[17:41:00.491]                       invokeRestart <- base::invokeRestart
[17:41:00.491]                       is.null <- base::is.null
[17:41:00.491]                       muffled <- FALSE
[17:41:00.491]                       if (inherits(cond, "message")) {
[17:41:00.491]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.491]                         if (muffled) 
[17:41:00.491]                           invokeRestart("muffleMessage")
[17:41:00.491]                       }
[17:41:00.491]                       else if (inherits(cond, "warning")) {
[17:41:00.491]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.491]                         if (muffled) 
[17:41:00.491]                           invokeRestart("muffleWarning")
[17:41:00.491]                       }
[17:41:00.491]                       else if (inherits(cond, "condition")) {
[17:41:00.491]                         if (!is.null(pattern)) {
[17:41:00.491]                           computeRestarts <- base::computeRestarts
[17:41:00.491]                           grepl <- base::grepl
[17:41:00.491]                           restarts <- computeRestarts(cond)
[17:41:00.491]                           for (restart in restarts) {
[17:41:00.491]                             name <- restart$name
[17:41:00.491]                             if (is.null(name)) 
[17:41:00.491]                               next
[17:41:00.491]                             if (!grepl(pattern, name)) 
[17:41:00.491]                               next
[17:41:00.491]                             invokeRestart(restart)
[17:41:00.491]                             muffled <- TRUE
[17:41:00.491]                             break
[17:41:00.491]                           }
[17:41:00.491]                         }
[17:41:00.491]                       }
[17:41:00.491]                       invisible(muffled)
[17:41:00.491]                     }
[17:41:00.491]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.491]                   }
[17:41:00.491]                 }
[17:41:00.491]             }
[17:41:00.491]         }))
[17:41:00.491]     }, error = function(ex) {
[17:41:00.491]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.491]                 ...future.rng), started = ...future.startTime, 
[17:41:00.491]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.491]             version = "1.8"), class = "FutureResult")
[17:41:00.491]     }, finally = {
[17:41:00.491]         if (!identical(...future.workdir, getwd())) 
[17:41:00.491]             setwd(...future.workdir)
[17:41:00.491]         {
[17:41:00.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.491]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.491]             }
[17:41:00.491]             base::options(...future.oldOptions)
[17:41:00.491]             if (.Platform$OS.type == "windows") {
[17:41:00.491]                 old_names <- names(...future.oldEnvVars)
[17:41:00.491]                 envs <- base::Sys.getenv()
[17:41:00.491]                 names <- names(envs)
[17:41:00.491]                 common <- intersect(names, old_names)
[17:41:00.491]                 added <- setdiff(names, old_names)
[17:41:00.491]                 removed <- setdiff(old_names, names)
[17:41:00.491]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.491]                   envs[common]]
[17:41:00.491]                 NAMES <- toupper(changed)
[17:41:00.491]                 args <- list()
[17:41:00.491]                 for (kk in seq_along(NAMES)) {
[17:41:00.491]                   name <- changed[[kk]]
[17:41:00.491]                   NAME <- NAMES[[kk]]
[17:41:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.491]                     next
[17:41:00.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.491]                 }
[17:41:00.491]                 NAMES <- toupper(added)
[17:41:00.491]                 for (kk in seq_along(NAMES)) {
[17:41:00.491]                   name <- added[[kk]]
[17:41:00.491]                   NAME <- NAMES[[kk]]
[17:41:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.491]                     next
[17:41:00.491]                   args[[name]] <- ""
[17:41:00.491]                 }
[17:41:00.491]                 NAMES <- toupper(removed)
[17:41:00.491]                 for (kk in seq_along(NAMES)) {
[17:41:00.491]                   name <- removed[[kk]]
[17:41:00.491]                   NAME <- NAMES[[kk]]
[17:41:00.491]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.491]                     next
[17:41:00.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.491]                 }
[17:41:00.491]                 if (length(args) > 0) 
[17:41:00.491]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.491]             }
[17:41:00.491]             else {
[17:41:00.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.491]             }
[17:41:00.491]             {
[17:41:00.491]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.491]                   0L) {
[17:41:00.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.491]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.491]                   base::options(opts)
[17:41:00.491]                 }
[17:41:00.491]                 {
[17:41:00.491]                   {
[17:41:00.491]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.491]                     NULL
[17:41:00.491]                   }
[17:41:00.491]                   options(future.plan = NULL)
[17:41:00.491]                   if (is.na(NA_character_)) 
[17:41:00.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.491]                     .init = FALSE)
[17:41:00.491]                 }
[17:41:00.491]             }
[17:41:00.491]         }
[17:41:00.491]     })
[17:41:00.491]     if (TRUE) {
[17:41:00.491]         base::sink(type = "output", split = FALSE)
[17:41:00.491]         if (TRUE) {
[17:41:00.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.491]         }
[17:41:00.491]         else {
[17:41:00.491]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.491]         }
[17:41:00.491]         base::close(...future.stdout)
[17:41:00.491]         ...future.stdout <- NULL
[17:41:00.491]     }
[17:41:00.491]     ...future.result$conditions <- ...future.conditions
[17:41:00.491]     ...future.result$finished <- base::Sys.time()
[17:41:00.491]     ...future.result
[17:41:00.491] }
[17:41:00.494] MultisessionFuture started
[17:41:00.494] - Launch lazy future ... done
[17:41:00.494] run() for ‘MultisessionFuture’ ... done
[17:41:00.495] getGlobalsAndPackages() ...
[17:41:00.495] Searching for globals...
[17:41:00.496] - globals found: [1] ‘{’
[17:41:00.496] Searching for globals ... DONE
[17:41:00.496] Resolving globals: FALSE
[17:41:00.496] 
[17:41:00.496] 
[17:41:00.497] getGlobalsAndPackages() ... DONE
[17:41:00.497] run() for ‘Future’ ...
[17:41:00.497] - state: ‘created’
[17:41:00.497] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.510] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.511] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.511]   - Field: ‘node’
[17:41:00.511]   - Field: ‘label’
[17:41:00.511]   - Field: ‘local’
[17:41:00.511]   - Field: ‘owner’
[17:41:00.511]   - Field: ‘envir’
[17:41:00.511]   - Field: ‘workers’
[17:41:00.511]   - Field: ‘packages’
[17:41:00.511]   - Field: ‘gc’
[17:41:00.511]   - Field: ‘conditions’
[17:41:00.512]   - Field: ‘persistent’
[17:41:00.512]   - Field: ‘expr’
[17:41:00.512]   - Field: ‘uuid’
[17:41:00.512]   - Field: ‘seed’
[17:41:00.512]   - Field: ‘version’
[17:41:00.512]   - Field: ‘result’
[17:41:00.512]   - Field: ‘asynchronous’
[17:41:00.512]   - Field: ‘calls’
[17:41:00.512]   - Field: ‘globals’
[17:41:00.512]   - Field: ‘stdout’
[17:41:00.512]   - Field: ‘earlySignal’
[17:41:00.513]   - Field: ‘lazy’
[17:41:00.513]   - Field: ‘state’
[17:41:00.513] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.513] - Launch lazy future ...
[17:41:00.513] Packages needed by the future expression (n = 0): <none>
[17:41:00.513] Packages needed by future strategies (n = 0): <none>
[17:41:00.514] {
[17:41:00.514]     {
[17:41:00.514]         {
[17:41:00.514]             ...future.startTime <- base::Sys.time()
[17:41:00.514]             {
[17:41:00.514]                 {
[17:41:00.514]                   {
[17:41:00.514]                     {
[17:41:00.514]                       base::local({
[17:41:00.514]                         has_future <- base::requireNamespace("future", 
[17:41:00.514]                           quietly = TRUE)
[17:41:00.514]                         if (has_future) {
[17:41:00.514]                           ns <- base::getNamespace("future")
[17:41:00.514]                           version <- ns[[".package"]][["version"]]
[17:41:00.514]                           if (is.null(version)) 
[17:41:00.514]                             version <- utils::packageVersion("future")
[17:41:00.514]                         }
[17:41:00.514]                         else {
[17:41:00.514]                           version <- NULL
[17:41:00.514]                         }
[17:41:00.514]                         if (!has_future || version < "1.8.0") {
[17:41:00.514]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.514]                             "", base::R.version$version.string), 
[17:41:00.514]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.514]                               "release", "version")], collapse = " "), 
[17:41:00.514]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.514]                             info)
[17:41:00.514]                           info <- base::paste(info, collapse = "; ")
[17:41:00.514]                           if (!has_future) {
[17:41:00.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.514]                               info)
[17:41:00.514]                           }
[17:41:00.514]                           else {
[17:41:00.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.514]                               info, version)
[17:41:00.514]                           }
[17:41:00.514]                           base::stop(msg)
[17:41:00.514]                         }
[17:41:00.514]                       })
[17:41:00.514]                     }
[17:41:00.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.514]                     base::options(mc.cores = 1L)
[17:41:00.514]                   }
[17:41:00.514]                   ...future.strategy.old <- future::plan("list")
[17:41:00.514]                   options(future.plan = NULL)
[17:41:00.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.514]                 }
[17:41:00.514]                 ...future.workdir <- getwd()
[17:41:00.514]             }
[17:41:00.514]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.514]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.514]         }
[17:41:00.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.514]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.514]             base::names(...future.oldOptions))
[17:41:00.514]     }
[17:41:00.514]     if (FALSE) {
[17:41:00.514]     }
[17:41:00.514]     else {
[17:41:00.514]         if (TRUE) {
[17:41:00.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.514]                 open = "w")
[17:41:00.514]         }
[17:41:00.514]         else {
[17:41:00.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.514]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.514]         }
[17:41:00.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.514]             base::sink(type = "output", split = FALSE)
[17:41:00.514]             base::close(...future.stdout)
[17:41:00.514]         }, add = TRUE)
[17:41:00.514]     }
[17:41:00.514]     ...future.frame <- base::sys.nframe()
[17:41:00.514]     ...future.conditions <- base::list()
[17:41:00.514]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.514]     if (FALSE) {
[17:41:00.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.514]     }
[17:41:00.514]     ...future.result <- base::tryCatch({
[17:41:00.514]         base::withCallingHandlers({
[17:41:00.514]             ...future.value <- base::withVisible(base::local({
[17:41:00.514]                 ...future.makeSendCondition <- base::local({
[17:41:00.514]                   sendCondition <- NULL
[17:41:00.514]                   function(frame = 1L) {
[17:41:00.514]                     if (is.function(sendCondition)) 
[17:41:00.514]                       return(sendCondition)
[17:41:00.514]                     ns <- getNamespace("parallel")
[17:41:00.514]                     if (exists("sendData", mode = "function", 
[17:41:00.514]                       envir = ns)) {
[17:41:00.514]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.514]                         envir = ns)
[17:41:00.514]                       envir <- sys.frame(frame)
[17:41:00.514]                       master <- NULL
[17:41:00.514]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.514]                         !identical(envir, emptyenv())) {
[17:41:00.514]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.514]                           inherits = FALSE)) {
[17:41:00.514]                           master <- get("master", mode = "list", 
[17:41:00.514]                             envir = envir, inherits = FALSE)
[17:41:00.514]                           if (inherits(master, c("SOCKnode", 
[17:41:00.514]                             "SOCK0node"))) {
[17:41:00.514]                             sendCondition <<- function(cond) {
[17:41:00.514]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.514]                                 success = TRUE)
[17:41:00.514]                               parallel_sendData(master, data)
[17:41:00.514]                             }
[17:41:00.514]                             return(sendCondition)
[17:41:00.514]                           }
[17:41:00.514]                         }
[17:41:00.514]                         frame <- frame + 1L
[17:41:00.514]                         envir <- sys.frame(frame)
[17:41:00.514]                       }
[17:41:00.514]                     }
[17:41:00.514]                     sendCondition <<- function(cond) NULL
[17:41:00.514]                   }
[17:41:00.514]                 })
[17:41:00.514]                 withCallingHandlers({
[17:41:00.514]                   {
[17:41:00.514]                     2
[17:41:00.514]                   }
[17:41:00.514]                 }, immediateCondition = function(cond) {
[17:41:00.514]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.514]                   sendCondition(cond)
[17:41:00.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.514]                   {
[17:41:00.514]                     inherits <- base::inherits
[17:41:00.514]                     invokeRestart <- base::invokeRestart
[17:41:00.514]                     is.null <- base::is.null
[17:41:00.514]                     muffled <- FALSE
[17:41:00.514]                     if (inherits(cond, "message")) {
[17:41:00.514]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.514]                       if (muffled) 
[17:41:00.514]                         invokeRestart("muffleMessage")
[17:41:00.514]                     }
[17:41:00.514]                     else if (inherits(cond, "warning")) {
[17:41:00.514]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.514]                       if (muffled) 
[17:41:00.514]                         invokeRestart("muffleWarning")
[17:41:00.514]                     }
[17:41:00.514]                     else if (inherits(cond, "condition")) {
[17:41:00.514]                       if (!is.null(pattern)) {
[17:41:00.514]                         computeRestarts <- base::computeRestarts
[17:41:00.514]                         grepl <- base::grepl
[17:41:00.514]                         restarts <- computeRestarts(cond)
[17:41:00.514]                         for (restart in restarts) {
[17:41:00.514]                           name <- restart$name
[17:41:00.514]                           if (is.null(name)) 
[17:41:00.514]                             next
[17:41:00.514]                           if (!grepl(pattern, name)) 
[17:41:00.514]                             next
[17:41:00.514]                           invokeRestart(restart)
[17:41:00.514]                           muffled <- TRUE
[17:41:00.514]                           break
[17:41:00.514]                         }
[17:41:00.514]                       }
[17:41:00.514]                     }
[17:41:00.514]                     invisible(muffled)
[17:41:00.514]                   }
[17:41:00.514]                   muffleCondition(cond)
[17:41:00.514]                 })
[17:41:00.514]             }))
[17:41:00.514]             future::FutureResult(value = ...future.value$value, 
[17:41:00.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.514]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.514]                     ...future.globalenv.names))
[17:41:00.514]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.514]         }, condition = base::local({
[17:41:00.514]             c <- base::c
[17:41:00.514]             inherits <- base::inherits
[17:41:00.514]             invokeRestart <- base::invokeRestart
[17:41:00.514]             length <- base::length
[17:41:00.514]             list <- base::list
[17:41:00.514]             seq.int <- base::seq.int
[17:41:00.514]             signalCondition <- base::signalCondition
[17:41:00.514]             sys.calls <- base::sys.calls
[17:41:00.514]             `[[` <- base::`[[`
[17:41:00.514]             `+` <- base::`+`
[17:41:00.514]             `<<-` <- base::`<<-`
[17:41:00.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.514]                   3L)]
[17:41:00.514]             }
[17:41:00.514]             function(cond) {
[17:41:00.514]                 is_error <- inherits(cond, "error")
[17:41:00.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.514]                   NULL)
[17:41:00.514]                 if (is_error) {
[17:41:00.514]                   sessionInformation <- function() {
[17:41:00.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.514]                       search = base::search(), system = base::Sys.info())
[17:41:00.514]                   }
[17:41:00.514]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.514]                     cond$call), session = sessionInformation(), 
[17:41:00.514]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.514]                   signalCondition(cond)
[17:41:00.514]                 }
[17:41:00.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.514]                 "immediateCondition"))) {
[17:41:00.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.514]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.514]                   if (TRUE && !signal) {
[17:41:00.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.514]                     {
[17:41:00.514]                       inherits <- base::inherits
[17:41:00.514]                       invokeRestart <- base::invokeRestart
[17:41:00.514]                       is.null <- base::is.null
[17:41:00.514]                       muffled <- FALSE
[17:41:00.514]                       if (inherits(cond, "message")) {
[17:41:00.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.514]                         if (muffled) 
[17:41:00.514]                           invokeRestart("muffleMessage")
[17:41:00.514]                       }
[17:41:00.514]                       else if (inherits(cond, "warning")) {
[17:41:00.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.514]                         if (muffled) 
[17:41:00.514]                           invokeRestart("muffleWarning")
[17:41:00.514]                       }
[17:41:00.514]                       else if (inherits(cond, "condition")) {
[17:41:00.514]                         if (!is.null(pattern)) {
[17:41:00.514]                           computeRestarts <- base::computeRestarts
[17:41:00.514]                           grepl <- base::grepl
[17:41:00.514]                           restarts <- computeRestarts(cond)
[17:41:00.514]                           for (restart in restarts) {
[17:41:00.514]                             name <- restart$name
[17:41:00.514]                             if (is.null(name)) 
[17:41:00.514]                               next
[17:41:00.514]                             if (!grepl(pattern, name)) 
[17:41:00.514]                               next
[17:41:00.514]                             invokeRestart(restart)
[17:41:00.514]                             muffled <- TRUE
[17:41:00.514]                             break
[17:41:00.514]                           }
[17:41:00.514]                         }
[17:41:00.514]                       }
[17:41:00.514]                       invisible(muffled)
[17:41:00.514]                     }
[17:41:00.514]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.514]                   }
[17:41:00.514]                 }
[17:41:00.514]                 else {
[17:41:00.514]                   if (TRUE) {
[17:41:00.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.514]                     {
[17:41:00.514]                       inherits <- base::inherits
[17:41:00.514]                       invokeRestart <- base::invokeRestart
[17:41:00.514]                       is.null <- base::is.null
[17:41:00.514]                       muffled <- FALSE
[17:41:00.514]                       if (inherits(cond, "message")) {
[17:41:00.514]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.514]                         if (muffled) 
[17:41:00.514]                           invokeRestart("muffleMessage")
[17:41:00.514]                       }
[17:41:00.514]                       else if (inherits(cond, "warning")) {
[17:41:00.514]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.514]                         if (muffled) 
[17:41:00.514]                           invokeRestart("muffleWarning")
[17:41:00.514]                       }
[17:41:00.514]                       else if (inherits(cond, "condition")) {
[17:41:00.514]                         if (!is.null(pattern)) {
[17:41:00.514]                           computeRestarts <- base::computeRestarts
[17:41:00.514]                           grepl <- base::grepl
[17:41:00.514]                           restarts <- computeRestarts(cond)
[17:41:00.514]                           for (restart in restarts) {
[17:41:00.514]                             name <- restart$name
[17:41:00.514]                             if (is.null(name)) 
[17:41:00.514]                               next
[17:41:00.514]                             if (!grepl(pattern, name)) 
[17:41:00.514]                               next
[17:41:00.514]                             invokeRestart(restart)
[17:41:00.514]                             muffled <- TRUE
[17:41:00.514]                             break
[17:41:00.514]                           }
[17:41:00.514]                         }
[17:41:00.514]                       }
[17:41:00.514]                       invisible(muffled)
[17:41:00.514]                     }
[17:41:00.514]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.514]                   }
[17:41:00.514]                 }
[17:41:00.514]             }
[17:41:00.514]         }))
[17:41:00.514]     }, error = function(ex) {
[17:41:00.514]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.514]                 ...future.rng), started = ...future.startTime, 
[17:41:00.514]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.514]             version = "1.8"), class = "FutureResult")
[17:41:00.514]     }, finally = {
[17:41:00.514]         if (!identical(...future.workdir, getwd())) 
[17:41:00.514]             setwd(...future.workdir)
[17:41:00.514]         {
[17:41:00.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.514]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.514]             }
[17:41:00.514]             base::options(...future.oldOptions)
[17:41:00.514]             if (.Platform$OS.type == "windows") {
[17:41:00.514]                 old_names <- names(...future.oldEnvVars)
[17:41:00.514]                 envs <- base::Sys.getenv()
[17:41:00.514]                 names <- names(envs)
[17:41:00.514]                 common <- intersect(names, old_names)
[17:41:00.514]                 added <- setdiff(names, old_names)
[17:41:00.514]                 removed <- setdiff(old_names, names)
[17:41:00.514]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.514]                   envs[common]]
[17:41:00.514]                 NAMES <- toupper(changed)
[17:41:00.514]                 args <- list()
[17:41:00.514]                 for (kk in seq_along(NAMES)) {
[17:41:00.514]                   name <- changed[[kk]]
[17:41:00.514]                   NAME <- NAMES[[kk]]
[17:41:00.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.514]                     next
[17:41:00.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.514]                 }
[17:41:00.514]                 NAMES <- toupper(added)
[17:41:00.514]                 for (kk in seq_along(NAMES)) {
[17:41:00.514]                   name <- added[[kk]]
[17:41:00.514]                   NAME <- NAMES[[kk]]
[17:41:00.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.514]                     next
[17:41:00.514]                   args[[name]] <- ""
[17:41:00.514]                 }
[17:41:00.514]                 NAMES <- toupper(removed)
[17:41:00.514]                 for (kk in seq_along(NAMES)) {
[17:41:00.514]                   name <- removed[[kk]]
[17:41:00.514]                   NAME <- NAMES[[kk]]
[17:41:00.514]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.514]                     next
[17:41:00.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.514]                 }
[17:41:00.514]                 if (length(args) > 0) 
[17:41:00.514]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.514]             }
[17:41:00.514]             else {
[17:41:00.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.514]             }
[17:41:00.514]             {
[17:41:00.514]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.514]                   0L) {
[17:41:00.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.514]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.514]                   base::options(opts)
[17:41:00.514]                 }
[17:41:00.514]                 {
[17:41:00.514]                   {
[17:41:00.514]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.514]                     NULL
[17:41:00.514]                   }
[17:41:00.514]                   options(future.plan = NULL)
[17:41:00.514]                   if (is.na(NA_character_)) 
[17:41:00.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.514]                     .init = FALSE)
[17:41:00.514]                 }
[17:41:00.514]             }
[17:41:00.514]         }
[17:41:00.514]     })
[17:41:00.514]     if (TRUE) {
[17:41:00.514]         base::sink(type = "output", split = FALSE)
[17:41:00.514]         if (TRUE) {
[17:41:00.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.514]         }
[17:41:00.514]         else {
[17:41:00.514]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.514]         }
[17:41:00.514]         base::close(...future.stdout)
[17:41:00.514]         ...future.stdout <- NULL
[17:41:00.514]     }
[17:41:00.514]     ...future.result$conditions <- ...future.conditions
[17:41:00.514]     ...future.result$finished <- base::Sys.time()
[17:41:00.514]     ...future.result
[17:41:00.514] }
[17:41:00.517] MultisessionFuture started
[17:41:00.517] - Launch lazy future ... done
[17:41:00.517] run() for ‘MultisessionFuture’ ... done
[17:41:00.517] resolve() on environment ...
[17:41:00.517]  recursive: 0
[17:41:00.518]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:41:00.518] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.518] - Validating connection of MultisessionFuture
[17:41:00.519] - received message: FutureResult
[17:41:00.519] - Received FutureResult
[17:41:00.519] - Erased future from FutureRegistry
[17:41:00.519] result() for ClusterFuture ...
[17:41:00.519] - result already collected: FutureResult
[17:41:00.519] result() for ClusterFuture ... done
[17:41:00.519] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.519] Future #1
[17:41:00.519]  length: 2 (resolved future 1)
[17:41:00.520] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.523] - Validating connection of MultisessionFuture
[17:41:00.523] - received message: FutureResult
[17:41:00.523] - Received FutureResult
[17:41:00.523] - Erased future from FutureRegistry
[17:41:00.523] result() for ClusterFuture ...
[17:41:00.523] - result already collected: FutureResult
[17:41:00.523] result() for ClusterFuture ... done
[17:41:00.524] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.524] Future #2
[17:41:00.524]  length: 1 (resolved future 2)
[17:41:00.524]  length: 0 (resolved future 3)
[17:41:00.524] resolve() on environment ... DONE
[17:41:00.525] getGlobalsAndPackages() ...
[17:41:00.525] Searching for globals...
[17:41:00.525] - globals found: [1] ‘{’
[17:41:00.525] Searching for globals ... DONE
[17:41:00.526] Resolving globals: FALSE
[17:41:00.526] 
[17:41:00.526] 
[17:41:00.526] getGlobalsAndPackages() ... DONE
[17:41:00.526] run() for ‘Future’ ...
[17:41:00.526] - state: ‘created’
[17:41:00.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.540]   - Field: ‘node’
[17:41:00.540]   - Field: ‘label’
[17:41:00.540]   - Field: ‘local’
[17:41:00.540]   - Field: ‘owner’
[17:41:00.540]   - Field: ‘envir’
[17:41:00.540]   - Field: ‘workers’
[17:41:00.540]   - Field: ‘packages’
[17:41:00.541]   - Field: ‘gc’
[17:41:00.541]   - Field: ‘conditions’
[17:41:00.541]   - Field: ‘persistent’
[17:41:00.541]   - Field: ‘expr’
[17:41:00.541]   - Field: ‘uuid’
[17:41:00.541]   - Field: ‘seed’
[17:41:00.541]   - Field: ‘version’
[17:41:00.541]   - Field: ‘result’
[17:41:00.541]   - Field: ‘asynchronous’
[17:41:00.541]   - Field: ‘calls’
[17:41:00.541]   - Field: ‘globals’
[17:41:00.541]   - Field: ‘stdout’
[17:41:00.542]   - Field: ‘earlySignal’
[17:41:00.542]   - Field: ‘lazy’
[17:41:00.542]   - Field: ‘state’
[17:41:00.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.542] - Launch lazy future ...
[17:41:00.542] Packages needed by the future expression (n = 0): <none>
[17:41:00.542] Packages needed by future strategies (n = 0): <none>
[17:41:00.543] {
[17:41:00.543]     {
[17:41:00.543]         {
[17:41:00.543]             ...future.startTime <- base::Sys.time()
[17:41:00.543]             {
[17:41:00.543]                 {
[17:41:00.543]                   {
[17:41:00.543]                     {
[17:41:00.543]                       base::local({
[17:41:00.543]                         has_future <- base::requireNamespace("future", 
[17:41:00.543]                           quietly = TRUE)
[17:41:00.543]                         if (has_future) {
[17:41:00.543]                           ns <- base::getNamespace("future")
[17:41:00.543]                           version <- ns[[".package"]][["version"]]
[17:41:00.543]                           if (is.null(version)) 
[17:41:00.543]                             version <- utils::packageVersion("future")
[17:41:00.543]                         }
[17:41:00.543]                         else {
[17:41:00.543]                           version <- NULL
[17:41:00.543]                         }
[17:41:00.543]                         if (!has_future || version < "1.8.0") {
[17:41:00.543]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.543]                             "", base::R.version$version.string), 
[17:41:00.543]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.543]                               "release", "version")], collapse = " "), 
[17:41:00.543]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.543]                             info)
[17:41:00.543]                           info <- base::paste(info, collapse = "; ")
[17:41:00.543]                           if (!has_future) {
[17:41:00.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.543]                               info)
[17:41:00.543]                           }
[17:41:00.543]                           else {
[17:41:00.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.543]                               info, version)
[17:41:00.543]                           }
[17:41:00.543]                           base::stop(msg)
[17:41:00.543]                         }
[17:41:00.543]                       })
[17:41:00.543]                     }
[17:41:00.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.543]                     base::options(mc.cores = 1L)
[17:41:00.543]                   }
[17:41:00.543]                   ...future.strategy.old <- future::plan("list")
[17:41:00.543]                   options(future.plan = NULL)
[17:41:00.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.543]                 }
[17:41:00.543]                 ...future.workdir <- getwd()
[17:41:00.543]             }
[17:41:00.543]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.543]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.543]         }
[17:41:00.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.543]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.543]             base::names(...future.oldOptions))
[17:41:00.543]     }
[17:41:00.543]     if (FALSE) {
[17:41:00.543]     }
[17:41:00.543]     else {
[17:41:00.543]         if (TRUE) {
[17:41:00.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.543]                 open = "w")
[17:41:00.543]         }
[17:41:00.543]         else {
[17:41:00.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.543]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.543]         }
[17:41:00.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.543]             base::sink(type = "output", split = FALSE)
[17:41:00.543]             base::close(...future.stdout)
[17:41:00.543]         }, add = TRUE)
[17:41:00.543]     }
[17:41:00.543]     ...future.frame <- base::sys.nframe()
[17:41:00.543]     ...future.conditions <- base::list()
[17:41:00.543]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.543]     if (FALSE) {
[17:41:00.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.543]     }
[17:41:00.543]     ...future.result <- base::tryCatch({
[17:41:00.543]         base::withCallingHandlers({
[17:41:00.543]             ...future.value <- base::withVisible(base::local({
[17:41:00.543]                 ...future.makeSendCondition <- base::local({
[17:41:00.543]                   sendCondition <- NULL
[17:41:00.543]                   function(frame = 1L) {
[17:41:00.543]                     if (is.function(sendCondition)) 
[17:41:00.543]                       return(sendCondition)
[17:41:00.543]                     ns <- getNamespace("parallel")
[17:41:00.543]                     if (exists("sendData", mode = "function", 
[17:41:00.543]                       envir = ns)) {
[17:41:00.543]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.543]                         envir = ns)
[17:41:00.543]                       envir <- sys.frame(frame)
[17:41:00.543]                       master <- NULL
[17:41:00.543]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.543]                         !identical(envir, emptyenv())) {
[17:41:00.543]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.543]                           inherits = FALSE)) {
[17:41:00.543]                           master <- get("master", mode = "list", 
[17:41:00.543]                             envir = envir, inherits = FALSE)
[17:41:00.543]                           if (inherits(master, c("SOCKnode", 
[17:41:00.543]                             "SOCK0node"))) {
[17:41:00.543]                             sendCondition <<- function(cond) {
[17:41:00.543]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.543]                                 success = TRUE)
[17:41:00.543]                               parallel_sendData(master, data)
[17:41:00.543]                             }
[17:41:00.543]                             return(sendCondition)
[17:41:00.543]                           }
[17:41:00.543]                         }
[17:41:00.543]                         frame <- frame + 1L
[17:41:00.543]                         envir <- sys.frame(frame)
[17:41:00.543]                       }
[17:41:00.543]                     }
[17:41:00.543]                     sendCondition <<- function(cond) NULL
[17:41:00.543]                   }
[17:41:00.543]                 })
[17:41:00.543]                 withCallingHandlers({
[17:41:00.543]                   {
[17:41:00.543]                     1
[17:41:00.543]                   }
[17:41:00.543]                 }, immediateCondition = function(cond) {
[17:41:00.543]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.543]                   sendCondition(cond)
[17:41:00.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.543]                   {
[17:41:00.543]                     inherits <- base::inherits
[17:41:00.543]                     invokeRestart <- base::invokeRestart
[17:41:00.543]                     is.null <- base::is.null
[17:41:00.543]                     muffled <- FALSE
[17:41:00.543]                     if (inherits(cond, "message")) {
[17:41:00.543]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.543]                       if (muffled) 
[17:41:00.543]                         invokeRestart("muffleMessage")
[17:41:00.543]                     }
[17:41:00.543]                     else if (inherits(cond, "warning")) {
[17:41:00.543]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.543]                       if (muffled) 
[17:41:00.543]                         invokeRestart("muffleWarning")
[17:41:00.543]                     }
[17:41:00.543]                     else if (inherits(cond, "condition")) {
[17:41:00.543]                       if (!is.null(pattern)) {
[17:41:00.543]                         computeRestarts <- base::computeRestarts
[17:41:00.543]                         grepl <- base::grepl
[17:41:00.543]                         restarts <- computeRestarts(cond)
[17:41:00.543]                         for (restart in restarts) {
[17:41:00.543]                           name <- restart$name
[17:41:00.543]                           if (is.null(name)) 
[17:41:00.543]                             next
[17:41:00.543]                           if (!grepl(pattern, name)) 
[17:41:00.543]                             next
[17:41:00.543]                           invokeRestart(restart)
[17:41:00.543]                           muffled <- TRUE
[17:41:00.543]                           break
[17:41:00.543]                         }
[17:41:00.543]                       }
[17:41:00.543]                     }
[17:41:00.543]                     invisible(muffled)
[17:41:00.543]                   }
[17:41:00.543]                   muffleCondition(cond)
[17:41:00.543]                 })
[17:41:00.543]             }))
[17:41:00.543]             future::FutureResult(value = ...future.value$value, 
[17:41:00.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.543]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.543]                     ...future.globalenv.names))
[17:41:00.543]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.543]         }, condition = base::local({
[17:41:00.543]             c <- base::c
[17:41:00.543]             inherits <- base::inherits
[17:41:00.543]             invokeRestart <- base::invokeRestart
[17:41:00.543]             length <- base::length
[17:41:00.543]             list <- base::list
[17:41:00.543]             seq.int <- base::seq.int
[17:41:00.543]             signalCondition <- base::signalCondition
[17:41:00.543]             sys.calls <- base::sys.calls
[17:41:00.543]             `[[` <- base::`[[`
[17:41:00.543]             `+` <- base::`+`
[17:41:00.543]             `<<-` <- base::`<<-`
[17:41:00.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.543]                   3L)]
[17:41:00.543]             }
[17:41:00.543]             function(cond) {
[17:41:00.543]                 is_error <- inherits(cond, "error")
[17:41:00.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.543]                   NULL)
[17:41:00.543]                 if (is_error) {
[17:41:00.543]                   sessionInformation <- function() {
[17:41:00.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.543]                       search = base::search(), system = base::Sys.info())
[17:41:00.543]                   }
[17:41:00.543]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.543]                     cond$call), session = sessionInformation(), 
[17:41:00.543]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.543]                   signalCondition(cond)
[17:41:00.543]                 }
[17:41:00.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.543]                 "immediateCondition"))) {
[17:41:00.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.543]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.543]                   if (TRUE && !signal) {
[17:41:00.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.543]                     {
[17:41:00.543]                       inherits <- base::inherits
[17:41:00.543]                       invokeRestart <- base::invokeRestart
[17:41:00.543]                       is.null <- base::is.null
[17:41:00.543]                       muffled <- FALSE
[17:41:00.543]                       if (inherits(cond, "message")) {
[17:41:00.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.543]                         if (muffled) 
[17:41:00.543]                           invokeRestart("muffleMessage")
[17:41:00.543]                       }
[17:41:00.543]                       else if (inherits(cond, "warning")) {
[17:41:00.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.543]                         if (muffled) 
[17:41:00.543]                           invokeRestart("muffleWarning")
[17:41:00.543]                       }
[17:41:00.543]                       else if (inherits(cond, "condition")) {
[17:41:00.543]                         if (!is.null(pattern)) {
[17:41:00.543]                           computeRestarts <- base::computeRestarts
[17:41:00.543]                           grepl <- base::grepl
[17:41:00.543]                           restarts <- computeRestarts(cond)
[17:41:00.543]                           for (restart in restarts) {
[17:41:00.543]                             name <- restart$name
[17:41:00.543]                             if (is.null(name)) 
[17:41:00.543]                               next
[17:41:00.543]                             if (!grepl(pattern, name)) 
[17:41:00.543]                               next
[17:41:00.543]                             invokeRestart(restart)
[17:41:00.543]                             muffled <- TRUE
[17:41:00.543]                             break
[17:41:00.543]                           }
[17:41:00.543]                         }
[17:41:00.543]                       }
[17:41:00.543]                       invisible(muffled)
[17:41:00.543]                     }
[17:41:00.543]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.543]                   }
[17:41:00.543]                 }
[17:41:00.543]                 else {
[17:41:00.543]                   if (TRUE) {
[17:41:00.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.543]                     {
[17:41:00.543]                       inherits <- base::inherits
[17:41:00.543]                       invokeRestart <- base::invokeRestart
[17:41:00.543]                       is.null <- base::is.null
[17:41:00.543]                       muffled <- FALSE
[17:41:00.543]                       if (inherits(cond, "message")) {
[17:41:00.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.543]                         if (muffled) 
[17:41:00.543]                           invokeRestart("muffleMessage")
[17:41:00.543]                       }
[17:41:00.543]                       else if (inherits(cond, "warning")) {
[17:41:00.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.543]                         if (muffled) 
[17:41:00.543]                           invokeRestart("muffleWarning")
[17:41:00.543]                       }
[17:41:00.543]                       else if (inherits(cond, "condition")) {
[17:41:00.543]                         if (!is.null(pattern)) {
[17:41:00.543]                           computeRestarts <- base::computeRestarts
[17:41:00.543]                           grepl <- base::grepl
[17:41:00.543]                           restarts <- computeRestarts(cond)
[17:41:00.543]                           for (restart in restarts) {
[17:41:00.543]                             name <- restart$name
[17:41:00.543]                             if (is.null(name)) 
[17:41:00.543]                               next
[17:41:00.543]                             if (!grepl(pattern, name)) 
[17:41:00.543]                               next
[17:41:00.543]                             invokeRestart(restart)
[17:41:00.543]                             muffled <- TRUE
[17:41:00.543]                             break
[17:41:00.543]                           }
[17:41:00.543]                         }
[17:41:00.543]                       }
[17:41:00.543]                       invisible(muffled)
[17:41:00.543]                     }
[17:41:00.543]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.543]                   }
[17:41:00.543]                 }
[17:41:00.543]             }
[17:41:00.543]         }))
[17:41:00.543]     }, error = function(ex) {
[17:41:00.543]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.543]                 ...future.rng), started = ...future.startTime, 
[17:41:00.543]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.543]             version = "1.8"), class = "FutureResult")
[17:41:00.543]     }, finally = {
[17:41:00.543]         if (!identical(...future.workdir, getwd())) 
[17:41:00.543]             setwd(...future.workdir)
[17:41:00.543]         {
[17:41:00.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.543]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.543]             }
[17:41:00.543]             base::options(...future.oldOptions)
[17:41:00.543]             if (.Platform$OS.type == "windows") {
[17:41:00.543]                 old_names <- names(...future.oldEnvVars)
[17:41:00.543]                 envs <- base::Sys.getenv()
[17:41:00.543]                 names <- names(envs)
[17:41:00.543]                 common <- intersect(names, old_names)
[17:41:00.543]                 added <- setdiff(names, old_names)
[17:41:00.543]                 removed <- setdiff(old_names, names)
[17:41:00.543]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.543]                   envs[common]]
[17:41:00.543]                 NAMES <- toupper(changed)
[17:41:00.543]                 args <- list()
[17:41:00.543]                 for (kk in seq_along(NAMES)) {
[17:41:00.543]                   name <- changed[[kk]]
[17:41:00.543]                   NAME <- NAMES[[kk]]
[17:41:00.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.543]                     next
[17:41:00.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.543]                 }
[17:41:00.543]                 NAMES <- toupper(added)
[17:41:00.543]                 for (kk in seq_along(NAMES)) {
[17:41:00.543]                   name <- added[[kk]]
[17:41:00.543]                   NAME <- NAMES[[kk]]
[17:41:00.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.543]                     next
[17:41:00.543]                   args[[name]] <- ""
[17:41:00.543]                 }
[17:41:00.543]                 NAMES <- toupper(removed)
[17:41:00.543]                 for (kk in seq_along(NAMES)) {
[17:41:00.543]                   name <- removed[[kk]]
[17:41:00.543]                   NAME <- NAMES[[kk]]
[17:41:00.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.543]                     next
[17:41:00.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.543]                 }
[17:41:00.543]                 if (length(args) > 0) 
[17:41:00.543]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.543]             }
[17:41:00.543]             else {
[17:41:00.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.543]             }
[17:41:00.543]             {
[17:41:00.543]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.543]                   0L) {
[17:41:00.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.543]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.543]                   base::options(opts)
[17:41:00.543]                 }
[17:41:00.543]                 {
[17:41:00.543]                   {
[17:41:00.543]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.543]                     NULL
[17:41:00.543]                   }
[17:41:00.543]                   options(future.plan = NULL)
[17:41:00.543]                   if (is.na(NA_character_)) 
[17:41:00.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.543]                     .init = FALSE)
[17:41:00.543]                 }
[17:41:00.543]             }
[17:41:00.543]         }
[17:41:00.543]     })
[17:41:00.543]     if (TRUE) {
[17:41:00.543]         base::sink(type = "output", split = FALSE)
[17:41:00.543]         if (TRUE) {
[17:41:00.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.543]         }
[17:41:00.543]         else {
[17:41:00.543]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.543]         }
[17:41:00.543]         base::close(...future.stdout)
[17:41:00.543]         ...future.stdout <- NULL
[17:41:00.543]     }
[17:41:00.543]     ...future.result$conditions <- ...future.conditions
[17:41:00.543]     ...future.result$finished <- base::Sys.time()
[17:41:00.543]     ...future.result
[17:41:00.543] }
[17:41:00.546] MultisessionFuture started
[17:41:00.546] - Launch lazy future ... done
[17:41:00.546] run() for ‘MultisessionFuture’ ... done
[17:41:00.546] getGlobalsAndPackages() ...
[17:41:00.547] Searching for globals...
[17:41:00.547] - globals found: [1] ‘{’
[17:41:00.548] Searching for globals ... DONE
[17:41:00.548] Resolving globals: FALSE
[17:41:00.548] 
[17:41:00.548] 
[17:41:00.548] getGlobalsAndPackages() ... DONE
[17:41:00.548] run() for ‘Future’ ...
[17:41:00.549] - state: ‘created’
[17:41:00.549] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.562] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.562] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.562]   - Field: ‘node’
[17:41:00.562]   - Field: ‘label’
[17:41:00.562]   - Field: ‘local’
[17:41:00.562]   - Field: ‘owner’
[17:41:00.562]   - Field: ‘envir’
[17:41:00.562]   - Field: ‘workers’
[17:41:00.563]   - Field: ‘packages’
[17:41:00.563]   - Field: ‘gc’
[17:41:00.563]   - Field: ‘conditions’
[17:41:00.563]   - Field: ‘persistent’
[17:41:00.563]   - Field: ‘expr’
[17:41:00.563]   - Field: ‘uuid’
[17:41:00.563]   - Field: ‘seed’
[17:41:00.563]   - Field: ‘version’
[17:41:00.563]   - Field: ‘result’
[17:41:00.563]   - Field: ‘asynchronous’
[17:41:00.563]   - Field: ‘calls’
[17:41:00.564]   - Field: ‘globals’
[17:41:00.564]   - Field: ‘stdout’
[17:41:00.564]   - Field: ‘earlySignal’
[17:41:00.564]   - Field: ‘lazy’
[17:41:00.564]   - Field: ‘state’
[17:41:00.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.564] - Launch lazy future ...
[17:41:00.564] Packages needed by the future expression (n = 0): <none>
[17:41:00.564] Packages needed by future strategies (n = 0): <none>
[17:41:00.565] {
[17:41:00.565]     {
[17:41:00.565]         {
[17:41:00.565]             ...future.startTime <- base::Sys.time()
[17:41:00.565]             {
[17:41:00.565]                 {
[17:41:00.565]                   {
[17:41:00.565]                     {
[17:41:00.565]                       base::local({
[17:41:00.565]                         has_future <- base::requireNamespace("future", 
[17:41:00.565]                           quietly = TRUE)
[17:41:00.565]                         if (has_future) {
[17:41:00.565]                           ns <- base::getNamespace("future")
[17:41:00.565]                           version <- ns[[".package"]][["version"]]
[17:41:00.565]                           if (is.null(version)) 
[17:41:00.565]                             version <- utils::packageVersion("future")
[17:41:00.565]                         }
[17:41:00.565]                         else {
[17:41:00.565]                           version <- NULL
[17:41:00.565]                         }
[17:41:00.565]                         if (!has_future || version < "1.8.0") {
[17:41:00.565]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.565]                             "", base::R.version$version.string), 
[17:41:00.565]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.565]                               "release", "version")], collapse = " "), 
[17:41:00.565]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.565]                             info)
[17:41:00.565]                           info <- base::paste(info, collapse = "; ")
[17:41:00.565]                           if (!has_future) {
[17:41:00.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.565]                               info)
[17:41:00.565]                           }
[17:41:00.565]                           else {
[17:41:00.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.565]                               info, version)
[17:41:00.565]                           }
[17:41:00.565]                           base::stop(msg)
[17:41:00.565]                         }
[17:41:00.565]                       })
[17:41:00.565]                     }
[17:41:00.565]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.565]                     base::options(mc.cores = 1L)
[17:41:00.565]                   }
[17:41:00.565]                   ...future.strategy.old <- future::plan("list")
[17:41:00.565]                   options(future.plan = NULL)
[17:41:00.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.565]                 }
[17:41:00.565]                 ...future.workdir <- getwd()
[17:41:00.565]             }
[17:41:00.565]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.565]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.565]         }
[17:41:00.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.565]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.565]             base::names(...future.oldOptions))
[17:41:00.565]     }
[17:41:00.565]     if (FALSE) {
[17:41:00.565]     }
[17:41:00.565]     else {
[17:41:00.565]         if (TRUE) {
[17:41:00.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.565]                 open = "w")
[17:41:00.565]         }
[17:41:00.565]         else {
[17:41:00.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.565]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.565]         }
[17:41:00.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.565]             base::sink(type = "output", split = FALSE)
[17:41:00.565]             base::close(...future.stdout)
[17:41:00.565]         }, add = TRUE)
[17:41:00.565]     }
[17:41:00.565]     ...future.frame <- base::sys.nframe()
[17:41:00.565]     ...future.conditions <- base::list()
[17:41:00.565]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.565]     if (FALSE) {
[17:41:00.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.565]     }
[17:41:00.565]     ...future.result <- base::tryCatch({
[17:41:00.565]         base::withCallingHandlers({
[17:41:00.565]             ...future.value <- base::withVisible(base::local({
[17:41:00.565]                 ...future.makeSendCondition <- base::local({
[17:41:00.565]                   sendCondition <- NULL
[17:41:00.565]                   function(frame = 1L) {
[17:41:00.565]                     if (is.function(sendCondition)) 
[17:41:00.565]                       return(sendCondition)
[17:41:00.565]                     ns <- getNamespace("parallel")
[17:41:00.565]                     if (exists("sendData", mode = "function", 
[17:41:00.565]                       envir = ns)) {
[17:41:00.565]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.565]                         envir = ns)
[17:41:00.565]                       envir <- sys.frame(frame)
[17:41:00.565]                       master <- NULL
[17:41:00.565]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.565]                         !identical(envir, emptyenv())) {
[17:41:00.565]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.565]                           inherits = FALSE)) {
[17:41:00.565]                           master <- get("master", mode = "list", 
[17:41:00.565]                             envir = envir, inherits = FALSE)
[17:41:00.565]                           if (inherits(master, c("SOCKnode", 
[17:41:00.565]                             "SOCK0node"))) {
[17:41:00.565]                             sendCondition <<- function(cond) {
[17:41:00.565]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.565]                                 success = TRUE)
[17:41:00.565]                               parallel_sendData(master, data)
[17:41:00.565]                             }
[17:41:00.565]                             return(sendCondition)
[17:41:00.565]                           }
[17:41:00.565]                         }
[17:41:00.565]                         frame <- frame + 1L
[17:41:00.565]                         envir <- sys.frame(frame)
[17:41:00.565]                       }
[17:41:00.565]                     }
[17:41:00.565]                     sendCondition <<- function(cond) NULL
[17:41:00.565]                   }
[17:41:00.565]                 })
[17:41:00.565]                 withCallingHandlers({
[17:41:00.565]                   {
[17:41:00.565]                     2
[17:41:00.565]                   }
[17:41:00.565]                 }, immediateCondition = function(cond) {
[17:41:00.565]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.565]                   sendCondition(cond)
[17:41:00.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.565]                   {
[17:41:00.565]                     inherits <- base::inherits
[17:41:00.565]                     invokeRestart <- base::invokeRestart
[17:41:00.565]                     is.null <- base::is.null
[17:41:00.565]                     muffled <- FALSE
[17:41:00.565]                     if (inherits(cond, "message")) {
[17:41:00.565]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.565]                       if (muffled) 
[17:41:00.565]                         invokeRestart("muffleMessage")
[17:41:00.565]                     }
[17:41:00.565]                     else if (inherits(cond, "warning")) {
[17:41:00.565]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.565]                       if (muffled) 
[17:41:00.565]                         invokeRestart("muffleWarning")
[17:41:00.565]                     }
[17:41:00.565]                     else if (inherits(cond, "condition")) {
[17:41:00.565]                       if (!is.null(pattern)) {
[17:41:00.565]                         computeRestarts <- base::computeRestarts
[17:41:00.565]                         grepl <- base::grepl
[17:41:00.565]                         restarts <- computeRestarts(cond)
[17:41:00.565]                         for (restart in restarts) {
[17:41:00.565]                           name <- restart$name
[17:41:00.565]                           if (is.null(name)) 
[17:41:00.565]                             next
[17:41:00.565]                           if (!grepl(pattern, name)) 
[17:41:00.565]                             next
[17:41:00.565]                           invokeRestart(restart)
[17:41:00.565]                           muffled <- TRUE
[17:41:00.565]                           break
[17:41:00.565]                         }
[17:41:00.565]                       }
[17:41:00.565]                     }
[17:41:00.565]                     invisible(muffled)
[17:41:00.565]                   }
[17:41:00.565]                   muffleCondition(cond)
[17:41:00.565]                 })
[17:41:00.565]             }))
[17:41:00.565]             future::FutureResult(value = ...future.value$value, 
[17:41:00.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.565]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.565]                     ...future.globalenv.names))
[17:41:00.565]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.565]         }, condition = base::local({
[17:41:00.565]             c <- base::c
[17:41:00.565]             inherits <- base::inherits
[17:41:00.565]             invokeRestart <- base::invokeRestart
[17:41:00.565]             length <- base::length
[17:41:00.565]             list <- base::list
[17:41:00.565]             seq.int <- base::seq.int
[17:41:00.565]             signalCondition <- base::signalCondition
[17:41:00.565]             sys.calls <- base::sys.calls
[17:41:00.565]             `[[` <- base::`[[`
[17:41:00.565]             `+` <- base::`+`
[17:41:00.565]             `<<-` <- base::`<<-`
[17:41:00.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.565]                   3L)]
[17:41:00.565]             }
[17:41:00.565]             function(cond) {
[17:41:00.565]                 is_error <- inherits(cond, "error")
[17:41:00.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.565]                   NULL)
[17:41:00.565]                 if (is_error) {
[17:41:00.565]                   sessionInformation <- function() {
[17:41:00.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.565]                       search = base::search(), system = base::Sys.info())
[17:41:00.565]                   }
[17:41:00.565]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.565]                     cond$call), session = sessionInformation(), 
[17:41:00.565]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.565]                   signalCondition(cond)
[17:41:00.565]                 }
[17:41:00.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.565]                 "immediateCondition"))) {
[17:41:00.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.565]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.565]                   if (TRUE && !signal) {
[17:41:00.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.565]                     {
[17:41:00.565]                       inherits <- base::inherits
[17:41:00.565]                       invokeRestart <- base::invokeRestart
[17:41:00.565]                       is.null <- base::is.null
[17:41:00.565]                       muffled <- FALSE
[17:41:00.565]                       if (inherits(cond, "message")) {
[17:41:00.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.565]                         if (muffled) 
[17:41:00.565]                           invokeRestart("muffleMessage")
[17:41:00.565]                       }
[17:41:00.565]                       else if (inherits(cond, "warning")) {
[17:41:00.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.565]                         if (muffled) 
[17:41:00.565]                           invokeRestart("muffleWarning")
[17:41:00.565]                       }
[17:41:00.565]                       else if (inherits(cond, "condition")) {
[17:41:00.565]                         if (!is.null(pattern)) {
[17:41:00.565]                           computeRestarts <- base::computeRestarts
[17:41:00.565]                           grepl <- base::grepl
[17:41:00.565]                           restarts <- computeRestarts(cond)
[17:41:00.565]                           for (restart in restarts) {
[17:41:00.565]                             name <- restart$name
[17:41:00.565]                             if (is.null(name)) 
[17:41:00.565]                               next
[17:41:00.565]                             if (!grepl(pattern, name)) 
[17:41:00.565]                               next
[17:41:00.565]                             invokeRestart(restart)
[17:41:00.565]                             muffled <- TRUE
[17:41:00.565]                             break
[17:41:00.565]                           }
[17:41:00.565]                         }
[17:41:00.565]                       }
[17:41:00.565]                       invisible(muffled)
[17:41:00.565]                     }
[17:41:00.565]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.565]                   }
[17:41:00.565]                 }
[17:41:00.565]                 else {
[17:41:00.565]                   if (TRUE) {
[17:41:00.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.565]                     {
[17:41:00.565]                       inherits <- base::inherits
[17:41:00.565]                       invokeRestart <- base::invokeRestart
[17:41:00.565]                       is.null <- base::is.null
[17:41:00.565]                       muffled <- FALSE
[17:41:00.565]                       if (inherits(cond, "message")) {
[17:41:00.565]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.565]                         if (muffled) 
[17:41:00.565]                           invokeRestart("muffleMessage")
[17:41:00.565]                       }
[17:41:00.565]                       else if (inherits(cond, "warning")) {
[17:41:00.565]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.565]                         if (muffled) 
[17:41:00.565]                           invokeRestart("muffleWarning")
[17:41:00.565]                       }
[17:41:00.565]                       else if (inherits(cond, "condition")) {
[17:41:00.565]                         if (!is.null(pattern)) {
[17:41:00.565]                           computeRestarts <- base::computeRestarts
[17:41:00.565]                           grepl <- base::grepl
[17:41:00.565]                           restarts <- computeRestarts(cond)
[17:41:00.565]                           for (restart in restarts) {
[17:41:00.565]                             name <- restart$name
[17:41:00.565]                             if (is.null(name)) 
[17:41:00.565]                               next
[17:41:00.565]                             if (!grepl(pattern, name)) 
[17:41:00.565]                               next
[17:41:00.565]                             invokeRestart(restart)
[17:41:00.565]                             muffled <- TRUE
[17:41:00.565]                             break
[17:41:00.565]                           }
[17:41:00.565]                         }
[17:41:00.565]                       }
[17:41:00.565]                       invisible(muffled)
[17:41:00.565]                     }
[17:41:00.565]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.565]                   }
[17:41:00.565]                 }
[17:41:00.565]             }
[17:41:00.565]         }))
[17:41:00.565]     }, error = function(ex) {
[17:41:00.565]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.565]                 ...future.rng), started = ...future.startTime, 
[17:41:00.565]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.565]             version = "1.8"), class = "FutureResult")
[17:41:00.565]     }, finally = {
[17:41:00.565]         if (!identical(...future.workdir, getwd())) 
[17:41:00.565]             setwd(...future.workdir)
[17:41:00.565]         {
[17:41:00.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.565]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.565]             }
[17:41:00.565]             base::options(...future.oldOptions)
[17:41:00.565]             if (.Platform$OS.type == "windows") {
[17:41:00.565]                 old_names <- names(...future.oldEnvVars)
[17:41:00.565]                 envs <- base::Sys.getenv()
[17:41:00.565]                 names <- names(envs)
[17:41:00.565]                 common <- intersect(names, old_names)
[17:41:00.565]                 added <- setdiff(names, old_names)
[17:41:00.565]                 removed <- setdiff(old_names, names)
[17:41:00.565]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.565]                   envs[common]]
[17:41:00.565]                 NAMES <- toupper(changed)
[17:41:00.565]                 args <- list()
[17:41:00.565]                 for (kk in seq_along(NAMES)) {
[17:41:00.565]                   name <- changed[[kk]]
[17:41:00.565]                   NAME <- NAMES[[kk]]
[17:41:00.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.565]                     next
[17:41:00.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.565]                 }
[17:41:00.565]                 NAMES <- toupper(added)
[17:41:00.565]                 for (kk in seq_along(NAMES)) {
[17:41:00.565]                   name <- added[[kk]]
[17:41:00.565]                   NAME <- NAMES[[kk]]
[17:41:00.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.565]                     next
[17:41:00.565]                   args[[name]] <- ""
[17:41:00.565]                 }
[17:41:00.565]                 NAMES <- toupper(removed)
[17:41:00.565]                 for (kk in seq_along(NAMES)) {
[17:41:00.565]                   name <- removed[[kk]]
[17:41:00.565]                   NAME <- NAMES[[kk]]
[17:41:00.565]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.565]                     next
[17:41:00.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.565]                 }
[17:41:00.565]                 if (length(args) > 0) 
[17:41:00.565]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.565]             }
[17:41:00.565]             else {
[17:41:00.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.565]             }
[17:41:00.565]             {
[17:41:00.565]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.565]                   0L) {
[17:41:00.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.565]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.565]                   base::options(opts)
[17:41:00.565]                 }
[17:41:00.565]                 {
[17:41:00.565]                   {
[17:41:00.565]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.565]                     NULL
[17:41:00.565]                   }
[17:41:00.565]                   options(future.plan = NULL)
[17:41:00.565]                   if (is.na(NA_character_)) 
[17:41:00.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.565]                     .init = FALSE)
[17:41:00.565]                 }
[17:41:00.565]             }
[17:41:00.565]         }
[17:41:00.565]     })
[17:41:00.565]     if (TRUE) {
[17:41:00.565]         base::sink(type = "output", split = FALSE)
[17:41:00.565]         if (TRUE) {
[17:41:00.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.565]         }
[17:41:00.565]         else {
[17:41:00.565]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.565]         }
[17:41:00.565]         base::close(...future.stdout)
[17:41:00.565]         ...future.stdout <- NULL
[17:41:00.565]     }
[17:41:00.565]     ...future.result$conditions <- ...future.conditions
[17:41:00.565]     ...future.result$finished <- base::Sys.time()
[17:41:00.565]     ...future.result
[17:41:00.565] }
[17:41:00.568] MultisessionFuture started
[17:41:00.568] - Launch lazy future ... done
[17:41:00.568] run() for ‘MultisessionFuture’ ... done
[17:41:00.568] resolve() on environment ...
[17:41:00.568]  recursive: 0
[17:41:00.569]  elements: [3] ‘a’
[17:41:00.569] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.569] - Validating connection of MultisessionFuture
[17:41:00.570] - received message: FutureResult
[17:41:00.570] - Received FutureResult
[17:41:00.570] - Erased future from FutureRegistry
[17:41:00.570] result() for ClusterFuture ...
[17:41:00.570] - result already collected: FutureResult
[17:41:00.570] result() for ClusterFuture ... done
[17:41:00.570] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.570] Future #1
[17:41:00.570]  length: 2 (resolved future 1)
[17:41:00.571] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.571] - Validating connection of MultisessionFuture
[17:41:00.571] - received message: FutureResult
[17:41:00.571] - Received FutureResult
[17:41:00.571] - Erased future from FutureRegistry
[17:41:00.571] result() for ClusterFuture ...
[17:41:00.571] - result already collected: FutureResult
[17:41:00.571] result() for ClusterFuture ... done
[17:41:00.571] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.572] Future #2
[17:41:00.572]  length: 1 (resolved future 2)
[17:41:00.572]  length: 0 (resolved future 3)
[17:41:00.572] resolve() on environment ... DONE
[17:41:00.572] resolve() on environment ...
[17:41:00.573]  recursive: 0
[17:41:00.573]  elements: [3] ‘b’
[17:41:00.573] Future #1
[17:41:00.573]  length: 2 (resolved future 1)
[17:41:00.573] Future #2
[17:41:00.573]  length: 1 (resolved future 2)
[17:41:00.573]  length: 0 (resolved future 3)
[17:41:00.574] resolve() on environment ... DONE
[17:41:00.574] resolve() on environment ...
[17:41:00.574]  recursive: 0
[17:41:00.574]  elements: [3] ‘c’
[17:41:00.575] Future #1
[17:41:00.575]  length: 2 (resolved future 1)
[17:41:00.575] Future #2
[17:41:00.575]  length: 1 (resolved future 2)
[17:41:00.575]  length: 0 (resolved future 3)
[17:41:00.575] resolve() on environment ... DONE
[17:41:00.576] resolve() on environment ...
[17:41:00.576]  recursive: 0
[17:41:00.576]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[17:41:00.576] Future #1
[17:41:00.576] result() for ClusterFuture ...
[17:41:00.576] - result already collected: FutureResult
[17:41:00.576] result() for ClusterFuture ... done
[17:41:00.577] result() for ClusterFuture ...
[17:41:00.577] - result already collected: FutureResult
[17:41:00.577] result() for ClusterFuture ... done
[17:41:00.577]  length: 2 (resolved future 1)
[17:41:00.577] Future #2
[17:41:00.577] result() for ClusterFuture ...
[17:41:00.577] - result already collected: FutureResult
[17:41:00.577] result() for ClusterFuture ... done
[17:41:00.577] result() for ClusterFuture ...
[17:41:00.577] - result already collected: FutureResult
[17:41:00.577] result() for ClusterFuture ... done
[17:41:00.578]  length: 1 (resolved future 2)
[17:41:00.578]  length: 0 (resolved future 3)
[17:41:00.578] resolve() on environment ... DONE
[17:41:00.578] resolve() on environment ...
[17:41:00.578]  recursive: 99
[17:41:00.579]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[17:41:00.579] Future #1
[17:41:00.579] result() for ClusterFuture ...
[17:41:00.579] - result already collected: FutureResult
[17:41:00.579] result() for ClusterFuture ... done
[17:41:00.579] result() for ClusterFuture ...
[17:41:00.579] - result already collected: FutureResult
[17:41:00.579] result() for ClusterFuture ... done
[17:41:00.579] A MultisessionFuture was resolved
[17:41:00.580]  length: 2 (resolved future 1)
[17:41:00.580] Future #2
[17:41:00.580] result() for ClusterFuture ...
[17:41:00.580] - result already collected: FutureResult
[17:41:00.580] result() for ClusterFuture ... done
[17:41:00.580] result() for ClusterFuture ...
[17:41:00.580] - result already collected: FutureResult
[17:41:00.580] result() for ClusterFuture ... done
[17:41:00.580] A MultisessionFuture was resolved
[17:41:00.580]  length: 1 (resolved future 2)
[17:41:00.580]  length: 0 (resolved future 3)
[17:41:00.581] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[17:41:00.581] resolve() on list environment ...
[17:41:00.581]  recursive: 0
[17:41:00.582]  length: 2
[17:41:00.582]  elements: ‘a’, ‘b’
[17:41:00.582]  length: 1 (resolved future 1)
[17:41:00.582]  length: 0 (resolved future 2)
[17:41:00.582] resolve() on list environment ... DONE
[17:41:00.582] getGlobalsAndPackages() ...
[17:41:00.582] Searching for globals...
[17:41:00.583] 
[17:41:00.583] Searching for globals ... DONE
[17:41:00.583] - globals: [0] <none>
[17:41:00.583] getGlobalsAndPackages() ... DONE
[17:41:00.583] run() for ‘Future’ ...
[17:41:00.583] - state: ‘created’
[17:41:00.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.597] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.597]   - Field: ‘node’
[17:41:00.597]   - Field: ‘label’
[17:41:00.597]   - Field: ‘local’
[17:41:00.597]   - Field: ‘owner’
[17:41:00.597]   - Field: ‘envir’
[17:41:00.597]   - Field: ‘workers’
[17:41:00.598]   - Field: ‘packages’
[17:41:00.598]   - Field: ‘gc’
[17:41:00.598]   - Field: ‘conditions’
[17:41:00.598]   - Field: ‘persistent’
[17:41:00.598]   - Field: ‘expr’
[17:41:00.598]   - Field: ‘uuid’
[17:41:00.598]   - Field: ‘seed’
[17:41:00.598]   - Field: ‘version’
[17:41:00.598]   - Field: ‘result’
[17:41:00.598]   - Field: ‘asynchronous’
[17:41:00.598]   - Field: ‘calls’
[17:41:00.599]   - Field: ‘globals’
[17:41:00.599]   - Field: ‘stdout’
[17:41:00.599]   - Field: ‘earlySignal’
[17:41:00.599]   - Field: ‘lazy’
[17:41:00.599]   - Field: ‘state’
[17:41:00.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.599] - Launch lazy future ...
[17:41:00.599] Packages needed by the future expression (n = 0): <none>
[17:41:00.599] Packages needed by future strategies (n = 0): <none>
[17:41:00.600] {
[17:41:00.600]     {
[17:41:00.600]         {
[17:41:00.600]             ...future.startTime <- base::Sys.time()
[17:41:00.600]             {
[17:41:00.600]                 {
[17:41:00.600]                   {
[17:41:00.600]                     {
[17:41:00.600]                       base::local({
[17:41:00.600]                         has_future <- base::requireNamespace("future", 
[17:41:00.600]                           quietly = TRUE)
[17:41:00.600]                         if (has_future) {
[17:41:00.600]                           ns <- base::getNamespace("future")
[17:41:00.600]                           version <- ns[[".package"]][["version"]]
[17:41:00.600]                           if (is.null(version)) 
[17:41:00.600]                             version <- utils::packageVersion("future")
[17:41:00.600]                         }
[17:41:00.600]                         else {
[17:41:00.600]                           version <- NULL
[17:41:00.600]                         }
[17:41:00.600]                         if (!has_future || version < "1.8.0") {
[17:41:00.600]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.600]                             "", base::R.version$version.string), 
[17:41:00.600]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.600]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.600]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.600]                               "release", "version")], collapse = " "), 
[17:41:00.600]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.600]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.600]                             info)
[17:41:00.600]                           info <- base::paste(info, collapse = "; ")
[17:41:00.600]                           if (!has_future) {
[17:41:00.600]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.600]                               info)
[17:41:00.600]                           }
[17:41:00.600]                           else {
[17:41:00.600]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.600]                               info, version)
[17:41:00.600]                           }
[17:41:00.600]                           base::stop(msg)
[17:41:00.600]                         }
[17:41:00.600]                       })
[17:41:00.600]                     }
[17:41:00.600]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.600]                     base::options(mc.cores = 1L)
[17:41:00.600]                   }
[17:41:00.600]                   ...future.strategy.old <- future::plan("list")
[17:41:00.600]                   options(future.plan = NULL)
[17:41:00.600]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.600]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.600]                 }
[17:41:00.600]                 ...future.workdir <- getwd()
[17:41:00.600]             }
[17:41:00.600]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.600]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.600]         }
[17:41:00.600]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.600]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.600]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.600]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.600]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.600]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.600]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.600]             base::names(...future.oldOptions))
[17:41:00.600]     }
[17:41:00.600]     if (FALSE) {
[17:41:00.600]     }
[17:41:00.600]     else {
[17:41:00.600]         if (TRUE) {
[17:41:00.600]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.600]                 open = "w")
[17:41:00.600]         }
[17:41:00.600]         else {
[17:41:00.600]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.600]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.600]         }
[17:41:00.600]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.600]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.600]             base::sink(type = "output", split = FALSE)
[17:41:00.600]             base::close(...future.stdout)
[17:41:00.600]         }, add = TRUE)
[17:41:00.600]     }
[17:41:00.600]     ...future.frame <- base::sys.nframe()
[17:41:00.600]     ...future.conditions <- base::list()
[17:41:00.600]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.600]     if (FALSE) {
[17:41:00.600]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.600]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.600]     }
[17:41:00.600]     ...future.result <- base::tryCatch({
[17:41:00.600]         base::withCallingHandlers({
[17:41:00.600]             ...future.value <- base::withVisible(base::local({
[17:41:00.600]                 ...future.makeSendCondition <- base::local({
[17:41:00.600]                   sendCondition <- NULL
[17:41:00.600]                   function(frame = 1L) {
[17:41:00.600]                     if (is.function(sendCondition)) 
[17:41:00.600]                       return(sendCondition)
[17:41:00.600]                     ns <- getNamespace("parallel")
[17:41:00.600]                     if (exists("sendData", mode = "function", 
[17:41:00.600]                       envir = ns)) {
[17:41:00.600]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.600]                         envir = ns)
[17:41:00.600]                       envir <- sys.frame(frame)
[17:41:00.600]                       master <- NULL
[17:41:00.600]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.600]                         !identical(envir, emptyenv())) {
[17:41:00.600]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.600]                           inherits = FALSE)) {
[17:41:00.600]                           master <- get("master", mode = "list", 
[17:41:00.600]                             envir = envir, inherits = FALSE)
[17:41:00.600]                           if (inherits(master, c("SOCKnode", 
[17:41:00.600]                             "SOCK0node"))) {
[17:41:00.600]                             sendCondition <<- function(cond) {
[17:41:00.600]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.600]                                 success = TRUE)
[17:41:00.600]                               parallel_sendData(master, data)
[17:41:00.600]                             }
[17:41:00.600]                             return(sendCondition)
[17:41:00.600]                           }
[17:41:00.600]                         }
[17:41:00.600]                         frame <- frame + 1L
[17:41:00.600]                         envir <- sys.frame(frame)
[17:41:00.600]                       }
[17:41:00.600]                     }
[17:41:00.600]                     sendCondition <<- function(cond) NULL
[17:41:00.600]                   }
[17:41:00.600]                 })
[17:41:00.600]                 withCallingHandlers({
[17:41:00.600]                   1
[17:41:00.600]                 }, immediateCondition = function(cond) {
[17:41:00.600]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.600]                   sendCondition(cond)
[17:41:00.600]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.600]                   {
[17:41:00.600]                     inherits <- base::inherits
[17:41:00.600]                     invokeRestart <- base::invokeRestart
[17:41:00.600]                     is.null <- base::is.null
[17:41:00.600]                     muffled <- FALSE
[17:41:00.600]                     if (inherits(cond, "message")) {
[17:41:00.600]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.600]                       if (muffled) 
[17:41:00.600]                         invokeRestart("muffleMessage")
[17:41:00.600]                     }
[17:41:00.600]                     else if (inherits(cond, "warning")) {
[17:41:00.600]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.600]                       if (muffled) 
[17:41:00.600]                         invokeRestart("muffleWarning")
[17:41:00.600]                     }
[17:41:00.600]                     else if (inherits(cond, "condition")) {
[17:41:00.600]                       if (!is.null(pattern)) {
[17:41:00.600]                         computeRestarts <- base::computeRestarts
[17:41:00.600]                         grepl <- base::grepl
[17:41:00.600]                         restarts <- computeRestarts(cond)
[17:41:00.600]                         for (restart in restarts) {
[17:41:00.600]                           name <- restart$name
[17:41:00.600]                           if (is.null(name)) 
[17:41:00.600]                             next
[17:41:00.600]                           if (!grepl(pattern, name)) 
[17:41:00.600]                             next
[17:41:00.600]                           invokeRestart(restart)
[17:41:00.600]                           muffled <- TRUE
[17:41:00.600]                           break
[17:41:00.600]                         }
[17:41:00.600]                       }
[17:41:00.600]                     }
[17:41:00.600]                     invisible(muffled)
[17:41:00.600]                   }
[17:41:00.600]                   muffleCondition(cond)
[17:41:00.600]                 })
[17:41:00.600]             }))
[17:41:00.600]             future::FutureResult(value = ...future.value$value, 
[17:41:00.600]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.600]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.600]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.600]                     ...future.globalenv.names))
[17:41:00.600]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.600]         }, condition = base::local({
[17:41:00.600]             c <- base::c
[17:41:00.600]             inherits <- base::inherits
[17:41:00.600]             invokeRestart <- base::invokeRestart
[17:41:00.600]             length <- base::length
[17:41:00.600]             list <- base::list
[17:41:00.600]             seq.int <- base::seq.int
[17:41:00.600]             signalCondition <- base::signalCondition
[17:41:00.600]             sys.calls <- base::sys.calls
[17:41:00.600]             `[[` <- base::`[[`
[17:41:00.600]             `+` <- base::`+`
[17:41:00.600]             `<<-` <- base::`<<-`
[17:41:00.600]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.600]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.600]                   3L)]
[17:41:00.600]             }
[17:41:00.600]             function(cond) {
[17:41:00.600]                 is_error <- inherits(cond, "error")
[17:41:00.600]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.600]                   NULL)
[17:41:00.600]                 if (is_error) {
[17:41:00.600]                   sessionInformation <- function() {
[17:41:00.600]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.600]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.600]                       search = base::search(), system = base::Sys.info())
[17:41:00.600]                   }
[17:41:00.600]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.600]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.600]                     cond$call), session = sessionInformation(), 
[17:41:00.600]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.600]                   signalCondition(cond)
[17:41:00.600]                 }
[17:41:00.600]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.600]                 "immediateCondition"))) {
[17:41:00.600]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.600]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.600]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.600]                   if (TRUE && !signal) {
[17:41:00.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.600]                     {
[17:41:00.600]                       inherits <- base::inherits
[17:41:00.600]                       invokeRestart <- base::invokeRestart
[17:41:00.600]                       is.null <- base::is.null
[17:41:00.600]                       muffled <- FALSE
[17:41:00.600]                       if (inherits(cond, "message")) {
[17:41:00.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.600]                         if (muffled) 
[17:41:00.600]                           invokeRestart("muffleMessage")
[17:41:00.600]                       }
[17:41:00.600]                       else if (inherits(cond, "warning")) {
[17:41:00.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.600]                         if (muffled) 
[17:41:00.600]                           invokeRestart("muffleWarning")
[17:41:00.600]                       }
[17:41:00.600]                       else if (inherits(cond, "condition")) {
[17:41:00.600]                         if (!is.null(pattern)) {
[17:41:00.600]                           computeRestarts <- base::computeRestarts
[17:41:00.600]                           grepl <- base::grepl
[17:41:00.600]                           restarts <- computeRestarts(cond)
[17:41:00.600]                           for (restart in restarts) {
[17:41:00.600]                             name <- restart$name
[17:41:00.600]                             if (is.null(name)) 
[17:41:00.600]                               next
[17:41:00.600]                             if (!grepl(pattern, name)) 
[17:41:00.600]                               next
[17:41:00.600]                             invokeRestart(restart)
[17:41:00.600]                             muffled <- TRUE
[17:41:00.600]                             break
[17:41:00.600]                           }
[17:41:00.600]                         }
[17:41:00.600]                       }
[17:41:00.600]                       invisible(muffled)
[17:41:00.600]                     }
[17:41:00.600]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.600]                   }
[17:41:00.600]                 }
[17:41:00.600]                 else {
[17:41:00.600]                   if (TRUE) {
[17:41:00.600]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.600]                     {
[17:41:00.600]                       inherits <- base::inherits
[17:41:00.600]                       invokeRestart <- base::invokeRestart
[17:41:00.600]                       is.null <- base::is.null
[17:41:00.600]                       muffled <- FALSE
[17:41:00.600]                       if (inherits(cond, "message")) {
[17:41:00.600]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.600]                         if (muffled) 
[17:41:00.600]                           invokeRestart("muffleMessage")
[17:41:00.600]                       }
[17:41:00.600]                       else if (inherits(cond, "warning")) {
[17:41:00.600]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.600]                         if (muffled) 
[17:41:00.600]                           invokeRestart("muffleWarning")
[17:41:00.600]                       }
[17:41:00.600]                       else if (inherits(cond, "condition")) {
[17:41:00.600]                         if (!is.null(pattern)) {
[17:41:00.600]                           computeRestarts <- base::computeRestarts
[17:41:00.600]                           grepl <- base::grepl
[17:41:00.600]                           restarts <- computeRestarts(cond)
[17:41:00.600]                           for (restart in restarts) {
[17:41:00.600]                             name <- restart$name
[17:41:00.600]                             if (is.null(name)) 
[17:41:00.600]                               next
[17:41:00.600]                             if (!grepl(pattern, name)) 
[17:41:00.600]                               next
[17:41:00.600]                             invokeRestart(restart)
[17:41:00.600]                             muffled <- TRUE
[17:41:00.600]                             break
[17:41:00.600]                           }
[17:41:00.600]                         }
[17:41:00.600]                       }
[17:41:00.600]                       invisible(muffled)
[17:41:00.600]                     }
[17:41:00.600]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.600]                   }
[17:41:00.600]                 }
[17:41:00.600]             }
[17:41:00.600]         }))
[17:41:00.600]     }, error = function(ex) {
[17:41:00.600]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.600]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.600]                 ...future.rng), started = ...future.startTime, 
[17:41:00.600]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.600]             version = "1.8"), class = "FutureResult")
[17:41:00.600]     }, finally = {
[17:41:00.600]         if (!identical(...future.workdir, getwd())) 
[17:41:00.600]             setwd(...future.workdir)
[17:41:00.600]         {
[17:41:00.600]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.600]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.600]             }
[17:41:00.600]             base::options(...future.oldOptions)
[17:41:00.600]             if (.Platform$OS.type == "windows") {
[17:41:00.600]                 old_names <- names(...future.oldEnvVars)
[17:41:00.600]                 envs <- base::Sys.getenv()
[17:41:00.600]                 names <- names(envs)
[17:41:00.600]                 common <- intersect(names, old_names)
[17:41:00.600]                 added <- setdiff(names, old_names)
[17:41:00.600]                 removed <- setdiff(old_names, names)
[17:41:00.600]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.600]                   envs[common]]
[17:41:00.600]                 NAMES <- toupper(changed)
[17:41:00.600]                 args <- list()
[17:41:00.600]                 for (kk in seq_along(NAMES)) {
[17:41:00.600]                   name <- changed[[kk]]
[17:41:00.600]                   NAME <- NAMES[[kk]]
[17:41:00.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.600]                     next
[17:41:00.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.600]                 }
[17:41:00.600]                 NAMES <- toupper(added)
[17:41:00.600]                 for (kk in seq_along(NAMES)) {
[17:41:00.600]                   name <- added[[kk]]
[17:41:00.600]                   NAME <- NAMES[[kk]]
[17:41:00.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.600]                     next
[17:41:00.600]                   args[[name]] <- ""
[17:41:00.600]                 }
[17:41:00.600]                 NAMES <- toupper(removed)
[17:41:00.600]                 for (kk in seq_along(NAMES)) {
[17:41:00.600]                   name <- removed[[kk]]
[17:41:00.600]                   NAME <- NAMES[[kk]]
[17:41:00.600]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.600]                     next
[17:41:00.600]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.600]                 }
[17:41:00.600]                 if (length(args) > 0) 
[17:41:00.600]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.600]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.600]             }
[17:41:00.600]             else {
[17:41:00.600]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.600]             }
[17:41:00.600]             {
[17:41:00.600]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.600]                   0L) {
[17:41:00.600]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.600]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.600]                   base::options(opts)
[17:41:00.600]                 }
[17:41:00.600]                 {
[17:41:00.600]                   {
[17:41:00.600]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.600]                     NULL
[17:41:00.600]                   }
[17:41:00.600]                   options(future.plan = NULL)
[17:41:00.600]                   if (is.na(NA_character_)) 
[17:41:00.600]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.600]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.600]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.600]                     .init = FALSE)
[17:41:00.600]                 }
[17:41:00.600]             }
[17:41:00.600]         }
[17:41:00.600]     })
[17:41:00.600]     if (TRUE) {
[17:41:00.600]         base::sink(type = "output", split = FALSE)
[17:41:00.600]         if (TRUE) {
[17:41:00.600]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.600]         }
[17:41:00.600]         else {
[17:41:00.600]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.600]         }
[17:41:00.600]         base::close(...future.stdout)
[17:41:00.600]         ...future.stdout <- NULL
[17:41:00.600]     }
[17:41:00.600]     ...future.result$conditions <- ...future.conditions
[17:41:00.600]     ...future.result$finished <- base::Sys.time()
[17:41:00.600]     ...future.result
[17:41:00.600] }
[17:41:00.603] MultisessionFuture started
[17:41:00.603] - Launch lazy future ... done
[17:41:00.603] run() for ‘MultisessionFuture’ ... done
[17:41:00.603] getGlobalsAndPackages() ...
[17:41:00.603] Searching for globals...
[17:41:00.603] 
[17:41:00.603] Searching for globals ... DONE
[17:41:00.604] - globals: [0] <none>
[17:41:00.604] getGlobalsAndPackages() ... DONE
[17:41:00.604] run() for ‘Future’ ...
[17:41:00.604] - state: ‘created’
[17:41:00.604] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.618]   - Field: ‘node’
[17:41:00.618]   - Field: ‘label’
[17:41:00.618]   - Field: ‘local’
[17:41:00.618]   - Field: ‘owner’
[17:41:00.618]   - Field: ‘envir’
[17:41:00.618]   - Field: ‘workers’
[17:41:00.618]   - Field: ‘packages’
[17:41:00.618]   - Field: ‘gc’
[17:41:00.618]   - Field: ‘conditions’
[17:41:00.618]   - Field: ‘persistent’
[17:41:00.618]   - Field: ‘expr’
[17:41:00.619]   - Field: ‘uuid’
[17:41:00.619]   - Field: ‘seed’
[17:41:00.619]   - Field: ‘version’
[17:41:00.619]   - Field: ‘result’
[17:41:00.619]   - Field: ‘asynchronous’
[17:41:00.619]   - Field: ‘calls’
[17:41:00.619]   - Field: ‘globals’
[17:41:00.619]   - Field: ‘stdout’
[17:41:00.619]   - Field: ‘earlySignal’
[17:41:00.619]   - Field: ‘lazy’
[17:41:00.619]   - Field: ‘state’
[17:41:00.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.620] - Launch lazy future ...
[17:41:00.620] Packages needed by the future expression (n = 0): <none>
[17:41:00.620] Packages needed by future strategies (n = 0): <none>
[17:41:00.620] {
[17:41:00.620]     {
[17:41:00.620]         {
[17:41:00.620]             ...future.startTime <- base::Sys.time()
[17:41:00.620]             {
[17:41:00.620]                 {
[17:41:00.620]                   {
[17:41:00.620]                     {
[17:41:00.620]                       base::local({
[17:41:00.620]                         has_future <- base::requireNamespace("future", 
[17:41:00.620]                           quietly = TRUE)
[17:41:00.620]                         if (has_future) {
[17:41:00.620]                           ns <- base::getNamespace("future")
[17:41:00.620]                           version <- ns[[".package"]][["version"]]
[17:41:00.620]                           if (is.null(version)) 
[17:41:00.620]                             version <- utils::packageVersion("future")
[17:41:00.620]                         }
[17:41:00.620]                         else {
[17:41:00.620]                           version <- NULL
[17:41:00.620]                         }
[17:41:00.620]                         if (!has_future || version < "1.8.0") {
[17:41:00.620]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.620]                             "", base::R.version$version.string), 
[17:41:00.620]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.620]                               "release", "version")], collapse = " "), 
[17:41:00.620]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.620]                             info)
[17:41:00.620]                           info <- base::paste(info, collapse = "; ")
[17:41:00.620]                           if (!has_future) {
[17:41:00.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.620]                               info)
[17:41:00.620]                           }
[17:41:00.620]                           else {
[17:41:00.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.620]                               info, version)
[17:41:00.620]                           }
[17:41:00.620]                           base::stop(msg)
[17:41:00.620]                         }
[17:41:00.620]                       })
[17:41:00.620]                     }
[17:41:00.620]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.620]                     base::options(mc.cores = 1L)
[17:41:00.620]                   }
[17:41:00.620]                   ...future.strategy.old <- future::plan("list")
[17:41:00.620]                   options(future.plan = NULL)
[17:41:00.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.620]                 }
[17:41:00.620]                 ...future.workdir <- getwd()
[17:41:00.620]             }
[17:41:00.620]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.620]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.620]         }
[17:41:00.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.620]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.620]             base::names(...future.oldOptions))
[17:41:00.620]     }
[17:41:00.620]     if (FALSE) {
[17:41:00.620]     }
[17:41:00.620]     else {
[17:41:00.620]         if (TRUE) {
[17:41:00.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.620]                 open = "w")
[17:41:00.620]         }
[17:41:00.620]         else {
[17:41:00.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.620]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.620]         }
[17:41:00.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.620]             base::sink(type = "output", split = FALSE)
[17:41:00.620]             base::close(...future.stdout)
[17:41:00.620]         }, add = TRUE)
[17:41:00.620]     }
[17:41:00.620]     ...future.frame <- base::sys.nframe()
[17:41:00.620]     ...future.conditions <- base::list()
[17:41:00.620]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.620]     if (FALSE) {
[17:41:00.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.620]     }
[17:41:00.620]     ...future.result <- base::tryCatch({
[17:41:00.620]         base::withCallingHandlers({
[17:41:00.620]             ...future.value <- base::withVisible(base::local({
[17:41:00.620]                 ...future.makeSendCondition <- base::local({
[17:41:00.620]                   sendCondition <- NULL
[17:41:00.620]                   function(frame = 1L) {
[17:41:00.620]                     if (is.function(sendCondition)) 
[17:41:00.620]                       return(sendCondition)
[17:41:00.620]                     ns <- getNamespace("parallel")
[17:41:00.620]                     if (exists("sendData", mode = "function", 
[17:41:00.620]                       envir = ns)) {
[17:41:00.620]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.620]                         envir = ns)
[17:41:00.620]                       envir <- sys.frame(frame)
[17:41:00.620]                       master <- NULL
[17:41:00.620]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.620]                         !identical(envir, emptyenv())) {
[17:41:00.620]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.620]                           inherits = FALSE)) {
[17:41:00.620]                           master <- get("master", mode = "list", 
[17:41:00.620]                             envir = envir, inherits = FALSE)
[17:41:00.620]                           if (inherits(master, c("SOCKnode", 
[17:41:00.620]                             "SOCK0node"))) {
[17:41:00.620]                             sendCondition <<- function(cond) {
[17:41:00.620]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.620]                                 success = TRUE)
[17:41:00.620]                               parallel_sendData(master, data)
[17:41:00.620]                             }
[17:41:00.620]                             return(sendCondition)
[17:41:00.620]                           }
[17:41:00.620]                         }
[17:41:00.620]                         frame <- frame + 1L
[17:41:00.620]                         envir <- sys.frame(frame)
[17:41:00.620]                       }
[17:41:00.620]                     }
[17:41:00.620]                     sendCondition <<- function(cond) NULL
[17:41:00.620]                   }
[17:41:00.620]                 })
[17:41:00.620]                 withCallingHandlers({
[17:41:00.620]                   2
[17:41:00.620]                 }, immediateCondition = function(cond) {
[17:41:00.620]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.620]                   sendCondition(cond)
[17:41:00.620]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.620]                   {
[17:41:00.620]                     inherits <- base::inherits
[17:41:00.620]                     invokeRestart <- base::invokeRestart
[17:41:00.620]                     is.null <- base::is.null
[17:41:00.620]                     muffled <- FALSE
[17:41:00.620]                     if (inherits(cond, "message")) {
[17:41:00.620]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.620]                       if (muffled) 
[17:41:00.620]                         invokeRestart("muffleMessage")
[17:41:00.620]                     }
[17:41:00.620]                     else if (inherits(cond, "warning")) {
[17:41:00.620]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.620]                       if (muffled) 
[17:41:00.620]                         invokeRestart("muffleWarning")
[17:41:00.620]                     }
[17:41:00.620]                     else if (inherits(cond, "condition")) {
[17:41:00.620]                       if (!is.null(pattern)) {
[17:41:00.620]                         computeRestarts <- base::computeRestarts
[17:41:00.620]                         grepl <- base::grepl
[17:41:00.620]                         restarts <- computeRestarts(cond)
[17:41:00.620]                         for (restart in restarts) {
[17:41:00.620]                           name <- restart$name
[17:41:00.620]                           if (is.null(name)) 
[17:41:00.620]                             next
[17:41:00.620]                           if (!grepl(pattern, name)) 
[17:41:00.620]                             next
[17:41:00.620]                           invokeRestart(restart)
[17:41:00.620]                           muffled <- TRUE
[17:41:00.620]                           break
[17:41:00.620]                         }
[17:41:00.620]                       }
[17:41:00.620]                     }
[17:41:00.620]                     invisible(muffled)
[17:41:00.620]                   }
[17:41:00.620]                   muffleCondition(cond)
[17:41:00.620]                 })
[17:41:00.620]             }))
[17:41:00.620]             future::FutureResult(value = ...future.value$value, 
[17:41:00.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.620]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.620]                     ...future.globalenv.names))
[17:41:00.620]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.620]         }, condition = base::local({
[17:41:00.620]             c <- base::c
[17:41:00.620]             inherits <- base::inherits
[17:41:00.620]             invokeRestart <- base::invokeRestart
[17:41:00.620]             length <- base::length
[17:41:00.620]             list <- base::list
[17:41:00.620]             seq.int <- base::seq.int
[17:41:00.620]             signalCondition <- base::signalCondition
[17:41:00.620]             sys.calls <- base::sys.calls
[17:41:00.620]             `[[` <- base::`[[`
[17:41:00.620]             `+` <- base::`+`
[17:41:00.620]             `<<-` <- base::`<<-`
[17:41:00.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.620]                   3L)]
[17:41:00.620]             }
[17:41:00.620]             function(cond) {
[17:41:00.620]                 is_error <- inherits(cond, "error")
[17:41:00.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.620]                   NULL)
[17:41:00.620]                 if (is_error) {
[17:41:00.620]                   sessionInformation <- function() {
[17:41:00.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.620]                       search = base::search(), system = base::Sys.info())
[17:41:00.620]                   }
[17:41:00.620]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.620]                     cond$call), session = sessionInformation(), 
[17:41:00.620]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.620]                   signalCondition(cond)
[17:41:00.620]                 }
[17:41:00.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.620]                 "immediateCondition"))) {
[17:41:00.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.620]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.620]                   if (TRUE && !signal) {
[17:41:00.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.620]                     {
[17:41:00.620]                       inherits <- base::inherits
[17:41:00.620]                       invokeRestart <- base::invokeRestart
[17:41:00.620]                       is.null <- base::is.null
[17:41:00.620]                       muffled <- FALSE
[17:41:00.620]                       if (inherits(cond, "message")) {
[17:41:00.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.620]                         if (muffled) 
[17:41:00.620]                           invokeRestart("muffleMessage")
[17:41:00.620]                       }
[17:41:00.620]                       else if (inherits(cond, "warning")) {
[17:41:00.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.620]                         if (muffled) 
[17:41:00.620]                           invokeRestart("muffleWarning")
[17:41:00.620]                       }
[17:41:00.620]                       else if (inherits(cond, "condition")) {
[17:41:00.620]                         if (!is.null(pattern)) {
[17:41:00.620]                           computeRestarts <- base::computeRestarts
[17:41:00.620]                           grepl <- base::grepl
[17:41:00.620]                           restarts <- computeRestarts(cond)
[17:41:00.620]                           for (restart in restarts) {
[17:41:00.620]                             name <- restart$name
[17:41:00.620]                             if (is.null(name)) 
[17:41:00.620]                               next
[17:41:00.620]                             if (!grepl(pattern, name)) 
[17:41:00.620]                               next
[17:41:00.620]                             invokeRestart(restart)
[17:41:00.620]                             muffled <- TRUE
[17:41:00.620]                             break
[17:41:00.620]                           }
[17:41:00.620]                         }
[17:41:00.620]                       }
[17:41:00.620]                       invisible(muffled)
[17:41:00.620]                     }
[17:41:00.620]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.620]                   }
[17:41:00.620]                 }
[17:41:00.620]                 else {
[17:41:00.620]                   if (TRUE) {
[17:41:00.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.620]                     {
[17:41:00.620]                       inherits <- base::inherits
[17:41:00.620]                       invokeRestart <- base::invokeRestart
[17:41:00.620]                       is.null <- base::is.null
[17:41:00.620]                       muffled <- FALSE
[17:41:00.620]                       if (inherits(cond, "message")) {
[17:41:00.620]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.620]                         if (muffled) 
[17:41:00.620]                           invokeRestart("muffleMessage")
[17:41:00.620]                       }
[17:41:00.620]                       else if (inherits(cond, "warning")) {
[17:41:00.620]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.620]                         if (muffled) 
[17:41:00.620]                           invokeRestart("muffleWarning")
[17:41:00.620]                       }
[17:41:00.620]                       else if (inherits(cond, "condition")) {
[17:41:00.620]                         if (!is.null(pattern)) {
[17:41:00.620]                           computeRestarts <- base::computeRestarts
[17:41:00.620]                           grepl <- base::grepl
[17:41:00.620]                           restarts <- computeRestarts(cond)
[17:41:00.620]                           for (restart in restarts) {
[17:41:00.620]                             name <- restart$name
[17:41:00.620]                             if (is.null(name)) 
[17:41:00.620]                               next
[17:41:00.620]                             if (!grepl(pattern, name)) 
[17:41:00.620]                               next
[17:41:00.620]                             invokeRestart(restart)
[17:41:00.620]                             muffled <- TRUE
[17:41:00.620]                             break
[17:41:00.620]                           }
[17:41:00.620]                         }
[17:41:00.620]                       }
[17:41:00.620]                       invisible(muffled)
[17:41:00.620]                     }
[17:41:00.620]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.620]                   }
[17:41:00.620]                 }
[17:41:00.620]             }
[17:41:00.620]         }))
[17:41:00.620]     }, error = function(ex) {
[17:41:00.620]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.620]                 ...future.rng), started = ...future.startTime, 
[17:41:00.620]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.620]             version = "1.8"), class = "FutureResult")
[17:41:00.620]     }, finally = {
[17:41:00.620]         if (!identical(...future.workdir, getwd())) 
[17:41:00.620]             setwd(...future.workdir)
[17:41:00.620]         {
[17:41:00.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.620]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.620]             }
[17:41:00.620]             base::options(...future.oldOptions)
[17:41:00.620]             if (.Platform$OS.type == "windows") {
[17:41:00.620]                 old_names <- names(...future.oldEnvVars)
[17:41:00.620]                 envs <- base::Sys.getenv()
[17:41:00.620]                 names <- names(envs)
[17:41:00.620]                 common <- intersect(names, old_names)
[17:41:00.620]                 added <- setdiff(names, old_names)
[17:41:00.620]                 removed <- setdiff(old_names, names)
[17:41:00.620]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.620]                   envs[common]]
[17:41:00.620]                 NAMES <- toupper(changed)
[17:41:00.620]                 args <- list()
[17:41:00.620]                 for (kk in seq_along(NAMES)) {
[17:41:00.620]                   name <- changed[[kk]]
[17:41:00.620]                   NAME <- NAMES[[kk]]
[17:41:00.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.620]                     next
[17:41:00.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.620]                 }
[17:41:00.620]                 NAMES <- toupper(added)
[17:41:00.620]                 for (kk in seq_along(NAMES)) {
[17:41:00.620]                   name <- added[[kk]]
[17:41:00.620]                   NAME <- NAMES[[kk]]
[17:41:00.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.620]                     next
[17:41:00.620]                   args[[name]] <- ""
[17:41:00.620]                 }
[17:41:00.620]                 NAMES <- toupper(removed)
[17:41:00.620]                 for (kk in seq_along(NAMES)) {
[17:41:00.620]                   name <- removed[[kk]]
[17:41:00.620]                   NAME <- NAMES[[kk]]
[17:41:00.620]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.620]                     next
[17:41:00.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.620]                 }
[17:41:00.620]                 if (length(args) > 0) 
[17:41:00.620]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.620]             }
[17:41:00.620]             else {
[17:41:00.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.620]             }
[17:41:00.620]             {
[17:41:00.620]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.620]                   0L) {
[17:41:00.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.620]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.620]                   base::options(opts)
[17:41:00.620]                 }
[17:41:00.620]                 {
[17:41:00.620]                   {
[17:41:00.620]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.620]                     NULL
[17:41:00.620]                   }
[17:41:00.620]                   options(future.plan = NULL)
[17:41:00.620]                   if (is.na(NA_character_)) 
[17:41:00.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.620]                     .init = FALSE)
[17:41:00.620]                 }
[17:41:00.620]             }
[17:41:00.620]         }
[17:41:00.620]     })
[17:41:00.620]     if (TRUE) {
[17:41:00.620]         base::sink(type = "output", split = FALSE)
[17:41:00.620]         if (TRUE) {
[17:41:00.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.620]         }
[17:41:00.620]         else {
[17:41:00.620]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.620]         }
[17:41:00.620]         base::close(...future.stdout)
[17:41:00.620]         ...future.stdout <- NULL
[17:41:00.620]     }
[17:41:00.620]     ...future.result$conditions <- ...future.conditions
[17:41:00.620]     ...future.result$finished <- base::Sys.time()
[17:41:00.620]     ...future.result
[17:41:00.620] }
[17:41:00.623] MultisessionFuture started
[17:41:00.623] - Launch lazy future ... done
[17:41:00.624] run() for ‘MultisessionFuture’ ... done
[17:41:00.624] resolve() on list environment ...
[17:41:00.625]  recursive: 0
[17:41:00.625]  length: 3
[17:41:00.626]  elements: ‘a’, ‘b’, ‘c’
[17:41:00.626] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.626] - Validating connection of MultisessionFuture
[17:41:00.626] - received message: FutureResult
[17:41:00.626] - Received FutureResult
[17:41:00.627] - Erased future from FutureRegistry
[17:41:00.627] result() for ClusterFuture ...
[17:41:00.627] - result already collected: FutureResult
[17:41:00.627] result() for ClusterFuture ... done
[17:41:00.627] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.627] Future #1
[17:41:00.627]  length: 2 (resolved future 1)
[17:41:00.628] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.628] - Validating connection of MultisessionFuture
[17:41:00.628] - received message: FutureResult
[17:41:00.628] - Received FutureResult
[17:41:00.628] - Erased future from FutureRegistry
[17:41:00.628] result() for ClusterFuture ...
[17:41:00.628] - result already collected: FutureResult
[17:41:00.628] result() for ClusterFuture ... done
[17:41:00.628] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.629] Future #2
[17:41:00.629]  length: 1 (resolved future 2)
[17:41:00.629]  length: 0 (resolved future 3)
[17:41:00.629] resolve() on list environment ... DONE
[17:41:00.629] getGlobalsAndPackages() ...
[17:41:00.630] Searching for globals...
[17:41:00.630] - globals found: [1] ‘{’
[17:41:00.630] Searching for globals ... DONE
[17:41:00.630] Resolving globals: FALSE
[17:41:00.631] 
[17:41:00.631] 
[17:41:00.631] getGlobalsAndPackages() ... DONE
[17:41:00.631] run() for ‘Future’ ...
[17:41:00.631] - state: ‘created’
[17:41:00.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.645] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.645]   - Field: ‘node’
[17:41:00.645]   - Field: ‘label’
[17:41:00.645]   - Field: ‘local’
[17:41:00.645]   - Field: ‘owner’
[17:41:00.645]   - Field: ‘envir’
[17:41:00.645]   - Field: ‘workers’
[17:41:00.645]   - Field: ‘packages’
[17:41:00.645]   - Field: ‘gc’
[17:41:00.646]   - Field: ‘conditions’
[17:41:00.646]   - Field: ‘persistent’
[17:41:00.646]   - Field: ‘expr’
[17:41:00.646]   - Field: ‘uuid’
[17:41:00.646]   - Field: ‘seed’
[17:41:00.646]   - Field: ‘version’
[17:41:00.646]   - Field: ‘result’
[17:41:00.646]   - Field: ‘asynchronous’
[17:41:00.646]   - Field: ‘calls’
[17:41:00.646]   - Field: ‘globals’
[17:41:00.646]   - Field: ‘stdout’
[17:41:00.646]   - Field: ‘earlySignal’
[17:41:00.647]   - Field: ‘lazy’
[17:41:00.647]   - Field: ‘state’
[17:41:00.647] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.647] - Launch lazy future ...
[17:41:00.647] Packages needed by the future expression (n = 0): <none>
[17:41:00.647] Packages needed by future strategies (n = 0): <none>
[17:41:00.648] {
[17:41:00.648]     {
[17:41:00.648]         {
[17:41:00.648]             ...future.startTime <- base::Sys.time()
[17:41:00.648]             {
[17:41:00.648]                 {
[17:41:00.648]                   {
[17:41:00.648]                     {
[17:41:00.648]                       base::local({
[17:41:00.648]                         has_future <- base::requireNamespace("future", 
[17:41:00.648]                           quietly = TRUE)
[17:41:00.648]                         if (has_future) {
[17:41:00.648]                           ns <- base::getNamespace("future")
[17:41:00.648]                           version <- ns[[".package"]][["version"]]
[17:41:00.648]                           if (is.null(version)) 
[17:41:00.648]                             version <- utils::packageVersion("future")
[17:41:00.648]                         }
[17:41:00.648]                         else {
[17:41:00.648]                           version <- NULL
[17:41:00.648]                         }
[17:41:00.648]                         if (!has_future || version < "1.8.0") {
[17:41:00.648]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.648]                             "", base::R.version$version.string), 
[17:41:00.648]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.648]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.648]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.648]                               "release", "version")], collapse = " "), 
[17:41:00.648]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.648]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.648]                             info)
[17:41:00.648]                           info <- base::paste(info, collapse = "; ")
[17:41:00.648]                           if (!has_future) {
[17:41:00.648]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.648]                               info)
[17:41:00.648]                           }
[17:41:00.648]                           else {
[17:41:00.648]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.648]                               info, version)
[17:41:00.648]                           }
[17:41:00.648]                           base::stop(msg)
[17:41:00.648]                         }
[17:41:00.648]                       })
[17:41:00.648]                     }
[17:41:00.648]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.648]                     base::options(mc.cores = 1L)
[17:41:00.648]                   }
[17:41:00.648]                   ...future.strategy.old <- future::plan("list")
[17:41:00.648]                   options(future.plan = NULL)
[17:41:00.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.648]                 }
[17:41:00.648]                 ...future.workdir <- getwd()
[17:41:00.648]             }
[17:41:00.648]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.648]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.648]         }
[17:41:00.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.648]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.648]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.648]             base::names(...future.oldOptions))
[17:41:00.648]     }
[17:41:00.648]     if (FALSE) {
[17:41:00.648]     }
[17:41:00.648]     else {
[17:41:00.648]         if (TRUE) {
[17:41:00.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.648]                 open = "w")
[17:41:00.648]         }
[17:41:00.648]         else {
[17:41:00.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.648]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.648]         }
[17:41:00.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.648]             base::sink(type = "output", split = FALSE)
[17:41:00.648]             base::close(...future.stdout)
[17:41:00.648]         }, add = TRUE)
[17:41:00.648]     }
[17:41:00.648]     ...future.frame <- base::sys.nframe()
[17:41:00.648]     ...future.conditions <- base::list()
[17:41:00.648]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.648]     if (FALSE) {
[17:41:00.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.648]     }
[17:41:00.648]     ...future.result <- base::tryCatch({
[17:41:00.648]         base::withCallingHandlers({
[17:41:00.648]             ...future.value <- base::withVisible(base::local({
[17:41:00.648]                 ...future.makeSendCondition <- base::local({
[17:41:00.648]                   sendCondition <- NULL
[17:41:00.648]                   function(frame = 1L) {
[17:41:00.648]                     if (is.function(sendCondition)) 
[17:41:00.648]                       return(sendCondition)
[17:41:00.648]                     ns <- getNamespace("parallel")
[17:41:00.648]                     if (exists("sendData", mode = "function", 
[17:41:00.648]                       envir = ns)) {
[17:41:00.648]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.648]                         envir = ns)
[17:41:00.648]                       envir <- sys.frame(frame)
[17:41:00.648]                       master <- NULL
[17:41:00.648]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.648]                         !identical(envir, emptyenv())) {
[17:41:00.648]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.648]                           inherits = FALSE)) {
[17:41:00.648]                           master <- get("master", mode = "list", 
[17:41:00.648]                             envir = envir, inherits = FALSE)
[17:41:00.648]                           if (inherits(master, c("SOCKnode", 
[17:41:00.648]                             "SOCK0node"))) {
[17:41:00.648]                             sendCondition <<- function(cond) {
[17:41:00.648]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.648]                                 success = TRUE)
[17:41:00.648]                               parallel_sendData(master, data)
[17:41:00.648]                             }
[17:41:00.648]                             return(sendCondition)
[17:41:00.648]                           }
[17:41:00.648]                         }
[17:41:00.648]                         frame <- frame + 1L
[17:41:00.648]                         envir <- sys.frame(frame)
[17:41:00.648]                       }
[17:41:00.648]                     }
[17:41:00.648]                     sendCondition <<- function(cond) NULL
[17:41:00.648]                   }
[17:41:00.648]                 })
[17:41:00.648]                 withCallingHandlers({
[17:41:00.648]                   {
[17:41:00.648]                     1
[17:41:00.648]                   }
[17:41:00.648]                 }, immediateCondition = function(cond) {
[17:41:00.648]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.648]                   sendCondition(cond)
[17:41:00.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.648]                   {
[17:41:00.648]                     inherits <- base::inherits
[17:41:00.648]                     invokeRestart <- base::invokeRestart
[17:41:00.648]                     is.null <- base::is.null
[17:41:00.648]                     muffled <- FALSE
[17:41:00.648]                     if (inherits(cond, "message")) {
[17:41:00.648]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.648]                       if (muffled) 
[17:41:00.648]                         invokeRestart("muffleMessage")
[17:41:00.648]                     }
[17:41:00.648]                     else if (inherits(cond, "warning")) {
[17:41:00.648]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.648]                       if (muffled) 
[17:41:00.648]                         invokeRestart("muffleWarning")
[17:41:00.648]                     }
[17:41:00.648]                     else if (inherits(cond, "condition")) {
[17:41:00.648]                       if (!is.null(pattern)) {
[17:41:00.648]                         computeRestarts <- base::computeRestarts
[17:41:00.648]                         grepl <- base::grepl
[17:41:00.648]                         restarts <- computeRestarts(cond)
[17:41:00.648]                         for (restart in restarts) {
[17:41:00.648]                           name <- restart$name
[17:41:00.648]                           if (is.null(name)) 
[17:41:00.648]                             next
[17:41:00.648]                           if (!grepl(pattern, name)) 
[17:41:00.648]                             next
[17:41:00.648]                           invokeRestart(restart)
[17:41:00.648]                           muffled <- TRUE
[17:41:00.648]                           break
[17:41:00.648]                         }
[17:41:00.648]                       }
[17:41:00.648]                     }
[17:41:00.648]                     invisible(muffled)
[17:41:00.648]                   }
[17:41:00.648]                   muffleCondition(cond)
[17:41:00.648]                 })
[17:41:00.648]             }))
[17:41:00.648]             future::FutureResult(value = ...future.value$value, 
[17:41:00.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.648]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.648]                     ...future.globalenv.names))
[17:41:00.648]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.648]         }, condition = base::local({
[17:41:00.648]             c <- base::c
[17:41:00.648]             inherits <- base::inherits
[17:41:00.648]             invokeRestart <- base::invokeRestart
[17:41:00.648]             length <- base::length
[17:41:00.648]             list <- base::list
[17:41:00.648]             seq.int <- base::seq.int
[17:41:00.648]             signalCondition <- base::signalCondition
[17:41:00.648]             sys.calls <- base::sys.calls
[17:41:00.648]             `[[` <- base::`[[`
[17:41:00.648]             `+` <- base::`+`
[17:41:00.648]             `<<-` <- base::`<<-`
[17:41:00.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.648]                   3L)]
[17:41:00.648]             }
[17:41:00.648]             function(cond) {
[17:41:00.648]                 is_error <- inherits(cond, "error")
[17:41:00.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.648]                   NULL)
[17:41:00.648]                 if (is_error) {
[17:41:00.648]                   sessionInformation <- function() {
[17:41:00.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.648]                       search = base::search(), system = base::Sys.info())
[17:41:00.648]                   }
[17:41:00.648]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.648]                     cond$call), session = sessionInformation(), 
[17:41:00.648]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.648]                   signalCondition(cond)
[17:41:00.648]                 }
[17:41:00.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.648]                 "immediateCondition"))) {
[17:41:00.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.648]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.648]                   if (TRUE && !signal) {
[17:41:00.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.648]                     {
[17:41:00.648]                       inherits <- base::inherits
[17:41:00.648]                       invokeRestart <- base::invokeRestart
[17:41:00.648]                       is.null <- base::is.null
[17:41:00.648]                       muffled <- FALSE
[17:41:00.648]                       if (inherits(cond, "message")) {
[17:41:00.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.648]                         if (muffled) 
[17:41:00.648]                           invokeRestart("muffleMessage")
[17:41:00.648]                       }
[17:41:00.648]                       else if (inherits(cond, "warning")) {
[17:41:00.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.648]                         if (muffled) 
[17:41:00.648]                           invokeRestart("muffleWarning")
[17:41:00.648]                       }
[17:41:00.648]                       else if (inherits(cond, "condition")) {
[17:41:00.648]                         if (!is.null(pattern)) {
[17:41:00.648]                           computeRestarts <- base::computeRestarts
[17:41:00.648]                           grepl <- base::grepl
[17:41:00.648]                           restarts <- computeRestarts(cond)
[17:41:00.648]                           for (restart in restarts) {
[17:41:00.648]                             name <- restart$name
[17:41:00.648]                             if (is.null(name)) 
[17:41:00.648]                               next
[17:41:00.648]                             if (!grepl(pattern, name)) 
[17:41:00.648]                               next
[17:41:00.648]                             invokeRestart(restart)
[17:41:00.648]                             muffled <- TRUE
[17:41:00.648]                             break
[17:41:00.648]                           }
[17:41:00.648]                         }
[17:41:00.648]                       }
[17:41:00.648]                       invisible(muffled)
[17:41:00.648]                     }
[17:41:00.648]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.648]                   }
[17:41:00.648]                 }
[17:41:00.648]                 else {
[17:41:00.648]                   if (TRUE) {
[17:41:00.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.648]                     {
[17:41:00.648]                       inherits <- base::inherits
[17:41:00.648]                       invokeRestart <- base::invokeRestart
[17:41:00.648]                       is.null <- base::is.null
[17:41:00.648]                       muffled <- FALSE
[17:41:00.648]                       if (inherits(cond, "message")) {
[17:41:00.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.648]                         if (muffled) 
[17:41:00.648]                           invokeRestart("muffleMessage")
[17:41:00.648]                       }
[17:41:00.648]                       else if (inherits(cond, "warning")) {
[17:41:00.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.648]                         if (muffled) 
[17:41:00.648]                           invokeRestart("muffleWarning")
[17:41:00.648]                       }
[17:41:00.648]                       else if (inherits(cond, "condition")) {
[17:41:00.648]                         if (!is.null(pattern)) {
[17:41:00.648]                           computeRestarts <- base::computeRestarts
[17:41:00.648]                           grepl <- base::grepl
[17:41:00.648]                           restarts <- computeRestarts(cond)
[17:41:00.648]                           for (restart in restarts) {
[17:41:00.648]                             name <- restart$name
[17:41:00.648]                             if (is.null(name)) 
[17:41:00.648]                               next
[17:41:00.648]                             if (!grepl(pattern, name)) 
[17:41:00.648]                               next
[17:41:00.648]                             invokeRestart(restart)
[17:41:00.648]                             muffled <- TRUE
[17:41:00.648]                             break
[17:41:00.648]                           }
[17:41:00.648]                         }
[17:41:00.648]                       }
[17:41:00.648]                       invisible(muffled)
[17:41:00.648]                     }
[17:41:00.648]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.648]                   }
[17:41:00.648]                 }
[17:41:00.648]             }
[17:41:00.648]         }))
[17:41:00.648]     }, error = function(ex) {
[17:41:00.648]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.648]                 ...future.rng), started = ...future.startTime, 
[17:41:00.648]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.648]             version = "1.8"), class = "FutureResult")
[17:41:00.648]     }, finally = {
[17:41:00.648]         if (!identical(...future.workdir, getwd())) 
[17:41:00.648]             setwd(...future.workdir)
[17:41:00.648]         {
[17:41:00.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.648]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.648]             }
[17:41:00.648]             base::options(...future.oldOptions)
[17:41:00.648]             if (.Platform$OS.type == "windows") {
[17:41:00.648]                 old_names <- names(...future.oldEnvVars)
[17:41:00.648]                 envs <- base::Sys.getenv()
[17:41:00.648]                 names <- names(envs)
[17:41:00.648]                 common <- intersect(names, old_names)
[17:41:00.648]                 added <- setdiff(names, old_names)
[17:41:00.648]                 removed <- setdiff(old_names, names)
[17:41:00.648]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.648]                   envs[common]]
[17:41:00.648]                 NAMES <- toupper(changed)
[17:41:00.648]                 args <- list()
[17:41:00.648]                 for (kk in seq_along(NAMES)) {
[17:41:00.648]                   name <- changed[[kk]]
[17:41:00.648]                   NAME <- NAMES[[kk]]
[17:41:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.648]                     next
[17:41:00.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.648]                 }
[17:41:00.648]                 NAMES <- toupper(added)
[17:41:00.648]                 for (kk in seq_along(NAMES)) {
[17:41:00.648]                   name <- added[[kk]]
[17:41:00.648]                   NAME <- NAMES[[kk]]
[17:41:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.648]                     next
[17:41:00.648]                   args[[name]] <- ""
[17:41:00.648]                 }
[17:41:00.648]                 NAMES <- toupper(removed)
[17:41:00.648]                 for (kk in seq_along(NAMES)) {
[17:41:00.648]                   name <- removed[[kk]]
[17:41:00.648]                   NAME <- NAMES[[kk]]
[17:41:00.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.648]                     next
[17:41:00.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.648]                 }
[17:41:00.648]                 if (length(args) > 0) 
[17:41:00.648]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.648]             }
[17:41:00.648]             else {
[17:41:00.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.648]             }
[17:41:00.648]             {
[17:41:00.648]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.648]                   0L) {
[17:41:00.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.648]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.648]                   base::options(opts)
[17:41:00.648]                 }
[17:41:00.648]                 {
[17:41:00.648]                   {
[17:41:00.648]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.648]                     NULL
[17:41:00.648]                   }
[17:41:00.648]                   options(future.plan = NULL)
[17:41:00.648]                   if (is.na(NA_character_)) 
[17:41:00.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.648]                     .init = FALSE)
[17:41:00.648]                 }
[17:41:00.648]             }
[17:41:00.648]         }
[17:41:00.648]     })
[17:41:00.648]     if (TRUE) {
[17:41:00.648]         base::sink(type = "output", split = FALSE)
[17:41:00.648]         if (TRUE) {
[17:41:00.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.648]         }
[17:41:00.648]         else {
[17:41:00.648]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.648]         }
[17:41:00.648]         base::close(...future.stdout)
[17:41:00.648]         ...future.stdout <- NULL
[17:41:00.648]     }
[17:41:00.648]     ...future.result$conditions <- ...future.conditions
[17:41:00.648]     ...future.result$finished <- base::Sys.time()
[17:41:00.648]     ...future.result
[17:41:00.648] }
[17:41:00.650] MultisessionFuture started
[17:41:00.651] - Launch lazy future ... done
[17:41:00.651] run() for ‘MultisessionFuture’ ... done
[17:41:00.651] getGlobalsAndPackages() ...
[17:41:00.651] Searching for globals...
[17:41:00.652] - globals found: [1] ‘{’
[17:41:00.653] Searching for globals ... DONE
[17:41:00.653] Resolving globals: FALSE
[17:41:00.653] 
[17:41:00.653] 
[17:41:00.653] getGlobalsAndPackages() ... DONE
[17:41:00.653] run() for ‘Future’ ...
[17:41:00.653] - state: ‘created’
[17:41:00.654] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.674] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.674] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.674]   - Field: ‘node’
[17:41:00.674]   - Field: ‘label’
[17:41:00.674]   - Field: ‘local’
[17:41:00.674]   - Field: ‘owner’
[17:41:00.674]   - Field: ‘envir’
[17:41:00.674]   - Field: ‘workers’
[17:41:00.675]   - Field: ‘packages’
[17:41:00.675]   - Field: ‘gc’
[17:41:00.675]   - Field: ‘conditions’
[17:41:00.675]   - Field: ‘persistent’
[17:41:00.675]   - Field: ‘expr’
[17:41:00.675]   - Field: ‘uuid’
[17:41:00.675]   - Field: ‘seed’
[17:41:00.675]   - Field: ‘version’
[17:41:00.675]   - Field: ‘result’
[17:41:00.675]   - Field: ‘asynchronous’
[17:41:00.675]   - Field: ‘calls’
[17:41:00.676]   - Field: ‘globals’
[17:41:00.676]   - Field: ‘stdout’
[17:41:00.676]   - Field: ‘earlySignal’
[17:41:00.676]   - Field: ‘lazy’
[17:41:00.676]   - Field: ‘state’
[17:41:00.676] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.676] - Launch lazy future ...
[17:41:00.676] Packages needed by the future expression (n = 0): <none>
[17:41:00.676] Packages needed by future strategies (n = 0): <none>
[17:41:00.677] {
[17:41:00.677]     {
[17:41:00.677]         {
[17:41:00.677]             ...future.startTime <- base::Sys.time()
[17:41:00.677]             {
[17:41:00.677]                 {
[17:41:00.677]                   {
[17:41:00.677]                     {
[17:41:00.677]                       base::local({
[17:41:00.677]                         has_future <- base::requireNamespace("future", 
[17:41:00.677]                           quietly = TRUE)
[17:41:00.677]                         if (has_future) {
[17:41:00.677]                           ns <- base::getNamespace("future")
[17:41:00.677]                           version <- ns[[".package"]][["version"]]
[17:41:00.677]                           if (is.null(version)) 
[17:41:00.677]                             version <- utils::packageVersion("future")
[17:41:00.677]                         }
[17:41:00.677]                         else {
[17:41:00.677]                           version <- NULL
[17:41:00.677]                         }
[17:41:00.677]                         if (!has_future || version < "1.8.0") {
[17:41:00.677]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.677]                             "", base::R.version$version.string), 
[17:41:00.677]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.677]                               "release", "version")], collapse = " "), 
[17:41:00.677]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.677]                             info)
[17:41:00.677]                           info <- base::paste(info, collapse = "; ")
[17:41:00.677]                           if (!has_future) {
[17:41:00.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.677]                               info)
[17:41:00.677]                           }
[17:41:00.677]                           else {
[17:41:00.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.677]                               info, version)
[17:41:00.677]                           }
[17:41:00.677]                           base::stop(msg)
[17:41:00.677]                         }
[17:41:00.677]                       })
[17:41:00.677]                     }
[17:41:00.677]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.677]                     base::options(mc.cores = 1L)
[17:41:00.677]                   }
[17:41:00.677]                   ...future.strategy.old <- future::plan("list")
[17:41:00.677]                   options(future.plan = NULL)
[17:41:00.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.677]                 }
[17:41:00.677]                 ...future.workdir <- getwd()
[17:41:00.677]             }
[17:41:00.677]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.677]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.677]         }
[17:41:00.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.677]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.677]             base::names(...future.oldOptions))
[17:41:00.677]     }
[17:41:00.677]     if (FALSE) {
[17:41:00.677]     }
[17:41:00.677]     else {
[17:41:00.677]         if (TRUE) {
[17:41:00.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.677]                 open = "w")
[17:41:00.677]         }
[17:41:00.677]         else {
[17:41:00.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.677]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.677]         }
[17:41:00.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.677]             base::sink(type = "output", split = FALSE)
[17:41:00.677]             base::close(...future.stdout)
[17:41:00.677]         }, add = TRUE)
[17:41:00.677]     }
[17:41:00.677]     ...future.frame <- base::sys.nframe()
[17:41:00.677]     ...future.conditions <- base::list()
[17:41:00.677]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.677]     if (FALSE) {
[17:41:00.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.677]     }
[17:41:00.677]     ...future.result <- base::tryCatch({
[17:41:00.677]         base::withCallingHandlers({
[17:41:00.677]             ...future.value <- base::withVisible(base::local({
[17:41:00.677]                 ...future.makeSendCondition <- base::local({
[17:41:00.677]                   sendCondition <- NULL
[17:41:00.677]                   function(frame = 1L) {
[17:41:00.677]                     if (is.function(sendCondition)) 
[17:41:00.677]                       return(sendCondition)
[17:41:00.677]                     ns <- getNamespace("parallel")
[17:41:00.677]                     if (exists("sendData", mode = "function", 
[17:41:00.677]                       envir = ns)) {
[17:41:00.677]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.677]                         envir = ns)
[17:41:00.677]                       envir <- sys.frame(frame)
[17:41:00.677]                       master <- NULL
[17:41:00.677]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.677]                         !identical(envir, emptyenv())) {
[17:41:00.677]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.677]                           inherits = FALSE)) {
[17:41:00.677]                           master <- get("master", mode = "list", 
[17:41:00.677]                             envir = envir, inherits = FALSE)
[17:41:00.677]                           if (inherits(master, c("SOCKnode", 
[17:41:00.677]                             "SOCK0node"))) {
[17:41:00.677]                             sendCondition <<- function(cond) {
[17:41:00.677]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.677]                                 success = TRUE)
[17:41:00.677]                               parallel_sendData(master, data)
[17:41:00.677]                             }
[17:41:00.677]                             return(sendCondition)
[17:41:00.677]                           }
[17:41:00.677]                         }
[17:41:00.677]                         frame <- frame + 1L
[17:41:00.677]                         envir <- sys.frame(frame)
[17:41:00.677]                       }
[17:41:00.677]                     }
[17:41:00.677]                     sendCondition <<- function(cond) NULL
[17:41:00.677]                   }
[17:41:00.677]                 })
[17:41:00.677]                 withCallingHandlers({
[17:41:00.677]                   {
[17:41:00.677]                     2
[17:41:00.677]                   }
[17:41:00.677]                 }, immediateCondition = function(cond) {
[17:41:00.677]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.677]                   sendCondition(cond)
[17:41:00.677]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.677]                   {
[17:41:00.677]                     inherits <- base::inherits
[17:41:00.677]                     invokeRestart <- base::invokeRestart
[17:41:00.677]                     is.null <- base::is.null
[17:41:00.677]                     muffled <- FALSE
[17:41:00.677]                     if (inherits(cond, "message")) {
[17:41:00.677]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.677]                       if (muffled) 
[17:41:00.677]                         invokeRestart("muffleMessage")
[17:41:00.677]                     }
[17:41:00.677]                     else if (inherits(cond, "warning")) {
[17:41:00.677]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.677]                       if (muffled) 
[17:41:00.677]                         invokeRestart("muffleWarning")
[17:41:00.677]                     }
[17:41:00.677]                     else if (inherits(cond, "condition")) {
[17:41:00.677]                       if (!is.null(pattern)) {
[17:41:00.677]                         computeRestarts <- base::computeRestarts
[17:41:00.677]                         grepl <- base::grepl
[17:41:00.677]                         restarts <- computeRestarts(cond)
[17:41:00.677]                         for (restart in restarts) {
[17:41:00.677]                           name <- restart$name
[17:41:00.677]                           if (is.null(name)) 
[17:41:00.677]                             next
[17:41:00.677]                           if (!grepl(pattern, name)) 
[17:41:00.677]                             next
[17:41:00.677]                           invokeRestart(restart)
[17:41:00.677]                           muffled <- TRUE
[17:41:00.677]                           break
[17:41:00.677]                         }
[17:41:00.677]                       }
[17:41:00.677]                     }
[17:41:00.677]                     invisible(muffled)
[17:41:00.677]                   }
[17:41:00.677]                   muffleCondition(cond)
[17:41:00.677]                 })
[17:41:00.677]             }))
[17:41:00.677]             future::FutureResult(value = ...future.value$value, 
[17:41:00.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.677]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.677]                     ...future.globalenv.names))
[17:41:00.677]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.677]         }, condition = base::local({
[17:41:00.677]             c <- base::c
[17:41:00.677]             inherits <- base::inherits
[17:41:00.677]             invokeRestart <- base::invokeRestart
[17:41:00.677]             length <- base::length
[17:41:00.677]             list <- base::list
[17:41:00.677]             seq.int <- base::seq.int
[17:41:00.677]             signalCondition <- base::signalCondition
[17:41:00.677]             sys.calls <- base::sys.calls
[17:41:00.677]             `[[` <- base::`[[`
[17:41:00.677]             `+` <- base::`+`
[17:41:00.677]             `<<-` <- base::`<<-`
[17:41:00.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.677]                   3L)]
[17:41:00.677]             }
[17:41:00.677]             function(cond) {
[17:41:00.677]                 is_error <- inherits(cond, "error")
[17:41:00.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.677]                   NULL)
[17:41:00.677]                 if (is_error) {
[17:41:00.677]                   sessionInformation <- function() {
[17:41:00.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.677]                       search = base::search(), system = base::Sys.info())
[17:41:00.677]                   }
[17:41:00.677]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.677]                     cond$call), session = sessionInformation(), 
[17:41:00.677]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.677]                   signalCondition(cond)
[17:41:00.677]                 }
[17:41:00.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.677]                 "immediateCondition"))) {
[17:41:00.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.677]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.677]                   if (TRUE && !signal) {
[17:41:00.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.677]                     {
[17:41:00.677]                       inherits <- base::inherits
[17:41:00.677]                       invokeRestart <- base::invokeRestart
[17:41:00.677]                       is.null <- base::is.null
[17:41:00.677]                       muffled <- FALSE
[17:41:00.677]                       if (inherits(cond, "message")) {
[17:41:00.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.677]                         if (muffled) 
[17:41:00.677]                           invokeRestart("muffleMessage")
[17:41:00.677]                       }
[17:41:00.677]                       else if (inherits(cond, "warning")) {
[17:41:00.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.677]                         if (muffled) 
[17:41:00.677]                           invokeRestart("muffleWarning")
[17:41:00.677]                       }
[17:41:00.677]                       else if (inherits(cond, "condition")) {
[17:41:00.677]                         if (!is.null(pattern)) {
[17:41:00.677]                           computeRestarts <- base::computeRestarts
[17:41:00.677]                           grepl <- base::grepl
[17:41:00.677]                           restarts <- computeRestarts(cond)
[17:41:00.677]                           for (restart in restarts) {
[17:41:00.677]                             name <- restart$name
[17:41:00.677]                             if (is.null(name)) 
[17:41:00.677]                               next
[17:41:00.677]                             if (!grepl(pattern, name)) 
[17:41:00.677]                               next
[17:41:00.677]                             invokeRestart(restart)
[17:41:00.677]                             muffled <- TRUE
[17:41:00.677]                             break
[17:41:00.677]                           }
[17:41:00.677]                         }
[17:41:00.677]                       }
[17:41:00.677]                       invisible(muffled)
[17:41:00.677]                     }
[17:41:00.677]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.677]                   }
[17:41:00.677]                 }
[17:41:00.677]                 else {
[17:41:00.677]                   if (TRUE) {
[17:41:00.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.677]                     {
[17:41:00.677]                       inherits <- base::inherits
[17:41:00.677]                       invokeRestart <- base::invokeRestart
[17:41:00.677]                       is.null <- base::is.null
[17:41:00.677]                       muffled <- FALSE
[17:41:00.677]                       if (inherits(cond, "message")) {
[17:41:00.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.677]                         if (muffled) 
[17:41:00.677]                           invokeRestart("muffleMessage")
[17:41:00.677]                       }
[17:41:00.677]                       else if (inherits(cond, "warning")) {
[17:41:00.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.677]                         if (muffled) 
[17:41:00.677]                           invokeRestart("muffleWarning")
[17:41:00.677]                       }
[17:41:00.677]                       else if (inherits(cond, "condition")) {
[17:41:00.677]                         if (!is.null(pattern)) {
[17:41:00.677]                           computeRestarts <- base::computeRestarts
[17:41:00.677]                           grepl <- base::grepl
[17:41:00.677]                           restarts <- computeRestarts(cond)
[17:41:00.677]                           for (restart in restarts) {
[17:41:00.677]                             name <- restart$name
[17:41:00.677]                             if (is.null(name)) 
[17:41:00.677]                               next
[17:41:00.677]                             if (!grepl(pattern, name)) 
[17:41:00.677]                               next
[17:41:00.677]                             invokeRestart(restart)
[17:41:00.677]                             muffled <- TRUE
[17:41:00.677]                             break
[17:41:00.677]                           }
[17:41:00.677]                         }
[17:41:00.677]                       }
[17:41:00.677]                       invisible(muffled)
[17:41:00.677]                     }
[17:41:00.677]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.677]                   }
[17:41:00.677]                 }
[17:41:00.677]             }
[17:41:00.677]         }))
[17:41:00.677]     }, error = function(ex) {
[17:41:00.677]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.677]                 ...future.rng), started = ...future.startTime, 
[17:41:00.677]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.677]             version = "1.8"), class = "FutureResult")
[17:41:00.677]     }, finally = {
[17:41:00.677]         if (!identical(...future.workdir, getwd())) 
[17:41:00.677]             setwd(...future.workdir)
[17:41:00.677]         {
[17:41:00.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.677]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.677]             }
[17:41:00.677]             base::options(...future.oldOptions)
[17:41:00.677]             if (.Platform$OS.type == "windows") {
[17:41:00.677]                 old_names <- names(...future.oldEnvVars)
[17:41:00.677]                 envs <- base::Sys.getenv()
[17:41:00.677]                 names <- names(envs)
[17:41:00.677]                 common <- intersect(names, old_names)
[17:41:00.677]                 added <- setdiff(names, old_names)
[17:41:00.677]                 removed <- setdiff(old_names, names)
[17:41:00.677]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.677]                   envs[common]]
[17:41:00.677]                 NAMES <- toupper(changed)
[17:41:00.677]                 args <- list()
[17:41:00.677]                 for (kk in seq_along(NAMES)) {
[17:41:00.677]                   name <- changed[[kk]]
[17:41:00.677]                   NAME <- NAMES[[kk]]
[17:41:00.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.677]                     next
[17:41:00.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.677]                 }
[17:41:00.677]                 NAMES <- toupper(added)
[17:41:00.677]                 for (kk in seq_along(NAMES)) {
[17:41:00.677]                   name <- added[[kk]]
[17:41:00.677]                   NAME <- NAMES[[kk]]
[17:41:00.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.677]                     next
[17:41:00.677]                   args[[name]] <- ""
[17:41:00.677]                 }
[17:41:00.677]                 NAMES <- toupper(removed)
[17:41:00.677]                 for (kk in seq_along(NAMES)) {
[17:41:00.677]                   name <- removed[[kk]]
[17:41:00.677]                   NAME <- NAMES[[kk]]
[17:41:00.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.677]                     next
[17:41:00.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.677]                 }
[17:41:00.677]                 if (length(args) > 0) 
[17:41:00.677]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.677]             }
[17:41:00.677]             else {
[17:41:00.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.677]             }
[17:41:00.677]             {
[17:41:00.677]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.677]                   0L) {
[17:41:00.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.677]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.677]                   base::options(opts)
[17:41:00.677]                 }
[17:41:00.677]                 {
[17:41:00.677]                   {
[17:41:00.677]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.677]                     NULL
[17:41:00.677]                   }
[17:41:00.677]                   options(future.plan = NULL)
[17:41:00.677]                   if (is.na(NA_character_)) 
[17:41:00.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.677]                     .init = FALSE)
[17:41:00.677]                 }
[17:41:00.677]             }
[17:41:00.677]         }
[17:41:00.677]     })
[17:41:00.677]     if (TRUE) {
[17:41:00.677]         base::sink(type = "output", split = FALSE)
[17:41:00.677]         if (TRUE) {
[17:41:00.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.677]         }
[17:41:00.677]         else {
[17:41:00.677]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.677]         }
[17:41:00.677]         base::close(...future.stdout)
[17:41:00.677]         ...future.stdout <- NULL
[17:41:00.677]     }
[17:41:00.677]     ...future.result$conditions <- ...future.conditions
[17:41:00.677]     ...future.result$finished <- base::Sys.time()
[17:41:00.677]     ...future.result
[17:41:00.677] }
[17:41:00.680] MultisessionFuture started
[17:41:00.680] - Launch lazy future ... done
[17:41:00.680] run() for ‘MultisessionFuture’ ... done
[17:41:00.680] resolve() on list environment ...
[17:41:00.680]  recursive: 0
[17:41:00.681]  length: 3
[17:41:00.681]  elements: ‘a’, ‘b’, ‘c’
[17:41:00.681] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.682] - Validating connection of MultisessionFuture
[17:41:00.682] - received message: FutureResult
[17:41:00.682] - Received FutureResult
[17:41:00.682] - Erased future from FutureRegistry
[17:41:00.682] result() for ClusterFuture ...
[17:41:00.682] - result already collected: FutureResult
[17:41:00.682] result() for ClusterFuture ... done
[17:41:00.682] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.682] Future #1
[17:41:00.682]  length: 2 (resolved future 1)
[17:41:00.683] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.683] - Validating connection of MultisessionFuture
[17:41:00.683] - received message: FutureResult
[17:41:00.683] - Received FutureResult
[17:41:00.683] - Erased future from FutureRegistry
[17:41:00.683] result() for ClusterFuture ...
[17:41:00.683] - result already collected: FutureResult
[17:41:00.684] result() for ClusterFuture ... done
[17:41:00.684] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.684] Future #2
[17:41:00.684]  length: 1 (resolved future 2)
[17:41:00.684]  length: 0 (resolved future 3)
[17:41:00.684] resolve() on list environment ... DONE
[17:41:00.684] getGlobalsAndPackages() ...
[17:41:00.684] Searching for globals...
[17:41:00.685] - globals found: [1] ‘{’
[17:41:00.685] Searching for globals ... DONE
[17:41:00.685] Resolving globals: FALSE
[17:41:00.685] 
[17:41:00.686] 
[17:41:00.686] getGlobalsAndPackages() ... DONE
[17:41:00.686] run() for ‘Future’ ...
[17:41:00.686] - state: ‘created’
[17:41:00.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.699] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.699] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.700]   - Field: ‘node’
[17:41:00.700]   - Field: ‘label’
[17:41:00.700]   - Field: ‘local’
[17:41:00.700]   - Field: ‘owner’
[17:41:00.700]   - Field: ‘envir’
[17:41:00.700]   - Field: ‘workers’
[17:41:00.700]   - Field: ‘packages’
[17:41:00.700]   - Field: ‘gc’
[17:41:00.700]   - Field: ‘conditions’
[17:41:00.700]   - Field: ‘persistent’
[17:41:00.700]   - Field: ‘expr’
[17:41:00.701]   - Field: ‘uuid’
[17:41:00.701]   - Field: ‘seed’
[17:41:00.701]   - Field: ‘version’
[17:41:00.701]   - Field: ‘result’
[17:41:00.701]   - Field: ‘asynchronous’
[17:41:00.701]   - Field: ‘calls’
[17:41:00.701]   - Field: ‘globals’
[17:41:00.701]   - Field: ‘stdout’
[17:41:00.701]   - Field: ‘earlySignal’
[17:41:00.701]   - Field: ‘lazy’
[17:41:00.701]   - Field: ‘state’
[17:41:00.701] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.702] - Launch lazy future ...
[17:41:00.702] Packages needed by the future expression (n = 0): <none>
[17:41:00.702] Packages needed by future strategies (n = 0): <none>
[17:41:00.702] {
[17:41:00.702]     {
[17:41:00.702]         {
[17:41:00.702]             ...future.startTime <- base::Sys.time()
[17:41:00.702]             {
[17:41:00.702]                 {
[17:41:00.702]                   {
[17:41:00.702]                     {
[17:41:00.702]                       base::local({
[17:41:00.702]                         has_future <- base::requireNamespace("future", 
[17:41:00.702]                           quietly = TRUE)
[17:41:00.702]                         if (has_future) {
[17:41:00.702]                           ns <- base::getNamespace("future")
[17:41:00.702]                           version <- ns[[".package"]][["version"]]
[17:41:00.702]                           if (is.null(version)) 
[17:41:00.702]                             version <- utils::packageVersion("future")
[17:41:00.702]                         }
[17:41:00.702]                         else {
[17:41:00.702]                           version <- NULL
[17:41:00.702]                         }
[17:41:00.702]                         if (!has_future || version < "1.8.0") {
[17:41:00.702]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.702]                             "", base::R.version$version.string), 
[17:41:00.702]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.702]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.702]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.702]                               "release", "version")], collapse = " "), 
[17:41:00.702]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.702]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.702]                             info)
[17:41:00.702]                           info <- base::paste(info, collapse = "; ")
[17:41:00.702]                           if (!has_future) {
[17:41:00.702]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.702]                               info)
[17:41:00.702]                           }
[17:41:00.702]                           else {
[17:41:00.702]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.702]                               info, version)
[17:41:00.702]                           }
[17:41:00.702]                           base::stop(msg)
[17:41:00.702]                         }
[17:41:00.702]                       })
[17:41:00.702]                     }
[17:41:00.702]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.702]                     base::options(mc.cores = 1L)
[17:41:00.702]                   }
[17:41:00.702]                   ...future.strategy.old <- future::plan("list")
[17:41:00.702]                   options(future.plan = NULL)
[17:41:00.702]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.702]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.702]                 }
[17:41:00.702]                 ...future.workdir <- getwd()
[17:41:00.702]             }
[17:41:00.702]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.702]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.702]         }
[17:41:00.702]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.702]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.702]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.702]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.702]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.702]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.702]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.702]             base::names(...future.oldOptions))
[17:41:00.702]     }
[17:41:00.702]     if (FALSE) {
[17:41:00.702]     }
[17:41:00.702]     else {
[17:41:00.702]         if (TRUE) {
[17:41:00.702]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.702]                 open = "w")
[17:41:00.702]         }
[17:41:00.702]         else {
[17:41:00.702]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.702]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.702]         }
[17:41:00.702]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.702]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.702]             base::sink(type = "output", split = FALSE)
[17:41:00.702]             base::close(...future.stdout)
[17:41:00.702]         }, add = TRUE)
[17:41:00.702]     }
[17:41:00.702]     ...future.frame <- base::sys.nframe()
[17:41:00.702]     ...future.conditions <- base::list()
[17:41:00.702]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.702]     if (FALSE) {
[17:41:00.702]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.702]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.702]     }
[17:41:00.702]     ...future.result <- base::tryCatch({
[17:41:00.702]         base::withCallingHandlers({
[17:41:00.702]             ...future.value <- base::withVisible(base::local({
[17:41:00.702]                 ...future.makeSendCondition <- base::local({
[17:41:00.702]                   sendCondition <- NULL
[17:41:00.702]                   function(frame = 1L) {
[17:41:00.702]                     if (is.function(sendCondition)) 
[17:41:00.702]                       return(sendCondition)
[17:41:00.702]                     ns <- getNamespace("parallel")
[17:41:00.702]                     if (exists("sendData", mode = "function", 
[17:41:00.702]                       envir = ns)) {
[17:41:00.702]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.702]                         envir = ns)
[17:41:00.702]                       envir <- sys.frame(frame)
[17:41:00.702]                       master <- NULL
[17:41:00.702]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.702]                         !identical(envir, emptyenv())) {
[17:41:00.702]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.702]                           inherits = FALSE)) {
[17:41:00.702]                           master <- get("master", mode = "list", 
[17:41:00.702]                             envir = envir, inherits = FALSE)
[17:41:00.702]                           if (inherits(master, c("SOCKnode", 
[17:41:00.702]                             "SOCK0node"))) {
[17:41:00.702]                             sendCondition <<- function(cond) {
[17:41:00.702]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.702]                                 success = TRUE)
[17:41:00.702]                               parallel_sendData(master, data)
[17:41:00.702]                             }
[17:41:00.702]                             return(sendCondition)
[17:41:00.702]                           }
[17:41:00.702]                         }
[17:41:00.702]                         frame <- frame + 1L
[17:41:00.702]                         envir <- sys.frame(frame)
[17:41:00.702]                       }
[17:41:00.702]                     }
[17:41:00.702]                     sendCondition <<- function(cond) NULL
[17:41:00.702]                   }
[17:41:00.702]                 })
[17:41:00.702]                 withCallingHandlers({
[17:41:00.702]                   {
[17:41:00.702]                     1
[17:41:00.702]                   }
[17:41:00.702]                 }, immediateCondition = function(cond) {
[17:41:00.702]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.702]                   sendCondition(cond)
[17:41:00.702]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.702]                   {
[17:41:00.702]                     inherits <- base::inherits
[17:41:00.702]                     invokeRestart <- base::invokeRestart
[17:41:00.702]                     is.null <- base::is.null
[17:41:00.702]                     muffled <- FALSE
[17:41:00.702]                     if (inherits(cond, "message")) {
[17:41:00.702]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.702]                       if (muffled) 
[17:41:00.702]                         invokeRestart("muffleMessage")
[17:41:00.702]                     }
[17:41:00.702]                     else if (inherits(cond, "warning")) {
[17:41:00.702]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.702]                       if (muffled) 
[17:41:00.702]                         invokeRestart("muffleWarning")
[17:41:00.702]                     }
[17:41:00.702]                     else if (inherits(cond, "condition")) {
[17:41:00.702]                       if (!is.null(pattern)) {
[17:41:00.702]                         computeRestarts <- base::computeRestarts
[17:41:00.702]                         grepl <- base::grepl
[17:41:00.702]                         restarts <- computeRestarts(cond)
[17:41:00.702]                         for (restart in restarts) {
[17:41:00.702]                           name <- restart$name
[17:41:00.702]                           if (is.null(name)) 
[17:41:00.702]                             next
[17:41:00.702]                           if (!grepl(pattern, name)) 
[17:41:00.702]                             next
[17:41:00.702]                           invokeRestart(restart)
[17:41:00.702]                           muffled <- TRUE
[17:41:00.702]                           break
[17:41:00.702]                         }
[17:41:00.702]                       }
[17:41:00.702]                     }
[17:41:00.702]                     invisible(muffled)
[17:41:00.702]                   }
[17:41:00.702]                   muffleCondition(cond)
[17:41:00.702]                 })
[17:41:00.702]             }))
[17:41:00.702]             future::FutureResult(value = ...future.value$value, 
[17:41:00.702]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.702]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.702]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.702]                     ...future.globalenv.names))
[17:41:00.702]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.702]         }, condition = base::local({
[17:41:00.702]             c <- base::c
[17:41:00.702]             inherits <- base::inherits
[17:41:00.702]             invokeRestart <- base::invokeRestart
[17:41:00.702]             length <- base::length
[17:41:00.702]             list <- base::list
[17:41:00.702]             seq.int <- base::seq.int
[17:41:00.702]             signalCondition <- base::signalCondition
[17:41:00.702]             sys.calls <- base::sys.calls
[17:41:00.702]             `[[` <- base::`[[`
[17:41:00.702]             `+` <- base::`+`
[17:41:00.702]             `<<-` <- base::`<<-`
[17:41:00.702]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.702]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.702]                   3L)]
[17:41:00.702]             }
[17:41:00.702]             function(cond) {
[17:41:00.702]                 is_error <- inherits(cond, "error")
[17:41:00.702]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.702]                   NULL)
[17:41:00.702]                 if (is_error) {
[17:41:00.702]                   sessionInformation <- function() {
[17:41:00.702]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.702]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.702]                       search = base::search(), system = base::Sys.info())
[17:41:00.702]                   }
[17:41:00.702]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.702]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.702]                     cond$call), session = sessionInformation(), 
[17:41:00.702]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.702]                   signalCondition(cond)
[17:41:00.702]                 }
[17:41:00.702]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.702]                 "immediateCondition"))) {
[17:41:00.702]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.702]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.702]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.702]                   if (TRUE && !signal) {
[17:41:00.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.702]                     {
[17:41:00.702]                       inherits <- base::inherits
[17:41:00.702]                       invokeRestart <- base::invokeRestart
[17:41:00.702]                       is.null <- base::is.null
[17:41:00.702]                       muffled <- FALSE
[17:41:00.702]                       if (inherits(cond, "message")) {
[17:41:00.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.702]                         if (muffled) 
[17:41:00.702]                           invokeRestart("muffleMessage")
[17:41:00.702]                       }
[17:41:00.702]                       else if (inherits(cond, "warning")) {
[17:41:00.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.702]                         if (muffled) 
[17:41:00.702]                           invokeRestart("muffleWarning")
[17:41:00.702]                       }
[17:41:00.702]                       else if (inherits(cond, "condition")) {
[17:41:00.702]                         if (!is.null(pattern)) {
[17:41:00.702]                           computeRestarts <- base::computeRestarts
[17:41:00.702]                           grepl <- base::grepl
[17:41:00.702]                           restarts <- computeRestarts(cond)
[17:41:00.702]                           for (restart in restarts) {
[17:41:00.702]                             name <- restart$name
[17:41:00.702]                             if (is.null(name)) 
[17:41:00.702]                               next
[17:41:00.702]                             if (!grepl(pattern, name)) 
[17:41:00.702]                               next
[17:41:00.702]                             invokeRestart(restart)
[17:41:00.702]                             muffled <- TRUE
[17:41:00.702]                             break
[17:41:00.702]                           }
[17:41:00.702]                         }
[17:41:00.702]                       }
[17:41:00.702]                       invisible(muffled)
[17:41:00.702]                     }
[17:41:00.702]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.702]                   }
[17:41:00.702]                 }
[17:41:00.702]                 else {
[17:41:00.702]                   if (TRUE) {
[17:41:00.702]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.702]                     {
[17:41:00.702]                       inherits <- base::inherits
[17:41:00.702]                       invokeRestart <- base::invokeRestart
[17:41:00.702]                       is.null <- base::is.null
[17:41:00.702]                       muffled <- FALSE
[17:41:00.702]                       if (inherits(cond, "message")) {
[17:41:00.702]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.702]                         if (muffled) 
[17:41:00.702]                           invokeRestart("muffleMessage")
[17:41:00.702]                       }
[17:41:00.702]                       else if (inherits(cond, "warning")) {
[17:41:00.702]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.702]                         if (muffled) 
[17:41:00.702]                           invokeRestart("muffleWarning")
[17:41:00.702]                       }
[17:41:00.702]                       else if (inherits(cond, "condition")) {
[17:41:00.702]                         if (!is.null(pattern)) {
[17:41:00.702]                           computeRestarts <- base::computeRestarts
[17:41:00.702]                           grepl <- base::grepl
[17:41:00.702]                           restarts <- computeRestarts(cond)
[17:41:00.702]                           for (restart in restarts) {
[17:41:00.702]                             name <- restart$name
[17:41:00.702]                             if (is.null(name)) 
[17:41:00.702]                               next
[17:41:00.702]                             if (!grepl(pattern, name)) 
[17:41:00.702]                               next
[17:41:00.702]                             invokeRestart(restart)
[17:41:00.702]                             muffled <- TRUE
[17:41:00.702]                             break
[17:41:00.702]                           }
[17:41:00.702]                         }
[17:41:00.702]                       }
[17:41:00.702]                       invisible(muffled)
[17:41:00.702]                     }
[17:41:00.702]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.702]                   }
[17:41:00.702]                 }
[17:41:00.702]             }
[17:41:00.702]         }))
[17:41:00.702]     }, error = function(ex) {
[17:41:00.702]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.702]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.702]                 ...future.rng), started = ...future.startTime, 
[17:41:00.702]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.702]             version = "1.8"), class = "FutureResult")
[17:41:00.702]     }, finally = {
[17:41:00.702]         if (!identical(...future.workdir, getwd())) 
[17:41:00.702]             setwd(...future.workdir)
[17:41:00.702]         {
[17:41:00.702]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.702]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.702]             }
[17:41:00.702]             base::options(...future.oldOptions)
[17:41:00.702]             if (.Platform$OS.type == "windows") {
[17:41:00.702]                 old_names <- names(...future.oldEnvVars)
[17:41:00.702]                 envs <- base::Sys.getenv()
[17:41:00.702]                 names <- names(envs)
[17:41:00.702]                 common <- intersect(names, old_names)
[17:41:00.702]                 added <- setdiff(names, old_names)
[17:41:00.702]                 removed <- setdiff(old_names, names)
[17:41:00.702]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.702]                   envs[common]]
[17:41:00.702]                 NAMES <- toupper(changed)
[17:41:00.702]                 args <- list()
[17:41:00.702]                 for (kk in seq_along(NAMES)) {
[17:41:00.702]                   name <- changed[[kk]]
[17:41:00.702]                   NAME <- NAMES[[kk]]
[17:41:00.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.702]                     next
[17:41:00.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.702]                 }
[17:41:00.702]                 NAMES <- toupper(added)
[17:41:00.702]                 for (kk in seq_along(NAMES)) {
[17:41:00.702]                   name <- added[[kk]]
[17:41:00.702]                   NAME <- NAMES[[kk]]
[17:41:00.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.702]                     next
[17:41:00.702]                   args[[name]] <- ""
[17:41:00.702]                 }
[17:41:00.702]                 NAMES <- toupper(removed)
[17:41:00.702]                 for (kk in seq_along(NAMES)) {
[17:41:00.702]                   name <- removed[[kk]]
[17:41:00.702]                   NAME <- NAMES[[kk]]
[17:41:00.702]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.702]                     next
[17:41:00.702]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.702]                 }
[17:41:00.702]                 if (length(args) > 0) 
[17:41:00.702]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.702]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.702]             }
[17:41:00.702]             else {
[17:41:00.702]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.702]             }
[17:41:00.702]             {
[17:41:00.702]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.702]                   0L) {
[17:41:00.702]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.702]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.702]                   base::options(opts)
[17:41:00.702]                 }
[17:41:00.702]                 {
[17:41:00.702]                   {
[17:41:00.702]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.702]                     NULL
[17:41:00.702]                   }
[17:41:00.702]                   options(future.plan = NULL)
[17:41:00.702]                   if (is.na(NA_character_)) 
[17:41:00.702]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.702]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.702]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.702]                     .init = FALSE)
[17:41:00.702]                 }
[17:41:00.702]             }
[17:41:00.702]         }
[17:41:00.702]     })
[17:41:00.702]     if (TRUE) {
[17:41:00.702]         base::sink(type = "output", split = FALSE)
[17:41:00.702]         if (TRUE) {
[17:41:00.702]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.702]         }
[17:41:00.702]         else {
[17:41:00.702]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.702]         }
[17:41:00.702]         base::close(...future.stdout)
[17:41:00.702]         ...future.stdout <- NULL
[17:41:00.702]     }
[17:41:00.702]     ...future.result$conditions <- ...future.conditions
[17:41:00.702]     ...future.result$finished <- base::Sys.time()
[17:41:00.702]     ...future.result
[17:41:00.702] }
[17:41:00.705] MultisessionFuture started
[17:41:00.705] - Launch lazy future ... done
[17:41:00.705] run() for ‘MultisessionFuture’ ... done
[17:41:00.706] getGlobalsAndPackages() ...
[17:41:00.706] Searching for globals...
[17:41:00.707] - globals found: [2] ‘{’, ‘Sys.sleep’
[17:41:00.708] Searching for globals ... DONE
[17:41:00.708] Resolving globals: FALSE
[17:41:00.708] 
[17:41:00.708] 
[17:41:00.708] getGlobalsAndPackages() ... DONE
[17:41:00.708] run() for ‘Future’ ...
[17:41:00.709] - state: ‘created’
[17:41:00.709] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.724] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.724]   - Field: ‘node’
[17:41:00.724]   - Field: ‘label’
[17:41:00.725]   - Field: ‘local’
[17:41:00.725]   - Field: ‘owner’
[17:41:00.725]   - Field: ‘envir’
[17:41:00.725]   - Field: ‘workers’
[17:41:00.725]   - Field: ‘packages’
[17:41:00.725]   - Field: ‘gc’
[17:41:00.725]   - Field: ‘conditions’
[17:41:00.725]   - Field: ‘persistent’
[17:41:00.725]   - Field: ‘expr’
[17:41:00.725]   - Field: ‘uuid’
[17:41:00.725]   - Field: ‘seed’
[17:41:00.725]   - Field: ‘version’
[17:41:00.726]   - Field: ‘result’
[17:41:00.726]   - Field: ‘asynchronous’
[17:41:00.726]   - Field: ‘calls’
[17:41:00.726]   - Field: ‘globals’
[17:41:00.726]   - Field: ‘stdout’
[17:41:00.726]   - Field: ‘earlySignal’
[17:41:00.726]   - Field: ‘lazy’
[17:41:00.726]   - Field: ‘state’
[17:41:00.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.726] - Launch lazy future ...
[17:41:00.727] Packages needed by the future expression (n = 0): <none>
[17:41:00.727] Packages needed by future strategies (n = 0): <none>
[17:41:00.727] {
[17:41:00.727]     {
[17:41:00.727]         {
[17:41:00.727]             ...future.startTime <- base::Sys.time()
[17:41:00.727]             {
[17:41:00.727]                 {
[17:41:00.727]                   {
[17:41:00.727]                     {
[17:41:00.727]                       base::local({
[17:41:00.727]                         has_future <- base::requireNamespace("future", 
[17:41:00.727]                           quietly = TRUE)
[17:41:00.727]                         if (has_future) {
[17:41:00.727]                           ns <- base::getNamespace("future")
[17:41:00.727]                           version <- ns[[".package"]][["version"]]
[17:41:00.727]                           if (is.null(version)) 
[17:41:00.727]                             version <- utils::packageVersion("future")
[17:41:00.727]                         }
[17:41:00.727]                         else {
[17:41:00.727]                           version <- NULL
[17:41:00.727]                         }
[17:41:00.727]                         if (!has_future || version < "1.8.0") {
[17:41:00.727]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.727]                             "", base::R.version$version.string), 
[17:41:00.727]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.727]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.727]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.727]                               "release", "version")], collapse = " "), 
[17:41:00.727]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.727]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.727]                             info)
[17:41:00.727]                           info <- base::paste(info, collapse = "; ")
[17:41:00.727]                           if (!has_future) {
[17:41:00.727]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.727]                               info)
[17:41:00.727]                           }
[17:41:00.727]                           else {
[17:41:00.727]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.727]                               info, version)
[17:41:00.727]                           }
[17:41:00.727]                           base::stop(msg)
[17:41:00.727]                         }
[17:41:00.727]                       })
[17:41:00.727]                     }
[17:41:00.727]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.727]                     base::options(mc.cores = 1L)
[17:41:00.727]                   }
[17:41:00.727]                   ...future.strategy.old <- future::plan("list")
[17:41:00.727]                   options(future.plan = NULL)
[17:41:00.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.727]                 }
[17:41:00.727]                 ...future.workdir <- getwd()
[17:41:00.727]             }
[17:41:00.727]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.727]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.727]         }
[17:41:00.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.727]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.727]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.727]             base::names(...future.oldOptions))
[17:41:00.727]     }
[17:41:00.727]     if (FALSE) {
[17:41:00.727]     }
[17:41:00.727]     else {
[17:41:00.727]         if (TRUE) {
[17:41:00.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.727]                 open = "w")
[17:41:00.727]         }
[17:41:00.727]         else {
[17:41:00.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.727]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.727]         }
[17:41:00.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.727]             base::sink(type = "output", split = FALSE)
[17:41:00.727]             base::close(...future.stdout)
[17:41:00.727]         }, add = TRUE)
[17:41:00.727]     }
[17:41:00.727]     ...future.frame <- base::sys.nframe()
[17:41:00.727]     ...future.conditions <- base::list()
[17:41:00.727]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.727]     if (FALSE) {
[17:41:00.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.727]     }
[17:41:00.727]     ...future.result <- base::tryCatch({
[17:41:00.727]         base::withCallingHandlers({
[17:41:00.727]             ...future.value <- base::withVisible(base::local({
[17:41:00.727]                 ...future.makeSendCondition <- base::local({
[17:41:00.727]                   sendCondition <- NULL
[17:41:00.727]                   function(frame = 1L) {
[17:41:00.727]                     if (is.function(sendCondition)) 
[17:41:00.727]                       return(sendCondition)
[17:41:00.727]                     ns <- getNamespace("parallel")
[17:41:00.727]                     if (exists("sendData", mode = "function", 
[17:41:00.727]                       envir = ns)) {
[17:41:00.727]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.727]                         envir = ns)
[17:41:00.727]                       envir <- sys.frame(frame)
[17:41:00.727]                       master <- NULL
[17:41:00.727]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.727]                         !identical(envir, emptyenv())) {
[17:41:00.727]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.727]                           inherits = FALSE)) {
[17:41:00.727]                           master <- get("master", mode = "list", 
[17:41:00.727]                             envir = envir, inherits = FALSE)
[17:41:00.727]                           if (inherits(master, c("SOCKnode", 
[17:41:00.727]                             "SOCK0node"))) {
[17:41:00.727]                             sendCondition <<- function(cond) {
[17:41:00.727]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.727]                                 success = TRUE)
[17:41:00.727]                               parallel_sendData(master, data)
[17:41:00.727]                             }
[17:41:00.727]                             return(sendCondition)
[17:41:00.727]                           }
[17:41:00.727]                         }
[17:41:00.727]                         frame <- frame + 1L
[17:41:00.727]                         envir <- sys.frame(frame)
[17:41:00.727]                       }
[17:41:00.727]                     }
[17:41:00.727]                     sendCondition <<- function(cond) NULL
[17:41:00.727]                   }
[17:41:00.727]                 })
[17:41:00.727]                 withCallingHandlers({
[17:41:00.727]                   {
[17:41:00.727]                     Sys.sleep(0.5)
[17:41:00.727]                     2
[17:41:00.727]                   }
[17:41:00.727]                 }, immediateCondition = function(cond) {
[17:41:00.727]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.727]                   sendCondition(cond)
[17:41:00.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.727]                   {
[17:41:00.727]                     inherits <- base::inherits
[17:41:00.727]                     invokeRestart <- base::invokeRestart
[17:41:00.727]                     is.null <- base::is.null
[17:41:00.727]                     muffled <- FALSE
[17:41:00.727]                     if (inherits(cond, "message")) {
[17:41:00.727]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.727]                       if (muffled) 
[17:41:00.727]                         invokeRestart("muffleMessage")
[17:41:00.727]                     }
[17:41:00.727]                     else if (inherits(cond, "warning")) {
[17:41:00.727]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.727]                       if (muffled) 
[17:41:00.727]                         invokeRestart("muffleWarning")
[17:41:00.727]                     }
[17:41:00.727]                     else if (inherits(cond, "condition")) {
[17:41:00.727]                       if (!is.null(pattern)) {
[17:41:00.727]                         computeRestarts <- base::computeRestarts
[17:41:00.727]                         grepl <- base::grepl
[17:41:00.727]                         restarts <- computeRestarts(cond)
[17:41:00.727]                         for (restart in restarts) {
[17:41:00.727]                           name <- restart$name
[17:41:00.727]                           if (is.null(name)) 
[17:41:00.727]                             next
[17:41:00.727]                           if (!grepl(pattern, name)) 
[17:41:00.727]                             next
[17:41:00.727]                           invokeRestart(restart)
[17:41:00.727]                           muffled <- TRUE
[17:41:00.727]                           break
[17:41:00.727]                         }
[17:41:00.727]                       }
[17:41:00.727]                     }
[17:41:00.727]                     invisible(muffled)
[17:41:00.727]                   }
[17:41:00.727]                   muffleCondition(cond)
[17:41:00.727]                 })
[17:41:00.727]             }))
[17:41:00.727]             future::FutureResult(value = ...future.value$value, 
[17:41:00.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.727]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.727]                     ...future.globalenv.names))
[17:41:00.727]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.727]         }, condition = base::local({
[17:41:00.727]             c <- base::c
[17:41:00.727]             inherits <- base::inherits
[17:41:00.727]             invokeRestart <- base::invokeRestart
[17:41:00.727]             length <- base::length
[17:41:00.727]             list <- base::list
[17:41:00.727]             seq.int <- base::seq.int
[17:41:00.727]             signalCondition <- base::signalCondition
[17:41:00.727]             sys.calls <- base::sys.calls
[17:41:00.727]             `[[` <- base::`[[`
[17:41:00.727]             `+` <- base::`+`
[17:41:00.727]             `<<-` <- base::`<<-`
[17:41:00.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.727]                   3L)]
[17:41:00.727]             }
[17:41:00.727]             function(cond) {
[17:41:00.727]                 is_error <- inherits(cond, "error")
[17:41:00.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.727]                   NULL)
[17:41:00.727]                 if (is_error) {
[17:41:00.727]                   sessionInformation <- function() {
[17:41:00.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.727]                       search = base::search(), system = base::Sys.info())
[17:41:00.727]                   }
[17:41:00.727]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.727]                     cond$call), session = sessionInformation(), 
[17:41:00.727]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.727]                   signalCondition(cond)
[17:41:00.727]                 }
[17:41:00.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.727]                 "immediateCondition"))) {
[17:41:00.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.727]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.727]                   if (TRUE && !signal) {
[17:41:00.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.727]                     {
[17:41:00.727]                       inherits <- base::inherits
[17:41:00.727]                       invokeRestart <- base::invokeRestart
[17:41:00.727]                       is.null <- base::is.null
[17:41:00.727]                       muffled <- FALSE
[17:41:00.727]                       if (inherits(cond, "message")) {
[17:41:00.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.727]                         if (muffled) 
[17:41:00.727]                           invokeRestart("muffleMessage")
[17:41:00.727]                       }
[17:41:00.727]                       else if (inherits(cond, "warning")) {
[17:41:00.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.727]                         if (muffled) 
[17:41:00.727]                           invokeRestart("muffleWarning")
[17:41:00.727]                       }
[17:41:00.727]                       else if (inherits(cond, "condition")) {
[17:41:00.727]                         if (!is.null(pattern)) {
[17:41:00.727]                           computeRestarts <- base::computeRestarts
[17:41:00.727]                           grepl <- base::grepl
[17:41:00.727]                           restarts <- computeRestarts(cond)
[17:41:00.727]                           for (restart in restarts) {
[17:41:00.727]                             name <- restart$name
[17:41:00.727]                             if (is.null(name)) 
[17:41:00.727]                               next
[17:41:00.727]                             if (!grepl(pattern, name)) 
[17:41:00.727]                               next
[17:41:00.727]                             invokeRestart(restart)
[17:41:00.727]                             muffled <- TRUE
[17:41:00.727]                             break
[17:41:00.727]                           }
[17:41:00.727]                         }
[17:41:00.727]                       }
[17:41:00.727]                       invisible(muffled)
[17:41:00.727]                     }
[17:41:00.727]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.727]                   }
[17:41:00.727]                 }
[17:41:00.727]                 else {
[17:41:00.727]                   if (TRUE) {
[17:41:00.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.727]                     {
[17:41:00.727]                       inherits <- base::inherits
[17:41:00.727]                       invokeRestart <- base::invokeRestart
[17:41:00.727]                       is.null <- base::is.null
[17:41:00.727]                       muffled <- FALSE
[17:41:00.727]                       if (inherits(cond, "message")) {
[17:41:00.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.727]                         if (muffled) 
[17:41:00.727]                           invokeRestart("muffleMessage")
[17:41:00.727]                       }
[17:41:00.727]                       else if (inherits(cond, "warning")) {
[17:41:00.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.727]                         if (muffled) 
[17:41:00.727]                           invokeRestart("muffleWarning")
[17:41:00.727]                       }
[17:41:00.727]                       else if (inherits(cond, "condition")) {
[17:41:00.727]                         if (!is.null(pattern)) {
[17:41:00.727]                           computeRestarts <- base::computeRestarts
[17:41:00.727]                           grepl <- base::grepl
[17:41:00.727]                           restarts <- computeRestarts(cond)
[17:41:00.727]                           for (restart in restarts) {
[17:41:00.727]                             name <- restart$name
[17:41:00.727]                             if (is.null(name)) 
[17:41:00.727]                               next
[17:41:00.727]                             if (!grepl(pattern, name)) 
[17:41:00.727]                               next
[17:41:00.727]                             invokeRestart(restart)
[17:41:00.727]                             muffled <- TRUE
[17:41:00.727]                             break
[17:41:00.727]                           }
[17:41:00.727]                         }
[17:41:00.727]                       }
[17:41:00.727]                       invisible(muffled)
[17:41:00.727]                     }
[17:41:00.727]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.727]                   }
[17:41:00.727]                 }
[17:41:00.727]             }
[17:41:00.727]         }))
[17:41:00.727]     }, error = function(ex) {
[17:41:00.727]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.727]                 ...future.rng), started = ...future.startTime, 
[17:41:00.727]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.727]             version = "1.8"), class = "FutureResult")
[17:41:00.727]     }, finally = {
[17:41:00.727]         if (!identical(...future.workdir, getwd())) 
[17:41:00.727]             setwd(...future.workdir)
[17:41:00.727]         {
[17:41:00.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.727]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.727]             }
[17:41:00.727]             base::options(...future.oldOptions)
[17:41:00.727]             if (.Platform$OS.type == "windows") {
[17:41:00.727]                 old_names <- names(...future.oldEnvVars)
[17:41:00.727]                 envs <- base::Sys.getenv()
[17:41:00.727]                 names <- names(envs)
[17:41:00.727]                 common <- intersect(names, old_names)
[17:41:00.727]                 added <- setdiff(names, old_names)
[17:41:00.727]                 removed <- setdiff(old_names, names)
[17:41:00.727]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.727]                   envs[common]]
[17:41:00.727]                 NAMES <- toupper(changed)
[17:41:00.727]                 args <- list()
[17:41:00.727]                 for (kk in seq_along(NAMES)) {
[17:41:00.727]                   name <- changed[[kk]]
[17:41:00.727]                   NAME <- NAMES[[kk]]
[17:41:00.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.727]                     next
[17:41:00.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.727]                 }
[17:41:00.727]                 NAMES <- toupper(added)
[17:41:00.727]                 for (kk in seq_along(NAMES)) {
[17:41:00.727]                   name <- added[[kk]]
[17:41:00.727]                   NAME <- NAMES[[kk]]
[17:41:00.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.727]                     next
[17:41:00.727]                   args[[name]] <- ""
[17:41:00.727]                 }
[17:41:00.727]                 NAMES <- toupper(removed)
[17:41:00.727]                 for (kk in seq_along(NAMES)) {
[17:41:00.727]                   name <- removed[[kk]]
[17:41:00.727]                   NAME <- NAMES[[kk]]
[17:41:00.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.727]                     next
[17:41:00.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.727]                 }
[17:41:00.727]                 if (length(args) > 0) 
[17:41:00.727]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.727]             }
[17:41:00.727]             else {
[17:41:00.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.727]             }
[17:41:00.727]             {
[17:41:00.727]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.727]                   0L) {
[17:41:00.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.727]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.727]                   base::options(opts)
[17:41:00.727]                 }
[17:41:00.727]                 {
[17:41:00.727]                   {
[17:41:00.727]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.727]                     NULL
[17:41:00.727]                   }
[17:41:00.727]                   options(future.plan = NULL)
[17:41:00.727]                   if (is.na(NA_character_)) 
[17:41:00.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.727]                     .init = FALSE)
[17:41:00.727]                 }
[17:41:00.727]             }
[17:41:00.727]         }
[17:41:00.727]     })
[17:41:00.727]     if (TRUE) {
[17:41:00.727]         base::sink(type = "output", split = FALSE)
[17:41:00.727]         if (TRUE) {
[17:41:00.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.727]         }
[17:41:00.727]         else {
[17:41:00.727]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.727]         }
[17:41:00.727]         base::close(...future.stdout)
[17:41:00.727]         ...future.stdout <- NULL
[17:41:00.727]     }
[17:41:00.727]     ...future.result$conditions <- ...future.conditions
[17:41:00.727]     ...future.result$finished <- base::Sys.time()
[17:41:00.727]     ...future.result
[17:41:00.727] }
[17:41:00.730] MultisessionFuture started
[17:41:00.730] - Launch lazy future ... done
[17:41:00.730] run() for ‘MultisessionFuture’ ... done
[17:41:00.731] getGlobalsAndPackages() ...
[17:41:00.731] Searching for globals...
[17:41:00.731] - globals found: [1] ‘{’
[17:41:00.731] Searching for globals ... DONE
[17:41:00.731] Resolving globals: FALSE
[17:41:00.732] 
[17:41:00.732] 
[17:41:00.732] getGlobalsAndPackages() ... DONE
[17:41:00.732] run() for ‘Future’ ...
[17:41:00.732] - state: ‘created’
[17:41:00.732] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:41:00.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:41:00.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:41:00.746]   - Field: ‘node’
[17:41:00.746]   - Field: ‘label’
[17:41:00.746]   - Field: ‘local’
[17:41:00.746]   - Field: ‘owner’
[17:41:00.746]   - Field: ‘envir’
[17:41:00.746]   - Field: ‘workers’
[17:41:00.746]   - Field: ‘packages’
[17:41:00.746]   - Field: ‘gc’
[17:41:00.746]   - Field: ‘conditions’
[17:41:00.747]   - Field: ‘persistent’
[17:41:00.747]   - Field: ‘expr’
[17:41:00.747]   - Field: ‘uuid’
[17:41:00.747]   - Field: ‘seed’
[17:41:00.747]   - Field: ‘version’
[17:41:00.747]   - Field: ‘result’
[17:41:00.747]   - Field: ‘asynchronous’
[17:41:00.747]   - Field: ‘calls’
[17:41:00.747]   - Field: ‘globals’
[17:41:00.747]   - Field: ‘stdout’
[17:41:00.747]   - Field: ‘earlySignal’
[17:41:00.748]   - Field: ‘lazy’
[17:41:00.748]   - Field: ‘state’
[17:41:00.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:41:00.748] - Launch lazy future ...
[17:41:00.748] Packages needed by the future expression (n = 0): <none>
[17:41:00.748] Packages needed by future strategies (n = 0): <none>
[17:41:00.749] {
[17:41:00.749]     {
[17:41:00.749]         {
[17:41:00.749]             ...future.startTime <- base::Sys.time()
[17:41:00.749]             {
[17:41:00.749]                 {
[17:41:00.749]                   {
[17:41:00.749]                     {
[17:41:00.749]                       base::local({
[17:41:00.749]                         has_future <- base::requireNamespace("future", 
[17:41:00.749]                           quietly = TRUE)
[17:41:00.749]                         if (has_future) {
[17:41:00.749]                           ns <- base::getNamespace("future")
[17:41:00.749]                           version <- ns[[".package"]][["version"]]
[17:41:00.749]                           if (is.null(version)) 
[17:41:00.749]                             version <- utils::packageVersion("future")
[17:41:00.749]                         }
[17:41:00.749]                         else {
[17:41:00.749]                           version <- NULL
[17:41:00.749]                         }
[17:41:00.749]                         if (!has_future || version < "1.8.0") {
[17:41:00.749]                           info <- base::c(r_version = base::gsub("R version ", 
[17:41:00.749]                             "", base::R.version$version.string), 
[17:41:00.749]                             platform = base::sprintf("%s (%s-bit)", 
[17:41:00.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:41:00.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:41:00.749]                               "release", "version")], collapse = " "), 
[17:41:00.749]                             hostname = base::Sys.info()[["nodename"]])
[17:41:00.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:41:00.749]                             info)
[17:41:00.749]                           info <- base::paste(info, collapse = "; ")
[17:41:00.749]                           if (!has_future) {
[17:41:00.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:41:00.749]                               info)
[17:41:00.749]                           }
[17:41:00.749]                           else {
[17:41:00.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:41:00.749]                               info, version)
[17:41:00.749]                           }
[17:41:00.749]                           base::stop(msg)
[17:41:00.749]                         }
[17:41:00.749]                       })
[17:41:00.749]                     }
[17:41:00.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:41:00.749]                     base::options(mc.cores = 1L)
[17:41:00.749]                   }
[17:41:00.749]                   ...future.strategy.old <- future::plan("list")
[17:41:00.749]                   options(future.plan = NULL)
[17:41:00.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:41:00.749]                 }
[17:41:00.749]                 ...future.workdir <- getwd()
[17:41:00.749]             }
[17:41:00.749]             ...future.oldOptions <- base::as.list(base::.Options)
[17:41:00.749]             ...future.oldEnvVars <- base::Sys.getenv()
[17:41:00.749]         }
[17:41:00.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:41:00.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:41:00.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:41:00.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:41:00.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:41:00.749]             future.stdout.windows.reencode = NULL, width = 80L)
[17:41:00.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:41:00.749]             base::names(...future.oldOptions))
[17:41:00.749]     }
[17:41:00.749]     if (FALSE) {
[17:41:00.749]     }
[17:41:00.749]     else {
[17:41:00.749]         if (TRUE) {
[17:41:00.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:41:00.749]                 open = "w")
[17:41:00.749]         }
[17:41:00.749]         else {
[17:41:00.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:41:00.749]                 windows = "NUL", "/dev/null"), open = "w")
[17:41:00.749]         }
[17:41:00.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:41:00.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:41:00.749]             base::sink(type = "output", split = FALSE)
[17:41:00.749]             base::close(...future.stdout)
[17:41:00.749]         }, add = TRUE)
[17:41:00.749]     }
[17:41:00.749]     ...future.frame <- base::sys.nframe()
[17:41:00.749]     ...future.conditions <- base::list()
[17:41:00.749]     ...future.rng <- base::globalenv()$.Random.seed
[17:41:00.749]     if (FALSE) {
[17:41:00.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:41:00.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:41:00.749]     }
[17:41:00.749]     ...future.result <- base::tryCatch({
[17:41:00.749]         base::withCallingHandlers({
[17:41:00.749]             ...future.value <- base::withVisible(base::local({
[17:41:00.749]                 ...future.makeSendCondition <- base::local({
[17:41:00.749]                   sendCondition <- NULL
[17:41:00.749]                   function(frame = 1L) {
[17:41:00.749]                     if (is.function(sendCondition)) 
[17:41:00.749]                       return(sendCondition)
[17:41:00.749]                     ns <- getNamespace("parallel")
[17:41:00.749]                     if (exists("sendData", mode = "function", 
[17:41:00.749]                       envir = ns)) {
[17:41:00.749]                       parallel_sendData <- get("sendData", mode = "function", 
[17:41:00.749]                         envir = ns)
[17:41:00.749]                       envir <- sys.frame(frame)
[17:41:00.749]                       master <- NULL
[17:41:00.749]                       while (!identical(envir, .GlobalEnv) && 
[17:41:00.749]                         !identical(envir, emptyenv())) {
[17:41:00.749]                         if (exists("master", mode = "list", envir = envir, 
[17:41:00.749]                           inherits = FALSE)) {
[17:41:00.749]                           master <- get("master", mode = "list", 
[17:41:00.749]                             envir = envir, inherits = FALSE)
[17:41:00.749]                           if (inherits(master, c("SOCKnode", 
[17:41:00.749]                             "SOCK0node"))) {
[17:41:00.749]                             sendCondition <<- function(cond) {
[17:41:00.749]                               data <- list(type = "VALUE", value = cond, 
[17:41:00.749]                                 success = TRUE)
[17:41:00.749]                               parallel_sendData(master, data)
[17:41:00.749]                             }
[17:41:00.749]                             return(sendCondition)
[17:41:00.749]                           }
[17:41:00.749]                         }
[17:41:00.749]                         frame <- frame + 1L
[17:41:00.749]                         envir <- sys.frame(frame)
[17:41:00.749]                       }
[17:41:00.749]                     }
[17:41:00.749]                     sendCondition <<- function(cond) NULL
[17:41:00.749]                   }
[17:41:00.749]                 })
[17:41:00.749]                 withCallingHandlers({
[17:41:00.749]                   {
[17:41:00.749]                     3
[17:41:00.749]                   }
[17:41:00.749]                 }, immediateCondition = function(cond) {
[17:41:00.749]                   sendCondition <- ...future.makeSendCondition()
[17:41:00.749]                   sendCondition(cond)
[17:41:00.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.749]                   {
[17:41:00.749]                     inherits <- base::inherits
[17:41:00.749]                     invokeRestart <- base::invokeRestart
[17:41:00.749]                     is.null <- base::is.null
[17:41:00.749]                     muffled <- FALSE
[17:41:00.749]                     if (inherits(cond, "message")) {
[17:41:00.749]                       muffled <- grepl(pattern, "muffleMessage")
[17:41:00.749]                       if (muffled) 
[17:41:00.749]                         invokeRestart("muffleMessage")
[17:41:00.749]                     }
[17:41:00.749]                     else if (inherits(cond, "warning")) {
[17:41:00.749]                       muffled <- grepl(pattern, "muffleWarning")
[17:41:00.749]                       if (muffled) 
[17:41:00.749]                         invokeRestart("muffleWarning")
[17:41:00.749]                     }
[17:41:00.749]                     else if (inherits(cond, "condition")) {
[17:41:00.749]                       if (!is.null(pattern)) {
[17:41:00.749]                         computeRestarts <- base::computeRestarts
[17:41:00.749]                         grepl <- base::grepl
[17:41:00.749]                         restarts <- computeRestarts(cond)
[17:41:00.749]                         for (restart in restarts) {
[17:41:00.749]                           name <- restart$name
[17:41:00.749]                           if (is.null(name)) 
[17:41:00.749]                             next
[17:41:00.749]                           if (!grepl(pattern, name)) 
[17:41:00.749]                             next
[17:41:00.749]                           invokeRestart(restart)
[17:41:00.749]                           muffled <- TRUE
[17:41:00.749]                           break
[17:41:00.749]                         }
[17:41:00.749]                       }
[17:41:00.749]                     }
[17:41:00.749]                     invisible(muffled)
[17:41:00.749]                   }
[17:41:00.749]                   muffleCondition(cond)
[17:41:00.749]                 })
[17:41:00.749]             }))
[17:41:00.749]             future::FutureResult(value = ...future.value$value, 
[17:41:00.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.749]                   ...future.rng), globalenv = if (FALSE) 
[17:41:00.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:41:00.749]                     ...future.globalenv.names))
[17:41:00.749]                 else NULL, started = ...future.startTime, version = "1.8")
[17:41:00.749]         }, condition = base::local({
[17:41:00.749]             c <- base::c
[17:41:00.749]             inherits <- base::inherits
[17:41:00.749]             invokeRestart <- base::invokeRestart
[17:41:00.749]             length <- base::length
[17:41:00.749]             list <- base::list
[17:41:00.749]             seq.int <- base::seq.int
[17:41:00.749]             signalCondition <- base::signalCondition
[17:41:00.749]             sys.calls <- base::sys.calls
[17:41:00.749]             `[[` <- base::`[[`
[17:41:00.749]             `+` <- base::`+`
[17:41:00.749]             `<<-` <- base::`<<-`
[17:41:00.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:41:00.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:41:00.749]                   3L)]
[17:41:00.749]             }
[17:41:00.749]             function(cond) {
[17:41:00.749]                 is_error <- inherits(cond, "error")
[17:41:00.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:41:00.749]                   NULL)
[17:41:00.749]                 if (is_error) {
[17:41:00.749]                   sessionInformation <- function() {
[17:41:00.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:41:00.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:41:00.749]                       search = base::search(), system = base::Sys.info())
[17:41:00.749]                   }
[17:41:00.749]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:41:00.749]                     cond$call), session = sessionInformation(), 
[17:41:00.749]                     timestamp = base::Sys.time(), signaled = 0L)
[17:41:00.749]                   signalCondition(cond)
[17:41:00.749]                 }
[17:41:00.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:41:00.749]                 "immediateCondition"))) {
[17:41:00.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:41:00.749]                   ...future.conditions[[length(...future.conditions) + 
[17:41:00.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:41:00.749]                   if (TRUE && !signal) {
[17:41:00.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.749]                     {
[17:41:00.749]                       inherits <- base::inherits
[17:41:00.749]                       invokeRestart <- base::invokeRestart
[17:41:00.749]                       is.null <- base::is.null
[17:41:00.749]                       muffled <- FALSE
[17:41:00.749]                       if (inherits(cond, "message")) {
[17:41:00.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.749]                         if (muffled) 
[17:41:00.749]                           invokeRestart("muffleMessage")
[17:41:00.749]                       }
[17:41:00.749]                       else if (inherits(cond, "warning")) {
[17:41:00.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.749]                         if (muffled) 
[17:41:00.749]                           invokeRestart("muffleWarning")
[17:41:00.749]                       }
[17:41:00.749]                       else if (inherits(cond, "condition")) {
[17:41:00.749]                         if (!is.null(pattern)) {
[17:41:00.749]                           computeRestarts <- base::computeRestarts
[17:41:00.749]                           grepl <- base::grepl
[17:41:00.749]                           restarts <- computeRestarts(cond)
[17:41:00.749]                           for (restart in restarts) {
[17:41:00.749]                             name <- restart$name
[17:41:00.749]                             if (is.null(name)) 
[17:41:00.749]                               next
[17:41:00.749]                             if (!grepl(pattern, name)) 
[17:41:00.749]                               next
[17:41:00.749]                             invokeRestart(restart)
[17:41:00.749]                             muffled <- TRUE
[17:41:00.749]                             break
[17:41:00.749]                           }
[17:41:00.749]                         }
[17:41:00.749]                       }
[17:41:00.749]                       invisible(muffled)
[17:41:00.749]                     }
[17:41:00.749]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.749]                   }
[17:41:00.749]                 }
[17:41:00.749]                 else {
[17:41:00.749]                   if (TRUE) {
[17:41:00.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:41:00.749]                     {
[17:41:00.749]                       inherits <- base::inherits
[17:41:00.749]                       invokeRestart <- base::invokeRestart
[17:41:00.749]                       is.null <- base::is.null
[17:41:00.749]                       muffled <- FALSE
[17:41:00.749]                       if (inherits(cond, "message")) {
[17:41:00.749]                         muffled <- grepl(pattern, "muffleMessage")
[17:41:00.749]                         if (muffled) 
[17:41:00.749]                           invokeRestart("muffleMessage")
[17:41:00.749]                       }
[17:41:00.749]                       else if (inherits(cond, "warning")) {
[17:41:00.749]                         muffled <- grepl(pattern, "muffleWarning")
[17:41:00.749]                         if (muffled) 
[17:41:00.749]                           invokeRestart("muffleWarning")
[17:41:00.749]                       }
[17:41:00.749]                       else if (inherits(cond, "condition")) {
[17:41:00.749]                         if (!is.null(pattern)) {
[17:41:00.749]                           computeRestarts <- base::computeRestarts
[17:41:00.749]                           grepl <- base::grepl
[17:41:00.749]                           restarts <- computeRestarts(cond)
[17:41:00.749]                           for (restart in restarts) {
[17:41:00.749]                             name <- restart$name
[17:41:00.749]                             if (is.null(name)) 
[17:41:00.749]                               next
[17:41:00.749]                             if (!grepl(pattern, name)) 
[17:41:00.749]                               next
[17:41:00.749]                             invokeRestart(restart)
[17:41:00.749]                             muffled <- TRUE
[17:41:00.749]                             break
[17:41:00.749]                           }
[17:41:00.749]                         }
[17:41:00.749]                       }
[17:41:00.749]                       invisible(muffled)
[17:41:00.749]                     }
[17:41:00.749]                     muffleCondition(cond, pattern = "^muffle")
[17:41:00.749]                   }
[17:41:00.749]                 }
[17:41:00.749]             }
[17:41:00.749]         }))
[17:41:00.749]     }, error = function(ex) {
[17:41:00.749]         base::structure(base::list(value = NULL, visible = NULL, 
[17:41:00.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:41:00.749]                 ...future.rng), started = ...future.startTime, 
[17:41:00.749]             finished = Sys.time(), session_uuid = NA_character_, 
[17:41:00.749]             version = "1.8"), class = "FutureResult")
[17:41:00.749]     }, finally = {
[17:41:00.749]         if (!identical(...future.workdir, getwd())) 
[17:41:00.749]             setwd(...future.workdir)
[17:41:00.749]         {
[17:41:00.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:41:00.749]                 ...future.oldOptions$nwarnings <- NULL
[17:41:00.749]             }
[17:41:00.749]             base::options(...future.oldOptions)
[17:41:00.749]             if (.Platform$OS.type == "windows") {
[17:41:00.749]                 old_names <- names(...future.oldEnvVars)
[17:41:00.749]                 envs <- base::Sys.getenv()
[17:41:00.749]                 names <- names(envs)
[17:41:00.749]                 common <- intersect(names, old_names)
[17:41:00.749]                 added <- setdiff(names, old_names)
[17:41:00.749]                 removed <- setdiff(old_names, names)
[17:41:00.749]                 changed <- common[...future.oldEnvVars[common] != 
[17:41:00.749]                   envs[common]]
[17:41:00.749]                 NAMES <- toupper(changed)
[17:41:00.749]                 args <- list()
[17:41:00.749]                 for (kk in seq_along(NAMES)) {
[17:41:00.749]                   name <- changed[[kk]]
[17:41:00.749]                   NAME <- NAMES[[kk]]
[17:41:00.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.749]                     next
[17:41:00.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.749]                 }
[17:41:00.749]                 NAMES <- toupper(added)
[17:41:00.749]                 for (kk in seq_along(NAMES)) {
[17:41:00.749]                   name <- added[[kk]]
[17:41:00.749]                   NAME <- NAMES[[kk]]
[17:41:00.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.749]                     next
[17:41:00.749]                   args[[name]] <- ""
[17:41:00.749]                 }
[17:41:00.749]                 NAMES <- toupper(removed)
[17:41:00.749]                 for (kk in seq_along(NAMES)) {
[17:41:00.749]                   name <- removed[[kk]]
[17:41:00.749]                   NAME <- NAMES[[kk]]
[17:41:00.749]                   if (name != NAME && is.element(NAME, old_names)) 
[17:41:00.749]                     next
[17:41:00.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:41:00.749]                 }
[17:41:00.749]                 if (length(args) > 0) 
[17:41:00.749]                   base::do.call(base::Sys.setenv, args = args)
[17:41:00.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:41:00.749]             }
[17:41:00.749]             else {
[17:41:00.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:41:00.749]             }
[17:41:00.749]             {
[17:41:00.749]                 if (base::length(...future.futureOptionsAdded) > 
[17:41:00.749]                   0L) {
[17:41:00.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:41:00.749]                   base::names(opts) <- ...future.futureOptionsAdded
[17:41:00.749]                   base::options(opts)
[17:41:00.749]                 }
[17:41:00.749]                 {
[17:41:00.749]                   {
[17:41:00.749]                     base::options(mc.cores = ...future.mc.cores.old)
[17:41:00.749]                     NULL
[17:41:00.749]                   }
[17:41:00.749]                   options(future.plan = NULL)
[17:41:00.749]                   if (is.na(NA_character_)) 
[17:41:00.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:41:00.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:41:00.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:41:00.749]                     .init = FALSE)
[17:41:00.749]                 }
[17:41:00.749]             }
[17:41:00.749]         }
[17:41:00.749]     })
[17:41:00.749]     if (TRUE) {
[17:41:00.749]         base::sink(type = "output", split = FALSE)
[17:41:00.749]         if (TRUE) {
[17:41:00.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:41:00.749]         }
[17:41:00.749]         else {
[17:41:00.749]             ...future.result["stdout"] <- base::list(NULL)
[17:41:00.749]         }
[17:41:00.749]         base::close(...future.stdout)
[17:41:00.749]         ...future.stdout <- NULL
[17:41:00.749]     }
[17:41:00.749]     ...future.result$conditions <- ...future.conditions
[17:41:00.749]     ...future.result$finished <- base::Sys.time()
[17:41:00.749]     ...future.result
[17:41:00.749] }
[17:41:00.751] Poll #1 (0): usedNodes() = 2, workers = 2
[17:41:00.761] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.761] - Validating connection of MultisessionFuture
[17:41:00.762] - received message: FutureResult
[17:41:00.762] - Received FutureResult
[17:41:00.762] - Erased future from FutureRegistry
[17:41:00.762] result() for ClusterFuture ...
[17:41:00.762] - result already collected: FutureResult
[17:41:00.762] result() for ClusterFuture ... done
[17:41:00.762] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.762] result() for ClusterFuture ...
[17:41:00.762] - result already collected: FutureResult
[17:41:00.762] result() for ClusterFuture ... done
[17:41:00.763] result() for ClusterFuture ...
[17:41:00.763] - result already collected: FutureResult
[17:41:00.763] result() for ClusterFuture ... done
[17:41:00.764] MultisessionFuture started
[17:41:00.764] - Launch lazy future ... done
[17:41:00.764] run() for ‘MultisessionFuture’ ... done
[17:41:00.765] resolve() on list environment ...
[17:41:00.765]  recursive: 0
[17:41:00.766]  length: 4
[17:41:00.766]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:00.767] Future #1
[17:41:00.767]  length: 3 (resolved future 1)
[17:41:00.778] receiveMessageFromWorker() for ClusterFuture ...
[17:41:00.778] - Validating connection of MultisessionFuture
[17:41:00.778] - received message: FutureResult
[17:41:00.778] - Received FutureResult
[17:41:00.778] - Erased future from FutureRegistry
[17:41:00.778] result() for ClusterFuture ...
[17:41:00.778] - result already collected: FutureResult
[17:41:00.778] result() for ClusterFuture ... done
[17:41:00.779] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:00.779] Future #3
[17:41:00.779]  length: 2 (resolved future 3)
[17:41:00.779]  length: 1 (resolved future 4)
[17:41:01.242] receiveMessageFromWorker() for ClusterFuture ...
[17:41:01.242] - Validating connection of MultisessionFuture
[17:41:01.243] - received message: FutureResult
[17:41:01.243] - Received FutureResult
[17:41:01.243] - Erased future from FutureRegistry
[17:41:01.243] result() for ClusterFuture ...
[17:41:01.243] - result already collected: FutureResult
[17:41:01.243] result() for ClusterFuture ... done
[17:41:01.243] receiveMessageFromWorker() for ClusterFuture ... done
[17:41:01.243] Future #2
[17:41:01.243]  length: 0 (resolved future 2)
[17:41:01.243] resolve() on list environment ... DONE
[17:41:01.244] resolve() on list environment ...
[17:41:01.244]  recursive: 0
[17:41:01.244]  length: 4
[17:41:01.245]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:01.245] Future #1
[17:41:01.245]  length: 3 (resolved future 1)
[17:41:01.245] Future #2
[17:41:01.245]  length: 2 (resolved future 2)
[17:41:01.245] Future #3
[17:41:01.245]  length: 1 (resolved future 3)
[17:41:01.245]  length: 0 (resolved future 4)
[17:41:01.245] resolve() on list environment ... DONE
[17:41:01.246] resolve() on list environment ...
[17:41:01.246]  recursive: 0
[17:41:01.247]  length: 4
[17:41:01.247]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:01.247] Future #1
[17:41:01.247]  length: 3 (resolved future 1)
[17:41:01.247] Future #2
[17:41:01.247]  length: 2 (resolved future 2)
[17:41:01.247] Future #3
[17:41:01.247]  length: 1 (resolved future 3)
[17:41:01.247]  length: 0 (resolved future 4)
[17:41:01.248] resolve() on list environment ... DONE
[17:41:01.248] resolve() on list environment ...
[17:41:01.248]  recursive: 0
[17:41:01.249]  length: 4
[17:41:01.249]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:01.249] Future #1
[17:41:01.249]  length: 3 (resolved future 1)
[17:41:01.249] Future #2
[17:41:01.249]  length: 2 (resolved future 2)
[17:41:01.249] Future #3
[17:41:01.249]  length: 1 (resolved future 3)
[17:41:01.250]  length: 0 (resolved future 4)
[17:41:01.250] resolve() on list environment ... DONE
[17:41:01.250] resolve() on list environment ...
[17:41:01.250]  recursive: 0
[17:41:01.251]  length: 4
[17:41:01.251]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:01.251] Future #1
[17:41:01.251] result() for ClusterFuture ...
[17:41:01.251] - result already collected: FutureResult
[17:41:01.251] result() for ClusterFuture ... done
[17:41:01.251] result() for ClusterFuture ...
[17:41:01.251] - result already collected: FutureResult
[17:41:01.252] result() for ClusterFuture ... done
[17:41:01.252]  length: 3 (resolved future 1)
[17:41:01.252] Future #2
[17:41:01.252] result() for ClusterFuture ...
[17:41:01.252] - result already collected: FutureResult
[17:41:01.252] result() for ClusterFuture ... done
[17:41:01.252] result() for ClusterFuture ...
[17:41:01.252] - result already collected: FutureResult
[17:41:01.252] result() for ClusterFuture ... done
[17:41:01.252]  length: 2 (resolved future 2)
[17:41:01.253] Future #3
[17:41:01.253] result() for ClusterFuture ...
[17:41:01.253] - result already collected: FutureResult
[17:41:01.253] result() for ClusterFuture ... done
[17:41:01.253] result() for ClusterFuture ...
[17:41:01.253] - result already collected: FutureResult
[17:41:01.253] result() for ClusterFuture ... done
[17:41:01.253]  length: 1 (resolved future 3)
[17:41:01.253]  length: 0 (resolved future 4)
[17:41:01.253] resolve() on list environment ... DONE
[17:41:01.254] resolve() on list environment ...
[17:41:01.254]  recursive: 99
[17:41:01.254]  length: 4
[17:41:01.255]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[17:41:01.255] Future #1
[17:41:01.255] result() for ClusterFuture ...
[17:41:01.255] - result already collected: FutureResult
[17:41:01.255] result() for ClusterFuture ... done
[17:41:01.255] result() for ClusterFuture ...
[17:41:01.255] - result already collected: FutureResult
[17:41:01.255] result() for ClusterFuture ... done
[17:41:01.255] A MultisessionFuture was resolved
[17:41:01.255]  length: 3 (resolved future 1)
[17:41:01.256] Future #2
[17:41:01.256] result() for ClusterFuture ...
[17:41:01.256] - result already collected: FutureResult
[17:41:01.256] result() for ClusterFuture ... done
[17:41:01.256] result() for ClusterFuture ...
[17:41:01.256] - result already collected: FutureResult
[17:41:01.256] result() for ClusterFuture ... done
[17:41:01.256] A MultisessionFuture was resolved
[17:41:01.256]  length: 2 (resolved future 2)
[17:41:01.256] Future #3
[17:41:01.257] result() for ClusterFuture ...
[17:41:01.257] - result already collected: FutureResult
[17:41:01.257] result() for ClusterFuture ... done
[17:41:01.257] result() for ClusterFuture ...
[17:41:01.257] - result already collected: FutureResult
[17:41:01.257] result() for ClusterFuture ... done
[17:41:01.260] A MultisessionFuture was resolved
[17:41:01.260]  length: 1 (resolved future 3)
[17:41:01.260]  length: 0 (resolved future 4)
[17:41:01.260] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[17:41:01.264] resolve() on list ...
[17:41:01.264]  recursive: 0
[17:41:01.264]  length: 3
[17:41:01.264] 
[17:41:01.264]  length: 2 (resolved future 1)
[17:41:01.264]  length: 1 (resolved future 2)
[17:41:01.265]  length: 0 (resolved future 3)
[17:41:01.265] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[17:41:01.266] plan(): Setting new future strategy stack:
[17:41:01.266] List of future strategies:
[17:41:01.266] 1. FutureStrategy:
[17:41:01.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:41:01.266]    - tweaked: FALSE
[17:41:01.266]    - call: future::plan(oplan)
[17:41:01.267] plan(): nbrOfWorkers() = 1
> 
