
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[09:32:17.527] plan(): Setting new future strategy stack:
[09:32:17.528] List of future strategies:
[09:32:17.528] 1. sequential:
[09:32:17.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.528]    - tweaked: FALSE
[09:32:17.528]    - call: future::plan("sequential")
[09:32:17.539] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[09:32:17.720] plan(): Setting new future strategy stack:
[09:32:17.720] List of future strategies:
[09:32:17.720] 1. sequential:
[09:32:17.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.720]    - tweaked: FALSE
[09:32:17.720]    - call: plan(strategy)
[09:32:17.730] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[09:32:17.731] resolve() on list ...
[09:32:17.731]  recursive: 0
[09:32:17.731]  length: 2
[09:32:17.731]  elements: ‘a’, ‘b’
[09:32:17.732]  length: 1 (resolved future 1)
[09:32:17.732]  length: 0 (resolved future 2)
[09:32:17.732] resolve() on list ... DONE
[09:32:17.733] getGlobalsAndPackages() ...
[09:32:17.733] Searching for globals...
[09:32:17.735] 
[09:32:17.735] Searching for globals ... DONE
[09:32:17.735] - globals: [0] <none>
[09:32:17.735] getGlobalsAndPackages() ... DONE
[09:32:17.736] run() for ‘Future’ ...
[09:32:17.736] - state: ‘created’
[09:32:17.736] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.737]   - Field: ‘label’
[09:32:17.737]   - Field: ‘local’
[09:32:17.737]   - Field: ‘owner’
[09:32:17.737]   - Field: ‘envir’
[09:32:17.737]   - Field: ‘packages’
[09:32:17.737]   - Field: ‘gc’
[09:32:17.737]   - Field: ‘conditions’
[09:32:17.737]   - Field: ‘expr’
[09:32:17.737]   - Field: ‘uuid’
[09:32:17.738]   - Field: ‘seed’
[09:32:17.738]   - Field: ‘version’
[09:32:17.738]   - Field: ‘result’
[09:32:17.738]   - Field: ‘asynchronous’
[09:32:17.738]   - Field: ‘calls’
[09:32:17.738]   - Field: ‘globals’
[09:32:17.738]   - Field: ‘stdout’
[09:32:17.738]   - Field: ‘earlySignal’
[09:32:17.738]   - Field: ‘lazy’
[09:32:17.738]   - Field: ‘state’
[09:32:17.738] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.738] - Launch lazy future ...
[09:32:17.739] Packages needed by the future expression (n = 0): <none>
[09:32:17.739] Packages needed by future strategies (n = 0): <none>
[09:32:17.740] {
[09:32:17.740]     {
[09:32:17.740]         {
[09:32:17.740]             ...future.startTime <- base::Sys.time()
[09:32:17.740]             {
[09:32:17.740]                 {
[09:32:17.740]                   {
[09:32:17.740]                     base::local({
[09:32:17.740]                       has_future <- base::requireNamespace("future", 
[09:32:17.740]                         quietly = TRUE)
[09:32:17.740]                       if (has_future) {
[09:32:17.740]                         ns <- base::getNamespace("future")
[09:32:17.740]                         version <- ns[[".package"]][["version"]]
[09:32:17.740]                         if (is.null(version)) 
[09:32:17.740]                           version <- utils::packageVersion("future")
[09:32:17.740]                       }
[09:32:17.740]                       else {
[09:32:17.740]                         version <- NULL
[09:32:17.740]                       }
[09:32:17.740]                       if (!has_future || version < "1.8.0") {
[09:32:17.740]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.740]                           "", base::R.version$version.string), 
[09:32:17.740]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.740]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.740]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.740]                             "release", "version")], collapse = " "), 
[09:32:17.740]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.740]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.740]                           info)
[09:32:17.740]                         info <- base::paste(info, collapse = "; ")
[09:32:17.740]                         if (!has_future) {
[09:32:17.740]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.740]                             info)
[09:32:17.740]                         }
[09:32:17.740]                         else {
[09:32:17.740]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.740]                             info, version)
[09:32:17.740]                         }
[09:32:17.740]                         base::stop(msg)
[09:32:17.740]                       }
[09:32:17.740]                     })
[09:32:17.740]                   }
[09:32:17.740]                   ...future.strategy.old <- future::plan("list")
[09:32:17.740]                   options(future.plan = NULL)
[09:32:17.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.740]                 }
[09:32:17.740]                 ...future.workdir <- getwd()
[09:32:17.740]             }
[09:32:17.740]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.740]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.740]         }
[09:32:17.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.740]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.740]             base::names(...future.oldOptions))
[09:32:17.740]     }
[09:32:17.740]     if (FALSE) {
[09:32:17.740]     }
[09:32:17.740]     else {
[09:32:17.740]         if (TRUE) {
[09:32:17.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.740]                 open = "w")
[09:32:17.740]         }
[09:32:17.740]         else {
[09:32:17.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.740]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.740]         }
[09:32:17.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.740]             base::sink(type = "output", split = FALSE)
[09:32:17.740]             base::close(...future.stdout)
[09:32:17.740]         }, add = TRUE)
[09:32:17.740]     }
[09:32:17.740]     ...future.frame <- base::sys.nframe()
[09:32:17.740]     ...future.conditions <- base::list()
[09:32:17.740]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.740]     if (FALSE) {
[09:32:17.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.740]     }
[09:32:17.740]     ...future.result <- base::tryCatch({
[09:32:17.740]         base::withCallingHandlers({
[09:32:17.740]             ...future.value <- base::withVisible(base::local(1))
[09:32:17.740]             future::FutureResult(value = ...future.value$value, 
[09:32:17.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.740]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.740]                     ...future.globalenv.names))
[09:32:17.740]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.740]         }, condition = base::local({
[09:32:17.740]             c <- base::c
[09:32:17.740]             inherits <- base::inherits
[09:32:17.740]             invokeRestart <- base::invokeRestart
[09:32:17.740]             length <- base::length
[09:32:17.740]             list <- base::list
[09:32:17.740]             seq.int <- base::seq.int
[09:32:17.740]             signalCondition <- base::signalCondition
[09:32:17.740]             sys.calls <- base::sys.calls
[09:32:17.740]             `[[` <- base::`[[`
[09:32:17.740]             `+` <- base::`+`
[09:32:17.740]             `<<-` <- base::`<<-`
[09:32:17.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.740]                   3L)]
[09:32:17.740]             }
[09:32:17.740]             function(cond) {
[09:32:17.740]                 is_error <- inherits(cond, "error")
[09:32:17.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.740]                   NULL)
[09:32:17.740]                 if (is_error) {
[09:32:17.740]                   sessionInformation <- function() {
[09:32:17.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.740]                       search = base::search(), system = base::Sys.info())
[09:32:17.740]                   }
[09:32:17.740]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.740]                     cond$call), session = sessionInformation(), 
[09:32:17.740]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.740]                   signalCondition(cond)
[09:32:17.740]                 }
[09:32:17.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.740]                 "immediateCondition"))) {
[09:32:17.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.740]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.740]                   if (TRUE && !signal) {
[09:32:17.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.740]                     {
[09:32:17.740]                       inherits <- base::inherits
[09:32:17.740]                       invokeRestart <- base::invokeRestart
[09:32:17.740]                       is.null <- base::is.null
[09:32:17.740]                       muffled <- FALSE
[09:32:17.740]                       if (inherits(cond, "message")) {
[09:32:17.740]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.740]                         if (muffled) 
[09:32:17.740]                           invokeRestart("muffleMessage")
[09:32:17.740]                       }
[09:32:17.740]                       else if (inherits(cond, "warning")) {
[09:32:17.740]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.740]                         if (muffled) 
[09:32:17.740]                           invokeRestart("muffleWarning")
[09:32:17.740]                       }
[09:32:17.740]                       else if (inherits(cond, "condition")) {
[09:32:17.740]                         if (!is.null(pattern)) {
[09:32:17.740]                           computeRestarts <- base::computeRestarts
[09:32:17.740]                           grepl <- base::grepl
[09:32:17.740]                           restarts <- computeRestarts(cond)
[09:32:17.740]                           for (restart in restarts) {
[09:32:17.740]                             name <- restart$name
[09:32:17.740]                             if (is.null(name)) 
[09:32:17.740]                               next
[09:32:17.740]                             if (!grepl(pattern, name)) 
[09:32:17.740]                               next
[09:32:17.740]                             invokeRestart(restart)
[09:32:17.740]                             muffled <- TRUE
[09:32:17.740]                             break
[09:32:17.740]                           }
[09:32:17.740]                         }
[09:32:17.740]                       }
[09:32:17.740]                       invisible(muffled)
[09:32:17.740]                     }
[09:32:17.740]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.740]                   }
[09:32:17.740]                 }
[09:32:17.740]                 else {
[09:32:17.740]                   if (TRUE) {
[09:32:17.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.740]                     {
[09:32:17.740]                       inherits <- base::inherits
[09:32:17.740]                       invokeRestart <- base::invokeRestart
[09:32:17.740]                       is.null <- base::is.null
[09:32:17.740]                       muffled <- FALSE
[09:32:17.740]                       if (inherits(cond, "message")) {
[09:32:17.740]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.740]                         if (muffled) 
[09:32:17.740]                           invokeRestart("muffleMessage")
[09:32:17.740]                       }
[09:32:17.740]                       else if (inherits(cond, "warning")) {
[09:32:17.740]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.740]                         if (muffled) 
[09:32:17.740]                           invokeRestart("muffleWarning")
[09:32:17.740]                       }
[09:32:17.740]                       else if (inherits(cond, "condition")) {
[09:32:17.740]                         if (!is.null(pattern)) {
[09:32:17.740]                           computeRestarts <- base::computeRestarts
[09:32:17.740]                           grepl <- base::grepl
[09:32:17.740]                           restarts <- computeRestarts(cond)
[09:32:17.740]                           for (restart in restarts) {
[09:32:17.740]                             name <- restart$name
[09:32:17.740]                             if (is.null(name)) 
[09:32:17.740]                               next
[09:32:17.740]                             if (!grepl(pattern, name)) 
[09:32:17.740]                               next
[09:32:17.740]                             invokeRestart(restart)
[09:32:17.740]                             muffled <- TRUE
[09:32:17.740]                             break
[09:32:17.740]                           }
[09:32:17.740]                         }
[09:32:17.740]                       }
[09:32:17.740]                       invisible(muffled)
[09:32:17.740]                     }
[09:32:17.740]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.740]                   }
[09:32:17.740]                 }
[09:32:17.740]             }
[09:32:17.740]         }))
[09:32:17.740]     }, error = function(ex) {
[09:32:17.740]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.740]                 ...future.rng), started = ...future.startTime, 
[09:32:17.740]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.740]             version = "1.8"), class = "FutureResult")
[09:32:17.740]     }, finally = {
[09:32:17.740]         if (!identical(...future.workdir, getwd())) 
[09:32:17.740]             setwd(...future.workdir)
[09:32:17.740]         {
[09:32:17.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.740]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.740]             }
[09:32:17.740]             base::options(...future.oldOptions)
[09:32:17.740]             if (.Platform$OS.type == "windows") {
[09:32:17.740]                 old_names <- names(...future.oldEnvVars)
[09:32:17.740]                 envs <- base::Sys.getenv()
[09:32:17.740]                 names <- names(envs)
[09:32:17.740]                 common <- intersect(names, old_names)
[09:32:17.740]                 added <- setdiff(names, old_names)
[09:32:17.740]                 removed <- setdiff(old_names, names)
[09:32:17.740]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.740]                   envs[common]]
[09:32:17.740]                 NAMES <- toupper(changed)
[09:32:17.740]                 args <- list()
[09:32:17.740]                 for (kk in seq_along(NAMES)) {
[09:32:17.740]                   name <- changed[[kk]]
[09:32:17.740]                   NAME <- NAMES[[kk]]
[09:32:17.740]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.740]                     next
[09:32:17.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.740]                 }
[09:32:17.740]                 NAMES <- toupper(added)
[09:32:17.740]                 for (kk in seq_along(NAMES)) {
[09:32:17.740]                   name <- added[[kk]]
[09:32:17.740]                   NAME <- NAMES[[kk]]
[09:32:17.740]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.740]                     next
[09:32:17.740]                   args[[name]] <- ""
[09:32:17.740]                 }
[09:32:17.740]                 NAMES <- toupper(removed)
[09:32:17.740]                 for (kk in seq_along(NAMES)) {
[09:32:17.740]                   name <- removed[[kk]]
[09:32:17.740]                   NAME <- NAMES[[kk]]
[09:32:17.740]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.740]                     next
[09:32:17.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.740]                 }
[09:32:17.740]                 if (length(args) > 0) 
[09:32:17.740]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.740]             }
[09:32:17.740]             else {
[09:32:17.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.740]             }
[09:32:17.740]             {
[09:32:17.740]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.740]                   0L) {
[09:32:17.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.740]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.740]                   base::options(opts)
[09:32:17.740]                 }
[09:32:17.740]                 {
[09:32:17.740]                   {
[09:32:17.740]                     NULL
[09:32:17.740]                     RNGkind("Mersenne-Twister")
[09:32:17.740]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.740]                       inherits = FALSE)
[09:32:17.740]                   }
[09:32:17.740]                   options(future.plan = NULL)
[09:32:17.740]                   if (is.na(NA_character_)) 
[09:32:17.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.740]                     .init = FALSE)
[09:32:17.740]                 }
[09:32:17.740]             }
[09:32:17.740]         }
[09:32:17.740]     })
[09:32:17.740]     if (TRUE) {
[09:32:17.740]         base::sink(type = "output", split = FALSE)
[09:32:17.740]         if (TRUE) {
[09:32:17.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.740]         }
[09:32:17.740]         else {
[09:32:17.740]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.740]         }
[09:32:17.740]         base::close(...future.stdout)
[09:32:17.740]         ...future.stdout <- NULL
[09:32:17.740]     }
[09:32:17.740]     ...future.result$conditions <- ...future.conditions
[09:32:17.740]     ...future.result$finished <- base::Sys.time()
[09:32:17.740]     ...future.result
[09:32:17.740] }
[09:32:17.742] plan(): Setting new future strategy stack:
[09:32:17.742] List of future strategies:
[09:32:17.742] 1. sequential:
[09:32:17.742]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.742]    - tweaked: FALSE
[09:32:17.742]    - call: NULL
[09:32:17.742] plan(): nbrOfWorkers() = 1
[09:32:17.743] plan(): Setting new future strategy stack:
[09:32:17.743] List of future strategies:
[09:32:17.743] 1. sequential:
[09:32:17.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.743]    - tweaked: FALSE
[09:32:17.743]    - call: plan(strategy)
[09:32:17.744] plan(): nbrOfWorkers() = 1
[09:32:17.744] SequentialFuture started (and completed)
[09:32:17.745] - Launch lazy future ... done
[09:32:17.745] run() for ‘SequentialFuture’ ... done
[09:32:17.745] getGlobalsAndPackages() ...
[09:32:17.745] Searching for globals...
[09:32:17.745] 
[09:32:17.745] Searching for globals ... DONE
[09:32:17.745] - globals: [0] <none>
[09:32:17.745] getGlobalsAndPackages() ... DONE
[09:32:17.746] run() for ‘Future’ ...
[09:32:17.746] - state: ‘created’
[09:32:17.746] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.746] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.746] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.746]   - Field: ‘label’
[09:32:17.746]   - Field: ‘local’
[09:32:17.746]   - Field: ‘owner’
[09:32:17.746]   - Field: ‘envir’
[09:32:17.747]   - Field: ‘packages’
[09:32:17.747]   - Field: ‘gc’
[09:32:17.747]   - Field: ‘conditions’
[09:32:17.747]   - Field: ‘expr’
[09:32:17.747]   - Field: ‘uuid’
[09:32:17.747]   - Field: ‘seed’
[09:32:17.747]   - Field: ‘version’
[09:32:17.747]   - Field: ‘result’
[09:32:17.747]   - Field: ‘asynchronous’
[09:32:17.747]   - Field: ‘calls’
[09:32:17.747]   - Field: ‘globals’
[09:32:17.747]   - Field: ‘stdout’
[09:32:17.748]   - Field: ‘earlySignal’
[09:32:17.748]   - Field: ‘lazy’
[09:32:17.748]   - Field: ‘state’
[09:32:17.748] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.748] - Launch lazy future ...
[09:32:17.748] Packages needed by the future expression (n = 0): <none>
[09:32:17.748] Packages needed by future strategies (n = 0): <none>
[09:32:17.749] {
[09:32:17.749]     {
[09:32:17.749]         {
[09:32:17.749]             ...future.startTime <- base::Sys.time()
[09:32:17.749]             {
[09:32:17.749]                 {
[09:32:17.749]                   {
[09:32:17.749]                     base::local({
[09:32:17.749]                       has_future <- base::requireNamespace("future", 
[09:32:17.749]                         quietly = TRUE)
[09:32:17.749]                       if (has_future) {
[09:32:17.749]                         ns <- base::getNamespace("future")
[09:32:17.749]                         version <- ns[[".package"]][["version"]]
[09:32:17.749]                         if (is.null(version)) 
[09:32:17.749]                           version <- utils::packageVersion("future")
[09:32:17.749]                       }
[09:32:17.749]                       else {
[09:32:17.749]                         version <- NULL
[09:32:17.749]                       }
[09:32:17.749]                       if (!has_future || version < "1.8.0") {
[09:32:17.749]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.749]                           "", base::R.version$version.string), 
[09:32:17.749]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.749]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.749]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.749]                             "release", "version")], collapse = " "), 
[09:32:17.749]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.749]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.749]                           info)
[09:32:17.749]                         info <- base::paste(info, collapse = "; ")
[09:32:17.749]                         if (!has_future) {
[09:32:17.749]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.749]                             info)
[09:32:17.749]                         }
[09:32:17.749]                         else {
[09:32:17.749]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.749]                             info, version)
[09:32:17.749]                         }
[09:32:17.749]                         base::stop(msg)
[09:32:17.749]                       }
[09:32:17.749]                     })
[09:32:17.749]                   }
[09:32:17.749]                   ...future.strategy.old <- future::plan("list")
[09:32:17.749]                   options(future.plan = NULL)
[09:32:17.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.749]                 }
[09:32:17.749]                 ...future.workdir <- getwd()
[09:32:17.749]             }
[09:32:17.749]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.749]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.749]         }
[09:32:17.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.749]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.749]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.749]             base::names(...future.oldOptions))
[09:32:17.749]     }
[09:32:17.749]     if (FALSE) {
[09:32:17.749]     }
[09:32:17.749]     else {
[09:32:17.749]         if (TRUE) {
[09:32:17.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.749]                 open = "w")
[09:32:17.749]         }
[09:32:17.749]         else {
[09:32:17.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.749]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.749]         }
[09:32:17.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.749]             base::sink(type = "output", split = FALSE)
[09:32:17.749]             base::close(...future.stdout)
[09:32:17.749]         }, add = TRUE)
[09:32:17.749]     }
[09:32:17.749]     ...future.frame <- base::sys.nframe()
[09:32:17.749]     ...future.conditions <- base::list()
[09:32:17.749]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.749]     if (FALSE) {
[09:32:17.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.749]     }
[09:32:17.749]     ...future.result <- base::tryCatch({
[09:32:17.749]         base::withCallingHandlers({
[09:32:17.749]             ...future.value <- base::withVisible(base::local(2))
[09:32:17.749]             future::FutureResult(value = ...future.value$value, 
[09:32:17.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.749]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.749]                     ...future.globalenv.names))
[09:32:17.749]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.749]         }, condition = base::local({
[09:32:17.749]             c <- base::c
[09:32:17.749]             inherits <- base::inherits
[09:32:17.749]             invokeRestart <- base::invokeRestart
[09:32:17.749]             length <- base::length
[09:32:17.749]             list <- base::list
[09:32:17.749]             seq.int <- base::seq.int
[09:32:17.749]             signalCondition <- base::signalCondition
[09:32:17.749]             sys.calls <- base::sys.calls
[09:32:17.749]             `[[` <- base::`[[`
[09:32:17.749]             `+` <- base::`+`
[09:32:17.749]             `<<-` <- base::`<<-`
[09:32:17.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.749]                   3L)]
[09:32:17.749]             }
[09:32:17.749]             function(cond) {
[09:32:17.749]                 is_error <- inherits(cond, "error")
[09:32:17.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.749]                   NULL)
[09:32:17.749]                 if (is_error) {
[09:32:17.749]                   sessionInformation <- function() {
[09:32:17.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.749]                       search = base::search(), system = base::Sys.info())
[09:32:17.749]                   }
[09:32:17.749]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.749]                     cond$call), session = sessionInformation(), 
[09:32:17.749]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.749]                   signalCondition(cond)
[09:32:17.749]                 }
[09:32:17.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.749]                 "immediateCondition"))) {
[09:32:17.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.749]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.749]                   if (TRUE && !signal) {
[09:32:17.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.749]                     {
[09:32:17.749]                       inherits <- base::inherits
[09:32:17.749]                       invokeRestart <- base::invokeRestart
[09:32:17.749]                       is.null <- base::is.null
[09:32:17.749]                       muffled <- FALSE
[09:32:17.749]                       if (inherits(cond, "message")) {
[09:32:17.749]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.749]                         if (muffled) 
[09:32:17.749]                           invokeRestart("muffleMessage")
[09:32:17.749]                       }
[09:32:17.749]                       else if (inherits(cond, "warning")) {
[09:32:17.749]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.749]                         if (muffled) 
[09:32:17.749]                           invokeRestart("muffleWarning")
[09:32:17.749]                       }
[09:32:17.749]                       else if (inherits(cond, "condition")) {
[09:32:17.749]                         if (!is.null(pattern)) {
[09:32:17.749]                           computeRestarts <- base::computeRestarts
[09:32:17.749]                           grepl <- base::grepl
[09:32:17.749]                           restarts <- computeRestarts(cond)
[09:32:17.749]                           for (restart in restarts) {
[09:32:17.749]                             name <- restart$name
[09:32:17.749]                             if (is.null(name)) 
[09:32:17.749]                               next
[09:32:17.749]                             if (!grepl(pattern, name)) 
[09:32:17.749]                               next
[09:32:17.749]                             invokeRestart(restart)
[09:32:17.749]                             muffled <- TRUE
[09:32:17.749]                             break
[09:32:17.749]                           }
[09:32:17.749]                         }
[09:32:17.749]                       }
[09:32:17.749]                       invisible(muffled)
[09:32:17.749]                     }
[09:32:17.749]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.749]                   }
[09:32:17.749]                 }
[09:32:17.749]                 else {
[09:32:17.749]                   if (TRUE) {
[09:32:17.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.749]                     {
[09:32:17.749]                       inherits <- base::inherits
[09:32:17.749]                       invokeRestart <- base::invokeRestart
[09:32:17.749]                       is.null <- base::is.null
[09:32:17.749]                       muffled <- FALSE
[09:32:17.749]                       if (inherits(cond, "message")) {
[09:32:17.749]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.749]                         if (muffled) 
[09:32:17.749]                           invokeRestart("muffleMessage")
[09:32:17.749]                       }
[09:32:17.749]                       else if (inherits(cond, "warning")) {
[09:32:17.749]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.749]                         if (muffled) 
[09:32:17.749]                           invokeRestart("muffleWarning")
[09:32:17.749]                       }
[09:32:17.749]                       else if (inherits(cond, "condition")) {
[09:32:17.749]                         if (!is.null(pattern)) {
[09:32:17.749]                           computeRestarts <- base::computeRestarts
[09:32:17.749]                           grepl <- base::grepl
[09:32:17.749]                           restarts <- computeRestarts(cond)
[09:32:17.749]                           for (restart in restarts) {
[09:32:17.749]                             name <- restart$name
[09:32:17.749]                             if (is.null(name)) 
[09:32:17.749]                               next
[09:32:17.749]                             if (!grepl(pattern, name)) 
[09:32:17.749]                               next
[09:32:17.749]                             invokeRestart(restart)
[09:32:17.749]                             muffled <- TRUE
[09:32:17.749]                             break
[09:32:17.749]                           }
[09:32:17.749]                         }
[09:32:17.749]                       }
[09:32:17.749]                       invisible(muffled)
[09:32:17.749]                     }
[09:32:17.749]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.749]                   }
[09:32:17.749]                 }
[09:32:17.749]             }
[09:32:17.749]         }))
[09:32:17.749]     }, error = function(ex) {
[09:32:17.749]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.749]                 ...future.rng), started = ...future.startTime, 
[09:32:17.749]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.749]             version = "1.8"), class = "FutureResult")
[09:32:17.749]     }, finally = {
[09:32:17.749]         if (!identical(...future.workdir, getwd())) 
[09:32:17.749]             setwd(...future.workdir)
[09:32:17.749]         {
[09:32:17.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.749]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.749]             }
[09:32:17.749]             base::options(...future.oldOptions)
[09:32:17.749]             if (.Platform$OS.type == "windows") {
[09:32:17.749]                 old_names <- names(...future.oldEnvVars)
[09:32:17.749]                 envs <- base::Sys.getenv()
[09:32:17.749]                 names <- names(envs)
[09:32:17.749]                 common <- intersect(names, old_names)
[09:32:17.749]                 added <- setdiff(names, old_names)
[09:32:17.749]                 removed <- setdiff(old_names, names)
[09:32:17.749]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.749]                   envs[common]]
[09:32:17.749]                 NAMES <- toupper(changed)
[09:32:17.749]                 args <- list()
[09:32:17.749]                 for (kk in seq_along(NAMES)) {
[09:32:17.749]                   name <- changed[[kk]]
[09:32:17.749]                   NAME <- NAMES[[kk]]
[09:32:17.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.749]                     next
[09:32:17.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.749]                 }
[09:32:17.749]                 NAMES <- toupper(added)
[09:32:17.749]                 for (kk in seq_along(NAMES)) {
[09:32:17.749]                   name <- added[[kk]]
[09:32:17.749]                   NAME <- NAMES[[kk]]
[09:32:17.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.749]                     next
[09:32:17.749]                   args[[name]] <- ""
[09:32:17.749]                 }
[09:32:17.749]                 NAMES <- toupper(removed)
[09:32:17.749]                 for (kk in seq_along(NAMES)) {
[09:32:17.749]                   name <- removed[[kk]]
[09:32:17.749]                   NAME <- NAMES[[kk]]
[09:32:17.749]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.749]                     next
[09:32:17.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.749]                 }
[09:32:17.749]                 if (length(args) > 0) 
[09:32:17.749]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.749]             }
[09:32:17.749]             else {
[09:32:17.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.749]             }
[09:32:17.749]             {
[09:32:17.749]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.749]                   0L) {
[09:32:17.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.749]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.749]                   base::options(opts)
[09:32:17.749]                 }
[09:32:17.749]                 {
[09:32:17.749]                   {
[09:32:17.749]                     NULL
[09:32:17.749]                     RNGkind("Mersenne-Twister")
[09:32:17.749]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.749]                       inherits = FALSE)
[09:32:17.749]                   }
[09:32:17.749]                   options(future.plan = NULL)
[09:32:17.749]                   if (is.na(NA_character_)) 
[09:32:17.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.749]                     .init = FALSE)
[09:32:17.749]                 }
[09:32:17.749]             }
[09:32:17.749]         }
[09:32:17.749]     })
[09:32:17.749]     if (TRUE) {
[09:32:17.749]         base::sink(type = "output", split = FALSE)
[09:32:17.749]         if (TRUE) {
[09:32:17.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.749]         }
[09:32:17.749]         else {
[09:32:17.749]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.749]         }
[09:32:17.749]         base::close(...future.stdout)
[09:32:17.749]         ...future.stdout <- NULL
[09:32:17.749]     }
[09:32:17.749]     ...future.result$conditions <- ...future.conditions
[09:32:17.749]     ...future.result$finished <- base::Sys.time()
[09:32:17.749]     ...future.result
[09:32:17.749] }
[09:32:17.750] plan(): Setting new future strategy stack:
[09:32:17.750] List of future strategies:
[09:32:17.750] 1. sequential:
[09:32:17.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.750]    - tweaked: FALSE
[09:32:17.750]    - call: NULL
[09:32:17.751] plan(): nbrOfWorkers() = 1
[09:32:17.752] plan(): Setting new future strategy stack:
[09:32:17.752] List of future strategies:
[09:32:17.752] 1. sequential:
[09:32:17.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.752]    - tweaked: FALSE
[09:32:17.752]    - call: plan(strategy)
[09:32:17.752] plan(): nbrOfWorkers() = 1
[09:32:17.752] SequentialFuture started (and completed)
[09:32:17.752] - Launch lazy future ... done
[09:32:17.752] run() for ‘SequentialFuture’ ... done
[09:32:17.753] resolve() on list ...
[09:32:17.753]  recursive: 0
[09:32:17.753]  length: 3
[09:32:17.753]  elements: ‘a’, ‘b’, ‘’
[09:32:17.753] resolved() for ‘SequentialFuture’ ...
[09:32:17.753] - state: ‘finished’
[09:32:17.753] - run: TRUE
[09:32:17.753] - result: ‘FutureResult’
[09:32:17.753] resolved() for ‘SequentialFuture’ ... done
[09:32:17.753] Future #1
[09:32:17.754]  length: 2 (resolved future 1)
[09:32:17.754] resolved() for ‘SequentialFuture’ ...
[09:32:17.754] - state: ‘finished’
[09:32:17.754] - run: TRUE
[09:32:17.754] - result: ‘FutureResult’
[09:32:17.754] resolved() for ‘SequentialFuture’ ... done
[09:32:17.754] Future #2
[09:32:17.754]  length: 1 (resolved future 2)
[09:32:17.754]  length: 0 (resolved future 3)
[09:32:17.754] resolve() on list ... DONE
[09:32:17.755] resolved() for ‘SequentialFuture’ ...
[09:32:17.755] - state: ‘finished’
[09:32:17.755] - run: TRUE
[09:32:17.755] - result: ‘FutureResult’
[09:32:17.755] resolved() for ‘SequentialFuture’ ... done
[09:32:17.755] resolved() for ‘SequentialFuture’ ...
[09:32:17.755] - state: ‘finished’
[09:32:17.755] - run: TRUE
[09:32:17.755] - result: ‘FutureResult’
[09:32:17.755] resolved() for ‘SequentialFuture’ ... done
[09:32:17.755] getGlobalsAndPackages() ...
[09:32:17.756] Searching for globals...
[09:32:17.756] 
[09:32:17.756] Searching for globals ... DONE
[09:32:17.756] - globals: [0] <none>
[09:32:17.756] getGlobalsAndPackages() ... DONE
[09:32:17.756] getGlobalsAndPackages() ...
[09:32:17.756] Searching for globals...
[09:32:17.757] 
[09:32:17.757] Searching for globals ... DONE
[09:32:17.757] - globals: [0] <none>
[09:32:17.757] getGlobalsAndPackages() ... DONE
[09:32:17.757] run() for ‘Future’ ...
[09:32:17.757] - state: ‘created’
[09:32:17.757] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.758] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.758] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.758]   - Field: ‘label’
[09:32:17.758]   - Field: ‘local’
[09:32:17.758]   - Field: ‘owner’
[09:32:17.758]   - Field: ‘envir’
[09:32:17.758]   - Field: ‘packages’
[09:32:17.758]   - Field: ‘gc’
[09:32:17.758]   - Field: ‘conditions’
[09:32:17.758]   - Field: ‘expr’
[09:32:17.758]   - Field: ‘uuid’
[09:32:17.759]   - Field: ‘seed’
[09:32:17.759]   - Field: ‘version’
[09:32:17.759]   - Field: ‘result’
[09:32:17.759]   - Field: ‘asynchronous’
[09:32:17.759]   - Field: ‘calls’
[09:32:17.759]   - Field: ‘globals’
[09:32:17.759]   - Field: ‘stdout’
[09:32:17.759]   - Field: ‘earlySignal’
[09:32:17.759]   - Field: ‘lazy’
[09:32:17.759]   - Field: ‘state’
[09:32:17.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.760] - Launch lazy future ...
[09:32:17.760] Packages needed by the future expression (n = 0): <none>
[09:32:17.760] Packages needed by future strategies (n = 0): <none>
[09:32:17.760] {
[09:32:17.760]     {
[09:32:17.760]         {
[09:32:17.760]             ...future.startTime <- base::Sys.time()
[09:32:17.760]             {
[09:32:17.760]                 {
[09:32:17.760]                   {
[09:32:17.760]                     base::local({
[09:32:17.760]                       has_future <- base::requireNamespace("future", 
[09:32:17.760]                         quietly = TRUE)
[09:32:17.760]                       if (has_future) {
[09:32:17.760]                         ns <- base::getNamespace("future")
[09:32:17.760]                         version <- ns[[".package"]][["version"]]
[09:32:17.760]                         if (is.null(version)) 
[09:32:17.760]                           version <- utils::packageVersion("future")
[09:32:17.760]                       }
[09:32:17.760]                       else {
[09:32:17.760]                         version <- NULL
[09:32:17.760]                       }
[09:32:17.760]                       if (!has_future || version < "1.8.0") {
[09:32:17.760]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.760]                           "", base::R.version$version.string), 
[09:32:17.760]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.760]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.760]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.760]                             "release", "version")], collapse = " "), 
[09:32:17.760]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.760]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.760]                           info)
[09:32:17.760]                         info <- base::paste(info, collapse = "; ")
[09:32:17.760]                         if (!has_future) {
[09:32:17.760]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.760]                             info)
[09:32:17.760]                         }
[09:32:17.760]                         else {
[09:32:17.760]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.760]                             info, version)
[09:32:17.760]                         }
[09:32:17.760]                         base::stop(msg)
[09:32:17.760]                       }
[09:32:17.760]                     })
[09:32:17.760]                   }
[09:32:17.760]                   ...future.strategy.old <- future::plan("list")
[09:32:17.760]                   options(future.plan = NULL)
[09:32:17.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.760]                 }
[09:32:17.760]                 ...future.workdir <- getwd()
[09:32:17.760]             }
[09:32:17.760]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.760]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.760]         }
[09:32:17.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.760]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.760]             base::names(...future.oldOptions))
[09:32:17.760]     }
[09:32:17.760]     if (FALSE) {
[09:32:17.760]     }
[09:32:17.760]     else {
[09:32:17.760]         if (TRUE) {
[09:32:17.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.760]                 open = "w")
[09:32:17.760]         }
[09:32:17.760]         else {
[09:32:17.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.760]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.760]         }
[09:32:17.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.760]             base::sink(type = "output", split = FALSE)
[09:32:17.760]             base::close(...future.stdout)
[09:32:17.760]         }, add = TRUE)
[09:32:17.760]     }
[09:32:17.760]     ...future.frame <- base::sys.nframe()
[09:32:17.760]     ...future.conditions <- base::list()
[09:32:17.760]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.760]     if (FALSE) {
[09:32:17.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.760]     }
[09:32:17.760]     ...future.result <- base::tryCatch({
[09:32:17.760]         base::withCallingHandlers({
[09:32:17.760]             ...future.value <- base::withVisible(base::local(2))
[09:32:17.760]             future::FutureResult(value = ...future.value$value, 
[09:32:17.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.760]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.760]                     ...future.globalenv.names))
[09:32:17.760]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.760]         }, condition = base::local({
[09:32:17.760]             c <- base::c
[09:32:17.760]             inherits <- base::inherits
[09:32:17.760]             invokeRestart <- base::invokeRestart
[09:32:17.760]             length <- base::length
[09:32:17.760]             list <- base::list
[09:32:17.760]             seq.int <- base::seq.int
[09:32:17.760]             signalCondition <- base::signalCondition
[09:32:17.760]             sys.calls <- base::sys.calls
[09:32:17.760]             `[[` <- base::`[[`
[09:32:17.760]             `+` <- base::`+`
[09:32:17.760]             `<<-` <- base::`<<-`
[09:32:17.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.760]                   3L)]
[09:32:17.760]             }
[09:32:17.760]             function(cond) {
[09:32:17.760]                 is_error <- inherits(cond, "error")
[09:32:17.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.760]                   NULL)
[09:32:17.760]                 if (is_error) {
[09:32:17.760]                   sessionInformation <- function() {
[09:32:17.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.760]                       search = base::search(), system = base::Sys.info())
[09:32:17.760]                   }
[09:32:17.760]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.760]                     cond$call), session = sessionInformation(), 
[09:32:17.760]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.760]                   signalCondition(cond)
[09:32:17.760]                 }
[09:32:17.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.760]                 "immediateCondition"))) {
[09:32:17.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.760]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.760]                   if (TRUE && !signal) {
[09:32:17.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.760]                     {
[09:32:17.760]                       inherits <- base::inherits
[09:32:17.760]                       invokeRestart <- base::invokeRestart
[09:32:17.760]                       is.null <- base::is.null
[09:32:17.760]                       muffled <- FALSE
[09:32:17.760]                       if (inherits(cond, "message")) {
[09:32:17.760]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.760]                         if (muffled) 
[09:32:17.760]                           invokeRestart("muffleMessage")
[09:32:17.760]                       }
[09:32:17.760]                       else if (inherits(cond, "warning")) {
[09:32:17.760]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.760]                         if (muffled) 
[09:32:17.760]                           invokeRestart("muffleWarning")
[09:32:17.760]                       }
[09:32:17.760]                       else if (inherits(cond, "condition")) {
[09:32:17.760]                         if (!is.null(pattern)) {
[09:32:17.760]                           computeRestarts <- base::computeRestarts
[09:32:17.760]                           grepl <- base::grepl
[09:32:17.760]                           restarts <- computeRestarts(cond)
[09:32:17.760]                           for (restart in restarts) {
[09:32:17.760]                             name <- restart$name
[09:32:17.760]                             if (is.null(name)) 
[09:32:17.760]                               next
[09:32:17.760]                             if (!grepl(pattern, name)) 
[09:32:17.760]                               next
[09:32:17.760]                             invokeRestart(restart)
[09:32:17.760]                             muffled <- TRUE
[09:32:17.760]                             break
[09:32:17.760]                           }
[09:32:17.760]                         }
[09:32:17.760]                       }
[09:32:17.760]                       invisible(muffled)
[09:32:17.760]                     }
[09:32:17.760]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.760]                   }
[09:32:17.760]                 }
[09:32:17.760]                 else {
[09:32:17.760]                   if (TRUE) {
[09:32:17.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.760]                     {
[09:32:17.760]                       inherits <- base::inherits
[09:32:17.760]                       invokeRestart <- base::invokeRestart
[09:32:17.760]                       is.null <- base::is.null
[09:32:17.760]                       muffled <- FALSE
[09:32:17.760]                       if (inherits(cond, "message")) {
[09:32:17.760]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.760]                         if (muffled) 
[09:32:17.760]                           invokeRestart("muffleMessage")
[09:32:17.760]                       }
[09:32:17.760]                       else if (inherits(cond, "warning")) {
[09:32:17.760]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.760]                         if (muffled) 
[09:32:17.760]                           invokeRestart("muffleWarning")
[09:32:17.760]                       }
[09:32:17.760]                       else if (inherits(cond, "condition")) {
[09:32:17.760]                         if (!is.null(pattern)) {
[09:32:17.760]                           computeRestarts <- base::computeRestarts
[09:32:17.760]                           grepl <- base::grepl
[09:32:17.760]                           restarts <- computeRestarts(cond)
[09:32:17.760]                           for (restart in restarts) {
[09:32:17.760]                             name <- restart$name
[09:32:17.760]                             if (is.null(name)) 
[09:32:17.760]                               next
[09:32:17.760]                             if (!grepl(pattern, name)) 
[09:32:17.760]                               next
[09:32:17.760]                             invokeRestart(restart)
[09:32:17.760]                             muffled <- TRUE
[09:32:17.760]                             break
[09:32:17.760]                           }
[09:32:17.760]                         }
[09:32:17.760]                       }
[09:32:17.760]                       invisible(muffled)
[09:32:17.760]                     }
[09:32:17.760]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.760]                   }
[09:32:17.760]                 }
[09:32:17.760]             }
[09:32:17.760]         }))
[09:32:17.760]     }, error = function(ex) {
[09:32:17.760]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.760]                 ...future.rng), started = ...future.startTime, 
[09:32:17.760]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.760]             version = "1.8"), class = "FutureResult")
[09:32:17.760]     }, finally = {
[09:32:17.760]         if (!identical(...future.workdir, getwd())) 
[09:32:17.760]             setwd(...future.workdir)
[09:32:17.760]         {
[09:32:17.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.760]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.760]             }
[09:32:17.760]             base::options(...future.oldOptions)
[09:32:17.760]             if (.Platform$OS.type == "windows") {
[09:32:17.760]                 old_names <- names(...future.oldEnvVars)
[09:32:17.760]                 envs <- base::Sys.getenv()
[09:32:17.760]                 names <- names(envs)
[09:32:17.760]                 common <- intersect(names, old_names)
[09:32:17.760]                 added <- setdiff(names, old_names)
[09:32:17.760]                 removed <- setdiff(old_names, names)
[09:32:17.760]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.760]                   envs[common]]
[09:32:17.760]                 NAMES <- toupper(changed)
[09:32:17.760]                 args <- list()
[09:32:17.760]                 for (kk in seq_along(NAMES)) {
[09:32:17.760]                   name <- changed[[kk]]
[09:32:17.760]                   NAME <- NAMES[[kk]]
[09:32:17.760]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.760]                     next
[09:32:17.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.760]                 }
[09:32:17.760]                 NAMES <- toupper(added)
[09:32:17.760]                 for (kk in seq_along(NAMES)) {
[09:32:17.760]                   name <- added[[kk]]
[09:32:17.760]                   NAME <- NAMES[[kk]]
[09:32:17.760]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.760]                     next
[09:32:17.760]                   args[[name]] <- ""
[09:32:17.760]                 }
[09:32:17.760]                 NAMES <- toupper(removed)
[09:32:17.760]                 for (kk in seq_along(NAMES)) {
[09:32:17.760]                   name <- removed[[kk]]
[09:32:17.760]                   NAME <- NAMES[[kk]]
[09:32:17.760]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.760]                     next
[09:32:17.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.760]                 }
[09:32:17.760]                 if (length(args) > 0) 
[09:32:17.760]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.760]             }
[09:32:17.760]             else {
[09:32:17.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.760]             }
[09:32:17.760]             {
[09:32:17.760]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.760]                   0L) {
[09:32:17.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.760]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.760]                   base::options(opts)
[09:32:17.760]                 }
[09:32:17.760]                 {
[09:32:17.760]                   {
[09:32:17.760]                     NULL
[09:32:17.760]                     RNGkind("Mersenne-Twister")
[09:32:17.760]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.760]                       inherits = FALSE)
[09:32:17.760]                   }
[09:32:17.760]                   options(future.plan = NULL)
[09:32:17.760]                   if (is.na(NA_character_)) 
[09:32:17.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.760]                     .init = FALSE)
[09:32:17.760]                 }
[09:32:17.760]             }
[09:32:17.760]         }
[09:32:17.760]     })
[09:32:17.760]     if (TRUE) {
[09:32:17.760]         base::sink(type = "output", split = FALSE)
[09:32:17.760]         if (TRUE) {
[09:32:17.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.760]         }
[09:32:17.760]         else {
[09:32:17.760]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.760]         }
[09:32:17.760]         base::close(...future.stdout)
[09:32:17.760]         ...future.stdout <- NULL
[09:32:17.760]     }
[09:32:17.760]     ...future.result$conditions <- ...future.conditions
[09:32:17.760]     ...future.result$finished <- base::Sys.time()
[09:32:17.760]     ...future.result
[09:32:17.760] }
[09:32:17.762] plan(): Setting new future strategy stack:
[09:32:17.762] List of future strategies:
[09:32:17.762] 1. sequential:
[09:32:17.762]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.762]    - tweaked: FALSE
[09:32:17.762]    - call: NULL
[09:32:17.762] plan(): nbrOfWorkers() = 1
[09:32:17.763] plan(): Setting new future strategy stack:
[09:32:17.763] List of future strategies:
[09:32:17.763] 1. sequential:
[09:32:17.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.763]    - tweaked: FALSE
[09:32:17.763]    - call: plan(strategy)
[09:32:17.763] plan(): nbrOfWorkers() = 1
[09:32:17.764] SequentialFuture started (and completed)
[09:32:17.764] - Launch lazy future ... done
[09:32:17.764] run() for ‘SequentialFuture’ ... done
[09:32:17.764] resolve() on list ...
[09:32:17.764]  recursive: 0
[09:32:17.764]  length: 3
[09:32:17.764]  elements: ‘a’, ‘b’, ‘’
[09:32:17.764] run() for ‘Future’ ...
[09:32:17.764] - state: ‘created’
[09:32:17.765] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.765] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.765] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.765]   - Field: ‘label’
[09:32:17.765]   - Field: ‘local’
[09:32:17.765]   - Field: ‘owner’
[09:32:17.765]   - Field: ‘envir’
[09:32:17.765]   - Field: ‘packages’
[09:32:17.765]   - Field: ‘gc’
[09:32:17.766]   - Field: ‘conditions’
[09:32:17.766]   - Field: ‘expr’
[09:32:17.766]   - Field: ‘uuid’
[09:32:17.766]   - Field: ‘seed’
[09:32:17.766]   - Field: ‘version’
[09:32:17.766]   - Field: ‘result’
[09:32:17.766]   - Field: ‘asynchronous’
[09:32:17.766]   - Field: ‘calls’
[09:32:17.766]   - Field: ‘globals’
[09:32:17.766]   - Field: ‘stdout’
[09:32:17.766]   - Field: ‘earlySignal’
[09:32:17.766]   - Field: ‘lazy’
[09:32:17.767]   - Field: ‘state’
[09:32:17.767] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.767] - Launch lazy future ...
[09:32:17.767] Packages needed by the future expression (n = 0): <none>
[09:32:17.767] Packages needed by future strategies (n = 0): <none>
[09:32:17.767] {
[09:32:17.767]     {
[09:32:17.767]         {
[09:32:17.767]             ...future.startTime <- base::Sys.time()
[09:32:17.767]             {
[09:32:17.767]                 {
[09:32:17.767]                   {
[09:32:17.767]                     base::local({
[09:32:17.767]                       has_future <- base::requireNamespace("future", 
[09:32:17.767]                         quietly = TRUE)
[09:32:17.767]                       if (has_future) {
[09:32:17.767]                         ns <- base::getNamespace("future")
[09:32:17.767]                         version <- ns[[".package"]][["version"]]
[09:32:17.767]                         if (is.null(version)) 
[09:32:17.767]                           version <- utils::packageVersion("future")
[09:32:17.767]                       }
[09:32:17.767]                       else {
[09:32:17.767]                         version <- NULL
[09:32:17.767]                       }
[09:32:17.767]                       if (!has_future || version < "1.8.0") {
[09:32:17.767]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.767]                           "", base::R.version$version.string), 
[09:32:17.767]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.767]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.767]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.767]                             "release", "version")], collapse = " "), 
[09:32:17.767]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.767]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.767]                           info)
[09:32:17.767]                         info <- base::paste(info, collapse = "; ")
[09:32:17.767]                         if (!has_future) {
[09:32:17.767]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.767]                             info)
[09:32:17.767]                         }
[09:32:17.767]                         else {
[09:32:17.767]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.767]                             info, version)
[09:32:17.767]                         }
[09:32:17.767]                         base::stop(msg)
[09:32:17.767]                       }
[09:32:17.767]                     })
[09:32:17.767]                   }
[09:32:17.767]                   ...future.strategy.old <- future::plan("list")
[09:32:17.767]                   options(future.plan = NULL)
[09:32:17.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.767]                 }
[09:32:17.767]                 ...future.workdir <- getwd()
[09:32:17.767]             }
[09:32:17.767]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.767]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.767]         }
[09:32:17.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.767]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.767]             base::names(...future.oldOptions))
[09:32:17.767]     }
[09:32:17.767]     if (FALSE) {
[09:32:17.767]     }
[09:32:17.767]     else {
[09:32:17.767]         if (TRUE) {
[09:32:17.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.767]                 open = "w")
[09:32:17.767]         }
[09:32:17.767]         else {
[09:32:17.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.767]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.767]         }
[09:32:17.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.767]             base::sink(type = "output", split = FALSE)
[09:32:17.767]             base::close(...future.stdout)
[09:32:17.767]         }, add = TRUE)
[09:32:17.767]     }
[09:32:17.767]     ...future.frame <- base::sys.nframe()
[09:32:17.767]     ...future.conditions <- base::list()
[09:32:17.767]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.767]     if (FALSE) {
[09:32:17.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.767]     }
[09:32:17.767]     ...future.result <- base::tryCatch({
[09:32:17.767]         base::withCallingHandlers({
[09:32:17.767]             ...future.value <- base::withVisible(base::local(1))
[09:32:17.767]             future::FutureResult(value = ...future.value$value, 
[09:32:17.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.767]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.767]                     ...future.globalenv.names))
[09:32:17.767]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.767]         }, condition = base::local({
[09:32:17.767]             c <- base::c
[09:32:17.767]             inherits <- base::inherits
[09:32:17.767]             invokeRestart <- base::invokeRestart
[09:32:17.767]             length <- base::length
[09:32:17.767]             list <- base::list
[09:32:17.767]             seq.int <- base::seq.int
[09:32:17.767]             signalCondition <- base::signalCondition
[09:32:17.767]             sys.calls <- base::sys.calls
[09:32:17.767]             `[[` <- base::`[[`
[09:32:17.767]             `+` <- base::`+`
[09:32:17.767]             `<<-` <- base::`<<-`
[09:32:17.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.767]                   3L)]
[09:32:17.767]             }
[09:32:17.767]             function(cond) {
[09:32:17.767]                 is_error <- inherits(cond, "error")
[09:32:17.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.767]                   NULL)
[09:32:17.767]                 if (is_error) {
[09:32:17.767]                   sessionInformation <- function() {
[09:32:17.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.767]                       search = base::search(), system = base::Sys.info())
[09:32:17.767]                   }
[09:32:17.767]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.767]                     cond$call), session = sessionInformation(), 
[09:32:17.767]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.767]                   signalCondition(cond)
[09:32:17.767]                 }
[09:32:17.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.767]                 "immediateCondition"))) {
[09:32:17.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.767]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.767]                   if (TRUE && !signal) {
[09:32:17.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.767]                     {
[09:32:17.767]                       inherits <- base::inherits
[09:32:17.767]                       invokeRestart <- base::invokeRestart
[09:32:17.767]                       is.null <- base::is.null
[09:32:17.767]                       muffled <- FALSE
[09:32:17.767]                       if (inherits(cond, "message")) {
[09:32:17.767]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.767]                         if (muffled) 
[09:32:17.767]                           invokeRestart("muffleMessage")
[09:32:17.767]                       }
[09:32:17.767]                       else if (inherits(cond, "warning")) {
[09:32:17.767]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.767]                         if (muffled) 
[09:32:17.767]                           invokeRestart("muffleWarning")
[09:32:17.767]                       }
[09:32:17.767]                       else if (inherits(cond, "condition")) {
[09:32:17.767]                         if (!is.null(pattern)) {
[09:32:17.767]                           computeRestarts <- base::computeRestarts
[09:32:17.767]                           grepl <- base::grepl
[09:32:17.767]                           restarts <- computeRestarts(cond)
[09:32:17.767]                           for (restart in restarts) {
[09:32:17.767]                             name <- restart$name
[09:32:17.767]                             if (is.null(name)) 
[09:32:17.767]                               next
[09:32:17.767]                             if (!grepl(pattern, name)) 
[09:32:17.767]                               next
[09:32:17.767]                             invokeRestart(restart)
[09:32:17.767]                             muffled <- TRUE
[09:32:17.767]                             break
[09:32:17.767]                           }
[09:32:17.767]                         }
[09:32:17.767]                       }
[09:32:17.767]                       invisible(muffled)
[09:32:17.767]                     }
[09:32:17.767]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.767]                   }
[09:32:17.767]                 }
[09:32:17.767]                 else {
[09:32:17.767]                   if (TRUE) {
[09:32:17.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.767]                     {
[09:32:17.767]                       inherits <- base::inherits
[09:32:17.767]                       invokeRestart <- base::invokeRestart
[09:32:17.767]                       is.null <- base::is.null
[09:32:17.767]                       muffled <- FALSE
[09:32:17.767]                       if (inherits(cond, "message")) {
[09:32:17.767]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.767]                         if (muffled) 
[09:32:17.767]                           invokeRestart("muffleMessage")
[09:32:17.767]                       }
[09:32:17.767]                       else if (inherits(cond, "warning")) {
[09:32:17.767]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.767]                         if (muffled) 
[09:32:17.767]                           invokeRestart("muffleWarning")
[09:32:17.767]                       }
[09:32:17.767]                       else if (inherits(cond, "condition")) {
[09:32:17.767]                         if (!is.null(pattern)) {
[09:32:17.767]                           computeRestarts <- base::computeRestarts
[09:32:17.767]                           grepl <- base::grepl
[09:32:17.767]                           restarts <- computeRestarts(cond)
[09:32:17.767]                           for (restart in restarts) {
[09:32:17.767]                             name <- restart$name
[09:32:17.767]                             if (is.null(name)) 
[09:32:17.767]                               next
[09:32:17.767]                             if (!grepl(pattern, name)) 
[09:32:17.767]                               next
[09:32:17.767]                             invokeRestart(restart)
[09:32:17.767]                             muffled <- TRUE
[09:32:17.767]                             break
[09:32:17.767]                           }
[09:32:17.767]                         }
[09:32:17.767]                       }
[09:32:17.767]                       invisible(muffled)
[09:32:17.767]                     }
[09:32:17.767]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.767]                   }
[09:32:17.767]                 }
[09:32:17.767]             }
[09:32:17.767]         }))
[09:32:17.767]     }, error = function(ex) {
[09:32:17.767]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.767]                 ...future.rng), started = ...future.startTime, 
[09:32:17.767]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.767]             version = "1.8"), class = "FutureResult")
[09:32:17.767]     }, finally = {
[09:32:17.767]         if (!identical(...future.workdir, getwd())) 
[09:32:17.767]             setwd(...future.workdir)
[09:32:17.767]         {
[09:32:17.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.767]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.767]             }
[09:32:17.767]             base::options(...future.oldOptions)
[09:32:17.767]             if (.Platform$OS.type == "windows") {
[09:32:17.767]                 old_names <- names(...future.oldEnvVars)
[09:32:17.767]                 envs <- base::Sys.getenv()
[09:32:17.767]                 names <- names(envs)
[09:32:17.767]                 common <- intersect(names, old_names)
[09:32:17.767]                 added <- setdiff(names, old_names)
[09:32:17.767]                 removed <- setdiff(old_names, names)
[09:32:17.767]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.767]                   envs[common]]
[09:32:17.767]                 NAMES <- toupper(changed)
[09:32:17.767]                 args <- list()
[09:32:17.767]                 for (kk in seq_along(NAMES)) {
[09:32:17.767]                   name <- changed[[kk]]
[09:32:17.767]                   NAME <- NAMES[[kk]]
[09:32:17.767]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.767]                     next
[09:32:17.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.767]                 }
[09:32:17.767]                 NAMES <- toupper(added)
[09:32:17.767]                 for (kk in seq_along(NAMES)) {
[09:32:17.767]                   name <- added[[kk]]
[09:32:17.767]                   NAME <- NAMES[[kk]]
[09:32:17.767]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.767]                     next
[09:32:17.767]                   args[[name]] <- ""
[09:32:17.767]                 }
[09:32:17.767]                 NAMES <- toupper(removed)
[09:32:17.767]                 for (kk in seq_along(NAMES)) {
[09:32:17.767]                   name <- removed[[kk]]
[09:32:17.767]                   NAME <- NAMES[[kk]]
[09:32:17.767]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.767]                     next
[09:32:17.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.767]                 }
[09:32:17.767]                 if (length(args) > 0) 
[09:32:17.767]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.767]             }
[09:32:17.767]             else {
[09:32:17.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.767]             }
[09:32:17.767]             {
[09:32:17.767]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.767]                   0L) {
[09:32:17.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.767]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.767]                   base::options(opts)
[09:32:17.767]                 }
[09:32:17.767]                 {
[09:32:17.767]                   {
[09:32:17.767]                     NULL
[09:32:17.767]                     RNGkind("Mersenne-Twister")
[09:32:17.767]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.767]                       inherits = FALSE)
[09:32:17.767]                   }
[09:32:17.767]                   options(future.plan = NULL)
[09:32:17.767]                   if (is.na(NA_character_)) 
[09:32:17.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.767]                     .init = FALSE)
[09:32:17.767]                 }
[09:32:17.767]             }
[09:32:17.767]         }
[09:32:17.767]     })
[09:32:17.767]     if (TRUE) {
[09:32:17.767]         base::sink(type = "output", split = FALSE)
[09:32:17.767]         if (TRUE) {
[09:32:17.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.767]         }
[09:32:17.767]         else {
[09:32:17.767]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.767]         }
[09:32:17.767]         base::close(...future.stdout)
[09:32:17.767]         ...future.stdout <- NULL
[09:32:17.767]     }
[09:32:17.767]     ...future.result$conditions <- ...future.conditions
[09:32:17.767]     ...future.result$finished <- base::Sys.time()
[09:32:17.767]     ...future.result
[09:32:17.767] }
[09:32:17.769] plan(): Setting new future strategy stack:
[09:32:17.769] List of future strategies:
[09:32:17.769] 1. sequential:
[09:32:17.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.769]    - tweaked: FALSE
[09:32:17.769]    - call: NULL
[09:32:17.771] plan(): nbrOfWorkers() = 1
[09:32:17.772] plan(): Setting new future strategy stack:
[09:32:17.772] List of future strategies:
[09:32:17.772] 1. sequential:
[09:32:17.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.772]    - tweaked: FALSE
[09:32:17.772]    - call: plan(strategy)
[09:32:17.772] plan(): nbrOfWorkers() = 1
[09:32:17.773] SequentialFuture started (and completed)
[09:32:17.773] - Launch lazy future ... done
[09:32:17.773] run() for ‘SequentialFuture’ ... done
[09:32:17.773] resolved() for ‘SequentialFuture’ ...
[09:32:17.773] - state: ‘finished’
[09:32:17.773] - run: TRUE
[09:32:17.773] - result: ‘FutureResult’
[09:32:17.773] resolved() for ‘SequentialFuture’ ... done
[09:32:17.773] Future #1
[09:32:17.773]  length: 2 (resolved future 1)
[09:32:17.774] resolved() for ‘SequentialFuture’ ...
[09:32:17.774] - state: ‘finished’
[09:32:17.774] - run: TRUE
[09:32:17.774] - result: ‘FutureResult’
[09:32:17.774] resolved() for ‘SequentialFuture’ ... done
[09:32:17.774] Future #2
[09:32:17.774]  length: 1 (resolved future 2)
[09:32:17.774]  length: 0 (resolved future 3)
[09:32:17.774] resolve() on list ... DONE
[09:32:17.774] resolved() for ‘SequentialFuture’ ...
[09:32:17.774] - state: ‘finished’
[09:32:17.775] - run: TRUE
[09:32:17.775] - result: ‘FutureResult’
[09:32:17.775] resolved() for ‘SequentialFuture’ ... done
[09:32:17.775] resolved() for ‘SequentialFuture’ ...
[09:32:17.775] - state: ‘finished’
[09:32:17.775] - run: TRUE
[09:32:17.775] - result: ‘FutureResult’
[09:32:17.775] resolved() for ‘SequentialFuture’ ... done
[09:32:17.775] getGlobalsAndPackages() ...
[09:32:17.775] Searching for globals...
[09:32:17.776] 
[09:32:17.776] Searching for globals ... DONE
[09:32:17.776] - globals: [0] <none>
[09:32:17.776] getGlobalsAndPackages() ... DONE
[09:32:17.776] getGlobalsAndPackages() ...
[09:32:17.776] Searching for globals...
[09:32:17.776] 
[09:32:17.777] Searching for globals ... DONE
[09:32:17.777] - globals: [0] <none>
[09:32:17.777] getGlobalsAndPackages() ... DONE
[09:32:17.777] resolve() on list ...
[09:32:17.777]  recursive: 0
[09:32:17.777]  length: 3
[09:32:17.777]  elements: ‘a’, ‘b’, ‘’
[09:32:17.777] run() for ‘Future’ ...
[09:32:17.777] - state: ‘created’
[09:32:17.778] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.778] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.778] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.778]   - Field: ‘label’
[09:32:17.778]   - Field: ‘local’
[09:32:17.778]   - Field: ‘owner’
[09:32:17.778]   - Field: ‘envir’
[09:32:17.778]   - Field: ‘packages’
[09:32:17.778]   - Field: ‘gc’
[09:32:17.779]   - Field: ‘conditions’
[09:32:17.779]   - Field: ‘expr’
[09:32:17.779]   - Field: ‘uuid’
[09:32:17.779]   - Field: ‘seed’
[09:32:17.779]   - Field: ‘version’
[09:32:17.779]   - Field: ‘result’
[09:32:17.779]   - Field: ‘asynchronous’
[09:32:17.779]   - Field: ‘calls’
[09:32:17.779]   - Field: ‘globals’
[09:32:17.779]   - Field: ‘stdout’
[09:32:17.779]   - Field: ‘earlySignal’
[09:32:17.779]   - Field: ‘lazy’
[09:32:17.780]   - Field: ‘state’
[09:32:17.780] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.780] - Launch lazy future ...
[09:32:17.780] Packages needed by the future expression (n = 0): <none>
[09:32:17.780] Packages needed by future strategies (n = 0): <none>
[09:32:17.780] {
[09:32:17.780]     {
[09:32:17.780]         {
[09:32:17.780]             ...future.startTime <- base::Sys.time()
[09:32:17.780]             {
[09:32:17.780]                 {
[09:32:17.780]                   {
[09:32:17.780]                     base::local({
[09:32:17.780]                       has_future <- base::requireNamespace("future", 
[09:32:17.780]                         quietly = TRUE)
[09:32:17.780]                       if (has_future) {
[09:32:17.780]                         ns <- base::getNamespace("future")
[09:32:17.780]                         version <- ns[[".package"]][["version"]]
[09:32:17.780]                         if (is.null(version)) 
[09:32:17.780]                           version <- utils::packageVersion("future")
[09:32:17.780]                       }
[09:32:17.780]                       else {
[09:32:17.780]                         version <- NULL
[09:32:17.780]                       }
[09:32:17.780]                       if (!has_future || version < "1.8.0") {
[09:32:17.780]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.780]                           "", base::R.version$version.string), 
[09:32:17.780]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.780]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.780]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.780]                             "release", "version")], collapse = " "), 
[09:32:17.780]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.780]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.780]                           info)
[09:32:17.780]                         info <- base::paste(info, collapse = "; ")
[09:32:17.780]                         if (!has_future) {
[09:32:17.780]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.780]                             info)
[09:32:17.780]                         }
[09:32:17.780]                         else {
[09:32:17.780]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.780]                             info, version)
[09:32:17.780]                         }
[09:32:17.780]                         base::stop(msg)
[09:32:17.780]                       }
[09:32:17.780]                     })
[09:32:17.780]                   }
[09:32:17.780]                   ...future.strategy.old <- future::plan("list")
[09:32:17.780]                   options(future.plan = NULL)
[09:32:17.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.780]                 }
[09:32:17.780]                 ...future.workdir <- getwd()
[09:32:17.780]             }
[09:32:17.780]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.780]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.780]         }
[09:32:17.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.780]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.780]             base::names(...future.oldOptions))
[09:32:17.780]     }
[09:32:17.780]     if (FALSE) {
[09:32:17.780]     }
[09:32:17.780]     else {
[09:32:17.780]         if (TRUE) {
[09:32:17.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.780]                 open = "w")
[09:32:17.780]         }
[09:32:17.780]         else {
[09:32:17.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.780]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.780]         }
[09:32:17.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.780]             base::sink(type = "output", split = FALSE)
[09:32:17.780]             base::close(...future.stdout)
[09:32:17.780]         }, add = TRUE)
[09:32:17.780]     }
[09:32:17.780]     ...future.frame <- base::sys.nframe()
[09:32:17.780]     ...future.conditions <- base::list()
[09:32:17.780]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.780]     if (FALSE) {
[09:32:17.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.780]     }
[09:32:17.780]     ...future.result <- base::tryCatch({
[09:32:17.780]         base::withCallingHandlers({
[09:32:17.780]             ...future.value <- base::withVisible(base::local(1))
[09:32:17.780]             future::FutureResult(value = ...future.value$value, 
[09:32:17.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.780]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.780]                     ...future.globalenv.names))
[09:32:17.780]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.780]         }, condition = base::local({
[09:32:17.780]             c <- base::c
[09:32:17.780]             inherits <- base::inherits
[09:32:17.780]             invokeRestart <- base::invokeRestart
[09:32:17.780]             length <- base::length
[09:32:17.780]             list <- base::list
[09:32:17.780]             seq.int <- base::seq.int
[09:32:17.780]             signalCondition <- base::signalCondition
[09:32:17.780]             sys.calls <- base::sys.calls
[09:32:17.780]             `[[` <- base::`[[`
[09:32:17.780]             `+` <- base::`+`
[09:32:17.780]             `<<-` <- base::`<<-`
[09:32:17.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.780]                   3L)]
[09:32:17.780]             }
[09:32:17.780]             function(cond) {
[09:32:17.780]                 is_error <- inherits(cond, "error")
[09:32:17.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.780]                   NULL)
[09:32:17.780]                 if (is_error) {
[09:32:17.780]                   sessionInformation <- function() {
[09:32:17.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.780]                       search = base::search(), system = base::Sys.info())
[09:32:17.780]                   }
[09:32:17.780]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.780]                     cond$call), session = sessionInformation(), 
[09:32:17.780]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.780]                   signalCondition(cond)
[09:32:17.780]                 }
[09:32:17.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.780]                 "immediateCondition"))) {
[09:32:17.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.780]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.780]                   if (TRUE && !signal) {
[09:32:17.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.780]                     {
[09:32:17.780]                       inherits <- base::inherits
[09:32:17.780]                       invokeRestart <- base::invokeRestart
[09:32:17.780]                       is.null <- base::is.null
[09:32:17.780]                       muffled <- FALSE
[09:32:17.780]                       if (inherits(cond, "message")) {
[09:32:17.780]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.780]                         if (muffled) 
[09:32:17.780]                           invokeRestart("muffleMessage")
[09:32:17.780]                       }
[09:32:17.780]                       else if (inherits(cond, "warning")) {
[09:32:17.780]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.780]                         if (muffled) 
[09:32:17.780]                           invokeRestart("muffleWarning")
[09:32:17.780]                       }
[09:32:17.780]                       else if (inherits(cond, "condition")) {
[09:32:17.780]                         if (!is.null(pattern)) {
[09:32:17.780]                           computeRestarts <- base::computeRestarts
[09:32:17.780]                           grepl <- base::grepl
[09:32:17.780]                           restarts <- computeRestarts(cond)
[09:32:17.780]                           for (restart in restarts) {
[09:32:17.780]                             name <- restart$name
[09:32:17.780]                             if (is.null(name)) 
[09:32:17.780]                               next
[09:32:17.780]                             if (!grepl(pattern, name)) 
[09:32:17.780]                               next
[09:32:17.780]                             invokeRestart(restart)
[09:32:17.780]                             muffled <- TRUE
[09:32:17.780]                             break
[09:32:17.780]                           }
[09:32:17.780]                         }
[09:32:17.780]                       }
[09:32:17.780]                       invisible(muffled)
[09:32:17.780]                     }
[09:32:17.780]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.780]                   }
[09:32:17.780]                 }
[09:32:17.780]                 else {
[09:32:17.780]                   if (TRUE) {
[09:32:17.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.780]                     {
[09:32:17.780]                       inherits <- base::inherits
[09:32:17.780]                       invokeRestart <- base::invokeRestart
[09:32:17.780]                       is.null <- base::is.null
[09:32:17.780]                       muffled <- FALSE
[09:32:17.780]                       if (inherits(cond, "message")) {
[09:32:17.780]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.780]                         if (muffled) 
[09:32:17.780]                           invokeRestart("muffleMessage")
[09:32:17.780]                       }
[09:32:17.780]                       else if (inherits(cond, "warning")) {
[09:32:17.780]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.780]                         if (muffled) 
[09:32:17.780]                           invokeRestart("muffleWarning")
[09:32:17.780]                       }
[09:32:17.780]                       else if (inherits(cond, "condition")) {
[09:32:17.780]                         if (!is.null(pattern)) {
[09:32:17.780]                           computeRestarts <- base::computeRestarts
[09:32:17.780]                           grepl <- base::grepl
[09:32:17.780]                           restarts <- computeRestarts(cond)
[09:32:17.780]                           for (restart in restarts) {
[09:32:17.780]                             name <- restart$name
[09:32:17.780]                             if (is.null(name)) 
[09:32:17.780]                               next
[09:32:17.780]                             if (!grepl(pattern, name)) 
[09:32:17.780]                               next
[09:32:17.780]                             invokeRestart(restart)
[09:32:17.780]                             muffled <- TRUE
[09:32:17.780]                             break
[09:32:17.780]                           }
[09:32:17.780]                         }
[09:32:17.780]                       }
[09:32:17.780]                       invisible(muffled)
[09:32:17.780]                     }
[09:32:17.780]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.780]                   }
[09:32:17.780]                 }
[09:32:17.780]             }
[09:32:17.780]         }))
[09:32:17.780]     }, error = function(ex) {
[09:32:17.780]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.780]                 ...future.rng), started = ...future.startTime, 
[09:32:17.780]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.780]             version = "1.8"), class = "FutureResult")
[09:32:17.780]     }, finally = {
[09:32:17.780]         if (!identical(...future.workdir, getwd())) 
[09:32:17.780]             setwd(...future.workdir)
[09:32:17.780]         {
[09:32:17.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.780]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.780]             }
[09:32:17.780]             base::options(...future.oldOptions)
[09:32:17.780]             if (.Platform$OS.type == "windows") {
[09:32:17.780]                 old_names <- names(...future.oldEnvVars)
[09:32:17.780]                 envs <- base::Sys.getenv()
[09:32:17.780]                 names <- names(envs)
[09:32:17.780]                 common <- intersect(names, old_names)
[09:32:17.780]                 added <- setdiff(names, old_names)
[09:32:17.780]                 removed <- setdiff(old_names, names)
[09:32:17.780]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.780]                   envs[common]]
[09:32:17.780]                 NAMES <- toupper(changed)
[09:32:17.780]                 args <- list()
[09:32:17.780]                 for (kk in seq_along(NAMES)) {
[09:32:17.780]                   name <- changed[[kk]]
[09:32:17.780]                   NAME <- NAMES[[kk]]
[09:32:17.780]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.780]                     next
[09:32:17.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.780]                 }
[09:32:17.780]                 NAMES <- toupper(added)
[09:32:17.780]                 for (kk in seq_along(NAMES)) {
[09:32:17.780]                   name <- added[[kk]]
[09:32:17.780]                   NAME <- NAMES[[kk]]
[09:32:17.780]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.780]                     next
[09:32:17.780]                   args[[name]] <- ""
[09:32:17.780]                 }
[09:32:17.780]                 NAMES <- toupper(removed)
[09:32:17.780]                 for (kk in seq_along(NAMES)) {
[09:32:17.780]                   name <- removed[[kk]]
[09:32:17.780]                   NAME <- NAMES[[kk]]
[09:32:17.780]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.780]                     next
[09:32:17.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.780]                 }
[09:32:17.780]                 if (length(args) > 0) 
[09:32:17.780]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.780]             }
[09:32:17.780]             else {
[09:32:17.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.780]             }
[09:32:17.780]             {
[09:32:17.780]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.780]                   0L) {
[09:32:17.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.780]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.780]                   base::options(opts)
[09:32:17.780]                 }
[09:32:17.780]                 {
[09:32:17.780]                   {
[09:32:17.780]                     NULL
[09:32:17.780]                     RNGkind("Mersenne-Twister")
[09:32:17.780]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.780]                       inherits = FALSE)
[09:32:17.780]                   }
[09:32:17.780]                   options(future.plan = NULL)
[09:32:17.780]                   if (is.na(NA_character_)) 
[09:32:17.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.780]                     .init = FALSE)
[09:32:17.780]                 }
[09:32:17.780]             }
[09:32:17.780]         }
[09:32:17.780]     })
[09:32:17.780]     if (TRUE) {
[09:32:17.780]         base::sink(type = "output", split = FALSE)
[09:32:17.780]         if (TRUE) {
[09:32:17.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.780]         }
[09:32:17.780]         else {
[09:32:17.780]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.780]         }
[09:32:17.780]         base::close(...future.stdout)
[09:32:17.780]         ...future.stdout <- NULL
[09:32:17.780]     }
[09:32:17.780]     ...future.result$conditions <- ...future.conditions
[09:32:17.780]     ...future.result$finished <- base::Sys.time()
[09:32:17.780]     ...future.result
[09:32:17.780] }
[09:32:17.782] plan(): Setting new future strategy stack:
[09:32:17.782] List of future strategies:
[09:32:17.782] 1. sequential:
[09:32:17.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.782]    - tweaked: FALSE
[09:32:17.782]    - call: NULL
[09:32:17.783] plan(): nbrOfWorkers() = 1
[09:32:17.783] plan(): Setting new future strategy stack:
[09:32:17.783] List of future strategies:
[09:32:17.783] 1. sequential:
[09:32:17.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.783]    - tweaked: FALSE
[09:32:17.783]    - call: plan(strategy)
[09:32:17.784] plan(): nbrOfWorkers() = 1
[09:32:17.784] SequentialFuture started (and completed)
[09:32:17.784] - Launch lazy future ... done
[09:32:17.784] run() for ‘SequentialFuture’ ... done
[09:32:17.784] resolved() for ‘SequentialFuture’ ...
[09:32:17.784] - state: ‘finished’
[09:32:17.784] - run: TRUE
[09:32:17.784] - result: ‘FutureResult’
[09:32:17.785] resolved() for ‘SequentialFuture’ ... done
[09:32:17.785] Future #1
[09:32:17.785]  length: 2 (resolved future 1)
[09:32:17.785] run() for ‘Future’ ...
[09:32:17.785] - state: ‘created’
[09:32:17.785] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.785] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.785]   - Field: ‘label’
[09:32:17.786]   - Field: ‘local’
[09:32:17.786]   - Field: ‘owner’
[09:32:17.786]   - Field: ‘envir’
[09:32:17.786]   - Field: ‘packages’
[09:32:17.786]   - Field: ‘gc’
[09:32:17.786]   - Field: ‘conditions’
[09:32:17.786]   - Field: ‘expr’
[09:32:17.786]   - Field: ‘uuid’
[09:32:17.786]   - Field: ‘seed’
[09:32:17.786]   - Field: ‘version’
[09:32:17.786]   - Field: ‘result’
[09:32:17.786]   - Field: ‘asynchronous’
[09:32:17.787]   - Field: ‘calls’
[09:32:17.787]   - Field: ‘globals’
[09:32:17.787]   - Field: ‘stdout’
[09:32:17.787]   - Field: ‘earlySignal’
[09:32:17.787]   - Field: ‘lazy’
[09:32:17.787]   - Field: ‘state’
[09:32:17.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.787] - Launch lazy future ...
[09:32:17.787] Packages needed by the future expression (n = 0): <none>
[09:32:17.787] Packages needed by future strategies (n = 0): <none>
[09:32:17.788] {
[09:32:17.788]     {
[09:32:17.788]         {
[09:32:17.788]             ...future.startTime <- base::Sys.time()
[09:32:17.788]             {
[09:32:17.788]                 {
[09:32:17.788]                   {
[09:32:17.788]                     base::local({
[09:32:17.788]                       has_future <- base::requireNamespace("future", 
[09:32:17.788]                         quietly = TRUE)
[09:32:17.788]                       if (has_future) {
[09:32:17.788]                         ns <- base::getNamespace("future")
[09:32:17.788]                         version <- ns[[".package"]][["version"]]
[09:32:17.788]                         if (is.null(version)) 
[09:32:17.788]                           version <- utils::packageVersion("future")
[09:32:17.788]                       }
[09:32:17.788]                       else {
[09:32:17.788]                         version <- NULL
[09:32:17.788]                       }
[09:32:17.788]                       if (!has_future || version < "1.8.0") {
[09:32:17.788]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.788]                           "", base::R.version$version.string), 
[09:32:17.788]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.788]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.788]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.788]                             "release", "version")], collapse = " "), 
[09:32:17.788]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.788]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.788]                           info)
[09:32:17.788]                         info <- base::paste(info, collapse = "; ")
[09:32:17.788]                         if (!has_future) {
[09:32:17.788]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.788]                             info)
[09:32:17.788]                         }
[09:32:17.788]                         else {
[09:32:17.788]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.788]                             info, version)
[09:32:17.788]                         }
[09:32:17.788]                         base::stop(msg)
[09:32:17.788]                       }
[09:32:17.788]                     })
[09:32:17.788]                   }
[09:32:17.788]                   ...future.strategy.old <- future::plan("list")
[09:32:17.788]                   options(future.plan = NULL)
[09:32:17.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.788]                 }
[09:32:17.788]                 ...future.workdir <- getwd()
[09:32:17.788]             }
[09:32:17.788]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.788]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.788]         }
[09:32:17.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.788]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.788]             base::names(...future.oldOptions))
[09:32:17.788]     }
[09:32:17.788]     if (FALSE) {
[09:32:17.788]     }
[09:32:17.788]     else {
[09:32:17.788]         if (TRUE) {
[09:32:17.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.788]                 open = "w")
[09:32:17.788]         }
[09:32:17.788]         else {
[09:32:17.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.788]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.788]         }
[09:32:17.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.788]             base::sink(type = "output", split = FALSE)
[09:32:17.788]             base::close(...future.stdout)
[09:32:17.788]         }, add = TRUE)
[09:32:17.788]     }
[09:32:17.788]     ...future.frame <- base::sys.nframe()
[09:32:17.788]     ...future.conditions <- base::list()
[09:32:17.788]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.788]     if (FALSE) {
[09:32:17.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.788]     }
[09:32:17.788]     ...future.result <- base::tryCatch({
[09:32:17.788]         base::withCallingHandlers({
[09:32:17.788]             ...future.value <- base::withVisible(base::local(2))
[09:32:17.788]             future::FutureResult(value = ...future.value$value, 
[09:32:17.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.788]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.788]                     ...future.globalenv.names))
[09:32:17.788]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.788]         }, condition = base::local({
[09:32:17.788]             c <- base::c
[09:32:17.788]             inherits <- base::inherits
[09:32:17.788]             invokeRestart <- base::invokeRestart
[09:32:17.788]             length <- base::length
[09:32:17.788]             list <- base::list
[09:32:17.788]             seq.int <- base::seq.int
[09:32:17.788]             signalCondition <- base::signalCondition
[09:32:17.788]             sys.calls <- base::sys.calls
[09:32:17.788]             `[[` <- base::`[[`
[09:32:17.788]             `+` <- base::`+`
[09:32:17.788]             `<<-` <- base::`<<-`
[09:32:17.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.788]                   3L)]
[09:32:17.788]             }
[09:32:17.788]             function(cond) {
[09:32:17.788]                 is_error <- inherits(cond, "error")
[09:32:17.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.788]                   NULL)
[09:32:17.788]                 if (is_error) {
[09:32:17.788]                   sessionInformation <- function() {
[09:32:17.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.788]                       search = base::search(), system = base::Sys.info())
[09:32:17.788]                   }
[09:32:17.788]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.788]                     cond$call), session = sessionInformation(), 
[09:32:17.788]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.788]                   signalCondition(cond)
[09:32:17.788]                 }
[09:32:17.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.788]                 "immediateCondition"))) {
[09:32:17.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.788]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.788]                   if (TRUE && !signal) {
[09:32:17.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.788]                     {
[09:32:17.788]                       inherits <- base::inherits
[09:32:17.788]                       invokeRestart <- base::invokeRestart
[09:32:17.788]                       is.null <- base::is.null
[09:32:17.788]                       muffled <- FALSE
[09:32:17.788]                       if (inherits(cond, "message")) {
[09:32:17.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.788]                         if (muffled) 
[09:32:17.788]                           invokeRestart("muffleMessage")
[09:32:17.788]                       }
[09:32:17.788]                       else if (inherits(cond, "warning")) {
[09:32:17.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.788]                         if (muffled) 
[09:32:17.788]                           invokeRestart("muffleWarning")
[09:32:17.788]                       }
[09:32:17.788]                       else if (inherits(cond, "condition")) {
[09:32:17.788]                         if (!is.null(pattern)) {
[09:32:17.788]                           computeRestarts <- base::computeRestarts
[09:32:17.788]                           grepl <- base::grepl
[09:32:17.788]                           restarts <- computeRestarts(cond)
[09:32:17.788]                           for (restart in restarts) {
[09:32:17.788]                             name <- restart$name
[09:32:17.788]                             if (is.null(name)) 
[09:32:17.788]                               next
[09:32:17.788]                             if (!grepl(pattern, name)) 
[09:32:17.788]                               next
[09:32:17.788]                             invokeRestart(restart)
[09:32:17.788]                             muffled <- TRUE
[09:32:17.788]                             break
[09:32:17.788]                           }
[09:32:17.788]                         }
[09:32:17.788]                       }
[09:32:17.788]                       invisible(muffled)
[09:32:17.788]                     }
[09:32:17.788]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.788]                   }
[09:32:17.788]                 }
[09:32:17.788]                 else {
[09:32:17.788]                   if (TRUE) {
[09:32:17.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.788]                     {
[09:32:17.788]                       inherits <- base::inherits
[09:32:17.788]                       invokeRestart <- base::invokeRestart
[09:32:17.788]                       is.null <- base::is.null
[09:32:17.788]                       muffled <- FALSE
[09:32:17.788]                       if (inherits(cond, "message")) {
[09:32:17.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.788]                         if (muffled) 
[09:32:17.788]                           invokeRestart("muffleMessage")
[09:32:17.788]                       }
[09:32:17.788]                       else if (inherits(cond, "warning")) {
[09:32:17.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.788]                         if (muffled) 
[09:32:17.788]                           invokeRestart("muffleWarning")
[09:32:17.788]                       }
[09:32:17.788]                       else if (inherits(cond, "condition")) {
[09:32:17.788]                         if (!is.null(pattern)) {
[09:32:17.788]                           computeRestarts <- base::computeRestarts
[09:32:17.788]                           grepl <- base::grepl
[09:32:17.788]                           restarts <- computeRestarts(cond)
[09:32:17.788]                           for (restart in restarts) {
[09:32:17.788]                             name <- restart$name
[09:32:17.788]                             if (is.null(name)) 
[09:32:17.788]                               next
[09:32:17.788]                             if (!grepl(pattern, name)) 
[09:32:17.788]                               next
[09:32:17.788]                             invokeRestart(restart)
[09:32:17.788]                             muffled <- TRUE
[09:32:17.788]                             break
[09:32:17.788]                           }
[09:32:17.788]                         }
[09:32:17.788]                       }
[09:32:17.788]                       invisible(muffled)
[09:32:17.788]                     }
[09:32:17.788]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.788]                   }
[09:32:17.788]                 }
[09:32:17.788]             }
[09:32:17.788]         }))
[09:32:17.788]     }, error = function(ex) {
[09:32:17.788]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.788]                 ...future.rng), started = ...future.startTime, 
[09:32:17.788]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.788]             version = "1.8"), class = "FutureResult")
[09:32:17.788]     }, finally = {
[09:32:17.788]         if (!identical(...future.workdir, getwd())) 
[09:32:17.788]             setwd(...future.workdir)
[09:32:17.788]         {
[09:32:17.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.788]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.788]             }
[09:32:17.788]             base::options(...future.oldOptions)
[09:32:17.788]             if (.Platform$OS.type == "windows") {
[09:32:17.788]                 old_names <- names(...future.oldEnvVars)
[09:32:17.788]                 envs <- base::Sys.getenv()
[09:32:17.788]                 names <- names(envs)
[09:32:17.788]                 common <- intersect(names, old_names)
[09:32:17.788]                 added <- setdiff(names, old_names)
[09:32:17.788]                 removed <- setdiff(old_names, names)
[09:32:17.788]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.788]                   envs[common]]
[09:32:17.788]                 NAMES <- toupper(changed)
[09:32:17.788]                 args <- list()
[09:32:17.788]                 for (kk in seq_along(NAMES)) {
[09:32:17.788]                   name <- changed[[kk]]
[09:32:17.788]                   NAME <- NAMES[[kk]]
[09:32:17.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.788]                     next
[09:32:17.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.788]                 }
[09:32:17.788]                 NAMES <- toupper(added)
[09:32:17.788]                 for (kk in seq_along(NAMES)) {
[09:32:17.788]                   name <- added[[kk]]
[09:32:17.788]                   NAME <- NAMES[[kk]]
[09:32:17.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.788]                     next
[09:32:17.788]                   args[[name]] <- ""
[09:32:17.788]                 }
[09:32:17.788]                 NAMES <- toupper(removed)
[09:32:17.788]                 for (kk in seq_along(NAMES)) {
[09:32:17.788]                   name <- removed[[kk]]
[09:32:17.788]                   NAME <- NAMES[[kk]]
[09:32:17.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.788]                     next
[09:32:17.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.788]                 }
[09:32:17.788]                 if (length(args) > 0) 
[09:32:17.788]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.788]             }
[09:32:17.788]             else {
[09:32:17.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.788]             }
[09:32:17.788]             {
[09:32:17.788]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.788]                   0L) {
[09:32:17.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.788]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.788]                   base::options(opts)
[09:32:17.788]                 }
[09:32:17.788]                 {
[09:32:17.788]                   {
[09:32:17.788]                     NULL
[09:32:17.788]                     RNGkind("Mersenne-Twister")
[09:32:17.788]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.788]                       inherits = FALSE)
[09:32:17.788]                   }
[09:32:17.788]                   options(future.plan = NULL)
[09:32:17.788]                   if (is.na(NA_character_)) 
[09:32:17.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.788]                     .init = FALSE)
[09:32:17.788]                 }
[09:32:17.788]             }
[09:32:17.788]         }
[09:32:17.788]     })
[09:32:17.788]     if (TRUE) {
[09:32:17.788]         base::sink(type = "output", split = FALSE)
[09:32:17.788]         if (TRUE) {
[09:32:17.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.788]         }
[09:32:17.788]         else {
[09:32:17.788]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.788]         }
[09:32:17.788]         base::close(...future.stdout)
[09:32:17.788]         ...future.stdout <- NULL
[09:32:17.788]     }
[09:32:17.788]     ...future.result$conditions <- ...future.conditions
[09:32:17.788]     ...future.result$finished <- base::Sys.time()
[09:32:17.788]     ...future.result
[09:32:17.788] }
[09:32:17.789] plan(): Setting new future strategy stack:
[09:32:17.790] List of future strategies:
[09:32:17.790] 1. sequential:
[09:32:17.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.790]    - tweaked: FALSE
[09:32:17.790]    - call: NULL
[09:32:17.790] plan(): nbrOfWorkers() = 1
[09:32:17.791] plan(): Setting new future strategy stack:
[09:32:17.791] List of future strategies:
[09:32:17.791] 1. sequential:
[09:32:17.791]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.791]    - tweaked: FALSE
[09:32:17.791]    - call: plan(strategy)
[09:32:17.791] plan(): nbrOfWorkers() = 1
[09:32:17.791] SequentialFuture started (and completed)
[09:32:17.791] - Launch lazy future ... done
[09:32:17.791] run() for ‘SequentialFuture’ ... done
[09:32:17.792] resolved() for ‘SequentialFuture’ ...
[09:32:17.792] - state: ‘finished’
[09:32:17.792] - run: TRUE
[09:32:17.792] - result: ‘FutureResult’
[09:32:17.792] resolved() for ‘SequentialFuture’ ... done
[09:32:17.792] Future #2
[09:32:17.792]  length: 1 (resolved future 2)
[09:32:17.792]  length: 0 (resolved future 3)
[09:32:17.792] resolve() on list ... DONE
[09:32:17.792] resolved() for ‘SequentialFuture’ ...
[09:32:17.793] - state: ‘finished’
[09:32:17.793] - run: TRUE
[09:32:17.793] - result: ‘FutureResult’
[09:32:17.793] resolved() for ‘SequentialFuture’ ... done
[09:32:17.793] resolved() for ‘SequentialFuture’ ...
[09:32:17.793] - state: ‘finished’
[09:32:17.793] - run: TRUE
[09:32:17.793] - result: ‘FutureResult’
[09:32:17.793] resolved() for ‘SequentialFuture’ ... done
[09:32:17.793] getGlobalsAndPackages() ...
[09:32:17.793] Searching for globals...
[09:32:17.794] 
[09:32:17.794] Searching for globals ... DONE
[09:32:17.794] - globals: [0] <none>
[09:32:17.794] getGlobalsAndPackages() ... DONE
[09:32:17.794] run() for ‘Future’ ...
[09:32:17.794] - state: ‘created’
[09:32:17.794] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.795] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.795]   - Field: ‘label’
[09:32:17.795]   - Field: ‘local’
[09:32:17.795]   - Field: ‘owner’
[09:32:17.795]   - Field: ‘envir’
[09:32:17.795]   - Field: ‘packages’
[09:32:17.795]   - Field: ‘gc’
[09:32:17.795]   - Field: ‘conditions’
[09:32:17.795]   - Field: ‘expr’
[09:32:17.795]   - Field: ‘uuid’
[09:32:17.796]   - Field: ‘seed’
[09:32:17.796]   - Field: ‘version’
[09:32:17.796]   - Field: ‘result’
[09:32:17.796]   - Field: ‘asynchronous’
[09:32:17.796]   - Field: ‘calls’
[09:32:17.796]   - Field: ‘globals’
[09:32:17.796]   - Field: ‘stdout’
[09:32:17.796]   - Field: ‘earlySignal’
[09:32:17.796]   - Field: ‘lazy’
[09:32:17.796]   - Field: ‘state’
[09:32:17.796] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.796] - Launch lazy future ...
[09:32:17.797] Packages needed by the future expression (n = 0): <none>
[09:32:17.797] Packages needed by future strategies (n = 0): <none>
[09:32:17.797] {
[09:32:17.797]     {
[09:32:17.797]         {
[09:32:17.797]             ...future.startTime <- base::Sys.time()
[09:32:17.797]             {
[09:32:17.797]                 {
[09:32:17.797]                   {
[09:32:17.797]                     base::local({
[09:32:17.797]                       has_future <- base::requireNamespace("future", 
[09:32:17.797]                         quietly = TRUE)
[09:32:17.797]                       if (has_future) {
[09:32:17.797]                         ns <- base::getNamespace("future")
[09:32:17.797]                         version <- ns[[".package"]][["version"]]
[09:32:17.797]                         if (is.null(version)) 
[09:32:17.797]                           version <- utils::packageVersion("future")
[09:32:17.797]                       }
[09:32:17.797]                       else {
[09:32:17.797]                         version <- NULL
[09:32:17.797]                       }
[09:32:17.797]                       if (!has_future || version < "1.8.0") {
[09:32:17.797]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.797]                           "", base::R.version$version.string), 
[09:32:17.797]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.797]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.797]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.797]                             "release", "version")], collapse = " "), 
[09:32:17.797]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.797]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.797]                           info)
[09:32:17.797]                         info <- base::paste(info, collapse = "; ")
[09:32:17.797]                         if (!has_future) {
[09:32:17.797]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.797]                             info)
[09:32:17.797]                         }
[09:32:17.797]                         else {
[09:32:17.797]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.797]                             info, version)
[09:32:17.797]                         }
[09:32:17.797]                         base::stop(msg)
[09:32:17.797]                       }
[09:32:17.797]                     })
[09:32:17.797]                   }
[09:32:17.797]                   ...future.strategy.old <- future::plan("list")
[09:32:17.797]                   options(future.plan = NULL)
[09:32:17.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.797]                 }
[09:32:17.797]                 ...future.workdir <- getwd()
[09:32:17.797]             }
[09:32:17.797]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.797]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.797]         }
[09:32:17.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.797]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.797]             base::names(...future.oldOptions))
[09:32:17.797]     }
[09:32:17.797]     if (FALSE) {
[09:32:17.797]     }
[09:32:17.797]     else {
[09:32:17.797]         if (TRUE) {
[09:32:17.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.797]                 open = "w")
[09:32:17.797]         }
[09:32:17.797]         else {
[09:32:17.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.797]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.797]         }
[09:32:17.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.797]             base::sink(type = "output", split = FALSE)
[09:32:17.797]             base::close(...future.stdout)
[09:32:17.797]         }, add = TRUE)
[09:32:17.797]     }
[09:32:17.797]     ...future.frame <- base::sys.nframe()
[09:32:17.797]     ...future.conditions <- base::list()
[09:32:17.797]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.797]     if (FALSE) {
[09:32:17.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.797]     }
[09:32:17.797]     ...future.result <- base::tryCatch({
[09:32:17.797]         base::withCallingHandlers({
[09:32:17.797]             ...future.value <- base::withVisible(base::local(1))
[09:32:17.797]             future::FutureResult(value = ...future.value$value, 
[09:32:17.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.797]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.797]                     ...future.globalenv.names))
[09:32:17.797]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.797]         }, condition = base::local({
[09:32:17.797]             c <- base::c
[09:32:17.797]             inherits <- base::inherits
[09:32:17.797]             invokeRestart <- base::invokeRestart
[09:32:17.797]             length <- base::length
[09:32:17.797]             list <- base::list
[09:32:17.797]             seq.int <- base::seq.int
[09:32:17.797]             signalCondition <- base::signalCondition
[09:32:17.797]             sys.calls <- base::sys.calls
[09:32:17.797]             `[[` <- base::`[[`
[09:32:17.797]             `+` <- base::`+`
[09:32:17.797]             `<<-` <- base::`<<-`
[09:32:17.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.797]                   3L)]
[09:32:17.797]             }
[09:32:17.797]             function(cond) {
[09:32:17.797]                 is_error <- inherits(cond, "error")
[09:32:17.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.797]                   NULL)
[09:32:17.797]                 if (is_error) {
[09:32:17.797]                   sessionInformation <- function() {
[09:32:17.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.797]                       search = base::search(), system = base::Sys.info())
[09:32:17.797]                   }
[09:32:17.797]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.797]                     cond$call), session = sessionInformation(), 
[09:32:17.797]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.797]                   signalCondition(cond)
[09:32:17.797]                 }
[09:32:17.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.797]                 "immediateCondition"))) {
[09:32:17.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.797]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.797]                   if (TRUE && !signal) {
[09:32:17.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.797]                     {
[09:32:17.797]                       inherits <- base::inherits
[09:32:17.797]                       invokeRestart <- base::invokeRestart
[09:32:17.797]                       is.null <- base::is.null
[09:32:17.797]                       muffled <- FALSE
[09:32:17.797]                       if (inherits(cond, "message")) {
[09:32:17.797]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.797]                         if (muffled) 
[09:32:17.797]                           invokeRestart("muffleMessage")
[09:32:17.797]                       }
[09:32:17.797]                       else if (inherits(cond, "warning")) {
[09:32:17.797]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.797]                         if (muffled) 
[09:32:17.797]                           invokeRestart("muffleWarning")
[09:32:17.797]                       }
[09:32:17.797]                       else if (inherits(cond, "condition")) {
[09:32:17.797]                         if (!is.null(pattern)) {
[09:32:17.797]                           computeRestarts <- base::computeRestarts
[09:32:17.797]                           grepl <- base::grepl
[09:32:17.797]                           restarts <- computeRestarts(cond)
[09:32:17.797]                           for (restart in restarts) {
[09:32:17.797]                             name <- restart$name
[09:32:17.797]                             if (is.null(name)) 
[09:32:17.797]                               next
[09:32:17.797]                             if (!grepl(pattern, name)) 
[09:32:17.797]                               next
[09:32:17.797]                             invokeRestart(restart)
[09:32:17.797]                             muffled <- TRUE
[09:32:17.797]                             break
[09:32:17.797]                           }
[09:32:17.797]                         }
[09:32:17.797]                       }
[09:32:17.797]                       invisible(muffled)
[09:32:17.797]                     }
[09:32:17.797]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.797]                   }
[09:32:17.797]                 }
[09:32:17.797]                 else {
[09:32:17.797]                   if (TRUE) {
[09:32:17.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.797]                     {
[09:32:17.797]                       inherits <- base::inherits
[09:32:17.797]                       invokeRestart <- base::invokeRestart
[09:32:17.797]                       is.null <- base::is.null
[09:32:17.797]                       muffled <- FALSE
[09:32:17.797]                       if (inherits(cond, "message")) {
[09:32:17.797]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.797]                         if (muffled) 
[09:32:17.797]                           invokeRestart("muffleMessage")
[09:32:17.797]                       }
[09:32:17.797]                       else if (inherits(cond, "warning")) {
[09:32:17.797]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.797]                         if (muffled) 
[09:32:17.797]                           invokeRestart("muffleWarning")
[09:32:17.797]                       }
[09:32:17.797]                       else if (inherits(cond, "condition")) {
[09:32:17.797]                         if (!is.null(pattern)) {
[09:32:17.797]                           computeRestarts <- base::computeRestarts
[09:32:17.797]                           grepl <- base::grepl
[09:32:17.797]                           restarts <- computeRestarts(cond)
[09:32:17.797]                           for (restart in restarts) {
[09:32:17.797]                             name <- restart$name
[09:32:17.797]                             if (is.null(name)) 
[09:32:17.797]                               next
[09:32:17.797]                             if (!grepl(pattern, name)) 
[09:32:17.797]                               next
[09:32:17.797]                             invokeRestart(restart)
[09:32:17.797]                             muffled <- TRUE
[09:32:17.797]                             break
[09:32:17.797]                           }
[09:32:17.797]                         }
[09:32:17.797]                       }
[09:32:17.797]                       invisible(muffled)
[09:32:17.797]                     }
[09:32:17.797]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.797]                   }
[09:32:17.797]                 }
[09:32:17.797]             }
[09:32:17.797]         }))
[09:32:17.797]     }, error = function(ex) {
[09:32:17.797]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.797]                 ...future.rng), started = ...future.startTime, 
[09:32:17.797]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.797]             version = "1.8"), class = "FutureResult")
[09:32:17.797]     }, finally = {
[09:32:17.797]         if (!identical(...future.workdir, getwd())) 
[09:32:17.797]             setwd(...future.workdir)
[09:32:17.797]         {
[09:32:17.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.797]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.797]             }
[09:32:17.797]             base::options(...future.oldOptions)
[09:32:17.797]             if (.Platform$OS.type == "windows") {
[09:32:17.797]                 old_names <- names(...future.oldEnvVars)
[09:32:17.797]                 envs <- base::Sys.getenv()
[09:32:17.797]                 names <- names(envs)
[09:32:17.797]                 common <- intersect(names, old_names)
[09:32:17.797]                 added <- setdiff(names, old_names)
[09:32:17.797]                 removed <- setdiff(old_names, names)
[09:32:17.797]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.797]                   envs[common]]
[09:32:17.797]                 NAMES <- toupper(changed)
[09:32:17.797]                 args <- list()
[09:32:17.797]                 for (kk in seq_along(NAMES)) {
[09:32:17.797]                   name <- changed[[kk]]
[09:32:17.797]                   NAME <- NAMES[[kk]]
[09:32:17.797]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.797]                     next
[09:32:17.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.797]                 }
[09:32:17.797]                 NAMES <- toupper(added)
[09:32:17.797]                 for (kk in seq_along(NAMES)) {
[09:32:17.797]                   name <- added[[kk]]
[09:32:17.797]                   NAME <- NAMES[[kk]]
[09:32:17.797]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.797]                     next
[09:32:17.797]                   args[[name]] <- ""
[09:32:17.797]                 }
[09:32:17.797]                 NAMES <- toupper(removed)
[09:32:17.797]                 for (kk in seq_along(NAMES)) {
[09:32:17.797]                   name <- removed[[kk]]
[09:32:17.797]                   NAME <- NAMES[[kk]]
[09:32:17.797]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.797]                     next
[09:32:17.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.797]                 }
[09:32:17.797]                 if (length(args) > 0) 
[09:32:17.797]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.797]             }
[09:32:17.797]             else {
[09:32:17.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.797]             }
[09:32:17.797]             {
[09:32:17.797]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.797]                   0L) {
[09:32:17.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.797]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.797]                   base::options(opts)
[09:32:17.797]                 }
[09:32:17.797]                 {
[09:32:17.797]                   {
[09:32:17.797]                     NULL
[09:32:17.797]                     RNGkind("Mersenne-Twister")
[09:32:17.797]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.797]                       inherits = FALSE)
[09:32:17.797]                   }
[09:32:17.797]                   options(future.plan = NULL)
[09:32:17.797]                   if (is.na(NA_character_)) 
[09:32:17.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.797]                     .init = FALSE)
[09:32:17.797]                 }
[09:32:17.797]             }
[09:32:17.797]         }
[09:32:17.797]     })
[09:32:17.797]     if (TRUE) {
[09:32:17.797]         base::sink(type = "output", split = FALSE)
[09:32:17.797]         if (TRUE) {
[09:32:17.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.797]         }
[09:32:17.797]         else {
[09:32:17.797]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.797]         }
[09:32:17.797]         base::close(...future.stdout)
[09:32:17.797]         ...future.stdout <- NULL
[09:32:17.797]     }
[09:32:17.797]     ...future.result$conditions <- ...future.conditions
[09:32:17.797]     ...future.result$finished <- base::Sys.time()
[09:32:17.797]     ...future.result
[09:32:17.797] }
[09:32:17.799] plan(): Setting new future strategy stack:
[09:32:17.799] List of future strategies:
[09:32:17.799] 1. sequential:
[09:32:17.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.799]    - tweaked: FALSE
[09:32:17.799]    - call: NULL
[09:32:17.799] plan(): nbrOfWorkers() = 1
[09:32:17.800] plan(): Setting new future strategy stack:
[09:32:17.800] List of future strategies:
[09:32:17.800] 1. sequential:
[09:32:17.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.800]    - tweaked: FALSE
[09:32:17.800]    - call: plan(strategy)
[09:32:17.800] plan(): nbrOfWorkers() = 1
[09:32:17.801] SequentialFuture started (and completed)
[09:32:17.801] - Launch lazy future ... done
[09:32:17.801] run() for ‘SequentialFuture’ ... done
[09:32:17.801] getGlobalsAndPackages() ...
[09:32:17.801] Searching for globals...
[09:32:17.807] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:17.807] Searching for globals ... DONE
[09:32:17.807] Resolving globals: FALSE
[09:32:17.807] 
[09:32:17.807] 
[09:32:17.807] getGlobalsAndPackages() ... DONE
[09:32:17.808] run() for ‘Future’ ...
[09:32:17.808] - state: ‘created’
[09:32:17.808] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:17.808] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:17.808] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:17.808]   - Field: ‘label’
[09:32:17.808]   - Field: ‘local’
[09:32:17.809]   - Field: ‘owner’
[09:32:17.809]   - Field: ‘envir’
[09:32:17.809]   - Field: ‘packages’
[09:32:17.809]   - Field: ‘gc’
[09:32:17.809]   - Field: ‘conditions’
[09:32:17.809]   - Field: ‘expr’
[09:32:17.809]   - Field: ‘uuid’
[09:32:17.809]   - Field: ‘seed’
[09:32:17.809]   - Field: ‘version’
[09:32:17.809]   - Field: ‘result’
[09:32:17.809]   - Field: ‘asynchronous’
[09:32:17.809]   - Field: ‘calls’
[09:32:17.810]   - Field: ‘globals’
[09:32:17.810]   - Field: ‘stdout’
[09:32:17.810]   - Field: ‘earlySignal’
[09:32:17.810]   - Field: ‘lazy’
[09:32:17.810]   - Field: ‘state’
[09:32:17.810] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:17.810] - Launch lazy future ...
[09:32:17.810] Packages needed by the future expression (n = 0): <none>
[09:32:17.810] Packages needed by future strategies (n = 0): <none>
[09:32:17.811] {
[09:32:17.811]     {
[09:32:17.811]         {
[09:32:17.811]             ...future.startTime <- base::Sys.time()
[09:32:17.811]             {
[09:32:17.811]                 {
[09:32:17.811]                   {
[09:32:17.811]                     base::local({
[09:32:17.811]                       has_future <- base::requireNamespace("future", 
[09:32:17.811]                         quietly = TRUE)
[09:32:17.811]                       if (has_future) {
[09:32:17.811]                         ns <- base::getNamespace("future")
[09:32:17.811]                         version <- ns[[".package"]][["version"]]
[09:32:17.811]                         if (is.null(version)) 
[09:32:17.811]                           version <- utils::packageVersion("future")
[09:32:17.811]                       }
[09:32:17.811]                       else {
[09:32:17.811]                         version <- NULL
[09:32:17.811]                       }
[09:32:17.811]                       if (!has_future || version < "1.8.0") {
[09:32:17.811]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:17.811]                           "", base::R.version$version.string), 
[09:32:17.811]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:17.811]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:17.811]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:17.811]                             "release", "version")], collapse = " "), 
[09:32:17.811]                           hostname = base::Sys.info()[["nodename"]])
[09:32:17.811]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:17.811]                           info)
[09:32:17.811]                         info <- base::paste(info, collapse = "; ")
[09:32:17.811]                         if (!has_future) {
[09:32:17.811]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:17.811]                             info)
[09:32:17.811]                         }
[09:32:17.811]                         else {
[09:32:17.811]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:17.811]                             info, version)
[09:32:17.811]                         }
[09:32:17.811]                         base::stop(msg)
[09:32:17.811]                       }
[09:32:17.811]                     })
[09:32:17.811]                   }
[09:32:17.811]                   ...future.strategy.old <- future::plan("list")
[09:32:17.811]                   options(future.plan = NULL)
[09:32:17.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:17.811]                 }
[09:32:17.811]                 ...future.workdir <- getwd()
[09:32:17.811]             }
[09:32:17.811]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:17.811]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:17.811]         }
[09:32:17.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:17.811]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:17.811]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:17.811]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:17.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:17.811]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:17.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:17.811]             base::names(...future.oldOptions))
[09:32:17.811]     }
[09:32:17.811]     if (FALSE) {
[09:32:17.811]     }
[09:32:17.811]     else {
[09:32:17.811]         if (TRUE) {
[09:32:17.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:17.811]                 open = "w")
[09:32:17.811]         }
[09:32:17.811]         else {
[09:32:17.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:17.811]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:17.811]         }
[09:32:17.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:17.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:17.811]             base::sink(type = "output", split = FALSE)
[09:32:17.811]             base::close(...future.stdout)
[09:32:17.811]         }, add = TRUE)
[09:32:17.811]     }
[09:32:17.811]     ...future.frame <- base::sys.nframe()
[09:32:17.811]     ...future.conditions <- base::list()
[09:32:17.811]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:17.811]     if (FALSE) {
[09:32:17.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:17.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:17.811]     }
[09:32:17.811]     ...future.result <- base::tryCatch({
[09:32:17.811]         base::withCallingHandlers({
[09:32:17.811]             ...future.value <- base::withVisible(base::local({
[09:32:17.811]                 Sys.sleep(0.5)
[09:32:17.811]                 2
[09:32:17.811]             }))
[09:32:17.811]             future::FutureResult(value = ...future.value$value, 
[09:32:17.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.811]                   ...future.rng), globalenv = if (FALSE) 
[09:32:17.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:17.811]                     ...future.globalenv.names))
[09:32:17.811]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:17.811]         }, condition = base::local({
[09:32:17.811]             c <- base::c
[09:32:17.811]             inherits <- base::inherits
[09:32:17.811]             invokeRestart <- base::invokeRestart
[09:32:17.811]             length <- base::length
[09:32:17.811]             list <- base::list
[09:32:17.811]             seq.int <- base::seq.int
[09:32:17.811]             signalCondition <- base::signalCondition
[09:32:17.811]             sys.calls <- base::sys.calls
[09:32:17.811]             `[[` <- base::`[[`
[09:32:17.811]             `+` <- base::`+`
[09:32:17.811]             `<<-` <- base::`<<-`
[09:32:17.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:17.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:17.811]                   3L)]
[09:32:17.811]             }
[09:32:17.811]             function(cond) {
[09:32:17.811]                 is_error <- inherits(cond, "error")
[09:32:17.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:17.811]                   NULL)
[09:32:17.811]                 if (is_error) {
[09:32:17.811]                   sessionInformation <- function() {
[09:32:17.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:17.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:17.811]                       search = base::search(), system = base::Sys.info())
[09:32:17.811]                   }
[09:32:17.811]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:17.811]                     cond$call), session = sessionInformation(), 
[09:32:17.811]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:17.811]                   signalCondition(cond)
[09:32:17.811]                 }
[09:32:17.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:17.811]                 "immediateCondition"))) {
[09:32:17.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:17.811]                   ...future.conditions[[length(...future.conditions) + 
[09:32:17.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:17.811]                   if (TRUE && !signal) {
[09:32:17.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.811]                     {
[09:32:17.811]                       inherits <- base::inherits
[09:32:17.811]                       invokeRestart <- base::invokeRestart
[09:32:17.811]                       is.null <- base::is.null
[09:32:17.811]                       muffled <- FALSE
[09:32:17.811]                       if (inherits(cond, "message")) {
[09:32:17.811]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.811]                         if (muffled) 
[09:32:17.811]                           invokeRestart("muffleMessage")
[09:32:17.811]                       }
[09:32:17.811]                       else if (inherits(cond, "warning")) {
[09:32:17.811]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.811]                         if (muffled) 
[09:32:17.811]                           invokeRestart("muffleWarning")
[09:32:17.811]                       }
[09:32:17.811]                       else if (inherits(cond, "condition")) {
[09:32:17.811]                         if (!is.null(pattern)) {
[09:32:17.811]                           computeRestarts <- base::computeRestarts
[09:32:17.811]                           grepl <- base::grepl
[09:32:17.811]                           restarts <- computeRestarts(cond)
[09:32:17.811]                           for (restart in restarts) {
[09:32:17.811]                             name <- restart$name
[09:32:17.811]                             if (is.null(name)) 
[09:32:17.811]                               next
[09:32:17.811]                             if (!grepl(pattern, name)) 
[09:32:17.811]                               next
[09:32:17.811]                             invokeRestart(restart)
[09:32:17.811]                             muffled <- TRUE
[09:32:17.811]                             break
[09:32:17.811]                           }
[09:32:17.811]                         }
[09:32:17.811]                       }
[09:32:17.811]                       invisible(muffled)
[09:32:17.811]                     }
[09:32:17.811]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.811]                   }
[09:32:17.811]                 }
[09:32:17.811]                 else {
[09:32:17.811]                   if (TRUE) {
[09:32:17.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:17.811]                     {
[09:32:17.811]                       inherits <- base::inherits
[09:32:17.811]                       invokeRestart <- base::invokeRestart
[09:32:17.811]                       is.null <- base::is.null
[09:32:17.811]                       muffled <- FALSE
[09:32:17.811]                       if (inherits(cond, "message")) {
[09:32:17.811]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:17.811]                         if (muffled) 
[09:32:17.811]                           invokeRestart("muffleMessage")
[09:32:17.811]                       }
[09:32:17.811]                       else if (inherits(cond, "warning")) {
[09:32:17.811]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:17.811]                         if (muffled) 
[09:32:17.811]                           invokeRestart("muffleWarning")
[09:32:17.811]                       }
[09:32:17.811]                       else if (inherits(cond, "condition")) {
[09:32:17.811]                         if (!is.null(pattern)) {
[09:32:17.811]                           computeRestarts <- base::computeRestarts
[09:32:17.811]                           grepl <- base::grepl
[09:32:17.811]                           restarts <- computeRestarts(cond)
[09:32:17.811]                           for (restart in restarts) {
[09:32:17.811]                             name <- restart$name
[09:32:17.811]                             if (is.null(name)) 
[09:32:17.811]                               next
[09:32:17.811]                             if (!grepl(pattern, name)) 
[09:32:17.811]                               next
[09:32:17.811]                             invokeRestart(restart)
[09:32:17.811]                             muffled <- TRUE
[09:32:17.811]                             break
[09:32:17.811]                           }
[09:32:17.811]                         }
[09:32:17.811]                       }
[09:32:17.811]                       invisible(muffled)
[09:32:17.811]                     }
[09:32:17.811]                     muffleCondition(cond, pattern = "^muffle")
[09:32:17.811]                   }
[09:32:17.811]                 }
[09:32:17.811]             }
[09:32:17.811]         }))
[09:32:17.811]     }, error = function(ex) {
[09:32:17.811]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:17.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:17.811]                 ...future.rng), started = ...future.startTime, 
[09:32:17.811]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:17.811]             version = "1.8"), class = "FutureResult")
[09:32:17.811]     }, finally = {
[09:32:17.811]         if (!identical(...future.workdir, getwd())) 
[09:32:17.811]             setwd(...future.workdir)
[09:32:17.811]         {
[09:32:17.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:17.811]                 ...future.oldOptions$nwarnings <- NULL
[09:32:17.811]             }
[09:32:17.811]             base::options(...future.oldOptions)
[09:32:17.811]             if (.Platform$OS.type == "windows") {
[09:32:17.811]                 old_names <- names(...future.oldEnvVars)
[09:32:17.811]                 envs <- base::Sys.getenv()
[09:32:17.811]                 names <- names(envs)
[09:32:17.811]                 common <- intersect(names, old_names)
[09:32:17.811]                 added <- setdiff(names, old_names)
[09:32:17.811]                 removed <- setdiff(old_names, names)
[09:32:17.811]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:17.811]                   envs[common]]
[09:32:17.811]                 NAMES <- toupper(changed)
[09:32:17.811]                 args <- list()
[09:32:17.811]                 for (kk in seq_along(NAMES)) {
[09:32:17.811]                   name <- changed[[kk]]
[09:32:17.811]                   NAME <- NAMES[[kk]]
[09:32:17.811]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.811]                     next
[09:32:17.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.811]                 }
[09:32:17.811]                 NAMES <- toupper(added)
[09:32:17.811]                 for (kk in seq_along(NAMES)) {
[09:32:17.811]                   name <- added[[kk]]
[09:32:17.811]                   NAME <- NAMES[[kk]]
[09:32:17.811]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.811]                     next
[09:32:17.811]                   args[[name]] <- ""
[09:32:17.811]                 }
[09:32:17.811]                 NAMES <- toupper(removed)
[09:32:17.811]                 for (kk in seq_along(NAMES)) {
[09:32:17.811]                   name <- removed[[kk]]
[09:32:17.811]                   NAME <- NAMES[[kk]]
[09:32:17.811]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:17.811]                     next
[09:32:17.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:17.811]                 }
[09:32:17.811]                 if (length(args) > 0) 
[09:32:17.811]                   base::do.call(base::Sys.setenv, args = args)
[09:32:17.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:17.811]             }
[09:32:17.811]             else {
[09:32:17.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:17.811]             }
[09:32:17.811]             {
[09:32:17.811]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:17.811]                   0L) {
[09:32:17.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:17.811]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:17.811]                   base::options(opts)
[09:32:17.811]                 }
[09:32:17.811]                 {
[09:32:17.811]                   {
[09:32:17.811]                     NULL
[09:32:17.811]                     RNGkind("Mersenne-Twister")
[09:32:17.811]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:17.811]                       inherits = FALSE)
[09:32:17.811]                   }
[09:32:17.811]                   options(future.plan = NULL)
[09:32:17.811]                   if (is.na(NA_character_)) 
[09:32:17.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:17.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:17.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:17.811]                     .init = FALSE)
[09:32:17.811]                 }
[09:32:17.811]             }
[09:32:17.811]         }
[09:32:17.811]     })
[09:32:17.811]     if (TRUE) {
[09:32:17.811]         base::sink(type = "output", split = FALSE)
[09:32:17.811]         if (TRUE) {
[09:32:17.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:17.811]         }
[09:32:17.811]         else {
[09:32:17.811]             ...future.result["stdout"] <- base::list(NULL)
[09:32:17.811]         }
[09:32:17.811]         base::close(...future.stdout)
[09:32:17.811]         ...future.stdout <- NULL
[09:32:17.811]     }
[09:32:17.811]     ...future.result$conditions <- ...future.conditions
[09:32:17.811]     ...future.result$finished <- base::Sys.time()
[09:32:17.811]     ...future.result
[09:32:17.811] }
[09:32:17.812] plan(): Setting new future strategy stack:
[09:32:17.812] List of future strategies:
[09:32:17.812] 1. sequential:
[09:32:17.812]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:17.812]    - tweaked: FALSE
[09:32:17.812]    - call: NULL
[09:32:17.813] plan(): nbrOfWorkers() = 1
[09:32:18.314] plan(): Setting new future strategy stack:
[09:32:18.315] List of future strategies:
[09:32:18.315] 1. sequential:
[09:32:18.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.315]    - tweaked: FALSE
[09:32:18.315]    - call: plan(strategy)
[09:32:18.315] plan(): nbrOfWorkers() = 1
[09:32:18.315] SequentialFuture started (and completed)
[09:32:18.316] - Launch lazy future ... done
[09:32:18.316] run() for ‘SequentialFuture’ ... done
[09:32:18.316] resolve() on list ...
[09:32:18.316]  recursive: 0
[09:32:18.316]  length: 1
[09:32:18.316] 
[09:32:18.317] resolved() for ‘SequentialFuture’ ...
[09:32:18.317] - state: ‘finished’
[09:32:18.317] - run: TRUE
[09:32:18.317] - result: ‘FutureResult’
[09:32:18.317] resolved() for ‘SequentialFuture’ ... done
[09:32:18.317] Future #1
[09:32:18.317]  length: 0 (resolved future 1)
[09:32:18.317] resolve() on list ... DONE
[09:32:18.317] resolved() for ‘SequentialFuture’ ...
[09:32:18.317] - state: ‘finished’
[09:32:18.318] - run: TRUE
[09:32:18.318] - result: ‘FutureResult’
[09:32:18.318] resolved() for ‘SequentialFuture’ ... done
[09:32:18.318] resolve() on list ...
[09:32:18.318]  recursive: 0
[09:32:18.318]  length: 1
[09:32:18.318] 
[09:32:18.318] resolved() for ‘SequentialFuture’ ...
[09:32:18.318] - state: ‘finished’
[09:32:18.318] - run: TRUE
[09:32:18.319] - result: ‘FutureResult’
[09:32:18.319] resolved() for ‘SequentialFuture’ ... done
[09:32:18.319] Future #1
[09:32:18.319]  length: 0 (resolved future 1)
[09:32:18.319] resolve() on list ... DONE
[09:32:18.319] resolved() for ‘SequentialFuture’ ...
[09:32:18.319] - state: ‘finished’
[09:32:18.319] - run: TRUE
[09:32:18.319] - result: ‘FutureResult’
[09:32:18.319] resolved() for ‘SequentialFuture’ ... done
[09:32:18.320] resolve() on list ...
[09:32:18.320]  recursive: 0
[09:32:18.320]  length: 1
[09:32:18.320] 
[09:32:18.320]  length: 0 (resolved future 1)
[09:32:18.320] resolve() on list ... DONE
[09:32:18.320] resolve() on list ...
[09:32:18.320]  recursive: 0
[09:32:18.320]  length: 4
[09:32:18.320] 
[09:32:18.320] resolved() for ‘SequentialFuture’ ...
[09:32:18.321] - state: ‘finished’
[09:32:18.321] - run: TRUE
[09:32:18.321] - result: ‘FutureResult’
[09:32:18.321] resolved() for ‘SequentialFuture’ ... done
[09:32:18.321] Future #1
[09:32:18.321]  length: 3 (resolved future 1)
[09:32:18.321] resolved() for ‘SequentialFuture’ ...
[09:32:18.321] - state: ‘finished’
[09:32:18.321] - run: TRUE
[09:32:18.321] - result: ‘FutureResult’
[09:32:18.321] resolved() for ‘SequentialFuture’ ... done
[09:32:18.322] Future #2
[09:32:18.322]  length: 2 (resolved future 2)
[09:32:18.322]  length: 1 (resolved future 3)
[09:32:18.322]  length: 0 (resolved future 4)
[09:32:18.322] resolve() on list ... DONE
[09:32:18.322] resolve() on list ...
[09:32:18.322]  recursive: 0
[09:32:18.322]  length: 4
[09:32:18.322] 
[09:32:18.322] resolved() for ‘SequentialFuture’ ...
[09:32:18.323] - state: ‘finished’
[09:32:18.323] - run: TRUE
[09:32:18.323] - result: ‘FutureResult’
[09:32:18.323] resolved() for ‘SequentialFuture’ ... done
[09:32:18.323] Future #1
[09:32:18.323]  length: 3 (resolved future 1)
[09:32:18.323] resolved() for ‘SequentialFuture’ ...
[09:32:18.323] - state: ‘finished’
[09:32:18.323] - run: TRUE
[09:32:18.323] - result: ‘FutureResult’
[09:32:18.323] resolved() for ‘SequentialFuture’ ... done
[09:32:18.324] Future #2
[09:32:18.324]  length: 2 (resolved future 2)
[09:32:18.324]  length: 1 (resolved future 3)
[09:32:18.324]  length: 0 (resolved future 4)
[09:32:18.324] resolve() on list ... DONE
[09:32:18.324] resolve() on list ...
[09:32:18.324]  recursive: 0
[09:32:18.324]  length: 1
[09:32:18.324] 
[09:32:18.325]  length: 0 (resolved future 1)
[09:32:18.325] resolve() on list ... DONE
[09:32:18.325] getGlobalsAndPackages() ...
[09:32:18.325] Searching for globals...
[09:32:18.326] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.326] Searching for globals ... DONE
[09:32:18.326] Resolving globals: FALSE
[09:32:18.327] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.327] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.327] - globals: [1] ‘kk’
[09:32:18.327] 
[09:32:18.328] getGlobalsAndPackages() ... DONE
[09:32:18.328] run() for ‘Future’ ...
[09:32:18.328] - state: ‘created’
[09:32:18.328] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.328]   - Field: ‘label’
[09:32:18.329]   - Field: ‘local’
[09:32:18.329]   - Field: ‘owner’
[09:32:18.329]   - Field: ‘envir’
[09:32:18.329]   - Field: ‘packages’
[09:32:18.329]   - Field: ‘gc’
[09:32:18.329]   - Field: ‘conditions’
[09:32:18.329]   - Field: ‘expr’
[09:32:18.329]   - Field: ‘uuid’
[09:32:18.329]   - Field: ‘seed’
[09:32:18.329]   - Field: ‘version’
[09:32:18.329]   - Field: ‘result’
[09:32:18.330]   - Field: ‘asynchronous’
[09:32:18.330]   - Field: ‘calls’
[09:32:18.330]   - Field: ‘globals’
[09:32:18.330]   - Field: ‘stdout’
[09:32:18.330]   - Field: ‘earlySignal’
[09:32:18.330]   - Field: ‘lazy’
[09:32:18.330]   - Field: ‘state’
[09:32:18.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.330] - Launch lazy future ...
[09:32:18.330] Packages needed by the future expression (n = 0): <none>
[09:32:18.331] Packages needed by future strategies (n = 0): <none>
[09:32:18.331] {
[09:32:18.331]     {
[09:32:18.331]         {
[09:32:18.331]             ...future.startTime <- base::Sys.time()
[09:32:18.331]             {
[09:32:18.331]                 {
[09:32:18.331]                   {
[09:32:18.331]                     base::local({
[09:32:18.331]                       has_future <- base::requireNamespace("future", 
[09:32:18.331]                         quietly = TRUE)
[09:32:18.331]                       if (has_future) {
[09:32:18.331]                         ns <- base::getNamespace("future")
[09:32:18.331]                         version <- ns[[".package"]][["version"]]
[09:32:18.331]                         if (is.null(version)) 
[09:32:18.331]                           version <- utils::packageVersion("future")
[09:32:18.331]                       }
[09:32:18.331]                       else {
[09:32:18.331]                         version <- NULL
[09:32:18.331]                       }
[09:32:18.331]                       if (!has_future || version < "1.8.0") {
[09:32:18.331]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.331]                           "", base::R.version$version.string), 
[09:32:18.331]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.331]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.331]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.331]                             "release", "version")], collapse = " "), 
[09:32:18.331]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.331]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.331]                           info)
[09:32:18.331]                         info <- base::paste(info, collapse = "; ")
[09:32:18.331]                         if (!has_future) {
[09:32:18.331]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.331]                             info)
[09:32:18.331]                         }
[09:32:18.331]                         else {
[09:32:18.331]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.331]                             info, version)
[09:32:18.331]                         }
[09:32:18.331]                         base::stop(msg)
[09:32:18.331]                       }
[09:32:18.331]                     })
[09:32:18.331]                   }
[09:32:18.331]                   ...future.strategy.old <- future::plan("list")
[09:32:18.331]                   options(future.plan = NULL)
[09:32:18.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.331]                 }
[09:32:18.331]                 ...future.workdir <- getwd()
[09:32:18.331]             }
[09:32:18.331]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.331]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.331]         }
[09:32:18.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.331]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.331]             base::names(...future.oldOptions))
[09:32:18.331]     }
[09:32:18.331]     if (FALSE) {
[09:32:18.331]     }
[09:32:18.331]     else {
[09:32:18.331]         if (TRUE) {
[09:32:18.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.331]                 open = "w")
[09:32:18.331]         }
[09:32:18.331]         else {
[09:32:18.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.331]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.331]         }
[09:32:18.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.331]             base::sink(type = "output", split = FALSE)
[09:32:18.331]             base::close(...future.stdout)
[09:32:18.331]         }, add = TRUE)
[09:32:18.331]     }
[09:32:18.331]     ...future.frame <- base::sys.nframe()
[09:32:18.331]     ...future.conditions <- base::list()
[09:32:18.331]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.331]     if (FALSE) {
[09:32:18.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.331]     }
[09:32:18.331]     ...future.result <- base::tryCatch({
[09:32:18.331]         base::withCallingHandlers({
[09:32:18.331]             ...future.value <- base::withVisible(base::local({
[09:32:18.331]                 Sys.sleep(0.1)
[09:32:18.331]                 kk
[09:32:18.331]             }))
[09:32:18.331]             future::FutureResult(value = ...future.value$value, 
[09:32:18.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.331]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.331]                     ...future.globalenv.names))
[09:32:18.331]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.331]         }, condition = base::local({
[09:32:18.331]             c <- base::c
[09:32:18.331]             inherits <- base::inherits
[09:32:18.331]             invokeRestart <- base::invokeRestart
[09:32:18.331]             length <- base::length
[09:32:18.331]             list <- base::list
[09:32:18.331]             seq.int <- base::seq.int
[09:32:18.331]             signalCondition <- base::signalCondition
[09:32:18.331]             sys.calls <- base::sys.calls
[09:32:18.331]             `[[` <- base::`[[`
[09:32:18.331]             `+` <- base::`+`
[09:32:18.331]             `<<-` <- base::`<<-`
[09:32:18.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.331]                   3L)]
[09:32:18.331]             }
[09:32:18.331]             function(cond) {
[09:32:18.331]                 is_error <- inherits(cond, "error")
[09:32:18.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.331]                   NULL)
[09:32:18.331]                 if (is_error) {
[09:32:18.331]                   sessionInformation <- function() {
[09:32:18.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.331]                       search = base::search(), system = base::Sys.info())
[09:32:18.331]                   }
[09:32:18.331]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.331]                     cond$call), session = sessionInformation(), 
[09:32:18.331]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.331]                   signalCondition(cond)
[09:32:18.331]                 }
[09:32:18.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.331]                 "immediateCondition"))) {
[09:32:18.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.331]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.331]                   if (TRUE && !signal) {
[09:32:18.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.331]                     {
[09:32:18.331]                       inherits <- base::inherits
[09:32:18.331]                       invokeRestart <- base::invokeRestart
[09:32:18.331]                       is.null <- base::is.null
[09:32:18.331]                       muffled <- FALSE
[09:32:18.331]                       if (inherits(cond, "message")) {
[09:32:18.331]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.331]                         if (muffled) 
[09:32:18.331]                           invokeRestart("muffleMessage")
[09:32:18.331]                       }
[09:32:18.331]                       else if (inherits(cond, "warning")) {
[09:32:18.331]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.331]                         if (muffled) 
[09:32:18.331]                           invokeRestart("muffleWarning")
[09:32:18.331]                       }
[09:32:18.331]                       else if (inherits(cond, "condition")) {
[09:32:18.331]                         if (!is.null(pattern)) {
[09:32:18.331]                           computeRestarts <- base::computeRestarts
[09:32:18.331]                           grepl <- base::grepl
[09:32:18.331]                           restarts <- computeRestarts(cond)
[09:32:18.331]                           for (restart in restarts) {
[09:32:18.331]                             name <- restart$name
[09:32:18.331]                             if (is.null(name)) 
[09:32:18.331]                               next
[09:32:18.331]                             if (!grepl(pattern, name)) 
[09:32:18.331]                               next
[09:32:18.331]                             invokeRestart(restart)
[09:32:18.331]                             muffled <- TRUE
[09:32:18.331]                             break
[09:32:18.331]                           }
[09:32:18.331]                         }
[09:32:18.331]                       }
[09:32:18.331]                       invisible(muffled)
[09:32:18.331]                     }
[09:32:18.331]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.331]                   }
[09:32:18.331]                 }
[09:32:18.331]                 else {
[09:32:18.331]                   if (TRUE) {
[09:32:18.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.331]                     {
[09:32:18.331]                       inherits <- base::inherits
[09:32:18.331]                       invokeRestart <- base::invokeRestart
[09:32:18.331]                       is.null <- base::is.null
[09:32:18.331]                       muffled <- FALSE
[09:32:18.331]                       if (inherits(cond, "message")) {
[09:32:18.331]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.331]                         if (muffled) 
[09:32:18.331]                           invokeRestart("muffleMessage")
[09:32:18.331]                       }
[09:32:18.331]                       else if (inherits(cond, "warning")) {
[09:32:18.331]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.331]                         if (muffled) 
[09:32:18.331]                           invokeRestart("muffleWarning")
[09:32:18.331]                       }
[09:32:18.331]                       else if (inherits(cond, "condition")) {
[09:32:18.331]                         if (!is.null(pattern)) {
[09:32:18.331]                           computeRestarts <- base::computeRestarts
[09:32:18.331]                           grepl <- base::grepl
[09:32:18.331]                           restarts <- computeRestarts(cond)
[09:32:18.331]                           for (restart in restarts) {
[09:32:18.331]                             name <- restart$name
[09:32:18.331]                             if (is.null(name)) 
[09:32:18.331]                               next
[09:32:18.331]                             if (!grepl(pattern, name)) 
[09:32:18.331]                               next
[09:32:18.331]                             invokeRestart(restart)
[09:32:18.331]                             muffled <- TRUE
[09:32:18.331]                             break
[09:32:18.331]                           }
[09:32:18.331]                         }
[09:32:18.331]                       }
[09:32:18.331]                       invisible(muffled)
[09:32:18.331]                     }
[09:32:18.331]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.331]                   }
[09:32:18.331]                 }
[09:32:18.331]             }
[09:32:18.331]         }))
[09:32:18.331]     }, error = function(ex) {
[09:32:18.331]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.331]                 ...future.rng), started = ...future.startTime, 
[09:32:18.331]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.331]             version = "1.8"), class = "FutureResult")
[09:32:18.331]     }, finally = {
[09:32:18.331]         if (!identical(...future.workdir, getwd())) 
[09:32:18.331]             setwd(...future.workdir)
[09:32:18.331]         {
[09:32:18.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.331]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.331]             }
[09:32:18.331]             base::options(...future.oldOptions)
[09:32:18.331]             if (.Platform$OS.type == "windows") {
[09:32:18.331]                 old_names <- names(...future.oldEnvVars)
[09:32:18.331]                 envs <- base::Sys.getenv()
[09:32:18.331]                 names <- names(envs)
[09:32:18.331]                 common <- intersect(names, old_names)
[09:32:18.331]                 added <- setdiff(names, old_names)
[09:32:18.331]                 removed <- setdiff(old_names, names)
[09:32:18.331]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.331]                   envs[common]]
[09:32:18.331]                 NAMES <- toupper(changed)
[09:32:18.331]                 args <- list()
[09:32:18.331]                 for (kk in seq_along(NAMES)) {
[09:32:18.331]                   name <- changed[[kk]]
[09:32:18.331]                   NAME <- NAMES[[kk]]
[09:32:18.331]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.331]                     next
[09:32:18.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.331]                 }
[09:32:18.331]                 NAMES <- toupper(added)
[09:32:18.331]                 for (kk in seq_along(NAMES)) {
[09:32:18.331]                   name <- added[[kk]]
[09:32:18.331]                   NAME <- NAMES[[kk]]
[09:32:18.331]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.331]                     next
[09:32:18.331]                   args[[name]] <- ""
[09:32:18.331]                 }
[09:32:18.331]                 NAMES <- toupper(removed)
[09:32:18.331]                 for (kk in seq_along(NAMES)) {
[09:32:18.331]                   name <- removed[[kk]]
[09:32:18.331]                   NAME <- NAMES[[kk]]
[09:32:18.331]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.331]                     next
[09:32:18.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.331]                 }
[09:32:18.331]                 if (length(args) > 0) 
[09:32:18.331]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.331]             }
[09:32:18.331]             else {
[09:32:18.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.331]             }
[09:32:18.331]             {
[09:32:18.331]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.331]                   0L) {
[09:32:18.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.331]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.331]                   base::options(opts)
[09:32:18.331]                 }
[09:32:18.331]                 {
[09:32:18.331]                   {
[09:32:18.331]                     NULL
[09:32:18.331]                     RNGkind("Mersenne-Twister")
[09:32:18.331]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.331]                       inherits = FALSE)
[09:32:18.331]                   }
[09:32:18.331]                   options(future.plan = NULL)
[09:32:18.331]                   if (is.na(NA_character_)) 
[09:32:18.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.331]                     .init = FALSE)
[09:32:18.331]                 }
[09:32:18.331]             }
[09:32:18.331]         }
[09:32:18.331]     })
[09:32:18.331]     if (TRUE) {
[09:32:18.331]         base::sink(type = "output", split = FALSE)
[09:32:18.331]         if (TRUE) {
[09:32:18.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.331]         }
[09:32:18.331]         else {
[09:32:18.331]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.331]         }
[09:32:18.331]         base::close(...future.stdout)
[09:32:18.331]         ...future.stdout <- NULL
[09:32:18.331]     }
[09:32:18.331]     ...future.result$conditions <- ...future.conditions
[09:32:18.331]     ...future.result$finished <- base::Sys.time()
[09:32:18.331]     ...future.result
[09:32:18.331] }
[09:32:18.333] assign_globals() ...
[09:32:18.333] List of 1
[09:32:18.333]  $ kk: int 1
[09:32:18.333]  - attr(*, "where")=List of 1
[09:32:18.333]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.333]  - attr(*, "resolved")= logi FALSE
[09:32:18.333]  - attr(*, "total_size")= num 56
[09:32:18.333]  - attr(*, "already-done")= logi TRUE
[09:32:18.339] - copied ‘kk’ to environment
[09:32:18.339] assign_globals() ... done
[09:32:18.339] plan(): Setting new future strategy stack:
[09:32:18.340] List of future strategies:
[09:32:18.340] 1. sequential:
[09:32:18.340]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.340]    - tweaked: FALSE
[09:32:18.340]    - call: NULL
[09:32:18.340] plan(): nbrOfWorkers() = 1
[09:32:18.441] plan(): Setting new future strategy stack:
[09:32:18.441] List of future strategies:
[09:32:18.441] 1. sequential:
[09:32:18.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.441]    - tweaked: FALSE
[09:32:18.441]    - call: plan(strategy)
[09:32:18.442] plan(): nbrOfWorkers() = 1
[09:32:18.442] SequentialFuture started (and completed)
[09:32:18.442] - Launch lazy future ... done
[09:32:18.442] run() for ‘SequentialFuture’ ... done
[09:32:18.442] getGlobalsAndPackages() ...
[09:32:18.442] Searching for globals...
[09:32:18.443] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.443] Searching for globals ... DONE
[09:32:18.443] Resolving globals: FALSE
[09:32:18.444] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.444] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.444] - globals: [1] ‘kk’
[09:32:18.444] 
[09:32:18.444] getGlobalsAndPackages() ... DONE
[09:32:18.445] run() for ‘Future’ ...
[09:32:18.445] - state: ‘created’
[09:32:18.445] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.445] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.445]   - Field: ‘label’
[09:32:18.445]   - Field: ‘local’
[09:32:18.445]   - Field: ‘owner’
[09:32:18.446]   - Field: ‘envir’
[09:32:18.446]   - Field: ‘packages’
[09:32:18.446]   - Field: ‘gc’
[09:32:18.446]   - Field: ‘conditions’
[09:32:18.446]   - Field: ‘expr’
[09:32:18.446]   - Field: ‘uuid’
[09:32:18.446]   - Field: ‘seed’
[09:32:18.446]   - Field: ‘version’
[09:32:18.446]   - Field: ‘result’
[09:32:18.446]   - Field: ‘asynchronous’
[09:32:18.446]   - Field: ‘calls’
[09:32:18.447]   - Field: ‘globals’
[09:32:18.447]   - Field: ‘stdout’
[09:32:18.447]   - Field: ‘earlySignal’
[09:32:18.447]   - Field: ‘lazy’
[09:32:18.447]   - Field: ‘state’
[09:32:18.447] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.447] - Launch lazy future ...
[09:32:18.447] Packages needed by the future expression (n = 0): <none>
[09:32:18.447] Packages needed by future strategies (n = 0): <none>
[09:32:18.448] {
[09:32:18.448]     {
[09:32:18.448]         {
[09:32:18.448]             ...future.startTime <- base::Sys.time()
[09:32:18.448]             {
[09:32:18.448]                 {
[09:32:18.448]                   {
[09:32:18.448]                     base::local({
[09:32:18.448]                       has_future <- base::requireNamespace("future", 
[09:32:18.448]                         quietly = TRUE)
[09:32:18.448]                       if (has_future) {
[09:32:18.448]                         ns <- base::getNamespace("future")
[09:32:18.448]                         version <- ns[[".package"]][["version"]]
[09:32:18.448]                         if (is.null(version)) 
[09:32:18.448]                           version <- utils::packageVersion("future")
[09:32:18.448]                       }
[09:32:18.448]                       else {
[09:32:18.448]                         version <- NULL
[09:32:18.448]                       }
[09:32:18.448]                       if (!has_future || version < "1.8.0") {
[09:32:18.448]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.448]                           "", base::R.version$version.string), 
[09:32:18.448]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.448]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.448]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.448]                             "release", "version")], collapse = " "), 
[09:32:18.448]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.448]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.448]                           info)
[09:32:18.448]                         info <- base::paste(info, collapse = "; ")
[09:32:18.448]                         if (!has_future) {
[09:32:18.448]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.448]                             info)
[09:32:18.448]                         }
[09:32:18.448]                         else {
[09:32:18.448]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.448]                             info, version)
[09:32:18.448]                         }
[09:32:18.448]                         base::stop(msg)
[09:32:18.448]                       }
[09:32:18.448]                     })
[09:32:18.448]                   }
[09:32:18.448]                   ...future.strategy.old <- future::plan("list")
[09:32:18.448]                   options(future.plan = NULL)
[09:32:18.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.448]                 }
[09:32:18.448]                 ...future.workdir <- getwd()
[09:32:18.448]             }
[09:32:18.448]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.448]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.448]         }
[09:32:18.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.448]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.448]             base::names(...future.oldOptions))
[09:32:18.448]     }
[09:32:18.448]     if (FALSE) {
[09:32:18.448]     }
[09:32:18.448]     else {
[09:32:18.448]         if (TRUE) {
[09:32:18.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.448]                 open = "w")
[09:32:18.448]         }
[09:32:18.448]         else {
[09:32:18.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.448]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.448]         }
[09:32:18.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.448]             base::sink(type = "output", split = FALSE)
[09:32:18.448]             base::close(...future.stdout)
[09:32:18.448]         }, add = TRUE)
[09:32:18.448]     }
[09:32:18.448]     ...future.frame <- base::sys.nframe()
[09:32:18.448]     ...future.conditions <- base::list()
[09:32:18.448]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.448]     if (FALSE) {
[09:32:18.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.448]     }
[09:32:18.448]     ...future.result <- base::tryCatch({
[09:32:18.448]         base::withCallingHandlers({
[09:32:18.448]             ...future.value <- base::withVisible(base::local({
[09:32:18.448]                 Sys.sleep(0.1)
[09:32:18.448]                 kk
[09:32:18.448]             }))
[09:32:18.448]             future::FutureResult(value = ...future.value$value, 
[09:32:18.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.448]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.448]                     ...future.globalenv.names))
[09:32:18.448]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.448]         }, condition = base::local({
[09:32:18.448]             c <- base::c
[09:32:18.448]             inherits <- base::inherits
[09:32:18.448]             invokeRestart <- base::invokeRestart
[09:32:18.448]             length <- base::length
[09:32:18.448]             list <- base::list
[09:32:18.448]             seq.int <- base::seq.int
[09:32:18.448]             signalCondition <- base::signalCondition
[09:32:18.448]             sys.calls <- base::sys.calls
[09:32:18.448]             `[[` <- base::`[[`
[09:32:18.448]             `+` <- base::`+`
[09:32:18.448]             `<<-` <- base::`<<-`
[09:32:18.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.448]                   3L)]
[09:32:18.448]             }
[09:32:18.448]             function(cond) {
[09:32:18.448]                 is_error <- inherits(cond, "error")
[09:32:18.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.448]                   NULL)
[09:32:18.448]                 if (is_error) {
[09:32:18.448]                   sessionInformation <- function() {
[09:32:18.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.448]                       search = base::search(), system = base::Sys.info())
[09:32:18.448]                   }
[09:32:18.448]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.448]                     cond$call), session = sessionInformation(), 
[09:32:18.448]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.448]                   signalCondition(cond)
[09:32:18.448]                 }
[09:32:18.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.448]                 "immediateCondition"))) {
[09:32:18.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.448]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.448]                   if (TRUE && !signal) {
[09:32:18.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.448]                     {
[09:32:18.448]                       inherits <- base::inherits
[09:32:18.448]                       invokeRestart <- base::invokeRestart
[09:32:18.448]                       is.null <- base::is.null
[09:32:18.448]                       muffled <- FALSE
[09:32:18.448]                       if (inherits(cond, "message")) {
[09:32:18.448]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.448]                         if (muffled) 
[09:32:18.448]                           invokeRestart("muffleMessage")
[09:32:18.448]                       }
[09:32:18.448]                       else if (inherits(cond, "warning")) {
[09:32:18.448]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.448]                         if (muffled) 
[09:32:18.448]                           invokeRestart("muffleWarning")
[09:32:18.448]                       }
[09:32:18.448]                       else if (inherits(cond, "condition")) {
[09:32:18.448]                         if (!is.null(pattern)) {
[09:32:18.448]                           computeRestarts <- base::computeRestarts
[09:32:18.448]                           grepl <- base::grepl
[09:32:18.448]                           restarts <- computeRestarts(cond)
[09:32:18.448]                           for (restart in restarts) {
[09:32:18.448]                             name <- restart$name
[09:32:18.448]                             if (is.null(name)) 
[09:32:18.448]                               next
[09:32:18.448]                             if (!grepl(pattern, name)) 
[09:32:18.448]                               next
[09:32:18.448]                             invokeRestart(restart)
[09:32:18.448]                             muffled <- TRUE
[09:32:18.448]                             break
[09:32:18.448]                           }
[09:32:18.448]                         }
[09:32:18.448]                       }
[09:32:18.448]                       invisible(muffled)
[09:32:18.448]                     }
[09:32:18.448]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.448]                   }
[09:32:18.448]                 }
[09:32:18.448]                 else {
[09:32:18.448]                   if (TRUE) {
[09:32:18.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.448]                     {
[09:32:18.448]                       inherits <- base::inherits
[09:32:18.448]                       invokeRestart <- base::invokeRestart
[09:32:18.448]                       is.null <- base::is.null
[09:32:18.448]                       muffled <- FALSE
[09:32:18.448]                       if (inherits(cond, "message")) {
[09:32:18.448]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.448]                         if (muffled) 
[09:32:18.448]                           invokeRestart("muffleMessage")
[09:32:18.448]                       }
[09:32:18.448]                       else if (inherits(cond, "warning")) {
[09:32:18.448]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.448]                         if (muffled) 
[09:32:18.448]                           invokeRestart("muffleWarning")
[09:32:18.448]                       }
[09:32:18.448]                       else if (inherits(cond, "condition")) {
[09:32:18.448]                         if (!is.null(pattern)) {
[09:32:18.448]                           computeRestarts <- base::computeRestarts
[09:32:18.448]                           grepl <- base::grepl
[09:32:18.448]                           restarts <- computeRestarts(cond)
[09:32:18.448]                           for (restart in restarts) {
[09:32:18.448]                             name <- restart$name
[09:32:18.448]                             if (is.null(name)) 
[09:32:18.448]                               next
[09:32:18.448]                             if (!grepl(pattern, name)) 
[09:32:18.448]                               next
[09:32:18.448]                             invokeRestart(restart)
[09:32:18.448]                             muffled <- TRUE
[09:32:18.448]                             break
[09:32:18.448]                           }
[09:32:18.448]                         }
[09:32:18.448]                       }
[09:32:18.448]                       invisible(muffled)
[09:32:18.448]                     }
[09:32:18.448]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.448]                   }
[09:32:18.448]                 }
[09:32:18.448]             }
[09:32:18.448]         }))
[09:32:18.448]     }, error = function(ex) {
[09:32:18.448]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.448]                 ...future.rng), started = ...future.startTime, 
[09:32:18.448]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.448]             version = "1.8"), class = "FutureResult")
[09:32:18.448]     }, finally = {
[09:32:18.448]         if (!identical(...future.workdir, getwd())) 
[09:32:18.448]             setwd(...future.workdir)
[09:32:18.448]         {
[09:32:18.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.448]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.448]             }
[09:32:18.448]             base::options(...future.oldOptions)
[09:32:18.448]             if (.Platform$OS.type == "windows") {
[09:32:18.448]                 old_names <- names(...future.oldEnvVars)
[09:32:18.448]                 envs <- base::Sys.getenv()
[09:32:18.448]                 names <- names(envs)
[09:32:18.448]                 common <- intersect(names, old_names)
[09:32:18.448]                 added <- setdiff(names, old_names)
[09:32:18.448]                 removed <- setdiff(old_names, names)
[09:32:18.448]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.448]                   envs[common]]
[09:32:18.448]                 NAMES <- toupper(changed)
[09:32:18.448]                 args <- list()
[09:32:18.448]                 for (kk in seq_along(NAMES)) {
[09:32:18.448]                   name <- changed[[kk]]
[09:32:18.448]                   NAME <- NAMES[[kk]]
[09:32:18.448]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.448]                     next
[09:32:18.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.448]                 }
[09:32:18.448]                 NAMES <- toupper(added)
[09:32:18.448]                 for (kk in seq_along(NAMES)) {
[09:32:18.448]                   name <- added[[kk]]
[09:32:18.448]                   NAME <- NAMES[[kk]]
[09:32:18.448]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.448]                     next
[09:32:18.448]                   args[[name]] <- ""
[09:32:18.448]                 }
[09:32:18.448]                 NAMES <- toupper(removed)
[09:32:18.448]                 for (kk in seq_along(NAMES)) {
[09:32:18.448]                   name <- removed[[kk]]
[09:32:18.448]                   NAME <- NAMES[[kk]]
[09:32:18.448]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.448]                     next
[09:32:18.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.448]                 }
[09:32:18.448]                 if (length(args) > 0) 
[09:32:18.448]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.448]             }
[09:32:18.448]             else {
[09:32:18.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.448]             }
[09:32:18.448]             {
[09:32:18.448]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.448]                   0L) {
[09:32:18.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.448]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.448]                   base::options(opts)
[09:32:18.448]                 }
[09:32:18.448]                 {
[09:32:18.448]                   {
[09:32:18.448]                     NULL
[09:32:18.448]                     RNGkind("Mersenne-Twister")
[09:32:18.448]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.448]                       inherits = FALSE)
[09:32:18.448]                   }
[09:32:18.448]                   options(future.plan = NULL)
[09:32:18.448]                   if (is.na(NA_character_)) 
[09:32:18.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.448]                     .init = FALSE)
[09:32:18.448]                 }
[09:32:18.448]             }
[09:32:18.448]         }
[09:32:18.448]     })
[09:32:18.448]     if (TRUE) {
[09:32:18.448]         base::sink(type = "output", split = FALSE)
[09:32:18.448]         if (TRUE) {
[09:32:18.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.448]         }
[09:32:18.448]         else {
[09:32:18.448]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.448]         }
[09:32:18.448]         base::close(...future.stdout)
[09:32:18.448]         ...future.stdout <- NULL
[09:32:18.448]     }
[09:32:18.448]     ...future.result$conditions <- ...future.conditions
[09:32:18.448]     ...future.result$finished <- base::Sys.time()
[09:32:18.448]     ...future.result
[09:32:18.448] }
[09:32:18.449] assign_globals() ...
[09:32:18.449] List of 1
[09:32:18.449]  $ kk: int 2
[09:32:18.449]  - attr(*, "where")=List of 1
[09:32:18.449]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.449]  - attr(*, "resolved")= logi FALSE
[09:32:18.449]  - attr(*, "total_size")= num 56
[09:32:18.449]  - attr(*, "already-done")= logi TRUE
[09:32:18.452] - copied ‘kk’ to environment
[09:32:18.452] assign_globals() ... done
[09:32:18.452] plan(): Setting new future strategy stack:
[09:32:18.452] List of future strategies:
[09:32:18.452] 1. sequential:
[09:32:18.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.452]    - tweaked: FALSE
[09:32:18.452]    - call: NULL
[09:32:18.452] plan(): nbrOfWorkers() = 1
[09:32:18.553] plan(): Setting new future strategy stack:
[09:32:18.554] List of future strategies:
[09:32:18.554] 1. sequential:
[09:32:18.554]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.554]    - tweaked: FALSE
[09:32:18.554]    - call: plan(strategy)
[09:32:18.554] plan(): nbrOfWorkers() = 1
[09:32:18.554] SequentialFuture started (and completed)
[09:32:18.554] - Launch lazy future ... done
[09:32:18.554] run() for ‘SequentialFuture’ ... done
[09:32:18.555] getGlobalsAndPackages() ...
[09:32:18.555] Searching for globals...
[09:32:18.555] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.556] Searching for globals ... DONE
[09:32:18.556] Resolving globals: FALSE
[09:32:18.556] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.556] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.557] - globals: [1] ‘kk’
[09:32:18.557] 
[09:32:18.557] getGlobalsAndPackages() ... DONE
[09:32:18.557] run() for ‘Future’ ...
[09:32:18.557] - state: ‘created’
[09:32:18.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.557] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.557] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.558]   - Field: ‘label’
[09:32:18.558]   - Field: ‘local’
[09:32:18.558]   - Field: ‘owner’
[09:32:18.558]   - Field: ‘envir’
[09:32:18.558]   - Field: ‘packages’
[09:32:18.558]   - Field: ‘gc’
[09:32:18.558]   - Field: ‘conditions’
[09:32:18.558]   - Field: ‘expr’
[09:32:18.558]   - Field: ‘uuid’
[09:32:18.558]   - Field: ‘seed’
[09:32:18.558]   - Field: ‘version’
[09:32:18.559]   - Field: ‘result’
[09:32:18.559]   - Field: ‘asynchronous’
[09:32:18.559]   - Field: ‘calls’
[09:32:18.559]   - Field: ‘globals’
[09:32:18.559]   - Field: ‘stdout’
[09:32:18.559]   - Field: ‘earlySignal’
[09:32:18.559]   - Field: ‘lazy’
[09:32:18.559]   - Field: ‘state’
[09:32:18.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.559] - Launch lazy future ...
[09:32:18.559] Packages needed by the future expression (n = 0): <none>
[09:32:18.560] Packages needed by future strategies (n = 0): <none>
[09:32:18.560] {
[09:32:18.560]     {
[09:32:18.560]         {
[09:32:18.560]             ...future.startTime <- base::Sys.time()
[09:32:18.560]             {
[09:32:18.560]                 {
[09:32:18.560]                   {
[09:32:18.560]                     base::local({
[09:32:18.560]                       has_future <- base::requireNamespace("future", 
[09:32:18.560]                         quietly = TRUE)
[09:32:18.560]                       if (has_future) {
[09:32:18.560]                         ns <- base::getNamespace("future")
[09:32:18.560]                         version <- ns[[".package"]][["version"]]
[09:32:18.560]                         if (is.null(version)) 
[09:32:18.560]                           version <- utils::packageVersion("future")
[09:32:18.560]                       }
[09:32:18.560]                       else {
[09:32:18.560]                         version <- NULL
[09:32:18.560]                       }
[09:32:18.560]                       if (!has_future || version < "1.8.0") {
[09:32:18.560]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.560]                           "", base::R.version$version.string), 
[09:32:18.560]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.560]                             "release", "version")], collapse = " "), 
[09:32:18.560]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.560]                           info)
[09:32:18.560]                         info <- base::paste(info, collapse = "; ")
[09:32:18.560]                         if (!has_future) {
[09:32:18.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.560]                             info)
[09:32:18.560]                         }
[09:32:18.560]                         else {
[09:32:18.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.560]                             info, version)
[09:32:18.560]                         }
[09:32:18.560]                         base::stop(msg)
[09:32:18.560]                       }
[09:32:18.560]                     })
[09:32:18.560]                   }
[09:32:18.560]                   ...future.strategy.old <- future::plan("list")
[09:32:18.560]                   options(future.plan = NULL)
[09:32:18.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.560]                 }
[09:32:18.560]                 ...future.workdir <- getwd()
[09:32:18.560]             }
[09:32:18.560]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.560]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.560]         }
[09:32:18.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.560]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.560]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.560]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.560]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.560]             base::names(...future.oldOptions))
[09:32:18.560]     }
[09:32:18.560]     if (FALSE) {
[09:32:18.560]     }
[09:32:18.560]     else {
[09:32:18.560]         if (TRUE) {
[09:32:18.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.560]                 open = "w")
[09:32:18.560]         }
[09:32:18.560]         else {
[09:32:18.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.560]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.560]         }
[09:32:18.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.560]             base::sink(type = "output", split = FALSE)
[09:32:18.560]             base::close(...future.stdout)
[09:32:18.560]         }, add = TRUE)
[09:32:18.560]     }
[09:32:18.560]     ...future.frame <- base::sys.nframe()
[09:32:18.560]     ...future.conditions <- base::list()
[09:32:18.560]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.560]     if (FALSE) {
[09:32:18.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.560]     }
[09:32:18.560]     ...future.result <- base::tryCatch({
[09:32:18.560]         base::withCallingHandlers({
[09:32:18.560]             ...future.value <- base::withVisible(base::local({
[09:32:18.560]                 Sys.sleep(0.1)
[09:32:18.560]                 kk
[09:32:18.560]             }))
[09:32:18.560]             future::FutureResult(value = ...future.value$value, 
[09:32:18.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.560]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.560]                     ...future.globalenv.names))
[09:32:18.560]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.560]         }, condition = base::local({
[09:32:18.560]             c <- base::c
[09:32:18.560]             inherits <- base::inherits
[09:32:18.560]             invokeRestart <- base::invokeRestart
[09:32:18.560]             length <- base::length
[09:32:18.560]             list <- base::list
[09:32:18.560]             seq.int <- base::seq.int
[09:32:18.560]             signalCondition <- base::signalCondition
[09:32:18.560]             sys.calls <- base::sys.calls
[09:32:18.560]             `[[` <- base::`[[`
[09:32:18.560]             `+` <- base::`+`
[09:32:18.560]             `<<-` <- base::`<<-`
[09:32:18.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.560]                   3L)]
[09:32:18.560]             }
[09:32:18.560]             function(cond) {
[09:32:18.560]                 is_error <- inherits(cond, "error")
[09:32:18.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.560]                   NULL)
[09:32:18.560]                 if (is_error) {
[09:32:18.560]                   sessionInformation <- function() {
[09:32:18.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.560]                       search = base::search(), system = base::Sys.info())
[09:32:18.560]                   }
[09:32:18.560]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.560]                     cond$call), session = sessionInformation(), 
[09:32:18.560]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.560]                   signalCondition(cond)
[09:32:18.560]                 }
[09:32:18.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.560]                 "immediateCondition"))) {
[09:32:18.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.560]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.560]                   if (TRUE && !signal) {
[09:32:18.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.560]                     {
[09:32:18.560]                       inherits <- base::inherits
[09:32:18.560]                       invokeRestart <- base::invokeRestart
[09:32:18.560]                       is.null <- base::is.null
[09:32:18.560]                       muffled <- FALSE
[09:32:18.560]                       if (inherits(cond, "message")) {
[09:32:18.560]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.560]                         if (muffled) 
[09:32:18.560]                           invokeRestart("muffleMessage")
[09:32:18.560]                       }
[09:32:18.560]                       else if (inherits(cond, "warning")) {
[09:32:18.560]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.560]                         if (muffled) 
[09:32:18.560]                           invokeRestart("muffleWarning")
[09:32:18.560]                       }
[09:32:18.560]                       else if (inherits(cond, "condition")) {
[09:32:18.560]                         if (!is.null(pattern)) {
[09:32:18.560]                           computeRestarts <- base::computeRestarts
[09:32:18.560]                           grepl <- base::grepl
[09:32:18.560]                           restarts <- computeRestarts(cond)
[09:32:18.560]                           for (restart in restarts) {
[09:32:18.560]                             name <- restart$name
[09:32:18.560]                             if (is.null(name)) 
[09:32:18.560]                               next
[09:32:18.560]                             if (!grepl(pattern, name)) 
[09:32:18.560]                               next
[09:32:18.560]                             invokeRestart(restart)
[09:32:18.560]                             muffled <- TRUE
[09:32:18.560]                             break
[09:32:18.560]                           }
[09:32:18.560]                         }
[09:32:18.560]                       }
[09:32:18.560]                       invisible(muffled)
[09:32:18.560]                     }
[09:32:18.560]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.560]                   }
[09:32:18.560]                 }
[09:32:18.560]                 else {
[09:32:18.560]                   if (TRUE) {
[09:32:18.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.560]                     {
[09:32:18.560]                       inherits <- base::inherits
[09:32:18.560]                       invokeRestart <- base::invokeRestart
[09:32:18.560]                       is.null <- base::is.null
[09:32:18.560]                       muffled <- FALSE
[09:32:18.560]                       if (inherits(cond, "message")) {
[09:32:18.560]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.560]                         if (muffled) 
[09:32:18.560]                           invokeRestart("muffleMessage")
[09:32:18.560]                       }
[09:32:18.560]                       else if (inherits(cond, "warning")) {
[09:32:18.560]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.560]                         if (muffled) 
[09:32:18.560]                           invokeRestart("muffleWarning")
[09:32:18.560]                       }
[09:32:18.560]                       else if (inherits(cond, "condition")) {
[09:32:18.560]                         if (!is.null(pattern)) {
[09:32:18.560]                           computeRestarts <- base::computeRestarts
[09:32:18.560]                           grepl <- base::grepl
[09:32:18.560]                           restarts <- computeRestarts(cond)
[09:32:18.560]                           for (restart in restarts) {
[09:32:18.560]                             name <- restart$name
[09:32:18.560]                             if (is.null(name)) 
[09:32:18.560]                               next
[09:32:18.560]                             if (!grepl(pattern, name)) 
[09:32:18.560]                               next
[09:32:18.560]                             invokeRestart(restart)
[09:32:18.560]                             muffled <- TRUE
[09:32:18.560]                             break
[09:32:18.560]                           }
[09:32:18.560]                         }
[09:32:18.560]                       }
[09:32:18.560]                       invisible(muffled)
[09:32:18.560]                     }
[09:32:18.560]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.560]                   }
[09:32:18.560]                 }
[09:32:18.560]             }
[09:32:18.560]         }))
[09:32:18.560]     }, error = function(ex) {
[09:32:18.560]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.560]                 ...future.rng), started = ...future.startTime, 
[09:32:18.560]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.560]             version = "1.8"), class = "FutureResult")
[09:32:18.560]     }, finally = {
[09:32:18.560]         if (!identical(...future.workdir, getwd())) 
[09:32:18.560]             setwd(...future.workdir)
[09:32:18.560]         {
[09:32:18.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.560]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.560]             }
[09:32:18.560]             base::options(...future.oldOptions)
[09:32:18.560]             if (.Platform$OS.type == "windows") {
[09:32:18.560]                 old_names <- names(...future.oldEnvVars)
[09:32:18.560]                 envs <- base::Sys.getenv()
[09:32:18.560]                 names <- names(envs)
[09:32:18.560]                 common <- intersect(names, old_names)
[09:32:18.560]                 added <- setdiff(names, old_names)
[09:32:18.560]                 removed <- setdiff(old_names, names)
[09:32:18.560]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.560]                   envs[common]]
[09:32:18.560]                 NAMES <- toupper(changed)
[09:32:18.560]                 args <- list()
[09:32:18.560]                 for (kk in seq_along(NAMES)) {
[09:32:18.560]                   name <- changed[[kk]]
[09:32:18.560]                   NAME <- NAMES[[kk]]
[09:32:18.560]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.560]                     next
[09:32:18.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.560]                 }
[09:32:18.560]                 NAMES <- toupper(added)
[09:32:18.560]                 for (kk in seq_along(NAMES)) {
[09:32:18.560]                   name <- added[[kk]]
[09:32:18.560]                   NAME <- NAMES[[kk]]
[09:32:18.560]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.560]                     next
[09:32:18.560]                   args[[name]] <- ""
[09:32:18.560]                 }
[09:32:18.560]                 NAMES <- toupper(removed)
[09:32:18.560]                 for (kk in seq_along(NAMES)) {
[09:32:18.560]                   name <- removed[[kk]]
[09:32:18.560]                   NAME <- NAMES[[kk]]
[09:32:18.560]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.560]                     next
[09:32:18.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.560]                 }
[09:32:18.560]                 if (length(args) > 0) 
[09:32:18.560]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.560]             }
[09:32:18.560]             else {
[09:32:18.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.560]             }
[09:32:18.560]             {
[09:32:18.560]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.560]                   0L) {
[09:32:18.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.560]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.560]                   base::options(opts)
[09:32:18.560]                 }
[09:32:18.560]                 {
[09:32:18.560]                   {
[09:32:18.560]                     NULL
[09:32:18.560]                     RNGkind("Mersenne-Twister")
[09:32:18.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.560]                       inherits = FALSE)
[09:32:18.560]                   }
[09:32:18.560]                   options(future.plan = NULL)
[09:32:18.560]                   if (is.na(NA_character_)) 
[09:32:18.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.560]                     .init = FALSE)
[09:32:18.560]                 }
[09:32:18.560]             }
[09:32:18.560]         }
[09:32:18.560]     })
[09:32:18.560]     if (TRUE) {
[09:32:18.560]         base::sink(type = "output", split = FALSE)
[09:32:18.560]         if (TRUE) {
[09:32:18.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.560]         }
[09:32:18.560]         else {
[09:32:18.560]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.560]         }
[09:32:18.560]         base::close(...future.stdout)
[09:32:18.560]         ...future.stdout <- NULL
[09:32:18.560]     }
[09:32:18.560]     ...future.result$conditions <- ...future.conditions
[09:32:18.560]     ...future.result$finished <- base::Sys.time()
[09:32:18.560]     ...future.result
[09:32:18.560] }
[09:32:18.562] assign_globals() ...
[09:32:18.562] List of 1
[09:32:18.562]  $ kk: int 3
[09:32:18.562]  - attr(*, "where")=List of 1
[09:32:18.562]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.562]  - attr(*, "resolved")= logi FALSE
[09:32:18.562]  - attr(*, "total_size")= num 56
[09:32:18.562]  - attr(*, "already-done")= logi TRUE
[09:32:18.564] - copied ‘kk’ to environment
[09:32:18.564] assign_globals() ... done
[09:32:18.564] plan(): Setting new future strategy stack:
[09:32:18.564] List of future strategies:
[09:32:18.564] 1. sequential:
[09:32:18.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.564]    - tweaked: FALSE
[09:32:18.564]    - call: NULL
[09:32:18.565] plan(): nbrOfWorkers() = 1
[09:32:18.667] plan(): Setting new future strategy stack:
[09:32:18.667] List of future strategies:
[09:32:18.667] 1. sequential:
[09:32:18.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.667]    - tweaked: FALSE
[09:32:18.667]    - call: plan(strategy)
[09:32:18.668] plan(): nbrOfWorkers() = 1
[09:32:18.668] SequentialFuture started (and completed)
[09:32:18.668] - Launch lazy future ... done
[09:32:18.668] run() for ‘SequentialFuture’ ... done
[09:32:18.668] resolve() on list ...
[09:32:18.668]  recursive: 0
[09:32:18.668]  length: 3
[09:32:18.669] 
[09:32:18.669] resolved() for ‘SequentialFuture’ ...
[09:32:18.669] - state: ‘finished’
[09:32:18.669] - run: TRUE
[09:32:18.669] - result: ‘FutureResult’
[09:32:18.669] resolved() for ‘SequentialFuture’ ... done
[09:32:18.669] Future #1
[09:32:18.669]  length: 2 (resolved future 1)
[09:32:18.669] resolved() for ‘SequentialFuture’ ...
[09:32:18.669] - state: ‘finished’
[09:32:18.669] - run: TRUE
[09:32:18.670] - result: ‘FutureResult’
[09:32:18.670] resolved() for ‘SequentialFuture’ ... done
[09:32:18.670] Future #2
[09:32:18.670]  length: 1 (resolved future 2)
[09:32:18.670] resolved() for ‘SequentialFuture’ ...
[09:32:18.670] - state: ‘finished’
[09:32:18.670] - run: TRUE
[09:32:18.670] - result: ‘FutureResult’
[09:32:18.670] resolved() for ‘SequentialFuture’ ... done
[09:32:18.670] Future #3
[09:32:18.670]  length: 0 (resolved future 3)
[09:32:18.671] resolve() on list ... DONE
[09:32:18.671] getGlobalsAndPackages() ...
[09:32:18.671] Searching for globals...
[09:32:18.672] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.672] Searching for globals ... DONE
[09:32:18.672] Resolving globals: FALSE
[09:32:18.672] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.673] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.673] - globals: [1] ‘kk’
[09:32:18.673] 
[09:32:18.673] getGlobalsAndPackages() ... DONE
[09:32:18.673] getGlobalsAndPackages() ...
[09:32:18.673] Searching for globals...
[09:32:18.674] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.674] Searching for globals ... DONE
[09:32:18.674] Resolving globals: FALSE
[09:32:18.674] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.675] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.675] - globals: [1] ‘kk’
[09:32:18.675] 
[09:32:18.675] getGlobalsAndPackages() ... DONE
[09:32:18.675] getGlobalsAndPackages() ...
[09:32:18.675] Searching for globals...
[09:32:18.676] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:18.676] Searching for globals ... DONE
[09:32:18.676] Resolving globals: FALSE
[09:32:18.677] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:18.677] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:18.677] - globals: [1] ‘kk’
[09:32:18.677] 
[09:32:18.677] getGlobalsAndPackages() ... DONE
[09:32:18.678] resolve() on list ...
[09:32:18.678]  recursive: 0
[09:32:18.678]  length: 3
[09:32:18.678] 
[09:32:18.678] run() for ‘Future’ ...
[09:32:18.678] - state: ‘created’
[09:32:18.678] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.678] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.679]   - Field: ‘label’
[09:32:18.679]   - Field: ‘local’
[09:32:18.679]   - Field: ‘owner’
[09:32:18.679]   - Field: ‘envir’
[09:32:18.679]   - Field: ‘packages’
[09:32:18.679]   - Field: ‘gc’
[09:32:18.679]   - Field: ‘conditions’
[09:32:18.679]   - Field: ‘expr’
[09:32:18.679]   - Field: ‘uuid’
[09:32:18.679]   - Field: ‘seed’
[09:32:18.679]   - Field: ‘version’
[09:32:18.680]   - Field: ‘result’
[09:32:18.680]   - Field: ‘asynchronous’
[09:32:18.680]   - Field: ‘calls’
[09:32:18.680]   - Field: ‘globals’
[09:32:18.680]   - Field: ‘stdout’
[09:32:18.680]   - Field: ‘earlySignal’
[09:32:18.680]   - Field: ‘lazy’
[09:32:18.680]   - Field: ‘state’
[09:32:18.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.680] - Launch lazy future ...
[09:32:18.681] Packages needed by the future expression (n = 0): <none>
[09:32:18.681] Packages needed by future strategies (n = 0): <none>
[09:32:18.681] {
[09:32:18.681]     {
[09:32:18.681]         {
[09:32:18.681]             ...future.startTime <- base::Sys.time()
[09:32:18.681]             {
[09:32:18.681]                 {
[09:32:18.681]                   {
[09:32:18.681]                     base::local({
[09:32:18.681]                       has_future <- base::requireNamespace("future", 
[09:32:18.681]                         quietly = TRUE)
[09:32:18.681]                       if (has_future) {
[09:32:18.681]                         ns <- base::getNamespace("future")
[09:32:18.681]                         version <- ns[[".package"]][["version"]]
[09:32:18.681]                         if (is.null(version)) 
[09:32:18.681]                           version <- utils::packageVersion("future")
[09:32:18.681]                       }
[09:32:18.681]                       else {
[09:32:18.681]                         version <- NULL
[09:32:18.681]                       }
[09:32:18.681]                       if (!has_future || version < "1.8.0") {
[09:32:18.681]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.681]                           "", base::R.version$version.string), 
[09:32:18.681]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.681]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.681]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.681]                             "release", "version")], collapse = " "), 
[09:32:18.681]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.681]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.681]                           info)
[09:32:18.681]                         info <- base::paste(info, collapse = "; ")
[09:32:18.681]                         if (!has_future) {
[09:32:18.681]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.681]                             info)
[09:32:18.681]                         }
[09:32:18.681]                         else {
[09:32:18.681]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.681]                             info, version)
[09:32:18.681]                         }
[09:32:18.681]                         base::stop(msg)
[09:32:18.681]                       }
[09:32:18.681]                     })
[09:32:18.681]                   }
[09:32:18.681]                   ...future.strategy.old <- future::plan("list")
[09:32:18.681]                   options(future.plan = NULL)
[09:32:18.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.681]                 }
[09:32:18.681]                 ...future.workdir <- getwd()
[09:32:18.681]             }
[09:32:18.681]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.681]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.681]         }
[09:32:18.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.681]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.681]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.681]             base::names(...future.oldOptions))
[09:32:18.681]     }
[09:32:18.681]     if (FALSE) {
[09:32:18.681]     }
[09:32:18.681]     else {
[09:32:18.681]         if (TRUE) {
[09:32:18.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.681]                 open = "w")
[09:32:18.681]         }
[09:32:18.681]         else {
[09:32:18.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.681]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.681]         }
[09:32:18.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.681]             base::sink(type = "output", split = FALSE)
[09:32:18.681]             base::close(...future.stdout)
[09:32:18.681]         }, add = TRUE)
[09:32:18.681]     }
[09:32:18.681]     ...future.frame <- base::sys.nframe()
[09:32:18.681]     ...future.conditions <- base::list()
[09:32:18.681]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.681]     if (FALSE) {
[09:32:18.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.681]     }
[09:32:18.681]     ...future.result <- base::tryCatch({
[09:32:18.681]         base::withCallingHandlers({
[09:32:18.681]             ...future.value <- base::withVisible(base::local({
[09:32:18.681]                 Sys.sleep(0.1)
[09:32:18.681]                 kk
[09:32:18.681]             }))
[09:32:18.681]             future::FutureResult(value = ...future.value$value, 
[09:32:18.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.681]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.681]                     ...future.globalenv.names))
[09:32:18.681]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.681]         }, condition = base::local({
[09:32:18.681]             c <- base::c
[09:32:18.681]             inherits <- base::inherits
[09:32:18.681]             invokeRestart <- base::invokeRestart
[09:32:18.681]             length <- base::length
[09:32:18.681]             list <- base::list
[09:32:18.681]             seq.int <- base::seq.int
[09:32:18.681]             signalCondition <- base::signalCondition
[09:32:18.681]             sys.calls <- base::sys.calls
[09:32:18.681]             `[[` <- base::`[[`
[09:32:18.681]             `+` <- base::`+`
[09:32:18.681]             `<<-` <- base::`<<-`
[09:32:18.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.681]                   3L)]
[09:32:18.681]             }
[09:32:18.681]             function(cond) {
[09:32:18.681]                 is_error <- inherits(cond, "error")
[09:32:18.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.681]                   NULL)
[09:32:18.681]                 if (is_error) {
[09:32:18.681]                   sessionInformation <- function() {
[09:32:18.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.681]                       search = base::search(), system = base::Sys.info())
[09:32:18.681]                   }
[09:32:18.681]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.681]                     cond$call), session = sessionInformation(), 
[09:32:18.681]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.681]                   signalCondition(cond)
[09:32:18.681]                 }
[09:32:18.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.681]                 "immediateCondition"))) {
[09:32:18.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.681]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.681]                   if (TRUE && !signal) {
[09:32:18.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.681]                     {
[09:32:18.681]                       inherits <- base::inherits
[09:32:18.681]                       invokeRestart <- base::invokeRestart
[09:32:18.681]                       is.null <- base::is.null
[09:32:18.681]                       muffled <- FALSE
[09:32:18.681]                       if (inherits(cond, "message")) {
[09:32:18.681]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.681]                         if (muffled) 
[09:32:18.681]                           invokeRestart("muffleMessage")
[09:32:18.681]                       }
[09:32:18.681]                       else if (inherits(cond, "warning")) {
[09:32:18.681]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.681]                         if (muffled) 
[09:32:18.681]                           invokeRestart("muffleWarning")
[09:32:18.681]                       }
[09:32:18.681]                       else if (inherits(cond, "condition")) {
[09:32:18.681]                         if (!is.null(pattern)) {
[09:32:18.681]                           computeRestarts <- base::computeRestarts
[09:32:18.681]                           grepl <- base::grepl
[09:32:18.681]                           restarts <- computeRestarts(cond)
[09:32:18.681]                           for (restart in restarts) {
[09:32:18.681]                             name <- restart$name
[09:32:18.681]                             if (is.null(name)) 
[09:32:18.681]                               next
[09:32:18.681]                             if (!grepl(pattern, name)) 
[09:32:18.681]                               next
[09:32:18.681]                             invokeRestart(restart)
[09:32:18.681]                             muffled <- TRUE
[09:32:18.681]                             break
[09:32:18.681]                           }
[09:32:18.681]                         }
[09:32:18.681]                       }
[09:32:18.681]                       invisible(muffled)
[09:32:18.681]                     }
[09:32:18.681]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.681]                   }
[09:32:18.681]                 }
[09:32:18.681]                 else {
[09:32:18.681]                   if (TRUE) {
[09:32:18.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.681]                     {
[09:32:18.681]                       inherits <- base::inherits
[09:32:18.681]                       invokeRestart <- base::invokeRestart
[09:32:18.681]                       is.null <- base::is.null
[09:32:18.681]                       muffled <- FALSE
[09:32:18.681]                       if (inherits(cond, "message")) {
[09:32:18.681]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.681]                         if (muffled) 
[09:32:18.681]                           invokeRestart("muffleMessage")
[09:32:18.681]                       }
[09:32:18.681]                       else if (inherits(cond, "warning")) {
[09:32:18.681]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.681]                         if (muffled) 
[09:32:18.681]                           invokeRestart("muffleWarning")
[09:32:18.681]                       }
[09:32:18.681]                       else if (inherits(cond, "condition")) {
[09:32:18.681]                         if (!is.null(pattern)) {
[09:32:18.681]                           computeRestarts <- base::computeRestarts
[09:32:18.681]                           grepl <- base::grepl
[09:32:18.681]                           restarts <- computeRestarts(cond)
[09:32:18.681]                           for (restart in restarts) {
[09:32:18.681]                             name <- restart$name
[09:32:18.681]                             if (is.null(name)) 
[09:32:18.681]                               next
[09:32:18.681]                             if (!grepl(pattern, name)) 
[09:32:18.681]                               next
[09:32:18.681]                             invokeRestart(restart)
[09:32:18.681]                             muffled <- TRUE
[09:32:18.681]                             break
[09:32:18.681]                           }
[09:32:18.681]                         }
[09:32:18.681]                       }
[09:32:18.681]                       invisible(muffled)
[09:32:18.681]                     }
[09:32:18.681]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.681]                   }
[09:32:18.681]                 }
[09:32:18.681]             }
[09:32:18.681]         }))
[09:32:18.681]     }, error = function(ex) {
[09:32:18.681]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.681]                 ...future.rng), started = ...future.startTime, 
[09:32:18.681]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.681]             version = "1.8"), class = "FutureResult")
[09:32:18.681]     }, finally = {
[09:32:18.681]         if (!identical(...future.workdir, getwd())) 
[09:32:18.681]             setwd(...future.workdir)
[09:32:18.681]         {
[09:32:18.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.681]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.681]             }
[09:32:18.681]             base::options(...future.oldOptions)
[09:32:18.681]             if (.Platform$OS.type == "windows") {
[09:32:18.681]                 old_names <- names(...future.oldEnvVars)
[09:32:18.681]                 envs <- base::Sys.getenv()
[09:32:18.681]                 names <- names(envs)
[09:32:18.681]                 common <- intersect(names, old_names)
[09:32:18.681]                 added <- setdiff(names, old_names)
[09:32:18.681]                 removed <- setdiff(old_names, names)
[09:32:18.681]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.681]                   envs[common]]
[09:32:18.681]                 NAMES <- toupper(changed)
[09:32:18.681]                 args <- list()
[09:32:18.681]                 for (kk in seq_along(NAMES)) {
[09:32:18.681]                   name <- changed[[kk]]
[09:32:18.681]                   NAME <- NAMES[[kk]]
[09:32:18.681]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.681]                     next
[09:32:18.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.681]                 }
[09:32:18.681]                 NAMES <- toupper(added)
[09:32:18.681]                 for (kk in seq_along(NAMES)) {
[09:32:18.681]                   name <- added[[kk]]
[09:32:18.681]                   NAME <- NAMES[[kk]]
[09:32:18.681]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.681]                     next
[09:32:18.681]                   args[[name]] <- ""
[09:32:18.681]                 }
[09:32:18.681]                 NAMES <- toupper(removed)
[09:32:18.681]                 for (kk in seq_along(NAMES)) {
[09:32:18.681]                   name <- removed[[kk]]
[09:32:18.681]                   NAME <- NAMES[[kk]]
[09:32:18.681]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.681]                     next
[09:32:18.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.681]                 }
[09:32:18.681]                 if (length(args) > 0) 
[09:32:18.681]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.681]             }
[09:32:18.681]             else {
[09:32:18.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.681]             }
[09:32:18.681]             {
[09:32:18.681]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.681]                   0L) {
[09:32:18.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.681]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.681]                   base::options(opts)
[09:32:18.681]                 }
[09:32:18.681]                 {
[09:32:18.681]                   {
[09:32:18.681]                     NULL
[09:32:18.681]                     RNGkind("Mersenne-Twister")
[09:32:18.681]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.681]                       inherits = FALSE)
[09:32:18.681]                   }
[09:32:18.681]                   options(future.plan = NULL)
[09:32:18.681]                   if (is.na(NA_character_)) 
[09:32:18.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.681]                     .init = FALSE)
[09:32:18.681]                 }
[09:32:18.681]             }
[09:32:18.681]         }
[09:32:18.681]     })
[09:32:18.681]     if (TRUE) {
[09:32:18.681]         base::sink(type = "output", split = FALSE)
[09:32:18.681]         if (TRUE) {
[09:32:18.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.681]         }
[09:32:18.681]         else {
[09:32:18.681]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.681]         }
[09:32:18.681]         base::close(...future.stdout)
[09:32:18.681]         ...future.stdout <- NULL
[09:32:18.681]     }
[09:32:18.681]     ...future.result$conditions <- ...future.conditions
[09:32:18.681]     ...future.result$finished <- base::Sys.time()
[09:32:18.681]     ...future.result
[09:32:18.681] }
[09:32:18.683] assign_globals() ...
[09:32:18.683] List of 1
[09:32:18.683]  $ kk: int 1
[09:32:18.683]  - attr(*, "where")=List of 1
[09:32:18.683]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.683]  - attr(*, "resolved")= logi FALSE
[09:32:18.683]  - attr(*, "total_size")= num 56
[09:32:18.683]  - attr(*, "already-done")= logi TRUE
[09:32:18.685] - copied ‘kk’ to environment
[09:32:18.685] assign_globals() ... done
[09:32:18.685] plan(): Setting new future strategy stack:
[09:32:18.685] List of future strategies:
[09:32:18.685] 1. sequential:
[09:32:18.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.685]    - tweaked: FALSE
[09:32:18.685]    - call: NULL
[09:32:18.686] plan(): nbrOfWorkers() = 1
[09:32:18.787] plan(): Setting new future strategy stack:
[09:32:18.787] List of future strategies:
[09:32:18.787] 1. sequential:
[09:32:18.787]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.787]    - tweaked: FALSE
[09:32:18.787]    - call: plan(strategy)
[09:32:18.787] plan(): nbrOfWorkers() = 1
[09:32:18.787] SequentialFuture started (and completed)
[09:32:18.788] - Launch lazy future ... done
[09:32:18.788] run() for ‘SequentialFuture’ ... done
[09:32:18.788] resolved() for ‘SequentialFuture’ ...
[09:32:18.788] - state: ‘finished’
[09:32:18.788] - run: TRUE
[09:32:18.788] - result: ‘FutureResult’
[09:32:18.788] resolved() for ‘SequentialFuture’ ... done
[09:32:18.788] Future #1
[09:32:18.788]  length: 2 (resolved future 1)
[09:32:18.789] run() for ‘Future’ ...
[09:32:18.789] - state: ‘created’
[09:32:18.789] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.789] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.789]   - Field: ‘label’
[09:32:18.789]   - Field: ‘local’
[09:32:18.789]   - Field: ‘owner’
[09:32:18.789]   - Field: ‘envir’
[09:32:18.790]   - Field: ‘packages’
[09:32:18.790]   - Field: ‘gc’
[09:32:18.790]   - Field: ‘conditions’
[09:32:18.790]   - Field: ‘expr’
[09:32:18.790]   - Field: ‘uuid’
[09:32:18.790]   - Field: ‘seed’
[09:32:18.790]   - Field: ‘version’
[09:32:18.790]   - Field: ‘result’
[09:32:18.790]   - Field: ‘asynchronous’
[09:32:18.790]   - Field: ‘calls’
[09:32:18.790]   - Field: ‘globals’
[09:32:18.790]   - Field: ‘stdout’
[09:32:18.791]   - Field: ‘earlySignal’
[09:32:18.791]   - Field: ‘lazy’
[09:32:18.791]   - Field: ‘state’
[09:32:18.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.791] - Launch lazy future ...
[09:32:18.791] Packages needed by the future expression (n = 0): <none>
[09:32:18.791] Packages needed by future strategies (n = 0): <none>
[09:32:18.792] {
[09:32:18.792]     {
[09:32:18.792]         {
[09:32:18.792]             ...future.startTime <- base::Sys.time()
[09:32:18.792]             {
[09:32:18.792]                 {
[09:32:18.792]                   {
[09:32:18.792]                     base::local({
[09:32:18.792]                       has_future <- base::requireNamespace("future", 
[09:32:18.792]                         quietly = TRUE)
[09:32:18.792]                       if (has_future) {
[09:32:18.792]                         ns <- base::getNamespace("future")
[09:32:18.792]                         version <- ns[[".package"]][["version"]]
[09:32:18.792]                         if (is.null(version)) 
[09:32:18.792]                           version <- utils::packageVersion("future")
[09:32:18.792]                       }
[09:32:18.792]                       else {
[09:32:18.792]                         version <- NULL
[09:32:18.792]                       }
[09:32:18.792]                       if (!has_future || version < "1.8.0") {
[09:32:18.792]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.792]                           "", base::R.version$version.string), 
[09:32:18.792]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.792]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.792]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.792]                             "release", "version")], collapse = " "), 
[09:32:18.792]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.792]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.792]                           info)
[09:32:18.792]                         info <- base::paste(info, collapse = "; ")
[09:32:18.792]                         if (!has_future) {
[09:32:18.792]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.792]                             info)
[09:32:18.792]                         }
[09:32:18.792]                         else {
[09:32:18.792]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.792]                             info, version)
[09:32:18.792]                         }
[09:32:18.792]                         base::stop(msg)
[09:32:18.792]                       }
[09:32:18.792]                     })
[09:32:18.792]                   }
[09:32:18.792]                   ...future.strategy.old <- future::plan("list")
[09:32:18.792]                   options(future.plan = NULL)
[09:32:18.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.792]                 }
[09:32:18.792]                 ...future.workdir <- getwd()
[09:32:18.792]             }
[09:32:18.792]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.792]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.792]         }
[09:32:18.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.792]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.792]             base::names(...future.oldOptions))
[09:32:18.792]     }
[09:32:18.792]     if (FALSE) {
[09:32:18.792]     }
[09:32:18.792]     else {
[09:32:18.792]         if (TRUE) {
[09:32:18.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.792]                 open = "w")
[09:32:18.792]         }
[09:32:18.792]         else {
[09:32:18.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.792]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.792]         }
[09:32:18.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.792]             base::sink(type = "output", split = FALSE)
[09:32:18.792]             base::close(...future.stdout)
[09:32:18.792]         }, add = TRUE)
[09:32:18.792]     }
[09:32:18.792]     ...future.frame <- base::sys.nframe()
[09:32:18.792]     ...future.conditions <- base::list()
[09:32:18.792]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.792]     if (FALSE) {
[09:32:18.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.792]     }
[09:32:18.792]     ...future.result <- base::tryCatch({
[09:32:18.792]         base::withCallingHandlers({
[09:32:18.792]             ...future.value <- base::withVisible(base::local({
[09:32:18.792]                 Sys.sleep(0.1)
[09:32:18.792]                 kk
[09:32:18.792]             }))
[09:32:18.792]             future::FutureResult(value = ...future.value$value, 
[09:32:18.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.792]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.792]                     ...future.globalenv.names))
[09:32:18.792]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.792]         }, condition = base::local({
[09:32:18.792]             c <- base::c
[09:32:18.792]             inherits <- base::inherits
[09:32:18.792]             invokeRestart <- base::invokeRestart
[09:32:18.792]             length <- base::length
[09:32:18.792]             list <- base::list
[09:32:18.792]             seq.int <- base::seq.int
[09:32:18.792]             signalCondition <- base::signalCondition
[09:32:18.792]             sys.calls <- base::sys.calls
[09:32:18.792]             `[[` <- base::`[[`
[09:32:18.792]             `+` <- base::`+`
[09:32:18.792]             `<<-` <- base::`<<-`
[09:32:18.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.792]                   3L)]
[09:32:18.792]             }
[09:32:18.792]             function(cond) {
[09:32:18.792]                 is_error <- inherits(cond, "error")
[09:32:18.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.792]                   NULL)
[09:32:18.792]                 if (is_error) {
[09:32:18.792]                   sessionInformation <- function() {
[09:32:18.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.792]                       search = base::search(), system = base::Sys.info())
[09:32:18.792]                   }
[09:32:18.792]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.792]                     cond$call), session = sessionInformation(), 
[09:32:18.792]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.792]                   signalCondition(cond)
[09:32:18.792]                 }
[09:32:18.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.792]                 "immediateCondition"))) {
[09:32:18.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.792]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.792]                   if (TRUE && !signal) {
[09:32:18.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.792]                     {
[09:32:18.792]                       inherits <- base::inherits
[09:32:18.792]                       invokeRestart <- base::invokeRestart
[09:32:18.792]                       is.null <- base::is.null
[09:32:18.792]                       muffled <- FALSE
[09:32:18.792]                       if (inherits(cond, "message")) {
[09:32:18.792]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.792]                         if (muffled) 
[09:32:18.792]                           invokeRestart("muffleMessage")
[09:32:18.792]                       }
[09:32:18.792]                       else if (inherits(cond, "warning")) {
[09:32:18.792]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.792]                         if (muffled) 
[09:32:18.792]                           invokeRestart("muffleWarning")
[09:32:18.792]                       }
[09:32:18.792]                       else if (inherits(cond, "condition")) {
[09:32:18.792]                         if (!is.null(pattern)) {
[09:32:18.792]                           computeRestarts <- base::computeRestarts
[09:32:18.792]                           grepl <- base::grepl
[09:32:18.792]                           restarts <- computeRestarts(cond)
[09:32:18.792]                           for (restart in restarts) {
[09:32:18.792]                             name <- restart$name
[09:32:18.792]                             if (is.null(name)) 
[09:32:18.792]                               next
[09:32:18.792]                             if (!grepl(pattern, name)) 
[09:32:18.792]                               next
[09:32:18.792]                             invokeRestart(restart)
[09:32:18.792]                             muffled <- TRUE
[09:32:18.792]                             break
[09:32:18.792]                           }
[09:32:18.792]                         }
[09:32:18.792]                       }
[09:32:18.792]                       invisible(muffled)
[09:32:18.792]                     }
[09:32:18.792]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.792]                   }
[09:32:18.792]                 }
[09:32:18.792]                 else {
[09:32:18.792]                   if (TRUE) {
[09:32:18.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.792]                     {
[09:32:18.792]                       inherits <- base::inherits
[09:32:18.792]                       invokeRestart <- base::invokeRestart
[09:32:18.792]                       is.null <- base::is.null
[09:32:18.792]                       muffled <- FALSE
[09:32:18.792]                       if (inherits(cond, "message")) {
[09:32:18.792]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.792]                         if (muffled) 
[09:32:18.792]                           invokeRestart("muffleMessage")
[09:32:18.792]                       }
[09:32:18.792]                       else if (inherits(cond, "warning")) {
[09:32:18.792]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.792]                         if (muffled) 
[09:32:18.792]                           invokeRestart("muffleWarning")
[09:32:18.792]                       }
[09:32:18.792]                       else if (inherits(cond, "condition")) {
[09:32:18.792]                         if (!is.null(pattern)) {
[09:32:18.792]                           computeRestarts <- base::computeRestarts
[09:32:18.792]                           grepl <- base::grepl
[09:32:18.792]                           restarts <- computeRestarts(cond)
[09:32:18.792]                           for (restart in restarts) {
[09:32:18.792]                             name <- restart$name
[09:32:18.792]                             if (is.null(name)) 
[09:32:18.792]                               next
[09:32:18.792]                             if (!grepl(pattern, name)) 
[09:32:18.792]                               next
[09:32:18.792]                             invokeRestart(restart)
[09:32:18.792]                             muffled <- TRUE
[09:32:18.792]                             break
[09:32:18.792]                           }
[09:32:18.792]                         }
[09:32:18.792]                       }
[09:32:18.792]                       invisible(muffled)
[09:32:18.792]                     }
[09:32:18.792]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.792]                   }
[09:32:18.792]                 }
[09:32:18.792]             }
[09:32:18.792]         }))
[09:32:18.792]     }, error = function(ex) {
[09:32:18.792]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.792]                 ...future.rng), started = ...future.startTime, 
[09:32:18.792]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.792]             version = "1.8"), class = "FutureResult")
[09:32:18.792]     }, finally = {
[09:32:18.792]         if (!identical(...future.workdir, getwd())) 
[09:32:18.792]             setwd(...future.workdir)
[09:32:18.792]         {
[09:32:18.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.792]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.792]             }
[09:32:18.792]             base::options(...future.oldOptions)
[09:32:18.792]             if (.Platform$OS.type == "windows") {
[09:32:18.792]                 old_names <- names(...future.oldEnvVars)
[09:32:18.792]                 envs <- base::Sys.getenv()
[09:32:18.792]                 names <- names(envs)
[09:32:18.792]                 common <- intersect(names, old_names)
[09:32:18.792]                 added <- setdiff(names, old_names)
[09:32:18.792]                 removed <- setdiff(old_names, names)
[09:32:18.792]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.792]                   envs[common]]
[09:32:18.792]                 NAMES <- toupper(changed)
[09:32:18.792]                 args <- list()
[09:32:18.792]                 for (kk in seq_along(NAMES)) {
[09:32:18.792]                   name <- changed[[kk]]
[09:32:18.792]                   NAME <- NAMES[[kk]]
[09:32:18.792]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.792]                     next
[09:32:18.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.792]                 }
[09:32:18.792]                 NAMES <- toupper(added)
[09:32:18.792]                 for (kk in seq_along(NAMES)) {
[09:32:18.792]                   name <- added[[kk]]
[09:32:18.792]                   NAME <- NAMES[[kk]]
[09:32:18.792]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.792]                     next
[09:32:18.792]                   args[[name]] <- ""
[09:32:18.792]                 }
[09:32:18.792]                 NAMES <- toupper(removed)
[09:32:18.792]                 for (kk in seq_along(NAMES)) {
[09:32:18.792]                   name <- removed[[kk]]
[09:32:18.792]                   NAME <- NAMES[[kk]]
[09:32:18.792]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.792]                     next
[09:32:18.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.792]                 }
[09:32:18.792]                 if (length(args) > 0) 
[09:32:18.792]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.792]             }
[09:32:18.792]             else {
[09:32:18.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.792]             }
[09:32:18.792]             {
[09:32:18.792]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.792]                   0L) {
[09:32:18.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.792]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.792]                   base::options(opts)
[09:32:18.792]                 }
[09:32:18.792]                 {
[09:32:18.792]                   {
[09:32:18.792]                     NULL
[09:32:18.792]                     RNGkind("Mersenne-Twister")
[09:32:18.792]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.792]                       inherits = FALSE)
[09:32:18.792]                   }
[09:32:18.792]                   options(future.plan = NULL)
[09:32:18.792]                   if (is.na(NA_character_)) 
[09:32:18.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.792]                     .init = FALSE)
[09:32:18.792]                 }
[09:32:18.792]             }
[09:32:18.792]         }
[09:32:18.792]     })
[09:32:18.792]     if (TRUE) {
[09:32:18.792]         base::sink(type = "output", split = FALSE)
[09:32:18.792]         if (TRUE) {
[09:32:18.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.792]         }
[09:32:18.792]         else {
[09:32:18.792]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.792]         }
[09:32:18.792]         base::close(...future.stdout)
[09:32:18.792]         ...future.stdout <- NULL
[09:32:18.792]     }
[09:32:18.792]     ...future.result$conditions <- ...future.conditions
[09:32:18.792]     ...future.result$finished <- base::Sys.time()
[09:32:18.792]     ...future.result
[09:32:18.792] }
[09:32:18.793] assign_globals() ...
[09:32:18.793] List of 1
[09:32:18.793]  $ kk: int 2
[09:32:18.793]  - attr(*, "where")=List of 1
[09:32:18.793]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.793]  - attr(*, "resolved")= logi FALSE
[09:32:18.793]  - attr(*, "total_size")= num 56
[09:32:18.793]  - attr(*, "already-done")= logi TRUE
[09:32:18.797] - copied ‘kk’ to environment
[09:32:18.797] assign_globals() ... done
[09:32:18.797] plan(): Setting new future strategy stack:
[09:32:18.797] List of future strategies:
[09:32:18.797] 1. sequential:
[09:32:18.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.797]    - tweaked: FALSE
[09:32:18.797]    - call: NULL
[09:32:18.798] plan(): nbrOfWorkers() = 1
[09:32:18.898] plan(): Setting new future strategy stack:
[09:32:18.899] List of future strategies:
[09:32:18.899] 1. sequential:
[09:32:18.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.899]    - tweaked: FALSE
[09:32:18.899]    - call: plan(strategy)
[09:32:18.899] plan(): nbrOfWorkers() = 1
[09:32:18.899] SequentialFuture started (and completed)
[09:32:18.899] - Launch lazy future ... done
[09:32:18.899] run() for ‘SequentialFuture’ ... done
[09:32:18.899] resolved() for ‘SequentialFuture’ ...
[09:32:18.900] - state: ‘finished’
[09:32:18.900] - run: TRUE
[09:32:18.900] - result: ‘FutureResult’
[09:32:18.900] resolved() for ‘SequentialFuture’ ... done
[09:32:18.900] Future #2
[09:32:18.900]  length: 1 (resolved future 2)
[09:32:18.900] run() for ‘Future’ ...
[09:32:18.900] - state: ‘created’
[09:32:18.900] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:18.901] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:18.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:18.901]   - Field: ‘label’
[09:32:18.901]   - Field: ‘local’
[09:32:18.901]   - Field: ‘owner’
[09:32:18.901]   - Field: ‘envir’
[09:32:18.901]   - Field: ‘packages’
[09:32:18.901]   - Field: ‘gc’
[09:32:18.901]   - Field: ‘conditions’
[09:32:18.902]   - Field: ‘expr’
[09:32:18.902]   - Field: ‘uuid’
[09:32:18.902]   - Field: ‘seed’
[09:32:18.902]   - Field: ‘version’
[09:32:18.902]   - Field: ‘result’
[09:32:18.902]   - Field: ‘asynchronous’
[09:32:18.902]   - Field: ‘calls’
[09:32:18.902]   - Field: ‘globals’
[09:32:18.902]   - Field: ‘stdout’
[09:32:18.902]   - Field: ‘earlySignal’
[09:32:18.902]   - Field: ‘lazy’
[09:32:18.902]   - Field: ‘state’
[09:32:18.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:18.903] - Launch lazy future ...
[09:32:18.903] Packages needed by the future expression (n = 0): <none>
[09:32:18.903] Packages needed by future strategies (n = 0): <none>
[09:32:18.903] {
[09:32:18.903]     {
[09:32:18.903]         {
[09:32:18.903]             ...future.startTime <- base::Sys.time()
[09:32:18.903]             {
[09:32:18.903]                 {
[09:32:18.903]                   {
[09:32:18.903]                     base::local({
[09:32:18.903]                       has_future <- base::requireNamespace("future", 
[09:32:18.903]                         quietly = TRUE)
[09:32:18.903]                       if (has_future) {
[09:32:18.903]                         ns <- base::getNamespace("future")
[09:32:18.903]                         version <- ns[[".package"]][["version"]]
[09:32:18.903]                         if (is.null(version)) 
[09:32:18.903]                           version <- utils::packageVersion("future")
[09:32:18.903]                       }
[09:32:18.903]                       else {
[09:32:18.903]                         version <- NULL
[09:32:18.903]                       }
[09:32:18.903]                       if (!has_future || version < "1.8.0") {
[09:32:18.903]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:18.903]                           "", base::R.version$version.string), 
[09:32:18.903]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:18.903]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:18.903]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:18.903]                             "release", "version")], collapse = " "), 
[09:32:18.903]                           hostname = base::Sys.info()[["nodename"]])
[09:32:18.903]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:18.903]                           info)
[09:32:18.903]                         info <- base::paste(info, collapse = "; ")
[09:32:18.903]                         if (!has_future) {
[09:32:18.903]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:18.903]                             info)
[09:32:18.903]                         }
[09:32:18.903]                         else {
[09:32:18.903]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:18.903]                             info, version)
[09:32:18.903]                         }
[09:32:18.903]                         base::stop(msg)
[09:32:18.903]                       }
[09:32:18.903]                     })
[09:32:18.903]                   }
[09:32:18.903]                   ...future.strategy.old <- future::plan("list")
[09:32:18.903]                   options(future.plan = NULL)
[09:32:18.903]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.903]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:18.903]                 }
[09:32:18.903]                 ...future.workdir <- getwd()
[09:32:18.903]             }
[09:32:18.903]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:18.903]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:18.903]         }
[09:32:18.903]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:18.903]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:18.903]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:18.903]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:18.903]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:18.903]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:18.903]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:18.903]             base::names(...future.oldOptions))
[09:32:18.903]     }
[09:32:18.903]     if (FALSE) {
[09:32:18.903]     }
[09:32:18.903]     else {
[09:32:18.903]         if (TRUE) {
[09:32:18.903]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:18.903]                 open = "w")
[09:32:18.903]         }
[09:32:18.903]         else {
[09:32:18.903]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:18.903]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:18.903]         }
[09:32:18.903]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:18.903]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:18.903]             base::sink(type = "output", split = FALSE)
[09:32:18.903]             base::close(...future.stdout)
[09:32:18.903]         }, add = TRUE)
[09:32:18.903]     }
[09:32:18.903]     ...future.frame <- base::sys.nframe()
[09:32:18.903]     ...future.conditions <- base::list()
[09:32:18.903]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:18.903]     if (FALSE) {
[09:32:18.903]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:18.903]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:18.903]     }
[09:32:18.903]     ...future.result <- base::tryCatch({
[09:32:18.903]         base::withCallingHandlers({
[09:32:18.903]             ...future.value <- base::withVisible(base::local({
[09:32:18.903]                 Sys.sleep(0.1)
[09:32:18.903]                 kk
[09:32:18.903]             }))
[09:32:18.903]             future::FutureResult(value = ...future.value$value, 
[09:32:18.903]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.903]                   ...future.rng), globalenv = if (FALSE) 
[09:32:18.903]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:18.903]                     ...future.globalenv.names))
[09:32:18.903]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:18.903]         }, condition = base::local({
[09:32:18.903]             c <- base::c
[09:32:18.903]             inherits <- base::inherits
[09:32:18.903]             invokeRestart <- base::invokeRestart
[09:32:18.903]             length <- base::length
[09:32:18.903]             list <- base::list
[09:32:18.903]             seq.int <- base::seq.int
[09:32:18.903]             signalCondition <- base::signalCondition
[09:32:18.903]             sys.calls <- base::sys.calls
[09:32:18.903]             `[[` <- base::`[[`
[09:32:18.903]             `+` <- base::`+`
[09:32:18.903]             `<<-` <- base::`<<-`
[09:32:18.903]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:18.903]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:18.903]                   3L)]
[09:32:18.903]             }
[09:32:18.903]             function(cond) {
[09:32:18.903]                 is_error <- inherits(cond, "error")
[09:32:18.903]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:18.903]                   NULL)
[09:32:18.903]                 if (is_error) {
[09:32:18.903]                   sessionInformation <- function() {
[09:32:18.903]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:18.903]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:18.903]                       search = base::search(), system = base::Sys.info())
[09:32:18.903]                   }
[09:32:18.903]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.903]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:18.903]                     cond$call), session = sessionInformation(), 
[09:32:18.903]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:18.903]                   signalCondition(cond)
[09:32:18.903]                 }
[09:32:18.903]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:18.903]                 "immediateCondition"))) {
[09:32:18.903]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:18.903]                   ...future.conditions[[length(...future.conditions) + 
[09:32:18.903]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:18.903]                   if (TRUE && !signal) {
[09:32:18.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.903]                     {
[09:32:18.903]                       inherits <- base::inherits
[09:32:18.903]                       invokeRestart <- base::invokeRestart
[09:32:18.903]                       is.null <- base::is.null
[09:32:18.903]                       muffled <- FALSE
[09:32:18.903]                       if (inherits(cond, "message")) {
[09:32:18.903]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.903]                         if (muffled) 
[09:32:18.903]                           invokeRestart("muffleMessage")
[09:32:18.903]                       }
[09:32:18.903]                       else if (inherits(cond, "warning")) {
[09:32:18.903]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.903]                         if (muffled) 
[09:32:18.903]                           invokeRestart("muffleWarning")
[09:32:18.903]                       }
[09:32:18.903]                       else if (inherits(cond, "condition")) {
[09:32:18.903]                         if (!is.null(pattern)) {
[09:32:18.903]                           computeRestarts <- base::computeRestarts
[09:32:18.903]                           grepl <- base::grepl
[09:32:18.903]                           restarts <- computeRestarts(cond)
[09:32:18.903]                           for (restart in restarts) {
[09:32:18.903]                             name <- restart$name
[09:32:18.903]                             if (is.null(name)) 
[09:32:18.903]                               next
[09:32:18.903]                             if (!grepl(pattern, name)) 
[09:32:18.903]                               next
[09:32:18.903]                             invokeRestart(restart)
[09:32:18.903]                             muffled <- TRUE
[09:32:18.903]                             break
[09:32:18.903]                           }
[09:32:18.903]                         }
[09:32:18.903]                       }
[09:32:18.903]                       invisible(muffled)
[09:32:18.903]                     }
[09:32:18.903]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.903]                   }
[09:32:18.903]                 }
[09:32:18.903]                 else {
[09:32:18.903]                   if (TRUE) {
[09:32:18.903]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:18.903]                     {
[09:32:18.903]                       inherits <- base::inherits
[09:32:18.903]                       invokeRestart <- base::invokeRestart
[09:32:18.903]                       is.null <- base::is.null
[09:32:18.903]                       muffled <- FALSE
[09:32:18.903]                       if (inherits(cond, "message")) {
[09:32:18.903]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:18.903]                         if (muffled) 
[09:32:18.903]                           invokeRestart("muffleMessage")
[09:32:18.903]                       }
[09:32:18.903]                       else if (inherits(cond, "warning")) {
[09:32:18.903]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:18.903]                         if (muffled) 
[09:32:18.903]                           invokeRestart("muffleWarning")
[09:32:18.903]                       }
[09:32:18.903]                       else if (inherits(cond, "condition")) {
[09:32:18.903]                         if (!is.null(pattern)) {
[09:32:18.903]                           computeRestarts <- base::computeRestarts
[09:32:18.903]                           grepl <- base::grepl
[09:32:18.903]                           restarts <- computeRestarts(cond)
[09:32:18.903]                           for (restart in restarts) {
[09:32:18.903]                             name <- restart$name
[09:32:18.903]                             if (is.null(name)) 
[09:32:18.903]                               next
[09:32:18.903]                             if (!grepl(pattern, name)) 
[09:32:18.903]                               next
[09:32:18.903]                             invokeRestart(restart)
[09:32:18.903]                             muffled <- TRUE
[09:32:18.903]                             break
[09:32:18.903]                           }
[09:32:18.903]                         }
[09:32:18.903]                       }
[09:32:18.903]                       invisible(muffled)
[09:32:18.903]                     }
[09:32:18.903]                     muffleCondition(cond, pattern = "^muffle")
[09:32:18.903]                   }
[09:32:18.903]                 }
[09:32:18.903]             }
[09:32:18.903]         }))
[09:32:18.903]     }, error = function(ex) {
[09:32:18.903]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:18.903]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:18.903]                 ...future.rng), started = ...future.startTime, 
[09:32:18.903]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:18.903]             version = "1.8"), class = "FutureResult")
[09:32:18.903]     }, finally = {
[09:32:18.903]         if (!identical(...future.workdir, getwd())) 
[09:32:18.903]             setwd(...future.workdir)
[09:32:18.903]         {
[09:32:18.903]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:18.903]                 ...future.oldOptions$nwarnings <- NULL
[09:32:18.903]             }
[09:32:18.903]             base::options(...future.oldOptions)
[09:32:18.903]             if (.Platform$OS.type == "windows") {
[09:32:18.903]                 old_names <- names(...future.oldEnvVars)
[09:32:18.903]                 envs <- base::Sys.getenv()
[09:32:18.903]                 names <- names(envs)
[09:32:18.903]                 common <- intersect(names, old_names)
[09:32:18.903]                 added <- setdiff(names, old_names)
[09:32:18.903]                 removed <- setdiff(old_names, names)
[09:32:18.903]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:18.903]                   envs[common]]
[09:32:18.903]                 NAMES <- toupper(changed)
[09:32:18.903]                 args <- list()
[09:32:18.903]                 for (kk in seq_along(NAMES)) {
[09:32:18.903]                   name <- changed[[kk]]
[09:32:18.903]                   NAME <- NAMES[[kk]]
[09:32:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.903]                     next
[09:32:18.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.903]                 }
[09:32:18.903]                 NAMES <- toupper(added)
[09:32:18.903]                 for (kk in seq_along(NAMES)) {
[09:32:18.903]                   name <- added[[kk]]
[09:32:18.903]                   NAME <- NAMES[[kk]]
[09:32:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.903]                     next
[09:32:18.903]                   args[[name]] <- ""
[09:32:18.903]                 }
[09:32:18.903]                 NAMES <- toupper(removed)
[09:32:18.903]                 for (kk in seq_along(NAMES)) {
[09:32:18.903]                   name <- removed[[kk]]
[09:32:18.903]                   NAME <- NAMES[[kk]]
[09:32:18.903]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:18.903]                     next
[09:32:18.903]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:18.903]                 }
[09:32:18.903]                 if (length(args) > 0) 
[09:32:18.903]                   base::do.call(base::Sys.setenv, args = args)
[09:32:18.903]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:18.903]             }
[09:32:18.903]             else {
[09:32:18.903]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:18.903]             }
[09:32:18.903]             {
[09:32:18.903]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:18.903]                   0L) {
[09:32:18.903]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:18.903]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:18.903]                   base::options(opts)
[09:32:18.903]                 }
[09:32:18.903]                 {
[09:32:18.903]                   {
[09:32:18.903]                     NULL
[09:32:18.903]                     RNGkind("Mersenne-Twister")
[09:32:18.903]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:18.903]                       inherits = FALSE)
[09:32:18.903]                   }
[09:32:18.903]                   options(future.plan = NULL)
[09:32:18.903]                   if (is.na(NA_character_)) 
[09:32:18.903]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:18.903]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:18.903]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:18.903]                     .init = FALSE)
[09:32:18.903]                 }
[09:32:18.903]             }
[09:32:18.903]         }
[09:32:18.903]     })
[09:32:18.903]     if (TRUE) {
[09:32:18.903]         base::sink(type = "output", split = FALSE)
[09:32:18.903]         if (TRUE) {
[09:32:18.903]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:18.903]         }
[09:32:18.903]         else {
[09:32:18.903]             ...future.result["stdout"] <- base::list(NULL)
[09:32:18.903]         }
[09:32:18.903]         base::close(...future.stdout)
[09:32:18.903]         ...future.stdout <- NULL
[09:32:18.903]     }
[09:32:18.903]     ...future.result$conditions <- ...future.conditions
[09:32:18.903]     ...future.result$finished <- base::Sys.time()
[09:32:18.903]     ...future.result
[09:32:18.903] }
[09:32:18.905] assign_globals() ...
[09:32:18.905] List of 1
[09:32:18.905]  $ kk: int 3
[09:32:18.905]  - attr(*, "where")=List of 1
[09:32:18.905]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:18.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:18.905]  - attr(*, "resolved")= logi FALSE
[09:32:18.905]  - attr(*, "total_size")= num 56
[09:32:18.905]  - attr(*, "already-done")= logi TRUE
[09:32:18.907] - copied ‘kk’ to environment
[09:32:18.907] assign_globals() ... done
[09:32:18.908] plan(): Setting new future strategy stack:
[09:32:18.908] List of future strategies:
[09:32:18.908] 1. sequential:
[09:32:18.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:18.908]    - tweaked: FALSE
[09:32:18.908]    - call: NULL
[09:32:18.908] plan(): nbrOfWorkers() = 1
[09:32:19.009] plan(): Setting new future strategy stack:
[09:32:19.010] List of future strategies:
[09:32:19.010] 1. sequential:
[09:32:19.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.010]    - tweaked: FALSE
[09:32:19.010]    - call: plan(strategy)
[09:32:19.010] plan(): nbrOfWorkers() = 1
[09:32:19.010] SequentialFuture started (and completed)
[09:32:19.010] - Launch lazy future ... done
[09:32:19.011] run() for ‘SequentialFuture’ ... done
[09:32:19.011] resolved() for ‘SequentialFuture’ ...
[09:32:19.011] - state: ‘finished’
[09:32:19.011] - run: TRUE
[09:32:19.011] - result: ‘FutureResult’
[09:32:19.011] resolved() for ‘SequentialFuture’ ... done
[09:32:19.011] Future #3
[09:32:19.011]  length: 0 (resolved future 3)
[09:32:19.011] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[09:32:19.012] resolve() on environment ...
[09:32:19.012]  recursive: 0
[09:32:19.013]  elements: [2] ‘a’, ‘b’
[09:32:19.013]  length: 1 (resolved future 1)
[09:32:19.014]  length: 0 (resolved future 2)
[09:32:19.014] resolve() on environment ... DONE
[09:32:19.014] getGlobalsAndPackages() ...
[09:32:19.014] Searching for globals...
[09:32:19.014] 
[09:32:19.015] Searching for globals ... DONE
[09:32:19.015] - globals: [0] <none>
[09:32:19.015] getGlobalsAndPackages() ... DONE
[09:32:19.015] run() for ‘Future’ ...
[09:32:19.015] - state: ‘created’
[09:32:19.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.016]   - Field: ‘label’
[09:32:19.016]   - Field: ‘local’
[09:32:19.016]   - Field: ‘owner’
[09:32:19.016]   - Field: ‘envir’
[09:32:19.016]   - Field: ‘packages’
[09:32:19.016]   - Field: ‘gc’
[09:32:19.016]   - Field: ‘conditions’
[09:32:19.016]   - Field: ‘expr’
[09:32:19.016]   - Field: ‘uuid’
[09:32:19.017]   - Field: ‘seed’
[09:32:19.017]   - Field: ‘version’
[09:32:19.017]   - Field: ‘result’
[09:32:19.017]   - Field: ‘asynchronous’
[09:32:19.017]   - Field: ‘calls’
[09:32:19.017]   - Field: ‘globals’
[09:32:19.017]   - Field: ‘stdout’
[09:32:19.017]   - Field: ‘earlySignal’
[09:32:19.017]   - Field: ‘lazy’
[09:32:19.017]   - Field: ‘state’
[09:32:19.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.018] - Launch lazy future ...
[09:32:19.018] Packages needed by the future expression (n = 0): <none>
[09:32:19.018] Packages needed by future strategies (n = 0): <none>
[09:32:19.018] {
[09:32:19.018]     {
[09:32:19.018]         {
[09:32:19.018]             ...future.startTime <- base::Sys.time()
[09:32:19.018]             {
[09:32:19.018]                 {
[09:32:19.018]                   {
[09:32:19.018]                     base::local({
[09:32:19.018]                       has_future <- base::requireNamespace("future", 
[09:32:19.018]                         quietly = TRUE)
[09:32:19.018]                       if (has_future) {
[09:32:19.018]                         ns <- base::getNamespace("future")
[09:32:19.018]                         version <- ns[[".package"]][["version"]]
[09:32:19.018]                         if (is.null(version)) 
[09:32:19.018]                           version <- utils::packageVersion("future")
[09:32:19.018]                       }
[09:32:19.018]                       else {
[09:32:19.018]                         version <- NULL
[09:32:19.018]                       }
[09:32:19.018]                       if (!has_future || version < "1.8.0") {
[09:32:19.018]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.018]                           "", base::R.version$version.string), 
[09:32:19.018]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.018]                             "release", "version")], collapse = " "), 
[09:32:19.018]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.018]                           info)
[09:32:19.018]                         info <- base::paste(info, collapse = "; ")
[09:32:19.018]                         if (!has_future) {
[09:32:19.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.018]                             info)
[09:32:19.018]                         }
[09:32:19.018]                         else {
[09:32:19.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.018]                             info, version)
[09:32:19.018]                         }
[09:32:19.018]                         base::stop(msg)
[09:32:19.018]                       }
[09:32:19.018]                     })
[09:32:19.018]                   }
[09:32:19.018]                   ...future.strategy.old <- future::plan("list")
[09:32:19.018]                   options(future.plan = NULL)
[09:32:19.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.018]                 }
[09:32:19.018]                 ...future.workdir <- getwd()
[09:32:19.018]             }
[09:32:19.018]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.018]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.018]         }
[09:32:19.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.018]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.018]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.018]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.018]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.018]             base::names(...future.oldOptions))
[09:32:19.018]     }
[09:32:19.018]     if (FALSE) {
[09:32:19.018]     }
[09:32:19.018]     else {
[09:32:19.018]         if (TRUE) {
[09:32:19.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.018]                 open = "w")
[09:32:19.018]         }
[09:32:19.018]         else {
[09:32:19.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.018]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.018]         }
[09:32:19.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.018]             base::sink(type = "output", split = FALSE)
[09:32:19.018]             base::close(...future.stdout)
[09:32:19.018]         }, add = TRUE)
[09:32:19.018]     }
[09:32:19.018]     ...future.frame <- base::sys.nframe()
[09:32:19.018]     ...future.conditions <- base::list()
[09:32:19.018]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.018]     if (FALSE) {
[09:32:19.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.018]     }
[09:32:19.018]     ...future.result <- base::tryCatch({
[09:32:19.018]         base::withCallingHandlers({
[09:32:19.018]             ...future.value <- base::withVisible(base::local(1))
[09:32:19.018]             future::FutureResult(value = ...future.value$value, 
[09:32:19.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.018]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.018]                     ...future.globalenv.names))
[09:32:19.018]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.018]         }, condition = base::local({
[09:32:19.018]             c <- base::c
[09:32:19.018]             inherits <- base::inherits
[09:32:19.018]             invokeRestart <- base::invokeRestart
[09:32:19.018]             length <- base::length
[09:32:19.018]             list <- base::list
[09:32:19.018]             seq.int <- base::seq.int
[09:32:19.018]             signalCondition <- base::signalCondition
[09:32:19.018]             sys.calls <- base::sys.calls
[09:32:19.018]             `[[` <- base::`[[`
[09:32:19.018]             `+` <- base::`+`
[09:32:19.018]             `<<-` <- base::`<<-`
[09:32:19.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.018]                   3L)]
[09:32:19.018]             }
[09:32:19.018]             function(cond) {
[09:32:19.018]                 is_error <- inherits(cond, "error")
[09:32:19.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.018]                   NULL)
[09:32:19.018]                 if (is_error) {
[09:32:19.018]                   sessionInformation <- function() {
[09:32:19.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.018]                       search = base::search(), system = base::Sys.info())
[09:32:19.018]                   }
[09:32:19.018]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.018]                     cond$call), session = sessionInformation(), 
[09:32:19.018]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.018]                   signalCondition(cond)
[09:32:19.018]                 }
[09:32:19.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.018]                 "immediateCondition"))) {
[09:32:19.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.018]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.018]                   if (TRUE && !signal) {
[09:32:19.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.018]                     {
[09:32:19.018]                       inherits <- base::inherits
[09:32:19.018]                       invokeRestart <- base::invokeRestart
[09:32:19.018]                       is.null <- base::is.null
[09:32:19.018]                       muffled <- FALSE
[09:32:19.018]                       if (inherits(cond, "message")) {
[09:32:19.018]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.018]                         if (muffled) 
[09:32:19.018]                           invokeRestart("muffleMessage")
[09:32:19.018]                       }
[09:32:19.018]                       else if (inherits(cond, "warning")) {
[09:32:19.018]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.018]                         if (muffled) 
[09:32:19.018]                           invokeRestart("muffleWarning")
[09:32:19.018]                       }
[09:32:19.018]                       else if (inherits(cond, "condition")) {
[09:32:19.018]                         if (!is.null(pattern)) {
[09:32:19.018]                           computeRestarts <- base::computeRestarts
[09:32:19.018]                           grepl <- base::grepl
[09:32:19.018]                           restarts <- computeRestarts(cond)
[09:32:19.018]                           for (restart in restarts) {
[09:32:19.018]                             name <- restart$name
[09:32:19.018]                             if (is.null(name)) 
[09:32:19.018]                               next
[09:32:19.018]                             if (!grepl(pattern, name)) 
[09:32:19.018]                               next
[09:32:19.018]                             invokeRestart(restart)
[09:32:19.018]                             muffled <- TRUE
[09:32:19.018]                             break
[09:32:19.018]                           }
[09:32:19.018]                         }
[09:32:19.018]                       }
[09:32:19.018]                       invisible(muffled)
[09:32:19.018]                     }
[09:32:19.018]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.018]                   }
[09:32:19.018]                 }
[09:32:19.018]                 else {
[09:32:19.018]                   if (TRUE) {
[09:32:19.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.018]                     {
[09:32:19.018]                       inherits <- base::inherits
[09:32:19.018]                       invokeRestart <- base::invokeRestart
[09:32:19.018]                       is.null <- base::is.null
[09:32:19.018]                       muffled <- FALSE
[09:32:19.018]                       if (inherits(cond, "message")) {
[09:32:19.018]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.018]                         if (muffled) 
[09:32:19.018]                           invokeRestart("muffleMessage")
[09:32:19.018]                       }
[09:32:19.018]                       else if (inherits(cond, "warning")) {
[09:32:19.018]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.018]                         if (muffled) 
[09:32:19.018]                           invokeRestart("muffleWarning")
[09:32:19.018]                       }
[09:32:19.018]                       else if (inherits(cond, "condition")) {
[09:32:19.018]                         if (!is.null(pattern)) {
[09:32:19.018]                           computeRestarts <- base::computeRestarts
[09:32:19.018]                           grepl <- base::grepl
[09:32:19.018]                           restarts <- computeRestarts(cond)
[09:32:19.018]                           for (restart in restarts) {
[09:32:19.018]                             name <- restart$name
[09:32:19.018]                             if (is.null(name)) 
[09:32:19.018]                               next
[09:32:19.018]                             if (!grepl(pattern, name)) 
[09:32:19.018]                               next
[09:32:19.018]                             invokeRestart(restart)
[09:32:19.018]                             muffled <- TRUE
[09:32:19.018]                             break
[09:32:19.018]                           }
[09:32:19.018]                         }
[09:32:19.018]                       }
[09:32:19.018]                       invisible(muffled)
[09:32:19.018]                     }
[09:32:19.018]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.018]                   }
[09:32:19.018]                 }
[09:32:19.018]             }
[09:32:19.018]         }))
[09:32:19.018]     }, error = function(ex) {
[09:32:19.018]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.018]                 ...future.rng), started = ...future.startTime, 
[09:32:19.018]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.018]             version = "1.8"), class = "FutureResult")
[09:32:19.018]     }, finally = {
[09:32:19.018]         if (!identical(...future.workdir, getwd())) 
[09:32:19.018]             setwd(...future.workdir)
[09:32:19.018]         {
[09:32:19.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.018]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.018]             }
[09:32:19.018]             base::options(...future.oldOptions)
[09:32:19.018]             if (.Platform$OS.type == "windows") {
[09:32:19.018]                 old_names <- names(...future.oldEnvVars)
[09:32:19.018]                 envs <- base::Sys.getenv()
[09:32:19.018]                 names <- names(envs)
[09:32:19.018]                 common <- intersect(names, old_names)
[09:32:19.018]                 added <- setdiff(names, old_names)
[09:32:19.018]                 removed <- setdiff(old_names, names)
[09:32:19.018]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.018]                   envs[common]]
[09:32:19.018]                 NAMES <- toupper(changed)
[09:32:19.018]                 args <- list()
[09:32:19.018]                 for (kk in seq_along(NAMES)) {
[09:32:19.018]                   name <- changed[[kk]]
[09:32:19.018]                   NAME <- NAMES[[kk]]
[09:32:19.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.018]                     next
[09:32:19.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.018]                 }
[09:32:19.018]                 NAMES <- toupper(added)
[09:32:19.018]                 for (kk in seq_along(NAMES)) {
[09:32:19.018]                   name <- added[[kk]]
[09:32:19.018]                   NAME <- NAMES[[kk]]
[09:32:19.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.018]                     next
[09:32:19.018]                   args[[name]] <- ""
[09:32:19.018]                 }
[09:32:19.018]                 NAMES <- toupper(removed)
[09:32:19.018]                 for (kk in seq_along(NAMES)) {
[09:32:19.018]                   name <- removed[[kk]]
[09:32:19.018]                   NAME <- NAMES[[kk]]
[09:32:19.018]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.018]                     next
[09:32:19.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.018]                 }
[09:32:19.018]                 if (length(args) > 0) 
[09:32:19.018]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.018]             }
[09:32:19.018]             else {
[09:32:19.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.018]             }
[09:32:19.018]             {
[09:32:19.018]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.018]                   0L) {
[09:32:19.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.018]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.018]                   base::options(opts)
[09:32:19.018]                 }
[09:32:19.018]                 {
[09:32:19.018]                   {
[09:32:19.018]                     NULL
[09:32:19.018]                     RNGkind("Mersenne-Twister")
[09:32:19.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.018]                       inherits = FALSE)
[09:32:19.018]                   }
[09:32:19.018]                   options(future.plan = NULL)
[09:32:19.018]                   if (is.na(NA_character_)) 
[09:32:19.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.018]                     .init = FALSE)
[09:32:19.018]                 }
[09:32:19.018]             }
[09:32:19.018]         }
[09:32:19.018]     })
[09:32:19.018]     if (TRUE) {
[09:32:19.018]         base::sink(type = "output", split = FALSE)
[09:32:19.018]         if (TRUE) {
[09:32:19.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.018]         }
[09:32:19.018]         else {
[09:32:19.018]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.018]         }
[09:32:19.018]         base::close(...future.stdout)
[09:32:19.018]         ...future.stdout <- NULL
[09:32:19.018]     }
[09:32:19.018]     ...future.result$conditions <- ...future.conditions
[09:32:19.018]     ...future.result$finished <- base::Sys.time()
[09:32:19.018]     ...future.result
[09:32:19.018] }
[09:32:19.020] plan(): Setting new future strategy stack:
[09:32:19.020] List of future strategies:
[09:32:19.020] 1. sequential:
[09:32:19.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.020]    - tweaked: FALSE
[09:32:19.020]    - call: NULL
[09:32:19.021] plan(): nbrOfWorkers() = 1
[09:32:19.021] plan(): Setting new future strategy stack:
[09:32:19.021] List of future strategies:
[09:32:19.021] 1. sequential:
[09:32:19.021]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.021]    - tweaked: FALSE
[09:32:19.021]    - call: plan(strategy)
[09:32:19.022] plan(): nbrOfWorkers() = 1
[09:32:19.022] SequentialFuture started (and completed)
[09:32:19.022] - Launch lazy future ... done
[09:32:19.022] run() for ‘SequentialFuture’ ... done
[09:32:19.022] getGlobalsAndPackages() ...
[09:32:19.022] Searching for globals...
[09:32:19.023] 
[09:32:19.023] Searching for globals ... DONE
[09:32:19.023] - globals: [0] <none>
[09:32:19.023] getGlobalsAndPackages() ... DONE
[09:32:19.023] run() for ‘Future’ ...
[09:32:19.023] - state: ‘created’
[09:32:19.023] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.024] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.024]   - Field: ‘label’
[09:32:19.024]   - Field: ‘local’
[09:32:19.026]   - Field: ‘owner’
[09:32:19.026]   - Field: ‘envir’
[09:32:19.026]   - Field: ‘packages’
[09:32:19.026]   - Field: ‘gc’
[09:32:19.026]   - Field: ‘conditions’
[09:32:19.026]   - Field: ‘expr’
[09:32:19.026]   - Field: ‘uuid’
[09:32:19.026]   - Field: ‘seed’
[09:32:19.026]   - Field: ‘version’
[09:32:19.027]   - Field: ‘result’
[09:32:19.027]   - Field: ‘asynchronous’
[09:32:19.027]   - Field: ‘calls’
[09:32:19.027]   - Field: ‘globals’
[09:32:19.027]   - Field: ‘stdout’
[09:32:19.027]   - Field: ‘earlySignal’
[09:32:19.027]   - Field: ‘lazy’
[09:32:19.027]   - Field: ‘state’
[09:32:19.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.027] - Launch lazy future ...
[09:32:19.027] Packages needed by the future expression (n = 0): <none>
[09:32:19.028] Packages needed by future strategies (n = 0): <none>
[09:32:19.028] {
[09:32:19.028]     {
[09:32:19.028]         {
[09:32:19.028]             ...future.startTime <- base::Sys.time()
[09:32:19.028]             {
[09:32:19.028]                 {
[09:32:19.028]                   {
[09:32:19.028]                     base::local({
[09:32:19.028]                       has_future <- base::requireNamespace("future", 
[09:32:19.028]                         quietly = TRUE)
[09:32:19.028]                       if (has_future) {
[09:32:19.028]                         ns <- base::getNamespace("future")
[09:32:19.028]                         version <- ns[[".package"]][["version"]]
[09:32:19.028]                         if (is.null(version)) 
[09:32:19.028]                           version <- utils::packageVersion("future")
[09:32:19.028]                       }
[09:32:19.028]                       else {
[09:32:19.028]                         version <- NULL
[09:32:19.028]                       }
[09:32:19.028]                       if (!has_future || version < "1.8.0") {
[09:32:19.028]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.028]                           "", base::R.version$version.string), 
[09:32:19.028]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.028]                             "release", "version")], collapse = " "), 
[09:32:19.028]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.028]                           info)
[09:32:19.028]                         info <- base::paste(info, collapse = "; ")
[09:32:19.028]                         if (!has_future) {
[09:32:19.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.028]                             info)
[09:32:19.028]                         }
[09:32:19.028]                         else {
[09:32:19.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.028]                             info, version)
[09:32:19.028]                         }
[09:32:19.028]                         base::stop(msg)
[09:32:19.028]                       }
[09:32:19.028]                     })
[09:32:19.028]                   }
[09:32:19.028]                   ...future.strategy.old <- future::plan("list")
[09:32:19.028]                   options(future.plan = NULL)
[09:32:19.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.028]                 }
[09:32:19.028]                 ...future.workdir <- getwd()
[09:32:19.028]             }
[09:32:19.028]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.028]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.028]         }
[09:32:19.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.028]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.028]             base::names(...future.oldOptions))
[09:32:19.028]     }
[09:32:19.028]     if (FALSE) {
[09:32:19.028]     }
[09:32:19.028]     else {
[09:32:19.028]         if (TRUE) {
[09:32:19.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.028]                 open = "w")
[09:32:19.028]         }
[09:32:19.028]         else {
[09:32:19.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.028]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.028]         }
[09:32:19.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.028]             base::sink(type = "output", split = FALSE)
[09:32:19.028]             base::close(...future.stdout)
[09:32:19.028]         }, add = TRUE)
[09:32:19.028]     }
[09:32:19.028]     ...future.frame <- base::sys.nframe()
[09:32:19.028]     ...future.conditions <- base::list()
[09:32:19.028]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.028]     if (FALSE) {
[09:32:19.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.028]     }
[09:32:19.028]     ...future.result <- base::tryCatch({
[09:32:19.028]         base::withCallingHandlers({
[09:32:19.028]             ...future.value <- base::withVisible(base::local(2))
[09:32:19.028]             future::FutureResult(value = ...future.value$value, 
[09:32:19.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.028]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.028]                     ...future.globalenv.names))
[09:32:19.028]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.028]         }, condition = base::local({
[09:32:19.028]             c <- base::c
[09:32:19.028]             inherits <- base::inherits
[09:32:19.028]             invokeRestart <- base::invokeRestart
[09:32:19.028]             length <- base::length
[09:32:19.028]             list <- base::list
[09:32:19.028]             seq.int <- base::seq.int
[09:32:19.028]             signalCondition <- base::signalCondition
[09:32:19.028]             sys.calls <- base::sys.calls
[09:32:19.028]             `[[` <- base::`[[`
[09:32:19.028]             `+` <- base::`+`
[09:32:19.028]             `<<-` <- base::`<<-`
[09:32:19.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.028]                   3L)]
[09:32:19.028]             }
[09:32:19.028]             function(cond) {
[09:32:19.028]                 is_error <- inherits(cond, "error")
[09:32:19.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.028]                   NULL)
[09:32:19.028]                 if (is_error) {
[09:32:19.028]                   sessionInformation <- function() {
[09:32:19.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.028]                       search = base::search(), system = base::Sys.info())
[09:32:19.028]                   }
[09:32:19.028]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.028]                     cond$call), session = sessionInformation(), 
[09:32:19.028]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.028]                   signalCondition(cond)
[09:32:19.028]                 }
[09:32:19.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.028]                 "immediateCondition"))) {
[09:32:19.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.028]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.028]                   if (TRUE && !signal) {
[09:32:19.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.028]                     {
[09:32:19.028]                       inherits <- base::inherits
[09:32:19.028]                       invokeRestart <- base::invokeRestart
[09:32:19.028]                       is.null <- base::is.null
[09:32:19.028]                       muffled <- FALSE
[09:32:19.028]                       if (inherits(cond, "message")) {
[09:32:19.028]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.028]                         if (muffled) 
[09:32:19.028]                           invokeRestart("muffleMessage")
[09:32:19.028]                       }
[09:32:19.028]                       else if (inherits(cond, "warning")) {
[09:32:19.028]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.028]                         if (muffled) 
[09:32:19.028]                           invokeRestart("muffleWarning")
[09:32:19.028]                       }
[09:32:19.028]                       else if (inherits(cond, "condition")) {
[09:32:19.028]                         if (!is.null(pattern)) {
[09:32:19.028]                           computeRestarts <- base::computeRestarts
[09:32:19.028]                           grepl <- base::grepl
[09:32:19.028]                           restarts <- computeRestarts(cond)
[09:32:19.028]                           for (restart in restarts) {
[09:32:19.028]                             name <- restart$name
[09:32:19.028]                             if (is.null(name)) 
[09:32:19.028]                               next
[09:32:19.028]                             if (!grepl(pattern, name)) 
[09:32:19.028]                               next
[09:32:19.028]                             invokeRestart(restart)
[09:32:19.028]                             muffled <- TRUE
[09:32:19.028]                             break
[09:32:19.028]                           }
[09:32:19.028]                         }
[09:32:19.028]                       }
[09:32:19.028]                       invisible(muffled)
[09:32:19.028]                     }
[09:32:19.028]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.028]                   }
[09:32:19.028]                 }
[09:32:19.028]                 else {
[09:32:19.028]                   if (TRUE) {
[09:32:19.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.028]                     {
[09:32:19.028]                       inherits <- base::inherits
[09:32:19.028]                       invokeRestart <- base::invokeRestart
[09:32:19.028]                       is.null <- base::is.null
[09:32:19.028]                       muffled <- FALSE
[09:32:19.028]                       if (inherits(cond, "message")) {
[09:32:19.028]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.028]                         if (muffled) 
[09:32:19.028]                           invokeRestart("muffleMessage")
[09:32:19.028]                       }
[09:32:19.028]                       else if (inherits(cond, "warning")) {
[09:32:19.028]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.028]                         if (muffled) 
[09:32:19.028]                           invokeRestart("muffleWarning")
[09:32:19.028]                       }
[09:32:19.028]                       else if (inherits(cond, "condition")) {
[09:32:19.028]                         if (!is.null(pattern)) {
[09:32:19.028]                           computeRestarts <- base::computeRestarts
[09:32:19.028]                           grepl <- base::grepl
[09:32:19.028]                           restarts <- computeRestarts(cond)
[09:32:19.028]                           for (restart in restarts) {
[09:32:19.028]                             name <- restart$name
[09:32:19.028]                             if (is.null(name)) 
[09:32:19.028]                               next
[09:32:19.028]                             if (!grepl(pattern, name)) 
[09:32:19.028]                               next
[09:32:19.028]                             invokeRestart(restart)
[09:32:19.028]                             muffled <- TRUE
[09:32:19.028]                             break
[09:32:19.028]                           }
[09:32:19.028]                         }
[09:32:19.028]                       }
[09:32:19.028]                       invisible(muffled)
[09:32:19.028]                     }
[09:32:19.028]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.028]                   }
[09:32:19.028]                 }
[09:32:19.028]             }
[09:32:19.028]         }))
[09:32:19.028]     }, error = function(ex) {
[09:32:19.028]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.028]                 ...future.rng), started = ...future.startTime, 
[09:32:19.028]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.028]             version = "1.8"), class = "FutureResult")
[09:32:19.028]     }, finally = {
[09:32:19.028]         if (!identical(...future.workdir, getwd())) 
[09:32:19.028]             setwd(...future.workdir)
[09:32:19.028]         {
[09:32:19.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.028]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.028]             }
[09:32:19.028]             base::options(...future.oldOptions)
[09:32:19.028]             if (.Platform$OS.type == "windows") {
[09:32:19.028]                 old_names <- names(...future.oldEnvVars)
[09:32:19.028]                 envs <- base::Sys.getenv()
[09:32:19.028]                 names <- names(envs)
[09:32:19.028]                 common <- intersect(names, old_names)
[09:32:19.028]                 added <- setdiff(names, old_names)
[09:32:19.028]                 removed <- setdiff(old_names, names)
[09:32:19.028]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.028]                   envs[common]]
[09:32:19.028]                 NAMES <- toupper(changed)
[09:32:19.028]                 args <- list()
[09:32:19.028]                 for (kk in seq_along(NAMES)) {
[09:32:19.028]                   name <- changed[[kk]]
[09:32:19.028]                   NAME <- NAMES[[kk]]
[09:32:19.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.028]                     next
[09:32:19.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.028]                 }
[09:32:19.028]                 NAMES <- toupper(added)
[09:32:19.028]                 for (kk in seq_along(NAMES)) {
[09:32:19.028]                   name <- added[[kk]]
[09:32:19.028]                   NAME <- NAMES[[kk]]
[09:32:19.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.028]                     next
[09:32:19.028]                   args[[name]] <- ""
[09:32:19.028]                 }
[09:32:19.028]                 NAMES <- toupper(removed)
[09:32:19.028]                 for (kk in seq_along(NAMES)) {
[09:32:19.028]                   name <- removed[[kk]]
[09:32:19.028]                   NAME <- NAMES[[kk]]
[09:32:19.028]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.028]                     next
[09:32:19.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.028]                 }
[09:32:19.028]                 if (length(args) > 0) 
[09:32:19.028]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.028]             }
[09:32:19.028]             else {
[09:32:19.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.028]             }
[09:32:19.028]             {
[09:32:19.028]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.028]                   0L) {
[09:32:19.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.028]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.028]                   base::options(opts)
[09:32:19.028]                 }
[09:32:19.028]                 {
[09:32:19.028]                   {
[09:32:19.028]                     NULL
[09:32:19.028]                     RNGkind("Mersenne-Twister")
[09:32:19.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.028]                       inherits = FALSE)
[09:32:19.028]                   }
[09:32:19.028]                   options(future.plan = NULL)
[09:32:19.028]                   if (is.na(NA_character_)) 
[09:32:19.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.028]                     .init = FALSE)
[09:32:19.028]                 }
[09:32:19.028]             }
[09:32:19.028]         }
[09:32:19.028]     })
[09:32:19.028]     if (TRUE) {
[09:32:19.028]         base::sink(type = "output", split = FALSE)
[09:32:19.028]         if (TRUE) {
[09:32:19.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.028]         }
[09:32:19.028]         else {
[09:32:19.028]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.028]         }
[09:32:19.028]         base::close(...future.stdout)
[09:32:19.028]         ...future.stdout <- NULL
[09:32:19.028]     }
[09:32:19.028]     ...future.result$conditions <- ...future.conditions
[09:32:19.028]     ...future.result$finished <- base::Sys.time()
[09:32:19.028]     ...future.result
[09:32:19.028] }
[09:32:19.030] plan(): Setting new future strategy stack:
[09:32:19.030] List of future strategies:
[09:32:19.030] 1. sequential:
[09:32:19.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.030]    - tweaked: FALSE
[09:32:19.030]    - call: NULL
[09:32:19.030] plan(): nbrOfWorkers() = 1
[09:32:19.031] plan(): Setting new future strategy stack:
[09:32:19.031] List of future strategies:
[09:32:19.031] 1. sequential:
[09:32:19.031]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.031]    - tweaked: FALSE
[09:32:19.031]    - call: plan(strategy)
[09:32:19.031] plan(): nbrOfWorkers() = 1
[09:32:19.032] SequentialFuture started (and completed)
[09:32:19.032] - Launch lazy future ... done
[09:32:19.032] run() for ‘SequentialFuture’ ... done
[09:32:19.032] resolve() on environment ...
[09:32:19.032]  recursive: 0
[09:32:19.033]  elements: [3] ‘a’, ‘b’, ‘c’
[09:32:19.033] resolved() for ‘SequentialFuture’ ...
[09:32:19.033] - state: ‘finished’
[09:32:19.033] - run: TRUE
[09:32:19.033] - result: ‘FutureResult’
[09:32:19.033] resolved() for ‘SequentialFuture’ ... done
[09:32:19.033] Future #1
[09:32:19.033]  length: 2 (resolved future 1)
[09:32:19.034] resolved() for ‘SequentialFuture’ ...
[09:32:19.034] - state: ‘finished’
[09:32:19.034] - run: TRUE
[09:32:19.034] - result: ‘FutureResult’
[09:32:19.034] resolved() for ‘SequentialFuture’ ... done
[09:32:19.034] Future #2
[09:32:19.034]  length: 1 (resolved future 2)
[09:32:19.034]  length: 0 (resolved future 3)
[09:32:19.034] resolve() on environment ... DONE
[09:32:19.034] resolved() for ‘SequentialFuture’ ...
[09:32:19.034] - state: ‘finished’
[09:32:19.035] - run: TRUE
[09:32:19.035] - result: ‘FutureResult’
[09:32:19.035] resolved() for ‘SequentialFuture’ ... done
[09:32:19.035] resolved() for ‘SequentialFuture’ ...
[09:32:19.035] - state: ‘finished’
[09:32:19.035] - run: TRUE
[09:32:19.035] - result: ‘FutureResult’
[09:32:19.035] resolved() for ‘SequentialFuture’ ... done
[09:32:19.036] getGlobalsAndPackages() ...
[09:32:19.036] Searching for globals...
[09:32:19.037] - globals found: [1] ‘{’
[09:32:19.037] Searching for globals ... DONE
[09:32:19.037] Resolving globals: FALSE
[09:32:19.037] 
[09:32:19.037] 
[09:32:19.037] getGlobalsAndPackages() ... DONE
[09:32:19.037] run() for ‘Future’ ...
[09:32:19.038] - state: ‘created’
[09:32:19.038] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.038]   - Field: ‘label’
[09:32:19.038]   - Field: ‘local’
[09:32:19.038]   - Field: ‘owner’
[09:32:19.038]   - Field: ‘envir’
[09:32:19.038]   - Field: ‘packages’
[09:32:19.039]   - Field: ‘gc’
[09:32:19.039]   - Field: ‘conditions’
[09:32:19.039]   - Field: ‘expr’
[09:32:19.039]   - Field: ‘uuid’
[09:32:19.039]   - Field: ‘seed’
[09:32:19.039]   - Field: ‘version’
[09:32:19.039]   - Field: ‘result’
[09:32:19.039]   - Field: ‘asynchronous’
[09:32:19.039]   - Field: ‘calls’
[09:32:19.039]   - Field: ‘globals’
[09:32:19.039]   - Field: ‘stdout’
[09:32:19.039]   - Field: ‘earlySignal’
[09:32:19.040]   - Field: ‘lazy’
[09:32:19.040]   - Field: ‘state’
[09:32:19.040] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.040] - Launch lazy future ...
[09:32:19.040] Packages needed by the future expression (n = 0): <none>
[09:32:19.040] Packages needed by future strategies (n = 0): <none>
[09:32:19.040] {
[09:32:19.040]     {
[09:32:19.040]         {
[09:32:19.040]             ...future.startTime <- base::Sys.time()
[09:32:19.040]             {
[09:32:19.040]                 {
[09:32:19.040]                   {
[09:32:19.040]                     base::local({
[09:32:19.040]                       has_future <- base::requireNamespace("future", 
[09:32:19.040]                         quietly = TRUE)
[09:32:19.040]                       if (has_future) {
[09:32:19.040]                         ns <- base::getNamespace("future")
[09:32:19.040]                         version <- ns[[".package"]][["version"]]
[09:32:19.040]                         if (is.null(version)) 
[09:32:19.040]                           version <- utils::packageVersion("future")
[09:32:19.040]                       }
[09:32:19.040]                       else {
[09:32:19.040]                         version <- NULL
[09:32:19.040]                       }
[09:32:19.040]                       if (!has_future || version < "1.8.0") {
[09:32:19.040]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.040]                           "", base::R.version$version.string), 
[09:32:19.040]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.040]                             "release", "version")], collapse = " "), 
[09:32:19.040]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.040]                           info)
[09:32:19.040]                         info <- base::paste(info, collapse = "; ")
[09:32:19.040]                         if (!has_future) {
[09:32:19.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.040]                             info)
[09:32:19.040]                         }
[09:32:19.040]                         else {
[09:32:19.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.040]                             info, version)
[09:32:19.040]                         }
[09:32:19.040]                         base::stop(msg)
[09:32:19.040]                       }
[09:32:19.040]                     })
[09:32:19.040]                   }
[09:32:19.040]                   ...future.strategy.old <- future::plan("list")
[09:32:19.040]                   options(future.plan = NULL)
[09:32:19.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.040]                 }
[09:32:19.040]                 ...future.workdir <- getwd()
[09:32:19.040]             }
[09:32:19.040]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.040]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.040]         }
[09:32:19.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.040]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.040]             base::names(...future.oldOptions))
[09:32:19.040]     }
[09:32:19.040]     if (FALSE) {
[09:32:19.040]     }
[09:32:19.040]     else {
[09:32:19.040]         if (TRUE) {
[09:32:19.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.040]                 open = "w")
[09:32:19.040]         }
[09:32:19.040]         else {
[09:32:19.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.040]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.040]         }
[09:32:19.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.040]             base::sink(type = "output", split = FALSE)
[09:32:19.040]             base::close(...future.stdout)
[09:32:19.040]         }, add = TRUE)
[09:32:19.040]     }
[09:32:19.040]     ...future.frame <- base::sys.nframe()
[09:32:19.040]     ...future.conditions <- base::list()
[09:32:19.040]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.040]     if (FALSE) {
[09:32:19.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.040]     }
[09:32:19.040]     ...future.result <- base::tryCatch({
[09:32:19.040]         base::withCallingHandlers({
[09:32:19.040]             ...future.value <- base::withVisible(base::local({
[09:32:19.040]                 1
[09:32:19.040]             }))
[09:32:19.040]             future::FutureResult(value = ...future.value$value, 
[09:32:19.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.040]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.040]                     ...future.globalenv.names))
[09:32:19.040]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.040]         }, condition = base::local({
[09:32:19.040]             c <- base::c
[09:32:19.040]             inherits <- base::inherits
[09:32:19.040]             invokeRestart <- base::invokeRestart
[09:32:19.040]             length <- base::length
[09:32:19.040]             list <- base::list
[09:32:19.040]             seq.int <- base::seq.int
[09:32:19.040]             signalCondition <- base::signalCondition
[09:32:19.040]             sys.calls <- base::sys.calls
[09:32:19.040]             `[[` <- base::`[[`
[09:32:19.040]             `+` <- base::`+`
[09:32:19.040]             `<<-` <- base::`<<-`
[09:32:19.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.040]                   3L)]
[09:32:19.040]             }
[09:32:19.040]             function(cond) {
[09:32:19.040]                 is_error <- inherits(cond, "error")
[09:32:19.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.040]                   NULL)
[09:32:19.040]                 if (is_error) {
[09:32:19.040]                   sessionInformation <- function() {
[09:32:19.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.040]                       search = base::search(), system = base::Sys.info())
[09:32:19.040]                   }
[09:32:19.040]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.040]                     cond$call), session = sessionInformation(), 
[09:32:19.040]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.040]                   signalCondition(cond)
[09:32:19.040]                 }
[09:32:19.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.040]                 "immediateCondition"))) {
[09:32:19.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.040]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.040]                   if (TRUE && !signal) {
[09:32:19.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.040]                     {
[09:32:19.040]                       inherits <- base::inherits
[09:32:19.040]                       invokeRestart <- base::invokeRestart
[09:32:19.040]                       is.null <- base::is.null
[09:32:19.040]                       muffled <- FALSE
[09:32:19.040]                       if (inherits(cond, "message")) {
[09:32:19.040]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.040]                         if (muffled) 
[09:32:19.040]                           invokeRestart("muffleMessage")
[09:32:19.040]                       }
[09:32:19.040]                       else if (inherits(cond, "warning")) {
[09:32:19.040]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.040]                         if (muffled) 
[09:32:19.040]                           invokeRestart("muffleWarning")
[09:32:19.040]                       }
[09:32:19.040]                       else if (inherits(cond, "condition")) {
[09:32:19.040]                         if (!is.null(pattern)) {
[09:32:19.040]                           computeRestarts <- base::computeRestarts
[09:32:19.040]                           grepl <- base::grepl
[09:32:19.040]                           restarts <- computeRestarts(cond)
[09:32:19.040]                           for (restart in restarts) {
[09:32:19.040]                             name <- restart$name
[09:32:19.040]                             if (is.null(name)) 
[09:32:19.040]                               next
[09:32:19.040]                             if (!grepl(pattern, name)) 
[09:32:19.040]                               next
[09:32:19.040]                             invokeRestart(restart)
[09:32:19.040]                             muffled <- TRUE
[09:32:19.040]                             break
[09:32:19.040]                           }
[09:32:19.040]                         }
[09:32:19.040]                       }
[09:32:19.040]                       invisible(muffled)
[09:32:19.040]                     }
[09:32:19.040]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.040]                   }
[09:32:19.040]                 }
[09:32:19.040]                 else {
[09:32:19.040]                   if (TRUE) {
[09:32:19.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.040]                     {
[09:32:19.040]                       inherits <- base::inherits
[09:32:19.040]                       invokeRestart <- base::invokeRestart
[09:32:19.040]                       is.null <- base::is.null
[09:32:19.040]                       muffled <- FALSE
[09:32:19.040]                       if (inherits(cond, "message")) {
[09:32:19.040]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.040]                         if (muffled) 
[09:32:19.040]                           invokeRestart("muffleMessage")
[09:32:19.040]                       }
[09:32:19.040]                       else if (inherits(cond, "warning")) {
[09:32:19.040]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.040]                         if (muffled) 
[09:32:19.040]                           invokeRestart("muffleWarning")
[09:32:19.040]                       }
[09:32:19.040]                       else if (inherits(cond, "condition")) {
[09:32:19.040]                         if (!is.null(pattern)) {
[09:32:19.040]                           computeRestarts <- base::computeRestarts
[09:32:19.040]                           grepl <- base::grepl
[09:32:19.040]                           restarts <- computeRestarts(cond)
[09:32:19.040]                           for (restart in restarts) {
[09:32:19.040]                             name <- restart$name
[09:32:19.040]                             if (is.null(name)) 
[09:32:19.040]                               next
[09:32:19.040]                             if (!grepl(pattern, name)) 
[09:32:19.040]                               next
[09:32:19.040]                             invokeRestart(restart)
[09:32:19.040]                             muffled <- TRUE
[09:32:19.040]                             break
[09:32:19.040]                           }
[09:32:19.040]                         }
[09:32:19.040]                       }
[09:32:19.040]                       invisible(muffled)
[09:32:19.040]                     }
[09:32:19.040]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.040]                   }
[09:32:19.040]                 }
[09:32:19.040]             }
[09:32:19.040]         }))
[09:32:19.040]     }, error = function(ex) {
[09:32:19.040]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.040]                 ...future.rng), started = ...future.startTime, 
[09:32:19.040]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.040]             version = "1.8"), class = "FutureResult")
[09:32:19.040]     }, finally = {
[09:32:19.040]         if (!identical(...future.workdir, getwd())) 
[09:32:19.040]             setwd(...future.workdir)
[09:32:19.040]         {
[09:32:19.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.040]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.040]             }
[09:32:19.040]             base::options(...future.oldOptions)
[09:32:19.040]             if (.Platform$OS.type == "windows") {
[09:32:19.040]                 old_names <- names(...future.oldEnvVars)
[09:32:19.040]                 envs <- base::Sys.getenv()
[09:32:19.040]                 names <- names(envs)
[09:32:19.040]                 common <- intersect(names, old_names)
[09:32:19.040]                 added <- setdiff(names, old_names)
[09:32:19.040]                 removed <- setdiff(old_names, names)
[09:32:19.040]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.040]                   envs[common]]
[09:32:19.040]                 NAMES <- toupper(changed)
[09:32:19.040]                 args <- list()
[09:32:19.040]                 for (kk in seq_along(NAMES)) {
[09:32:19.040]                   name <- changed[[kk]]
[09:32:19.040]                   NAME <- NAMES[[kk]]
[09:32:19.040]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.040]                     next
[09:32:19.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.040]                 }
[09:32:19.040]                 NAMES <- toupper(added)
[09:32:19.040]                 for (kk in seq_along(NAMES)) {
[09:32:19.040]                   name <- added[[kk]]
[09:32:19.040]                   NAME <- NAMES[[kk]]
[09:32:19.040]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.040]                     next
[09:32:19.040]                   args[[name]] <- ""
[09:32:19.040]                 }
[09:32:19.040]                 NAMES <- toupper(removed)
[09:32:19.040]                 for (kk in seq_along(NAMES)) {
[09:32:19.040]                   name <- removed[[kk]]
[09:32:19.040]                   NAME <- NAMES[[kk]]
[09:32:19.040]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.040]                     next
[09:32:19.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.040]                 }
[09:32:19.040]                 if (length(args) > 0) 
[09:32:19.040]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.040]             }
[09:32:19.040]             else {
[09:32:19.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.040]             }
[09:32:19.040]             {
[09:32:19.040]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.040]                   0L) {
[09:32:19.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.040]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.040]                   base::options(opts)
[09:32:19.040]                 }
[09:32:19.040]                 {
[09:32:19.040]                   {
[09:32:19.040]                     NULL
[09:32:19.040]                     RNGkind("Mersenne-Twister")
[09:32:19.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.040]                       inherits = FALSE)
[09:32:19.040]                   }
[09:32:19.040]                   options(future.plan = NULL)
[09:32:19.040]                   if (is.na(NA_character_)) 
[09:32:19.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.040]                     .init = FALSE)
[09:32:19.040]                 }
[09:32:19.040]             }
[09:32:19.040]         }
[09:32:19.040]     })
[09:32:19.040]     if (TRUE) {
[09:32:19.040]         base::sink(type = "output", split = FALSE)
[09:32:19.040]         if (TRUE) {
[09:32:19.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.040]         }
[09:32:19.040]         else {
[09:32:19.040]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.040]         }
[09:32:19.040]         base::close(...future.stdout)
[09:32:19.040]         ...future.stdout <- NULL
[09:32:19.040]     }
[09:32:19.040]     ...future.result$conditions <- ...future.conditions
[09:32:19.040]     ...future.result$finished <- base::Sys.time()
[09:32:19.040]     ...future.result
[09:32:19.040] }
[09:32:19.042] plan(): Setting new future strategy stack:
[09:32:19.042] List of future strategies:
[09:32:19.042] 1. sequential:
[09:32:19.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.042]    - tweaked: FALSE
[09:32:19.042]    - call: NULL
[09:32:19.043] plan(): nbrOfWorkers() = 1
[09:32:19.043] plan(): Setting new future strategy stack:
[09:32:19.043] List of future strategies:
[09:32:19.043] 1. sequential:
[09:32:19.043]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.043]    - tweaked: FALSE
[09:32:19.043]    - call: plan(strategy)
[09:32:19.044] plan(): nbrOfWorkers() = 1
[09:32:19.044] SequentialFuture started (and completed)
[09:32:19.044] - Launch lazy future ... done
[09:32:19.044] run() for ‘SequentialFuture’ ... done
[09:32:19.044] getGlobalsAndPackages() ...
[09:32:19.045] Searching for globals...
[09:32:19.045] - globals found: [1] ‘{’
[09:32:19.045] Searching for globals ... DONE
[09:32:19.045] Resolving globals: FALSE
[09:32:19.046] 
[09:32:19.046] 
[09:32:19.046] getGlobalsAndPackages() ... DONE
[09:32:19.046] run() for ‘Future’ ...
[09:32:19.046] - state: ‘created’
[09:32:19.046] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.046] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.046] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.047]   - Field: ‘label’
[09:32:19.047]   - Field: ‘local’
[09:32:19.047]   - Field: ‘owner’
[09:32:19.047]   - Field: ‘envir’
[09:32:19.047]   - Field: ‘packages’
[09:32:19.047]   - Field: ‘gc’
[09:32:19.047]   - Field: ‘conditions’
[09:32:19.047]   - Field: ‘expr’
[09:32:19.047]   - Field: ‘uuid’
[09:32:19.047]   - Field: ‘seed’
[09:32:19.047]   - Field: ‘version’
[09:32:19.048]   - Field: ‘result’
[09:32:19.048]   - Field: ‘asynchronous’
[09:32:19.048]   - Field: ‘calls’
[09:32:19.048]   - Field: ‘globals’
[09:32:19.048]   - Field: ‘stdout’
[09:32:19.048]   - Field: ‘earlySignal’
[09:32:19.048]   - Field: ‘lazy’
[09:32:19.048]   - Field: ‘state’
[09:32:19.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.048] - Launch lazy future ...
[09:32:19.048] Packages needed by the future expression (n = 0): <none>
[09:32:19.049] Packages needed by future strategies (n = 0): <none>
[09:32:19.049] {
[09:32:19.049]     {
[09:32:19.049]         {
[09:32:19.049]             ...future.startTime <- base::Sys.time()
[09:32:19.049]             {
[09:32:19.049]                 {
[09:32:19.049]                   {
[09:32:19.049]                     base::local({
[09:32:19.049]                       has_future <- base::requireNamespace("future", 
[09:32:19.049]                         quietly = TRUE)
[09:32:19.049]                       if (has_future) {
[09:32:19.049]                         ns <- base::getNamespace("future")
[09:32:19.049]                         version <- ns[[".package"]][["version"]]
[09:32:19.049]                         if (is.null(version)) 
[09:32:19.049]                           version <- utils::packageVersion("future")
[09:32:19.049]                       }
[09:32:19.049]                       else {
[09:32:19.049]                         version <- NULL
[09:32:19.049]                       }
[09:32:19.049]                       if (!has_future || version < "1.8.0") {
[09:32:19.049]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.049]                           "", base::R.version$version.string), 
[09:32:19.049]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.049]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.049]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.049]                             "release", "version")], collapse = " "), 
[09:32:19.049]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.049]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.049]                           info)
[09:32:19.049]                         info <- base::paste(info, collapse = "; ")
[09:32:19.049]                         if (!has_future) {
[09:32:19.049]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.049]                             info)
[09:32:19.049]                         }
[09:32:19.049]                         else {
[09:32:19.049]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.049]                             info, version)
[09:32:19.049]                         }
[09:32:19.049]                         base::stop(msg)
[09:32:19.049]                       }
[09:32:19.049]                     })
[09:32:19.049]                   }
[09:32:19.049]                   ...future.strategy.old <- future::plan("list")
[09:32:19.049]                   options(future.plan = NULL)
[09:32:19.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.049]                 }
[09:32:19.049]                 ...future.workdir <- getwd()
[09:32:19.049]             }
[09:32:19.049]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.049]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.049]         }
[09:32:19.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.049]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.049]             base::names(...future.oldOptions))
[09:32:19.049]     }
[09:32:19.049]     if (FALSE) {
[09:32:19.049]     }
[09:32:19.049]     else {
[09:32:19.049]         if (TRUE) {
[09:32:19.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.049]                 open = "w")
[09:32:19.049]         }
[09:32:19.049]         else {
[09:32:19.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.049]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.049]         }
[09:32:19.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.049]             base::sink(type = "output", split = FALSE)
[09:32:19.049]             base::close(...future.stdout)
[09:32:19.049]         }, add = TRUE)
[09:32:19.049]     }
[09:32:19.049]     ...future.frame <- base::sys.nframe()
[09:32:19.049]     ...future.conditions <- base::list()
[09:32:19.049]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.049]     if (FALSE) {
[09:32:19.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.049]     }
[09:32:19.049]     ...future.result <- base::tryCatch({
[09:32:19.049]         base::withCallingHandlers({
[09:32:19.049]             ...future.value <- base::withVisible(base::local({
[09:32:19.049]                 2
[09:32:19.049]             }))
[09:32:19.049]             future::FutureResult(value = ...future.value$value, 
[09:32:19.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.049]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.049]                     ...future.globalenv.names))
[09:32:19.049]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.049]         }, condition = base::local({
[09:32:19.049]             c <- base::c
[09:32:19.049]             inherits <- base::inherits
[09:32:19.049]             invokeRestart <- base::invokeRestart
[09:32:19.049]             length <- base::length
[09:32:19.049]             list <- base::list
[09:32:19.049]             seq.int <- base::seq.int
[09:32:19.049]             signalCondition <- base::signalCondition
[09:32:19.049]             sys.calls <- base::sys.calls
[09:32:19.049]             `[[` <- base::`[[`
[09:32:19.049]             `+` <- base::`+`
[09:32:19.049]             `<<-` <- base::`<<-`
[09:32:19.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.049]                   3L)]
[09:32:19.049]             }
[09:32:19.049]             function(cond) {
[09:32:19.049]                 is_error <- inherits(cond, "error")
[09:32:19.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.049]                   NULL)
[09:32:19.049]                 if (is_error) {
[09:32:19.049]                   sessionInformation <- function() {
[09:32:19.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.049]                       search = base::search(), system = base::Sys.info())
[09:32:19.049]                   }
[09:32:19.049]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.049]                     cond$call), session = sessionInformation(), 
[09:32:19.049]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.049]                   signalCondition(cond)
[09:32:19.049]                 }
[09:32:19.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.049]                 "immediateCondition"))) {
[09:32:19.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.049]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.049]                   if (TRUE && !signal) {
[09:32:19.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.049]                     {
[09:32:19.049]                       inherits <- base::inherits
[09:32:19.049]                       invokeRestart <- base::invokeRestart
[09:32:19.049]                       is.null <- base::is.null
[09:32:19.049]                       muffled <- FALSE
[09:32:19.049]                       if (inherits(cond, "message")) {
[09:32:19.049]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.049]                         if (muffled) 
[09:32:19.049]                           invokeRestart("muffleMessage")
[09:32:19.049]                       }
[09:32:19.049]                       else if (inherits(cond, "warning")) {
[09:32:19.049]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.049]                         if (muffled) 
[09:32:19.049]                           invokeRestart("muffleWarning")
[09:32:19.049]                       }
[09:32:19.049]                       else if (inherits(cond, "condition")) {
[09:32:19.049]                         if (!is.null(pattern)) {
[09:32:19.049]                           computeRestarts <- base::computeRestarts
[09:32:19.049]                           grepl <- base::grepl
[09:32:19.049]                           restarts <- computeRestarts(cond)
[09:32:19.049]                           for (restart in restarts) {
[09:32:19.049]                             name <- restart$name
[09:32:19.049]                             if (is.null(name)) 
[09:32:19.049]                               next
[09:32:19.049]                             if (!grepl(pattern, name)) 
[09:32:19.049]                               next
[09:32:19.049]                             invokeRestart(restart)
[09:32:19.049]                             muffled <- TRUE
[09:32:19.049]                             break
[09:32:19.049]                           }
[09:32:19.049]                         }
[09:32:19.049]                       }
[09:32:19.049]                       invisible(muffled)
[09:32:19.049]                     }
[09:32:19.049]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.049]                   }
[09:32:19.049]                 }
[09:32:19.049]                 else {
[09:32:19.049]                   if (TRUE) {
[09:32:19.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.049]                     {
[09:32:19.049]                       inherits <- base::inherits
[09:32:19.049]                       invokeRestart <- base::invokeRestart
[09:32:19.049]                       is.null <- base::is.null
[09:32:19.049]                       muffled <- FALSE
[09:32:19.049]                       if (inherits(cond, "message")) {
[09:32:19.049]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.049]                         if (muffled) 
[09:32:19.049]                           invokeRestart("muffleMessage")
[09:32:19.049]                       }
[09:32:19.049]                       else if (inherits(cond, "warning")) {
[09:32:19.049]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.049]                         if (muffled) 
[09:32:19.049]                           invokeRestart("muffleWarning")
[09:32:19.049]                       }
[09:32:19.049]                       else if (inherits(cond, "condition")) {
[09:32:19.049]                         if (!is.null(pattern)) {
[09:32:19.049]                           computeRestarts <- base::computeRestarts
[09:32:19.049]                           grepl <- base::grepl
[09:32:19.049]                           restarts <- computeRestarts(cond)
[09:32:19.049]                           for (restart in restarts) {
[09:32:19.049]                             name <- restart$name
[09:32:19.049]                             if (is.null(name)) 
[09:32:19.049]                               next
[09:32:19.049]                             if (!grepl(pattern, name)) 
[09:32:19.049]                               next
[09:32:19.049]                             invokeRestart(restart)
[09:32:19.049]                             muffled <- TRUE
[09:32:19.049]                             break
[09:32:19.049]                           }
[09:32:19.049]                         }
[09:32:19.049]                       }
[09:32:19.049]                       invisible(muffled)
[09:32:19.049]                     }
[09:32:19.049]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.049]                   }
[09:32:19.049]                 }
[09:32:19.049]             }
[09:32:19.049]         }))
[09:32:19.049]     }, error = function(ex) {
[09:32:19.049]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.049]                 ...future.rng), started = ...future.startTime, 
[09:32:19.049]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.049]             version = "1.8"), class = "FutureResult")
[09:32:19.049]     }, finally = {
[09:32:19.049]         if (!identical(...future.workdir, getwd())) 
[09:32:19.049]             setwd(...future.workdir)
[09:32:19.049]         {
[09:32:19.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.049]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.049]             }
[09:32:19.049]             base::options(...future.oldOptions)
[09:32:19.049]             if (.Platform$OS.type == "windows") {
[09:32:19.049]                 old_names <- names(...future.oldEnvVars)
[09:32:19.049]                 envs <- base::Sys.getenv()
[09:32:19.049]                 names <- names(envs)
[09:32:19.049]                 common <- intersect(names, old_names)
[09:32:19.049]                 added <- setdiff(names, old_names)
[09:32:19.049]                 removed <- setdiff(old_names, names)
[09:32:19.049]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.049]                   envs[common]]
[09:32:19.049]                 NAMES <- toupper(changed)
[09:32:19.049]                 args <- list()
[09:32:19.049]                 for (kk in seq_along(NAMES)) {
[09:32:19.049]                   name <- changed[[kk]]
[09:32:19.049]                   NAME <- NAMES[[kk]]
[09:32:19.049]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.049]                     next
[09:32:19.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.049]                 }
[09:32:19.049]                 NAMES <- toupper(added)
[09:32:19.049]                 for (kk in seq_along(NAMES)) {
[09:32:19.049]                   name <- added[[kk]]
[09:32:19.049]                   NAME <- NAMES[[kk]]
[09:32:19.049]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.049]                     next
[09:32:19.049]                   args[[name]] <- ""
[09:32:19.049]                 }
[09:32:19.049]                 NAMES <- toupper(removed)
[09:32:19.049]                 for (kk in seq_along(NAMES)) {
[09:32:19.049]                   name <- removed[[kk]]
[09:32:19.049]                   NAME <- NAMES[[kk]]
[09:32:19.049]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.049]                     next
[09:32:19.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.049]                 }
[09:32:19.049]                 if (length(args) > 0) 
[09:32:19.049]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.049]             }
[09:32:19.049]             else {
[09:32:19.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.049]             }
[09:32:19.049]             {
[09:32:19.049]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.049]                   0L) {
[09:32:19.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.049]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.049]                   base::options(opts)
[09:32:19.049]                 }
[09:32:19.049]                 {
[09:32:19.049]                   {
[09:32:19.049]                     NULL
[09:32:19.049]                     RNGkind("Mersenne-Twister")
[09:32:19.049]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.049]                       inherits = FALSE)
[09:32:19.049]                   }
[09:32:19.049]                   options(future.plan = NULL)
[09:32:19.049]                   if (is.na(NA_character_)) 
[09:32:19.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.049]                     .init = FALSE)
[09:32:19.049]                 }
[09:32:19.049]             }
[09:32:19.049]         }
[09:32:19.049]     })
[09:32:19.049]     if (TRUE) {
[09:32:19.049]         base::sink(type = "output", split = FALSE)
[09:32:19.049]         if (TRUE) {
[09:32:19.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.049]         }
[09:32:19.049]         else {
[09:32:19.049]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.049]         }
[09:32:19.049]         base::close(...future.stdout)
[09:32:19.049]         ...future.stdout <- NULL
[09:32:19.049]     }
[09:32:19.049]     ...future.result$conditions <- ...future.conditions
[09:32:19.049]     ...future.result$finished <- base::Sys.time()
[09:32:19.049]     ...future.result
[09:32:19.049] }
[09:32:19.051] plan(): Setting new future strategy stack:
[09:32:19.051] List of future strategies:
[09:32:19.051] 1. sequential:
[09:32:19.051]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.051]    - tweaked: FALSE
[09:32:19.051]    - call: NULL
[09:32:19.051] plan(): nbrOfWorkers() = 1
[09:32:19.052] plan(): Setting new future strategy stack:
[09:32:19.052] List of future strategies:
[09:32:19.052] 1. sequential:
[09:32:19.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.052]    - tweaked: FALSE
[09:32:19.052]    - call: plan(strategy)
[09:32:19.052] plan(): nbrOfWorkers() = 1
[09:32:19.052] SequentialFuture started (and completed)
[09:32:19.053] - Launch lazy future ... done
[09:32:19.053] run() for ‘SequentialFuture’ ... done
[09:32:19.054] resolve() on environment ...
[09:32:19.054]  recursive: 0
[09:32:19.055]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:19.055] resolved() for ‘SequentialFuture’ ...
[09:32:19.055] - state: ‘finished’
[09:32:19.055] - run: TRUE
[09:32:19.055] - result: ‘FutureResult’
[09:32:19.055] resolved() for ‘SequentialFuture’ ... done
[09:32:19.055] Future #1
[09:32:19.056]  length: 2 (resolved future 1)
[09:32:19.056] resolved() for ‘SequentialFuture’ ...
[09:32:19.056] - state: ‘finished’
[09:32:19.056] - run: TRUE
[09:32:19.056] - result: ‘FutureResult’
[09:32:19.056] resolved() for ‘SequentialFuture’ ... done
[09:32:19.056] Future #2
[09:32:19.056]  length: 1 (resolved future 2)
[09:32:19.056]  length: 0 (resolved future 3)
[09:32:19.056] resolve() on environment ... DONE
[09:32:19.057] getGlobalsAndPackages() ...
[09:32:19.057] Searching for globals...
[09:32:19.057] - globals found: [1] ‘{’
[09:32:19.057] Searching for globals ... DONE
[09:32:19.058] Resolving globals: FALSE
[09:32:19.058] 
[09:32:19.058] 
[09:32:19.058] getGlobalsAndPackages() ... DONE
[09:32:19.058] run() for ‘Future’ ...
[09:32:19.058] - state: ‘created’
[09:32:19.058] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.059] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.059]   - Field: ‘label’
[09:32:19.059]   - Field: ‘local’
[09:32:19.059]   - Field: ‘owner’
[09:32:19.059]   - Field: ‘envir’
[09:32:19.059]   - Field: ‘packages’
[09:32:19.059]   - Field: ‘gc’
[09:32:19.059]   - Field: ‘conditions’
[09:32:19.059]   - Field: ‘expr’
[09:32:19.060]   - Field: ‘uuid’
[09:32:19.060]   - Field: ‘seed’
[09:32:19.060]   - Field: ‘version’
[09:32:19.060]   - Field: ‘result’
[09:32:19.060]   - Field: ‘asynchronous’
[09:32:19.060]   - Field: ‘calls’
[09:32:19.060]   - Field: ‘globals’
[09:32:19.060]   - Field: ‘stdout’
[09:32:19.060]   - Field: ‘earlySignal’
[09:32:19.060]   - Field: ‘lazy’
[09:32:19.060]   - Field: ‘state’
[09:32:19.060] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.061] - Launch lazy future ...
[09:32:19.061] Packages needed by the future expression (n = 0): <none>
[09:32:19.061] Packages needed by future strategies (n = 0): <none>
[09:32:19.061] {
[09:32:19.061]     {
[09:32:19.061]         {
[09:32:19.061]             ...future.startTime <- base::Sys.time()
[09:32:19.061]             {
[09:32:19.061]                 {
[09:32:19.061]                   {
[09:32:19.061]                     base::local({
[09:32:19.061]                       has_future <- base::requireNamespace("future", 
[09:32:19.061]                         quietly = TRUE)
[09:32:19.061]                       if (has_future) {
[09:32:19.061]                         ns <- base::getNamespace("future")
[09:32:19.061]                         version <- ns[[".package"]][["version"]]
[09:32:19.061]                         if (is.null(version)) 
[09:32:19.061]                           version <- utils::packageVersion("future")
[09:32:19.061]                       }
[09:32:19.061]                       else {
[09:32:19.061]                         version <- NULL
[09:32:19.061]                       }
[09:32:19.061]                       if (!has_future || version < "1.8.0") {
[09:32:19.061]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.061]                           "", base::R.version$version.string), 
[09:32:19.061]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.061]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.061]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.061]                             "release", "version")], collapse = " "), 
[09:32:19.061]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.061]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.061]                           info)
[09:32:19.061]                         info <- base::paste(info, collapse = "; ")
[09:32:19.061]                         if (!has_future) {
[09:32:19.061]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.061]                             info)
[09:32:19.061]                         }
[09:32:19.061]                         else {
[09:32:19.061]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.061]                             info, version)
[09:32:19.061]                         }
[09:32:19.061]                         base::stop(msg)
[09:32:19.061]                       }
[09:32:19.061]                     })
[09:32:19.061]                   }
[09:32:19.061]                   ...future.strategy.old <- future::plan("list")
[09:32:19.061]                   options(future.plan = NULL)
[09:32:19.061]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.061]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.061]                 }
[09:32:19.061]                 ...future.workdir <- getwd()
[09:32:19.061]             }
[09:32:19.061]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.061]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.061]         }
[09:32:19.061]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.061]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.061]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.061]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.061]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.061]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.061]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.061]             base::names(...future.oldOptions))
[09:32:19.061]     }
[09:32:19.061]     if (FALSE) {
[09:32:19.061]     }
[09:32:19.061]     else {
[09:32:19.061]         if (TRUE) {
[09:32:19.061]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.061]                 open = "w")
[09:32:19.061]         }
[09:32:19.061]         else {
[09:32:19.061]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.061]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.061]         }
[09:32:19.061]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.061]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.061]             base::sink(type = "output", split = FALSE)
[09:32:19.061]             base::close(...future.stdout)
[09:32:19.061]         }, add = TRUE)
[09:32:19.061]     }
[09:32:19.061]     ...future.frame <- base::sys.nframe()
[09:32:19.061]     ...future.conditions <- base::list()
[09:32:19.061]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.061]     if (FALSE) {
[09:32:19.061]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.061]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.061]     }
[09:32:19.061]     ...future.result <- base::tryCatch({
[09:32:19.061]         base::withCallingHandlers({
[09:32:19.061]             ...future.value <- base::withVisible(base::local({
[09:32:19.061]                 1
[09:32:19.061]             }))
[09:32:19.061]             future::FutureResult(value = ...future.value$value, 
[09:32:19.061]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.061]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.061]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.061]                     ...future.globalenv.names))
[09:32:19.061]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.061]         }, condition = base::local({
[09:32:19.061]             c <- base::c
[09:32:19.061]             inherits <- base::inherits
[09:32:19.061]             invokeRestart <- base::invokeRestart
[09:32:19.061]             length <- base::length
[09:32:19.061]             list <- base::list
[09:32:19.061]             seq.int <- base::seq.int
[09:32:19.061]             signalCondition <- base::signalCondition
[09:32:19.061]             sys.calls <- base::sys.calls
[09:32:19.061]             `[[` <- base::`[[`
[09:32:19.061]             `+` <- base::`+`
[09:32:19.061]             `<<-` <- base::`<<-`
[09:32:19.061]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.061]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.061]                   3L)]
[09:32:19.061]             }
[09:32:19.061]             function(cond) {
[09:32:19.061]                 is_error <- inherits(cond, "error")
[09:32:19.061]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.061]                   NULL)
[09:32:19.061]                 if (is_error) {
[09:32:19.061]                   sessionInformation <- function() {
[09:32:19.061]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.061]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.061]                       search = base::search(), system = base::Sys.info())
[09:32:19.061]                   }
[09:32:19.061]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.061]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.061]                     cond$call), session = sessionInformation(), 
[09:32:19.061]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.061]                   signalCondition(cond)
[09:32:19.061]                 }
[09:32:19.061]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.061]                 "immediateCondition"))) {
[09:32:19.061]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.061]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.061]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.061]                   if (TRUE && !signal) {
[09:32:19.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.061]                     {
[09:32:19.061]                       inherits <- base::inherits
[09:32:19.061]                       invokeRestart <- base::invokeRestart
[09:32:19.061]                       is.null <- base::is.null
[09:32:19.061]                       muffled <- FALSE
[09:32:19.061]                       if (inherits(cond, "message")) {
[09:32:19.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.061]                         if (muffled) 
[09:32:19.061]                           invokeRestart("muffleMessage")
[09:32:19.061]                       }
[09:32:19.061]                       else if (inherits(cond, "warning")) {
[09:32:19.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.061]                         if (muffled) 
[09:32:19.061]                           invokeRestart("muffleWarning")
[09:32:19.061]                       }
[09:32:19.061]                       else if (inherits(cond, "condition")) {
[09:32:19.061]                         if (!is.null(pattern)) {
[09:32:19.061]                           computeRestarts <- base::computeRestarts
[09:32:19.061]                           grepl <- base::grepl
[09:32:19.061]                           restarts <- computeRestarts(cond)
[09:32:19.061]                           for (restart in restarts) {
[09:32:19.061]                             name <- restart$name
[09:32:19.061]                             if (is.null(name)) 
[09:32:19.061]                               next
[09:32:19.061]                             if (!grepl(pattern, name)) 
[09:32:19.061]                               next
[09:32:19.061]                             invokeRestart(restart)
[09:32:19.061]                             muffled <- TRUE
[09:32:19.061]                             break
[09:32:19.061]                           }
[09:32:19.061]                         }
[09:32:19.061]                       }
[09:32:19.061]                       invisible(muffled)
[09:32:19.061]                     }
[09:32:19.061]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.061]                   }
[09:32:19.061]                 }
[09:32:19.061]                 else {
[09:32:19.061]                   if (TRUE) {
[09:32:19.061]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.061]                     {
[09:32:19.061]                       inherits <- base::inherits
[09:32:19.061]                       invokeRestart <- base::invokeRestart
[09:32:19.061]                       is.null <- base::is.null
[09:32:19.061]                       muffled <- FALSE
[09:32:19.061]                       if (inherits(cond, "message")) {
[09:32:19.061]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.061]                         if (muffled) 
[09:32:19.061]                           invokeRestart("muffleMessage")
[09:32:19.061]                       }
[09:32:19.061]                       else if (inherits(cond, "warning")) {
[09:32:19.061]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.061]                         if (muffled) 
[09:32:19.061]                           invokeRestart("muffleWarning")
[09:32:19.061]                       }
[09:32:19.061]                       else if (inherits(cond, "condition")) {
[09:32:19.061]                         if (!is.null(pattern)) {
[09:32:19.061]                           computeRestarts <- base::computeRestarts
[09:32:19.061]                           grepl <- base::grepl
[09:32:19.061]                           restarts <- computeRestarts(cond)
[09:32:19.061]                           for (restart in restarts) {
[09:32:19.061]                             name <- restart$name
[09:32:19.061]                             if (is.null(name)) 
[09:32:19.061]                               next
[09:32:19.061]                             if (!grepl(pattern, name)) 
[09:32:19.061]                               next
[09:32:19.061]                             invokeRestart(restart)
[09:32:19.061]                             muffled <- TRUE
[09:32:19.061]                             break
[09:32:19.061]                           }
[09:32:19.061]                         }
[09:32:19.061]                       }
[09:32:19.061]                       invisible(muffled)
[09:32:19.061]                     }
[09:32:19.061]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.061]                   }
[09:32:19.061]                 }
[09:32:19.061]             }
[09:32:19.061]         }))
[09:32:19.061]     }, error = function(ex) {
[09:32:19.061]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.061]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.061]                 ...future.rng), started = ...future.startTime, 
[09:32:19.061]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.061]             version = "1.8"), class = "FutureResult")
[09:32:19.061]     }, finally = {
[09:32:19.061]         if (!identical(...future.workdir, getwd())) 
[09:32:19.061]             setwd(...future.workdir)
[09:32:19.061]         {
[09:32:19.061]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.061]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.061]             }
[09:32:19.061]             base::options(...future.oldOptions)
[09:32:19.061]             if (.Platform$OS.type == "windows") {
[09:32:19.061]                 old_names <- names(...future.oldEnvVars)
[09:32:19.061]                 envs <- base::Sys.getenv()
[09:32:19.061]                 names <- names(envs)
[09:32:19.061]                 common <- intersect(names, old_names)
[09:32:19.061]                 added <- setdiff(names, old_names)
[09:32:19.061]                 removed <- setdiff(old_names, names)
[09:32:19.061]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.061]                   envs[common]]
[09:32:19.061]                 NAMES <- toupper(changed)
[09:32:19.061]                 args <- list()
[09:32:19.061]                 for (kk in seq_along(NAMES)) {
[09:32:19.061]                   name <- changed[[kk]]
[09:32:19.061]                   NAME <- NAMES[[kk]]
[09:32:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.061]                     next
[09:32:19.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.061]                 }
[09:32:19.061]                 NAMES <- toupper(added)
[09:32:19.061]                 for (kk in seq_along(NAMES)) {
[09:32:19.061]                   name <- added[[kk]]
[09:32:19.061]                   NAME <- NAMES[[kk]]
[09:32:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.061]                     next
[09:32:19.061]                   args[[name]] <- ""
[09:32:19.061]                 }
[09:32:19.061]                 NAMES <- toupper(removed)
[09:32:19.061]                 for (kk in seq_along(NAMES)) {
[09:32:19.061]                   name <- removed[[kk]]
[09:32:19.061]                   NAME <- NAMES[[kk]]
[09:32:19.061]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.061]                     next
[09:32:19.061]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.061]                 }
[09:32:19.061]                 if (length(args) > 0) 
[09:32:19.061]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.061]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.061]             }
[09:32:19.061]             else {
[09:32:19.061]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.061]             }
[09:32:19.061]             {
[09:32:19.061]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.061]                   0L) {
[09:32:19.061]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.061]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.061]                   base::options(opts)
[09:32:19.061]                 }
[09:32:19.061]                 {
[09:32:19.061]                   {
[09:32:19.061]                     NULL
[09:32:19.061]                     RNGkind("Mersenne-Twister")
[09:32:19.061]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.061]                       inherits = FALSE)
[09:32:19.061]                   }
[09:32:19.061]                   options(future.plan = NULL)
[09:32:19.061]                   if (is.na(NA_character_)) 
[09:32:19.061]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.061]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.061]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.061]                     .init = FALSE)
[09:32:19.061]                 }
[09:32:19.061]             }
[09:32:19.061]         }
[09:32:19.061]     })
[09:32:19.061]     if (TRUE) {
[09:32:19.061]         base::sink(type = "output", split = FALSE)
[09:32:19.061]         if (TRUE) {
[09:32:19.061]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.061]         }
[09:32:19.061]         else {
[09:32:19.061]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.061]         }
[09:32:19.061]         base::close(...future.stdout)
[09:32:19.061]         ...future.stdout <- NULL
[09:32:19.061]     }
[09:32:19.061]     ...future.result$conditions <- ...future.conditions
[09:32:19.061]     ...future.result$finished <- base::Sys.time()
[09:32:19.061]     ...future.result
[09:32:19.061] }
[09:32:19.063] plan(): Setting new future strategy stack:
[09:32:19.063] List of future strategies:
[09:32:19.063] 1. sequential:
[09:32:19.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.063]    - tweaked: FALSE
[09:32:19.063]    - call: NULL
[09:32:19.063] plan(): nbrOfWorkers() = 1
[09:32:19.064] plan(): Setting new future strategy stack:
[09:32:19.064] List of future strategies:
[09:32:19.064] 1. sequential:
[09:32:19.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.064]    - tweaked: FALSE
[09:32:19.064]    - call: plan(strategy)
[09:32:19.065] plan(): nbrOfWorkers() = 1
[09:32:19.065] SequentialFuture started (and completed)
[09:32:19.065] - Launch lazy future ... done
[09:32:19.065] run() for ‘SequentialFuture’ ... done
[09:32:19.065] getGlobalsAndPackages() ...
[09:32:19.065] Searching for globals...
[09:32:19.066] - globals found: [1] ‘{’
[09:32:19.066] Searching for globals ... DONE
[09:32:19.066] Resolving globals: FALSE
[09:32:19.066] 
[09:32:19.066] 
[09:32:19.066] getGlobalsAndPackages() ... DONE
[09:32:19.067] run() for ‘Future’ ...
[09:32:19.067] - state: ‘created’
[09:32:19.067] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.067] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.067] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.067]   - Field: ‘label’
[09:32:19.067]   - Field: ‘local’
[09:32:19.067]   - Field: ‘owner’
[09:32:19.067]   - Field: ‘envir’
[09:32:19.068]   - Field: ‘packages’
[09:32:19.068]   - Field: ‘gc’
[09:32:19.068]   - Field: ‘conditions’
[09:32:19.068]   - Field: ‘expr’
[09:32:19.068]   - Field: ‘uuid’
[09:32:19.068]   - Field: ‘seed’
[09:32:19.068]   - Field: ‘version’
[09:32:19.068]   - Field: ‘result’
[09:32:19.068]   - Field: ‘asynchronous’
[09:32:19.068]   - Field: ‘calls’
[09:32:19.068]   - Field: ‘globals’
[09:32:19.068]   - Field: ‘stdout’
[09:32:19.069]   - Field: ‘earlySignal’
[09:32:19.069]   - Field: ‘lazy’
[09:32:19.069]   - Field: ‘state’
[09:32:19.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.069] - Launch lazy future ...
[09:32:19.069] Packages needed by the future expression (n = 0): <none>
[09:32:19.069] Packages needed by future strategies (n = 0): <none>
[09:32:19.070] {
[09:32:19.070]     {
[09:32:19.070]         {
[09:32:19.070]             ...future.startTime <- base::Sys.time()
[09:32:19.070]             {
[09:32:19.070]                 {
[09:32:19.070]                   {
[09:32:19.070]                     base::local({
[09:32:19.070]                       has_future <- base::requireNamespace("future", 
[09:32:19.070]                         quietly = TRUE)
[09:32:19.070]                       if (has_future) {
[09:32:19.070]                         ns <- base::getNamespace("future")
[09:32:19.070]                         version <- ns[[".package"]][["version"]]
[09:32:19.070]                         if (is.null(version)) 
[09:32:19.070]                           version <- utils::packageVersion("future")
[09:32:19.070]                       }
[09:32:19.070]                       else {
[09:32:19.070]                         version <- NULL
[09:32:19.070]                       }
[09:32:19.070]                       if (!has_future || version < "1.8.0") {
[09:32:19.070]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.070]                           "", base::R.version$version.string), 
[09:32:19.070]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.070]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.070]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.070]                             "release", "version")], collapse = " "), 
[09:32:19.070]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.070]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.070]                           info)
[09:32:19.070]                         info <- base::paste(info, collapse = "; ")
[09:32:19.070]                         if (!has_future) {
[09:32:19.070]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.070]                             info)
[09:32:19.070]                         }
[09:32:19.070]                         else {
[09:32:19.070]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.070]                             info, version)
[09:32:19.070]                         }
[09:32:19.070]                         base::stop(msg)
[09:32:19.070]                       }
[09:32:19.070]                     })
[09:32:19.070]                   }
[09:32:19.070]                   ...future.strategy.old <- future::plan("list")
[09:32:19.070]                   options(future.plan = NULL)
[09:32:19.070]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.070]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.070]                 }
[09:32:19.070]                 ...future.workdir <- getwd()
[09:32:19.070]             }
[09:32:19.070]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.070]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.070]         }
[09:32:19.070]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.070]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.070]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.070]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.070]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.070]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.070]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.070]             base::names(...future.oldOptions))
[09:32:19.070]     }
[09:32:19.070]     if (FALSE) {
[09:32:19.070]     }
[09:32:19.070]     else {
[09:32:19.070]         if (TRUE) {
[09:32:19.070]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.070]                 open = "w")
[09:32:19.070]         }
[09:32:19.070]         else {
[09:32:19.070]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.070]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.070]         }
[09:32:19.070]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.070]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.070]             base::sink(type = "output", split = FALSE)
[09:32:19.070]             base::close(...future.stdout)
[09:32:19.070]         }, add = TRUE)
[09:32:19.070]     }
[09:32:19.070]     ...future.frame <- base::sys.nframe()
[09:32:19.070]     ...future.conditions <- base::list()
[09:32:19.070]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.070]     if (FALSE) {
[09:32:19.070]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.070]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.070]     }
[09:32:19.070]     ...future.result <- base::tryCatch({
[09:32:19.070]         base::withCallingHandlers({
[09:32:19.070]             ...future.value <- base::withVisible(base::local({
[09:32:19.070]                 2
[09:32:19.070]             }))
[09:32:19.070]             future::FutureResult(value = ...future.value$value, 
[09:32:19.070]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.070]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.070]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.070]                     ...future.globalenv.names))
[09:32:19.070]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.070]         }, condition = base::local({
[09:32:19.070]             c <- base::c
[09:32:19.070]             inherits <- base::inherits
[09:32:19.070]             invokeRestart <- base::invokeRestart
[09:32:19.070]             length <- base::length
[09:32:19.070]             list <- base::list
[09:32:19.070]             seq.int <- base::seq.int
[09:32:19.070]             signalCondition <- base::signalCondition
[09:32:19.070]             sys.calls <- base::sys.calls
[09:32:19.070]             `[[` <- base::`[[`
[09:32:19.070]             `+` <- base::`+`
[09:32:19.070]             `<<-` <- base::`<<-`
[09:32:19.070]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.070]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.070]                   3L)]
[09:32:19.070]             }
[09:32:19.070]             function(cond) {
[09:32:19.070]                 is_error <- inherits(cond, "error")
[09:32:19.070]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.070]                   NULL)
[09:32:19.070]                 if (is_error) {
[09:32:19.070]                   sessionInformation <- function() {
[09:32:19.070]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.070]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.070]                       search = base::search(), system = base::Sys.info())
[09:32:19.070]                   }
[09:32:19.070]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.070]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.070]                     cond$call), session = sessionInformation(), 
[09:32:19.070]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.070]                   signalCondition(cond)
[09:32:19.070]                 }
[09:32:19.070]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.070]                 "immediateCondition"))) {
[09:32:19.070]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.070]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.070]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.070]                   if (TRUE && !signal) {
[09:32:19.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.070]                     {
[09:32:19.070]                       inherits <- base::inherits
[09:32:19.070]                       invokeRestart <- base::invokeRestart
[09:32:19.070]                       is.null <- base::is.null
[09:32:19.070]                       muffled <- FALSE
[09:32:19.070]                       if (inherits(cond, "message")) {
[09:32:19.070]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.070]                         if (muffled) 
[09:32:19.070]                           invokeRestart("muffleMessage")
[09:32:19.070]                       }
[09:32:19.070]                       else if (inherits(cond, "warning")) {
[09:32:19.070]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.070]                         if (muffled) 
[09:32:19.070]                           invokeRestart("muffleWarning")
[09:32:19.070]                       }
[09:32:19.070]                       else if (inherits(cond, "condition")) {
[09:32:19.070]                         if (!is.null(pattern)) {
[09:32:19.070]                           computeRestarts <- base::computeRestarts
[09:32:19.070]                           grepl <- base::grepl
[09:32:19.070]                           restarts <- computeRestarts(cond)
[09:32:19.070]                           for (restart in restarts) {
[09:32:19.070]                             name <- restart$name
[09:32:19.070]                             if (is.null(name)) 
[09:32:19.070]                               next
[09:32:19.070]                             if (!grepl(pattern, name)) 
[09:32:19.070]                               next
[09:32:19.070]                             invokeRestart(restart)
[09:32:19.070]                             muffled <- TRUE
[09:32:19.070]                             break
[09:32:19.070]                           }
[09:32:19.070]                         }
[09:32:19.070]                       }
[09:32:19.070]                       invisible(muffled)
[09:32:19.070]                     }
[09:32:19.070]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.070]                   }
[09:32:19.070]                 }
[09:32:19.070]                 else {
[09:32:19.070]                   if (TRUE) {
[09:32:19.070]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.070]                     {
[09:32:19.070]                       inherits <- base::inherits
[09:32:19.070]                       invokeRestart <- base::invokeRestart
[09:32:19.070]                       is.null <- base::is.null
[09:32:19.070]                       muffled <- FALSE
[09:32:19.070]                       if (inherits(cond, "message")) {
[09:32:19.070]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.070]                         if (muffled) 
[09:32:19.070]                           invokeRestart("muffleMessage")
[09:32:19.070]                       }
[09:32:19.070]                       else if (inherits(cond, "warning")) {
[09:32:19.070]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.070]                         if (muffled) 
[09:32:19.070]                           invokeRestart("muffleWarning")
[09:32:19.070]                       }
[09:32:19.070]                       else if (inherits(cond, "condition")) {
[09:32:19.070]                         if (!is.null(pattern)) {
[09:32:19.070]                           computeRestarts <- base::computeRestarts
[09:32:19.070]                           grepl <- base::grepl
[09:32:19.070]                           restarts <- computeRestarts(cond)
[09:32:19.070]                           for (restart in restarts) {
[09:32:19.070]                             name <- restart$name
[09:32:19.070]                             if (is.null(name)) 
[09:32:19.070]                               next
[09:32:19.070]                             if (!grepl(pattern, name)) 
[09:32:19.070]                               next
[09:32:19.070]                             invokeRestart(restart)
[09:32:19.070]                             muffled <- TRUE
[09:32:19.070]                             break
[09:32:19.070]                           }
[09:32:19.070]                         }
[09:32:19.070]                       }
[09:32:19.070]                       invisible(muffled)
[09:32:19.070]                     }
[09:32:19.070]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.070]                   }
[09:32:19.070]                 }
[09:32:19.070]             }
[09:32:19.070]         }))
[09:32:19.070]     }, error = function(ex) {
[09:32:19.070]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.070]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.070]                 ...future.rng), started = ...future.startTime, 
[09:32:19.070]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.070]             version = "1.8"), class = "FutureResult")
[09:32:19.070]     }, finally = {
[09:32:19.070]         if (!identical(...future.workdir, getwd())) 
[09:32:19.070]             setwd(...future.workdir)
[09:32:19.070]         {
[09:32:19.070]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.070]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.070]             }
[09:32:19.070]             base::options(...future.oldOptions)
[09:32:19.070]             if (.Platform$OS.type == "windows") {
[09:32:19.070]                 old_names <- names(...future.oldEnvVars)
[09:32:19.070]                 envs <- base::Sys.getenv()
[09:32:19.070]                 names <- names(envs)
[09:32:19.070]                 common <- intersect(names, old_names)
[09:32:19.070]                 added <- setdiff(names, old_names)
[09:32:19.070]                 removed <- setdiff(old_names, names)
[09:32:19.070]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.070]                   envs[common]]
[09:32:19.070]                 NAMES <- toupper(changed)
[09:32:19.070]                 args <- list()
[09:32:19.070]                 for (kk in seq_along(NAMES)) {
[09:32:19.070]                   name <- changed[[kk]]
[09:32:19.070]                   NAME <- NAMES[[kk]]
[09:32:19.070]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.070]                     next
[09:32:19.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.070]                 }
[09:32:19.070]                 NAMES <- toupper(added)
[09:32:19.070]                 for (kk in seq_along(NAMES)) {
[09:32:19.070]                   name <- added[[kk]]
[09:32:19.070]                   NAME <- NAMES[[kk]]
[09:32:19.070]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.070]                     next
[09:32:19.070]                   args[[name]] <- ""
[09:32:19.070]                 }
[09:32:19.070]                 NAMES <- toupper(removed)
[09:32:19.070]                 for (kk in seq_along(NAMES)) {
[09:32:19.070]                   name <- removed[[kk]]
[09:32:19.070]                   NAME <- NAMES[[kk]]
[09:32:19.070]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.070]                     next
[09:32:19.070]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.070]                 }
[09:32:19.070]                 if (length(args) > 0) 
[09:32:19.070]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.070]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.070]             }
[09:32:19.070]             else {
[09:32:19.070]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.070]             }
[09:32:19.070]             {
[09:32:19.070]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.070]                   0L) {
[09:32:19.070]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.070]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.070]                   base::options(opts)
[09:32:19.070]                 }
[09:32:19.070]                 {
[09:32:19.070]                   {
[09:32:19.070]                     NULL
[09:32:19.070]                     RNGkind("Mersenne-Twister")
[09:32:19.070]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.070]                       inherits = FALSE)
[09:32:19.070]                   }
[09:32:19.070]                   options(future.plan = NULL)
[09:32:19.070]                   if (is.na(NA_character_)) 
[09:32:19.070]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.070]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.070]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.070]                     .init = FALSE)
[09:32:19.070]                 }
[09:32:19.070]             }
[09:32:19.070]         }
[09:32:19.070]     })
[09:32:19.070]     if (TRUE) {
[09:32:19.070]         base::sink(type = "output", split = FALSE)
[09:32:19.070]         if (TRUE) {
[09:32:19.070]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.070]         }
[09:32:19.070]         else {
[09:32:19.070]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.070]         }
[09:32:19.070]         base::close(...future.stdout)
[09:32:19.070]         ...future.stdout <- NULL
[09:32:19.070]     }
[09:32:19.070]     ...future.result$conditions <- ...future.conditions
[09:32:19.070]     ...future.result$finished <- base::Sys.time()
[09:32:19.070]     ...future.result
[09:32:19.070] }
[09:32:19.071] plan(): Setting new future strategy stack:
[09:32:19.071] List of future strategies:
[09:32:19.071] 1. sequential:
[09:32:19.071]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.071]    - tweaked: FALSE
[09:32:19.071]    - call: NULL
[09:32:19.072] plan(): nbrOfWorkers() = 1
[09:32:19.072] plan(): Setting new future strategy stack:
[09:32:19.072] List of future strategies:
[09:32:19.072] 1. sequential:
[09:32:19.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.072]    - tweaked: FALSE
[09:32:19.072]    - call: plan(strategy)
[09:32:19.073] plan(): nbrOfWorkers() = 1
[09:32:19.073] SequentialFuture started (and completed)
[09:32:19.073] - Launch lazy future ... done
[09:32:19.073] run() for ‘SequentialFuture’ ... done
[09:32:19.074] resolve() on environment ...
[09:32:19.074]  recursive: 0
[09:32:19.074]  elements: [3] ‘a’
[09:32:19.074] resolved() for ‘SequentialFuture’ ...
[09:32:19.074] - state: ‘finished’
[09:32:19.074] - run: TRUE
[09:32:19.075] - result: ‘FutureResult’
[09:32:19.075] resolved() for ‘SequentialFuture’ ... done
[09:32:19.075] Future #1
[09:32:19.075]  length: 2 (resolved future 1)
[09:32:19.075] resolved() for ‘SequentialFuture’ ...
[09:32:19.075] - state: ‘finished’
[09:32:19.075] - run: TRUE
[09:32:19.075] - result: ‘FutureResult’
[09:32:19.075] resolved() for ‘SequentialFuture’ ... done
[09:32:19.075] Future #2
[09:32:19.075]  length: 1 (resolved future 2)
[09:32:19.076]  length: 0 (resolved future 3)
[09:32:19.076] resolve() on environment ... DONE
[09:32:19.076] resolved() for ‘SequentialFuture’ ...
[09:32:19.076] - state: ‘finished’
[09:32:19.076] - run: TRUE
[09:32:19.076] - result: ‘FutureResult’
[09:32:19.076] resolved() for ‘SequentialFuture’ ... done
[09:32:19.077] resolve() on environment ...
[09:32:19.077]  recursive: 0
[09:32:19.077]  elements: [3] ‘b’
[09:32:19.077] resolved() for ‘SequentialFuture’ ...
[09:32:19.077] - state: ‘finished’
[09:32:19.077] - run: TRUE
[09:32:19.077] - result: ‘FutureResult’
[09:32:19.078] resolved() for ‘SequentialFuture’ ... done
[09:32:19.078] Future #1
[09:32:19.078]  length: 2 (resolved future 1)
[09:32:19.078] resolved() for ‘SequentialFuture’ ...
[09:32:19.078] - state: ‘finished’
[09:32:19.078] - run: TRUE
[09:32:19.078] - result: ‘FutureResult’
[09:32:19.078] resolved() for ‘SequentialFuture’ ... done
[09:32:19.078] Future #2
[09:32:19.078]  length: 1 (resolved future 2)
[09:32:19.078]  length: 0 (resolved future 3)
[09:32:19.079] resolve() on environment ... DONE
[09:32:19.080] resolve() on environment ...
[09:32:19.080]  recursive: 0
[09:32:19.080]  elements: [3] ‘c’
[09:32:19.081] resolved() for ‘SequentialFuture’ ...
[09:32:19.081] - state: ‘finished’
[09:32:19.081] - run: TRUE
[09:32:19.081] - result: ‘FutureResult’
[09:32:19.081] resolved() for ‘SequentialFuture’ ... done
[09:32:19.081] Future #1
[09:32:19.081]  length: 2 (resolved future 1)
[09:32:19.081] resolved() for ‘SequentialFuture’ ...
[09:32:19.081] - state: ‘finished’
[09:32:19.081] - run: TRUE
[09:32:19.081] - result: ‘FutureResult’
[09:32:19.082] resolved() for ‘SequentialFuture’ ... done
[09:32:19.082] Future #2
[09:32:19.082]  length: 1 (resolved future 2)
[09:32:19.082]  length: 0 (resolved future 3)
[09:32:19.082] resolve() on environment ... DONE
[09:32:19.082] resolve() on environment ...
[09:32:19.082]  recursive: 0
[09:32:19.083]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[09:32:19.083] resolved() for ‘SequentialFuture’ ...
[09:32:19.083] - state: ‘finished’
[09:32:19.083] - run: TRUE
[09:32:19.083] - result: ‘FutureResult’
[09:32:19.083] resolved() for ‘SequentialFuture’ ... done
[09:32:19.083] Future #1
[09:32:19.084]  length: 2 (resolved future 1)
[09:32:19.084] resolved() for ‘SequentialFuture’ ...
[09:32:19.084] - state: ‘finished’
[09:32:19.084] - run: TRUE
[09:32:19.084] - result: ‘FutureResult’
[09:32:19.084] resolved() for ‘SequentialFuture’ ... done
[09:32:19.084] Future #2
[09:32:19.084]  length: 1 (resolved future 2)
[09:32:19.085]  length: 0 (resolved future 3)
[09:32:19.085] resolve() on environment ... DONE
[09:32:19.085] resolve() on environment ...
[09:32:19.085]  recursive: 99
[09:32:19.086]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:19.086] resolved() for ‘SequentialFuture’ ...
[09:32:19.086] - state: ‘finished’
[09:32:19.086] - run: TRUE
[09:32:19.086] - result: ‘FutureResult’
[09:32:19.086] resolved() for ‘SequentialFuture’ ... done
[09:32:19.086] Future #1
[09:32:19.086] resolved() for ‘SequentialFuture’ ...
[09:32:19.086] - state: ‘finished’
[09:32:19.086] - run: TRUE
[09:32:19.087] - result: ‘FutureResult’
[09:32:19.087] resolved() for ‘SequentialFuture’ ... done
[09:32:19.087] A SequentialFuture was resolved
[09:32:19.087]  length: 2 (resolved future 1)
[09:32:19.087] resolved() for ‘SequentialFuture’ ...
[09:32:19.087] - state: ‘finished’
[09:32:19.087] - run: TRUE
[09:32:19.087] - result: ‘FutureResult’
[09:32:19.087] resolved() for ‘SequentialFuture’ ... done
[09:32:19.087] Future #2
[09:32:19.087] resolved() for ‘SequentialFuture’ ...
[09:32:19.088] - state: ‘finished’
[09:32:19.088] - run: TRUE
[09:32:19.088] - result: ‘FutureResult’
[09:32:19.088] resolved() for ‘SequentialFuture’ ... done
[09:32:19.088] A SequentialFuture was resolved
[09:32:19.088]  length: 1 (resolved future 2)
[09:32:19.088]  length: 0 (resolved future 3)
[09:32:19.088] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[09:32:19.089] resolve() on list environment ...
[09:32:19.089]  recursive: 0
[09:32:19.090]  length: 2
[09:32:19.090]  elements: ‘a’, ‘b’
[09:32:19.090]  length: 1 (resolved future 1)
[09:32:19.090]  length: 0 (resolved future 2)
[09:32:19.090] resolve() on list environment ... DONE
[09:32:19.091] getGlobalsAndPackages() ...
[09:32:19.091] Searching for globals...
[09:32:19.091] 
[09:32:19.091] Searching for globals ... DONE
[09:32:19.091] - globals: [0] <none>
[09:32:19.091] getGlobalsAndPackages() ... DONE
[09:32:19.091] run() for ‘Future’ ...
[09:32:19.091] - state: ‘created’
[09:32:19.092] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.092] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.092]   - Field: ‘label’
[09:32:19.092]   - Field: ‘local’
[09:32:19.092]   - Field: ‘owner’
[09:32:19.092]   - Field: ‘envir’
[09:32:19.092]   - Field: ‘packages’
[09:32:19.092]   - Field: ‘gc’
[09:32:19.093]   - Field: ‘conditions’
[09:32:19.093]   - Field: ‘expr’
[09:32:19.093]   - Field: ‘uuid’
[09:32:19.093]   - Field: ‘seed’
[09:32:19.093]   - Field: ‘version’
[09:32:19.093]   - Field: ‘result’
[09:32:19.093]   - Field: ‘asynchronous’
[09:32:19.093]   - Field: ‘calls’
[09:32:19.093]   - Field: ‘globals’
[09:32:19.093]   - Field: ‘stdout’
[09:32:19.093]   - Field: ‘earlySignal’
[09:32:19.093]   - Field: ‘lazy’
[09:32:19.094]   - Field: ‘state’
[09:32:19.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.094] - Launch lazy future ...
[09:32:19.094] Packages needed by the future expression (n = 0): <none>
[09:32:19.094] Packages needed by future strategies (n = 0): <none>
[09:32:19.094] {
[09:32:19.094]     {
[09:32:19.094]         {
[09:32:19.094]             ...future.startTime <- base::Sys.time()
[09:32:19.094]             {
[09:32:19.094]                 {
[09:32:19.094]                   {
[09:32:19.094]                     base::local({
[09:32:19.094]                       has_future <- base::requireNamespace("future", 
[09:32:19.094]                         quietly = TRUE)
[09:32:19.094]                       if (has_future) {
[09:32:19.094]                         ns <- base::getNamespace("future")
[09:32:19.094]                         version <- ns[[".package"]][["version"]]
[09:32:19.094]                         if (is.null(version)) 
[09:32:19.094]                           version <- utils::packageVersion("future")
[09:32:19.094]                       }
[09:32:19.094]                       else {
[09:32:19.094]                         version <- NULL
[09:32:19.094]                       }
[09:32:19.094]                       if (!has_future || version < "1.8.0") {
[09:32:19.094]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.094]                           "", base::R.version$version.string), 
[09:32:19.094]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.094]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.094]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.094]                             "release", "version")], collapse = " "), 
[09:32:19.094]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.094]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.094]                           info)
[09:32:19.094]                         info <- base::paste(info, collapse = "; ")
[09:32:19.094]                         if (!has_future) {
[09:32:19.094]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.094]                             info)
[09:32:19.094]                         }
[09:32:19.094]                         else {
[09:32:19.094]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.094]                             info, version)
[09:32:19.094]                         }
[09:32:19.094]                         base::stop(msg)
[09:32:19.094]                       }
[09:32:19.094]                     })
[09:32:19.094]                   }
[09:32:19.094]                   ...future.strategy.old <- future::plan("list")
[09:32:19.094]                   options(future.plan = NULL)
[09:32:19.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.094]                 }
[09:32:19.094]                 ...future.workdir <- getwd()
[09:32:19.094]             }
[09:32:19.094]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.094]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.094]         }
[09:32:19.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.094]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.094]             base::names(...future.oldOptions))
[09:32:19.094]     }
[09:32:19.094]     if (FALSE) {
[09:32:19.094]     }
[09:32:19.094]     else {
[09:32:19.094]         if (TRUE) {
[09:32:19.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.094]                 open = "w")
[09:32:19.094]         }
[09:32:19.094]         else {
[09:32:19.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.094]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.094]         }
[09:32:19.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.094]             base::sink(type = "output", split = FALSE)
[09:32:19.094]             base::close(...future.stdout)
[09:32:19.094]         }, add = TRUE)
[09:32:19.094]     }
[09:32:19.094]     ...future.frame <- base::sys.nframe()
[09:32:19.094]     ...future.conditions <- base::list()
[09:32:19.094]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.094]     if (FALSE) {
[09:32:19.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.094]     }
[09:32:19.094]     ...future.result <- base::tryCatch({
[09:32:19.094]         base::withCallingHandlers({
[09:32:19.094]             ...future.value <- base::withVisible(base::local(1))
[09:32:19.094]             future::FutureResult(value = ...future.value$value, 
[09:32:19.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.094]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.094]                     ...future.globalenv.names))
[09:32:19.094]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.094]         }, condition = base::local({
[09:32:19.094]             c <- base::c
[09:32:19.094]             inherits <- base::inherits
[09:32:19.094]             invokeRestart <- base::invokeRestart
[09:32:19.094]             length <- base::length
[09:32:19.094]             list <- base::list
[09:32:19.094]             seq.int <- base::seq.int
[09:32:19.094]             signalCondition <- base::signalCondition
[09:32:19.094]             sys.calls <- base::sys.calls
[09:32:19.094]             `[[` <- base::`[[`
[09:32:19.094]             `+` <- base::`+`
[09:32:19.094]             `<<-` <- base::`<<-`
[09:32:19.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.094]                   3L)]
[09:32:19.094]             }
[09:32:19.094]             function(cond) {
[09:32:19.094]                 is_error <- inherits(cond, "error")
[09:32:19.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.094]                   NULL)
[09:32:19.094]                 if (is_error) {
[09:32:19.094]                   sessionInformation <- function() {
[09:32:19.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.094]                       search = base::search(), system = base::Sys.info())
[09:32:19.094]                   }
[09:32:19.094]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.094]                     cond$call), session = sessionInformation(), 
[09:32:19.094]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.094]                   signalCondition(cond)
[09:32:19.094]                 }
[09:32:19.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.094]                 "immediateCondition"))) {
[09:32:19.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.094]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.094]                   if (TRUE && !signal) {
[09:32:19.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.094]                     {
[09:32:19.094]                       inherits <- base::inherits
[09:32:19.094]                       invokeRestart <- base::invokeRestart
[09:32:19.094]                       is.null <- base::is.null
[09:32:19.094]                       muffled <- FALSE
[09:32:19.094]                       if (inherits(cond, "message")) {
[09:32:19.094]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.094]                         if (muffled) 
[09:32:19.094]                           invokeRestart("muffleMessage")
[09:32:19.094]                       }
[09:32:19.094]                       else if (inherits(cond, "warning")) {
[09:32:19.094]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.094]                         if (muffled) 
[09:32:19.094]                           invokeRestart("muffleWarning")
[09:32:19.094]                       }
[09:32:19.094]                       else if (inherits(cond, "condition")) {
[09:32:19.094]                         if (!is.null(pattern)) {
[09:32:19.094]                           computeRestarts <- base::computeRestarts
[09:32:19.094]                           grepl <- base::grepl
[09:32:19.094]                           restarts <- computeRestarts(cond)
[09:32:19.094]                           for (restart in restarts) {
[09:32:19.094]                             name <- restart$name
[09:32:19.094]                             if (is.null(name)) 
[09:32:19.094]                               next
[09:32:19.094]                             if (!grepl(pattern, name)) 
[09:32:19.094]                               next
[09:32:19.094]                             invokeRestart(restart)
[09:32:19.094]                             muffled <- TRUE
[09:32:19.094]                             break
[09:32:19.094]                           }
[09:32:19.094]                         }
[09:32:19.094]                       }
[09:32:19.094]                       invisible(muffled)
[09:32:19.094]                     }
[09:32:19.094]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.094]                   }
[09:32:19.094]                 }
[09:32:19.094]                 else {
[09:32:19.094]                   if (TRUE) {
[09:32:19.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.094]                     {
[09:32:19.094]                       inherits <- base::inherits
[09:32:19.094]                       invokeRestart <- base::invokeRestart
[09:32:19.094]                       is.null <- base::is.null
[09:32:19.094]                       muffled <- FALSE
[09:32:19.094]                       if (inherits(cond, "message")) {
[09:32:19.094]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.094]                         if (muffled) 
[09:32:19.094]                           invokeRestart("muffleMessage")
[09:32:19.094]                       }
[09:32:19.094]                       else if (inherits(cond, "warning")) {
[09:32:19.094]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.094]                         if (muffled) 
[09:32:19.094]                           invokeRestart("muffleWarning")
[09:32:19.094]                       }
[09:32:19.094]                       else if (inherits(cond, "condition")) {
[09:32:19.094]                         if (!is.null(pattern)) {
[09:32:19.094]                           computeRestarts <- base::computeRestarts
[09:32:19.094]                           grepl <- base::grepl
[09:32:19.094]                           restarts <- computeRestarts(cond)
[09:32:19.094]                           for (restart in restarts) {
[09:32:19.094]                             name <- restart$name
[09:32:19.094]                             if (is.null(name)) 
[09:32:19.094]                               next
[09:32:19.094]                             if (!grepl(pattern, name)) 
[09:32:19.094]                               next
[09:32:19.094]                             invokeRestart(restart)
[09:32:19.094]                             muffled <- TRUE
[09:32:19.094]                             break
[09:32:19.094]                           }
[09:32:19.094]                         }
[09:32:19.094]                       }
[09:32:19.094]                       invisible(muffled)
[09:32:19.094]                     }
[09:32:19.094]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.094]                   }
[09:32:19.094]                 }
[09:32:19.094]             }
[09:32:19.094]         }))
[09:32:19.094]     }, error = function(ex) {
[09:32:19.094]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.094]                 ...future.rng), started = ...future.startTime, 
[09:32:19.094]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.094]             version = "1.8"), class = "FutureResult")
[09:32:19.094]     }, finally = {
[09:32:19.094]         if (!identical(...future.workdir, getwd())) 
[09:32:19.094]             setwd(...future.workdir)
[09:32:19.094]         {
[09:32:19.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.094]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.094]             }
[09:32:19.094]             base::options(...future.oldOptions)
[09:32:19.094]             if (.Platform$OS.type == "windows") {
[09:32:19.094]                 old_names <- names(...future.oldEnvVars)
[09:32:19.094]                 envs <- base::Sys.getenv()
[09:32:19.094]                 names <- names(envs)
[09:32:19.094]                 common <- intersect(names, old_names)
[09:32:19.094]                 added <- setdiff(names, old_names)
[09:32:19.094]                 removed <- setdiff(old_names, names)
[09:32:19.094]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.094]                   envs[common]]
[09:32:19.094]                 NAMES <- toupper(changed)
[09:32:19.094]                 args <- list()
[09:32:19.094]                 for (kk in seq_along(NAMES)) {
[09:32:19.094]                   name <- changed[[kk]]
[09:32:19.094]                   NAME <- NAMES[[kk]]
[09:32:19.094]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.094]                     next
[09:32:19.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.094]                 }
[09:32:19.094]                 NAMES <- toupper(added)
[09:32:19.094]                 for (kk in seq_along(NAMES)) {
[09:32:19.094]                   name <- added[[kk]]
[09:32:19.094]                   NAME <- NAMES[[kk]]
[09:32:19.094]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.094]                     next
[09:32:19.094]                   args[[name]] <- ""
[09:32:19.094]                 }
[09:32:19.094]                 NAMES <- toupper(removed)
[09:32:19.094]                 for (kk in seq_along(NAMES)) {
[09:32:19.094]                   name <- removed[[kk]]
[09:32:19.094]                   NAME <- NAMES[[kk]]
[09:32:19.094]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.094]                     next
[09:32:19.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.094]                 }
[09:32:19.094]                 if (length(args) > 0) 
[09:32:19.094]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.094]             }
[09:32:19.094]             else {
[09:32:19.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.094]             }
[09:32:19.094]             {
[09:32:19.094]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.094]                   0L) {
[09:32:19.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.094]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.094]                   base::options(opts)
[09:32:19.094]                 }
[09:32:19.094]                 {
[09:32:19.094]                   {
[09:32:19.094]                     NULL
[09:32:19.094]                     RNGkind("Mersenne-Twister")
[09:32:19.094]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.094]                       inherits = FALSE)
[09:32:19.094]                   }
[09:32:19.094]                   options(future.plan = NULL)
[09:32:19.094]                   if (is.na(NA_character_)) 
[09:32:19.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.094]                     .init = FALSE)
[09:32:19.094]                 }
[09:32:19.094]             }
[09:32:19.094]         }
[09:32:19.094]     })
[09:32:19.094]     if (TRUE) {
[09:32:19.094]         base::sink(type = "output", split = FALSE)
[09:32:19.094]         if (TRUE) {
[09:32:19.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.094]         }
[09:32:19.094]         else {
[09:32:19.094]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.094]         }
[09:32:19.094]         base::close(...future.stdout)
[09:32:19.094]         ...future.stdout <- NULL
[09:32:19.094]     }
[09:32:19.094]     ...future.result$conditions <- ...future.conditions
[09:32:19.094]     ...future.result$finished <- base::Sys.time()
[09:32:19.094]     ...future.result
[09:32:19.094] }
[09:32:19.096] plan(): Setting new future strategy stack:
[09:32:19.096] List of future strategies:
[09:32:19.096] 1. sequential:
[09:32:19.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.096]    - tweaked: FALSE
[09:32:19.096]    - call: NULL
[09:32:19.097] plan(): nbrOfWorkers() = 1
[09:32:19.097] plan(): Setting new future strategy stack:
[09:32:19.097] List of future strategies:
[09:32:19.097] 1. sequential:
[09:32:19.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.097]    - tweaked: FALSE
[09:32:19.097]    - call: plan(strategy)
[09:32:19.098] plan(): nbrOfWorkers() = 1
[09:32:19.098] SequentialFuture started (and completed)
[09:32:19.098] - Launch lazy future ... done
[09:32:19.098] run() for ‘SequentialFuture’ ... done
[09:32:19.098] getGlobalsAndPackages() ...
[09:32:19.098] Searching for globals...
[09:32:19.099] 
[09:32:19.099] Searching for globals ... DONE
[09:32:19.099] - globals: [0] <none>
[09:32:19.099] getGlobalsAndPackages() ... DONE
[09:32:19.099] run() for ‘Future’ ...
[09:32:19.099] - state: ‘created’
[09:32:19.099] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.099] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.100]   - Field: ‘label’
[09:32:19.100]   - Field: ‘local’
[09:32:19.100]   - Field: ‘owner’
[09:32:19.100]   - Field: ‘envir’
[09:32:19.100]   - Field: ‘packages’
[09:32:19.100]   - Field: ‘gc’
[09:32:19.100]   - Field: ‘conditions’
[09:32:19.100]   - Field: ‘expr’
[09:32:19.100]   - Field: ‘uuid’
[09:32:19.100]   - Field: ‘seed’
[09:32:19.101]   - Field: ‘version’
[09:32:19.101]   - Field: ‘result’
[09:32:19.101]   - Field: ‘asynchronous’
[09:32:19.101]   - Field: ‘calls’
[09:32:19.101]   - Field: ‘globals’
[09:32:19.101]   - Field: ‘stdout’
[09:32:19.101]   - Field: ‘earlySignal’
[09:32:19.101]   - Field: ‘lazy’
[09:32:19.101]   - Field: ‘state’
[09:32:19.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.101] - Launch lazy future ...
[09:32:19.102] Packages needed by the future expression (n = 0): <none>
[09:32:19.102] Packages needed by future strategies (n = 0): <none>
[09:32:19.102] {
[09:32:19.102]     {
[09:32:19.102]         {
[09:32:19.102]             ...future.startTime <- base::Sys.time()
[09:32:19.102]             {
[09:32:19.102]                 {
[09:32:19.102]                   {
[09:32:19.102]                     base::local({
[09:32:19.102]                       has_future <- base::requireNamespace("future", 
[09:32:19.102]                         quietly = TRUE)
[09:32:19.102]                       if (has_future) {
[09:32:19.102]                         ns <- base::getNamespace("future")
[09:32:19.102]                         version <- ns[[".package"]][["version"]]
[09:32:19.102]                         if (is.null(version)) 
[09:32:19.102]                           version <- utils::packageVersion("future")
[09:32:19.102]                       }
[09:32:19.102]                       else {
[09:32:19.102]                         version <- NULL
[09:32:19.102]                       }
[09:32:19.102]                       if (!has_future || version < "1.8.0") {
[09:32:19.102]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.102]                           "", base::R.version$version.string), 
[09:32:19.102]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.102]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.102]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.102]                             "release", "version")], collapse = " "), 
[09:32:19.102]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.102]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.102]                           info)
[09:32:19.102]                         info <- base::paste(info, collapse = "; ")
[09:32:19.102]                         if (!has_future) {
[09:32:19.102]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.102]                             info)
[09:32:19.102]                         }
[09:32:19.102]                         else {
[09:32:19.102]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.102]                             info, version)
[09:32:19.102]                         }
[09:32:19.102]                         base::stop(msg)
[09:32:19.102]                       }
[09:32:19.102]                     })
[09:32:19.102]                   }
[09:32:19.102]                   ...future.strategy.old <- future::plan("list")
[09:32:19.102]                   options(future.plan = NULL)
[09:32:19.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.102]                 }
[09:32:19.102]                 ...future.workdir <- getwd()
[09:32:19.102]             }
[09:32:19.102]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.102]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.102]         }
[09:32:19.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.102]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.102]             base::names(...future.oldOptions))
[09:32:19.102]     }
[09:32:19.102]     if (FALSE) {
[09:32:19.102]     }
[09:32:19.102]     else {
[09:32:19.102]         if (TRUE) {
[09:32:19.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.102]                 open = "w")
[09:32:19.102]         }
[09:32:19.102]         else {
[09:32:19.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.102]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.102]         }
[09:32:19.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.102]             base::sink(type = "output", split = FALSE)
[09:32:19.102]             base::close(...future.stdout)
[09:32:19.102]         }, add = TRUE)
[09:32:19.102]     }
[09:32:19.102]     ...future.frame <- base::sys.nframe()
[09:32:19.102]     ...future.conditions <- base::list()
[09:32:19.102]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.102]     if (FALSE) {
[09:32:19.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.102]     }
[09:32:19.102]     ...future.result <- base::tryCatch({
[09:32:19.102]         base::withCallingHandlers({
[09:32:19.102]             ...future.value <- base::withVisible(base::local(2))
[09:32:19.102]             future::FutureResult(value = ...future.value$value, 
[09:32:19.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.102]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.102]                     ...future.globalenv.names))
[09:32:19.102]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.102]         }, condition = base::local({
[09:32:19.102]             c <- base::c
[09:32:19.102]             inherits <- base::inherits
[09:32:19.102]             invokeRestart <- base::invokeRestart
[09:32:19.102]             length <- base::length
[09:32:19.102]             list <- base::list
[09:32:19.102]             seq.int <- base::seq.int
[09:32:19.102]             signalCondition <- base::signalCondition
[09:32:19.102]             sys.calls <- base::sys.calls
[09:32:19.102]             `[[` <- base::`[[`
[09:32:19.102]             `+` <- base::`+`
[09:32:19.102]             `<<-` <- base::`<<-`
[09:32:19.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.102]                   3L)]
[09:32:19.102]             }
[09:32:19.102]             function(cond) {
[09:32:19.102]                 is_error <- inherits(cond, "error")
[09:32:19.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.102]                   NULL)
[09:32:19.102]                 if (is_error) {
[09:32:19.102]                   sessionInformation <- function() {
[09:32:19.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.102]                       search = base::search(), system = base::Sys.info())
[09:32:19.102]                   }
[09:32:19.102]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.102]                     cond$call), session = sessionInformation(), 
[09:32:19.102]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.102]                   signalCondition(cond)
[09:32:19.102]                 }
[09:32:19.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.102]                 "immediateCondition"))) {
[09:32:19.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.102]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.102]                   if (TRUE && !signal) {
[09:32:19.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.102]                     {
[09:32:19.102]                       inherits <- base::inherits
[09:32:19.102]                       invokeRestart <- base::invokeRestart
[09:32:19.102]                       is.null <- base::is.null
[09:32:19.102]                       muffled <- FALSE
[09:32:19.102]                       if (inherits(cond, "message")) {
[09:32:19.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.102]                         if (muffled) 
[09:32:19.102]                           invokeRestart("muffleMessage")
[09:32:19.102]                       }
[09:32:19.102]                       else if (inherits(cond, "warning")) {
[09:32:19.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.102]                         if (muffled) 
[09:32:19.102]                           invokeRestart("muffleWarning")
[09:32:19.102]                       }
[09:32:19.102]                       else if (inherits(cond, "condition")) {
[09:32:19.102]                         if (!is.null(pattern)) {
[09:32:19.102]                           computeRestarts <- base::computeRestarts
[09:32:19.102]                           grepl <- base::grepl
[09:32:19.102]                           restarts <- computeRestarts(cond)
[09:32:19.102]                           for (restart in restarts) {
[09:32:19.102]                             name <- restart$name
[09:32:19.102]                             if (is.null(name)) 
[09:32:19.102]                               next
[09:32:19.102]                             if (!grepl(pattern, name)) 
[09:32:19.102]                               next
[09:32:19.102]                             invokeRestart(restart)
[09:32:19.102]                             muffled <- TRUE
[09:32:19.102]                             break
[09:32:19.102]                           }
[09:32:19.102]                         }
[09:32:19.102]                       }
[09:32:19.102]                       invisible(muffled)
[09:32:19.102]                     }
[09:32:19.102]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.102]                   }
[09:32:19.102]                 }
[09:32:19.102]                 else {
[09:32:19.102]                   if (TRUE) {
[09:32:19.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.102]                     {
[09:32:19.102]                       inherits <- base::inherits
[09:32:19.102]                       invokeRestart <- base::invokeRestart
[09:32:19.102]                       is.null <- base::is.null
[09:32:19.102]                       muffled <- FALSE
[09:32:19.102]                       if (inherits(cond, "message")) {
[09:32:19.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.102]                         if (muffled) 
[09:32:19.102]                           invokeRestart("muffleMessage")
[09:32:19.102]                       }
[09:32:19.102]                       else if (inherits(cond, "warning")) {
[09:32:19.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.102]                         if (muffled) 
[09:32:19.102]                           invokeRestart("muffleWarning")
[09:32:19.102]                       }
[09:32:19.102]                       else if (inherits(cond, "condition")) {
[09:32:19.102]                         if (!is.null(pattern)) {
[09:32:19.102]                           computeRestarts <- base::computeRestarts
[09:32:19.102]                           grepl <- base::grepl
[09:32:19.102]                           restarts <- computeRestarts(cond)
[09:32:19.102]                           for (restart in restarts) {
[09:32:19.102]                             name <- restart$name
[09:32:19.102]                             if (is.null(name)) 
[09:32:19.102]                               next
[09:32:19.102]                             if (!grepl(pattern, name)) 
[09:32:19.102]                               next
[09:32:19.102]                             invokeRestart(restart)
[09:32:19.102]                             muffled <- TRUE
[09:32:19.102]                             break
[09:32:19.102]                           }
[09:32:19.102]                         }
[09:32:19.102]                       }
[09:32:19.102]                       invisible(muffled)
[09:32:19.102]                     }
[09:32:19.102]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.102]                   }
[09:32:19.102]                 }
[09:32:19.102]             }
[09:32:19.102]         }))
[09:32:19.102]     }, error = function(ex) {
[09:32:19.102]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.102]                 ...future.rng), started = ...future.startTime, 
[09:32:19.102]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.102]             version = "1.8"), class = "FutureResult")
[09:32:19.102]     }, finally = {
[09:32:19.102]         if (!identical(...future.workdir, getwd())) 
[09:32:19.102]             setwd(...future.workdir)
[09:32:19.102]         {
[09:32:19.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.102]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.102]             }
[09:32:19.102]             base::options(...future.oldOptions)
[09:32:19.102]             if (.Platform$OS.type == "windows") {
[09:32:19.102]                 old_names <- names(...future.oldEnvVars)
[09:32:19.102]                 envs <- base::Sys.getenv()
[09:32:19.102]                 names <- names(envs)
[09:32:19.102]                 common <- intersect(names, old_names)
[09:32:19.102]                 added <- setdiff(names, old_names)
[09:32:19.102]                 removed <- setdiff(old_names, names)
[09:32:19.102]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.102]                   envs[common]]
[09:32:19.102]                 NAMES <- toupper(changed)
[09:32:19.102]                 args <- list()
[09:32:19.102]                 for (kk in seq_along(NAMES)) {
[09:32:19.102]                   name <- changed[[kk]]
[09:32:19.102]                   NAME <- NAMES[[kk]]
[09:32:19.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.102]                     next
[09:32:19.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.102]                 }
[09:32:19.102]                 NAMES <- toupper(added)
[09:32:19.102]                 for (kk in seq_along(NAMES)) {
[09:32:19.102]                   name <- added[[kk]]
[09:32:19.102]                   NAME <- NAMES[[kk]]
[09:32:19.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.102]                     next
[09:32:19.102]                   args[[name]] <- ""
[09:32:19.102]                 }
[09:32:19.102]                 NAMES <- toupper(removed)
[09:32:19.102]                 for (kk in seq_along(NAMES)) {
[09:32:19.102]                   name <- removed[[kk]]
[09:32:19.102]                   NAME <- NAMES[[kk]]
[09:32:19.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.102]                     next
[09:32:19.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.102]                 }
[09:32:19.102]                 if (length(args) > 0) 
[09:32:19.102]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.102]             }
[09:32:19.102]             else {
[09:32:19.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.102]             }
[09:32:19.102]             {
[09:32:19.102]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.102]                   0L) {
[09:32:19.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.102]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.102]                   base::options(opts)
[09:32:19.102]                 }
[09:32:19.102]                 {
[09:32:19.102]                   {
[09:32:19.102]                     NULL
[09:32:19.102]                     RNGkind("Mersenne-Twister")
[09:32:19.102]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.102]                       inherits = FALSE)
[09:32:19.102]                   }
[09:32:19.102]                   options(future.plan = NULL)
[09:32:19.102]                   if (is.na(NA_character_)) 
[09:32:19.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.102]                     .init = FALSE)
[09:32:19.102]                 }
[09:32:19.102]             }
[09:32:19.102]         }
[09:32:19.102]     })
[09:32:19.102]     if (TRUE) {
[09:32:19.102]         base::sink(type = "output", split = FALSE)
[09:32:19.102]         if (TRUE) {
[09:32:19.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.102]         }
[09:32:19.102]         else {
[09:32:19.102]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.102]         }
[09:32:19.102]         base::close(...future.stdout)
[09:32:19.102]         ...future.stdout <- NULL
[09:32:19.102]     }
[09:32:19.102]     ...future.result$conditions <- ...future.conditions
[09:32:19.102]     ...future.result$finished <- base::Sys.time()
[09:32:19.102]     ...future.result
[09:32:19.102] }
[09:32:19.104] plan(): Setting new future strategy stack:
[09:32:19.104] List of future strategies:
[09:32:19.104] 1. sequential:
[09:32:19.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.104]    - tweaked: FALSE
[09:32:19.104]    - call: NULL
[09:32:19.104] plan(): nbrOfWorkers() = 1
[09:32:19.106] plan(): Setting new future strategy stack:
[09:32:19.106] List of future strategies:
[09:32:19.106] 1. sequential:
[09:32:19.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.106]    - tweaked: FALSE
[09:32:19.106]    - call: plan(strategy)
[09:32:19.106] plan(): nbrOfWorkers() = 1
[09:32:19.107] SequentialFuture started (and completed)
[09:32:19.107] - Launch lazy future ... done
[09:32:19.107] run() for ‘SequentialFuture’ ... done
[09:32:19.107] resolve() on list environment ...
[09:32:19.107]  recursive: 0
[09:32:19.108]  length: 3
[09:32:19.108]  elements: ‘a’, ‘b’, ‘c’
[09:32:19.108] resolved() for ‘SequentialFuture’ ...
[09:32:19.108] - state: ‘finished’
[09:32:19.108] - run: TRUE
[09:32:19.108] - result: ‘FutureResult’
[09:32:19.109] resolved() for ‘SequentialFuture’ ... done
[09:32:19.109] Future #1
[09:32:19.109]  length: 2 (resolved future 1)
[09:32:19.109] resolved() for ‘SequentialFuture’ ...
[09:32:19.109] - state: ‘finished’
[09:32:19.109] - run: TRUE
[09:32:19.109] - result: ‘FutureResult’
[09:32:19.109] resolved() for ‘SequentialFuture’ ... done
[09:32:19.109] Future #2
[09:32:19.109]  length: 1 (resolved future 2)
[09:32:19.109]  length: 0 (resolved future 3)
[09:32:19.110] resolve() on list environment ... DONE
[09:32:19.110] getGlobalsAndPackages() ...
[09:32:19.110] Searching for globals...
[09:32:19.111] - globals found: [1] ‘{’
[09:32:19.111] Searching for globals ... DONE
[09:32:19.111] Resolving globals: FALSE
[09:32:19.111] 
[09:32:19.111] 
[09:32:19.111] getGlobalsAndPackages() ... DONE
[09:32:19.112] run() for ‘Future’ ...
[09:32:19.112] - state: ‘created’
[09:32:19.112] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.112] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.112] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.112]   - Field: ‘label’
[09:32:19.112]   - Field: ‘local’
[09:32:19.112]   - Field: ‘owner’
[09:32:19.113]   - Field: ‘envir’
[09:32:19.113]   - Field: ‘packages’
[09:32:19.113]   - Field: ‘gc’
[09:32:19.113]   - Field: ‘conditions’
[09:32:19.113]   - Field: ‘expr’
[09:32:19.113]   - Field: ‘uuid’
[09:32:19.113]   - Field: ‘seed’
[09:32:19.113]   - Field: ‘version’
[09:32:19.113]   - Field: ‘result’
[09:32:19.113]   - Field: ‘asynchronous’
[09:32:19.113]   - Field: ‘calls’
[09:32:19.113]   - Field: ‘globals’
[09:32:19.114]   - Field: ‘stdout’
[09:32:19.114]   - Field: ‘earlySignal’
[09:32:19.114]   - Field: ‘lazy’
[09:32:19.114]   - Field: ‘state’
[09:32:19.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.114] - Launch lazy future ...
[09:32:19.114] Packages needed by the future expression (n = 0): <none>
[09:32:19.114] Packages needed by future strategies (n = 0): <none>
[09:32:19.115] {
[09:32:19.115]     {
[09:32:19.115]         {
[09:32:19.115]             ...future.startTime <- base::Sys.time()
[09:32:19.115]             {
[09:32:19.115]                 {
[09:32:19.115]                   {
[09:32:19.115]                     base::local({
[09:32:19.115]                       has_future <- base::requireNamespace("future", 
[09:32:19.115]                         quietly = TRUE)
[09:32:19.115]                       if (has_future) {
[09:32:19.115]                         ns <- base::getNamespace("future")
[09:32:19.115]                         version <- ns[[".package"]][["version"]]
[09:32:19.115]                         if (is.null(version)) 
[09:32:19.115]                           version <- utils::packageVersion("future")
[09:32:19.115]                       }
[09:32:19.115]                       else {
[09:32:19.115]                         version <- NULL
[09:32:19.115]                       }
[09:32:19.115]                       if (!has_future || version < "1.8.0") {
[09:32:19.115]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.115]                           "", base::R.version$version.string), 
[09:32:19.115]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.115]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.115]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.115]                             "release", "version")], collapse = " "), 
[09:32:19.115]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.115]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.115]                           info)
[09:32:19.115]                         info <- base::paste(info, collapse = "; ")
[09:32:19.115]                         if (!has_future) {
[09:32:19.115]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.115]                             info)
[09:32:19.115]                         }
[09:32:19.115]                         else {
[09:32:19.115]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.115]                             info, version)
[09:32:19.115]                         }
[09:32:19.115]                         base::stop(msg)
[09:32:19.115]                       }
[09:32:19.115]                     })
[09:32:19.115]                   }
[09:32:19.115]                   ...future.strategy.old <- future::plan("list")
[09:32:19.115]                   options(future.plan = NULL)
[09:32:19.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.115]                 }
[09:32:19.115]                 ...future.workdir <- getwd()
[09:32:19.115]             }
[09:32:19.115]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.115]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.115]         }
[09:32:19.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.115]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.115]             base::names(...future.oldOptions))
[09:32:19.115]     }
[09:32:19.115]     if (FALSE) {
[09:32:19.115]     }
[09:32:19.115]     else {
[09:32:19.115]         if (TRUE) {
[09:32:19.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.115]                 open = "w")
[09:32:19.115]         }
[09:32:19.115]         else {
[09:32:19.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.115]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.115]         }
[09:32:19.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.115]             base::sink(type = "output", split = FALSE)
[09:32:19.115]             base::close(...future.stdout)
[09:32:19.115]         }, add = TRUE)
[09:32:19.115]     }
[09:32:19.115]     ...future.frame <- base::sys.nframe()
[09:32:19.115]     ...future.conditions <- base::list()
[09:32:19.115]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.115]     if (FALSE) {
[09:32:19.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.115]     }
[09:32:19.115]     ...future.result <- base::tryCatch({
[09:32:19.115]         base::withCallingHandlers({
[09:32:19.115]             ...future.value <- base::withVisible(base::local({
[09:32:19.115]                 1
[09:32:19.115]             }))
[09:32:19.115]             future::FutureResult(value = ...future.value$value, 
[09:32:19.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.115]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.115]                     ...future.globalenv.names))
[09:32:19.115]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.115]         }, condition = base::local({
[09:32:19.115]             c <- base::c
[09:32:19.115]             inherits <- base::inherits
[09:32:19.115]             invokeRestart <- base::invokeRestart
[09:32:19.115]             length <- base::length
[09:32:19.115]             list <- base::list
[09:32:19.115]             seq.int <- base::seq.int
[09:32:19.115]             signalCondition <- base::signalCondition
[09:32:19.115]             sys.calls <- base::sys.calls
[09:32:19.115]             `[[` <- base::`[[`
[09:32:19.115]             `+` <- base::`+`
[09:32:19.115]             `<<-` <- base::`<<-`
[09:32:19.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.115]                   3L)]
[09:32:19.115]             }
[09:32:19.115]             function(cond) {
[09:32:19.115]                 is_error <- inherits(cond, "error")
[09:32:19.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.115]                   NULL)
[09:32:19.115]                 if (is_error) {
[09:32:19.115]                   sessionInformation <- function() {
[09:32:19.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.115]                       search = base::search(), system = base::Sys.info())
[09:32:19.115]                   }
[09:32:19.115]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.115]                     cond$call), session = sessionInformation(), 
[09:32:19.115]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.115]                   signalCondition(cond)
[09:32:19.115]                 }
[09:32:19.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.115]                 "immediateCondition"))) {
[09:32:19.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.115]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.115]                   if (TRUE && !signal) {
[09:32:19.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.115]                     {
[09:32:19.115]                       inherits <- base::inherits
[09:32:19.115]                       invokeRestart <- base::invokeRestart
[09:32:19.115]                       is.null <- base::is.null
[09:32:19.115]                       muffled <- FALSE
[09:32:19.115]                       if (inherits(cond, "message")) {
[09:32:19.115]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.115]                         if (muffled) 
[09:32:19.115]                           invokeRestart("muffleMessage")
[09:32:19.115]                       }
[09:32:19.115]                       else if (inherits(cond, "warning")) {
[09:32:19.115]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.115]                         if (muffled) 
[09:32:19.115]                           invokeRestart("muffleWarning")
[09:32:19.115]                       }
[09:32:19.115]                       else if (inherits(cond, "condition")) {
[09:32:19.115]                         if (!is.null(pattern)) {
[09:32:19.115]                           computeRestarts <- base::computeRestarts
[09:32:19.115]                           grepl <- base::grepl
[09:32:19.115]                           restarts <- computeRestarts(cond)
[09:32:19.115]                           for (restart in restarts) {
[09:32:19.115]                             name <- restart$name
[09:32:19.115]                             if (is.null(name)) 
[09:32:19.115]                               next
[09:32:19.115]                             if (!grepl(pattern, name)) 
[09:32:19.115]                               next
[09:32:19.115]                             invokeRestart(restart)
[09:32:19.115]                             muffled <- TRUE
[09:32:19.115]                             break
[09:32:19.115]                           }
[09:32:19.115]                         }
[09:32:19.115]                       }
[09:32:19.115]                       invisible(muffled)
[09:32:19.115]                     }
[09:32:19.115]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.115]                   }
[09:32:19.115]                 }
[09:32:19.115]                 else {
[09:32:19.115]                   if (TRUE) {
[09:32:19.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.115]                     {
[09:32:19.115]                       inherits <- base::inherits
[09:32:19.115]                       invokeRestart <- base::invokeRestart
[09:32:19.115]                       is.null <- base::is.null
[09:32:19.115]                       muffled <- FALSE
[09:32:19.115]                       if (inherits(cond, "message")) {
[09:32:19.115]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.115]                         if (muffled) 
[09:32:19.115]                           invokeRestart("muffleMessage")
[09:32:19.115]                       }
[09:32:19.115]                       else if (inherits(cond, "warning")) {
[09:32:19.115]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.115]                         if (muffled) 
[09:32:19.115]                           invokeRestart("muffleWarning")
[09:32:19.115]                       }
[09:32:19.115]                       else if (inherits(cond, "condition")) {
[09:32:19.115]                         if (!is.null(pattern)) {
[09:32:19.115]                           computeRestarts <- base::computeRestarts
[09:32:19.115]                           grepl <- base::grepl
[09:32:19.115]                           restarts <- computeRestarts(cond)
[09:32:19.115]                           for (restart in restarts) {
[09:32:19.115]                             name <- restart$name
[09:32:19.115]                             if (is.null(name)) 
[09:32:19.115]                               next
[09:32:19.115]                             if (!grepl(pattern, name)) 
[09:32:19.115]                               next
[09:32:19.115]                             invokeRestart(restart)
[09:32:19.115]                             muffled <- TRUE
[09:32:19.115]                             break
[09:32:19.115]                           }
[09:32:19.115]                         }
[09:32:19.115]                       }
[09:32:19.115]                       invisible(muffled)
[09:32:19.115]                     }
[09:32:19.115]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.115]                   }
[09:32:19.115]                 }
[09:32:19.115]             }
[09:32:19.115]         }))
[09:32:19.115]     }, error = function(ex) {
[09:32:19.115]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.115]                 ...future.rng), started = ...future.startTime, 
[09:32:19.115]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.115]             version = "1.8"), class = "FutureResult")
[09:32:19.115]     }, finally = {
[09:32:19.115]         if (!identical(...future.workdir, getwd())) 
[09:32:19.115]             setwd(...future.workdir)
[09:32:19.115]         {
[09:32:19.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.115]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.115]             }
[09:32:19.115]             base::options(...future.oldOptions)
[09:32:19.115]             if (.Platform$OS.type == "windows") {
[09:32:19.115]                 old_names <- names(...future.oldEnvVars)
[09:32:19.115]                 envs <- base::Sys.getenv()
[09:32:19.115]                 names <- names(envs)
[09:32:19.115]                 common <- intersect(names, old_names)
[09:32:19.115]                 added <- setdiff(names, old_names)
[09:32:19.115]                 removed <- setdiff(old_names, names)
[09:32:19.115]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.115]                   envs[common]]
[09:32:19.115]                 NAMES <- toupper(changed)
[09:32:19.115]                 args <- list()
[09:32:19.115]                 for (kk in seq_along(NAMES)) {
[09:32:19.115]                   name <- changed[[kk]]
[09:32:19.115]                   NAME <- NAMES[[kk]]
[09:32:19.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.115]                     next
[09:32:19.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.115]                 }
[09:32:19.115]                 NAMES <- toupper(added)
[09:32:19.115]                 for (kk in seq_along(NAMES)) {
[09:32:19.115]                   name <- added[[kk]]
[09:32:19.115]                   NAME <- NAMES[[kk]]
[09:32:19.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.115]                     next
[09:32:19.115]                   args[[name]] <- ""
[09:32:19.115]                 }
[09:32:19.115]                 NAMES <- toupper(removed)
[09:32:19.115]                 for (kk in seq_along(NAMES)) {
[09:32:19.115]                   name <- removed[[kk]]
[09:32:19.115]                   NAME <- NAMES[[kk]]
[09:32:19.115]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.115]                     next
[09:32:19.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.115]                 }
[09:32:19.115]                 if (length(args) > 0) 
[09:32:19.115]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.115]             }
[09:32:19.115]             else {
[09:32:19.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.115]             }
[09:32:19.115]             {
[09:32:19.115]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.115]                   0L) {
[09:32:19.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.115]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.115]                   base::options(opts)
[09:32:19.115]                 }
[09:32:19.115]                 {
[09:32:19.115]                   {
[09:32:19.115]                     NULL
[09:32:19.115]                     RNGkind("Mersenne-Twister")
[09:32:19.115]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.115]                       inherits = FALSE)
[09:32:19.115]                   }
[09:32:19.115]                   options(future.plan = NULL)
[09:32:19.115]                   if (is.na(NA_character_)) 
[09:32:19.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.115]                     .init = FALSE)
[09:32:19.115]                 }
[09:32:19.115]             }
[09:32:19.115]         }
[09:32:19.115]     })
[09:32:19.115]     if (TRUE) {
[09:32:19.115]         base::sink(type = "output", split = FALSE)
[09:32:19.115]         if (TRUE) {
[09:32:19.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.115]         }
[09:32:19.115]         else {
[09:32:19.115]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.115]         }
[09:32:19.115]         base::close(...future.stdout)
[09:32:19.115]         ...future.stdout <- NULL
[09:32:19.115]     }
[09:32:19.115]     ...future.result$conditions <- ...future.conditions
[09:32:19.115]     ...future.result$finished <- base::Sys.time()
[09:32:19.115]     ...future.result
[09:32:19.115] }
[09:32:19.116] plan(): Setting new future strategy stack:
[09:32:19.116] List of future strategies:
[09:32:19.116] 1. sequential:
[09:32:19.116]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.116]    - tweaked: FALSE
[09:32:19.116]    - call: NULL
[09:32:19.117] plan(): nbrOfWorkers() = 1
[09:32:19.117] plan(): Setting new future strategy stack:
[09:32:19.117] List of future strategies:
[09:32:19.117] 1. sequential:
[09:32:19.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.117]    - tweaked: FALSE
[09:32:19.117]    - call: plan(strategy)
[09:32:19.118] plan(): nbrOfWorkers() = 1
[09:32:19.118] SequentialFuture started (and completed)
[09:32:19.118] - Launch lazy future ... done
[09:32:19.118] run() for ‘SequentialFuture’ ... done
[09:32:19.119] getGlobalsAndPackages() ...
[09:32:19.119] Searching for globals...
[09:32:19.119] - globals found: [1] ‘{’
[09:32:19.119] Searching for globals ... DONE
[09:32:19.119] Resolving globals: FALSE
[09:32:19.120] 
[09:32:19.120] 
[09:32:19.120] getGlobalsAndPackages() ... DONE
[09:32:19.120] run() for ‘Future’ ...
[09:32:19.120] - state: ‘created’
[09:32:19.120] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.120] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.120] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.121]   - Field: ‘label’
[09:32:19.121]   - Field: ‘local’
[09:32:19.121]   - Field: ‘owner’
[09:32:19.121]   - Field: ‘envir’
[09:32:19.121]   - Field: ‘packages’
[09:32:19.121]   - Field: ‘gc’
[09:32:19.121]   - Field: ‘conditions’
[09:32:19.121]   - Field: ‘expr’
[09:32:19.121]   - Field: ‘uuid’
[09:32:19.121]   - Field: ‘seed’
[09:32:19.121]   - Field: ‘version’
[09:32:19.122]   - Field: ‘result’
[09:32:19.122]   - Field: ‘asynchronous’
[09:32:19.122]   - Field: ‘calls’
[09:32:19.122]   - Field: ‘globals’
[09:32:19.122]   - Field: ‘stdout’
[09:32:19.122]   - Field: ‘earlySignal’
[09:32:19.122]   - Field: ‘lazy’
[09:32:19.122]   - Field: ‘state’
[09:32:19.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.122] - Launch lazy future ...
[09:32:19.122] Packages needed by the future expression (n = 0): <none>
[09:32:19.123] Packages needed by future strategies (n = 0): <none>
[09:32:19.123] {
[09:32:19.123]     {
[09:32:19.123]         {
[09:32:19.123]             ...future.startTime <- base::Sys.time()
[09:32:19.123]             {
[09:32:19.123]                 {
[09:32:19.123]                   {
[09:32:19.123]                     base::local({
[09:32:19.123]                       has_future <- base::requireNamespace("future", 
[09:32:19.123]                         quietly = TRUE)
[09:32:19.123]                       if (has_future) {
[09:32:19.123]                         ns <- base::getNamespace("future")
[09:32:19.123]                         version <- ns[[".package"]][["version"]]
[09:32:19.123]                         if (is.null(version)) 
[09:32:19.123]                           version <- utils::packageVersion("future")
[09:32:19.123]                       }
[09:32:19.123]                       else {
[09:32:19.123]                         version <- NULL
[09:32:19.123]                       }
[09:32:19.123]                       if (!has_future || version < "1.8.0") {
[09:32:19.123]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.123]                           "", base::R.version$version.string), 
[09:32:19.123]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.123]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.123]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.123]                             "release", "version")], collapse = " "), 
[09:32:19.123]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.123]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.123]                           info)
[09:32:19.123]                         info <- base::paste(info, collapse = "; ")
[09:32:19.123]                         if (!has_future) {
[09:32:19.123]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.123]                             info)
[09:32:19.123]                         }
[09:32:19.123]                         else {
[09:32:19.123]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.123]                             info, version)
[09:32:19.123]                         }
[09:32:19.123]                         base::stop(msg)
[09:32:19.123]                       }
[09:32:19.123]                     })
[09:32:19.123]                   }
[09:32:19.123]                   ...future.strategy.old <- future::plan("list")
[09:32:19.123]                   options(future.plan = NULL)
[09:32:19.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.123]                 }
[09:32:19.123]                 ...future.workdir <- getwd()
[09:32:19.123]             }
[09:32:19.123]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.123]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.123]         }
[09:32:19.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.123]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.123]             base::names(...future.oldOptions))
[09:32:19.123]     }
[09:32:19.123]     if (FALSE) {
[09:32:19.123]     }
[09:32:19.123]     else {
[09:32:19.123]         if (TRUE) {
[09:32:19.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.123]                 open = "w")
[09:32:19.123]         }
[09:32:19.123]         else {
[09:32:19.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.123]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.123]         }
[09:32:19.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.123]             base::sink(type = "output", split = FALSE)
[09:32:19.123]             base::close(...future.stdout)
[09:32:19.123]         }, add = TRUE)
[09:32:19.123]     }
[09:32:19.123]     ...future.frame <- base::sys.nframe()
[09:32:19.123]     ...future.conditions <- base::list()
[09:32:19.123]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.123]     if (FALSE) {
[09:32:19.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.123]     }
[09:32:19.123]     ...future.result <- base::tryCatch({
[09:32:19.123]         base::withCallingHandlers({
[09:32:19.123]             ...future.value <- base::withVisible(base::local({
[09:32:19.123]                 2
[09:32:19.123]             }))
[09:32:19.123]             future::FutureResult(value = ...future.value$value, 
[09:32:19.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.123]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.123]                     ...future.globalenv.names))
[09:32:19.123]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.123]         }, condition = base::local({
[09:32:19.123]             c <- base::c
[09:32:19.123]             inherits <- base::inherits
[09:32:19.123]             invokeRestart <- base::invokeRestart
[09:32:19.123]             length <- base::length
[09:32:19.123]             list <- base::list
[09:32:19.123]             seq.int <- base::seq.int
[09:32:19.123]             signalCondition <- base::signalCondition
[09:32:19.123]             sys.calls <- base::sys.calls
[09:32:19.123]             `[[` <- base::`[[`
[09:32:19.123]             `+` <- base::`+`
[09:32:19.123]             `<<-` <- base::`<<-`
[09:32:19.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.123]                   3L)]
[09:32:19.123]             }
[09:32:19.123]             function(cond) {
[09:32:19.123]                 is_error <- inherits(cond, "error")
[09:32:19.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.123]                   NULL)
[09:32:19.123]                 if (is_error) {
[09:32:19.123]                   sessionInformation <- function() {
[09:32:19.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.123]                       search = base::search(), system = base::Sys.info())
[09:32:19.123]                   }
[09:32:19.123]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.123]                     cond$call), session = sessionInformation(), 
[09:32:19.123]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.123]                   signalCondition(cond)
[09:32:19.123]                 }
[09:32:19.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.123]                 "immediateCondition"))) {
[09:32:19.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.123]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.123]                   if (TRUE && !signal) {
[09:32:19.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.123]                     {
[09:32:19.123]                       inherits <- base::inherits
[09:32:19.123]                       invokeRestart <- base::invokeRestart
[09:32:19.123]                       is.null <- base::is.null
[09:32:19.123]                       muffled <- FALSE
[09:32:19.123]                       if (inherits(cond, "message")) {
[09:32:19.123]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.123]                         if (muffled) 
[09:32:19.123]                           invokeRestart("muffleMessage")
[09:32:19.123]                       }
[09:32:19.123]                       else if (inherits(cond, "warning")) {
[09:32:19.123]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.123]                         if (muffled) 
[09:32:19.123]                           invokeRestart("muffleWarning")
[09:32:19.123]                       }
[09:32:19.123]                       else if (inherits(cond, "condition")) {
[09:32:19.123]                         if (!is.null(pattern)) {
[09:32:19.123]                           computeRestarts <- base::computeRestarts
[09:32:19.123]                           grepl <- base::grepl
[09:32:19.123]                           restarts <- computeRestarts(cond)
[09:32:19.123]                           for (restart in restarts) {
[09:32:19.123]                             name <- restart$name
[09:32:19.123]                             if (is.null(name)) 
[09:32:19.123]                               next
[09:32:19.123]                             if (!grepl(pattern, name)) 
[09:32:19.123]                               next
[09:32:19.123]                             invokeRestart(restart)
[09:32:19.123]                             muffled <- TRUE
[09:32:19.123]                             break
[09:32:19.123]                           }
[09:32:19.123]                         }
[09:32:19.123]                       }
[09:32:19.123]                       invisible(muffled)
[09:32:19.123]                     }
[09:32:19.123]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.123]                   }
[09:32:19.123]                 }
[09:32:19.123]                 else {
[09:32:19.123]                   if (TRUE) {
[09:32:19.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.123]                     {
[09:32:19.123]                       inherits <- base::inherits
[09:32:19.123]                       invokeRestart <- base::invokeRestart
[09:32:19.123]                       is.null <- base::is.null
[09:32:19.123]                       muffled <- FALSE
[09:32:19.123]                       if (inherits(cond, "message")) {
[09:32:19.123]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.123]                         if (muffled) 
[09:32:19.123]                           invokeRestart("muffleMessage")
[09:32:19.123]                       }
[09:32:19.123]                       else if (inherits(cond, "warning")) {
[09:32:19.123]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.123]                         if (muffled) 
[09:32:19.123]                           invokeRestart("muffleWarning")
[09:32:19.123]                       }
[09:32:19.123]                       else if (inherits(cond, "condition")) {
[09:32:19.123]                         if (!is.null(pattern)) {
[09:32:19.123]                           computeRestarts <- base::computeRestarts
[09:32:19.123]                           grepl <- base::grepl
[09:32:19.123]                           restarts <- computeRestarts(cond)
[09:32:19.123]                           for (restart in restarts) {
[09:32:19.123]                             name <- restart$name
[09:32:19.123]                             if (is.null(name)) 
[09:32:19.123]                               next
[09:32:19.123]                             if (!grepl(pattern, name)) 
[09:32:19.123]                               next
[09:32:19.123]                             invokeRestart(restart)
[09:32:19.123]                             muffled <- TRUE
[09:32:19.123]                             break
[09:32:19.123]                           }
[09:32:19.123]                         }
[09:32:19.123]                       }
[09:32:19.123]                       invisible(muffled)
[09:32:19.123]                     }
[09:32:19.123]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.123]                   }
[09:32:19.123]                 }
[09:32:19.123]             }
[09:32:19.123]         }))
[09:32:19.123]     }, error = function(ex) {
[09:32:19.123]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.123]                 ...future.rng), started = ...future.startTime, 
[09:32:19.123]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.123]             version = "1.8"), class = "FutureResult")
[09:32:19.123]     }, finally = {
[09:32:19.123]         if (!identical(...future.workdir, getwd())) 
[09:32:19.123]             setwd(...future.workdir)
[09:32:19.123]         {
[09:32:19.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.123]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.123]             }
[09:32:19.123]             base::options(...future.oldOptions)
[09:32:19.123]             if (.Platform$OS.type == "windows") {
[09:32:19.123]                 old_names <- names(...future.oldEnvVars)
[09:32:19.123]                 envs <- base::Sys.getenv()
[09:32:19.123]                 names <- names(envs)
[09:32:19.123]                 common <- intersect(names, old_names)
[09:32:19.123]                 added <- setdiff(names, old_names)
[09:32:19.123]                 removed <- setdiff(old_names, names)
[09:32:19.123]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.123]                   envs[common]]
[09:32:19.123]                 NAMES <- toupper(changed)
[09:32:19.123]                 args <- list()
[09:32:19.123]                 for (kk in seq_along(NAMES)) {
[09:32:19.123]                   name <- changed[[kk]]
[09:32:19.123]                   NAME <- NAMES[[kk]]
[09:32:19.123]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.123]                     next
[09:32:19.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.123]                 }
[09:32:19.123]                 NAMES <- toupper(added)
[09:32:19.123]                 for (kk in seq_along(NAMES)) {
[09:32:19.123]                   name <- added[[kk]]
[09:32:19.123]                   NAME <- NAMES[[kk]]
[09:32:19.123]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.123]                     next
[09:32:19.123]                   args[[name]] <- ""
[09:32:19.123]                 }
[09:32:19.123]                 NAMES <- toupper(removed)
[09:32:19.123]                 for (kk in seq_along(NAMES)) {
[09:32:19.123]                   name <- removed[[kk]]
[09:32:19.123]                   NAME <- NAMES[[kk]]
[09:32:19.123]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.123]                     next
[09:32:19.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.123]                 }
[09:32:19.123]                 if (length(args) > 0) 
[09:32:19.123]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.123]             }
[09:32:19.123]             else {
[09:32:19.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.123]             }
[09:32:19.123]             {
[09:32:19.123]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.123]                   0L) {
[09:32:19.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.123]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.123]                   base::options(opts)
[09:32:19.123]                 }
[09:32:19.123]                 {
[09:32:19.123]                   {
[09:32:19.123]                     NULL
[09:32:19.123]                     RNGkind("Mersenne-Twister")
[09:32:19.123]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.123]                       inherits = FALSE)
[09:32:19.123]                   }
[09:32:19.123]                   options(future.plan = NULL)
[09:32:19.123]                   if (is.na(NA_character_)) 
[09:32:19.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.123]                     .init = FALSE)
[09:32:19.123]                 }
[09:32:19.123]             }
[09:32:19.123]         }
[09:32:19.123]     })
[09:32:19.123]     if (TRUE) {
[09:32:19.123]         base::sink(type = "output", split = FALSE)
[09:32:19.123]         if (TRUE) {
[09:32:19.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.123]         }
[09:32:19.123]         else {
[09:32:19.123]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.123]         }
[09:32:19.123]         base::close(...future.stdout)
[09:32:19.123]         ...future.stdout <- NULL
[09:32:19.123]     }
[09:32:19.123]     ...future.result$conditions <- ...future.conditions
[09:32:19.123]     ...future.result$finished <- base::Sys.time()
[09:32:19.123]     ...future.result
[09:32:19.123] }
[09:32:19.125] plan(): Setting new future strategy stack:
[09:32:19.125] List of future strategies:
[09:32:19.125] 1. sequential:
[09:32:19.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.125]    - tweaked: FALSE
[09:32:19.125]    - call: NULL
[09:32:19.125] plan(): nbrOfWorkers() = 1
[09:32:19.126] plan(): Setting new future strategy stack:
[09:32:19.126] List of future strategies:
[09:32:19.126] 1. sequential:
[09:32:19.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.126]    - tweaked: FALSE
[09:32:19.126]    - call: plan(strategy)
[09:32:19.126] plan(): nbrOfWorkers() = 1
[09:32:19.126] SequentialFuture started (and completed)
[09:32:19.126] - Launch lazy future ... done
[09:32:19.127] run() for ‘SequentialFuture’ ... done
[09:32:19.127] resolve() on list environment ...
[09:32:19.127]  recursive: 0
[09:32:19.128]  length: 3
[09:32:19.128]  elements: ‘a’, ‘b’, ‘c’
[09:32:19.128] resolved() for ‘SequentialFuture’ ...
[09:32:19.128] - state: ‘finished’
[09:32:19.128] - run: TRUE
[09:32:19.128] - result: ‘FutureResult’
[09:32:19.128] resolved() for ‘SequentialFuture’ ... done
[09:32:19.128] Future #1
[09:32:19.128]  length: 2 (resolved future 1)
[09:32:19.128] resolved() for ‘SequentialFuture’ ...
[09:32:19.129] - state: ‘finished’
[09:32:19.129] - run: TRUE
[09:32:19.129] - result: ‘FutureResult’
[09:32:19.129] resolved() for ‘SequentialFuture’ ... done
[09:32:19.129] Future #2
[09:32:19.129]  length: 1 (resolved future 2)
[09:32:19.129]  length: 0 (resolved future 3)
[09:32:19.129] resolve() on list environment ... DONE
[09:32:19.130] getGlobalsAndPackages() ...
[09:32:19.131] Searching for globals...
[09:32:19.131] - globals found: [1] ‘{’
[09:32:19.131] Searching for globals ... DONE
[09:32:19.131] Resolving globals: FALSE
[09:32:19.132] 
[09:32:19.132] 
[09:32:19.132] getGlobalsAndPackages() ... DONE
[09:32:19.132] run() for ‘Future’ ...
[09:32:19.132] - state: ‘created’
[09:32:19.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.132] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.132] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.133]   - Field: ‘label’
[09:32:19.133]   - Field: ‘local’
[09:32:19.133]   - Field: ‘owner’
[09:32:19.133]   - Field: ‘envir’
[09:32:19.133]   - Field: ‘packages’
[09:32:19.133]   - Field: ‘gc’
[09:32:19.133]   - Field: ‘conditions’
[09:32:19.133]   - Field: ‘expr’
[09:32:19.133]   - Field: ‘uuid’
[09:32:19.133]   - Field: ‘seed’
[09:32:19.133]   - Field: ‘version’
[09:32:19.133]   - Field: ‘result’
[09:32:19.134]   - Field: ‘asynchronous’
[09:32:19.134]   - Field: ‘calls’
[09:32:19.134]   - Field: ‘globals’
[09:32:19.134]   - Field: ‘stdout’
[09:32:19.134]   - Field: ‘earlySignal’
[09:32:19.134]   - Field: ‘lazy’
[09:32:19.134]   - Field: ‘state’
[09:32:19.134] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.134] - Launch lazy future ...
[09:32:19.134] Packages needed by the future expression (n = 0): <none>
[09:32:19.134] Packages needed by future strategies (n = 0): <none>
[09:32:19.135] {
[09:32:19.135]     {
[09:32:19.135]         {
[09:32:19.135]             ...future.startTime <- base::Sys.time()
[09:32:19.135]             {
[09:32:19.135]                 {
[09:32:19.135]                   {
[09:32:19.135]                     base::local({
[09:32:19.135]                       has_future <- base::requireNamespace("future", 
[09:32:19.135]                         quietly = TRUE)
[09:32:19.135]                       if (has_future) {
[09:32:19.135]                         ns <- base::getNamespace("future")
[09:32:19.135]                         version <- ns[[".package"]][["version"]]
[09:32:19.135]                         if (is.null(version)) 
[09:32:19.135]                           version <- utils::packageVersion("future")
[09:32:19.135]                       }
[09:32:19.135]                       else {
[09:32:19.135]                         version <- NULL
[09:32:19.135]                       }
[09:32:19.135]                       if (!has_future || version < "1.8.0") {
[09:32:19.135]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.135]                           "", base::R.version$version.string), 
[09:32:19.135]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.135]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.135]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.135]                             "release", "version")], collapse = " "), 
[09:32:19.135]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.135]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.135]                           info)
[09:32:19.135]                         info <- base::paste(info, collapse = "; ")
[09:32:19.135]                         if (!has_future) {
[09:32:19.135]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.135]                             info)
[09:32:19.135]                         }
[09:32:19.135]                         else {
[09:32:19.135]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.135]                             info, version)
[09:32:19.135]                         }
[09:32:19.135]                         base::stop(msg)
[09:32:19.135]                       }
[09:32:19.135]                     })
[09:32:19.135]                   }
[09:32:19.135]                   ...future.strategy.old <- future::plan("list")
[09:32:19.135]                   options(future.plan = NULL)
[09:32:19.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.135]                 }
[09:32:19.135]                 ...future.workdir <- getwd()
[09:32:19.135]             }
[09:32:19.135]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.135]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.135]         }
[09:32:19.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.135]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.135]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.135]             base::names(...future.oldOptions))
[09:32:19.135]     }
[09:32:19.135]     if (FALSE) {
[09:32:19.135]     }
[09:32:19.135]     else {
[09:32:19.135]         if (TRUE) {
[09:32:19.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.135]                 open = "w")
[09:32:19.135]         }
[09:32:19.135]         else {
[09:32:19.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.135]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.135]         }
[09:32:19.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.135]             base::sink(type = "output", split = FALSE)
[09:32:19.135]             base::close(...future.stdout)
[09:32:19.135]         }, add = TRUE)
[09:32:19.135]     }
[09:32:19.135]     ...future.frame <- base::sys.nframe()
[09:32:19.135]     ...future.conditions <- base::list()
[09:32:19.135]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.135]     if (FALSE) {
[09:32:19.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.135]     }
[09:32:19.135]     ...future.result <- base::tryCatch({
[09:32:19.135]         base::withCallingHandlers({
[09:32:19.135]             ...future.value <- base::withVisible(base::local({
[09:32:19.135]                 1
[09:32:19.135]             }))
[09:32:19.135]             future::FutureResult(value = ...future.value$value, 
[09:32:19.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.135]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.135]                     ...future.globalenv.names))
[09:32:19.135]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.135]         }, condition = base::local({
[09:32:19.135]             c <- base::c
[09:32:19.135]             inherits <- base::inherits
[09:32:19.135]             invokeRestart <- base::invokeRestart
[09:32:19.135]             length <- base::length
[09:32:19.135]             list <- base::list
[09:32:19.135]             seq.int <- base::seq.int
[09:32:19.135]             signalCondition <- base::signalCondition
[09:32:19.135]             sys.calls <- base::sys.calls
[09:32:19.135]             `[[` <- base::`[[`
[09:32:19.135]             `+` <- base::`+`
[09:32:19.135]             `<<-` <- base::`<<-`
[09:32:19.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.135]                   3L)]
[09:32:19.135]             }
[09:32:19.135]             function(cond) {
[09:32:19.135]                 is_error <- inherits(cond, "error")
[09:32:19.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.135]                   NULL)
[09:32:19.135]                 if (is_error) {
[09:32:19.135]                   sessionInformation <- function() {
[09:32:19.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.135]                       search = base::search(), system = base::Sys.info())
[09:32:19.135]                   }
[09:32:19.135]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.135]                     cond$call), session = sessionInformation(), 
[09:32:19.135]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.135]                   signalCondition(cond)
[09:32:19.135]                 }
[09:32:19.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.135]                 "immediateCondition"))) {
[09:32:19.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.135]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.135]                   if (TRUE && !signal) {
[09:32:19.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.135]                     {
[09:32:19.135]                       inherits <- base::inherits
[09:32:19.135]                       invokeRestart <- base::invokeRestart
[09:32:19.135]                       is.null <- base::is.null
[09:32:19.135]                       muffled <- FALSE
[09:32:19.135]                       if (inherits(cond, "message")) {
[09:32:19.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.135]                         if (muffled) 
[09:32:19.135]                           invokeRestart("muffleMessage")
[09:32:19.135]                       }
[09:32:19.135]                       else if (inherits(cond, "warning")) {
[09:32:19.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.135]                         if (muffled) 
[09:32:19.135]                           invokeRestart("muffleWarning")
[09:32:19.135]                       }
[09:32:19.135]                       else if (inherits(cond, "condition")) {
[09:32:19.135]                         if (!is.null(pattern)) {
[09:32:19.135]                           computeRestarts <- base::computeRestarts
[09:32:19.135]                           grepl <- base::grepl
[09:32:19.135]                           restarts <- computeRestarts(cond)
[09:32:19.135]                           for (restart in restarts) {
[09:32:19.135]                             name <- restart$name
[09:32:19.135]                             if (is.null(name)) 
[09:32:19.135]                               next
[09:32:19.135]                             if (!grepl(pattern, name)) 
[09:32:19.135]                               next
[09:32:19.135]                             invokeRestart(restart)
[09:32:19.135]                             muffled <- TRUE
[09:32:19.135]                             break
[09:32:19.135]                           }
[09:32:19.135]                         }
[09:32:19.135]                       }
[09:32:19.135]                       invisible(muffled)
[09:32:19.135]                     }
[09:32:19.135]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.135]                   }
[09:32:19.135]                 }
[09:32:19.135]                 else {
[09:32:19.135]                   if (TRUE) {
[09:32:19.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.135]                     {
[09:32:19.135]                       inherits <- base::inherits
[09:32:19.135]                       invokeRestart <- base::invokeRestart
[09:32:19.135]                       is.null <- base::is.null
[09:32:19.135]                       muffled <- FALSE
[09:32:19.135]                       if (inherits(cond, "message")) {
[09:32:19.135]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.135]                         if (muffled) 
[09:32:19.135]                           invokeRestart("muffleMessage")
[09:32:19.135]                       }
[09:32:19.135]                       else if (inherits(cond, "warning")) {
[09:32:19.135]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.135]                         if (muffled) 
[09:32:19.135]                           invokeRestart("muffleWarning")
[09:32:19.135]                       }
[09:32:19.135]                       else if (inherits(cond, "condition")) {
[09:32:19.135]                         if (!is.null(pattern)) {
[09:32:19.135]                           computeRestarts <- base::computeRestarts
[09:32:19.135]                           grepl <- base::grepl
[09:32:19.135]                           restarts <- computeRestarts(cond)
[09:32:19.135]                           for (restart in restarts) {
[09:32:19.135]                             name <- restart$name
[09:32:19.135]                             if (is.null(name)) 
[09:32:19.135]                               next
[09:32:19.135]                             if (!grepl(pattern, name)) 
[09:32:19.135]                               next
[09:32:19.135]                             invokeRestart(restart)
[09:32:19.135]                             muffled <- TRUE
[09:32:19.135]                             break
[09:32:19.135]                           }
[09:32:19.135]                         }
[09:32:19.135]                       }
[09:32:19.135]                       invisible(muffled)
[09:32:19.135]                     }
[09:32:19.135]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.135]                   }
[09:32:19.135]                 }
[09:32:19.135]             }
[09:32:19.135]         }))
[09:32:19.135]     }, error = function(ex) {
[09:32:19.135]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.135]                 ...future.rng), started = ...future.startTime, 
[09:32:19.135]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.135]             version = "1.8"), class = "FutureResult")
[09:32:19.135]     }, finally = {
[09:32:19.135]         if (!identical(...future.workdir, getwd())) 
[09:32:19.135]             setwd(...future.workdir)
[09:32:19.135]         {
[09:32:19.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.135]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.135]             }
[09:32:19.135]             base::options(...future.oldOptions)
[09:32:19.135]             if (.Platform$OS.type == "windows") {
[09:32:19.135]                 old_names <- names(...future.oldEnvVars)
[09:32:19.135]                 envs <- base::Sys.getenv()
[09:32:19.135]                 names <- names(envs)
[09:32:19.135]                 common <- intersect(names, old_names)
[09:32:19.135]                 added <- setdiff(names, old_names)
[09:32:19.135]                 removed <- setdiff(old_names, names)
[09:32:19.135]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.135]                   envs[common]]
[09:32:19.135]                 NAMES <- toupper(changed)
[09:32:19.135]                 args <- list()
[09:32:19.135]                 for (kk in seq_along(NAMES)) {
[09:32:19.135]                   name <- changed[[kk]]
[09:32:19.135]                   NAME <- NAMES[[kk]]
[09:32:19.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.135]                     next
[09:32:19.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.135]                 }
[09:32:19.135]                 NAMES <- toupper(added)
[09:32:19.135]                 for (kk in seq_along(NAMES)) {
[09:32:19.135]                   name <- added[[kk]]
[09:32:19.135]                   NAME <- NAMES[[kk]]
[09:32:19.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.135]                     next
[09:32:19.135]                   args[[name]] <- ""
[09:32:19.135]                 }
[09:32:19.135]                 NAMES <- toupper(removed)
[09:32:19.135]                 for (kk in seq_along(NAMES)) {
[09:32:19.135]                   name <- removed[[kk]]
[09:32:19.135]                   NAME <- NAMES[[kk]]
[09:32:19.135]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.135]                     next
[09:32:19.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.135]                 }
[09:32:19.135]                 if (length(args) > 0) 
[09:32:19.135]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.135]             }
[09:32:19.135]             else {
[09:32:19.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.135]             }
[09:32:19.135]             {
[09:32:19.135]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.135]                   0L) {
[09:32:19.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.135]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.135]                   base::options(opts)
[09:32:19.135]                 }
[09:32:19.135]                 {
[09:32:19.135]                   {
[09:32:19.135]                     NULL
[09:32:19.135]                     RNGkind("Mersenne-Twister")
[09:32:19.135]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.135]                       inherits = FALSE)
[09:32:19.135]                   }
[09:32:19.135]                   options(future.plan = NULL)
[09:32:19.135]                   if (is.na(NA_character_)) 
[09:32:19.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.135]                     .init = FALSE)
[09:32:19.135]                 }
[09:32:19.135]             }
[09:32:19.135]         }
[09:32:19.135]     })
[09:32:19.135]     if (TRUE) {
[09:32:19.135]         base::sink(type = "output", split = FALSE)
[09:32:19.135]         if (TRUE) {
[09:32:19.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.135]         }
[09:32:19.135]         else {
[09:32:19.135]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.135]         }
[09:32:19.135]         base::close(...future.stdout)
[09:32:19.135]         ...future.stdout <- NULL
[09:32:19.135]     }
[09:32:19.135]     ...future.result$conditions <- ...future.conditions
[09:32:19.135]     ...future.result$finished <- base::Sys.time()
[09:32:19.135]     ...future.result
[09:32:19.135] }
[09:32:19.137] plan(): Setting new future strategy stack:
[09:32:19.137] List of future strategies:
[09:32:19.137] 1. sequential:
[09:32:19.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.137]    - tweaked: FALSE
[09:32:19.137]    - call: NULL
[09:32:19.137] plan(): nbrOfWorkers() = 1
[09:32:19.138] plan(): Setting new future strategy stack:
[09:32:19.138] List of future strategies:
[09:32:19.138] 1. sequential:
[09:32:19.138]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.138]    - tweaked: FALSE
[09:32:19.138]    - call: plan(strategy)
[09:32:19.138] plan(): nbrOfWorkers() = 1
[09:32:19.138] SequentialFuture started (and completed)
[09:32:19.138] - Launch lazy future ... done
[09:32:19.139] run() for ‘SequentialFuture’ ... done
[09:32:19.139] getGlobalsAndPackages() ...
[09:32:19.139] Searching for globals...
[09:32:19.140] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:19.140] Searching for globals ... DONE
[09:32:19.140] Resolving globals: FALSE
[09:32:19.140] 
[09:32:19.140] 
[09:32:19.140] getGlobalsAndPackages() ... DONE
[09:32:19.141] run() for ‘Future’ ...
[09:32:19.141] - state: ‘created’
[09:32:19.141] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.141] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.141] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.141]   - Field: ‘label’
[09:32:19.141]   - Field: ‘local’
[09:32:19.141]   - Field: ‘owner’
[09:32:19.142]   - Field: ‘envir’
[09:32:19.142]   - Field: ‘packages’
[09:32:19.142]   - Field: ‘gc’
[09:32:19.142]   - Field: ‘conditions’
[09:32:19.142]   - Field: ‘expr’
[09:32:19.142]   - Field: ‘uuid’
[09:32:19.142]   - Field: ‘seed’
[09:32:19.142]   - Field: ‘version’
[09:32:19.142]   - Field: ‘result’
[09:32:19.142]   - Field: ‘asynchronous’
[09:32:19.142]   - Field: ‘calls’
[09:32:19.142]   - Field: ‘globals’
[09:32:19.143]   - Field: ‘stdout’
[09:32:19.143]   - Field: ‘earlySignal’
[09:32:19.143]   - Field: ‘lazy’
[09:32:19.143]   - Field: ‘state’
[09:32:19.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.143] - Launch lazy future ...
[09:32:19.143] Packages needed by the future expression (n = 0): <none>
[09:32:19.143] Packages needed by future strategies (n = 0): <none>
[09:32:19.144] {
[09:32:19.144]     {
[09:32:19.144]         {
[09:32:19.144]             ...future.startTime <- base::Sys.time()
[09:32:19.144]             {
[09:32:19.144]                 {
[09:32:19.144]                   {
[09:32:19.144]                     base::local({
[09:32:19.144]                       has_future <- base::requireNamespace("future", 
[09:32:19.144]                         quietly = TRUE)
[09:32:19.144]                       if (has_future) {
[09:32:19.144]                         ns <- base::getNamespace("future")
[09:32:19.144]                         version <- ns[[".package"]][["version"]]
[09:32:19.144]                         if (is.null(version)) 
[09:32:19.144]                           version <- utils::packageVersion("future")
[09:32:19.144]                       }
[09:32:19.144]                       else {
[09:32:19.144]                         version <- NULL
[09:32:19.144]                       }
[09:32:19.144]                       if (!has_future || version < "1.8.0") {
[09:32:19.144]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.144]                           "", base::R.version$version.string), 
[09:32:19.144]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.144]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.144]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.144]                             "release", "version")], collapse = " "), 
[09:32:19.144]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.144]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.144]                           info)
[09:32:19.144]                         info <- base::paste(info, collapse = "; ")
[09:32:19.144]                         if (!has_future) {
[09:32:19.144]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.144]                             info)
[09:32:19.144]                         }
[09:32:19.144]                         else {
[09:32:19.144]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.144]                             info, version)
[09:32:19.144]                         }
[09:32:19.144]                         base::stop(msg)
[09:32:19.144]                       }
[09:32:19.144]                     })
[09:32:19.144]                   }
[09:32:19.144]                   ...future.strategy.old <- future::plan("list")
[09:32:19.144]                   options(future.plan = NULL)
[09:32:19.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.144]                 }
[09:32:19.144]                 ...future.workdir <- getwd()
[09:32:19.144]             }
[09:32:19.144]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.144]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.144]         }
[09:32:19.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.144]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.144]             base::names(...future.oldOptions))
[09:32:19.144]     }
[09:32:19.144]     if (FALSE) {
[09:32:19.144]     }
[09:32:19.144]     else {
[09:32:19.144]         if (TRUE) {
[09:32:19.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.144]                 open = "w")
[09:32:19.144]         }
[09:32:19.144]         else {
[09:32:19.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.144]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.144]         }
[09:32:19.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.144]             base::sink(type = "output", split = FALSE)
[09:32:19.144]             base::close(...future.stdout)
[09:32:19.144]         }, add = TRUE)
[09:32:19.144]     }
[09:32:19.144]     ...future.frame <- base::sys.nframe()
[09:32:19.144]     ...future.conditions <- base::list()
[09:32:19.144]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.144]     if (FALSE) {
[09:32:19.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.144]     }
[09:32:19.144]     ...future.result <- base::tryCatch({
[09:32:19.144]         base::withCallingHandlers({
[09:32:19.144]             ...future.value <- base::withVisible(base::local({
[09:32:19.144]                 Sys.sleep(0.5)
[09:32:19.144]                 2
[09:32:19.144]             }))
[09:32:19.144]             future::FutureResult(value = ...future.value$value, 
[09:32:19.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.144]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.144]                     ...future.globalenv.names))
[09:32:19.144]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.144]         }, condition = base::local({
[09:32:19.144]             c <- base::c
[09:32:19.144]             inherits <- base::inherits
[09:32:19.144]             invokeRestart <- base::invokeRestart
[09:32:19.144]             length <- base::length
[09:32:19.144]             list <- base::list
[09:32:19.144]             seq.int <- base::seq.int
[09:32:19.144]             signalCondition <- base::signalCondition
[09:32:19.144]             sys.calls <- base::sys.calls
[09:32:19.144]             `[[` <- base::`[[`
[09:32:19.144]             `+` <- base::`+`
[09:32:19.144]             `<<-` <- base::`<<-`
[09:32:19.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.144]                   3L)]
[09:32:19.144]             }
[09:32:19.144]             function(cond) {
[09:32:19.144]                 is_error <- inherits(cond, "error")
[09:32:19.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.144]                   NULL)
[09:32:19.144]                 if (is_error) {
[09:32:19.144]                   sessionInformation <- function() {
[09:32:19.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.144]                       search = base::search(), system = base::Sys.info())
[09:32:19.144]                   }
[09:32:19.144]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.144]                     cond$call), session = sessionInformation(), 
[09:32:19.144]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.144]                   signalCondition(cond)
[09:32:19.144]                 }
[09:32:19.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.144]                 "immediateCondition"))) {
[09:32:19.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.144]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.144]                   if (TRUE && !signal) {
[09:32:19.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.144]                     {
[09:32:19.144]                       inherits <- base::inherits
[09:32:19.144]                       invokeRestart <- base::invokeRestart
[09:32:19.144]                       is.null <- base::is.null
[09:32:19.144]                       muffled <- FALSE
[09:32:19.144]                       if (inherits(cond, "message")) {
[09:32:19.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.144]                         if (muffled) 
[09:32:19.144]                           invokeRestart("muffleMessage")
[09:32:19.144]                       }
[09:32:19.144]                       else if (inherits(cond, "warning")) {
[09:32:19.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.144]                         if (muffled) 
[09:32:19.144]                           invokeRestart("muffleWarning")
[09:32:19.144]                       }
[09:32:19.144]                       else if (inherits(cond, "condition")) {
[09:32:19.144]                         if (!is.null(pattern)) {
[09:32:19.144]                           computeRestarts <- base::computeRestarts
[09:32:19.144]                           grepl <- base::grepl
[09:32:19.144]                           restarts <- computeRestarts(cond)
[09:32:19.144]                           for (restart in restarts) {
[09:32:19.144]                             name <- restart$name
[09:32:19.144]                             if (is.null(name)) 
[09:32:19.144]                               next
[09:32:19.144]                             if (!grepl(pattern, name)) 
[09:32:19.144]                               next
[09:32:19.144]                             invokeRestart(restart)
[09:32:19.144]                             muffled <- TRUE
[09:32:19.144]                             break
[09:32:19.144]                           }
[09:32:19.144]                         }
[09:32:19.144]                       }
[09:32:19.144]                       invisible(muffled)
[09:32:19.144]                     }
[09:32:19.144]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.144]                   }
[09:32:19.144]                 }
[09:32:19.144]                 else {
[09:32:19.144]                   if (TRUE) {
[09:32:19.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.144]                     {
[09:32:19.144]                       inherits <- base::inherits
[09:32:19.144]                       invokeRestart <- base::invokeRestart
[09:32:19.144]                       is.null <- base::is.null
[09:32:19.144]                       muffled <- FALSE
[09:32:19.144]                       if (inherits(cond, "message")) {
[09:32:19.144]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.144]                         if (muffled) 
[09:32:19.144]                           invokeRestart("muffleMessage")
[09:32:19.144]                       }
[09:32:19.144]                       else if (inherits(cond, "warning")) {
[09:32:19.144]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.144]                         if (muffled) 
[09:32:19.144]                           invokeRestart("muffleWarning")
[09:32:19.144]                       }
[09:32:19.144]                       else if (inherits(cond, "condition")) {
[09:32:19.144]                         if (!is.null(pattern)) {
[09:32:19.144]                           computeRestarts <- base::computeRestarts
[09:32:19.144]                           grepl <- base::grepl
[09:32:19.144]                           restarts <- computeRestarts(cond)
[09:32:19.144]                           for (restart in restarts) {
[09:32:19.144]                             name <- restart$name
[09:32:19.144]                             if (is.null(name)) 
[09:32:19.144]                               next
[09:32:19.144]                             if (!grepl(pattern, name)) 
[09:32:19.144]                               next
[09:32:19.144]                             invokeRestart(restart)
[09:32:19.144]                             muffled <- TRUE
[09:32:19.144]                             break
[09:32:19.144]                           }
[09:32:19.144]                         }
[09:32:19.144]                       }
[09:32:19.144]                       invisible(muffled)
[09:32:19.144]                     }
[09:32:19.144]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.144]                   }
[09:32:19.144]                 }
[09:32:19.144]             }
[09:32:19.144]         }))
[09:32:19.144]     }, error = function(ex) {
[09:32:19.144]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.144]                 ...future.rng), started = ...future.startTime, 
[09:32:19.144]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.144]             version = "1.8"), class = "FutureResult")
[09:32:19.144]     }, finally = {
[09:32:19.144]         if (!identical(...future.workdir, getwd())) 
[09:32:19.144]             setwd(...future.workdir)
[09:32:19.144]         {
[09:32:19.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.144]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.144]             }
[09:32:19.144]             base::options(...future.oldOptions)
[09:32:19.144]             if (.Platform$OS.type == "windows") {
[09:32:19.144]                 old_names <- names(...future.oldEnvVars)
[09:32:19.144]                 envs <- base::Sys.getenv()
[09:32:19.144]                 names <- names(envs)
[09:32:19.144]                 common <- intersect(names, old_names)
[09:32:19.144]                 added <- setdiff(names, old_names)
[09:32:19.144]                 removed <- setdiff(old_names, names)
[09:32:19.144]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.144]                   envs[common]]
[09:32:19.144]                 NAMES <- toupper(changed)
[09:32:19.144]                 args <- list()
[09:32:19.144]                 for (kk in seq_along(NAMES)) {
[09:32:19.144]                   name <- changed[[kk]]
[09:32:19.144]                   NAME <- NAMES[[kk]]
[09:32:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.144]                     next
[09:32:19.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.144]                 }
[09:32:19.144]                 NAMES <- toupper(added)
[09:32:19.144]                 for (kk in seq_along(NAMES)) {
[09:32:19.144]                   name <- added[[kk]]
[09:32:19.144]                   NAME <- NAMES[[kk]]
[09:32:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.144]                     next
[09:32:19.144]                   args[[name]] <- ""
[09:32:19.144]                 }
[09:32:19.144]                 NAMES <- toupper(removed)
[09:32:19.144]                 for (kk in seq_along(NAMES)) {
[09:32:19.144]                   name <- removed[[kk]]
[09:32:19.144]                   NAME <- NAMES[[kk]]
[09:32:19.144]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.144]                     next
[09:32:19.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.144]                 }
[09:32:19.144]                 if (length(args) > 0) 
[09:32:19.144]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.144]             }
[09:32:19.144]             else {
[09:32:19.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.144]             }
[09:32:19.144]             {
[09:32:19.144]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.144]                   0L) {
[09:32:19.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.144]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.144]                   base::options(opts)
[09:32:19.144]                 }
[09:32:19.144]                 {
[09:32:19.144]                   {
[09:32:19.144]                     NULL
[09:32:19.144]                     RNGkind("Mersenne-Twister")
[09:32:19.144]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.144]                       inherits = FALSE)
[09:32:19.144]                   }
[09:32:19.144]                   options(future.plan = NULL)
[09:32:19.144]                   if (is.na(NA_character_)) 
[09:32:19.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.144]                     .init = FALSE)
[09:32:19.144]                 }
[09:32:19.144]             }
[09:32:19.144]         }
[09:32:19.144]     })
[09:32:19.144]     if (TRUE) {
[09:32:19.144]         base::sink(type = "output", split = FALSE)
[09:32:19.144]         if (TRUE) {
[09:32:19.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.144]         }
[09:32:19.144]         else {
[09:32:19.144]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.144]         }
[09:32:19.144]         base::close(...future.stdout)
[09:32:19.144]         ...future.stdout <- NULL
[09:32:19.144]     }
[09:32:19.144]     ...future.result$conditions <- ...future.conditions
[09:32:19.144]     ...future.result$finished <- base::Sys.time()
[09:32:19.144]     ...future.result
[09:32:19.144] }
[09:32:19.145] plan(): Setting new future strategy stack:
[09:32:19.145] List of future strategies:
[09:32:19.145] 1. sequential:
[09:32:19.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.145]    - tweaked: FALSE
[09:32:19.145]    - call: NULL
[09:32:19.146] plan(): nbrOfWorkers() = 1
[09:32:19.647] plan(): Setting new future strategy stack:
[09:32:19.647] List of future strategies:
[09:32:19.647] 1. sequential:
[09:32:19.647]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.647]    - tweaked: FALSE
[09:32:19.647]    - call: plan(strategy)
[09:32:19.648] plan(): nbrOfWorkers() = 1
[09:32:19.648] SequentialFuture started (and completed)
[09:32:19.648] - Launch lazy future ... done
[09:32:19.648] run() for ‘SequentialFuture’ ... done
[09:32:19.649] getGlobalsAndPackages() ...
[09:32:19.649] Searching for globals...
[09:32:19.649] - globals found: [1] ‘{’
[09:32:19.650] Searching for globals ... DONE
[09:32:19.650] Resolving globals: FALSE
[09:32:19.650] 
[09:32:19.650] 
[09:32:19.650] getGlobalsAndPackages() ... DONE
[09:32:19.650] run() for ‘Future’ ...
[09:32:19.650] - state: ‘created’
[09:32:19.651] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[09:32:19.651] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[09:32:19.651] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[09:32:19.651]   - Field: ‘label’
[09:32:19.651]   - Field: ‘local’
[09:32:19.651]   - Field: ‘owner’
[09:32:19.651]   - Field: ‘envir’
[09:32:19.651]   - Field: ‘packages’
[09:32:19.652]   - Field: ‘gc’
[09:32:19.652]   - Field: ‘conditions’
[09:32:19.652]   - Field: ‘expr’
[09:32:19.652]   - Field: ‘uuid’
[09:32:19.652]   - Field: ‘seed’
[09:32:19.652]   - Field: ‘version’
[09:32:19.652]   - Field: ‘result’
[09:32:19.652]   - Field: ‘asynchronous’
[09:32:19.652]   - Field: ‘calls’
[09:32:19.652]   - Field: ‘globals’
[09:32:19.652]   - Field: ‘stdout’
[09:32:19.653]   - Field: ‘earlySignal’
[09:32:19.653]   - Field: ‘lazy’
[09:32:19.653]   - Field: ‘state’
[09:32:19.653] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[09:32:19.653] - Launch lazy future ...
[09:32:19.653] Packages needed by the future expression (n = 0): <none>
[09:32:19.653] Packages needed by future strategies (n = 0): <none>
[09:32:19.654] {
[09:32:19.654]     {
[09:32:19.654]         {
[09:32:19.654]             ...future.startTime <- base::Sys.time()
[09:32:19.654]             {
[09:32:19.654]                 {
[09:32:19.654]                   {
[09:32:19.654]                     base::local({
[09:32:19.654]                       has_future <- base::requireNamespace("future", 
[09:32:19.654]                         quietly = TRUE)
[09:32:19.654]                       if (has_future) {
[09:32:19.654]                         ns <- base::getNamespace("future")
[09:32:19.654]                         version <- ns[[".package"]][["version"]]
[09:32:19.654]                         if (is.null(version)) 
[09:32:19.654]                           version <- utils::packageVersion("future")
[09:32:19.654]                       }
[09:32:19.654]                       else {
[09:32:19.654]                         version <- NULL
[09:32:19.654]                       }
[09:32:19.654]                       if (!has_future || version < "1.8.0") {
[09:32:19.654]                         info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.654]                           "", base::R.version$version.string), 
[09:32:19.654]                           platform = base::sprintf("%s (%s-bit)", 
[09:32:19.654]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.654]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.654]                             "release", "version")], collapse = " "), 
[09:32:19.654]                           hostname = base::Sys.info()[["nodename"]])
[09:32:19.654]                         info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.654]                           info)
[09:32:19.654]                         info <- base::paste(info, collapse = "; ")
[09:32:19.654]                         if (!has_future) {
[09:32:19.654]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.654]                             info)
[09:32:19.654]                         }
[09:32:19.654]                         else {
[09:32:19.654]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.654]                             info, version)
[09:32:19.654]                         }
[09:32:19.654]                         base::stop(msg)
[09:32:19.654]                       }
[09:32:19.654]                     })
[09:32:19.654]                   }
[09:32:19.654]                   ...future.strategy.old <- future::plan("list")
[09:32:19.654]                   options(future.plan = NULL)
[09:32:19.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.654]                 }
[09:32:19.654]                 ...future.workdir <- getwd()
[09:32:19.654]             }
[09:32:19.654]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.654]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.654]         }
[09:32:19.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.654]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.654]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.654]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.654]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.654]             base::names(...future.oldOptions))
[09:32:19.654]     }
[09:32:19.654]     if (FALSE) {
[09:32:19.654]     }
[09:32:19.654]     else {
[09:32:19.654]         if (TRUE) {
[09:32:19.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.654]                 open = "w")
[09:32:19.654]         }
[09:32:19.654]         else {
[09:32:19.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.654]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.654]         }
[09:32:19.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.654]             base::sink(type = "output", split = FALSE)
[09:32:19.654]             base::close(...future.stdout)
[09:32:19.654]         }, add = TRUE)
[09:32:19.654]     }
[09:32:19.654]     ...future.frame <- base::sys.nframe()
[09:32:19.654]     ...future.conditions <- base::list()
[09:32:19.654]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.654]     if (FALSE) {
[09:32:19.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.654]     }
[09:32:19.654]     ...future.result <- base::tryCatch({
[09:32:19.654]         base::withCallingHandlers({
[09:32:19.654]             ...future.value <- base::withVisible(base::local({
[09:32:19.654]                 3
[09:32:19.654]             }))
[09:32:19.654]             future::FutureResult(value = ...future.value$value, 
[09:32:19.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.654]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.654]                     ...future.globalenv.names))
[09:32:19.654]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.654]         }, condition = base::local({
[09:32:19.654]             c <- base::c
[09:32:19.654]             inherits <- base::inherits
[09:32:19.654]             invokeRestart <- base::invokeRestart
[09:32:19.654]             length <- base::length
[09:32:19.654]             list <- base::list
[09:32:19.654]             seq.int <- base::seq.int
[09:32:19.654]             signalCondition <- base::signalCondition
[09:32:19.654]             sys.calls <- base::sys.calls
[09:32:19.654]             `[[` <- base::`[[`
[09:32:19.654]             `+` <- base::`+`
[09:32:19.654]             `<<-` <- base::`<<-`
[09:32:19.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.654]                   3L)]
[09:32:19.654]             }
[09:32:19.654]             function(cond) {
[09:32:19.654]                 is_error <- inherits(cond, "error")
[09:32:19.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.654]                   NULL)
[09:32:19.654]                 if (is_error) {
[09:32:19.654]                   sessionInformation <- function() {
[09:32:19.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.654]                       search = base::search(), system = base::Sys.info())
[09:32:19.654]                   }
[09:32:19.654]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.654]                     cond$call), session = sessionInformation(), 
[09:32:19.654]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.654]                   signalCondition(cond)
[09:32:19.654]                 }
[09:32:19.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.654]                 "immediateCondition"))) {
[09:32:19.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.654]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.654]                   if (TRUE && !signal) {
[09:32:19.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.654]                     {
[09:32:19.654]                       inherits <- base::inherits
[09:32:19.654]                       invokeRestart <- base::invokeRestart
[09:32:19.654]                       is.null <- base::is.null
[09:32:19.654]                       muffled <- FALSE
[09:32:19.654]                       if (inherits(cond, "message")) {
[09:32:19.654]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.654]                         if (muffled) 
[09:32:19.654]                           invokeRestart("muffleMessage")
[09:32:19.654]                       }
[09:32:19.654]                       else if (inherits(cond, "warning")) {
[09:32:19.654]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.654]                         if (muffled) 
[09:32:19.654]                           invokeRestart("muffleWarning")
[09:32:19.654]                       }
[09:32:19.654]                       else if (inherits(cond, "condition")) {
[09:32:19.654]                         if (!is.null(pattern)) {
[09:32:19.654]                           computeRestarts <- base::computeRestarts
[09:32:19.654]                           grepl <- base::grepl
[09:32:19.654]                           restarts <- computeRestarts(cond)
[09:32:19.654]                           for (restart in restarts) {
[09:32:19.654]                             name <- restart$name
[09:32:19.654]                             if (is.null(name)) 
[09:32:19.654]                               next
[09:32:19.654]                             if (!grepl(pattern, name)) 
[09:32:19.654]                               next
[09:32:19.654]                             invokeRestart(restart)
[09:32:19.654]                             muffled <- TRUE
[09:32:19.654]                             break
[09:32:19.654]                           }
[09:32:19.654]                         }
[09:32:19.654]                       }
[09:32:19.654]                       invisible(muffled)
[09:32:19.654]                     }
[09:32:19.654]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.654]                   }
[09:32:19.654]                 }
[09:32:19.654]                 else {
[09:32:19.654]                   if (TRUE) {
[09:32:19.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.654]                     {
[09:32:19.654]                       inherits <- base::inherits
[09:32:19.654]                       invokeRestart <- base::invokeRestart
[09:32:19.654]                       is.null <- base::is.null
[09:32:19.654]                       muffled <- FALSE
[09:32:19.654]                       if (inherits(cond, "message")) {
[09:32:19.654]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.654]                         if (muffled) 
[09:32:19.654]                           invokeRestart("muffleMessage")
[09:32:19.654]                       }
[09:32:19.654]                       else if (inherits(cond, "warning")) {
[09:32:19.654]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.654]                         if (muffled) 
[09:32:19.654]                           invokeRestart("muffleWarning")
[09:32:19.654]                       }
[09:32:19.654]                       else if (inherits(cond, "condition")) {
[09:32:19.654]                         if (!is.null(pattern)) {
[09:32:19.654]                           computeRestarts <- base::computeRestarts
[09:32:19.654]                           grepl <- base::grepl
[09:32:19.654]                           restarts <- computeRestarts(cond)
[09:32:19.654]                           for (restart in restarts) {
[09:32:19.654]                             name <- restart$name
[09:32:19.654]                             if (is.null(name)) 
[09:32:19.654]                               next
[09:32:19.654]                             if (!grepl(pattern, name)) 
[09:32:19.654]                               next
[09:32:19.654]                             invokeRestart(restart)
[09:32:19.654]                             muffled <- TRUE
[09:32:19.654]                             break
[09:32:19.654]                           }
[09:32:19.654]                         }
[09:32:19.654]                       }
[09:32:19.654]                       invisible(muffled)
[09:32:19.654]                     }
[09:32:19.654]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.654]                   }
[09:32:19.654]                 }
[09:32:19.654]             }
[09:32:19.654]         }))
[09:32:19.654]     }, error = function(ex) {
[09:32:19.654]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.654]                 ...future.rng), started = ...future.startTime, 
[09:32:19.654]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.654]             version = "1.8"), class = "FutureResult")
[09:32:19.654]     }, finally = {
[09:32:19.654]         if (!identical(...future.workdir, getwd())) 
[09:32:19.654]             setwd(...future.workdir)
[09:32:19.654]         {
[09:32:19.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.654]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.654]             }
[09:32:19.654]             base::options(...future.oldOptions)
[09:32:19.654]             if (.Platform$OS.type == "windows") {
[09:32:19.654]                 old_names <- names(...future.oldEnvVars)
[09:32:19.654]                 envs <- base::Sys.getenv()
[09:32:19.654]                 names <- names(envs)
[09:32:19.654]                 common <- intersect(names, old_names)
[09:32:19.654]                 added <- setdiff(names, old_names)
[09:32:19.654]                 removed <- setdiff(old_names, names)
[09:32:19.654]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.654]                   envs[common]]
[09:32:19.654]                 NAMES <- toupper(changed)
[09:32:19.654]                 args <- list()
[09:32:19.654]                 for (kk in seq_along(NAMES)) {
[09:32:19.654]                   name <- changed[[kk]]
[09:32:19.654]                   NAME <- NAMES[[kk]]
[09:32:19.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.654]                     next
[09:32:19.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.654]                 }
[09:32:19.654]                 NAMES <- toupper(added)
[09:32:19.654]                 for (kk in seq_along(NAMES)) {
[09:32:19.654]                   name <- added[[kk]]
[09:32:19.654]                   NAME <- NAMES[[kk]]
[09:32:19.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.654]                     next
[09:32:19.654]                   args[[name]] <- ""
[09:32:19.654]                 }
[09:32:19.654]                 NAMES <- toupper(removed)
[09:32:19.654]                 for (kk in seq_along(NAMES)) {
[09:32:19.654]                   name <- removed[[kk]]
[09:32:19.654]                   NAME <- NAMES[[kk]]
[09:32:19.654]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.654]                     next
[09:32:19.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.654]                 }
[09:32:19.654]                 if (length(args) > 0) 
[09:32:19.654]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.654]             }
[09:32:19.654]             else {
[09:32:19.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.654]             }
[09:32:19.654]             {
[09:32:19.654]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.654]                   0L) {
[09:32:19.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.654]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.654]                   base::options(opts)
[09:32:19.654]                 }
[09:32:19.654]                 {
[09:32:19.654]                   {
[09:32:19.654]                     NULL
[09:32:19.654]                     RNGkind("Mersenne-Twister")
[09:32:19.654]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[09:32:19.654]                       inherits = FALSE)
[09:32:19.654]                   }
[09:32:19.654]                   options(future.plan = NULL)
[09:32:19.654]                   if (is.na(NA_character_)) 
[09:32:19.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.654]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.654]                     .init = FALSE)
[09:32:19.654]                 }
[09:32:19.654]             }
[09:32:19.654]         }
[09:32:19.654]     })
[09:32:19.654]     if (TRUE) {
[09:32:19.654]         base::sink(type = "output", split = FALSE)
[09:32:19.654]         if (TRUE) {
[09:32:19.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.654]         }
[09:32:19.654]         else {
[09:32:19.654]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.654]         }
[09:32:19.654]         base::close(...future.stdout)
[09:32:19.654]         ...future.stdout <- NULL
[09:32:19.654]     }
[09:32:19.654]     ...future.result$conditions <- ...future.conditions
[09:32:19.654]     ...future.result$finished <- base::Sys.time()
[09:32:19.654]     ...future.result
[09:32:19.654] }
[09:32:19.655] plan(): Setting new future strategy stack:
[09:32:19.656] List of future strategies:
[09:32:19.656] 1. sequential:
[09:32:19.656]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.656]    - tweaked: FALSE
[09:32:19.656]    - call: NULL
[09:32:19.656] plan(): nbrOfWorkers() = 1
[09:32:19.657] plan(): Setting new future strategy stack:
[09:32:19.657] List of future strategies:
[09:32:19.657] 1. sequential:
[09:32:19.657]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.657]    - tweaked: FALSE
[09:32:19.657]    - call: plan(strategy)
[09:32:19.657] plan(): nbrOfWorkers() = 1
[09:32:19.657] SequentialFuture started (and completed)
[09:32:19.659] - Launch lazy future ... done
[09:32:19.659] run() for ‘SequentialFuture’ ... done
[09:32:19.660] resolve() on list environment ...
[09:32:19.660]  recursive: 0
[09:32:19.661]  length: 4
[09:32:19.661]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.661] resolved() for ‘SequentialFuture’ ...
[09:32:19.661] - state: ‘finished’
[09:32:19.661] - run: TRUE
[09:32:19.661] - result: ‘FutureResult’
[09:32:19.661] resolved() for ‘SequentialFuture’ ... done
[09:32:19.661] Future #1
[09:32:19.662]  length: 3 (resolved future 1)
[09:32:19.662] resolved() for ‘SequentialFuture’ ...
[09:32:19.662] - state: ‘finished’
[09:32:19.662] - run: TRUE
[09:32:19.662] - result: ‘FutureResult’
[09:32:19.662] resolved() for ‘SequentialFuture’ ... done
[09:32:19.662] Future #2
[09:32:19.662]  length: 2 (resolved future 2)
[09:32:19.662] resolved() for ‘SequentialFuture’ ...
[09:32:19.662] - state: ‘finished’
[09:32:19.663] - run: TRUE
[09:32:19.663] - result: ‘FutureResult’
[09:32:19.663] resolved() for ‘SequentialFuture’ ... done
[09:32:19.663] Future #3
[09:32:19.663]  length: 1 (resolved future 3)
[09:32:19.663]  length: 0 (resolved future 4)
[09:32:19.663] resolve() on list environment ... DONE
[09:32:19.663] resolved() for ‘SequentialFuture’ ...
[09:32:19.664] - state: ‘finished’
[09:32:19.664] - run: TRUE
[09:32:19.664] - result: ‘FutureResult’
[09:32:19.664] resolved() for ‘SequentialFuture’ ... done
[09:32:19.664] resolve() on list environment ...
[09:32:19.664]  recursive: 0
[09:32:19.665]  length: 4
[09:32:19.665]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.665] resolved() for ‘SequentialFuture’ ...
[09:32:19.665] - state: ‘finished’
[09:32:19.665] - run: TRUE
[09:32:19.665] - result: ‘FutureResult’
[09:32:19.665] resolved() for ‘SequentialFuture’ ... done
[09:32:19.665] Future #1
[09:32:19.665]  length: 3 (resolved future 1)
[09:32:19.665] resolved() for ‘SequentialFuture’ ...
[09:32:19.666] - state: ‘finished’
[09:32:19.666] - run: TRUE
[09:32:19.666] - result: ‘FutureResult’
[09:32:19.666] resolved() for ‘SequentialFuture’ ... done
[09:32:19.666] Future #2
[09:32:19.666]  length: 2 (resolved future 2)
[09:32:19.666] resolved() for ‘SequentialFuture’ ...
[09:32:19.666] - state: ‘finished’
[09:32:19.666] - run: TRUE
[09:32:19.666] - result: ‘FutureResult’
[09:32:19.666] resolved() for ‘SequentialFuture’ ... done
[09:32:19.667] Future #3
[09:32:19.667]  length: 1 (resolved future 3)
[09:32:19.667]  length: 0 (resolved future 4)
[09:32:19.667] resolve() on list environment ... DONE
[09:32:19.667] resolve() on list environment ...
[09:32:19.667]  recursive: 0
[09:32:19.668]  length: 4
[09:32:19.668]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.668] resolved() for ‘SequentialFuture’ ...
[09:32:19.668] - state: ‘finished’
[09:32:19.668] - run: TRUE
[09:32:19.669] - result: ‘FutureResult’
[09:32:19.669] resolved() for ‘SequentialFuture’ ... done
[09:32:19.669] Future #1
[09:32:19.669]  length: 3 (resolved future 1)
[09:32:19.669] resolved() for ‘SequentialFuture’ ...
[09:32:19.669] - state: ‘finished’
[09:32:19.669] - run: TRUE
[09:32:19.669] - result: ‘FutureResult’
[09:32:19.669] resolved() for ‘SequentialFuture’ ... done
[09:32:19.669] Future #2
[09:32:19.669]  length: 2 (resolved future 2)
[09:32:19.670] resolved() for ‘SequentialFuture’ ...
[09:32:19.670] - state: ‘finished’
[09:32:19.670] - run: TRUE
[09:32:19.670] - result: ‘FutureResult’
[09:32:19.670] resolved() for ‘SequentialFuture’ ... done
[09:32:19.670] Future #3
[09:32:19.670]  length: 1 (resolved future 3)
[09:32:19.670]  length: 0 (resolved future 4)
[09:32:19.670] resolve() on list environment ... DONE
[09:32:19.671] resolve() on list environment ...
[09:32:19.671]  recursive: 0
[09:32:19.671]  length: 4
[09:32:19.671]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.672] resolved() for ‘SequentialFuture’ ...
[09:32:19.672] - state: ‘finished’
[09:32:19.672] - run: TRUE
[09:32:19.672] - result: ‘FutureResult’
[09:32:19.672] resolved() for ‘SequentialFuture’ ... done
[09:32:19.672] Future #1
[09:32:19.672]  length: 3 (resolved future 1)
[09:32:19.672] resolved() for ‘SequentialFuture’ ...
[09:32:19.672] - state: ‘finished’
[09:32:19.672] - run: TRUE
[09:32:19.673] - result: ‘FutureResult’
[09:32:19.673] resolved() for ‘SequentialFuture’ ... done
[09:32:19.673] Future #2
[09:32:19.673]  length: 2 (resolved future 2)
[09:32:19.673] resolved() for ‘SequentialFuture’ ...
[09:32:19.673] - state: ‘finished’
[09:32:19.673] - run: TRUE
[09:32:19.673] - result: ‘FutureResult’
[09:32:19.673] resolved() for ‘SequentialFuture’ ... done
[09:32:19.673] Future #3
[09:32:19.673]  length: 1 (resolved future 3)
[09:32:19.674]  length: 0 (resolved future 4)
[09:32:19.674] resolve() on list environment ... DONE
[09:32:19.674] resolve() on list environment ...
[09:32:19.674]  recursive: 0
[09:32:19.675]  length: 4
[09:32:19.675]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.675] resolved() for ‘SequentialFuture’ ...
[09:32:19.675] - state: ‘finished’
[09:32:19.675] - run: TRUE
[09:32:19.675] - result: ‘FutureResult’
[09:32:19.675] resolved() for ‘SequentialFuture’ ... done
[09:32:19.675] Future #1
[09:32:19.676]  length: 3 (resolved future 1)
[09:32:19.676] resolved() for ‘SequentialFuture’ ...
[09:32:19.676] - state: ‘finished’
[09:32:19.676] - run: TRUE
[09:32:19.676] - result: ‘FutureResult’
[09:32:19.676] resolved() for ‘SequentialFuture’ ... done
[09:32:19.676] Future #2
[09:32:19.676]  length: 2 (resolved future 2)
[09:32:19.676] resolved() for ‘SequentialFuture’ ...
[09:32:19.676] - state: ‘finished’
[09:32:19.677] - run: TRUE
[09:32:19.677] - result: ‘FutureResult’
[09:32:19.677] resolved() for ‘SequentialFuture’ ... done
[09:32:19.677] Future #3
[09:32:19.677]  length: 1 (resolved future 3)
[09:32:19.677]  length: 0 (resolved future 4)
[09:32:19.677] resolve() on list environment ... DONE
[09:32:19.678] resolve() on list environment ...
[09:32:19.678]  recursive: 99
[09:32:19.678]  length: 4
[09:32:19.678]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:19.678] resolved() for ‘SequentialFuture’ ...
[09:32:19.678] - state: ‘finished’
[09:32:19.679] - run: TRUE
[09:32:19.679] - result: ‘FutureResult’
[09:32:19.679] resolved() for ‘SequentialFuture’ ... done
[09:32:19.679] Future #1
[09:32:19.679] resolved() for ‘SequentialFuture’ ...
[09:32:19.680] - state: ‘finished’
[09:32:19.680] - run: TRUE
[09:32:19.680] - result: ‘FutureResult’
[09:32:19.680] resolved() for ‘SequentialFuture’ ... done
[09:32:19.681] A SequentialFuture was resolved
[09:32:19.681]  length: 3 (resolved future 1)
[09:32:19.681] resolved() for ‘SequentialFuture’ ...
[09:32:19.681] - state: ‘finished’
[09:32:19.681] - run: TRUE
[09:32:19.681] - result: ‘FutureResult’
[09:32:19.681] resolved() for ‘SequentialFuture’ ... done
[09:32:19.681] Future #2
[09:32:19.681] resolved() for ‘SequentialFuture’ ...
[09:32:19.681] - state: ‘finished’
[09:32:19.682] - run: TRUE
[09:32:19.682] - result: ‘FutureResult’
[09:32:19.682] resolved() for ‘SequentialFuture’ ... done
[09:32:19.682] A SequentialFuture was resolved
[09:32:19.682]  length: 2 (resolved future 2)
[09:32:19.682] resolved() for ‘SequentialFuture’ ...
[09:32:19.682] - state: ‘finished’
[09:32:19.682] - run: TRUE
[09:32:19.682] - result: ‘FutureResult’
[09:32:19.682] resolved() for ‘SequentialFuture’ ... done
[09:32:19.682] Future #3
[09:32:19.683] resolved() for ‘SequentialFuture’ ...
[09:32:19.683] - state: ‘finished’
[09:32:19.683] - run: TRUE
[09:32:19.683] - result: ‘FutureResult’
[09:32:19.683] resolved() for ‘SequentialFuture’ ... done
[09:32:19.683] A SequentialFuture was resolved
[09:32:19.683]  length: 1 (resolved future 3)
[09:32:19.683]  length: 0 (resolved future 4)
[09:32:19.683] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[09:32:19.684] plan(): Setting new future strategy stack:
[09:32:19.684] List of future strategies:
[09:32:19.684] 1. multicore:
[09:32:19.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.684]    - tweaked: FALSE
[09:32:19.684]    - call: plan(strategy)
[09:32:19.688] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[09:32:19.688] resolve() on list ...
[09:32:19.688]  recursive: 0
[09:32:19.688]  length: 2
[09:32:19.688]  elements: ‘a’, ‘b’
[09:32:19.688]  length: 1 (resolved future 1)
[09:32:19.688]  length: 0 (resolved future 2)
[09:32:19.688] resolve() on list ... DONE
[09:32:19.689] getGlobalsAndPackages() ...
[09:32:19.689] Searching for globals...
[09:32:19.689] 
[09:32:19.689] Searching for globals ... DONE
[09:32:19.689] - globals: [0] <none>
[09:32:19.689] getGlobalsAndPackages() ... DONE
[09:32:19.689] run() for ‘Future’ ...
[09:32:19.690] - state: ‘created’
[09:32:19.690] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.693] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.693] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.693]   - Field: ‘label’
[09:32:19.693]   - Field: ‘local’
[09:32:19.694]   - Field: ‘owner’
[09:32:19.694]   - Field: ‘envir’
[09:32:19.694]   - Field: ‘workers’
[09:32:19.694]   - Field: ‘packages’
[09:32:19.694]   - Field: ‘gc’
[09:32:19.694]   - Field: ‘job’
[09:32:19.694]   - Field: ‘conditions’
[09:32:19.694]   - Field: ‘expr’
[09:32:19.694]   - Field: ‘uuid’
[09:32:19.694]   - Field: ‘seed’
[09:32:19.694]   - Field: ‘version’
[09:32:19.695]   - Field: ‘result’
[09:32:19.695]   - Field: ‘asynchronous’
[09:32:19.695]   - Field: ‘calls’
[09:32:19.695]   - Field: ‘globals’
[09:32:19.695]   - Field: ‘stdout’
[09:32:19.695]   - Field: ‘earlySignal’
[09:32:19.695]   - Field: ‘lazy’
[09:32:19.695]   - Field: ‘state’
[09:32:19.695] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.695] - Launch lazy future ...
[09:32:19.696] Packages needed by the future expression (n = 0): <none>
[09:32:19.696] Packages needed by future strategies (n = 0): <none>
[09:32:19.697] {
[09:32:19.697]     {
[09:32:19.697]         {
[09:32:19.697]             ...future.startTime <- base::Sys.time()
[09:32:19.697]             {
[09:32:19.697]                 {
[09:32:19.697]                   {
[09:32:19.697]                     {
[09:32:19.697]                       base::local({
[09:32:19.697]                         has_future <- base::requireNamespace("future", 
[09:32:19.697]                           quietly = TRUE)
[09:32:19.697]                         if (has_future) {
[09:32:19.697]                           ns <- base::getNamespace("future")
[09:32:19.697]                           version <- ns[[".package"]][["version"]]
[09:32:19.697]                           if (is.null(version)) 
[09:32:19.697]                             version <- utils::packageVersion("future")
[09:32:19.697]                         }
[09:32:19.697]                         else {
[09:32:19.697]                           version <- NULL
[09:32:19.697]                         }
[09:32:19.697]                         if (!has_future || version < "1.8.0") {
[09:32:19.697]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.697]                             "", base::R.version$version.string), 
[09:32:19.697]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.697]                               "release", "version")], collapse = " "), 
[09:32:19.697]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.697]                             info)
[09:32:19.697]                           info <- base::paste(info, collapse = "; ")
[09:32:19.697]                           if (!has_future) {
[09:32:19.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.697]                               info)
[09:32:19.697]                           }
[09:32:19.697]                           else {
[09:32:19.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.697]                               info, version)
[09:32:19.697]                           }
[09:32:19.697]                           base::stop(msg)
[09:32:19.697]                         }
[09:32:19.697]                       })
[09:32:19.697]                     }
[09:32:19.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.697]                     base::options(mc.cores = 1L)
[09:32:19.697]                   }
[09:32:19.697]                   ...future.strategy.old <- future::plan("list")
[09:32:19.697]                   options(future.plan = NULL)
[09:32:19.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.697]                 }
[09:32:19.697]                 ...future.workdir <- getwd()
[09:32:19.697]             }
[09:32:19.697]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.697]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.697]         }
[09:32:19.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.697]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.697]             base::names(...future.oldOptions))
[09:32:19.697]     }
[09:32:19.697]     if (FALSE) {
[09:32:19.697]     }
[09:32:19.697]     else {
[09:32:19.697]         if (TRUE) {
[09:32:19.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.697]                 open = "w")
[09:32:19.697]         }
[09:32:19.697]         else {
[09:32:19.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.697]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.697]         }
[09:32:19.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.697]             base::sink(type = "output", split = FALSE)
[09:32:19.697]             base::close(...future.stdout)
[09:32:19.697]         }, add = TRUE)
[09:32:19.697]     }
[09:32:19.697]     ...future.frame <- base::sys.nframe()
[09:32:19.697]     ...future.conditions <- base::list()
[09:32:19.697]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.697]     if (FALSE) {
[09:32:19.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.697]     }
[09:32:19.697]     ...future.result <- base::tryCatch({
[09:32:19.697]         base::withCallingHandlers({
[09:32:19.697]             ...future.value <- base::withVisible(base::local({
[09:32:19.697]                 withCallingHandlers({
[09:32:19.697]                   1
[09:32:19.697]                 }, immediateCondition = function(cond) {
[09:32:19.697]                   save_rds <- function (object, pathname, ...) 
[09:32:19.697]                   {
[09:32:19.697]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.697]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.697]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.697]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.697]                         fi_tmp[["mtime"]])
[09:32:19.697]                     }
[09:32:19.697]                     tryCatch({
[09:32:19.697]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.697]                     }, error = function(ex) {
[09:32:19.697]                       msg <- conditionMessage(ex)
[09:32:19.697]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.697]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.697]                         fi_tmp[["mtime"]], msg)
[09:32:19.697]                       ex$message <- msg
[09:32:19.697]                       stop(ex)
[09:32:19.697]                     })
[09:32:19.697]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.697]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.697]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.697]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.697]                       fi <- file.info(pathname)
[09:32:19.697]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.697]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.697]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.697]                         fi[["size"]], fi[["mtime"]])
[09:32:19.697]                       stop(msg)
[09:32:19.697]                     }
[09:32:19.697]                     invisible(pathname)
[09:32:19.697]                   }
[09:32:19.697]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.697]                     rootPath = tempdir()) 
[09:32:19.697]                   {
[09:32:19.697]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.697]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.697]                       tmpdir = path, fileext = ".rds")
[09:32:19.697]                     save_rds(obj, file)
[09:32:19.697]                   }
[09:32:19.697]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.697]                   {
[09:32:19.697]                     inherits <- base::inherits
[09:32:19.697]                     invokeRestart <- base::invokeRestart
[09:32:19.697]                     is.null <- base::is.null
[09:32:19.697]                     muffled <- FALSE
[09:32:19.697]                     if (inherits(cond, "message")) {
[09:32:19.697]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.697]                       if (muffled) 
[09:32:19.697]                         invokeRestart("muffleMessage")
[09:32:19.697]                     }
[09:32:19.697]                     else if (inherits(cond, "warning")) {
[09:32:19.697]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.697]                       if (muffled) 
[09:32:19.697]                         invokeRestart("muffleWarning")
[09:32:19.697]                     }
[09:32:19.697]                     else if (inherits(cond, "condition")) {
[09:32:19.697]                       if (!is.null(pattern)) {
[09:32:19.697]                         computeRestarts <- base::computeRestarts
[09:32:19.697]                         grepl <- base::grepl
[09:32:19.697]                         restarts <- computeRestarts(cond)
[09:32:19.697]                         for (restart in restarts) {
[09:32:19.697]                           name <- restart$name
[09:32:19.697]                           if (is.null(name)) 
[09:32:19.697]                             next
[09:32:19.697]                           if (!grepl(pattern, name)) 
[09:32:19.697]                             next
[09:32:19.697]                           invokeRestart(restart)
[09:32:19.697]                           muffled <- TRUE
[09:32:19.697]                           break
[09:32:19.697]                         }
[09:32:19.697]                       }
[09:32:19.697]                     }
[09:32:19.697]                     invisible(muffled)
[09:32:19.697]                   }
[09:32:19.697]                   muffleCondition(cond)
[09:32:19.697]                 })
[09:32:19.697]             }))
[09:32:19.697]             future::FutureResult(value = ...future.value$value, 
[09:32:19.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.697]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.697]                     ...future.globalenv.names))
[09:32:19.697]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.697]         }, condition = base::local({
[09:32:19.697]             c <- base::c
[09:32:19.697]             inherits <- base::inherits
[09:32:19.697]             invokeRestart <- base::invokeRestart
[09:32:19.697]             length <- base::length
[09:32:19.697]             list <- base::list
[09:32:19.697]             seq.int <- base::seq.int
[09:32:19.697]             signalCondition <- base::signalCondition
[09:32:19.697]             sys.calls <- base::sys.calls
[09:32:19.697]             `[[` <- base::`[[`
[09:32:19.697]             `+` <- base::`+`
[09:32:19.697]             `<<-` <- base::`<<-`
[09:32:19.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.697]                   3L)]
[09:32:19.697]             }
[09:32:19.697]             function(cond) {
[09:32:19.697]                 is_error <- inherits(cond, "error")
[09:32:19.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.697]                   NULL)
[09:32:19.697]                 if (is_error) {
[09:32:19.697]                   sessionInformation <- function() {
[09:32:19.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.697]                       search = base::search(), system = base::Sys.info())
[09:32:19.697]                   }
[09:32:19.697]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.697]                     cond$call), session = sessionInformation(), 
[09:32:19.697]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.697]                   signalCondition(cond)
[09:32:19.697]                 }
[09:32:19.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.697]                 "immediateCondition"))) {
[09:32:19.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.697]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.697]                   if (TRUE && !signal) {
[09:32:19.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.697]                     {
[09:32:19.697]                       inherits <- base::inherits
[09:32:19.697]                       invokeRestart <- base::invokeRestart
[09:32:19.697]                       is.null <- base::is.null
[09:32:19.697]                       muffled <- FALSE
[09:32:19.697]                       if (inherits(cond, "message")) {
[09:32:19.697]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.697]                         if (muffled) 
[09:32:19.697]                           invokeRestart("muffleMessage")
[09:32:19.697]                       }
[09:32:19.697]                       else if (inherits(cond, "warning")) {
[09:32:19.697]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.697]                         if (muffled) 
[09:32:19.697]                           invokeRestart("muffleWarning")
[09:32:19.697]                       }
[09:32:19.697]                       else if (inherits(cond, "condition")) {
[09:32:19.697]                         if (!is.null(pattern)) {
[09:32:19.697]                           computeRestarts <- base::computeRestarts
[09:32:19.697]                           grepl <- base::grepl
[09:32:19.697]                           restarts <- computeRestarts(cond)
[09:32:19.697]                           for (restart in restarts) {
[09:32:19.697]                             name <- restart$name
[09:32:19.697]                             if (is.null(name)) 
[09:32:19.697]                               next
[09:32:19.697]                             if (!grepl(pattern, name)) 
[09:32:19.697]                               next
[09:32:19.697]                             invokeRestart(restart)
[09:32:19.697]                             muffled <- TRUE
[09:32:19.697]                             break
[09:32:19.697]                           }
[09:32:19.697]                         }
[09:32:19.697]                       }
[09:32:19.697]                       invisible(muffled)
[09:32:19.697]                     }
[09:32:19.697]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.697]                   }
[09:32:19.697]                 }
[09:32:19.697]                 else {
[09:32:19.697]                   if (TRUE) {
[09:32:19.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.697]                     {
[09:32:19.697]                       inherits <- base::inherits
[09:32:19.697]                       invokeRestart <- base::invokeRestart
[09:32:19.697]                       is.null <- base::is.null
[09:32:19.697]                       muffled <- FALSE
[09:32:19.697]                       if (inherits(cond, "message")) {
[09:32:19.697]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.697]                         if (muffled) 
[09:32:19.697]                           invokeRestart("muffleMessage")
[09:32:19.697]                       }
[09:32:19.697]                       else if (inherits(cond, "warning")) {
[09:32:19.697]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.697]                         if (muffled) 
[09:32:19.697]                           invokeRestart("muffleWarning")
[09:32:19.697]                       }
[09:32:19.697]                       else if (inherits(cond, "condition")) {
[09:32:19.697]                         if (!is.null(pattern)) {
[09:32:19.697]                           computeRestarts <- base::computeRestarts
[09:32:19.697]                           grepl <- base::grepl
[09:32:19.697]                           restarts <- computeRestarts(cond)
[09:32:19.697]                           for (restart in restarts) {
[09:32:19.697]                             name <- restart$name
[09:32:19.697]                             if (is.null(name)) 
[09:32:19.697]                               next
[09:32:19.697]                             if (!grepl(pattern, name)) 
[09:32:19.697]                               next
[09:32:19.697]                             invokeRestart(restart)
[09:32:19.697]                             muffled <- TRUE
[09:32:19.697]                             break
[09:32:19.697]                           }
[09:32:19.697]                         }
[09:32:19.697]                       }
[09:32:19.697]                       invisible(muffled)
[09:32:19.697]                     }
[09:32:19.697]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.697]                   }
[09:32:19.697]                 }
[09:32:19.697]             }
[09:32:19.697]         }))
[09:32:19.697]     }, error = function(ex) {
[09:32:19.697]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.697]                 ...future.rng), started = ...future.startTime, 
[09:32:19.697]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.697]             version = "1.8"), class = "FutureResult")
[09:32:19.697]     }, finally = {
[09:32:19.697]         if (!identical(...future.workdir, getwd())) 
[09:32:19.697]             setwd(...future.workdir)
[09:32:19.697]         {
[09:32:19.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.697]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.697]             }
[09:32:19.697]             base::options(...future.oldOptions)
[09:32:19.697]             if (.Platform$OS.type == "windows") {
[09:32:19.697]                 old_names <- names(...future.oldEnvVars)
[09:32:19.697]                 envs <- base::Sys.getenv()
[09:32:19.697]                 names <- names(envs)
[09:32:19.697]                 common <- intersect(names, old_names)
[09:32:19.697]                 added <- setdiff(names, old_names)
[09:32:19.697]                 removed <- setdiff(old_names, names)
[09:32:19.697]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.697]                   envs[common]]
[09:32:19.697]                 NAMES <- toupper(changed)
[09:32:19.697]                 args <- list()
[09:32:19.697]                 for (kk in seq_along(NAMES)) {
[09:32:19.697]                   name <- changed[[kk]]
[09:32:19.697]                   NAME <- NAMES[[kk]]
[09:32:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.697]                     next
[09:32:19.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.697]                 }
[09:32:19.697]                 NAMES <- toupper(added)
[09:32:19.697]                 for (kk in seq_along(NAMES)) {
[09:32:19.697]                   name <- added[[kk]]
[09:32:19.697]                   NAME <- NAMES[[kk]]
[09:32:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.697]                     next
[09:32:19.697]                   args[[name]] <- ""
[09:32:19.697]                 }
[09:32:19.697]                 NAMES <- toupper(removed)
[09:32:19.697]                 for (kk in seq_along(NAMES)) {
[09:32:19.697]                   name <- removed[[kk]]
[09:32:19.697]                   NAME <- NAMES[[kk]]
[09:32:19.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.697]                     next
[09:32:19.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.697]                 }
[09:32:19.697]                 if (length(args) > 0) 
[09:32:19.697]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.697]             }
[09:32:19.697]             else {
[09:32:19.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.697]             }
[09:32:19.697]             {
[09:32:19.697]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.697]                   0L) {
[09:32:19.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.697]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.697]                   base::options(opts)
[09:32:19.697]                 }
[09:32:19.697]                 {
[09:32:19.697]                   {
[09:32:19.697]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.697]                     NULL
[09:32:19.697]                   }
[09:32:19.697]                   options(future.plan = NULL)
[09:32:19.697]                   if (is.na(NA_character_)) 
[09:32:19.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.697]                     .init = FALSE)
[09:32:19.697]                 }
[09:32:19.697]             }
[09:32:19.697]         }
[09:32:19.697]     })
[09:32:19.697]     if (TRUE) {
[09:32:19.697]         base::sink(type = "output", split = FALSE)
[09:32:19.697]         if (TRUE) {
[09:32:19.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.697]         }
[09:32:19.697]         else {
[09:32:19.697]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.697]         }
[09:32:19.697]         base::close(...future.stdout)
[09:32:19.697]         ...future.stdout <- NULL
[09:32:19.697]     }
[09:32:19.697]     ...future.result$conditions <- ...future.conditions
[09:32:19.697]     ...future.result$finished <- base::Sys.time()
[09:32:19.697]     ...future.result
[09:32:19.697] }
[09:32:19.699] requestCore(): workers = 2
[09:32:19.702] MulticoreFuture started
[09:32:19.702] - Launch lazy future ... done
[09:32:19.702] plan(): Setting new future strategy stack:
[09:32:19.702] run() for ‘MulticoreFuture’ ... done
[09:32:19.703] getGlobalsAndPackages() ...
[09:32:19.703] Searching for globals...
[09:32:19.703] List of future strategies:
[09:32:19.703] 1. sequential:
[09:32:19.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.703]    - tweaked: FALSE
[09:32:19.703]    - call: NULL
[09:32:19.704] plan(): nbrOfWorkers() = 1
[09:32:19.704] 
[09:32:19.704] Searching for globals ... DONE
[09:32:19.704] - globals: [0] <none>
[09:32:19.705] getGlobalsAndPackages() ... DONE
[09:32:19.705] run() for ‘Future’ ...
[09:32:19.705] - state: ‘created’
[09:32:19.705] plan(): Setting new future strategy stack:
[09:32:19.706] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.706] List of future strategies:
[09:32:19.706] 1. multicore:
[09:32:19.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.706]    - tweaked: FALSE
[09:32:19.706]    - call: plan(strategy)
[09:32:19.710] plan(): nbrOfWorkers() = 2
[09:32:19.710] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.711]   - Field: ‘label’
[09:32:19.711]   - Field: ‘local’
[09:32:19.711]   - Field: ‘owner’
[09:32:19.711]   - Field: ‘envir’
[09:32:19.711]   - Field: ‘workers’
[09:32:19.711]   - Field: ‘packages’
[09:32:19.711]   - Field: ‘gc’
[09:32:19.712]   - Field: ‘job’
[09:32:19.712]   - Field: ‘conditions’
[09:32:19.712]   - Field: ‘expr’
[09:32:19.712]   - Field: ‘uuid’
[09:32:19.712]   - Field: ‘seed’
[09:32:19.712]   - Field: ‘version’
[09:32:19.712]   - Field: ‘result’
[09:32:19.713]   - Field: ‘asynchronous’
[09:32:19.713]   - Field: ‘calls’
[09:32:19.713]   - Field: ‘globals’
[09:32:19.713]   - Field: ‘stdout’
[09:32:19.713]   - Field: ‘earlySignal’
[09:32:19.713]   - Field: ‘lazy’
[09:32:19.713]   - Field: ‘state’
[09:32:19.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.714] - Launch lazy future ...
[09:32:19.714] Packages needed by the future expression (n = 0): <none>
[09:32:19.714] Packages needed by future strategies (n = 0): <none>
[09:32:19.715] {
[09:32:19.715]     {
[09:32:19.715]         {
[09:32:19.715]             ...future.startTime <- base::Sys.time()
[09:32:19.715]             {
[09:32:19.715]                 {
[09:32:19.715]                   {
[09:32:19.715]                     {
[09:32:19.715]                       base::local({
[09:32:19.715]                         has_future <- base::requireNamespace("future", 
[09:32:19.715]                           quietly = TRUE)
[09:32:19.715]                         if (has_future) {
[09:32:19.715]                           ns <- base::getNamespace("future")
[09:32:19.715]                           version <- ns[[".package"]][["version"]]
[09:32:19.715]                           if (is.null(version)) 
[09:32:19.715]                             version <- utils::packageVersion("future")
[09:32:19.715]                         }
[09:32:19.715]                         else {
[09:32:19.715]                           version <- NULL
[09:32:19.715]                         }
[09:32:19.715]                         if (!has_future || version < "1.8.0") {
[09:32:19.715]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.715]                             "", base::R.version$version.string), 
[09:32:19.715]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.715]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.715]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.715]                               "release", "version")], collapse = " "), 
[09:32:19.715]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.715]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.715]                             info)
[09:32:19.715]                           info <- base::paste(info, collapse = "; ")
[09:32:19.715]                           if (!has_future) {
[09:32:19.715]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.715]                               info)
[09:32:19.715]                           }
[09:32:19.715]                           else {
[09:32:19.715]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.715]                               info, version)
[09:32:19.715]                           }
[09:32:19.715]                           base::stop(msg)
[09:32:19.715]                         }
[09:32:19.715]                       })
[09:32:19.715]                     }
[09:32:19.715]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.715]                     base::options(mc.cores = 1L)
[09:32:19.715]                   }
[09:32:19.715]                   ...future.strategy.old <- future::plan("list")
[09:32:19.715]                   options(future.plan = NULL)
[09:32:19.715]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.715]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.715]                 }
[09:32:19.715]                 ...future.workdir <- getwd()
[09:32:19.715]             }
[09:32:19.715]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.715]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.715]         }
[09:32:19.715]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.715]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.715]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.715]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.715]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.715]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.715]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.715]             base::names(...future.oldOptions))
[09:32:19.715]     }
[09:32:19.715]     if (FALSE) {
[09:32:19.715]     }
[09:32:19.715]     else {
[09:32:19.715]         if (TRUE) {
[09:32:19.715]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.715]                 open = "w")
[09:32:19.715]         }
[09:32:19.715]         else {
[09:32:19.715]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.715]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.715]         }
[09:32:19.715]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.715]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.715]             base::sink(type = "output", split = FALSE)
[09:32:19.715]             base::close(...future.stdout)
[09:32:19.715]         }, add = TRUE)
[09:32:19.715]     }
[09:32:19.715]     ...future.frame <- base::sys.nframe()
[09:32:19.715]     ...future.conditions <- base::list()
[09:32:19.715]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.715]     if (FALSE) {
[09:32:19.715]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.715]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.715]     }
[09:32:19.715]     ...future.result <- base::tryCatch({
[09:32:19.715]         base::withCallingHandlers({
[09:32:19.715]             ...future.value <- base::withVisible(base::local({
[09:32:19.715]                 withCallingHandlers({
[09:32:19.715]                   2
[09:32:19.715]                 }, immediateCondition = function(cond) {
[09:32:19.715]                   save_rds <- function (object, pathname, ...) 
[09:32:19.715]                   {
[09:32:19.715]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.715]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.715]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.715]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.715]                         fi_tmp[["mtime"]])
[09:32:19.715]                     }
[09:32:19.715]                     tryCatch({
[09:32:19.715]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.715]                     }, error = function(ex) {
[09:32:19.715]                       msg <- conditionMessage(ex)
[09:32:19.715]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.715]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.715]                         fi_tmp[["mtime"]], msg)
[09:32:19.715]                       ex$message <- msg
[09:32:19.715]                       stop(ex)
[09:32:19.715]                     })
[09:32:19.715]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.715]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.715]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.715]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.715]                       fi <- file.info(pathname)
[09:32:19.715]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.715]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.715]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.715]                         fi[["size"]], fi[["mtime"]])
[09:32:19.715]                       stop(msg)
[09:32:19.715]                     }
[09:32:19.715]                     invisible(pathname)
[09:32:19.715]                   }
[09:32:19.715]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.715]                     rootPath = tempdir()) 
[09:32:19.715]                   {
[09:32:19.715]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.715]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.715]                       tmpdir = path, fileext = ".rds")
[09:32:19.715]                     save_rds(obj, file)
[09:32:19.715]                   }
[09:32:19.715]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.715]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.715]                   {
[09:32:19.715]                     inherits <- base::inherits
[09:32:19.715]                     invokeRestart <- base::invokeRestart
[09:32:19.715]                     is.null <- base::is.null
[09:32:19.715]                     muffled <- FALSE
[09:32:19.715]                     if (inherits(cond, "message")) {
[09:32:19.715]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.715]                       if (muffled) 
[09:32:19.715]                         invokeRestart("muffleMessage")
[09:32:19.715]                     }
[09:32:19.715]                     else if (inherits(cond, "warning")) {
[09:32:19.715]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.715]                       if (muffled) 
[09:32:19.715]                         invokeRestart("muffleWarning")
[09:32:19.715]                     }
[09:32:19.715]                     else if (inherits(cond, "condition")) {
[09:32:19.715]                       if (!is.null(pattern)) {
[09:32:19.715]                         computeRestarts <- base::computeRestarts
[09:32:19.715]                         grepl <- base::grepl
[09:32:19.715]                         restarts <- computeRestarts(cond)
[09:32:19.715]                         for (restart in restarts) {
[09:32:19.715]                           name <- restart$name
[09:32:19.715]                           if (is.null(name)) 
[09:32:19.715]                             next
[09:32:19.715]                           if (!grepl(pattern, name)) 
[09:32:19.715]                             next
[09:32:19.715]                           invokeRestart(restart)
[09:32:19.715]                           muffled <- TRUE
[09:32:19.715]                           break
[09:32:19.715]                         }
[09:32:19.715]                       }
[09:32:19.715]                     }
[09:32:19.715]                     invisible(muffled)
[09:32:19.715]                   }
[09:32:19.715]                   muffleCondition(cond)
[09:32:19.715]                 })
[09:32:19.715]             }))
[09:32:19.715]             future::FutureResult(value = ...future.value$value, 
[09:32:19.715]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.715]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.715]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.715]                     ...future.globalenv.names))
[09:32:19.715]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.715]         }, condition = base::local({
[09:32:19.715]             c <- base::c
[09:32:19.715]             inherits <- base::inherits
[09:32:19.715]             invokeRestart <- base::invokeRestart
[09:32:19.715]             length <- base::length
[09:32:19.715]             list <- base::list
[09:32:19.715]             seq.int <- base::seq.int
[09:32:19.715]             signalCondition <- base::signalCondition
[09:32:19.715]             sys.calls <- base::sys.calls
[09:32:19.715]             `[[` <- base::`[[`
[09:32:19.715]             `+` <- base::`+`
[09:32:19.715]             `<<-` <- base::`<<-`
[09:32:19.715]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.715]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.715]                   3L)]
[09:32:19.715]             }
[09:32:19.715]             function(cond) {
[09:32:19.715]                 is_error <- inherits(cond, "error")
[09:32:19.715]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.715]                   NULL)
[09:32:19.715]                 if (is_error) {
[09:32:19.715]                   sessionInformation <- function() {
[09:32:19.715]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.715]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.715]                       search = base::search(), system = base::Sys.info())
[09:32:19.715]                   }
[09:32:19.715]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.715]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.715]                     cond$call), session = sessionInformation(), 
[09:32:19.715]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.715]                   signalCondition(cond)
[09:32:19.715]                 }
[09:32:19.715]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.715]                 "immediateCondition"))) {
[09:32:19.715]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.715]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.715]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.715]                   if (TRUE && !signal) {
[09:32:19.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.715]                     {
[09:32:19.715]                       inherits <- base::inherits
[09:32:19.715]                       invokeRestart <- base::invokeRestart
[09:32:19.715]                       is.null <- base::is.null
[09:32:19.715]                       muffled <- FALSE
[09:32:19.715]                       if (inherits(cond, "message")) {
[09:32:19.715]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.715]                         if (muffled) 
[09:32:19.715]                           invokeRestart("muffleMessage")
[09:32:19.715]                       }
[09:32:19.715]                       else if (inherits(cond, "warning")) {
[09:32:19.715]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.715]                         if (muffled) 
[09:32:19.715]                           invokeRestart("muffleWarning")
[09:32:19.715]                       }
[09:32:19.715]                       else if (inherits(cond, "condition")) {
[09:32:19.715]                         if (!is.null(pattern)) {
[09:32:19.715]                           computeRestarts <- base::computeRestarts
[09:32:19.715]                           grepl <- base::grepl
[09:32:19.715]                           restarts <- computeRestarts(cond)
[09:32:19.715]                           for (restart in restarts) {
[09:32:19.715]                             name <- restart$name
[09:32:19.715]                             if (is.null(name)) 
[09:32:19.715]                               next
[09:32:19.715]                             if (!grepl(pattern, name)) 
[09:32:19.715]                               next
[09:32:19.715]                             invokeRestart(restart)
[09:32:19.715]                             muffled <- TRUE
[09:32:19.715]                             break
[09:32:19.715]                           }
[09:32:19.715]                         }
[09:32:19.715]                       }
[09:32:19.715]                       invisible(muffled)
[09:32:19.715]                     }
[09:32:19.715]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.715]                   }
[09:32:19.715]                 }
[09:32:19.715]                 else {
[09:32:19.715]                   if (TRUE) {
[09:32:19.715]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.715]                     {
[09:32:19.715]                       inherits <- base::inherits
[09:32:19.715]                       invokeRestart <- base::invokeRestart
[09:32:19.715]                       is.null <- base::is.null
[09:32:19.715]                       muffled <- FALSE
[09:32:19.715]                       if (inherits(cond, "message")) {
[09:32:19.715]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.715]                         if (muffled) 
[09:32:19.715]                           invokeRestart("muffleMessage")
[09:32:19.715]                       }
[09:32:19.715]                       else if (inherits(cond, "warning")) {
[09:32:19.715]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.715]                         if (muffled) 
[09:32:19.715]                           invokeRestart("muffleWarning")
[09:32:19.715]                       }
[09:32:19.715]                       else if (inherits(cond, "condition")) {
[09:32:19.715]                         if (!is.null(pattern)) {
[09:32:19.715]                           computeRestarts <- base::computeRestarts
[09:32:19.715]                           grepl <- base::grepl
[09:32:19.715]                           restarts <- computeRestarts(cond)
[09:32:19.715]                           for (restart in restarts) {
[09:32:19.715]                             name <- restart$name
[09:32:19.715]                             if (is.null(name)) 
[09:32:19.715]                               next
[09:32:19.715]                             if (!grepl(pattern, name)) 
[09:32:19.715]                               next
[09:32:19.715]                             invokeRestart(restart)
[09:32:19.715]                             muffled <- TRUE
[09:32:19.715]                             break
[09:32:19.715]                           }
[09:32:19.715]                         }
[09:32:19.715]                       }
[09:32:19.715]                       invisible(muffled)
[09:32:19.715]                     }
[09:32:19.715]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.715]                   }
[09:32:19.715]                 }
[09:32:19.715]             }
[09:32:19.715]         }))
[09:32:19.715]     }, error = function(ex) {
[09:32:19.715]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.715]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.715]                 ...future.rng), started = ...future.startTime, 
[09:32:19.715]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.715]             version = "1.8"), class = "FutureResult")
[09:32:19.715]     }, finally = {
[09:32:19.715]         if (!identical(...future.workdir, getwd())) 
[09:32:19.715]             setwd(...future.workdir)
[09:32:19.715]         {
[09:32:19.715]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.715]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.715]             }
[09:32:19.715]             base::options(...future.oldOptions)
[09:32:19.715]             if (.Platform$OS.type == "windows") {
[09:32:19.715]                 old_names <- names(...future.oldEnvVars)
[09:32:19.715]                 envs <- base::Sys.getenv()
[09:32:19.715]                 names <- names(envs)
[09:32:19.715]                 common <- intersect(names, old_names)
[09:32:19.715]                 added <- setdiff(names, old_names)
[09:32:19.715]                 removed <- setdiff(old_names, names)
[09:32:19.715]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.715]                   envs[common]]
[09:32:19.715]                 NAMES <- toupper(changed)
[09:32:19.715]                 args <- list()
[09:32:19.715]                 for (kk in seq_along(NAMES)) {
[09:32:19.715]                   name <- changed[[kk]]
[09:32:19.715]                   NAME <- NAMES[[kk]]
[09:32:19.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.715]                     next
[09:32:19.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.715]                 }
[09:32:19.715]                 NAMES <- toupper(added)
[09:32:19.715]                 for (kk in seq_along(NAMES)) {
[09:32:19.715]                   name <- added[[kk]]
[09:32:19.715]                   NAME <- NAMES[[kk]]
[09:32:19.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.715]                     next
[09:32:19.715]                   args[[name]] <- ""
[09:32:19.715]                 }
[09:32:19.715]                 NAMES <- toupper(removed)
[09:32:19.715]                 for (kk in seq_along(NAMES)) {
[09:32:19.715]                   name <- removed[[kk]]
[09:32:19.715]                   NAME <- NAMES[[kk]]
[09:32:19.715]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.715]                     next
[09:32:19.715]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.715]                 }
[09:32:19.715]                 if (length(args) > 0) 
[09:32:19.715]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.715]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.715]             }
[09:32:19.715]             else {
[09:32:19.715]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.715]             }
[09:32:19.715]             {
[09:32:19.715]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.715]                   0L) {
[09:32:19.715]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.715]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.715]                   base::options(opts)
[09:32:19.715]                 }
[09:32:19.715]                 {
[09:32:19.715]                   {
[09:32:19.715]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.715]                     NULL
[09:32:19.715]                   }
[09:32:19.715]                   options(future.plan = NULL)
[09:32:19.715]                   if (is.na(NA_character_)) 
[09:32:19.715]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.715]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.715]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.715]                     .init = FALSE)
[09:32:19.715]                 }
[09:32:19.715]             }
[09:32:19.715]         }
[09:32:19.715]     })
[09:32:19.715]     if (TRUE) {
[09:32:19.715]         base::sink(type = "output", split = FALSE)
[09:32:19.715]         if (TRUE) {
[09:32:19.715]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.715]         }
[09:32:19.715]         else {
[09:32:19.715]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.715]         }
[09:32:19.715]         base::close(...future.stdout)
[09:32:19.715]         ...future.stdout <- NULL
[09:32:19.715]     }
[09:32:19.715]     ...future.result$conditions <- ...future.conditions
[09:32:19.715]     ...future.result$finished <- base::Sys.time()
[09:32:19.715]     ...future.result
[09:32:19.715] }
[09:32:19.718] requestCore(): workers = 2
[09:32:19.724] MulticoreFuture started
[09:32:19.724] - Launch lazy future ... done
[09:32:19.724] run() for ‘MulticoreFuture’ ... done
[09:32:19.725] resolve() on list ...
[09:32:19.725]  recursive: 0
[09:32:19.725]  length: 3
[09:32:19.725] plan(): Setting new future strategy stack:
[09:32:19.725]  elements: ‘a’, ‘b’, ‘’
[09:32:19.725] List of future strategies:
[09:32:19.725] 1. sequential:
[09:32:19.725]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.725]    - tweaked: FALSE
[09:32:19.725]    - call: NULL
[09:32:19.726] plan(): nbrOfWorkers() = 1
[09:32:19.774] Future #1
[09:32:19.774]  length: 2 (resolved future 1)
[09:32:19.774] plan(): Setting new future strategy stack:
[09:32:19.774] List of future strategies:
[09:32:19.774] 1. multicore:
[09:32:19.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.774]    - tweaked: FALSE
[09:32:19.774]    - call: plan(strategy)
[09:32:19.778] plan(): nbrOfWorkers() = 2
[09:32:19.778] Future #2
[09:32:19.778]  length: 1 (resolved future 2)
[09:32:19.778]  length: 0 (resolved future 3)
[09:32:19.779] resolve() on list ... DONE
[09:32:19.779] getGlobalsAndPackages() ...
[09:32:19.779] Searching for globals...
[09:32:19.780] 
[09:32:19.780] Searching for globals ... DONE
[09:32:19.780] - globals: [0] <none>
[09:32:19.780] getGlobalsAndPackages() ... DONE
[09:32:19.780] getGlobalsAndPackages() ...
[09:32:19.780] Searching for globals...
[09:32:19.781] 
[09:32:19.781] Searching for globals ... DONE
[09:32:19.781] - globals: [0] <none>
[09:32:19.781] getGlobalsAndPackages() ... DONE
[09:32:19.781] run() for ‘Future’ ...
[09:32:19.781] - state: ‘created’
[09:32:19.781] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.785]   - Field: ‘label’
[09:32:19.785]   - Field: ‘local’
[09:32:19.785]   - Field: ‘owner’
[09:32:19.786]   - Field: ‘envir’
[09:32:19.786]   - Field: ‘workers’
[09:32:19.786]   - Field: ‘packages’
[09:32:19.786]   - Field: ‘gc’
[09:32:19.786]   - Field: ‘job’
[09:32:19.786]   - Field: ‘conditions’
[09:32:19.786]   - Field: ‘expr’
[09:32:19.786]   - Field: ‘uuid’
[09:32:19.786]   - Field: ‘seed’
[09:32:19.786]   - Field: ‘version’
[09:32:19.787]   - Field: ‘result’
[09:32:19.787]   - Field: ‘asynchronous’
[09:32:19.787]   - Field: ‘calls’
[09:32:19.787]   - Field: ‘globals’
[09:32:19.787]   - Field: ‘stdout’
[09:32:19.787]   - Field: ‘earlySignal’
[09:32:19.787]   - Field: ‘lazy’
[09:32:19.787]   - Field: ‘state’
[09:32:19.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.787] - Launch lazy future ...
[09:32:19.788] Packages needed by the future expression (n = 0): <none>
[09:32:19.788] Packages needed by future strategies (n = 0): <none>
[09:32:19.788] {
[09:32:19.788]     {
[09:32:19.788]         {
[09:32:19.788]             ...future.startTime <- base::Sys.time()
[09:32:19.788]             {
[09:32:19.788]                 {
[09:32:19.788]                   {
[09:32:19.788]                     {
[09:32:19.788]                       base::local({
[09:32:19.788]                         has_future <- base::requireNamespace("future", 
[09:32:19.788]                           quietly = TRUE)
[09:32:19.788]                         if (has_future) {
[09:32:19.788]                           ns <- base::getNamespace("future")
[09:32:19.788]                           version <- ns[[".package"]][["version"]]
[09:32:19.788]                           if (is.null(version)) 
[09:32:19.788]                             version <- utils::packageVersion("future")
[09:32:19.788]                         }
[09:32:19.788]                         else {
[09:32:19.788]                           version <- NULL
[09:32:19.788]                         }
[09:32:19.788]                         if (!has_future || version < "1.8.0") {
[09:32:19.788]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.788]                             "", base::R.version$version.string), 
[09:32:19.788]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.788]                               "release", "version")], collapse = " "), 
[09:32:19.788]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.788]                             info)
[09:32:19.788]                           info <- base::paste(info, collapse = "; ")
[09:32:19.788]                           if (!has_future) {
[09:32:19.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.788]                               info)
[09:32:19.788]                           }
[09:32:19.788]                           else {
[09:32:19.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.788]                               info, version)
[09:32:19.788]                           }
[09:32:19.788]                           base::stop(msg)
[09:32:19.788]                         }
[09:32:19.788]                       })
[09:32:19.788]                     }
[09:32:19.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.788]                     base::options(mc.cores = 1L)
[09:32:19.788]                   }
[09:32:19.788]                   ...future.strategy.old <- future::plan("list")
[09:32:19.788]                   options(future.plan = NULL)
[09:32:19.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.788]                 }
[09:32:19.788]                 ...future.workdir <- getwd()
[09:32:19.788]             }
[09:32:19.788]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.788]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.788]         }
[09:32:19.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.788]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.788]             base::names(...future.oldOptions))
[09:32:19.788]     }
[09:32:19.788]     if (FALSE) {
[09:32:19.788]     }
[09:32:19.788]     else {
[09:32:19.788]         if (TRUE) {
[09:32:19.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.788]                 open = "w")
[09:32:19.788]         }
[09:32:19.788]         else {
[09:32:19.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.788]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.788]         }
[09:32:19.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.788]             base::sink(type = "output", split = FALSE)
[09:32:19.788]             base::close(...future.stdout)
[09:32:19.788]         }, add = TRUE)
[09:32:19.788]     }
[09:32:19.788]     ...future.frame <- base::sys.nframe()
[09:32:19.788]     ...future.conditions <- base::list()
[09:32:19.788]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.788]     if (FALSE) {
[09:32:19.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.788]     }
[09:32:19.788]     ...future.result <- base::tryCatch({
[09:32:19.788]         base::withCallingHandlers({
[09:32:19.788]             ...future.value <- base::withVisible(base::local({
[09:32:19.788]                 withCallingHandlers({
[09:32:19.788]                   2
[09:32:19.788]                 }, immediateCondition = function(cond) {
[09:32:19.788]                   save_rds <- function (object, pathname, ...) 
[09:32:19.788]                   {
[09:32:19.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.788]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.788]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.788]                         fi_tmp[["mtime"]])
[09:32:19.788]                     }
[09:32:19.788]                     tryCatch({
[09:32:19.788]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.788]                     }, error = function(ex) {
[09:32:19.788]                       msg <- conditionMessage(ex)
[09:32:19.788]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.788]                         fi_tmp[["mtime"]], msg)
[09:32:19.788]                       ex$message <- msg
[09:32:19.788]                       stop(ex)
[09:32:19.788]                     })
[09:32:19.788]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.788]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.788]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.788]                       fi <- file.info(pathname)
[09:32:19.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.788]                         fi[["size"]], fi[["mtime"]])
[09:32:19.788]                       stop(msg)
[09:32:19.788]                     }
[09:32:19.788]                     invisible(pathname)
[09:32:19.788]                   }
[09:32:19.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.788]                     rootPath = tempdir()) 
[09:32:19.788]                   {
[09:32:19.788]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.788]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.788]                       tmpdir = path, fileext = ".rds")
[09:32:19.788]                     save_rds(obj, file)
[09:32:19.788]                   }
[09:32:19.788]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.788]                   {
[09:32:19.788]                     inherits <- base::inherits
[09:32:19.788]                     invokeRestart <- base::invokeRestart
[09:32:19.788]                     is.null <- base::is.null
[09:32:19.788]                     muffled <- FALSE
[09:32:19.788]                     if (inherits(cond, "message")) {
[09:32:19.788]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.788]                       if (muffled) 
[09:32:19.788]                         invokeRestart("muffleMessage")
[09:32:19.788]                     }
[09:32:19.788]                     else if (inherits(cond, "warning")) {
[09:32:19.788]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.788]                       if (muffled) 
[09:32:19.788]                         invokeRestart("muffleWarning")
[09:32:19.788]                     }
[09:32:19.788]                     else if (inherits(cond, "condition")) {
[09:32:19.788]                       if (!is.null(pattern)) {
[09:32:19.788]                         computeRestarts <- base::computeRestarts
[09:32:19.788]                         grepl <- base::grepl
[09:32:19.788]                         restarts <- computeRestarts(cond)
[09:32:19.788]                         for (restart in restarts) {
[09:32:19.788]                           name <- restart$name
[09:32:19.788]                           if (is.null(name)) 
[09:32:19.788]                             next
[09:32:19.788]                           if (!grepl(pattern, name)) 
[09:32:19.788]                             next
[09:32:19.788]                           invokeRestart(restart)
[09:32:19.788]                           muffled <- TRUE
[09:32:19.788]                           break
[09:32:19.788]                         }
[09:32:19.788]                       }
[09:32:19.788]                     }
[09:32:19.788]                     invisible(muffled)
[09:32:19.788]                   }
[09:32:19.788]                   muffleCondition(cond)
[09:32:19.788]                 })
[09:32:19.788]             }))
[09:32:19.788]             future::FutureResult(value = ...future.value$value, 
[09:32:19.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.788]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.788]                     ...future.globalenv.names))
[09:32:19.788]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.788]         }, condition = base::local({
[09:32:19.788]             c <- base::c
[09:32:19.788]             inherits <- base::inherits
[09:32:19.788]             invokeRestart <- base::invokeRestart
[09:32:19.788]             length <- base::length
[09:32:19.788]             list <- base::list
[09:32:19.788]             seq.int <- base::seq.int
[09:32:19.788]             signalCondition <- base::signalCondition
[09:32:19.788]             sys.calls <- base::sys.calls
[09:32:19.788]             `[[` <- base::`[[`
[09:32:19.788]             `+` <- base::`+`
[09:32:19.788]             `<<-` <- base::`<<-`
[09:32:19.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.788]                   3L)]
[09:32:19.788]             }
[09:32:19.788]             function(cond) {
[09:32:19.788]                 is_error <- inherits(cond, "error")
[09:32:19.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.788]                   NULL)
[09:32:19.788]                 if (is_error) {
[09:32:19.788]                   sessionInformation <- function() {
[09:32:19.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.788]                       search = base::search(), system = base::Sys.info())
[09:32:19.788]                   }
[09:32:19.788]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.788]                     cond$call), session = sessionInformation(), 
[09:32:19.788]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.788]                   signalCondition(cond)
[09:32:19.788]                 }
[09:32:19.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.788]                 "immediateCondition"))) {
[09:32:19.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.788]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.788]                   if (TRUE && !signal) {
[09:32:19.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.788]                     {
[09:32:19.788]                       inherits <- base::inherits
[09:32:19.788]                       invokeRestart <- base::invokeRestart
[09:32:19.788]                       is.null <- base::is.null
[09:32:19.788]                       muffled <- FALSE
[09:32:19.788]                       if (inherits(cond, "message")) {
[09:32:19.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.788]                         if (muffled) 
[09:32:19.788]                           invokeRestart("muffleMessage")
[09:32:19.788]                       }
[09:32:19.788]                       else if (inherits(cond, "warning")) {
[09:32:19.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.788]                         if (muffled) 
[09:32:19.788]                           invokeRestart("muffleWarning")
[09:32:19.788]                       }
[09:32:19.788]                       else if (inherits(cond, "condition")) {
[09:32:19.788]                         if (!is.null(pattern)) {
[09:32:19.788]                           computeRestarts <- base::computeRestarts
[09:32:19.788]                           grepl <- base::grepl
[09:32:19.788]                           restarts <- computeRestarts(cond)
[09:32:19.788]                           for (restart in restarts) {
[09:32:19.788]                             name <- restart$name
[09:32:19.788]                             if (is.null(name)) 
[09:32:19.788]                               next
[09:32:19.788]                             if (!grepl(pattern, name)) 
[09:32:19.788]                               next
[09:32:19.788]                             invokeRestart(restart)
[09:32:19.788]                             muffled <- TRUE
[09:32:19.788]                             break
[09:32:19.788]                           }
[09:32:19.788]                         }
[09:32:19.788]                       }
[09:32:19.788]                       invisible(muffled)
[09:32:19.788]                     }
[09:32:19.788]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.788]                   }
[09:32:19.788]                 }
[09:32:19.788]                 else {
[09:32:19.788]                   if (TRUE) {
[09:32:19.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.788]                     {
[09:32:19.788]                       inherits <- base::inherits
[09:32:19.788]                       invokeRestart <- base::invokeRestart
[09:32:19.788]                       is.null <- base::is.null
[09:32:19.788]                       muffled <- FALSE
[09:32:19.788]                       if (inherits(cond, "message")) {
[09:32:19.788]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.788]                         if (muffled) 
[09:32:19.788]                           invokeRestart("muffleMessage")
[09:32:19.788]                       }
[09:32:19.788]                       else if (inherits(cond, "warning")) {
[09:32:19.788]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.788]                         if (muffled) 
[09:32:19.788]                           invokeRestart("muffleWarning")
[09:32:19.788]                       }
[09:32:19.788]                       else if (inherits(cond, "condition")) {
[09:32:19.788]                         if (!is.null(pattern)) {
[09:32:19.788]                           computeRestarts <- base::computeRestarts
[09:32:19.788]                           grepl <- base::grepl
[09:32:19.788]                           restarts <- computeRestarts(cond)
[09:32:19.788]                           for (restart in restarts) {
[09:32:19.788]                             name <- restart$name
[09:32:19.788]                             if (is.null(name)) 
[09:32:19.788]                               next
[09:32:19.788]                             if (!grepl(pattern, name)) 
[09:32:19.788]                               next
[09:32:19.788]                             invokeRestart(restart)
[09:32:19.788]                             muffled <- TRUE
[09:32:19.788]                             break
[09:32:19.788]                           }
[09:32:19.788]                         }
[09:32:19.788]                       }
[09:32:19.788]                       invisible(muffled)
[09:32:19.788]                     }
[09:32:19.788]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.788]                   }
[09:32:19.788]                 }
[09:32:19.788]             }
[09:32:19.788]         }))
[09:32:19.788]     }, error = function(ex) {
[09:32:19.788]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.788]                 ...future.rng), started = ...future.startTime, 
[09:32:19.788]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.788]             version = "1.8"), class = "FutureResult")
[09:32:19.788]     }, finally = {
[09:32:19.788]         if (!identical(...future.workdir, getwd())) 
[09:32:19.788]             setwd(...future.workdir)
[09:32:19.788]         {
[09:32:19.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.788]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.788]             }
[09:32:19.788]             base::options(...future.oldOptions)
[09:32:19.788]             if (.Platform$OS.type == "windows") {
[09:32:19.788]                 old_names <- names(...future.oldEnvVars)
[09:32:19.788]                 envs <- base::Sys.getenv()
[09:32:19.788]                 names <- names(envs)
[09:32:19.788]                 common <- intersect(names, old_names)
[09:32:19.788]                 added <- setdiff(names, old_names)
[09:32:19.788]                 removed <- setdiff(old_names, names)
[09:32:19.788]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.788]                   envs[common]]
[09:32:19.788]                 NAMES <- toupper(changed)
[09:32:19.788]                 args <- list()
[09:32:19.788]                 for (kk in seq_along(NAMES)) {
[09:32:19.788]                   name <- changed[[kk]]
[09:32:19.788]                   NAME <- NAMES[[kk]]
[09:32:19.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.788]                     next
[09:32:19.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.788]                 }
[09:32:19.788]                 NAMES <- toupper(added)
[09:32:19.788]                 for (kk in seq_along(NAMES)) {
[09:32:19.788]                   name <- added[[kk]]
[09:32:19.788]                   NAME <- NAMES[[kk]]
[09:32:19.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.788]                     next
[09:32:19.788]                   args[[name]] <- ""
[09:32:19.788]                 }
[09:32:19.788]                 NAMES <- toupper(removed)
[09:32:19.788]                 for (kk in seq_along(NAMES)) {
[09:32:19.788]                   name <- removed[[kk]]
[09:32:19.788]                   NAME <- NAMES[[kk]]
[09:32:19.788]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.788]                     next
[09:32:19.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.788]                 }
[09:32:19.788]                 if (length(args) > 0) 
[09:32:19.788]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.788]             }
[09:32:19.788]             else {
[09:32:19.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.788]             }
[09:32:19.788]             {
[09:32:19.788]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.788]                   0L) {
[09:32:19.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.788]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.788]                   base::options(opts)
[09:32:19.788]                 }
[09:32:19.788]                 {
[09:32:19.788]                   {
[09:32:19.788]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.788]                     NULL
[09:32:19.788]                   }
[09:32:19.788]                   options(future.plan = NULL)
[09:32:19.788]                   if (is.na(NA_character_)) 
[09:32:19.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.788]                     .init = FALSE)
[09:32:19.788]                 }
[09:32:19.788]             }
[09:32:19.788]         }
[09:32:19.788]     })
[09:32:19.788]     if (TRUE) {
[09:32:19.788]         base::sink(type = "output", split = FALSE)
[09:32:19.788]         if (TRUE) {
[09:32:19.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.788]         }
[09:32:19.788]         else {
[09:32:19.788]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.788]         }
[09:32:19.788]         base::close(...future.stdout)
[09:32:19.788]         ...future.stdout <- NULL
[09:32:19.788]     }
[09:32:19.788]     ...future.result$conditions <- ...future.conditions
[09:32:19.788]     ...future.result$finished <- base::Sys.time()
[09:32:19.788]     ...future.result
[09:32:19.788] }
[09:32:19.791] requestCore(): workers = 2
[09:32:19.791] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:19.802] result() for MulticoreFuture ...
[09:32:19.803] result() for MulticoreFuture ...
[09:32:19.803] result() for MulticoreFuture ... done
[09:32:19.803] result() for MulticoreFuture ... done
[09:32:19.803] result() for MulticoreFuture ...
[09:32:19.803] result() for MulticoreFuture ... done
[09:32:19.806] MulticoreFuture started
[09:32:19.806] - Launch lazy future ... done
[09:32:19.807] run() for ‘MulticoreFuture’ ... done
[09:32:19.807] resolve() on list ...
[09:32:19.807] plan(): Setting new future strategy stack:
[09:32:19.807]  recursive: 0
[09:32:19.808]  length: 3
[09:32:19.808]  elements: ‘a’, ‘b’, ‘’
[09:32:19.808] run() for ‘Future’ ...
[09:32:19.808] - state: ‘created’
[09:32:19.807] List of future strategies:
[09:32:19.807] 1. sequential:
[09:32:19.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.807]    - tweaked: FALSE
[09:32:19.807]    - call: NULL
[09:32:19.809] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.809] plan(): nbrOfWorkers() = 1
[09:32:19.811] plan(): Setting new future strategy stack:
[09:32:19.812] List of future strategies:
[09:32:19.812] 1. multicore:
[09:32:19.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.812]    - tweaked: FALSE
[09:32:19.812]    - call: plan(strategy)
[09:32:19.815] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.815] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.815]   - Field: ‘label’
[09:32:19.816]   - Field: ‘local’
[09:32:19.816]   - Field: ‘owner’
[09:32:19.816]   - Field: ‘envir’
[09:32:19.816]   - Field: ‘workers’
[09:32:19.817] plan(): nbrOfWorkers() = 2
[09:32:19.817]   - Field: ‘packages’
[09:32:19.817]   - Field: ‘gc’
[09:32:19.817]   - Field: ‘job’
[09:32:19.817]   - Field: ‘conditions’
[09:32:19.817]   - Field: ‘expr’
[09:32:19.817]   - Field: ‘uuid’
[09:32:19.818]   - Field: ‘seed’
[09:32:19.818]   - Field: ‘version’
[09:32:19.818]   - Field: ‘result’
[09:32:19.818]   - Field: ‘asynchronous’
[09:32:19.818]   - Field: ‘calls’
[09:32:19.818]   - Field: ‘globals’
[09:32:19.818]   - Field: ‘stdout’
[09:32:19.819]   - Field: ‘earlySignal’
[09:32:19.819]   - Field: ‘lazy’
[09:32:19.819]   - Field: ‘state’
[09:32:19.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.819] - Launch lazy future ...
[09:32:19.820] Packages needed by the future expression (n = 0): <none>
[09:32:19.820] Packages needed by future strategies (n = 0): <none>
[09:32:19.821] {
[09:32:19.821]     {
[09:32:19.821]         {
[09:32:19.821]             ...future.startTime <- base::Sys.time()
[09:32:19.821]             {
[09:32:19.821]                 {
[09:32:19.821]                   {
[09:32:19.821]                     {
[09:32:19.821]                       base::local({
[09:32:19.821]                         has_future <- base::requireNamespace("future", 
[09:32:19.821]                           quietly = TRUE)
[09:32:19.821]                         if (has_future) {
[09:32:19.821]                           ns <- base::getNamespace("future")
[09:32:19.821]                           version <- ns[[".package"]][["version"]]
[09:32:19.821]                           if (is.null(version)) 
[09:32:19.821]                             version <- utils::packageVersion("future")
[09:32:19.821]                         }
[09:32:19.821]                         else {
[09:32:19.821]                           version <- NULL
[09:32:19.821]                         }
[09:32:19.821]                         if (!has_future || version < "1.8.0") {
[09:32:19.821]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.821]                             "", base::R.version$version.string), 
[09:32:19.821]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.821]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.821]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.821]                               "release", "version")], collapse = " "), 
[09:32:19.821]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.821]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.821]                             info)
[09:32:19.821]                           info <- base::paste(info, collapse = "; ")
[09:32:19.821]                           if (!has_future) {
[09:32:19.821]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.821]                               info)
[09:32:19.821]                           }
[09:32:19.821]                           else {
[09:32:19.821]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.821]                               info, version)
[09:32:19.821]                           }
[09:32:19.821]                           base::stop(msg)
[09:32:19.821]                         }
[09:32:19.821]                       })
[09:32:19.821]                     }
[09:32:19.821]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.821]                     base::options(mc.cores = 1L)
[09:32:19.821]                   }
[09:32:19.821]                   ...future.strategy.old <- future::plan("list")
[09:32:19.821]                   options(future.plan = NULL)
[09:32:19.821]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.821]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.821]                 }
[09:32:19.821]                 ...future.workdir <- getwd()
[09:32:19.821]             }
[09:32:19.821]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.821]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.821]         }
[09:32:19.821]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.821]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.821]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.821]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.821]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.821]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.821]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.821]             base::names(...future.oldOptions))
[09:32:19.821]     }
[09:32:19.821]     if (FALSE) {
[09:32:19.821]     }
[09:32:19.821]     else {
[09:32:19.821]         if (TRUE) {
[09:32:19.821]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.821]                 open = "w")
[09:32:19.821]         }
[09:32:19.821]         else {
[09:32:19.821]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.821]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.821]         }
[09:32:19.821]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.821]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.821]             base::sink(type = "output", split = FALSE)
[09:32:19.821]             base::close(...future.stdout)
[09:32:19.821]         }, add = TRUE)
[09:32:19.821]     }
[09:32:19.821]     ...future.frame <- base::sys.nframe()
[09:32:19.821]     ...future.conditions <- base::list()
[09:32:19.821]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.821]     if (FALSE) {
[09:32:19.821]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.821]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.821]     }
[09:32:19.821]     ...future.result <- base::tryCatch({
[09:32:19.821]         base::withCallingHandlers({
[09:32:19.821]             ...future.value <- base::withVisible(base::local({
[09:32:19.821]                 withCallingHandlers({
[09:32:19.821]                   1
[09:32:19.821]                 }, immediateCondition = function(cond) {
[09:32:19.821]                   save_rds <- function (object, pathname, ...) 
[09:32:19.821]                   {
[09:32:19.821]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.821]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.821]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.821]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.821]                         fi_tmp[["mtime"]])
[09:32:19.821]                     }
[09:32:19.821]                     tryCatch({
[09:32:19.821]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.821]                     }, error = function(ex) {
[09:32:19.821]                       msg <- conditionMessage(ex)
[09:32:19.821]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.821]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.821]                         fi_tmp[["mtime"]], msg)
[09:32:19.821]                       ex$message <- msg
[09:32:19.821]                       stop(ex)
[09:32:19.821]                     })
[09:32:19.821]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.821]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.821]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.821]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.821]                       fi <- file.info(pathname)
[09:32:19.821]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.821]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.821]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.821]                         fi[["size"]], fi[["mtime"]])
[09:32:19.821]                       stop(msg)
[09:32:19.821]                     }
[09:32:19.821]                     invisible(pathname)
[09:32:19.821]                   }
[09:32:19.821]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.821]                     rootPath = tempdir()) 
[09:32:19.821]                   {
[09:32:19.821]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.821]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.821]                       tmpdir = path, fileext = ".rds")
[09:32:19.821]                     save_rds(obj, file)
[09:32:19.821]                   }
[09:32:19.821]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.821]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.821]                   {
[09:32:19.821]                     inherits <- base::inherits
[09:32:19.821]                     invokeRestart <- base::invokeRestart
[09:32:19.821]                     is.null <- base::is.null
[09:32:19.821]                     muffled <- FALSE
[09:32:19.821]                     if (inherits(cond, "message")) {
[09:32:19.821]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.821]                       if (muffled) 
[09:32:19.821]                         invokeRestart("muffleMessage")
[09:32:19.821]                     }
[09:32:19.821]                     else if (inherits(cond, "warning")) {
[09:32:19.821]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.821]                       if (muffled) 
[09:32:19.821]                         invokeRestart("muffleWarning")
[09:32:19.821]                     }
[09:32:19.821]                     else if (inherits(cond, "condition")) {
[09:32:19.821]                       if (!is.null(pattern)) {
[09:32:19.821]                         computeRestarts <- base::computeRestarts
[09:32:19.821]                         grepl <- base::grepl
[09:32:19.821]                         restarts <- computeRestarts(cond)
[09:32:19.821]                         for (restart in restarts) {
[09:32:19.821]                           name <- restart$name
[09:32:19.821]                           if (is.null(name)) 
[09:32:19.821]                             next
[09:32:19.821]                           if (!grepl(pattern, name)) 
[09:32:19.821]                             next
[09:32:19.821]                           invokeRestart(restart)
[09:32:19.821]                           muffled <- TRUE
[09:32:19.821]                           break
[09:32:19.821]                         }
[09:32:19.821]                       }
[09:32:19.821]                     }
[09:32:19.821]                     invisible(muffled)
[09:32:19.821]                   }
[09:32:19.821]                   muffleCondition(cond)
[09:32:19.821]                 })
[09:32:19.821]             }))
[09:32:19.821]             future::FutureResult(value = ...future.value$value, 
[09:32:19.821]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.821]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.821]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.821]                     ...future.globalenv.names))
[09:32:19.821]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.821]         }, condition = base::local({
[09:32:19.821]             c <- base::c
[09:32:19.821]             inherits <- base::inherits
[09:32:19.821]             invokeRestart <- base::invokeRestart
[09:32:19.821]             length <- base::length
[09:32:19.821]             list <- base::list
[09:32:19.821]             seq.int <- base::seq.int
[09:32:19.821]             signalCondition <- base::signalCondition
[09:32:19.821]             sys.calls <- base::sys.calls
[09:32:19.821]             `[[` <- base::`[[`
[09:32:19.821]             `+` <- base::`+`
[09:32:19.821]             `<<-` <- base::`<<-`
[09:32:19.821]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.821]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.821]                   3L)]
[09:32:19.821]             }
[09:32:19.821]             function(cond) {
[09:32:19.821]                 is_error <- inherits(cond, "error")
[09:32:19.821]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.821]                   NULL)
[09:32:19.821]                 if (is_error) {
[09:32:19.821]                   sessionInformation <- function() {
[09:32:19.821]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.821]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.821]                       search = base::search(), system = base::Sys.info())
[09:32:19.821]                   }
[09:32:19.821]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.821]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.821]                     cond$call), session = sessionInformation(), 
[09:32:19.821]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.821]                   signalCondition(cond)
[09:32:19.821]                 }
[09:32:19.821]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.821]                 "immediateCondition"))) {
[09:32:19.821]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.821]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.821]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.821]                   if (TRUE && !signal) {
[09:32:19.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.821]                     {
[09:32:19.821]                       inherits <- base::inherits
[09:32:19.821]                       invokeRestart <- base::invokeRestart
[09:32:19.821]                       is.null <- base::is.null
[09:32:19.821]                       muffled <- FALSE
[09:32:19.821]                       if (inherits(cond, "message")) {
[09:32:19.821]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.821]                         if (muffled) 
[09:32:19.821]                           invokeRestart("muffleMessage")
[09:32:19.821]                       }
[09:32:19.821]                       else if (inherits(cond, "warning")) {
[09:32:19.821]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.821]                         if (muffled) 
[09:32:19.821]                           invokeRestart("muffleWarning")
[09:32:19.821]                       }
[09:32:19.821]                       else if (inherits(cond, "condition")) {
[09:32:19.821]                         if (!is.null(pattern)) {
[09:32:19.821]                           computeRestarts <- base::computeRestarts
[09:32:19.821]                           grepl <- base::grepl
[09:32:19.821]                           restarts <- computeRestarts(cond)
[09:32:19.821]                           for (restart in restarts) {
[09:32:19.821]                             name <- restart$name
[09:32:19.821]                             if (is.null(name)) 
[09:32:19.821]                               next
[09:32:19.821]                             if (!grepl(pattern, name)) 
[09:32:19.821]                               next
[09:32:19.821]                             invokeRestart(restart)
[09:32:19.821]                             muffled <- TRUE
[09:32:19.821]                             break
[09:32:19.821]                           }
[09:32:19.821]                         }
[09:32:19.821]                       }
[09:32:19.821]                       invisible(muffled)
[09:32:19.821]                     }
[09:32:19.821]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.821]                   }
[09:32:19.821]                 }
[09:32:19.821]                 else {
[09:32:19.821]                   if (TRUE) {
[09:32:19.821]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.821]                     {
[09:32:19.821]                       inherits <- base::inherits
[09:32:19.821]                       invokeRestart <- base::invokeRestart
[09:32:19.821]                       is.null <- base::is.null
[09:32:19.821]                       muffled <- FALSE
[09:32:19.821]                       if (inherits(cond, "message")) {
[09:32:19.821]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.821]                         if (muffled) 
[09:32:19.821]                           invokeRestart("muffleMessage")
[09:32:19.821]                       }
[09:32:19.821]                       else if (inherits(cond, "warning")) {
[09:32:19.821]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.821]                         if (muffled) 
[09:32:19.821]                           invokeRestart("muffleWarning")
[09:32:19.821]                       }
[09:32:19.821]                       else if (inherits(cond, "condition")) {
[09:32:19.821]                         if (!is.null(pattern)) {
[09:32:19.821]                           computeRestarts <- base::computeRestarts
[09:32:19.821]                           grepl <- base::grepl
[09:32:19.821]                           restarts <- computeRestarts(cond)
[09:32:19.821]                           for (restart in restarts) {
[09:32:19.821]                             name <- restart$name
[09:32:19.821]                             if (is.null(name)) 
[09:32:19.821]                               next
[09:32:19.821]                             if (!grepl(pattern, name)) 
[09:32:19.821]                               next
[09:32:19.821]                             invokeRestart(restart)
[09:32:19.821]                             muffled <- TRUE
[09:32:19.821]                             break
[09:32:19.821]                           }
[09:32:19.821]                         }
[09:32:19.821]                       }
[09:32:19.821]                       invisible(muffled)
[09:32:19.821]                     }
[09:32:19.821]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.821]                   }
[09:32:19.821]                 }
[09:32:19.821]             }
[09:32:19.821]         }))
[09:32:19.821]     }, error = function(ex) {
[09:32:19.821]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.821]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.821]                 ...future.rng), started = ...future.startTime, 
[09:32:19.821]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.821]             version = "1.8"), class = "FutureResult")
[09:32:19.821]     }, finally = {
[09:32:19.821]         if (!identical(...future.workdir, getwd())) 
[09:32:19.821]             setwd(...future.workdir)
[09:32:19.821]         {
[09:32:19.821]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.821]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.821]             }
[09:32:19.821]             base::options(...future.oldOptions)
[09:32:19.821]             if (.Platform$OS.type == "windows") {
[09:32:19.821]                 old_names <- names(...future.oldEnvVars)
[09:32:19.821]                 envs <- base::Sys.getenv()
[09:32:19.821]                 names <- names(envs)
[09:32:19.821]                 common <- intersect(names, old_names)
[09:32:19.821]                 added <- setdiff(names, old_names)
[09:32:19.821]                 removed <- setdiff(old_names, names)
[09:32:19.821]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.821]                   envs[common]]
[09:32:19.821]                 NAMES <- toupper(changed)
[09:32:19.821]                 args <- list()
[09:32:19.821]                 for (kk in seq_along(NAMES)) {
[09:32:19.821]                   name <- changed[[kk]]
[09:32:19.821]                   NAME <- NAMES[[kk]]
[09:32:19.821]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.821]                     next
[09:32:19.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.821]                 }
[09:32:19.821]                 NAMES <- toupper(added)
[09:32:19.821]                 for (kk in seq_along(NAMES)) {
[09:32:19.821]                   name <- added[[kk]]
[09:32:19.821]                   NAME <- NAMES[[kk]]
[09:32:19.821]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.821]                     next
[09:32:19.821]                   args[[name]] <- ""
[09:32:19.821]                 }
[09:32:19.821]                 NAMES <- toupper(removed)
[09:32:19.821]                 for (kk in seq_along(NAMES)) {
[09:32:19.821]                   name <- removed[[kk]]
[09:32:19.821]                   NAME <- NAMES[[kk]]
[09:32:19.821]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.821]                     next
[09:32:19.821]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.821]                 }
[09:32:19.821]                 if (length(args) > 0) 
[09:32:19.821]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.821]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.821]             }
[09:32:19.821]             else {
[09:32:19.821]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.821]             }
[09:32:19.821]             {
[09:32:19.821]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.821]                   0L) {
[09:32:19.821]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.821]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.821]                   base::options(opts)
[09:32:19.821]                 }
[09:32:19.821]                 {
[09:32:19.821]                   {
[09:32:19.821]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.821]                     NULL
[09:32:19.821]                   }
[09:32:19.821]                   options(future.plan = NULL)
[09:32:19.821]                   if (is.na(NA_character_)) 
[09:32:19.821]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.821]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.821]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.821]                     .init = FALSE)
[09:32:19.821]                 }
[09:32:19.821]             }
[09:32:19.821]         }
[09:32:19.821]     })
[09:32:19.821]     if (TRUE) {
[09:32:19.821]         base::sink(type = "output", split = FALSE)
[09:32:19.821]         if (TRUE) {
[09:32:19.821]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.821]         }
[09:32:19.821]         else {
[09:32:19.821]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.821]         }
[09:32:19.821]         base::close(...future.stdout)
[09:32:19.821]         ...future.stdout <- NULL
[09:32:19.821]     }
[09:32:19.821]     ...future.result$conditions <- ...future.conditions
[09:32:19.821]     ...future.result$finished <- base::Sys.time()
[09:32:19.821]     ...future.result
[09:32:19.821] }
[09:32:19.824] requestCore(): workers = 2
[09:32:19.824] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:19.851] result() for MulticoreFuture ...
[09:32:19.852] result() for MulticoreFuture ...
[09:32:19.852] result() for MulticoreFuture ... done
[09:32:19.853] result() for MulticoreFuture ... done
[09:32:19.853] result() for MulticoreFuture ...
[09:32:19.853] result() for MulticoreFuture ... done
[09:32:19.856] MulticoreFuture started
[09:32:19.856] - Launch lazy future ... done
[09:32:19.857] run() for ‘MulticoreFuture’ ... done
[09:32:19.857] plan(): Setting new future strategy stack:
[09:32:19.857] List of future strategies:
[09:32:19.857] 1. sequential:
[09:32:19.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.857]    - tweaked: FALSE
[09:32:19.857]    - call: NULL
[09:32:19.859] plan(): nbrOfWorkers() = 1
[09:32:19.861] plan(): Setting new future strategy stack:
[09:32:19.862] List of future strategies:
[09:32:19.862] 1. multicore:
[09:32:19.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.862]    - tweaked: FALSE
[09:32:19.862]    - call: plan(strategy)
[09:32:19.867] plan(): nbrOfWorkers() = 2
[09:32:19.867] Future #1
[09:32:19.867]  length: 2 (resolved future 1)
[09:32:19.868] Future #2
[09:32:19.868]  length: 1 (resolved future 2)
[09:32:19.868]  length: 0 (resolved future 3)
[09:32:19.869] resolve() on list ... DONE
[09:32:19.869] getGlobalsAndPackages() ...
[09:32:19.869] Searching for globals...
[09:32:19.870] 
[09:32:19.870] Searching for globals ... DONE
[09:32:19.871] - globals: [0] <none>
[09:32:19.871] getGlobalsAndPackages() ... DONE
[09:32:19.871] getGlobalsAndPackages() ...
[09:32:19.871] Searching for globals...
[09:32:19.872] 
[09:32:19.872] Searching for globals ... DONE
[09:32:19.872] - globals: [0] <none>
[09:32:19.872] getGlobalsAndPackages() ... DONE
[09:32:19.873] resolve() on list ...
[09:32:19.873]  recursive: 0
[09:32:19.873]  length: 3
[09:32:19.873]  elements: ‘a’, ‘b’, ‘’
[09:32:19.873] run() for ‘Future’ ...
[09:32:19.873] - state: ‘created’
[09:32:19.874] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.878] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.878] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.879]   - Field: ‘label’
[09:32:19.879]   - Field: ‘local’
[09:32:19.879]   - Field: ‘owner’
[09:32:19.879]   - Field: ‘envir’
[09:32:19.879]   - Field: ‘workers’
[09:32:19.879]   - Field: ‘packages’
[09:32:19.880]   - Field: ‘gc’
[09:32:19.880]   - Field: ‘job’
[09:32:19.880]   - Field: ‘conditions’
[09:32:19.880]   - Field: ‘expr’
[09:32:19.880]   - Field: ‘uuid’
[09:32:19.880]   - Field: ‘seed’
[09:32:19.880]   - Field: ‘version’
[09:32:19.881]   - Field: ‘result’
[09:32:19.881]   - Field: ‘asynchronous’
[09:32:19.881]   - Field: ‘calls’
[09:32:19.881]   - Field: ‘globals’
[09:32:19.881]   - Field: ‘stdout’
[09:32:19.881]   - Field: ‘earlySignal’
[09:32:19.881]   - Field: ‘lazy’
[09:32:19.882]   - Field: ‘state’
[09:32:19.882] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.882] - Launch lazy future ...
[09:32:19.882] Packages needed by the future expression (n = 0): <none>
[09:32:19.882] Packages needed by future strategies (n = 0): <none>
[09:32:19.883] {
[09:32:19.883]     {
[09:32:19.883]         {
[09:32:19.883]             ...future.startTime <- base::Sys.time()
[09:32:19.883]             {
[09:32:19.883]                 {
[09:32:19.883]                   {
[09:32:19.883]                     {
[09:32:19.883]                       base::local({
[09:32:19.883]                         has_future <- base::requireNamespace("future", 
[09:32:19.883]                           quietly = TRUE)
[09:32:19.883]                         if (has_future) {
[09:32:19.883]                           ns <- base::getNamespace("future")
[09:32:19.883]                           version <- ns[[".package"]][["version"]]
[09:32:19.883]                           if (is.null(version)) 
[09:32:19.883]                             version <- utils::packageVersion("future")
[09:32:19.883]                         }
[09:32:19.883]                         else {
[09:32:19.883]                           version <- NULL
[09:32:19.883]                         }
[09:32:19.883]                         if (!has_future || version < "1.8.0") {
[09:32:19.883]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.883]                             "", base::R.version$version.string), 
[09:32:19.883]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.883]                               "release", "version")], collapse = " "), 
[09:32:19.883]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.883]                             info)
[09:32:19.883]                           info <- base::paste(info, collapse = "; ")
[09:32:19.883]                           if (!has_future) {
[09:32:19.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.883]                               info)
[09:32:19.883]                           }
[09:32:19.883]                           else {
[09:32:19.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.883]                               info, version)
[09:32:19.883]                           }
[09:32:19.883]                           base::stop(msg)
[09:32:19.883]                         }
[09:32:19.883]                       })
[09:32:19.883]                     }
[09:32:19.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.883]                     base::options(mc.cores = 1L)
[09:32:19.883]                   }
[09:32:19.883]                   ...future.strategy.old <- future::plan("list")
[09:32:19.883]                   options(future.plan = NULL)
[09:32:19.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.883]                 }
[09:32:19.883]                 ...future.workdir <- getwd()
[09:32:19.883]             }
[09:32:19.883]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.883]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.883]         }
[09:32:19.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.883]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.883]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.883]             base::names(...future.oldOptions))
[09:32:19.883]     }
[09:32:19.883]     if (FALSE) {
[09:32:19.883]     }
[09:32:19.883]     else {
[09:32:19.883]         if (TRUE) {
[09:32:19.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.883]                 open = "w")
[09:32:19.883]         }
[09:32:19.883]         else {
[09:32:19.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.883]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.883]         }
[09:32:19.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.883]             base::sink(type = "output", split = FALSE)
[09:32:19.883]             base::close(...future.stdout)
[09:32:19.883]         }, add = TRUE)
[09:32:19.883]     }
[09:32:19.883]     ...future.frame <- base::sys.nframe()
[09:32:19.883]     ...future.conditions <- base::list()
[09:32:19.883]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.883]     if (FALSE) {
[09:32:19.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.883]     }
[09:32:19.883]     ...future.result <- base::tryCatch({
[09:32:19.883]         base::withCallingHandlers({
[09:32:19.883]             ...future.value <- base::withVisible(base::local({
[09:32:19.883]                 withCallingHandlers({
[09:32:19.883]                   1
[09:32:19.883]                 }, immediateCondition = function(cond) {
[09:32:19.883]                   save_rds <- function (object, pathname, ...) 
[09:32:19.883]                   {
[09:32:19.883]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.883]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.883]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.883]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.883]                         fi_tmp[["mtime"]])
[09:32:19.883]                     }
[09:32:19.883]                     tryCatch({
[09:32:19.883]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.883]                     }, error = function(ex) {
[09:32:19.883]                       msg <- conditionMessage(ex)
[09:32:19.883]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.883]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.883]                         fi_tmp[["mtime"]], msg)
[09:32:19.883]                       ex$message <- msg
[09:32:19.883]                       stop(ex)
[09:32:19.883]                     })
[09:32:19.883]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.883]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.883]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.883]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.883]                       fi <- file.info(pathname)
[09:32:19.883]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.883]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.883]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.883]                         fi[["size"]], fi[["mtime"]])
[09:32:19.883]                       stop(msg)
[09:32:19.883]                     }
[09:32:19.883]                     invisible(pathname)
[09:32:19.883]                   }
[09:32:19.883]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.883]                     rootPath = tempdir()) 
[09:32:19.883]                   {
[09:32:19.883]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.883]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.883]                       tmpdir = path, fileext = ".rds")
[09:32:19.883]                     save_rds(obj, file)
[09:32:19.883]                   }
[09:32:19.883]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.883]                   {
[09:32:19.883]                     inherits <- base::inherits
[09:32:19.883]                     invokeRestart <- base::invokeRestart
[09:32:19.883]                     is.null <- base::is.null
[09:32:19.883]                     muffled <- FALSE
[09:32:19.883]                     if (inherits(cond, "message")) {
[09:32:19.883]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.883]                       if (muffled) 
[09:32:19.883]                         invokeRestart("muffleMessage")
[09:32:19.883]                     }
[09:32:19.883]                     else if (inherits(cond, "warning")) {
[09:32:19.883]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.883]                       if (muffled) 
[09:32:19.883]                         invokeRestart("muffleWarning")
[09:32:19.883]                     }
[09:32:19.883]                     else if (inherits(cond, "condition")) {
[09:32:19.883]                       if (!is.null(pattern)) {
[09:32:19.883]                         computeRestarts <- base::computeRestarts
[09:32:19.883]                         grepl <- base::grepl
[09:32:19.883]                         restarts <- computeRestarts(cond)
[09:32:19.883]                         for (restart in restarts) {
[09:32:19.883]                           name <- restart$name
[09:32:19.883]                           if (is.null(name)) 
[09:32:19.883]                             next
[09:32:19.883]                           if (!grepl(pattern, name)) 
[09:32:19.883]                             next
[09:32:19.883]                           invokeRestart(restart)
[09:32:19.883]                           muffled <- TRUE
[09:32:19.883]                           break
[09:32:19.883]                         }
[09:32:19.883]                       }
[09:32:19.883]                     }
[09:32:19.883]                     invisible(muffled)
[09:32:19.883]                   }
[09:32:19.883]                   muffleCondition(cond)
[09:32:19.883]                 })
[09:32:19.883]             }))
[09:32:19.883]             future::FutureResult(value = ...future.value$value, 
[09:32:19.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.883]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.883]                     ...future.globalenv.names))
[09:32:19.883]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.883]         }, condition = base::local({
[09:32:19.883]             c <- base::c
[09:32:19.883]             inherits <- base::inherits
[09:32:19.883]             invokeRestart <- base::invokeRestart
[09:32:19.883]             length <- base::length
[09:32:19.883]             list <- base::list
[09:32:19.883]             seq.int <- base::seq.int
[09:32:19.883]             signalCondition <- base::signalCondition
[09:32:19.883]             sys.calls <- base::sys.calls
[09:32:19.883]             `[[` <- base::`[[`
[09:32:19.883]             `+` <- base::`+`
[09:32:19.883]             `<<-` <- base::`<<-`
[09:32:19.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.883]                   3L)]
[09:32:19.883]             }
[09:32:19.883]             function(cond) {
[09:32:19.883]                 is_error <- inherits(cond, "error")
[09:32:19.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.883]                   NULL)
[09:32:19.883]                 if (is_error) {
[09:32:19.883]                   sessionInformation <- function() {
[09:32:19.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.883]                       search = base::search(), system = base::Sys.info())
[09:32:19.883]                   }
[09:32:19.883]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.883]                     cond$call), session = sessionInformation(), 
[09:32:19.883]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.883]                   signalCondition(cond)
[09:32:19.883]                 }
[09:32:19.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.883]                 "immediateCondition"))) {
[09:32:19.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.883]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.883]                   if (TRUE && !signal) {
[09:32:19.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.883]                     {
[09:32:19.883]                       inherits <- base::inherits
[09:32:19.883]                       invokeRestart <- base::invokeRestart
[09:32:19.883]                       is.null <- base::is.null
[09:32:19.883]                       muffled <- FALSE
[09:32:19.883]                       if (inherits(cond, "message")) {
[09:32:19.883]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.883]                         if (muffled) 
[09:32:19.883]                           invokeRestart("muffleMessage")
[09:32:19.883]                       }
[09:32:19.883]                       else if (inherits(cond, "warning")) {
[09:32:19.883]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.883]                         if (muffled) 
[09:32:19.883]                           invokeRestart("muffleWarning")
[09:32:19.883]                       }
[09:32:19.883]                       else if (inherits(cond, "condition")) {
[09:32:19.883]                         if (!is.null(pattern)) {
[09:32:19.883]                           computeRestarts <- base::computeRestarts
[09:32:19.883]                           grepl <- base::grepl
[09:32:19.883]                           restarts <- computeRestarts(cond)
[09:32:19.883]                           for (restart in restarts) {
[09:32:19.883]                             name <- restart$name
[09:32:19.883]                             if (is.null(name)) 
[09:32:19.883]                               next
[09:32:19.883]                             if (!grepl(pattern, name)) 
[09:32:19.883]                               next
[09:32:19.883]                             invokeRestart(restart)
[09:32:19.883]                             muffled <- TRUE
[09:32:19.883]                             break
[09:32:19.883]                           }
[09:32:19.883]                         }
[09:32:19.883]                       }
[09:32:19.883]                       invisible(muffled)
[09:32:19.883]                     }
[09:32:19.883]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.883]                   }
[09:32:19.883]                 }
[09:32:19.883]                 else {
[09:32:19.883]                   if (TRUE) {
[09:32:19.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.883]                     {
[09:32:19.883]                       inherits <- base::inherits
[09:32:19.883]                       invokeRestart <- base::invokeRestart
[09:32:19.883]                       is.null <- base::is.null
[09:32:19.883]                       muffled <- FALSE
[09:32:19.883]                       if (inherits(cond, "message")) {
[09:32:19.883]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.883]                         if (muffled) 
[09:32:19.883]                           invokeRestart("muffleMessage")
[09:32:19.883]                       }
[09:32:19.883]                       else if (inherits(cond, "warning")) {
[09:32:19.883]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.883]                         if (muffled) 
[09:32:19.883]                           invokeRestart("muffleWarning")
[09:32:19.883]                       }
[09:32:19.883]                       else if (inherits(cond, "condition")) {
[09:32:19.883]                         if (!is.null(pattern)) {
[09:32:19.883]                           computeRestarts <- base::computeRestarts
[09:32:19.883]                           grepl <- base::grepl
[09:32:19.883]                           restarts <- computeRestarts(cond)
[09:32:19.883]                           for (restart in restarts) {
[09:32:19.883]                             name <- restart$name
[09:32:19.883]                             if (is.null(name)) 
[09:32:19.883]                               next
[09:32:19.883]                             if (!grepl(pattern, name)) 
[09:32:19.883]                               next
[09:32:19.883]                             invokeRestart(restart)
[09:32:19.883]                             muffled <- TRUE
[09:32:19.883]                             break
[09:32:19.883]                           }
[09:32:19.883]                         }
[09:32:19.883]                       }
[09:32:19.883]                       invisible(muffled)
[09:32:19.883]                     }
[09:32:19.883]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.883]                   }
[09:32:19.883]                 }
[09:32:19.883]             }
[09:32:19.883]         }))
[09:32:19.883]     }, error = function(ex) {
[09:32:19.883]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.883]                 ...future.rng), started = ...future.startTime, 
[09:32:19.883]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.883]             version = "1.8"), class = "FutureResult")
[09:32:19.883]     }, finally = {
[09:32:19.883]         if (!identical(...future.workdir, getwd())) 
[09:32:19.883]             setwd(...future.workdir)
[09:32:19.883]         {
[09:32:19.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.883]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.883]             }
[09:32:19.883]             base::options(...future.oldOptions)
[09:32:19.883]             if (.Platform$OS.type == "windows") {
[09:32:19.883]                 old_names <- names(...future.oldEnvVars)
[09:32:19.883]                 envs <- base::Sys.getenv()
[09:32:19.883]                 names <- names(envs)
[09:32:19.883]                 common <- intersect(names, old_names)
[09:32:19.883]                 added <- setdiff(names, old_names)
[09:32:19.883]                 removed <- setdiff(old_names, names)
[09:32:19.883]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.883]                   envs[common]]
[09:32:19.883]                 NAMES <- toupper(changed)
[09:32:19.883]                 args <- list()
[09:32:19.883]                 for (kk in seq_along(NAMES)) {
[09:32:19.883]                   name <- changed[[kk]]
[09:32:19.883]                   NAME <- NAMES[[kk]]
[09:32:19.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.883]                     next
[09:32:19.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.883]                 }
[09:32:19.883]                 NAMES <- toupper(added)
[09:32:19.883]                 for (kk in seq_along(NAMES)) {
[09:32:19.883]                   name <- added[[kk]]
[09:32:19.883]                   NAME <- NAMES[[kk]]
[09:32:19.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.883]                     next
[09:32:19.883]                   args[[name]] <- ""
[09:32:19.883]                 }
[09:32:19.883]                 NAMES <- toupper(removed)
[09:32:19.883]                 for (kk in seq_along(NAMES)) {
[09:32:19.883]                   name <- removed[[kk]]
[09:32:19.883]                   NAME <- NAMES[[kk]]
[09:32:19.883]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.883]                     next
[09:32:19.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.883]                 }
[09:32:19.883]                 if (length(args) > 0) 
[09:32:19.883]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.883]             }
[09:32:19.883]             else {
[09:32:19.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.883]             }
[09:32:19.883]             {
[09:32:19.883]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.883]                   0L) {
[09:32:19.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.883]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.883]                   base::options(opts)
[09:32:19.883]                 }
[09:32:19.883]                 {
[09:32:19.883]                   {
[09:32:19.883]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.883]                     NULL
[09:32:19.883]                   }
[09:32:19.883]                   options(future.plan = NULL)
[09:32:19.883]                   if (is.na(NA_character_)) 
[09:32:19.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.883]                     .init = FALSE)
[09:32:19.883]                 }
[09:32:19.883]             }
[09:32:19.883]         }
[09:32:19.883]     })
[09:32:19.883]     if (TRUE) {
[09:32:19.883]         base::sink(type = "output", split = FALSE)
[09:32:19.883]         if (TRUE) {
[09:32:19.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.883]         }
[09:32:19.883]         else {
[09:32:19.883]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.883]         }
[09:32:19.883]         base::close(...future.stdout)
[09:32:19.883]         ...future.stdout <- NULL
[09:32:19.883]     }
[09:32:19.883]     ...future.result$conditions <- ...future.conditions
[09:32:19.883]     ...future.result$finished <- base::Sys.time()
[09:32:19.883]     ...future.result
[09:32:19.883] }
[09:32:19.886] requestCore(): workers = 2
[09:32:19.887] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:19.897] result() for MulticoreFuture ...
[09:32:19.898] result() for MulticoreFuture ...
[09:32:19.898] result() for MulticoreFuture ... done
[09:32:19.899] result() for MulticoreFuture ... done
[09:32:19.899] result() for MulticoreFuture ...
[09:32:19.899] result() for MulticoreFuture ... done
[09:32:19.902] MulticoreFuture started
[09:32:19.902] - Launch lazy future ... done
[09:32:19.902] run() for ‘MulticoreFuture’ ... done
[09:32:19.902] plan(): Setting new future strategy stack:
[09:32:19.903] List of future strategies:
[09:32:19.903] 1. sequential:
[09:32:19.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.903]    - tweaked: FALSE
[09:32:19.903]    - call: NULL
[09:32:19.904] plan(): nbrOfWorkers() = 1
[09:32:19.906] plan(): Setting new future strategy stack:
[09:32:19.906] List of future strategies:
[09:32:19.906] 1. multicore:
[09:32:19.906]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.906]    - tweaked: FALSE
[09:32:19.906]    - call: plan(strategy)
[09:32:19.912] plan(): nbrOfWorkers() = 2
[09:32:19.912] Future #1
[09:32:19.913]  length: 2 (resolved future 1)
[09:32:19.913] run() for ‘Future’ ...
[09:32:19.913] - state: ‘created’
[09:32:19.913] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.918]   - Field: ‘label’
[09:32:19.918]   - Field: ‘local’
[09:32:19.918]   - Field: ‘owner’
[09:32:19.919]   - Field: ‘envir’
[09:32:19.919]   - Field: ‘workers’
[09:32:19.919]   - Field: ‘packages’
[09:32:19.919]   - Field: ‘gc’
[09:32:19.919]   - Field: ‘job’
[09:32:19.919]   - Field: ‘conditions’
[09:32:19.919]   - Field: ‘expr’
[09:32:19.920]   - Field: ‘uuid’
[09:32:19.920]   - Field: ‘seed’
[09:32:19.920]   - Field: ‘version’
[09:32:19.920]   - Field: ‘result’
[09:32:19.920]   - Field: ‘asynchronous’
[09:32:19.920]   - Field: ‘calls’
[09:32:19.921]   - Field: ‘globals’
[09:32:19.921]   - Field: ‘stdout’
[09:32:19.921]   - Field: ‘earlySignal’
[09:32:19.921]   - Field: ‘lazy’
[09:32:19.921]   - Field: ‘state’
[09:32:19.921] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.921] - Launch lazy future ...
[09:32:19.922] Packages needed by the future expression (n = 0): <none>
[09:32:19.922] Packages needed by future strategies (n = 0): <none>
[09:32:19.923] {
[09:32:19.923]     {
[09:32:19.923]         {
[09:32:19.923]             ...future.startTime <- base::Sys.time()
[09:32:19.923]             {
[09:32:19.923]                 {
[09:32:19.923]                   {
[09:32:19.923]                     {
[09:32:19.923]                       base::local({
[09:32:19.923]                         has_future <- base::requireNamespace("future", 
[09:32:19.923]                           quietly = TRUE)
[09:32:19.923]                         if (has_future) {
[09:32:19.923]                           ns <- base::getNamespace("future")
[09:32:19.923]                           version <- ns[[".package"]][["version"]]
[09:32:19.923]                           if (is.null(version)) 
[09:32:19.923]                             version <- utils::packageVersion("future")
[09:32:19.923]                         }
[09:32:19.923]                         else {
[09:32:19.923]                           version <- NULL
[09:32:19.923]                         }
[09:32:19.923]                         if (!has_future || version < "1.8.0") {
[09:32:19.923]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.923]                             "", base::R.version$version.string), 
[09:32:19.923]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.923]                               "release", "version")], collapse = " "), 
[09:32:19.923]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.923]                             info)
[09:32:19.923]                           info <- base::paste(info, collapse = "; ")
[09:32:19.923]                           if (!has_future) {
[09:32:19.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.923]                               info)
[09:32:19.923]                           }
[09:32:19.923]                           else {
[09:32:19.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.923]                               info, version)
[09:32:19.923]                           }
[09:32:19.923]                           base::stop(msg)
[09:32:19.923]                         }
[09:32:19.923]                       })
[09:32:19.923]                     }
[09:32:19.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.923]                     base::options(mc.cores = 1L)
[09:32:19.923]                   }
[09:32:19.923]                   ...future.strategy.old <- future::plan("list")
[09:32:19.923]                   options(future.plan = NULL)
[09:32:19.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.923]                 }
[09:32:19.923]                 ...future.workdir <- getwd()
[09:32:19.923]             }
[09:32:19.923]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.923]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.923]         }
[09:32:19.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.923]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.923]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.923]             base::names(...future.oldOptions))
[09:32:19.923]     }
[09:32:19.923]     if (FALSE) {
[09:32:19.923]     }
[09:32:19.923]     else {
[09:32:19.923]         if (TRUE) {
[09:32:19.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.923]                 open = "w")
[09:32:19.923]         }
[09:32:19.923]         else {
[09:32:19.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.923]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.923]         }
[09:32:19.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.923]             base::sink(type = "output", split = FALSE)
[09:32:19.923]             base::close(...future.stdout)
[09:32:19.923]         }, add = TRUE)
[09:32:19.923]     }
[09:32:19.923]     ...future.frame <- base::sys.nframe()
[09:32:19.923]     ...future.conditions <- base::list()
[09:32:19.923]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.923]     if (FALSE) {
[09:32:19.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.923]     }
[09:32:19.923]     ...future.result <- base::tryCatch({
[09:32:19.923]         base::withCallingHandlers({
[09:32:19.923]             ...future.value <- base::withVisible(base::local({
[09:32:19.923]                 withCallingHandlers({
[09:32:19.923]                   2
[09:32:19.923]                 }, immediateCondition = function(cond) {
[09:32:19.923]                   save_rds <- function (object, pathname, ...) 
[09:32:19.923]                   {
[09:32:19.923]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.923]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.923]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.923]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.923]                         fi_tmp[["mtime"]])
[09:32:19.923]                     }
[09:32:19.923]                     tryCatch({
[09:32:19.923]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.923]                     }, error = function(ex) {
[09:32:19.923]                       msg <- conditionMessage(ex)
[09:32:19.923]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.923]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.923]                         fi_tmp[["mtime"]], msg)
[09:32:19.923]                       ex$message <- msg
[09:32:19.923]                       stop(ex)
[09:32:19.923]                     })
[09:32:19.923]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.923]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.923]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.923]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.923]                       fi <- file.info(pathname)
[09:32:19.923]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.923]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.923]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.923]                         fi[["size"]], fi[["mtime"]])
[09:32:19.923]                       stop(msg)
[09:32:19.923]                     }
[09:32:19.923]                     invisible(pathname)
[09:32:19.923]                   }
[09:32:19.923]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.923]                     rootPath = tempdir()) 
[09:32:19.923]                   {
[09:32:19.923]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.923]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.923]                       tmpdir = path, fileext = ".rds")
[09:32:19.923]                     save_rds(obj, file)
[09:32:19.923]                   }
[09:32:19.923]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.923]                   {
[09:32:19.923]                     inherits <- base::inherits
[09:32:19.923]                     invokeRestart <- base::invokeRestart
[09:32:19.923]                     is.null <- base::is.null
[09:32:19.923]                     muffled <- FALSE
[09:32:19.923]                     if (inherits(cond, "message")) {
[09:32:19.923]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.923]                       if (muffled) 
[09:32:19.923]                         invokeRestart("muffleMessage")
[09:32:19.923]                     }
[09:32:19.923]                     else if (inherits(cond, "warning")) {
[09:32:19.923]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.923]                       if (muffled) 
[09:32:19.923]                         invokeRestart("muffleWarning")
[09:32:19.923]                     }
[09:32:19.923]                     else if (inherits(cond, "condition")) {
[09:32:19.923]                       if (!is.null(pattern)) {
[09:32:19.923]                         computeRestarts <- base::computeRestarts
[09:32:19.923]                         grepl <- base::grepl
[09:32:19.923]                         restarts <- computeRestarts(cond)
[09:32:19.923]                         for (restart in restarts) {
[09:32:19.923]                           name <- restart$name
[09:32:19.923]                           if (is.null(name)) 
[09:32:19.923]                             next
[09:32:19.923]                           if (!grepl(pattern, name)) 
[09:32:19.923]                             next
[09:32:19.923]                           invokeRestart(restart)
[09:32:19.923]                           muffled <- TRUE
[09:32:19.923]                           break
[09:32:19.923]                         }
[09:32:19.923]                       }
[09:32:19.923]                     }
[09:32:19.923]                     invisible(muffled)
[09:32:19.923]                   }
[09:32:19.923]                   muffleCondition(cond)
[09:32:19.923]                 })
[09:32:19.923]             }))
[09:32:19.923]             future::FutureResult(value = ...future.value$value, 
[09:32:19.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.923]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.923]                     ...future.globalenv.names))
[09:32:19.923]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.923]         }, condition = base::local({
[09:32:19.923]             c <- base::c
[09:32:19.923]             inherits <- base::inherits
[09:32:19.923]             invokeRestart <- base::invokeRestart
[09:32:19.923]             length <- base::length
[09:32:19.923]             list <- base::list
[09:32:19.923]             seq.int <- base::seq.int
[09:32:19.923]             signalCondition <- base::signalCondition
[09:32:19.923]             sys.calls <- base::sys.calls
[09:32:19.923]             `[[` <- base::`[[`
[09:32:19.923]             `+` <- base::`+`
[09:32:19.923]             `<<-` <- base::`<<-`
[09:32:19.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.923]                   3L)]
[09:32:19.923]             }
[09:32:19.923]             function(cond) {
[09:32:19.923]                 is_error <- inherits(cond, "error")
[09:32:19.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.923]                   NULL)
[09:32:19.923]                 if (is_error) {
[09:32:19.923]                   sessionInformation <- function() {
[09:32:19.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.923]                       search = base::search(), system = base::Sys.info())
[09:32:19.923]                   }
[09:32:19.923]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.923]                     cond$call), session = sessionInformation(), 
[09:32:19.923]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.923]                   signalCondition(cond)
[09:32:19.923]                 }
[09:32:19.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.923]                 "immediateCondition"))) {
[09:32:19.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.923]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.923]                   if (TRUE && !signal) {
[09:32:19.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.923]                     {
[09:32:19.923]                       inherits <- base::inherits
[09:32:19.923]                       invokeRestart <- base::invokeRestart
[09:32:19.923]                       is.null <- base::is.null
[09:32:19.923]                       muffled <- FALSE
[09:32:19.923]                       if (inherits(cond, "message")) {
[09:32:19.923]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.923]                         if (muffled) 
[09:32:19.923]                           invokeRestart("muffleMessage")
[09:32:19.923]                       }
[09:32:19.923]                       else if (inherits(cond, "warning")) {
[09:32:19.923]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.923]                         if (muffled) 
[09:32:19.923]                           invokeRestart("muffleWarning")
[09:32:19.923]                       }
[09:32:19.923]                       else if (inherits(cond, "condition")) {
[09:32:19.923]                         if (!is.null(pattern)) {
[09:32:19.923]                           computeRestarts <- base::computeRestarts
[09:32:19.923]                           grepl <- base::grepl
[09:32:19.923]                           restarts <- computeRestarts(cond)
[09:32:19.923]                           for (restart in restarts) {
[09:32:19.923]                             name <- restart$name
[09:32:19.923]                             if (is.null(name)) 
[09:32:19.923]                               next
[09:32:19.923]                             if (!grepl(pattern, name)) 
[09:32:19.923]                               next
[09:32:19.923]                             invokeRestart(restart)
[09:32:19.923]                             muffled <- TRUE
[09:32:19.923]                             break
[09:32:19.923]                           }
[09:32:19.923]                         }
[09:32:19.923]                       }
[09:32:19.923]                       invisible(muffled)
[09:32:19.923]                     }
[09:32:19.923]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.923]                   }
[09:32:19.923]                 }
[09:32:19.923]                 else {
[09:32:19.923]                   if (TRUE) {
[09:32:19.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.923]                     {
[09:32:19.923]                       inherits <- base::inherits
[09:32:19.923]                       invokeRestart <- base::invokeRestart
[09:32:19.923]                       is.null <- base::is.null
[09:32:19.923]                       muffled <- FALSE
[09:32:19.923]                       if (inherits(cond, "message")) {
[09:32:19.923]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.923]                         if (muffled) 
[09:32:19.923]                           invokeRestart("muffleMessage")
[09:32:19.923]                       }
[09:32:19.923]                       else if (inherits(cond, "warning")) {
[09:32:19.923]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.923]                         if (muffled) 
[09:32:19.923]                           invokeRestart("muffleWarning")
[09:32:19.923]                       }
[09:32:19.923]                       else if (inherits(cond, "condition")) {
[09:32:19.923]                         if (!is.null(pattern)) {
[09:32:19.923]                           computeRestarts <- base::computeRestarts
[09:32:19.923]                           grepl <- base::grepl
[09:32:19.923]                           restarts <- computeRestarts(cond)
[09:32:19.923]                           for (restart in restarts) {
[09:32:19.923]                             name <- restart$name
[09:32:19.923]                             if (is.null(name)) 
[09:32:19.923]                               next
[09:32:19.923]                             if (!grepl(pattern, name)) 
[09:32:19.923]                               next
[09:32:19.923]                             invokeRestart(restart)
[09:32:19.923]                             muffled <- TRUE
[09:32:19.923]                             break
[09:32:19.923]                           }
[09:32:19.923]                         }
[09:32:19.923]                       }
[09:32:19.923]                       invisible(muffled)
[09:32:19.923]                     }
[09:32:19.923]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.923]                   }
[09:32:19.923]                 }
[09:32:19.923]             }
[09:32:19.923]         }))
[09:32:19.923]     }, error = function(ex) {
[09:32:19.923]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.923]                 ...future.rng), started = ...future.startTime, 
[09:32:19.923]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.923]             version = "1.8"), class = "FutureResult")
[09:32:19.923]     }, finally = {
[09:32:19.923]         if (!identical(...future.workdir, getwd())) 
[09:32:19.923]             setwd(...future.workdir)
[09:32:19.923]         {
[09:32:19.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.923]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.923]             }
[09:32:19.923]             base::options(...future.oldOptions)
[09:32:19.923]             if (.Platform$OS.type == "windows") {
[09:32:19.923]                 old_names <- names(...future.oldEnvVars)
[09:32:19.923]                 envs <- base::Sys.getenv()
[09:32:19.923]                 names <- names(envs)
[09:32:19.923]                 common <- intersect(names, old_names)
[09:32:19.923]                 added <- setdiff(names, old_names)
[09:32:19.923]                 removed <- setdiff(old_names, names)
[09:32:19.923]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.923]                   envs[common]]
[09:32:19.923]                 NAMES <- toupper(changed)
[09:32:19.923]                 args <- list()
[09:32:19.923]                 for (kk in seq_along(NAMES)) {
[09:32:19.923]                   name <- changed[[kk]]
[09:32:19.923]                   NAME <- NAMES[[kk]]
[09:32:19.923]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.923]                     next
[09:32:19.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.923]                 }
[09:32:19.923]                 NAMES <- toupper(added)
[09:32:19.923]                 for (kk in seq_along(NAMES)) {
[09:32:19.923]                   name <- added[[kk]]
[09:32:19.923]                   NAME <- NAMES[[kk]]
[09:32:19.923]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.923]                     next
[09:32:19.923]                   args[[name]] <- ""
[09:32:19.923]                 }
[09:32:19.923]                 NAMES <- toupper(removed)
[09:32:19.923]                 for (kk in seq_along(NAMES)) {
[09:32:19.923]                   name <- removed[[kk]]
[09:32:19.923]                   NAME <- NAMES[[kk]]
[09:32:19.923]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.923]                     next
[09:32:19.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.923]                 }
[09:32:19.923]                 if (length(args) > 0) 
[09:32:19.923]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.923]             }
[09:32:19.923]             else {
[09:32:19.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.923]             }
[09:32:19.923]             {
[09:32:19.923]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.923]                   0L) {
[09:32:19.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.923]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.923]                   base::options(opts)
[09:32:19.923]                 }
[09:32:19.923]                 {
[09:32:19.923]                   {
[09:32:19.923]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.923]                     NULL
[09:32:19.923]                   }
[09:32:19.923]                   options(future.plan = NULL)
[09:32:19.923]                   if (is.na(NA_character_)) 
[09:32:19.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.923]                     .init = FALSE)
[09:32:19.923]                 }
[09:32:19.923]             }
[09:32:19.923]         }
[09:32:19.923]     })
[09:32:19.923]     if (TRUE) {
[09:32:19.923]         base::sink(type = "output", split = FALSE)
[09:32:19.923]         if (TRUE) {
[09:32:19.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.923]         }
[09:32:19.923]         else {
[09:32:19.923]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.923]         }
[09:32:19.923]         base::close(...future.stdout)
[09:32:19.923]         ...future.stdout <- NULL
[09:32:19.923]     }
[09:32:19.923]     ...future.result$conditions <- ...future.conditions
[09:32:19.923]     ...future.result$finished <- base::Sys.time()
[09:32:19.923]     ...future.result
[09:32:19.923] }
[09:32:19.926] requestCore(): workers = 2
[09:32:19.926] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:19.937] result() for MulticoreFuture ...
[09:32:19.938] result() for MulticoreFuture ...
[09:32:19.938] result() for MulticoreFuture ... done
[09:32:19.938] result() for MulticoreFuture ... done
[09:32:19.938] result() for MulticoreFuture ...
[09:32:19.939] result() for MulticoreFuture ... done
[09:32:19.941] MulticoreFuture started
[09:32:19.942] - Launch lazy future ... done
[09:32:19.942] run() for ‘MulticoreFuture’ ... done
[09:32:19.942] plan(): Setting new future strategy stack:
[09:32:19.942] List of future strategies:
[09:32:19.942] 1. sequential:
[09:32:19.942]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.942]    - tweaked: FALSE
[09:32:19.942]    - call: NULL
[09:32:19.943] plan(): nbrOfWorkers() = 1
[09:32:19.945] plan(): Setting new future strategy stack:
[09:32:19.946] List of future strategies:
[09:32:19.946] 1. multicore:
[09:32:19.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.946]    - tweaked: FALSE
[09:32:19.946]    - call: plan(strategy)
[09:32:19.950] plan(): nbrOfWorkers() = 2
[09:32:19.951] Future #2
[09:32:19.951]  length: 1 (resolved future 2)
[09:32:19.951]  length: 0 (resolved future 3)
[09:32:19.952] resolve() on list ... DONE
[09:32:19.952] getGlobalsAndPackages() ...
[09:32:19.952] Searching for globals...
[09:32:19.953] 
[09:32:19.953] Searching for globals ... DONE
[09:32:19.953] - globals: [0] <none>
[09:32:19.954] getGlobalsAndPackages() ... DONE
[09:32:19.954] run() for ‘Future’ ...
[09:32:19.954] - state: ‘created’
[09:32:19.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.959] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.959]   - Field: ‘label’
[09:32:19.959]   - Field: ‘local’
[09:32:19.959]   - Field: ‘owner’
[09:32:19.960]   - Field: ‘envir’
[09:32:19.960]   - Field: ‘workers’
[09:32:19.960]   - Field: ‘packages’
[09:32:19.960]   - Field: ‘gc’
[09:32:19.960]   - Field: ‘job’
[09:32:19.960]   - Field: ‘conditions’
[09:32:19.961]   - Field: ‘expr’
[09:32:19.961]   - Field: ‘uuid’
[09:32:19.961]   - Field: ‘seed’
[09:32:19.961]   - Field: ‘version’
[09:32:19.961]   - Field: ‘result’
[09:32:19.961]   - Field: ‘asynchronous’
[09:32:19.961]   - Field: ‘calls’
[09:32:19.962]   - Field: ‘globals’
[09:32:19.962]   - Field: ‘stdout’
[09:32:19.962]   - Field: ‘earlySignal’
[09:32:19.962]   - Field: ‘lazy’
[09:32:19.962]   - Field: ‘state’
[09:32:19.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:19.962] - Launch lazy future ...
[09:32:19.963] Packages needed by the future expression (n = 0): <none>
[09:32:19.963] Packages needed by future strategies (n = 0): <none>
[09:32:19.968] {
[09:32:19.968]     {
[09:32:19.968]         {
[09:32:19.968]             ...future.startTime <- base::Sys.time()
[09:32:19.968]             {
[09:32:19.968]                 {
[09:32:19.968]                   {
[09:32:19.968]                     {
[09:32:19.968]                       base::local({
[09:32:19.968]                         has_future <- base::requireNamespace("future", 
[09:32:19.968]                           quietly = TRUE)
[09:32:19.968]                         if (has_future) {
[09:32:19.968]                           ns <- base::getNamespace("future")
[09:32:19.968]                           version <- ns[[".package"]][["version"]]
[09:32:19.968]                           if (is.null(version)) 
[09:32:19.968]                             version <- utils::packageVersion("future")
[09:32:19.968]                         }
[09:32:19.968]                         else {
[09:32:19.968]                           version <- NULL
[09:32:19.968]                         }
[09:32:19.968]                         if (!has_future || version < "1.8.0") {
[09:32:19.968]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:19.968]                             "", base::R.version$version.string), 
[09:32:19.968]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:19.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:19.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:19.968]                               "release", "version")], collapse = " "), 
[09:32:19.968]                             hostname = base::Sys.info()[["nodename"]])
[09:32:19.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:19.968]                             info)
[09:32:19.968]                           info <- base::paste(info, collapse = "; ")
[09:32:19.968]                           if (!has_future) {
[09:32:19.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:19.968]                               info)
[09:32:19.968]                           }
[09:32:19.968]                           else {
[09:32:19.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:19.968]                               info, version)
[09:32:19.968]                           }
[09:32:19.968]                           base::stop(msg)
[09:32:19.968]                         }
[09:32:19.968]                       })
[09:32:19.968]                     }
[09:32:19.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:19.968]                     base::options(mc.cores = 1L)
[09:32:19.968]                   }
[09:32:19.968]                   ...future.strategy.old <- future::plan("list")
[09:32:19.968]                   options(future.plan = NULL)
[09:32:19.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:19.968]                 }
[09:32:19.968]                 ...future.workdir <- getwd()
[09:32:19.968]             }
[09:32:19.968]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:19.968]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:19.968]         }
[09:32:19.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:19.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:19.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:19.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:19.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:19.968]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:19.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:19.968]             base::names(...future.oldOptions))
[09:32:19.968]     }
[09:32:19.968]     if (FALSE) {
[09:32:19.968]     }
[09:32:19.968]     else {
[09:32:19.968]         if (TRUE) {
[09:32:19.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:19.968]                 open = "w")
[09:32:19.968]         }
[09:32:19.968]         else {
[09:32:19.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:19.968]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:19.968]         }
[09:32:19.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:19.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:19.968]             base::sink(type = "output", split = FALSE)
[09:32:19.968]             base::close(...future.stdout)
[09:32:19.968]         }, add = TRUE)
[09:32:19.968]     }
[09:32:19.968]     ...future.frame <- base::sys.nframe()
[09:32:19.968]     ...future.conditions <- base::list()
[09:32:19.968]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:19.968]     if (FALSE) {
[09:32:19.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:19.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:19.968]     }
[09:32:19.968]     ...future.result <- base::tryCatch({
[09:32:19.968]         base::withCallingHandlers({
[09:32:19.968]             ...future.value <- base::withVisible(base::local({
[09:32:19.968]                 withCallingHandlers({
[09:32:19.968]                   1
[09:32:19.968]                 }, immediateCondition = function(cond) {
[09:32:19.968]                   save_rds <- function (object, pathname, ...) 
[09:32:19.968]                   {
[09:32:19.968]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:19.968]                     if (file_test("-f", pathname_tmp)) {
[09:32:19.968]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.968]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:19.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.968]                         fi_tmp[["mtime"]])
[09:32:19.968]                     }
[09:32:19.968]                     tryCatch({
[09:32:19.968]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:19.968]                     }, error = function(ex) {
[09:32:19.968]                       msg <- conditionMessage(ex)
[09:32:19.968]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.968]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:19.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.968]                         fi_tmp[["mtime"]], msg)
[09:32:19.968]                       ex$message <- msg
[09:32:19.968]                       stop(ex)
[09:32:19.968]                     })
[09:32:19.968]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:19.968]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:19.968]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:19.968]                       fi_tmp <- file.info(pathname_tmp)
[09:32:19.968]                       fi <- file.info(pathname)
[09:32:19.968]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:19.968]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:19.968]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:19.968]                         fi[["size"]], fi[["mtime"]])
[09:32:19.968]                       stop(msg)
[09:32:19.968]                     }
[09:32:19.968]                     invisible(pathname)
[09:32:19.968]                   }
[09:32:19.968]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:19.968]                     rootPath = tempdir()) 
[09:32:19.968]                   {
[09:32:19.968]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:19.968]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:19.968]                       tmpdir = path, fileext = ".rds")
[09:32:19.968]                     save_rds(obj, file)
[09:32:19.968]                   }
[09:32:19.968]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:19.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.968]                   {
[09:32:19.968]                     inherits <- base::inherits
[09:32:19.968]                     invokeRestart <- base::invokeRestart
[09:32:19.968]                     is.null <- base::is.null
[09:32:19.968]                     muffled <- FALSE
[09:32:19.968]                     if (inherits(cond, "message")) {
[09:32:19.968]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:19.968]                       if (muffled) 
[09:32:19.968]                         invokeRestart("muffleMessage")
[09:32:19.968]                     }
[09:32:19.968]                     else if (inherits(cond, "warning")) {
[09:32:19.968]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:19.968]                       if (muffled) 
[09:32:19.968]                         invokeRestart("muffleWarning")
[09:32:19.968]                     }
[09:32:19.968]                     else if (inherits(cond, "condition")) {
[09:32:19.968]                       if (!is.null(pattern)) {
[09:32:19.968]                         computeRestarts <- base::computeRestarts
[09:32:19.968]                         grepl <- base::grepl
[09:32:19.968]                         restarts <- computeRestarts(cond)
[09:32:19.968]                         for (restart in restarts) {
[09:32:19.968]                           name <- restart$name
[09:32:19.968]                           if (is.null(name)) 
[09:32:19.968]                             next
[09:32:19.968]                           if (!grepl(pattern, name)) 
[09:32:19.968]                             next
[09:32:19.968]                           invokeRestart(restart)
[09:32:19.968]                           muffled <- TRUE
[09:32:19.968]                           break
[09:32:19.968]                         }
[09:32:19.968]                       }
[09:32:19.968]                     }
[09:32:19.968]                     invisible(muffled)
[09:32:19.968]                   }
[09:32:19.968]                   muffleCondition(cond)
[09:32:19.968]                 })
[09:32:19.968]             }))
[09:32:19.968]             future::FutureResult(value = ...future.value$value, 
[09:32:19.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.968]                   ...future.rng), globalenv = if (FALSE) 
[09:32:19.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:19.968]                     ...future.globalenv.names))
[09:32:19.968]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:19.968]         }, condition = base::local({
[09:32:19.968]             c <- base::c
[09:32:19.968]             inherits <- base::inherits
[09:32:19.968]             invokeRestart <- base::invokeRestart
[09:32:19.968]             length <- base::length
[09:32:19.968]             list <- base::list
[09:32:19.968]             seq.int <- base::seq.int
[09:32:19.968]             signalCondition <- base::signalCondition
[09:32:19.968]             sys.calls <- base::sys.calls
[09:32:19.968]             `[[` <- base::`[[`
[09:32:19.968]             `+` <- base::`+`
[09:32:19.968]             `<<-` <- base::`<<-`
[09:32:19.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:19.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:19.968]                   3L)]
[09:32:19.968]             }
[09:32:19.968]             function(cond) {
[09:32:19.968]                 is_error <- inherits(cond, "error")
[09:32:19.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:19.968]                   NULL)
[09:32:19.968]                 if (is_error) {
[09:32:19.968]                   sessionInformation <- function() {
[09:32:19.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:19.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:19.968]                       search = base::search(), system = base::Sys.info())
[09:32:19.968]                   }
[09:32:19.968]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:19.968]                     cond$call), session = sessionInformation(), 
[09:32:19.968]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:19.968]                   signalCondition(cond)
[09:32:19.968]                 }
[09:32:19.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:19.968]                 "immediateCondition"))) {
[09:32:19.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:19.968]                   ...future.conditions[[length(...future.conditions) + 
[09:32:19.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:19.968]                   if (TRUE && !signal) {
[09:32:19.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.968]                     {
[09:32:19.968]                       inherits <- base::inherits
[09:32:19.968]                       invokeRestart <- base::invokeRestart
[09:32:19.968]                       is.null <- base::is.null
[09:32:19.968]                       muffled <- FALSE
[09:32:19.968]                       if (inherits(cond, "message")) {
[09:32:19.968]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.968]                         if (muffled) 
[09:32:19.968]                           invokeRestart("muffleMessage")
[09:32:19.968]                       }
[09:32:19.968]                       else if (inherits(cond, "warning")) {
[09:32:19.968]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.968]                         if (muffled) 
[09:32:19.968]                           invokeRestart("muffleWarning")
[09:32:19.968]                       }
[09:32:19.968]                       else if (inherits(cond, "condition")) {
[09:32:19.968]                         if (!is.null(pattern)) {
[09:32:19.968]                           computeRestarts <- base::computeRestarts
[09:32:19.968]                           grepl <- base::grepl
[09:32:19.968]                           restarts <- computeRestarts(cond)
[09:32:19.968]                           for (restart in restarts) {
[09:32:19.968]                             name <- restart$name
[09:32:19.968]                             if (is.null(name)) 
[09:32:19.968]                               next
[09:32:19.968]                             if (!grepl(pattern, name)) 
[09:32:19.968]                               next
[09:32:19.968]                             invokeRestart(restart)
[09:32:19.968]                             muffled <- TRUE
[09:32:19.968]                             break
[09:32:19.968]                           }
[09:32:19.968]                         }
[09:32:19.968]                       }
[09:32:19.968]                       invisible(muffled)
[09:32:19.968]                     }
[09:32:19.968]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.968]                   }
[09:32:19.968]                 }
[09:32:19.968]                 else {
[09:32:19.968]                   if (TRUE) {
[09:32:19.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:19.968]                     {
[09:32:19.968]                       inherits <- base::inherits
[09:32:19.968]                       invokeRestart <- base::invokeRestart
[09:32:19.968]                       is.null <- base::is.null
[09:32:19.968]                       muffled <- FALSE
[09:32:19.968]                       if (inherits(cond, "message")) {
[09:32:19.968]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:19.968]                         if (muffled) 
[09:32:19.968]                           invokeRestart("muffleMessage")
[09:32:19.968]                       }
[09:32:19.968]                       else if (inherits(cond, "warning")) {
[09:32:19.968]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:19.968]                         if (muffled) 
[09:32:19.968]                           invokeRestart("muffleWarning")
[09:32:19.968]                       }
[09:32:19.968]                       else if (inherits(cond, "condition")) {
[09:32:19.968]                         if (!is.null(pattern)) {
[09:32:19.968]                           computeRestarts <- base::computeRestarts
[09:32:19.968]                           grepl <- base::grepl
[09:32:19.968]                           restarts <- computeRestarts(cond)
[09:32:19.968]                           for (restart in restarts) {
[09:32:19.968]                             name <- restart$name
[09:32:19.968]                             if (is.null(name)) 
[09:32:19.968]                               next
[09:32:19.968]                             if (!grepl(pattern, name)) 
[09:32:19.968]                               next
[09:32:19.968]                             invokeRestart(restart)
[09:32:19.968]                             muffled <- TRUE
[09:32:19.968]                             break
[09:32:19.968]                           }
[09:32:19.968]                         }
[09:32:19.968]                       }
[09:32:19.968]                       invisible(muffled)
[09:32:19.968]                     }
[09:32:19.968]                     muffleCondition(cond, pattern = "^muffle")
[09:32:19.968]                   }
[09:32:19.968]                 }
[09:32:19.968]             }
[09:32:19.968]         }))
[09:32:19.968]     }, error = function(ex) {
[09:32:19.968]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:19.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:19.968]                 ...future.rng), started = ...future.startTime, 
[09:32:19.968]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:19.968]             version = "1.8"), class = "FutureResult")
[09:32:19.968]     }, finally = {
[09:32:19.968]         if (!identical(...future.workdir, getwd())) 
[09:32:19.968]             setwd(...future.workdir)
[09:32:19.968]         {
[09:32:19.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:19.968]                 ...future.oldOptions$nwarnings <- NULL
[09:32:19.968]             }
[09:32:19.968]             base::options(...future.oldOptions)
[09:32:19.968]             if (.Platform$OS.type == "windows") {
[09:32:19.968]                 old_names <- names(...future.oldEnvVars)
[09:32:19.968]                 envs <- base::Sys.getenv()
[09:32:19.968]                 names <- names(envs)
[09:32:19.968]                 common <- intersect(names, old_names)
[09:32:19.968]                 added <- setdiff(names, old_names)
[09:32:19.968]                 removed <- setdiff(old_names, names)
[09:32:19.968]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:19.968]                   envs[common]]
[09:32:19.968]                 NAMES <- toupper(changed)
[09:32:19.968]                 args <- list()
[09:32:19.968]                 for (kk in seq_along(NAMES)) {
[09:32:19.968]                   name <- changed[[kk]]
[09:32:19.968]                   NAME <- NAMES[[kk]]
[09:32:19.968]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.968]                     next
[09:32:19.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.968]                 }
[09:32:19.968]                 NAMES <- toupper(added)
[09:32:19.968]                 for (kk in seq_along(NAMES)) {
[09:32:19.968]                   name <- added[[kk]]
[09:32:19.968]                   NAME <- NAMES[[kk]]
[09:32:19.968]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.968]                     next
[09:32:19.968]                   args[[name]] <- ""
[09:32:19.968]                 }
[09:32:19.968]                 NAMES <- toupper(removed)
[09:32:19.968]                 for (kk in seq_along(NAMES)) {
[09:32:19.968]                   name <- removed[[kk]]
[09:32:19.968]                   NAME <- NAMES[[kk]]
[09:32:19.968]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:19.968]                     next
[09:32:19.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:19.968]                 }
[09:32:19.968]                 if (length(args) > 0) 
[09:32:19.968]                   base::do.call(base::Sys.setenv, args = args)
[09:32:19.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:19.968]             }
[09:32:19.968]             else {
[09:32:19.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:19.968]             }
[09:32:19.968]             {
[09:32:19.968]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:19.968]                   0L) {
[09:32:19.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:19.968]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:19.968]                   base::options(opts)
[09:32:19.968]                 }
[09:32:19.968]                 {
[09:32:19.968]                   {
[09:32:19.968]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:19.968]                     NULL
[09:32:19.968]                   }
[09:32:19.968]                   options(future.plan = NULL)
[09:32:19.968]                   if (is.na(NA_character_)) 
[09:32:19.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:19.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:19.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:19.968]                     .init = FALSE)
[09:32:19.968]                 }
[09:32:19.968]             }
[09:32:19.968]         }
[09:32:19.968]     })
[09:32:19.968]     if (TRUE) {
[09:32:19.968]         base::sink(type = "output", split = FALSE)
[09:32:19.968]         if (TRUE) {
[09:32:19.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:19.968]         }
[09:32:19.968]         else {
[09:32:19.968]             ...future.result["stdout"] <- base::list(NULL)
[09:32:19.968]         }
[09:32:19.968]         base::close(...future.stdout)
[09:32:19.968]         ...future.stdout <- NULL
[09:32:19.968]     }
[09:32:19.968]     ...future.result$conditions <- ...future.conditions
[09:32:19.968]     ...future.result$finished <- base::Sys.time()
[09:32:19.968]     ...future.result
[09:32:19.968] }
[09:32:19.971] requestCore(): workers = 2
[09:32:19.971] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:19.982] result() for MulticoreFuture ...
[09:32:19.983] result() for MulticoreFuture ...
[09:32:19.984] result() for MulticoreFuture ... done
[09:32:19.984] result() for MulticoreFuture ... done
[09:32:19.984] result() for MulticoreFuture ...
[09:32:19.984] result() for MulticoreFuture ... done
[09:32:19.986] MulticoreFuture started
[09:32:19.987] - Launch lazy future ... done
[09:32:19.987] run() for ‘MulticoreFuture’ ... done
[09:32:19.987] plan(): Setting new future strategy stack:
[09:32:19.988] getGlobalsAndPackages() ...
[09:32:19.988] Searching for globals...
[09:32:19.988] List of future strategies:
[09:32:19.988] 1. sequential:
[09:32:19.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:19.988]    - tweaked: FALSE
[09:32:19.988]    - call: NULL
[09:32:19.989] plan(): nbrOfWorkers() = 1
[09:32:19.991] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:19.991] Searching for globals ... DONE
[09:32:19.991] Resolving globals: FALSE
[09:32:19.991] plan(): Setting new future strategy stack:
[09:32:19.992] 
[09:32:19.991] List of future strategies:
[09:32:19.991] 1. multicore:
[09:32:19.991]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:19.991]    - tweaked: FALSE
[09:32:19.991]    - call: plan(strategy)
[09:32:19.992] 
[09:32:19.992] getGlobalsAndPackages() ... DONE
[09:32:19.993] run() for ‘Future’ ...
[09:32:19.993] - state: ‘created’
[09:32:19.993] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:19.997] plan(): nbrOfWorkers() = 2
[09:32:19.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:19.999] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:19.999]   - Field: ‘label’
[09:32:19.999]   - Field: ‘local’
[09:32:19.999]   - Field: ‘owner’
[09:32:19.999]   - Field: ‘envir’
[09:32:19.999]   - Field: ‘workers’
[09:32:20.000]   - Field: ‘packages’
[09:32:20.000]   - Field: ‘gc’
[09:32:20.000]   - Field: ‘job’
[09:32:20.000]   - Field: ‘conditions’
[09:32:20.000]   - Field: ‘expr’
[09:32:20.000]   - Field: ‘uuid’
[09:32:20.000]   - Field: ‘seed’
[09:32:20.001]   - Field: ‘version’
[09:32:20.001]   - Field: ‘result’
[09:32:20.001]   - Field: ‘asynchronous’
[09:32:20.001]   - Field: ‘calls’
[09:32:20.001]   - Field: ‘globals’
[09:32:20.001]   - Field: ‘stdout’
[09:32:20.001]   - Field: ‘earlySignal’
[09:32:20.002]   - Field: ‘lazy’
[09:32:20.002]   - Field: ‘state’
[09:32:20.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.002] - Launch lazy future ...
[09:32:20.002] Packages needed by the future expression (n = 0): <none>
[09:32:20.003] Packages needed by future strategies (n = 0): <none>
[09:32:20.003] {
[09:32:20.003]     {
[09:32:20.003]         {
[09:32:20.003]             ...future.startTime <- base::Sys.time()
[09:32:20.003]             {
[09:32:20.003]                 {
[09:32:20.003]                   {
[09:32:20.003]                     {
[09:32:20.003]                       base::local({
[09:32:20.003]                         has_future <- base::requireNamespace("future", 
[09:32:20.003]                           quietly = TRUE)
[09:32:20.003]                         if (has_future) {
[09:32:20.003]                           ns <- base::getNamespace("future")
[09:32:20.003]                           version <- ns[[".package"]][["version"]]
[09:32:20.003]                           if (is.null(version)) 
[09:32:20.003]                             version <- utils::packageVersion("future")
[09:32:20.003]                         }
[09:32:20.003]                         else {
[09:32:20.003]                           version <- NULL
[09:32:20.003]                         }
[09:32:20.003]                         if (!has_future || version < "1.8.0") {
[09:32:20.003]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.003]                             "", base::R.version$version.string), 
[09:32:20.003]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.003]                               "release", "version")], collapse = " "), 
[09:32:20.003]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.003]                             info)
[09:32:20.003]                           info <- base::paste(info, collapse = "; ")
[09:32:20.003]                           if (!has_future) {
[09:32:20.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.003]                               info)
[09:32:20.003]                           }
[09:32:20.003]                           else {
[09:32:20.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.003]                               info, version)
[09:32:20.003]                           }
[09:32:20.003]                           base::stop(msg)
[09:32:20.003]                         }
[09:32:20.003]                       })
[09:32:20.003]                     }
[09:32:20.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.003]                     base::options(mc.cores = 1L)
[09:32:20.003]                   }
[09:32:20.003]                   ...future.strategy.old <- future::plan("list")
[09:32:20.003]                   options(future.plan = NULL)
[09:32:20.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.003]                 }
[09:32:20.003]                 ...future.workdir <- getwd()
[09:32:20.003]             }
[09:32:20.003]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.003]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.003]         }
[09:32:20.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.003]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.003]             base::names(...future.oldOptions))
[09:32:20.003]     }
[09:32:20.003]     if (FALSE) {
[09:32:20.003]     }
[09:32:20.003]     else {
[09:32:20.003]         if (TRUE) {
[09:32:20.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.003]                 open = "w")
[09:32:20.003]         }
[09:32:20.003]         else {
[09:32:20.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.003]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.003]         }
[09:32:20.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.003]             base::sink(type = "output", split = FALSE)
[09:32:20.003]             base::close(...future.stdout)
[09:32:20.003]         }, add = TRUE)
[09:32:20.003]     }
[09:32:20.003]     ...future.frame <- base::sys.nframe()
[09:32:20.003]     ...future.conditions <- base::list()
[09:32:20.003]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.003]     if (FALSE) {
[09:32:20.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.003]     }
[09:32:20.003]     ...future.result <- base::tryCatch({
[09:32:20.003]         base::withCallingHandlers({
[09:32:20.003]             ...future.value <- base::withVisible(base::local({
[09:32:20.003]                 withCallingHandlers({
[09:32:20.003]                   {
[09:32:20.003]                     Sys.sleep(0.5)
[09:32:20.003]                     2
[09:32:20.003]                   }
[09:32:20.003]                 }, immediateCondition = function(cond) {
[09:32:20.003]                   save_rds <- function (object, pathname, ...) 
[09:32:20.003]                   {
[09:32:20.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.003]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.003]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.003]                         fi_tmp[["mtime"]])
[09:32:20.003]                     }
[09:32:20.003]                     tryCatch({
[09:32:20.003]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.003]                     }, error = function(ex) {
[09:32:20.003]                       msg <- conditionMessage(ex)
[09:32:20.003]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.003]                         fi_tmp[["mtime"]], msg)
[09:32:20.003]                       ex$message <- msg
[09:32:20.003]                       stop(ex)
[09:32:20.003]                     })
[09:32:20.003]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.003]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.003]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.003]                       fi <- file.info(pathname)
[09:32:20.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.003]                         fi[["size"]], fi[["mtime"]])
[09:32:20.003]                       stop(msg)
[09:32:20.003]                     }
[09:32:20.003]                     invisible(pathname)
[09:32:20.003]                   }
[09:32:20.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.003]                     rootPath = tempdir()) 
[09:32:20.003]                   {
[09:32:20.003]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.003]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.003]                       tmpdir = path, fileext = ".rds")
[09:32:20.003]                     save_rds(obj, file)
[09:32:20.003]                   }
[09:32:20.003]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.003]                   {
[09:32:20.003]                     inherits <- base::inherits
[09:32:20.003]                     invokeRestart <- base::invokeRestart
[09:32:20.003]                     is.null <- base::is.null
[09:32:20.003]                     muffled <- FALSE
[09:32:20.003]                     if (inherits(cond, "message")) {
[09:32:20.003]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.003]                       if (muffled) 
[09:32:20.003]                         invokeRestart("muffleMessage")
[09:32:20.003]                     }
[09:32:20.003]                     else if (inherits(cond, "warning")) {
[09:32:20.003]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.003]                       if (muffled) 
[09:32:20.003]                         invokeRestart("muffleWarning")
[09:32:20.003]                     }
[09:32:20.003]                     else if (inherits(cond, "condition")) {
[09:32:20.003]                       if (!is.null(pattern)) {
[09:32:20.003]                         computeRestarts <- base::computeRestarts
[09:32:20.003]                         grepl <- base::grepl
[09:32:20.003]                         restarts <- computeRestarts(cond)
[09:32:20.003]                         for (restart in restarts) {
[09:32:20.003]                           name <- restart$name
[09:32:20.003]                           if (is.null(name)) 
[09:32:20.003]                             next
[09:32:20.003]                           if (!grepl(pattern, name)) 
[09:32:20.003]                             next
[09:32:20.003]                           invokeRestart(restart)
[09:32:20.003]                           muffled <- TRUE
[09:32:20.003]                           break
[09:32:20.003]                         }
[09:32:20.003]                       }
[09:32:20.003]                     }
[09:32:20.003]                     invisible(muffled)
[09:32:20.003]                   }
[09:32:20.003]                   muffleCondition(cond)
[09:32:20.003]                 })
[09:32:20.003]             }))
[09:32:20.003]             future::FutureResult(value = ...future.value$value, 
[09:32:20.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.003]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.003]                     ...future.globalenv.names))
[09:32:20.003]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.003]         }, condition = base::local({
[09:32:20.003]             c <- base::c
[09:32:20.003]             inherits <- base::inherits
[09:32:20.003]             invokeRestart <- base::invokeRestart
[09:32:20.003]             length <- base::length
[09:32:20.003]             list <- base::list
[09:32:20.003]             seq.int <- base::seq.int
[09:32:20.003]             signalCondition <- base::signalCondition
[09:32:20.003]             sys.calls <- base::sys.calls
[09:32:20.003]             `[[` <- base::`[[`
[09:32:20.003]             `+` <- base::`+`
[09:32:20.003]             `<<-` <- base::`<<-`
[09:32:20.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.003]                   3L)]
[09:32:20.003]             }
[09:32:20.003]             function(cond) {
[09:32:20.003]                 is_error <- inherits(cond, "error")
[09:32:20.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.003]                   NULL)
[09:32:20.003]                 if (is_error) {
[09:32:20.003]                   sessionInformation <- function() {
[09:32:20.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.003]                       search = base::search(), system = base::Sys.info())
[09:32:20.003]                   }
[09:32:20.003]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.003]                     cond$call), session = sessionInformation(), 
[09:32:20.003]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.003]                   signalCondition(cond)
[09:32:20.003]                 }
[09:32:20.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.003]                 "immediateCondition"))) {
[09:32:20.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.003]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.003]                   if (TRUE && !signal) {
[09:32:20.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.003]                     {
[09:32:20.003]                       inherits <- base::inherits
[09:32:20.003]                       invokeRestart <- base::invokeRestart
[09:32:20.003]                       is.null <- base::is.null
[09:32:20.003]                       muffled <- FALSE
[09:32:20.003]                       if (inherits(cond, "message")) {
[09:32:20.003]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.003]                         if (muffled) 
[09:32:20.003]                           invokeRestart("muffleMessage")
[09:32:20.003]                       }
[09:32:20.003]                       else if (inherits(cond, "warning")) {
[09:32:20.003]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.003]                         if (muffled) 
[09:32:20.003]                           invokeRestart("muffleWarning")
[09:32:20.003]                       }
[09:32:20.003]                       else if (inherits(cond, "condition")) {
[09:32:20.003]                         if (!is.null(pattern)) {
[09:32:20.003]                           computeRestarts <- base::computeRestarts
[09:32:20.003]                           grepl <- base::grepl
[09:32:20.003]                           restarts <- computeRestarts(cond)
[09:32:20.003]                           for (restart in restarts) {
[09:32:20.003]                             name <- restart$name
[09:32:20.003]                             if (is.null(name)) 
[09:32:20.003]                               next
[09:32:20.003]                             if (!grepl(pattern, name)) 
[09:32:20.003]                               next
[09:32:20.003]                             invokeRestart(restart)
[09:32:20.003]                             muffled <- TRUE
[09:32:20.003]                             break
[09:32:20.003]                           }
[09:32:20.003]                         }
[09:32:20.003]                       }
[09:32:20.003]                       invisible(muffled)
[09:32:20.003]                     }
[09:32:20.003]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.003]                   }
[09:32:20.003]                 }
[09:32:20.003]                 else {
[09:32:20.003]                   if (TRUE) {
[09:32:20.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.003]                     {
[09:32:20.003]                       inherits <- base::inherits
[09:32:20.003]                       invokeRestart <- base::invokeRestart
[09:32:20.003]                       is.null <- base::is.null
[09:32:20.003]                       muffled <- FALSE
[09:32:20.003]                       if (inherits(cond, "message")) {
[09:32:20.003]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.003]                         if (muffled) 
[09:32:20.003]                           invokeRestart("muffleMessage")
[09:32:20.003]                       }
[09:32:20.003]                       else if (inherits(cond, "warning")) {
[09:32:20.003]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.003]                         if (muffled) 
[09:32:20.003]                           invokeRestart("muffleWarning")
[09:32:20.003]                       }
[09:32:20.003]                       else if (inherits(cond, "condition")) {
[09:32:20.003]                         if (!is.null(pattern)) {
[09:32:20.003]                           computeRestarts <- base::computeRestarts
[09:32:20.003]                           grepl <- base::grepl
[09:32:20.003]                           restarts <- computeRestarts(cond)
[09:32:20.003]                           for (restart in restarts) {
[09:32:20.003]                             name <- restart$name
[09:32:20.003]                             if (is.null(name)) 
[09:32:20.003]                               next
[09:32:20.003]                             if (!grepl(pattern, name)) 
[09:32:20.003]                               next
[09:32:20.003]                             invokeRestart(restart)
[09:32:20.003]                             muffled <- TRUE
[09:32:20.003]                             break
[09:32:20.003]                           }
[09:32:20.003]                         }
[09:32:20.003]                       }
[09:32:20.003]                       invisible(muffled)
[09:32:20.003]                     }
[09:32:20.003]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.003]                   }
[09:32:20.003]                 }
[09:32:20.003]             }
[09:32:20.003]         }))
[09:32:20.003]     }, error = function(ex) {
[09:32:20.003]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.003]                 ...future.rng), started = ...future.startTime, 
[09:32:20.003]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.003]             version = "1.8"), class = "FutureResult")
[09:32:20.003]     }, finally = {
[09:32:20.003]         if (!identical(...future.workdir, getwd())) 
[09:32:20.003]             setwd(...future.workdir)
[09:32:20.003]         {
[09:32:20.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.003]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.003]             }
[09:32:20.003]             base::options(...future.oldOptions)
[09:32:20.003]             if (.Platform$OS.type == "windows") {
[09:32:20.003]                 old_names <- names(...future.oldEnvVars)
[09:32:20.003]                 envs <- base::Sys.getenv()
[09:32:20.003]                 names <- names(envs)
[09:32:20.003]                 common <- intersect(names, old_names)
[09:32:20.003]                 added <- setdiff(names, old_names)
[09:32:20.003]                 removed <- setdiff(old_names, names)
[09:32:20.003]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.003]                   envs[common]]
[09:32:20.003]                 NAMES <- toupper(changed)
[09:32:20.003]                 args <- list()
[09:32:20.003]                 for (kk in seq_along(NAMES)) {
[09:32:20.003]                   name <- changed[[kk]]
[09:32:20.003]                   NAME <- NAMES[[kk]]
[09:32:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.003]                     next
[09:32:20.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.003]                 }
[09:32:20.003]                 NAMES <- toupper(added)
[09:32:20.003]                 for (kk in seq_along(NAMES)) {
[09:32:20.003]                   name <- added[[kk]]
[09:32:20.003]                   NAME <- NAMES[[kk]]
[09:32:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.003]                     next
[09:32:20.003]                   args[[name]] <- ""
[09:32:20.003]                 }
[09:32:20.003]                 NAMES <- toupper(removed)
[09:32:20.003]                 for (kk in seq_along(NAMES)) {
[09:32:20.003]                   name <- removed[[kk]]
[09:32:20.003]                   NAME <- NAMES[[kk]]
[09:32:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.003]                     next
[09:32:20.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.003]                 }
[09:32:20.003]                 if (length(args) > 0) 
[09:32:20.003]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.003]             }
[09:32:20.003]             else {
[09:32:20.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.003]             }
[09:32:20.003]             {
[09:32:20.003]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.003]                   0L) {
[09:32:20.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.003]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.003]                   base::options(opts)
[09:32:20.003]                 }
[09:32:20.003]                 {
[09:32:20.003]                   {
[09:32:20.003]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.003]                     NULL
[09:32:20.003]                   }
[09:32:20.003]                   options(future.plan = NULL)
[09:32:20.003]                   if (is.na(NA_character_)) 
[09:32:20.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.003]                     .init = FALSE)
[09:32:20.003]                 }
[09:32:20.003]             }
[09:32:20.003]         }
[09:32:20.003]     })
[09:32:20.003]     if (TRUE) {
[09:32:20.003]         base::sink(type = "output", split = FALSE)
[09:32:20.003]         if (TRUE) {
[09:32:20.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.003]         }
[09:32:20.003]         else {
[09:32:20.003]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.003]         }
[09:32:20.003]         base::close(...future.stdout)
[09:32:20.003]         ...future.stdout <- NULL
[09:32:20.003]     }
[09:32:20.003]     ...future.result$conditions <- ...future.conditions
[09:32:20.003]     ...future.result$finished <- base::Sys.time()
[09:32:20.003]     ...future.result
[09:32:20.003] }
[09:32:20.007] requestCore(): workers = 2
[09:32:20.007] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.018] result() for MulticoreFuture ...
[09:32:20.019] result() for MulticoreFuture ...
[09:32:20.019] result() for MulticoreFuture ... done
[09:32:20.019] result() for MulticoreFuture ... done
[09:32:20.019] result() for MulticoreFuture ...
[09:32:20.019] result() for MulticoreFuture ... done
[09:32:20.022] MulticoreFuture started
[09:32:20.022] - Launch lazy future ... done
[09:32:20.022] run() for ‘MulticoreFuture’ ... done
[09:32:20.023] plan(): Setting new future strategy stack:
[09:32:20.023] resolve() on list ...
[09:32:20.023]  recursive: 0
[09:32:20.023]  length: 1
[09:32:20.024] 
[09:32:20.023] List of future strategies:
[09:32:20.023] 1. sequential:
[09:32:20.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.023]    - tweaked: FALSE
[09:32:20.023]    - call: NULL
[09:32:20.024] Future #1
[09:32:20.024] plan(): nbrOfWorkers() = 1
[09:32:20.024]  length: 0 (resolved future 1)
[09:32:20.025] resolve() on list ... DONE
[09:32:20.025] resolve() on list ...
[09:32:20.025]  recursive: 0
[09:32:20.025]  length: 1
[09:32:20.025] 
[09:32:20.527] plan(): Setting new future strategy stack:
[09:32:20.527] List of future strategies:
[09:32:20.527] 1. multicore:
[09:32:20.527]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:20.527]    - tweaked: FALSE
[09:32:20.527]    - call: plan(strategy)
[09:32:20.532] plan(): nbrOfWorkers() = 2
[09:32:20.536] Future #1
[09:32:20.536]  length: 0 (resolved future 1)
[09:32:20.536] resolve() on list ... DONE
[09:32:20.537] resolve() on list ...
[09:32:20.537]  recursive: 0
[09:32:20.537]  length: 1
[09:32:20.537] 
[09:32:20.538]  length: 0 (resolved future 1)
[09:32:20.538] resolve() on list ... DONE
[09:32:20.538] resolve() on list ...
[09:32:20.538]  recursive: 0
[09:32:20.538]  length: 4
[09:32:20.538] 
[09:32:20.539] Future #1
[09:32:20.539]  length: 3 (resolved future 1)
[09:32:20.539] Future #2
[09:32:20.539]  length: 2 (resolved future 2)
[09:32:20.540]  length: 1 (resolved future 3)
[09:32:20.540]  length: 0 (resolved future 4)
[09:32:20.540] resolve() on list ... DONE
[09:32:20.540] resolve() on list ...
[09:32:20.540]  recursive: 0
[09:32:20.540]  length: 4
[09:32:20.541] 
[09:32:20.541] Future #1
[09:32:20.541]  length: 3 (resolved future 1)
[09:32:20.541] Future #2
[09:32:20.541]  length: 2 (resolved future 2)
[09:32:20.542]  length: 1 (resolved future 3)
[09:32:20.542]  length: 0 (resolved future 4)
[09:32:20.542] resolve() on list ... DONE
[09:32:20.542] resolve() on list ...
[09:32:20.542]  recursive: 0
[09:32:20.542]  length: 1
[09:32:20.543] 
[09:32:20.543]  length: 0 (resolved future 1)
[09:32:20.543] resolve() on list ... DONE
[09:32:20.543] getGlobalsAndPackages() ...
[09:32:20.543] Searching for globals...
[09:32:20.545] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.545] Searching for globals ... DONE
[09:32:20.546] Resolving globals: FALSE
[09:32:20.546] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.547] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.547] - globals: [1] ‘kk’
[09:32:20.547] 
[09:32:20.547] getGlobalsAndPackages() ... DONE
[09:32:20.548] run() for ‘Future’ ...
[09:32:20.548] - state: ‘created’
[09:32:20.548] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.552] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.553]   - Field: ‘label’
[09:32:20.553]   - Field: ‘local’
[09:32:20.553]   - Field: ‘owner’
[09:32:20.553]   - Field: ‘envir’
[09:32:20.553]   - Field: ‘workers’
[09:32:20.554]   - Field: ‘packages’
[09:32:20.554]   - Field: ‘gc’
[09:32:20.554]   - Field: ‘job’
[09:32:20.554]   - Field: ‘conditions’
[09:32:20.554]   - Field: ‘expr’
[09:32:20.554]   - Field: ‘uuid’
[09:32:20.554]   - Field: ‘seed’
[09:32:20.554]   - Field: ‘version’
[09:32:20.555]   - Field: ‘result’
[09:32:20.555]   - Field: ‘asynchronous’
[09:32:20.555]   - Field: ‘calls’
[09:32:20.558]   - Field: ‘globals’
[09:32:20.559]   - Field: ‘stdout’
[09:32:20.559]   - Field: ‘earlySignal’
[09:32:20.559]   - Field: ‘lazy’
[09:32:20.559]   - Field: ‘state’
[09:32:20.560] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.560] - Launch lazy future ...
[09:32:20.561] Packages needed by the future expression (n = 0): <none>
[09:32:20.561] Packages needed by future strategies (n = 0): <none>
[09:32:20.562] {
[09:32:20.562]     {
[09:32:20.562]         {
[09:32:20.562]             ...future.startTime <- base::Sys.time()
[09:32:20.562]             {
[09:32:20.562]                 {
[09:32:20.562]                   {
[09:32:20.562]                     {
[09:32:20.562]                       base::local({
[09:32:20.562]                         has_future <- base::requireNamespace("future", 
[09:32:20.562]                           quietly = TRUE)
[09:32:20.562]                         if (has_future) {
[09:32:20.562]                           ns <- base::getNamespace("future")
[09:32:20.562]                           version <- ns[[".package"]][["version"]]
[09:32:20.562]                           if (is.null(version)) 
[09:32:20.562]                             version <- utils::packageVersion("future")
[09:32:20.562]                         }
[09:32:20.562]                         else {
[09:32:20.562]                           version <- NULL
[09:32:20.562]                         }
[09:32:20.562]                         if (!has_future || version < "1.8.0") {
[09:32:20.562]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.562]                             "", base::R.version$version.string), 
[09:32:20.562]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.562]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.562]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.562]                               "release", "version")], collapse = " "), 
[09:32:20.562]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.562]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.562]                             info)
[09:32:20.562]                           info <- base::paste(info, collapse = "; ")
[09:32:20.562]                           if (!has_future) {
[09:32:20.562]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.562]                               info)
[09:32:20.562]                           }
[09:32:20.562]                           else {
[09:32:20.562]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.562]                               info, version)
[09:32:20.562]                           }
[09:32:20.562]                           base::stop(msg)
[09:32:20.562]                         }
[09:32:20.562]                       })
[09:32:20.562]                     }
[09:32:20.562]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.562]                     base::options(mc.cores = 1L)
[09:32:20.562]                   }
[09:32:20.562]                   ...future.strategy.old <- future::plan("list")
[09:32:20.562]                   options(future.plan = NULL)
[09:32:20.562]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.562]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.562]                 }
[09:32:20.562]                 ...future.workdir <- getwd()
[09:32:20.562]             }
[09:32:20.562]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.562]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.562]         }
[09:32:20.562]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.562]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.562]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.562]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.562]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.562]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.562]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.562]             base::names(...future.oldOptions))
[09:32:20.562]     }
[09:32:20.562]     if (FALSE) {
[09:32:20.562]     }
[09:32:20.562]     else {
[09:32:20.562]         if (TRUE) {
[09:32:20.562]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.562]                 open = "w")
[09:32:20.562]         }
[09:32:20.562]         else {
[09:32:20.562]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.562]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.562]         }
[09:32:20.562]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.562]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.562]             base::sink(type = "output", split = FALSE)
[09:32:20.562]             base::close(...future.stdout)
[09:32:20.562]         }, add = TRUE)
[09:32:20.562]     }
[09:32:20.562]     ...future.frame <- base::sys.nframe()
[09:32:20.562]     ...future.conditions <- base::list()
[09:32:20.562]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.562]     if (FALSE) {
[09:32:20.562]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.562]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.562]     }
[09:32:20.562]     ...future.result <- base::tryCatch({
[09:32:20.562]         base::withCallingHandlers({
[09:32:20.562]             ...future.value <- base::withVisible(base::local({
[09:32:20.562]                 withCallingHandlers({
[09:32:20.562]                   {
[09:32:20.562]                     Sys.sleep(0.1)
[09:32:20.562]                     kk
[09:32:20.562]                   }
[09:32:20.562]                 }, immediateCondition = function(cond) {
[09:32:20.562]                   save_rds <- function (object, pathname, ...) 
[09:32:20.562]                   {
[09:32:20.562]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.562]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.562]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.562]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.562]                         fi_tmp[["mtime"]])
[09:32:20.562]                     }
[09:32:20.562]                     tryCatch({
[09:32:20.562]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.562]                     }, error = function(ex) {
[09:32:20.562]                       msg <- conditionMessage(ex)
[09:32:20.562]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.562]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.562]                         fi_tmp[["mtime"]], msg)
[09:32:20.562]                       ex$message <- msg
[09:32:20.562]                       stop(ex)
[09:32:20.562]                     })
[09:32:20.562]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.562]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.562]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.562]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.562]                       fi <- file.info(pathname)
[09:32:20.562]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.562]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.562]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.562]                         fi[["size"]], fi[["mtime"]])
[09:32:20.562]                       stop(msg)
[09:32:20.562]                     }
[09:32:20.562]                     invisible(pathname)
[09:32:20.562]                   }
[09:32:20.562]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.562]                     rootPath = tempdir()) 
[09:32:20.562]                   {
[09:32:20.562]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.562]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.562]                       tmpdir = path, fileext = ".rds")
[09:32:20.562]                     save_rds(obj, file)
[09:32:20.562]                   }
[09:32:20.562]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.562]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.562]                   {
[09:32:20.562]                     inherits <- base::inherits
[09:32:20.562]                     invokeRestart <- base::invokeRestart
[09:32:20.562]                     is.null <- base::is.null
[09:32:20.562]                     muffled <- FALSE
[09:32:20.562]                     if (inherits(cond, "message")) {
[09:32:20.562]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.562]                       if (muffled) 
[09:32:20.562]                         invokeRestart("muffleMessage")
[09:32:20.562]                     }
[09:32:20.562]                     else if (inherits(cond, "warning")) {
[09:32:20.562]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.562]                       if (muffled) 
[09:32:20.562]                         invokeRestart("muffleWarning")
[09:32:20.562]                     }
[09:32:20.562]                     else if (inherits(cond, "condition")) {
[09:32:20.562]                       if (!is.null(pattern)) {
[09:32:20.562]                         computeRestarts <- base::computeRestarts
[09:32:20.562]                         grepl <- base::grepl
[09:32:20.562]                         restarts <- computeRestarts(cond)
[09:32:20.562]                         for (restart in restarts) {
[09:32:20.562]                           name <- restart$name
[09:32:20.562]                           if (is.null(name)) 
[09:32:20.562]                             next
[09:32:20.562]                           if (!grepl(pattern, name)) 
[09:32:20.562]                             next
[09:32:20.562]                           invokeRestart(restart)
[09:32:20.562]                           muffled <- TRUE
[09:32:20.562]                           break
[09:32:20.562]                         }
[09:32:20.562]                       }
[09:32:20.562]                     }
[09:32:20.562]                     invisible(muffled)
[09:32:20.562]                   }
[09:32:20.562]                   muffleCondition(cond)
[09:32:20.562]                 })
[09:32:20.562]             }))
[09:32:20.562]             future::FutureResult(value = ...future.value$value, 
[09:32:20.562]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.562]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.562]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.562]                     ...future.globalenv.names))
[09:32:20.562]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.562]         }, condition = base::local({
[09:32:20.562]             c <- base::c
[09:32:20.562]             inherits <- base::inherits
[09:32:20.562]             invokeRestart <- base::invokeRestart
[09:32:20.562]             length <- base::length
[09:32:20.562]             list <- base::list
[09:32:20.562]             seq.int <- base::seq.int
[09:32:20.562]             signalCondition <- base::signalCondition
[09:32:20.562]             sys.calls <- base::sys.calls
[09:32:20.562]             `[[` <- base::`[[`
[09:32:20.562]             `+` <- base::`+`
[09:32:20.562]             `<<-` <- base::`<<-`
[09:32:20.562]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.562]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.562]                   3L)]
[09:32:20.562]             }
[09:32:20.562]             function(cond) {
[09:32:20.562]                 is_error <- inherits(cond, "error")
[09:32:20.562]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.562]                   NULL)
[09:32:20.562]                 if (is_error) {
[09:32:20.562]                   sessionInformation <- function() {
[09:32:20.562]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.562]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.562]                       search = base::search(), system = base::Sys.info())
[09:32:20.562]                   }
[09:32:20.562]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.562]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.562]                     cond$call), session = sessionInformation(), 
[09:32:20.562]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.562]                   signalCondition(cond)
[09:32:20.562]                 }
[09:32:20.562]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.562]                 "immediateCondition"))) {
[09:32:20.562]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.562]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.562]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.562]                   if (TRUE && !signal) {
[09:32:20.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.562]                     {
[09:32:20.562]                       inherits <- base::inherits
[09:32:20.562]                       invokeRestart <- base::invokeRestart
[09:32:20.562]                       is.null <- base::is.null
[09:32:20.562]                       muffled <- FALSE
[09:32:20.562]                       if (inherits(cond, "message")) {
[09:32:20.562]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.562]                         if (muffled) 
[09:32:20.562]                           invokeRestart("muffleMessage")
[09:32:20.562]                       }
[09:32:20.562]                       else if (inherits(cond, "warning")) {
[09:32:20.562]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.562]                         if (muffled) 
[09:32:20.562]                           invokeRestart("muffleWarning")
[09:32:20.562]                       }
[09:32:20.562]                       else if (inherits(cond, "condition")) {
[09:32:20.562]                         if (!is.null(pattern)) {
[09:32:20.562]                           computeRestarts <- base::computeRestarts
[09:32:20.562]                           grepl <- base::grepl
[09:32:20.562]                           restarts <- computeRestarts(cond)
[09:32:20.562]                           for (restart in restarts) {
[09:32:20.562]                             name <- restart$name
[09:32:20.562]                             if (is.null(name)) 
[09:32:20.562]                               next
[09:32:20.562]                             if (!grepl(pattern, name)) 
[09:32:20.562]                               next
[09:32:20.562]                             invokeRestart(restart)
[09:32:20.562]                             muffled <- TRUE
[09:32:20.562]                             break
[09:32:20.562]                           }
[09:32:20.562]                         }
[09:32:20.562]                       }
[09:32:20.562]                       invisible(muffled)
[09:32:20.562]                     }
[09:32:20.562]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.562]                   }
[09:32:20.562]                 }
[09:32:20.562]                 else {
[09:32:20.562]                   if (TRUE) {
[09:32:20.562]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.562]                     {
[09:32:20.562]                       inherits <- base::inherits
[09:32:20.562]                       invokeRestart <- base::invokeRestart
[09:32:20.562]                       is.null <- base::is.null
[09:32:20.562]                       muffled <- FALSE
[09:32:20.562]                       if (inherits(cond, "message")) {
[09:32:20.562]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.562]                         if (muffled) 
[09:32:20.562]                           invokeRestart("muffleMessage")
[09:32:20.562]                       }
[09:32:20.562]                       else if (inherits(cond, "warning")) {
[09:32:20.562]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.562]                         if (muffled) 
[09:32:20.562]                           invokeRestart("muffleWarning")
[09:32:20.562]                       }
[09:32:20.562]                       else if (inherits(cond, "condition")) {
[09:32:20.562]                         if (!is.null(pattern)) {
[09:32:20.562]                           computeRestarts <- base::computeRestarts
[09:32:20.562]                           grepl <- base::grepl
[09:32:20.562]                           restarts <- computeRestarts(cond)
[09:32:20.562]                           for (restart in restarts) {
[09:32:20.562]                             name <- restart$name
[09:32:20.562]                             if (is.null(name)) 
[09:32:20.562]                               next
[09:32:20.562]                             if (!grepl(pattern, name)) 
[09:32:20.562]                               next
[09:32:20.562]                             invokeRestart(restart)
[09:32:20.562]                             muffled <- TRUE
[09:32:20.562]                             break
[09:32:20.562]                           }
[09:32:20.562]                         }
[09:32:20.562]                       }
[09:32:20.562]                       invisible(muffled)
[09:32:20.562]                     }
[09:32:20.562]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.562]                   }
[09:32:20.562]                 }
[09:32:20.562]             }
[09:32:20.562]         }))
[09:32:20.562]     }, error = function(ex) {
[09:32:20.562]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.562]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.562]                 ...future.rng), started = ...future.startTime, 
[09:32:20.562]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.562]             version = "1.8"), class = "FutureResult")
[09:32:20.562]     }, finally = {
[09:32:20.562]         if (!identical(...future.workdir, getwd())) 
[09:32:20.562]             setwd(...future.workdir)
[09:32:20.562]         {
[09:32:20.562]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.562]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.562]             }
[09:32:20.562]             base::options(...future.oldOptions)
[09:32:20.562]             if (.Platform$OS.type == "windows") {
[09:32:20.562]                 old_names <- names(...future.oldEnvVars)
[09:32:20.562]                 envs <- base::Sys.getenv()
[09:32:20.562]                 names <- names(envs)
[09:32:20.562]                 common <- intersect(names, old_names)
[09:32:20.562]                 added <- setdiff(names, old_names)
[09:32:20.562]                 removed <- setdiff(old_names, names)
[09:32:20.562]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.562]                   envs[common]]
[09:32:20.562]                 NAMES <- toupper(changed)
[09:32:20.562]                 args <- list()
[09:32:20.562]                 for (kk in seq_along(NAMES)) {
[09:32:20.562]                   name <- changed[[kk]]
[09:32:20.562]                   NAME <- NAMES[[kk]]
[09:32:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.562]                     next
[09:32:20.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.562]                 }
[09:32:20.562]                 NAMES <- toupper(added)
[09:32:20.562]                 for (kk in seq_along(NAMES)) {
[09:32:20.562]                   name <- added[[kk]]
[09:32:20.562]                   NAME <- NAMES[[kk]]
[09:32:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.562]                     next
[09:32:20.562]                   args[[name]] <- ""
[09:32:20.562]                 }
[09:32:20.562]                 NAMES <- toupper(removed)
[09:32:20.562]                 for (kk in seq_along(NAMES)) {
[09:32:20.562]                   name <- removed[[kk]]
[09:32:20.562]                   NAME <- NAMES[[kk]]
[09:32:20.562]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.562]                     next
[09:32:20.562]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.562]                 }
[09:32:20.562]                 if (length(args) > 0) 
[09:32:20.562]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.562]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.562]             }
[09:32:20.562]             else {
[09:32:20.562]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.562]             }
[09:32:20.562]             {
[09:32:20.562]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.562]                   0L) {
[09:32:20.562]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.562]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.562]                   base::options(opts)
[09:32:20.562]                 }
[09:32:20.562]                 {
[09:32:20.562]                   {
[09:32:20.562]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.562]                     NULL
[09:32:20.562]                   }
[09:32:20.562]                   options(future.plan = NULL)
[09:32:20.562]                   if (is.na(NA_character_)) 
[09:32:20.562]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.562]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.562]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.562]                     .init = FALSE)
[09:32:20.562]                 }
[09:32:20.562]             }
[09:32:20.562]         }
[09:32:20.562]     })
[09:32:20.562]     if (TRUE) {
[09:32:20.562]         base::sink(type = "output", split = FALSE)
[09:32:20.562]         if (TRUE) {
[09:32:20.562]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.562]         }
[09:32:20.562]         else {
[09:32:20.562]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.562]         }
[09:32:20.562]         base::close(...future.stdout)
[09:32:20.562]         ...future.stdout <- NULL
[09:32:20.562]     }
[09:32:20.562]     ...future.result$conditions <- ...future.conditions
[09:32:20.562]     ...future.result$finished <- base::Sys.time()
[09:32:20.562]     ...future.result
[09:32:20.562] }
[09:32:20.564] assign_globals() ...
[09:32:20.564] List of 1
[09:32:20.564]  $ kk: int 1
[09:32:20.564]  - attr(*, "where")=List of 1
[09:32:20.564]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.564]  - attr(*, "resolved")= logi FALSE
[09:32:20.564]  - attr(*, "total_size")= num 56
[09:32:20.564]  - attr(*, "already-done")= logi TRUE
[09:32:20.568] - copied ‘kk’ to environment
[09:32:20.568] assign_globals() ... done
[09:32:20.569] requestCore(): workers = 2
[09:32:20.569] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.579] result() for MulticoreFuture ...
[09:32:20.580] result() for MulticoreFuture ...
[09:32:20.580] result() for MulticoreFuture ... done
[09:32:20.581] result() for MulticoreFuture ... done
[09:32:20.581] result() for MulticoreFuture ...
[09:32:20.581] result() for MulticoreFuture ... done
[09:32:20.583] MulticoreFuture started
[09:32:20.584] - Launch lazy future ... done
[09:32:20.584] run() for ‘MulticoreFuture’ ... done
[09:32:20.585] getGlobalsAndPackages() ...
[09:32:20.585] plan(): Setting new future strategy stack:
[09:32:20.585] Searching for globals...
[09:32:20.585] List of future strategies:
[09:32:20.585] 1. sequential:
[09:32:20.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.585]    - tweaked: FALSE
[09:32:20.585]    - call: NULL
[09:32:20.587] plan(): nbrOfWorkers() = 1
[09:32:20.588] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.588] Searching for globals ... DONE
[09:32:20.589] Resolving globals: FALSE
[09:32:20.589] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.590] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.590] - globals: [1] ‘kk’
[09:32:20.590] 
[09:32:20.591] getGlobalsAndPackages() ... DONE
[09:32:20.591] run() for ‘Future’ ...
[09:32:20.591] - state: ‘created’
[09:32:20.591] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.596] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.597] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.597]   - Field: ‘label’
[09:32:20.597]   - Field: ‘local’
[09:32:20.597]   - Field: ‘owner’
[09:32:20.597]   - Field: ‘envir’
[09:32:20.597]   - Field: ‘workers’
[09:32:20.597]   - Field: ‘packages’
[09:32:20.598]   - Field: ‘gc’
[09:32:20.598]   - Field: ‘job’
[09:32:20.598]   - Field: ‘conditions’
[09:32:20.598]   - Field: ‘expr’
[09:32:20.598]   - Field: ‘uuid’
[09:32:20.598]   - Field: ‘seed’
[09:32:20.598]   - Field: ‘version’
[09:32:20.599]   - Field: ‘result’
[09:32:20.599]   - Field: ‘asynchronous’
[09:32:20.599]   - Field: ‘calls’
[09:32:20.599]   - Field: ‘globals’
[09:32:20.599]   - Field: ‘stdout’
[09:32:20.599]   - Field: ‘earlySignal’
[09:32:20.599]   - Field: ‘lazy’
[09:32:20.600]   - Field: ‘state’
[09:32:20.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.600] - Launch lazy future ...
[09:32:20.600] Packages needed by the future expression (n = 0): <none>
[09:32:20.601] Packages needed by future strategies (n = 0): <none>
[09:32:20.601] {
[09:32:20.601]     {
[09:32:20.601]         {
[09:32:20.601]             ...future.startTime <- base::Sys.time()
[09:32:20.601]             {
[09:32:20.601]                 {
[09:32:20.601]                   {
[09:32:20.601]                     {
[09:32:20.601]                       base::local({
[09:32:20.601]                         has_future <- base::requireNamespace("future", 
[09:32:20.601]                           quietly = TRUE)
[09:32:20.601]                         if (has_future) {
[09:32:20.601]                           ns <- base::getNamespace("future")
[09:32:20.601]                           version <- ns[[".package"]][["version"]]
[09:32:20.601]                           if (is.null(version)) 
[09:32:20.601]                             version <- utils::packageVersion("future")
[09:32:20.601]                         }
[09:32:20.601]                         else {
[09:32:20.601]                           version <- NULL
[09:32:20.601]                         }
[09:32:20.601]                         if (!has_future || version < "1.8.0") {
[09:32:20.601]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.601]                             "", base::R.version$version.string), 
[09:32:20.601]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.601]                               "release", "version")], collapse = " "), 
[09:32:20.601]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.601]                             info)
[09:32:20.601]                           info <- base::paste(info, collapse = "; ")
[09:32:20.601]                           if (!has_future) {
[09:32:20.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.601]                               info)
[09:32:20.601]                           }
[09:32:20.601]                           else {
[09:32:20.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.601]                               info, version)
[09:32:20.601]                           }
[09:32:20.601]                           base::stop(msg)
[09:32:20.601]                         }
[09:32:20.601]                       })
[09:32:20.601]                     }
[09:32:20.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.601]                     base::options(mc.cores = 1L)
[09:32:20.601]                   }
[09:32:20.601]                   ...future.strategy.old <- future::plan("list")
[09:32:20.601]                   options(future.plan = NULL)
[09:32:20.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.601]                 }
[09:32:20.601]                 ...future.workdir <- getwd()
[09:32:20.601]             }
[09:32:20.601]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.601]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.601]         }
[09:32:20.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.601]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.601]             base::names(...future.oldOptions))
[09:32:20.601]     }
[09:32:20.601]     if (FALSE) {
[09:32:20.601]     }
[09:32:20.601]     else {
[09:32:20.601]         if (TRUE) {
[09:32:20.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.601]                 open = "w")
[09:32:20.601]         }
[09:32:20.601]         else {
[09:32:20.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.601]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.601]         }
[09:32:20.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.601]             base::sink(type = "output", split = FALSE)
[09:32:20.601]             base::close(...future.stdout)
[09:32:20.601]         }, add = TRUE)
[09:32:20.601]     }
[09:32:20.601]     ...future.frame <- base::sys.nframe()
[09:32:20.601]     ...future.conditions <- base::list()
[09:32:20.601]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.601]     if (FALSE) {
[09:32:20.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.601]     }
[09:32:20.601]     ...future.result <- base::tryCatch({
[09:32:20.601]         base::withCallingHandlers({
[09:32:20.601]             ...future.value <- base::withVisible(base::local({
[09:32:20.601]                 withCallingHandlers({
[09:32:20.601]                   {
[09:32:20.601]                     Sys.sleep(0.1)
[09:32:20.601]                     kk
[09:32:20.601]                   }
[09:32:20.601]                 }, immediateCondition = function(cond) {
[09:32:20.601]                   save_rds <- function (object, pathname, ...) 
[09:32:20.601]                   {
[09:32:20.601]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.601]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.601]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.601]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.601]                         fi_tmp[["mtime"]])
[09:32:20.601]                     }
[09:32:20.601]                     tryCatch({
[09:32:20.601]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.601]                     }, error = function(ex) {
[09:32:20.601]                       msg <- conditionMessage(ex)
[09:32:20.601]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.601]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.601]                         fi_tmp[["mtime"]], msg)
[09:32:20.601]                       ex$message <- msg
[09:32:20.601]                       stop(ex)
[09:32:20.601]                     })
[09:32:20.601]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.601]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.601]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.601]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.601]                       fi <- file.info(pathname)
[09:32:20.601]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.601]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.601]                         fi[["size"]], fi[["mtime"]])
[09:32:20.601]                       stop(msg)
[09:32:20.601]                     }
[09:32:20.601]                     invisible(pathname)
[09:32:20.601]                   }
[09:32:20.601]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.601]                     rootPath = tempdir()) 
[09:32:20.601]                   {
[09:32:20.601]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.601]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.601]                       tmpdir = path, fileext = ".rds")
[09:32:20.601]                     save_rds(obj, file)
[09:32:20.601]                   }
[09:32:20.601]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.601]                   {
[09:32:20.601]                     inherits <- base::inherits
[09:32:20.601]                     invokeRestart <- base::invokeRestart
[09:32:20.601]                     is.null <- base::is.null
[09:32:20.601]                     muffled <- FALSE
[09:32:20.601]                     if (inherits(cond, "message")) {
[09:32:20.601]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.601]                       if (muffled) 
[09:32:20.601]                         invokeRestart("muffleMessage")
[09:32:20.601]                     }
[09:32:20.601]                     else if (inherits(cond, "warning")) {
[09:32:20.601]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.601]                       if (muffled) 
[09:32:20.601]                         invokeRestart("muffleWarning")
[09:32:20.601]                     }
[09:32:20.601]                     else if (inherits(cond, "condition")) {
[09:32:20.601]                       if (!is.null(pattern)) {
[09:32:20.601]                         computeRestarts <- base::computeRestarts
[09:32:20.601]                         grepl <- base::grepl
[09:32:20.601]                         restarts <- computeRestarts(cond)
[09:32:20.601]                         for (restart in restarts) {
[09:32:20.601]                           name <- restart$name
[09:32:20.601]                           if (is.null(name)) 
[09:32:20.601]                             next
[09:32:20.601]                           if (!grepl(pattern, name)) 
[09:32:20.601]                             next
[09:32:20.601]                           invokeRestart(restart)
[09:32:20.601]                           muffled <- TRUE
[09:32:20.601]                           break
[09:32:20.601]                         }
[09:32:20.601]                       }
[09:32:20.601]                     }
[09:32:20.601]                     invisible(muffled)
[09:32:20.601]                   }
[09:32:20.601]                   muffleCondition(cond)
[09:32:20.601]                 })
[09:32:20.601]             }))
[09:32:20.601]             future::FutureResult(value = ...future.value$value, 
[09:32:20.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.601]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.601]                     ...future.globalenv.names))
[09:32:20.601]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.601]         }, condition = base::local({
[09:32:20.601]             c <- base::c
[09:32:20.601]             inherits <- base::inherits
[09:32:20.601]             invokeRestart <- base::invokeRestart
[09:32:20.601]             length <- base::length
[09:32:20.601]             list <- base::list
[09:32:20.601]             seq.int <- base::seq.int
[09:32:20.601]             signalCondition <- base::signalCondition
[09:32:20.601]             sys.calls <- base::sys.calls
[09:32:20.601]             `[[` <- base::`[[`
[09:32:20.601]             `+` <- base::`+`
[09:32:20.601]             `<<-` <- base::`<<-`
[09:32:20.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.601]                   3L)]
[09:32:20.601]             }
[09:32:20.601]             function(cond) {
[09:32:20.601]                 is_error <- inherits(cond, "error")
[09:32:20.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.601]                   NULL)
[09:32:20.601]                 if (is_error) {
[09:32:20.601]                   sessionInformation <- function() {
[09:32:20.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.601]                       search = base::search(), system = base::Sys.info())
[09:32:20.601]                   }
[09:32:20.601]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.601]                     cond$call), session = sessionInformation(), 
[09:32:20.601]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.601]                   signalCondition(cond)
[09:32:20.601]                 }
[09:32:20.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.601]                 "immediateCondition"))) {
[09:32:20.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.601]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.601]                   if (TRUE && !signal) {
[09:32:20.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.601]                     {
[09:32:20.601]                       inherits <- base::inherits
[09:32:20.601]                       invokeRestart <- base::invokeRestart
[09:32:20.601]                       is.null <- base::is.null
[09:32:20.601]                       muffled <- FALSE
[09:32:20.601]                       if (inherits(cond, "message")) {
[09:32:20.601]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.601]                         if (muffled) 
[09:32:20.601]                           invokeRestart("muffleMessage")
[09:32:20.601]                       }
[09:32:20.601]                       else if (inherits(cond, "warning")) {
[09:32:20.601]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.601]                         if (muffled) 
[09:32:20.601]                           invokeRestart("muffleWarning")
[09:32:20.601]                       }
[09:32:20.601]                       else if (inherits(cond, "condition")) {
[09:32:20.601]                         if (!is.null(pattern)) {
[09:32:20.601]                           computeRestarts <- base::computeRestarts
[09:32:20.601]                           grepl <- base::grepl
[09:32:20.601]                           restarts <- computeRestarts(cond)
[09:32:20.601]                           for (restart in restarts) {
[09:32:20.601]                             name <- restart$name
[09:32:20.601]                             if (is.null(name)) 
[09:32:20.601]                               next
[09:32:20.601]                             if (!grepl(pattern, name)) 
[09:32:20.601]                               next
[09:32:20.601]                             invokeRestart(restart)
[09:32:20.601]                             muffled <- TRUE
[09:32:20.601]                             break
[09:32:20.601]                           }
[09:32:20.601]                         }
[09:32:20.601]                       }
[09:32:20.601]                       invisible(muffled)
[09:32:20.601]                     }
[09:32:20.601]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.601]                   }
[09:32:20.601]                 }
[09:32:20.601]                 else {
[09:32:20.601]                   if (TRUE) {
[09:32:20.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.601]                     {
[09:32:20.601]                       inherits <- base::inherits
[09:32:20.601]                       invokeRestart <- base::invokeRestart
[09:32:20.601]                       is.null <- base::is.null
[09:32:20.601]                       muffled <- FALSE
[09:32:20.601]                       if (inherits(cond, "message")) {
[09:32:20.601]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.601]                         if (muffled) 
[09:32:20.601]                           invokeRestart("muffleMessage")
[09:32:20.601]                       }
[09:32:20.601]                       else if (inherits(cond, "warning")) {
[09:32:20.601]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.601]                         if (muffled) 
[09:32:20.601]                           invokeRestart("muffleWarning")
[09:32:20.601]                       }
[09:32:20.601]                       else if (inherits(cond, "condition")) {
[09:32:20.601]                         if (!is.null(pattern)) {
[09:32:20.601]                           computeRestarts <- base::computeRestarts
[09:32:20.601]                           grepl <- base::grepl
[09:32:20.601]                           restarts <- computeRestarts(cond)
[09:32:20.601]                           for (restart in restarts) {
[09:32:20.601]                             name <- restart$name
[09:32:20.601]                             if (is.null(name)) 
[09:32:20.601]                               next
[09:32:20.601]                             if (!grepl(pattern, name)) 
[09:32:20.601]                               next
[09:32:20.601]                             invokeRestart(restart)
[09:32:20.601]                             muffled <- TRUE
[09:32:20.601]                             break
[09:32:20.601]                           }
[09:32:20.601]                         }
[09:32:20.601]                       }
[09:32:20.601]                       invisible(muffled)
[09:32:20.601]                     }
[09:32:20.601]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.601]                   }
[09:32:20.601]                 }
[09:32:20.601]             }
[09:32:20.601]         }))
[09:32:20.601]     }, error = function(ex) {
[09:32:20.601]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.601]                 ...future.rng), started = ...future.startTime, 
[09:32:20.601]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.601]             version = "1.8"), class = "FutureResult")
[09:32:20.601]     }, finally = {
[09:32:20.601]         if (!identical(...future.workdir, getwd())) 
[09:32:20.601]             setwd(...future.workdir)
[09:32:20.601]         {
[09:32:20.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.601]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.601]             }
[09:32:20.601]             base::options(...future.oldOptions)
[09:32:20.601]             if (.Platform$OS.type == "windows") {
[09:32:20.601]                 old_names <- names(...future.oldEnvVars)
[09:32:20.601]                 envs <- base::Sys.getenv()
[09:32:20.601]                 names <- names(envs)
[09:32:20.601]                 common <- intersect(names, old_names)
[09:32:20.601]                 added <- setdiff(names, old_names)
[09:32:20.601]                 removed <- setdiff(old_names, names)
[09:32:20.601]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.601]                   envs[common]]
[09:32:20.601]                 NAMES <- toupper(changed)
[09:32:20.601]                 args <- list()
[09:32:20.601]                 for (kk in seq_along(NAMES)) {
[09:32:20.601]                   name <- changed[[kk]]
[09:32:20.601]                   NAME <- NAMES[[kk]]
[09:32:20.601]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.601]                     next
[09:32:20.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.601]                 }
[09:32:20.601]                 NAMES <- toupper(added)
[09:32:20.601]                 for (kk in seq_along(NAMES)) {
[09:32:20.601]                   name <- added[[kk]]
[09:32:20.601]                   NAME <- NAMES[[kk]]
[09:32:20.601]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.601]                     next
[09:32:20.601]                   args[[name]] <- ""
[09:32:20.601]                 }
[09:32:20.601]                 NAMES <- toupper(removed)
[09:32:20.601]                 for (kk in seq_along(NAMES)) {
[09:32:20.601]                   name <- removed[[kk]]
[09:32:20.601]                   NAME <- NAMES[[kk]]
[09:32:20.601]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.601]                     next
[09:32:20.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.601]                 }
[09:32:20.601]                 if (length(args) > 0) 
[09:32:20.601]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.601]             }
[09:32:20.601]             else {
[09:32:20.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.601]             }
[09:32:20.601]             {
[09:32:20.601]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.601]                   0L) {
[09:32:20.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.601]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.601]                   base::options(opts)
[09:32:20.601]                 }
[09:32:20.601]                 {
[09:32:20.601]                   {
[09:32:20.601]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.601]                     NULL
[09:32:20.601]                   }
[09:32:20.601]                   options(future.plan = NULL)
[09:32:20.601]                   if (is.na(NA_character_)) 
[09:32:20.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.601]                     .init = FALSE)
[09:32:20.601]                 }
[09:32:20.601]             }
[09:32:20.601]         }
[09:32:20.601]     })
[09:32:20.601]     if (TRUE) {
[09:32:20.601]         base::sink(type = "output", split = FALSE)
[09:32:20.601]         if (TRUE) {
[09:32:20.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.601]         }
[09:32:20.601]         else {
[09:32:20.601]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.601]         }
[09:32:20.601]         base::close(...future.stdout)
[09:32:20.601]         ...future.stdout <- NULL
[09:32:20.601]     }
[09:32:20.601]     ...future.result$conditions <- ...future.conditions
[09:32:20.601]     ...future.result$finished <- base::Sys.time()
[09:32:20.601]     ...future.result
[09:32:20.601] }
[09:32:20.605] assign_globals() ...
[09:32:20.605] List of 1
[09:32:20.605]  $ kk: int 2
[09:32:20.605]  - attr(*, "where")=List of 1
[09:32:20.605]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.605]  - attr(*, "resolved")= logi FALSE
[09:32:20.605]  - attr(*, "total_size")= num 56
[09:32:20.605]  - attr(*, "already-done")= logi TRUE
[09:32:20.609] - copied ‘kk’ to environment
[09:32:20.609] assign_globals() ... done
[09:32:20.609] requestCore(): workers = 2
[09:32:20.609] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.620] result() for MulticoreFuture ...
[09:32:20.621] result() for MulticoreFuture ...
[09:32:20.621] result() for MulticoreFuture ... done
[09:32:20.621] result() for MulticoreFuture ... done
[09:32:20.621] result() for MulticoreFuture ...
[09:32:20.621] result() for MulticoreFuture ... done
[09:32:20.624] MulticoreFuture started
[09:32:20.624] - Launch lazy future ... done
[09:32:20.624] run() for ‘MulticoreFuture’ ... done
[09:32:20.625] getGlobalsAndPackages() ...
[09:32:20.625] plan(): Setting new future strategy stack:
[09:32:20.625] Searching for globals...
[09:32:20.625] List of future strategies:
[09:32:20.625] 1. sequential:
[09:32:20.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.625]    - tweaked: FALSE
[09:32:20.625]    - call: NULL
[09:32:20.627] plan(): nbrOfWorkers() = 1
[09:32:20.628] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.628] Searching for globals ... DONE
[09:32:20.629] Resolving globals: FALSE
[09:32:20.629] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.630] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.630] - globals: [1] ‘kk’
[09:32:20.630] 
[09:32:20.630] getGlobalsAndPackages() ... DONE
[09:32:20.631] run() for ‘Future’ ...
[09:32:20.631] - state: ‘created’
[09:32:20.631] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.636] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.637]   - Field: ‘label’
[09:32:20.637]   - Field: ‘local’
[09:32:20.637]   - Field: ‘owner’
[09:32:20.637]   - Field: ‘envir’
[09:32:20.637]   - Field: ‘workers’
[09:32:20.637]   - Field: ‘packages’
[09:32:20.637]   - Field: ‘gc’
[09:32:20.638]   - Field: ‘job’
[09:32:20.638]   - Field: ‘conditions’
[09:32:20.638]   - Field: ‘expr’
[09:32:20.638]   - Field: ‘uuid’
[09:32:20.638]   - Field: ‘seed’
[09:32:20.638]   - Field: ‘version’
[09:32:20.639]   - Field: ‘result’
[09:32:20.639]   - Field: ‘asynchronous’
[09:32:20.639]   - Field: ‘calls’
[09:32:20.642]   - Field: ‘globals’
[09:32:20.643]   - Field: ‘stdout’
[09:32:20.643]   - Field: ‘earlySignal’
[09:32:20.643]   - Field: ‘lazy’
[09:32:20.644]   - Field: ‘state’
[09:32:20.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.644] - Launch lazy future ...
[09:32:20.645] Packages needed by the future expression (n = 0): <none>
[09:32:20.645] Packages needed by future strategies (n = 0): <none>
[09:32:20.647] {
[09:32:20.647]     {
[09:32:20.647]         {
[09:32:20.647]             ...future.startTime <- base::Sys.time()
[09:32:20.647]             {
[09:32:20.647]                 {
[09:32:20.647]                   {
[09:32:20.647]                     {
[09:32:20.647]                       base::local({
[09:32:20.647]                         has_future <- base::requireNamespace("future", 
[09:32:20.647]                           quietly = TRUE)
[09:32:20.647]                         if (has_future) {
[09:32:20.647]                           ns <- base::getNamespace("future")
[09:32:20.647]                           version <- ns[[".package"]][["version"]]
[09:32:20.647]                           if (is.null(version)) 
[09:32:20.647]                             version <- utils::packageVersion("future")
[09:32:20.647]                         }
[09:32:20.647]                         else {
[09:32:20.647]                           version <- NULL
[09:32:20.647]                         }
[09:32:20.647]                         if (!has_future || version < "1.8.0") {
[09:32:20.647]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.647]                             "", base::R.version$version.string), 
[09:32:20.647]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.647]                               "release", "version")], collapse = " "), 
[09:32:20.647]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.647]                             info)
[09:32:20.647]                           info <- base::paste(info, collapse = "; ")
[09:32:20.647]                           if (!has_future) {
[09:32:20.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.647]                               info)
[09:32:20.647]                           }
[09:32:20.647]                           else {
[09:32:20.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.647]                               info, version)
[09:32:20.647]                           }
[09:32:20.647]                           base::stop(msg)
[09:32:20.647]                         }
[09:32:20.647]                       })
[09:32:20.647]                     }
[09:32:20.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.647]                     base::options(mc.cores = 1L)
[09:32:20.647]                   }
[09:32:20.647]                   ...future.strategy.old <- future::plan("list")
[09:32:20.647]                   options(future.plan = NULL)
[09:32:20.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.647]                 }
[09:32:20.647]                 ...future.workdir <- getwd()
[09:32:20.647]             }
[09:32:20.647]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.647]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.647]         }
[09:32:20.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.647]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.647]             base::names(...future.oldOptions))
[09:32:20.647]     }
[09:32:20.647]     if (FALSE) {
[09:32:20.647]     }
[09:32:20.647]     else {
[09:32:20.647]         if (TRUE) {
[09:32:20.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.647]                 open = "w")
[09:32:20.647]         }
[09:32:20.647]         else {
[09:32:20.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.647]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.647]         }
[09:32:20.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.647]             base::sink(type = "output", split = FALSE)
[09:32:20.647]             base::close(...future.stdout)
[09:32:20.647]         }, add = TRUE)
[09:32:20.647]     }
[09:32:20.647]     ...future.frame <- base::sys.nframe()
[09:32:20.647]     ...future.conditions <- base::list()
[09:32:20.647]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.647]     if (FALSE) {
[09:32:20.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.647]     }
[09:32:20.647]     ...future.result <- base::tryCatch({
[09:32:20.647]         base::withCallingHandlers({
[09:32:20.647]             ...future.value <- base::withVisible(base::local({
[09:32:20.647]                 withCallingHandlers({
[09:32:20.647]                   {
[09:32:20.647]                     Sys.sleep(0.1)
[09:32:20.647]                     kk
[09:32:20.647]                   }
[09:32:20.647]                 }, immediateCondition = function(cond) {
[09:32:20.647]                   save_rds <- function (object, pathname, ...) 
[09:32:20.647]                   {
[09:32:20.647]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.647]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.647]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.647]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.647]                         fi_tmp[["mtime"]])
[09:32:20.647]                     }
[09:32:20.647]                     tryCatch({
[09:32:20.647]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.647]                     }, error = function(ex) {
[09:32:20.647]                       msg <- conditionMessage(ex)
[09:32:20.647]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.647]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.647]                         fi_tmp[["mtime"]], msg)
[09:32:20.647]                       ex$message <- msg
[09:32:20.647]                       stop(ex)
[09:32:20.647]                     })
[09:32:20.647]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.647]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.647]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.647]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.647]                       fi <- file.info(pathname)
[09:32:20.647]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.647]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.647]                         fi[["size"]], fi[["mtime"]])
[09:32:20.647]                       stop(msg)
[09:32:20.647]                     }
[09:32:20.647]                     invisible(pathname)
[09:32:20.647]                   }
[09:32:20.647]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.647]                     rootPath = tempdir()) 
[09:32:20.647]                   {
[09:32:20.647]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.647]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.647]                       tmpdir = path, fileext = ".rds")
[09:32:20.647]                     save_rds(obj, file)
[09:32:20.647]                   }
[09:32:20.647]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.647]                   {
[09:32:20.647]                     inherits <- base::inherits
[09:32:20.647]                     invokeRestart <- base::invokeRestart
[09:32:20.647]                     is.null <- base::is.null
[09:32:20.647]                     muffled <- FALSE
[09:32:20.647]                     if (inherits(cond, "message")) {
[09:32:20.647]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.647]                       if (muffled) 
[09:32:20.647]                         invokeRestart("muffleMessage")
[09:32:20.647]                     }
[09:32:20.647]                     else if (inherits(cond, "warning")) {
[09:32:20.647]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.647]                       if (muffled) 
[09:32:20.647]                         invokeRestart("muffleWarning")
[09:32:20.647]                     }
[09:32:20.647]                     else if (inherits(cond, "condition")) {
[09:32:20.647]                       if (!is.null(pattern)) {
[09:32:20.647]                         computeRestarts <- base::computeRestarts
[09:32:20.647]                         grepl <- base::grepl
[09:32:20.647]                         restarts <- computeRestarts(cond)
[09:32:20.647]                         for (restart in restarts) {
[09:32:20.647]                           name <- restart$name
[09:32:20.647]                           if (is.null(name)) 
[09:32:20.647]                             next
[09:32:20.647]                           if (!grepl(pattern, name)) 
[09:32:20.647]                             next
[09:32:20.647]                           invokeRestart(restart)
[09:32:20.647]                           muffled <- TRUE
[09:32:20.647]                           break
[09:32:20.647]                         }
[09:32:20.647]                       }
[09:32:20.647]                     }
[09:32:20.647]                     invisible(muffled)
[09:32:20.647]                   }
[09:32:20.647]                   muffleCondition(cond)
[09:32:20.647]                 })
[09:32:20.647]             }))
[09:32:20.647]             future::FutureResult(value = ...future.value$value, 
[09:32:20.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.647]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.647]                     ...future.globalenv.names))
[09:32:20.647]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.647]         }, condition = base::local({
[09:32:20.647]             c <- base::c
[09:32:20.647]             inherits <- base::inherits
[09:32:20.647]             invokeRestart <- base::invokeRestart
[09:32:20.647]             length <- base::length
[09:32:20.647]             list <- base::list
[09:32:20.647]             seq.int <- base::seq.int
[09:32:20.647]             signalCondition <- base::signalCondition
[09:32:20.647]             sys.calls <- base::sys.calls
[09:32:20.647]             `[[` <- base::`[[`
[09:32:20.647]             `+` <- base::`+`
[09:32:20.647]             `<<-` <- base::`<<-`
[09:32:20.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.647]                   3L)]
[09:32:20.647]             }
[09:32:20.647]             function(cond) {
[09:32:20.647]                 is_error <- inherits(cond, "error")
[09:32:20.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.647]                   NULL)
[09:32:20.647]                 if (is_error) {
[09:32:20.647]                   sessionInformation <- function() {
[09:32:20.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.647]                       search = base::search(), system = base::Sys.info())
[09:32:20.647]                   }
[09:32:20.647]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.647]                     cond$call), session = sessionInformation(), 
[09:32:20.647]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.647]                   signalCondition(cond)
[09:32:20.647]                 }
[09:32:20.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.647]                 "immediateCondition"))) {
[09:32:20.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.647]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.647]                   if (TRUE && !signal) {
[09:32:20.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.647]                     {
[09:32:20.647]                       inherits <- base::inherits
[09:32:20.647]                       invokeRestart <- base::invokeRestart
[09:32:20.647]                       is.null <- base::is.null
[09:32:20.647]                       muffled <- FALSE
[09:32:20.647]                       if (inherits(cond, "message")) {
[09:32:20.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.647]                         if (muffled) 
[09:32:20.647]                           invokeRestart("muffleMessage")
[09:32:20.647]                       }
[09:32:20.647]                       else if (inherits(cond, "warning")) {
[09:32:20.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.647]                         if (muffled) 
[09:32:20.647]                           invokeRestart("muffleWarning")
[09:32:20.647]                       }
[09:32:20.647]                       else if (inherits(cond, "condition")) {
[09:32:20.647]                         if (!is.null(pattern)) {
[09:32:20.647]                           computeRestarts <- base::computeRestarts
[09:32:20.647]                           grepl <- base::grepl
[09:32:20.647]                           restarts <- computeRestarts(cond)
[09:32:20.647]                           for (restart in restarts) {
[09:32:20.647]                             name <- restart$name
[09:32:20.647]                             if (is.null(name)) 
[09:32:20.647]                               next
[09:32:20.647]                             if (!grepl(pattern, name)) 
[09:32:20.647]                               next
[09:32:20.647]                             invokeRestart(restart)
[09:32:20.647]                             muffled <- TRUE
[09:32:20.647]                             break
[09:32:20.647]                           }
[09:32:20.647]                         }
[09:32:20.647]                       }
[09:32:20.647]                       invisible(muffled)
[09:32:20.647]                     }
[09:32:20.647]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.647]                   }
[09:32:20.647]                 }
[09:32:20.647]                 else {
[09:32:20.647]                   if (TRUE) {
[09:32:20.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.647]                     {
[09:32:20.647]                       inherits <- base::inherits
[09:32:20.647]                       invokeRestart <- base::invokeRestart
[09:32:20.647]                       is.null <- base::is.null
[09:32:20.647]                       muffled <- FALSE
[09:32:20.647]                       if (inherits(cond, "message")) {
[09:32:20.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.647]                         if (muffled) 
[09:32:20.647]                           invokeRestart("muffleMessage")
[09:32:20.647]                       }
[09:32:20.647]                       else if (inherits(cond, "warning")) {
[09:32:20.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.647]                         if (muffled) 
[09:32:20.647]                           invokeRestart("muffleWarning")
[09:32:20.647]                       }
[09:32:20.647]                       else if (inherits(cond, "condition")) {
[09:32:20.647]                         if (!is.null(pattern)) {
[09:32:20.647]                           computeRestarts <- base::computeRestarts
[09:32:20.647]                           grepl <- base::grepl
[09:32:20.647]                           restarts <- computeRestarts(cond)
[09:32:20.647]                           for (restart in restarts) {
[09:32:20.647]                             name <- restart$name
[09:32:20.647]                             if (is.null(name)) 
[09:32:20.647]                               next
[09:32:20.647]                             if (!grepl(pattern, name)) 
[09:32:20.647]                               next
[09:32:20.647]                             invokeRestart(restart)
[09:32:20.647]                             muffled <- TRUE
[09:32:20.647]                             break
[09:32:20.647]                           }
[09:32:20.647]                         }
[09:32:20.647]                       }
[09:32:20.647]                       invisible(muffled)
[09:32:20.647]                     }
[09:32:20.647]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.647]                   }
[09:32:20.647]                 }
[09:32:20.647]             }
[09:32:20.647]         }))
[09:32:20.647]     }, error = function(ex) {
[09:32:20.647]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.647]                 ...future.rng), started = ...future.startTime, 
[09:32:20.647]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.647]             version = "1.8"), class = "FutureResult")
[09:32:20.647]     }, finally = {
[09:32:20.647]         if (!identical(...future.workdir, getwd())) 
[09:32:20.647]             setwd(...future.workdir)
[09:32:20.647]         {
[09:32:20.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.647]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.647]             }
[09:32:20.647]             base::options(...future.oldOptions)
[09:32:20.647]             if (.Platform$OS.type == "windows") {
[09:32:20.647]                 old_names <- names(...future.oldEnvVars)
[09:32:20.647]                 envs <- base::Sys.getenv()
[09:32:20.647]                 names <- names(envs)
[09:32:20.647]                 common <- intersect(names, old_names)
[09:32:20.647]                 added <- setdiff(names, old_names)
[09:32:20.647]                 removed <- setdiff(old_names, names)
[09:32:20.647]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.647]                   envs[common]]
[09:32:20.647]                 NAMES <- toupper(changed)
[09:32:20.647]                 args <- list()
[09:32:20.647]                 for (kk in seq_along(NAMES)) {
[09:32:20.647]                   name <- changed[[kk]]
[09:32:20.647]                   NAME <- NAMES[[kk]]
[09:32:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.647]                     next
[09:32:20.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.647]                 }
[09:32:20.647]                 NAMES <- toupper(added)
[09:32:20.647]                 for (kk in seq_along(NAMES)) {
[09:32:20.647]                   name <- added[[kk]]
[09:32:20.647]                   NAME <- NAMES[[kk]]
[09:32:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.647]                     next
[09:32:20.647]                   args[[name]] <- ""
[09:32:20.647]                 }
[09:32:20.647]                 NAMES <- toupper(removed)
[09:32:20.647]                 for (kk in seq_along(NAMES)) {
[09:32:20.647]                   name <- removed[[kk]]
[09:32:20.647]                   NAME <- NAMES[[kk]]
[09:32:20.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.647]                     next
[09:32:20.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.647]                 }
[09:32:20.647]                 if (length(args) > 0) 
[09:32:20.647]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.647]             }
[09:32:20.647]             else {
[09:32:20.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.647]             }
[09:32:20.647]             {
[09:32:20.647]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.647]                   0L) {
[09:32:20.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.647]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.647]                   base::options(opts)
[09:32:20.647]                 }
[09:32:20.647]                 {
[09:32:20.647]                   {
[09:32:20.647]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.647]                     NULL
[09:32:20.647]                   }
[09:32:20.647]                   options(future.plan = NULL)
[09:32:20.647]                   if (is.na(NA_character_)) 
[09:32:20.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.647]                     .init = FALSE)
[09:32:20.647]                 }
[09:32:20.647]             }
[09:32:20.647]         }
[09:32:20.647]     })
[09:32:20.647]     if (TRUE) {
[09:32:20.647]         base::sink(type = "output", split = FALSE)
[09:32:20.647]         if (TRUE) {
[09:32:20.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.647]         }
[09:32:20.647]         else {
[09:32:20.647]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.647]         }
[09:32:20.647]         base::close(...future.stdout)
[09:32:20.647]         ...future.stdout <- NULL
[09:32:20.647]     }
[09:32:20.647]     ...future.result$conditions <- ...future.conditions
[09:32:20.647]     ...future.result$finished <- base::Sys.time()
[09:32:20.647]     ...future.result
[09:32:20.647] }
[09:32:20.649] assign_globals() ...
[09:32:20.649] List of 1
[09:32:20.649]  $ kk: int 3
[09:32:20.649]  - attr(*, "where")=List of 1
[09:32:20.649]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.649]  - attr(*, "resolved")= logi FALSE
[09:32:20.649]  - attr(*, "total_size")= num 56
[09:32:20.649]  - attr(*, "already-done")= logi TRUE
[09:32:20.653] - copied ‘kk’ to environment
[09:32:20.654] assign_globals() ... done
[09:32:20.654] requestCore(): workers = 2
[09:32:20.654] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.685] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[09:32:20.689] plan(): Setting new future strategy stack:
[09:32:20.689] List of future strategies:
[09:32:20.689] 1. multicore:
[09:32:20.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:20.689]    - tweaked: FALSE
[09:32:20.689]    - call: plan(strategy)
[09:32:20.694] plan(): nbrOfWorkers() = 2
[09:32:20.696] result() for MulticoreFuture ...
[09:32:20.697] result() for MulticoreFuture ...
[09:32:20.697] result() for MulticoreFuture ... done
[09:32:20.697] result() for MulticoreFuture ... done
[09:32:20.697] result() for MulticoreFuture ...
[09:32:20.698] result() for MulticoreFuture ... done
[09:32:20.700] MulticoreFuture started
[09:32:20.701] - Launch lazy future ... done
[09:32:20.701] run() for ‘MulticoreFuture’ ... done
[09:32:20.701] resolve() on list ...
[09:32:20.701] plan(): Setting new future strategy stack:
[09:32:20.701]  recursive: 0
[09:32:20.702]  length: 3
[09:32:20.702] 
[09:32:20.702] Future #1
[09:32:20.702]  length: 2 (resolved future 1)
[09:32:20.702] List of future strategies:
[09:32:20.702] 1. sequential:
[09:32:20.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.702]    - tweaked: FALSE
[09:32:20.702]    - call: NULL
[09:32:20.703] plan(): nbrOfWorkers() = 1
[09:32:20.729] plan(): Setting new future strategy stack:
[09:32:20.729] List of future strategies:
[09:32:20.729] 1. multicore:
[09:32:20.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:20.729]    - tweaked: FALSE
[09:32:20.729]    - call: plan(strategy)
[09:32:20.734] plan(): nbrOfWorkers() = 2
[09:32:20.734] Future #2
[09:32:20.734]  length: 1 (resolved future 2)
[09:32:20.805] plan(): Setting new future strategy stack:
[09:32:20.805] List of future strategies:
[09:32:20.805] 1. multicore:
[09:32:20.805]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:20.805]    - tweaked: FALSE
[09:32:20.805]    - call: plan(strategy)
[09:32:20.810] plan(): nbrOfWorkers() = 2
[09:32:20.816] Future #3
[09:32:20.816]  length: 0 (resolved future 3)
[09:32:20.816] resolve() on list ... DONE
[09:32:20.817] getGlobalsAndPackages() ...
[09:32:20.817] Searching for globals...
[09:32:20.819] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.819] Searching for globals ... DONE
[09:32:20.819] Resolving globals: FALSE
[09:32:20.820] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.821] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.821] - globals: [1] ‘kk’
[09:32:20.821] 
[09:32:20.821] getGlobalsAndPackages() ... DONE
[09:32:20.822] getGlobalsAndPackages() ...
[09:32:20.822] Searching for globals...
[09:32:20.823] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.824] Searching for globals ... DONE
[09:32:20.824] Resolving globals: FALSE
[09:32:20.824] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.825] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.825] - globals: [1] ‘kk’
[09:32:20.825] 
[09:32:20.825] getGlobalsAndPackages() ... DONE
[09:32:20.825] getGlobalsAndPackages() ...
[09:32:20.826] Searching for globals...
[09:32:20.827] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:20.827] Searching for globals ... DONE
[09:32:20.827] Resolving globals: FALSE
[09:32:20.828] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:20.828] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:20.828] - globals: [1] ‘kk’
[09:32:20.829] 
[09:32:20.829] getGlobalsAndPackages() ... DONE
[09:32:20.829] resolve() on list ...
[09:32:20.829]  recursive: 0
[09:32:20.829]  length: 3
[09:32:20.829] 
[09:32:20.830] run() for ‘Future’ ...
[09:32:20.830] - state: ‘created’
[09:32:20.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.834] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.835]   - Field: ‘label’
[09:32:20.835]   - Field: ‘local’
[09:32:20.835]   - Field: ‘owner’
[09:32:20.835]   - Field: ‘envir’
[09:32:20.835]   - Field: ‘workers’
[09:32:20.835]   - Field: ‘packages’
[09:32:20.835]   - Field: ‘gc’
[09:32:20.836]   - Field: ‘job’
[09:32:20.836]   - Field: ‘conditions’
[09:32:20.836]   - Field: ‘expr’
[09:32:20.836]   - Field: ‘uuid’
[09:32:20.836]   - Field: ‘seed’
[09:32:20.836]   - Field: ‘version’
[09:32:20.836]   - Field: ‘result’
[09:32:20.837]   - Field: ‘asynchronous’
[09:32:20.837]   - Field: ‘calls’
[09:32:20.837]   - Field: ‘globals’
[09:32:20.837]   - Field: ‘stdout’
[09:32:20.837]   - Field: ‘earlySignal’
[09:32:20.837]   - Field: ‘lazy’
[09:32:20.837]   - Field: ‘state’
[09:32:20.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.838] - Launch lazy future ...
[09:32:20.838] Packages needed by the future expression (n = 0): <none>
[09:32:20.838] Packages needed by future strategies (n = 0): <none>
[09:32:20.839] {
[09:32:20.839]     {
[09:32:20.839]         {
[09:32:20.839]             ...future.startTime <- base::Sys.time()
[09:32:20.839]             {
[09:32:20.839]                 {
[09:32:20.839]                   {
[09:32:20.839]                     {
[09:32:20.839]                       base::local({
[09:32:20.839]                         has_future <- base::requireNamespace("future", 
[09:32:20.839]                           quietly = TRUE)
[09:32:20.839]                         if (has_future) {
[09:32:20.839]                           ns <- base::getNamespace("future")
[09:32:20.839]                           version <- ns[[".package"]][["version"]]
[09:32:20.839]                           if (is.null(version)) 
[09:32:20.839]                             version <- utils::packageVersion("future")
[09:32:20.839]                         }
[09:32:20.839]                         else {
[09:32:20.839]                           version <- NULL
[09:32:20.839]                         }
[09:32:20.839]                         if (!has_future || version < "1.8.0") {
[09:32:20.839]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.839]                             "", base::R.version$version.string), 
[09:32:20.839]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.839]                               "release", "version")], collapse = " "), 
[09:32:20.839]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.839]                             info)
[09:32:20.839]                           info <- base::paste(info, collapse = "; ")
[09:32:20.839]                           if (!has_future) {
[09:32:20.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.839]                               info)
[09:32:20.839]                           }
[09:32:20.839]                           else {
[09:32:20.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.839]                               info, version)
[09:32:20.839]                           }
[09:32:20.839]                           base::stop(msg)
[09:32:20.839]                         }
[09:32:20.839]                       })
[09:32:20.839]                     }
[09:32:20.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.839]                     base::options(mc.cores = 1L)
[09:32:20.839]                   }
[09:32:20.839]                   ...future.strategy.old <- future::plan("list")
[09:32:20.839]                   options(future.plan = NULL)
[09:32:20.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.839]                 }
[09:32:20.839]                 ...future.workdir <- getwd()
[09:32:20.839]             }
[09:32:20.839]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.839]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.839]         }
[09:32:20.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.839]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.839]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.839]             base::names(...future.oldOptions))
[09:32:20.839]     }
[09:32:20.839]     if (FALSE) {
[09:32:20.839]     }
[09:32:20.839]     else {
[09:32:20.839]         if (TRUE) {
[09:32:20.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.839]                 open = "w")
[09:32:20.839]         }
[09:32:20.839]         else {
[09:32:20.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.839]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.839]         }
[09:32:20.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.839]             base::sink(type = "output", split = FALSE)
[09:32:20.839]             base::close(...future.stdout)
[09:32:20.839]         }, add = TRUE)
[09:32:20.839]     }
[09:32:20.839]     ...future.frame <- base::sys.nframe()
[09:32:20.839]     ...future.conditions <- base::list()
[09:32:20.839]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.839]     if (FALSE) {
[09:32:20.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.839]     }
[09:32:20.839]     ...future.result <- base::tryCatch({
[09:32:20.839]         base::withCallingHandlers({
[09:32:20.839]             ...future.value <- base::withVisible(base::local({
[09:32:20.839]                 withCallingHandlers({
[09:32:20.839]                   {
[09:32:20.839]                     Sys.sleep(0.1)
[09:32:20.839]                     kk
[09:32:20.839]                   }
[09:32:20.839]                 }, immediateCondition = function(cond) {
[09:32:20.839]                   save_rds <- function (object, pathname, ...) 
[09:32:20.839]                   {
[09:32:20.839]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.839]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.839]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.839]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.839]                         fi_tmp[["mtime"]])
[09:32:20.839]                     }
[09:32:20.839]                     tryCatch({
[09:32:20.839]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.839]                     }, error = function(ex) {
[09:32:20.839]                       msg <- conditionMessage(ex)
[09:32:20.839]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.839]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.839]                         fi_tmp[["mtime"]], msg)
[09:32:20.839]                       ex$message <- msg
[09:32:20.839]                       stop(ex)
[09:32:20.839]                     })
[09:32:20.839]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.839]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.839]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.839]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.839]                       fi <- file.info(pathname)
[09:32:20.839]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.839]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.839]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.839]                         fi[["size"]], fi[["mtime"]])
[09:32:20.839]                       stop(msg)
[09:32:20.839]                     }
[09:32:20.839]                     invisible(pathname)
[09:32:20.839]                   }
[09:32:20.839]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.839]                     rootPath = tempdir()) 
[09:32:20.839]                   {
[09:32:20.839]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.839]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.839]                       tmpdir = path, fileext = ".rds")
[09:32:20.839]                     save_rds(obj, file)
[09:32:20.839]                   }
[09:32:20.839]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.839]                   {
[09:32:20.839]                     inherits <- base::inherits
[09:32:20.839]                     invokeRestart <- base::invokeRestart
[09:32:20.839]                     is.null <- base::is.null
[09:32:20.839]                     muffled <- FALSE
[09:32:20.839]                     if (inherits(cond, "message")) {
[09:32:20.839]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.839]                       if (muffled) 
[09:32:20.839]                         invokeRestart("muffleMessage")
[09:32:20.839]                     }
[09:32:20.839]                     else if (inherits(cond, "warning")) {
[09:32:20.839]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.839]                       if (muffled) 
[09:32:20.839]                         invokeRestart("muffleWarning")
[09:32:20.839]                     }
[09:32:20.839]                     else if (inherits(cond, "condition")) {
[09:32:20.839]                       if (!is.null(pattern)) {
[09:32:20.839]                         computeRestarts <- base::computeRestarts
[09:32:20.839]                         grepl <- base::grepl
[09:32:20.839]                         restarts <- computeRestarts(cond)
[09:32:20.839]                         for (restart in restarts) {
[09:32:20.839]                           name <- restart$name
[09:32:20.839]                           if (is.null(name)) 
[09:32:20.839]                             next
[09:32:20.839]                           if (!grepl(pattern, name)) 
[09:32:20.839]                             next
[09:32:20.839]                           invokeRestart(restart)
[09:32:20.839]                           muffled <- TRUE
[09:32:20.839]                           break
[09:32:20.839]                         }
[09:32:20.839]                       }
[09:32:20.839]                     }
[09:32:20.839]                     invisible(muffled)
[09:32:20.839]                   }
[09:32:20.839]                   muffleCondition(cond)
[09:32:20.839]                 })
[09:32:20.839]             }))
[09:32:20.839]             future::FutureResult(value = ...future.value$value, 
[09:32:20.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.839]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.839]                     ...future.globalenv.names))
[09:32:20.839]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.839]         }, condition = base::local({
[09:32:20.839]             c <- base::c
[09:32:20.839]             inherits <- base::inherits
[09:32:20.839]             invokeRestart <- base::invokeRestart
[09:32:20.839]             length <- base::length
[09:32:20.839]             list <- base::list
[09:32:20.839]             seq.int <- base::seq.int
[09:32:20.839]             signalCondition <- base::signalCondition
[09:32:20.839]             sys.calls <- base::sys.calls
[09:32:20.839]             `[[` <- base::`[[`
[09:32:20.839]             `+` <- base::`+`
[09:32:20.839]             `<<-` <- base::`<<-`
[09:32:20.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.839]                   3L)]
[09:32:20.839]             }
[09:32:20.839]             function(cond) {
[09:32:20.839]                 is_error <- inherits(cond, "error")
[09:32:20.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.839]                   NULL)
[09:32:20.839]                 if (is_error) {
[09:32:20.839]                   sessionInformation <- function() {
[09:32:20.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.839]                       search = base::search(), system = base::Sys.info())
[09:32:20.839]                   }
[09:32:20.839]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.839]                     cond$call), session = sessionInformation(), 
[09:32:20.839]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.839]                   signalCondition(cond)
[09:32:20.839]                 }
[09:32:20.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.839]                 "immediateCondition"))) {
[09:32:20.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.839]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.839]                   if (TRUE && !signal) {
[09:32:20.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.839]                     {
[09:32:20.839]                       inherits <- base::inherits
[09:32:20.839]                       invokeRestart <- base::invokeRestart
[09:32:20.839]                       is.null <- base::is.null
[09:32:20.839]                       muffled <- FALSE
[09:32:20.839]                       if (inherits(cond, "message")) {
[09:32:20.839]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.839]                         if (muffled) 
[09:32:20.839]                           invokeRestart("muffleMessage")
[09:32:20.839]                       }
[09:32:20.839]                       else if (inherits(cond, "warning")) {
[09:32:20.839]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.839]                         if (muffled) 
[09:32:20.839]                           invokeRestart("muffleWarning")
[09:32:20.839]                       }
[09:32:20.839]                       else if (inherits(cond, "condition")) {
[09:32:20.839]                         if (!is.null(pattern)) {
[09:32:20.839]                           computeRestarts <- base::computeRestarts
[09:32:20.839]                           grepl <- base::grepl
[09:32:20.839]                           restarts <- computeRestarts(cond)
[09:32:20.839]                           for (restart in restarts) {
[09:32:20.839]                             name <- restart$name
[09:32:20.839]                             if (is.null(name)) 
[09:32:20.839]                               next
[09:32:20.839]                             if (!grepl(pattern, name)) 
[09:32:20.839]                               next
[09:32:20.839]                             invokeRestart(restart)
[09:32:20.839]                             muffled <- TRUE
[09:32:20.839]                             break
[09:32:20.839]                           }
[09:32:20.839]                         }
[09:32:20.839]                       }
[09:32:20.839]                       invisible(muffled)
[09:32:20.839]                     }
[09:32:20.839]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.839]                   }
[09:32:20.839]                 }
[09:32:20.839]                 else {
[09:32:20.839]                   if (TRUE) {
[09:32:20.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.839]                     {
[09:32:20.839]                       inherits <- base::inherits
[09:32:20.839]                       invokeRestart <- base::invokeRestart
[09:32:20.839]                       is.null <- base::is.null
[09:32:20.839]                       muffled <- FALSE
[09:32:20.839]                       if (inherits(cond, "message")) {
[09:32:20.839]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.839]                         if (muffled) 
[09:32:20.839]                           invokeRestart("muffleMessage")
[09:32:20.839]                       }
[09:32:20.839]                       else if (inherits(cond, "warning")) {
[09:32:20.839]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.839]                         if (muffled) 
[09:32:20.839]                           invokeRestart("muffleWarning")
[09:32:20.839]                       }
[09:32:20.839]                       else if (inherits(cond, "condition")) {
[09:32:20.839]                         if (!is.null(pattern)) {
[09:32:20.839]                           computeRestarts <- base::computeRestarts
[09:32:20.839]                           grepl <- base::grepl
[09:32:20.839]                           restarts <- computeRestarts(cond)
[09:32:20.839]                           for (restart in restarts) {
[09:32:20.839]                             name <- restart$name
[09:32:20.839]                             if (is.null(name)) 
[09:32:20.839]                               next
[09:32:20.839]                             if (!grepl(pattern, name)) 
[09:32:20.839]                               next
[09:32:20.839]                             invokeRestart(restart)
[09:32:20.839]                             muffled <- TRUE
[09:32:20.839]                             break
[09:32:20.839]                           }
[09:32:20.839]                         }
[09:32:20.839]                       }
[09:32:20.839]                       invisible(muffled)
[09:32:20.839]                     }
[09:32:20.839]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.839]                   }
[09:32:20.839]                 }
[09:32:20.839]             }
[09:32:20.839]         }))
[09:32:20.839]     }, error = function(ex) {
[09:32:20.839]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.839]                 ...future.rng), started = ...future.startTime, 
[09:32:20.839]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.839]             version = "1.8"), class = "FutureResult")
[09:32:20.839]     }, finally = {
[09:32:20.839]         if (!identical(...future.workdir, getwd())) 
[09:32:20.839]             setwd(...future.workdir)
[09:32:20.839]         {
[09:32:20.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.839]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.839]             }
[09:32:20.839]             base::options(...future.oldOptions)
[09:32:20.839]             if (.Platform$OS.type == "windows") {
[09:32:20.839]                 old_names <- names(...future.oldEnvVars)
[09:32:20.839]                 envs <- base::Sys.getenv()
[09:32:20.839]                 names <- names(envs)
[09:32:20.839]                 common <- intersect(names, old_names)
[09:32:20.839]                 added <- setdiff(names, old_names)
[09:32:20.839]                 removed <- setdiff(old_names, names)
[09:32:20.839]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.839]                   envs[common]]
[09:32:20.839]                 NAMES <- toupper(changed)
[09:32:20.839]                 args <- list()
[09:32:20.839]                 for (kk in seq_along(NAMES)) {
[09:32:20.839]                   name <- changed[[kk]]
[09:32:20.839]                   NAME <- NAMES[[kk]]
[09:32:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.839]                     next
[09:32:20.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.839]                 }
[09:32:20.839]                 NAMES <- toupper(added)
[09:32:20.839]                 for (kk in seq_along(NAMES)) {
[09:32:20.839]                   name <- added[[kk]]
[09:32:20.839]                   NAME <- NAMES[[kk]]
[09:32:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.839]                     next
[09:32:20.839]                   args[[name]] <- ""
[09:32:20.839]                 }
[09:32:20.839]                 NAMES <- toupper(removed)
[09:32:20.839]                 for (kk in seq_along(NAMES)) {
[09:32:20.839]                   name <- removed[[kk]]
[09:32:20.839]                   NAME <- NAMES[[kk]]
[09:32:20.839]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.839]                     next
[09:32:20.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.839]                 }
[09:32:20.839]                 if (length(args) > 0) 
[09:32:20.839]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.839]             }
[09:32:20.839]             else {
[09:32:20.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.839]             }
[09:32:20.839]             {
[09:32:20.839]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.839]                   0L) {
[09:32:20.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.839]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.839]                   base::options(opts)
[09:32:20.839]                 }
[09:32:20.839]                 {
[09:32:20.839]                   {
[09:32:20.839]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.839]                     NULL
[09:32:20.839]                   }
[09:32:20.839]                   options(future.plan = NULL)
[09:32:20.839]                   if (is.na(NA_character_)) 
[09:32:20.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.839]                     .init = FALSE)
[09:32:20.839]                 }
[09:32:20.839]             }
[09:32:20.839]         }
[09:32:20.839]     })
[09:32:20.839]     if (TRUE) {
[09:32:20.839]         base::sink(type = "output", split = FALSE)
[09:32:20.839]         if (TRUE) {
[09:32:20.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.839]         }
[09:32:20.839]         else {
[09:32:20.839]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.839]         }
[09:32:20.839]         base::close(...future.stdout)
[09:32:20.839]         ...future.stdout <- NULL
[09:32:20.839]     }
[09:32:20.839]     ...future.result$conditions <- ...future.conditions
[09:32:20.839]     ...future.result$finished <- base::Sys.time()
[09:32:20.839]     ...future.result
[09:32:20.839] }
[09:32:20.842] assign_globals() ...
[09:32:20.842] List of 1
[09:32:20.842]  $ kk: int 1
[09:32:20.842]  - attr(*, "where")=List of 1
[09:32:20.842]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.842]  - attr(*, "resolved")= logi FALSE
[09:32:20.842]  - attr(*, "total_size")= num 56
[09:32:20.842]  - attr(*, "already-done")= logi TRUE
[09:32:20.846] - copied ‘kk’ to environment
[09:32:20.846] assign_globals() ... done
[09:32:20.848] requestCore(): workers = 2
[09:32:20.849] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.860] result() for MulticoreFuture ...
[09:32:20.861] result() for MulticoreFuture ...
[09:32:20.861] result() for MulticoreFuture ... done
[09:32:20.861] result() for MulticoreFuture ... done
[09:32:20.861] result() for MulticoreFuture ...
[09:32:20.862] result() for MulticoreFuture ... done
[09:32:20.865] MulticoreFuture started
[09:32:20.865] - Launch lazy future ... done
[09:32:20.866] run() for ‘MulticoreFuture’ ... done
[09:32:20.866] plan(): Setting new future strategy stack:
[09:32:20.866] List of future strategies:
[09:32:20.866] 1. sequential:
[09:32:20.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.866]    - tweaked: FALSE
[09:32:20.866]    - call: NULL
[09:32:20.868] plan(): nbrOfWorkers() = 1
[09:32:20.877] run() for ‘Future’ ...
[09:32:20.877] - state: ‘created’
[09:32:20.877] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.883] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.884]   - Field: ‘label’
[09:32:20.884]   - Field: ‘local’
[09:32:20.884]   - Field: ‘owner’
[09:32:20.884]   - Field: ‘envir’
[09:32:20.884]   - Field: ‘workers’
[09:32:20.884]   - Field: ‘packages’
[09:32:20.885]   - Field: ‘gc’
[09:32:20.885]   - Field: ‘job’
[09:32:20.885]   - Field: ‘conditions’
[09:32:20.885]   - Field: ‘expr’
[09:32:20.885]   - Field: ‘uuid’
[09:32:20.885]   - Field: ‘seed’
[09:32:20.886]   - Field: ‘version’
[09:32:20.886]   - Field: ‘result’
[09:32:20.886]   - Field: ‘asynchronous’
[09:32:20.886]   - Field: ‘calls’
[09:32:20.886]   - Field: ‘globals’
[09:32:20.886]   - Field: ‘stdout’
[09:32:20.887]   - Field: ‘earlySignal’
[09:32:20.887]   - Field: ‘lazy’
[09:32:20.887]   - Field: ‘state’
[09:32:20.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.887] - Launch lazy future ...
[09:32:20.888] Packages needed by the future expression (n = 0): <none>
[09:32:20.888] Packages needed by future strategies (n = 0): <none>
[09:32:20.889] {
[09:32:20.889]     {
[09:32:20.889]         {
[09:32:20.889]             ...future.startTime <- base::Sys.time()
[09:32:20.889]             {
[09:32:20.889]                 {
[09:32:20.889]                   {
[09:32:20.889]                     {
[09:32:20.889]                       base::local({
[09:32:20.889]                         has_future <- base::requireNamespace("future", 
[09:32:20.889]                           quietly = TRUE)
[09:32:20.889]                         if (has_future) {
[09:32:20.889]                           ns <- base::getNamespace("future")
[09:32:20.889]                           version <- ns[[".package"]][["version"]]
[09:32:20.889]                           if (is.null(version)) 
[09:32:20.889]                             version <- utils::packageVersion("future")
[09:32:20.889]                         }
[09:32:20.889]                         else {
[09:32:20.889]                           version <- NULL
[09:32:20.889]                         }
[09:32:20.889]                         if (!has_future || version < "1.8.0") {
[09:32:20.889]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.889]                             "", base::R.version$version.string), 
[09:32:20.889]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.889]                               "release", "version")], collapse = " "), 
[09:32:20.889]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.889]                             info)
[09:32:20.889]                           info <- base::paste(info, collapse = "; ")
[09:32:20.889]                           if (!has_future) {
[09:32:20.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.889]                               info)
[09:32:20.889]                           }
[09:32:20.889]                           else {
[09:32:20.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.889]                               info, version)
[09:32:20.889]                           }
[09:32:20.889]                           base::stop(msg)
[09:32:20.889]                         }
[09:32:20.889]                       })
[09:32:20.889]                     }
[09:32:20.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.889]                     base::options(mc.cores = 1L)
[09:32:20.889]                   }
[09:32:20.889]                   ...future.strategy.old <- future::plan("list")
[09:32:20.889]                   options(future.plan = NULL)
[09:32:20.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.889]                 }
[09:32:20.889]                 ...future.workdir <- getwd()
[09:32:20.889]             }
[09:32:20.889]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.889]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.889]         }
[09:32:20.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.889]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.889]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.889]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.889]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.889]             base::names(...future.oldOptions))
[09:32:20.889]     }
[09:32:20.889]     if (FALSE) {
[09:32:20.889]     }
[09:32:20.889]     else {
[09:32:20.889]         if (TRUE) {
[09:32:20.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.889]                 open = "w")
[09:32:20.889]         }
[09:32:20.889]         else {
[09:32:20.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.889]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.889]         }
[09:32:20.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.889]             base::sink(type = "output", split = FALSE)
[09:32:20.889]             base::close(...future.stdout)
[09:32:20.889]         }, add = TRUE)
[09:32:20.889]     }
[09:32:20.889]     ...future.frame <- base::sys.nframe()
[09:32:20.889]     ...future.conditions <- base::list()
[09:32:20.889]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.889]     if (FALSE) {
[09:32:20.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.889]     }
[09:32:20.889]     ...future.result <- base::tryCatch({
[09:32:20.889]         base::withCallingHandlers({
[09:32:20.889]             ...future.value <- base::withVisible(base::local({
[09:32:20.889]                 withCallingHandlers({
[09:32:20.889]                   {
[09:32:20.889]                     Sys.sleep(0.1)
[09:32:20.889]                     kk
[09:32:20.889]                   }
[09:32:20.889]                 }, immediateCondition = function(cond) {
[09:32:20.889]                   save_rds <- function (object, pathname, ...) 
[09:32:20.889]                   {
[09:32:20.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.889]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.889]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.889]                         fi_tmp[["mtime"]])
[09:32:20.889]                     }
[09:32:20.889]                     tryCatch({
[09:32:20.889]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.889]                     }, error = function(ex) {
[09:32:20.889]                       msg <- conditionMessage(ex)
[09:32:20.889]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.889]                         fi_tmp[["mtime"]], msg)
[09:32:20.889]                       ex$message <- msg
[09:32:20.889]                       stop(ex)
[09:32:20.889]                     })
[09:32:20.889]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.889]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.889]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.889]                       fi <- file.info(pathname)
[09:32:20.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.889]                         fi[["size"]], fi[["mtime"]])
[09:32:20.889]                       stop(msg)
[09:32:20.889]                     }
[09:32:20.889]                     invisible(pathname)
[09:32:20.889]                   }
[09:32:20.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.889]                     rootPath = tempdir()) 
[09:32:20.889]                   {
[09:32:20.889]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.889]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.889]                       tmpdir = path, fileext = ".rds")
[09:32:20.889]                     save_rds(obj, file)
[09:32:20.889]                   }
[09:32:20.889]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.889]                   {
[09:32:20.889]                     inherits <- base::inherits
[09:32:20.889]                     invokeRestart <- base::invokeRestart
[09:32:20.889]                     is.null <- base::is.null
[09:32:20.889]                     muffled <- FALSE
[09:32:20.889]                     if (inherits(cond, "message")) {
[09:32:20.889]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.889]                       if (muffled) 
[09:32:20.889]                         invokeRestart("muffleMessage")
[09:32:20.889]                     }
[09:32:20.889]                     else if (inherits(cond, "warning")) {
[09:32:20.889]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.889]                       if (muffled) 
[09:32:20.889]                         invokeRestart("muffleWarning")
[09:32:20.889]                     }
[09:32:20.889]                     else if (inherits(cond, "condition")) {
[09:32:20.889]                       if (!is.null(pattern)) {
[09:32:20.889]                         computeRestarts <- base::computeRestarts
[09:32:20.889]                         grepl <- base::grepl
[09:32:20.889]                         restarts <- computeRestarts(cond)
[09:32:20.889]                         for (restart in restarts) {
[09:32:20.889]                           name <- restart$name
[09:32:20.889]                           if (is.null(name)) 
[09:32:20.889]                             next
[09:32:20.889]                           if (!grepl(pattern, name)) 
[09:32:20.889]                             next
[09:32:20.889]                           invokeRestart(restart)
[09:32:20.889]                           muffled <- TRUE
[09:32:20.889]                           break
[09:32:20.889]                         }
[09:32:20.889]                       }
[09:32:20.889]                     }
[09:32:20.889]                     invisible(muffled)
[09:32:20.889]                   }
[09:32:20.889]                   muffleCondition(cond)
[09:32:20.889]                 })
[09:32:20.889]             }))
[09:32:20.889]             future::FutureResult(value = ...future.value$value, 
[09:32:20.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.889]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.889]                     ...future.globalenv.names))
[09:32:20.889]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.889]         }, condition = base::local({
[09:32:20.889]             c <- base::c
[09:32:20.889]             inherits <- base::inherits
[09:32:20.889]             invokeRestart <- base::invokeRestart
[09:32:20.889]             length <- base::length
[09:32:20.889]             list <- base::list
[09:32:20.889]             seq.int <- base::seq.int
[09:32:20.889]             signalCondition <- base::signalCondition
[09:32:20.889]             sys.calls <- base::sys.calls
[09:32:20.889]             `[[` <- base::`[[`
[09:32:20.889]             `+` <- base::`+`
[09:32:20.889]             `<<-` <- base::`<<-`
[09:32:20.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.889]                   3L)]
[09:32:20.889]             }
[09:32:20.889]             function(cond) {
[09:32:20.889]                 is_error <- inherits(cond, "error")
[09:32:20.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.889]                   NULL)
[09:32:20.889]                 if (is_error) {
[09:32:20.889]                   sessionInformation <- function() {
[09:32:20.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.889]                       search = base::search(), system = base::Sys.info())
[09:32:20.889]                   }
[09:32:20.889]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.889]                     cond$call), session = sessionInformation(), 
[09:32:20.889]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.889]                   signalCondition(cond)
[09:32:20.889]                 }
[09:32:20.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.889]                 "immediateCondition"))) {
[09:32:20.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.889]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.889]                   if (TRUE && !signal) {
[09:32:20.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.889]                     {
[09:32:20.889]                       inherits <- base::inherits
[09:32:20.889]                       invokeRestart <- base::invokeRestart
[09:32:20.889]                       is.null <- base::is.null
[09:32:20.889]                       muffled <- FALSE
[09:32:20.889]                       if (inherits(cond, "message")) {
[09:32:20.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.889]                         if (muffled) 
[09:32:20.889]                           invokeRestart("muffleMessage")
[09:32:20.889]                       }
[09:32:20.889]                       else if (inherits(cond, "warning")) {
[09:32:20.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.889]                         if (muffled) 
[09:32:20.889]                           invokeRestart("muffleWarning")
[09:32:20.889]                       }
[09:32:20.889]                       else if (inherits(cond, "condition")) {
[09:32:20.889]                         if (!is.null(pattern)) {
[09:32:20.889]                           computeRestarts <- base::computeRestarts
[09:32:20.889]                           grepl <- base::grepl
[09:32:20.889]                           restarts <- computeRestarts(cond)
[09:32:20.889]                           for (restart in restarts) {
[09:32:20.889]                             name <- restart$name
[09:32:20.889]                             if (is.null(name)) 
[09:32:20.889]                               next
[09:32:20.889]                             if (!grepl(pattern, name)) 
[09:32:20.889]                               next
[09:32:20.889]                             invokeRestart(restart)
[09:32:20.889]                             muffled <- TRUE
[09:32:20.889]                             break
[09:32:20.889]                           }
[09:32:20.889]                         }
[09:32:20.889]                       }
[09:32:20.889]                       invisible(muffled)
[09:32:20.889]                     }
[09:32:20.889]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.889]                   }
[09:32:20.889]                 }
[09:32:20.889]                 else {
[09:32:20.889]                   if (TRUE) {
[09:32:20.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.889]                     {
[09:32:20.889]                       inherits <- base::inherits
[09:32:20.889]                       invokeRestart <- base::invokeRestart
[09:32:20.889]                       is.null <- base::is.null
[09:32:20.889]                       muffled <- FALSE
[09:32:20.889]                       if (inherits(cond, "message")) {
[09:32:20.889]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.889]                         if (muffled) 
[09:32:20.889]                           invokeRestart("muffleMessage")
[09:32:20.889]                       }
[09:32:20.889]                       else if (inherits(cond, "warning")) {
[09:32:20.889]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.889]                         if (muffled) 
[09:32:20.889]                           invokeRestart("muffleWarning")
[09:32:20.889]                       }
[09:32:20.889]                       else if (inherits(cond, "condition")) {
[09:32:20.889]                         if (!is.null(pattern)) {
[09:32:20.889]                           computeRestarts <- base::computeRestarts
[09:32:20.889]                           grepl <- base::grepl
[09:32:20.889]                           restarts <- computeRestarts(cond)
[09:32:20.889]                           for (restart in restarts) {
[09:32:20.889]                             name <- restart$name
[09:32:20.889]                             if (is.null(name)) 
[09:32:20.889]                               next
[09:32:20.889]                             if (!grepl(pattern, name)) 
[09:32:20.889]                               next
[09:32:20.889]                             invokeRestart(restart)
[09:32:20.889]                             muffled <- TRUE
[09:32:20.889]                             break
[09:32:20.889]                           }
[09:32:20.889]                         }
[09:32:20.889]                       }
[09:32:20.889]                       invisible(muffled)
[09:32:20.889]                     }
[09:32:20.889]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.889]                   }
[09:32:20.889]                 }
[09:32:20.889]             }
[09:32:20.889]         }))
[09:32:20.889]     }, error = function(ex) {
[09:32:20.889]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.889]                 ...future.rng), started = ...future.startTime, 
[09:32:20.889]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.889]             version = "1.8"), class = "FutureResult")
[09:32:20.889]     }, finally = {
[09:32:20.889]         if (!identical(...future.workdir, getwd())) 
[09:32:20.889]             setwd(...future.workdir)
[09:32:20.889]         {
[09:32:20.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.889]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.889]             }
[09:32:20.889]             base::options(...future.oldOptions)
[09:32:20.889]             if (.Platform$OS.type == "windows") {
[09:32:20.889]                 old_names <- names(...future.oldEnvVars)
[09:32:20.889]                 envs <- base::Sys.getenv()
[09:32:20.889]                 names <- names(envs)
[09:32:20.889]                 common <- intersect(names, old_names)
[09:32:20.889]                 added <- setdiff(names, old_names)
[09:32:20.889]                 removed <- setdiff(old_names, names)
[09:32:20.889]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.889]                   envs[common]]
[09:32:20.889]                 NAMES <- toupper(changed)
[09:32:20.889]                 args <- list()
[09:32:20.889]                 for (kk in seq_along(NAMES)) {
[09:32:20.889]                   name <- changed[[kk]]
[09:32:20.889]                   NAME <- NAMES[[kk]]
[09:32:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.889]                     next
[09:32:20.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.889]                 }
[09:32:20.889]                 NAMES <- toupper(added)
[09:32:20.889]                 for (kk in seq_along(NAMES)) {
[09:32:20.889]                   name <- added[[kk]]
[09:32:20.889]                   NAME <- NAMES[[kk]]
[09:32:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.889]                     next
[09:32:20.889]                   args[[name]] <- ""
[09:32:20.889]                 }
[09:32:20.889]                 NAMES <- toupper(removed)
[09:32:20.889]                 for (kk in seq_along(NAMES)) {
[09:32:20.889]                   name <- removed[[kk]]
[09:32:20.889]                   NAME <- NAMES[[kk]]
[09:32:20.889]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.889]                     next
[09:32:20.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.889]                 }
[09:32:20.889]                 if (length(args) > 0) 
[09:32:20.889]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.889]             }
[09:32:20.889]             else {
[09:32:20.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.889]             }
[09:32:20.889]             {
[09:32:20.889]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.889]                   0L) {
[09:32:20.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.889]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.889]                   base::options(opts)
[09:32:20.889]                 }
[09:32:20.889]                 {
[09:32:20.889]                   {
[09:32:20.889]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.889]                     NULL
[09:32:20.889]                   }
[09:32:20.889]                   options(future.plan = NULL)
[09:32:20.889]                   if (is.na(NA_character_)) 
[09:32:20.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.889]                     .init = FALSE)
[09:32:20.889]                 }
[09:32:20.889]             }
[09:32:20.889]         }
[09:32:20.889]     })
[09:32:20.889]     if (TRUE) {
[09:32:20.889]         base::sink(type = "output", split = FALSE)
[09:32:20.889]         if (TRUE) {
[09:32:20.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.889]         }
[09:32:20.889]         else {
[09:32:20.889]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.889]         }
[09:32:20.889]         base::close(...future.stdout)
[09:32:20.889]         ...future.stdout <- NULL
[09:32:20.889]     }
[09:32:20.889]     ...future.result$conditions <- ...future.conditions
[09:32:20.889]     ...future.result$finished <- base::Sys.time()
[09:32:20.889]     ...future.result
[09:32:20.889] }
[09:32:20.892] assign_globals() ...
[09:32:20.892] List of 1
[09:32:20.892]  $ kk: int 2
[09:32:20.892]  - attr(*, "where")=List of 1
[09:32:20.892]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.892]  - attr(*, "resolved")= logi FALSE
[09:32:20.892]  - attr(*, "total_size")= num 56
[09:32:20.892]  - attr(*, "already-done")= logi TRUE
[09:32:20.896] - copied ‘kk’ to environment
[09:32:20.896] assign_globals() ... done
[09:32:20.897] requestCore(): workers = 2
[09:32:20.897] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.908] result() for MulticoreFuture ...
[09:32:20.908] result() for MulticoreFuture ...
[09:32:20.909] result() for MulticoreFuture ... done
[09:32:20.909] result() for MulticoreFuture ... done
[09:32:20.909] result() for MulticoreFuture ...
[09:32:20.909] result() for MulticoreFuture ... done
[09:32:20.911] MulticoreFuture started
[09:32:20.912] - Launch lazy future ... done
[09:32:20.912] run() for ‘MulticoreFuture’ ... done
[09:32:20.912] plan(): Setting new future strategy stack:
[09:32:20.913] List of future strategies:
[09:32:20.913] 1. sequential:
[09:32:20.913]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.913]    - tweaked: FALSE
[09:32:20.913]    - call: NULL
[09:32:20.914] plan(): nbrOfWorkers() = 1
[09:32:20.923] run() for ‘Future’ ...
[09:32:20.923] - state: ‘created’
[09:32:20.923] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:20.929] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:20.929] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:20.929]   - Field: ‘label’
[09:32:20.929]   - Field: ‘local’
[09:32:20.929]   - Field: ‘owner’
[09:32:20.930]   - Field: ‘envir’
[09:32:20.930]   - Field: ‘workers’
[09:32:20.930]   - Field: ‘packages’
[09:32:20.930]   - Field: ‘gc’
[09:32:20.930]   - Field: ‘job’
[09:32:20.930]   - Field: ‘conditions’
[09:32:20.930]   - Field: ‘expr’
[09:32:20.931]   - Field: ‘uuid’
[09:32:20.931]   - Field: ‘seed’
[09:32:20.931]   - Field: ‘version’
[09:32:20.931]   - Field: ‘result’
[09:32:20.931]   - Field: ‘asynchronous’
[09:32:20.931]   - Field: ‘calls’
[09:32:20.931]   - Field: ‘globals’
[09:32:20.932]   - Field: ‘stdout’
[09:32:20.932]   - Field: ‘earlySignal’
[09:32:20.932]   - Field: ‘lazy’
[09:32:20.932]   - Field: ‘state’
[09:32:20.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:20.932] - Launch lazy future ...
[09:32:20.933] Packages needed by the future expression (n = 0): <none>
[09:32:20.933] Packages needed by future strategies (n = 0): <none>
[09:32:20.934] {
[09:32:20.934]     {
[09:32:20.934]         {
[09:32:20.934]             ...future.startTime <- base::Sys.time()
[09:32:20.934]             {
[09:32:20.934]                 {
[09:32:20.934]                   {
[09:32:20.934]                     {
[09:32:20.934]                       base::local({
[09:32:20.934]                         has_future <- base::requireNamespace("future", 
[09:32:20.934]                           quietly = TRUE)
[09:32:20.934]                         if (has_future) {
[09:32:20.934]                           ns <- base::getNamespace("future")
[09:32:20.934]                           version <- ns[[".package"]][["version"]]
[09:32:20.934]                           if (is.null(version)) 
[09:32:20.934]                             version <- utils::packageVersion("future")
[09:32:20.934]                         }
[09:32:20.934]                         else {
[09:32:20.934]                           version <- NULL
[09:32:20.934]                         }
[09:32:20.934]                         if (!has_future || version < "1.8.0") {
[09:32:20.934]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:20.934]                             "", base::R.version$version.string), 
[09:32:20.934]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:20.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:20.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:20.934]                               "release", "version")], collapse = " "), 
[09:32:20.934]                             hostname = base::Sys.info()[["nodename"]])
[09:32:20.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:20.934]                             info)
[09:32:20.934]                           info <- base::paste(info, collapse = "; ")
[09:32:20.934]                           if (!has_future) {
[09:32:20.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:20.934]                               info)
[09:32:20.934]                           }
[09:32:20.934]                           else {
[09:32:20.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:20.934]                               info, version)
[09:32:20.934]                           }
[09:32:20.934]                           base::stop(msg)
[09:32:20.934]                         }
[09:32:20.934]                       })
[09:32:20.934]                     }
[09:32:20.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:20.934]                     base::options(mc.cores = 1L)
[09:32:20.934]                   }
[09:32:20.934]                   ...future.strategy.old <- future::plan("list")
[09:32:20.934]                   options(future.plan = NULL)
[09:32:20.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:20.934]                 }
[09:32:20.934]                 ...future.workdir <- getwd()
[09:32:20.934]             }
[09:32:20.934]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:20.934]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:20.934]         }
[09:32:20.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:20.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:20.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:20.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:20.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:20.934]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:20.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:20.934]             base::names(...future.oldOptions))
[09:32:20.934]     }
[09:32:20.934]     if (FALSE) {
[09:32:20.934]     }
[09:32:20.934]     else {
[09:32:20.934]         if (TRUE) {
[09:32:20.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:20.934]                 open = "w")
[09:32:20.934]         }
[09:32:20.934]         else {
[09:32:20.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:20.934]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:20.934]         }
[09:32:20.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:20.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:20.934]             base::sink(type = "output", split = FALSE)
[09:32:20.934]             base::close(...future.stdout)
[09:32:20.934]         }, add = TRUE)
[09:32:20.934]     }
[09:32:20.934]     ...future.frame <- base::sys.nframe()
[09:32:20.934]     ...future.conditions <- base::list()
[09:32:20.934]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:20.934]     if (FALSE) {
[09:32:20.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:20.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:20.934]     }
[09:32:20.934]     ...future.result <- base::tryCatch({
[09:32:20.934]         base::withCallingHandlers({
[09:32:20.934]             ...future.value <- base::withVisible(base::local({
[09:32:20.934]                 withCallingHandlers({
[09:32:20.934]                   {
[09:32:20.934]                     Sys.sleep(0.1)
[09:32:20.934]                     kk
[09:32:20.934]                   }
[09:32:20.934]                 }, immediateCondition = function(cond) {
[09:32:20.934]                   save_rds <- function (object, pathname, ...) 
[09:32:20.934]                   {
[09:32:20.934]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:20.934]                     if (file_test("-f", pathname_tmp)) {
[09:32:20.934]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.934]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:20.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.934]                         fi_tmp[["mtime"]])
[09:32:20.934]                     }
[09:32:20.934]                     tryCatch({
[09:32:20.934]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:20.934]                     }, error = function(ex) {
[09:32:20.934]                       msg <- conditionMessage(ex)
[09:32:20.934]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.934]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:20.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.934]                         fi_tmp[["mtime"]], msg)
[09:32:20.934]                       ex$message <- msg
[09:32:20.934]                       stop(ex)
[09:32:20.934]                     })
[09:32:20.934]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:20.934]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:20.934]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:20.934]                       fi_tmp <- file.info(pathname_tmp)
[09:32:20.934]                       fi <- file.info(pathname)
[09:32:20.934]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:20.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:20.934]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:20.934]                         fi[["size"]], fi[["mtime"]])
[09:32:20.934]                       stop(msg)
[09:32:20.934]                     }
[09:32:20.934]                     invisible(pathname)
[09:32:20.934]                   }
[09:32:20.934]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:20.934]                     rootPath = tempdir()) 
[09:32:20.934]                   {
[09:32:20.934]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:20.934]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:20.934]                       tmpdir = path, fileext = ".rds")
[09:32:20.934]                     save_rds(obj, file)
[09:32:20.934]                   }
[09:32:20.934]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:20.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.934]                   {
[09:32:20.934]                     inherits <- base::inherits
[09:32:20.934]                     invokeRestart <- base::invokeRestart
[09:32:20.934]                     is.null <- base::is.null
[09:32:20.934]                     muffled <- FALSE
[09:32:20.934]                     if (inherits(cond, "message")) {
[09:32:20.934]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:20.934]                       if (muffled) 
[09:32:20.934]                         invokeRestart("muffleMessage")
[09:32:20.934]                     }
[09:32:20.934]                     else if (inherits(cond, "warning")) {
[09:32:20.934]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:20.934]                       if (muffled) 
[09:32:20.934]                         invokeRestart("muffleWarning")
[09:32:20.934]                     }
[09:32:20.934]                     else if (inherits(cond, "condition")) {
[09:32:20.934]                       if (!is.null(pattern)) {
[09:32:20.934]                         computeRestarts <- base::computeRestarts
[09:32:20.934]                         grepl <- base::grepl
[09:32:20.934]                         restarts <- computeRestarts(cond)
[09:32:20.934]                         for (restart in restarts) {
[09:32:20.934]                           name <- restart$name
[09:32:20.934]                           if (is.null(name)) 
[09:32:20.934]                             next
[09:32:20.934]                           if (!grepl(pattern, name)) 
[09:32:20.934]                             next
[09:32:20.934]                           invokeRestart(restart)
[09:32:20.934]                           muffled <- TRUE
[09:32:20.934]                           break
[09:32:20.934]                         }
[09:32:20.934]                       }
[09:32:20.934]                     }
[09:32:20.934]                     invisible(muffled)
[09:32:20.934]                   }
[09:32:20.934]                   muffleCondition(cond)
[09:32:20.934]                 })
[09:32:20.934]             }))
[09:32:20.934]             future::FutureResult(value = ...future.value$value, 
[09:32:20.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.934]                   ...future.rng), globalenv = if (FALSE) 
[09:32:20.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:20.934]                     ...future.globalenv.names))
[09:32:20.934]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:20.934]         }, condition = base::local({
[09:32:20.934]             c <- base::c
[09:32:20.934]             inherits <- base::inherits
[09:32:20.934]             invokeRestart <- base::invokeRestart
[09:32:20.934]             length <- base::length
[09:32:20.934]             list <- base::list
[09:32:20.934]             seq.int <- base::seq.int
[09:32:20.934]             signalCondition <- base::signalCondition
[09:32:20.934]             sys.calls <- base::sys.calls
[09:32:20.934]             `[[` <- base::`[[`
[09:32:20.934]             `+` <- base::`+`
[09:32:20.934]             `<<-` <- base::`<<-`
[09:32:20.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:20.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:20.934]                   3L)]
[09:32:20.934]             }
[09:32:20.934]             function(cond) {
[09:32:20.934]                 is_error <- inherits(cond, "error")
[09:32:20.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:20.934]                   NULL)
[09:32:20.934]                 if (is_error) {
[09:32:20.934]                   sessionInformation <- function() {
[09:32:20.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:20.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:20.934]                       search = base::search(), system = base::Sys.info())
[09:32:20.934]                   }
[09:32:20.934]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:20.934]                     cond$call), session = sessionInformation(), 
[09:32:20.934]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:20.934]                   signalCondition(cond)
[09:32:20.934]                 }
[09:32:20.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:20.934]                 "immediateCondition"))) {
[09:32:20.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:20.934]                   ...future.conditions[[length(...future.conditions) + 
[09:32:20.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:20.934]                   if (TRUE && !signal) {
[09:32:20.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.934]                     {
[09:32:20.934]                       inherits <- base::inherits
[09:32:20.934]                       invokeRestart <- base::invokeRestart
[09:32:20.934]                       is.null <- base::is.null
[09:32:20.934]                       muffled <- FALSE
[09:32:20.934]                       if (inherits(cond, "message")) {
[09:32:20.934]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.934]                         if (muffled) 
[09:32:20.934]                           invokeRestart("muffleMessage")
[09:32:20.934]                       }
[09:32:20.934]                       else if (inherits(cond, "warning")) {
[09:32:20.934]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.934]                         if (muffled) 
[09:32:20.934]                           invokeRestart("muffleWarning")
[09:32:20.934]                       }
[09:32:20.934]                       else if (inherits(cond, "condition")) {
[09:32:20.934]                         if (!is.null(pattern)) {
[09:32:20.934]                           computeRestarts <- base::computeRestarts
[09:32:20.934]                           grepl <- base::grepl
[09:32:20.934]                           restarts <- computeRestarts(cond)
[09:32:20.934]                           for (restart in restarts) {
[09:32:20.934]                             name <- restart$name
[09:32:20.934]                             if (is.null(name)) 
[09:32:20.934]                               next
[09:32:20.934]                             if (!grepl(pattern, name)) 
[09:32:20.934]                               next
[09:32:20.934]                             invokeRestart(restart)
[09:32:20.934]                             muffled <- TRUE
[09:32:20.934]                             break
[09:32:20.934]                           }
[09:32:20.934]                         }
[09:32:20.934]                       }
[09:32:20.934]                       invisible(muffled)
[09:32:20.934]                     }
[09:32:20.934]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.934]                   }
[09:32:20.934]                 }
[09:32:20.934]                 else {
[09:32:20.934]                   if (TRUE) {
[09:32:20.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:20.934]                     {
[09:32:20.934]                       inherits <- base::inherits
[09:32:20.934]                       invokeRestart <- base::invokeRestart
[09:32:20.934]                       is.null <- base::is.null
[09:32:20.934]                       muffled <- FALSE
[09:32:20.934]                       if (inherits(cond, "message")) {
[09:32:20.934]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:20.934]                         if (muffled) 
[09:32:20.934]                           invokeRestart("muffleMessage")
[09:32:20.934]                       }
[09:32:20.934]                       else if (inherits(cond, "warning")) {
[09:32:20.934]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:20.934]                         if (muffled) 
[09:32:20.934]                           invokeRestart("muffleWarning")
[09:32:20.934]                       }
[09:32:20.934]                       else if (inherits(cond, "condition")) {
[09:32:20.934]                         if (!is.null(pattern)) {
[09:32:20.934]                           computeRestarts <- base::computeRestarts
[09:32:20.934]                           grepl <- base::grepl
[09:32:20.934]                           restarts <- computeRestarts(cond)
[09:32:20.934]                           for (restart in restarts) {
[09:32:20.934]                             name <- restart$name
[09:32:20.934]                             if (is.null(name)) 
[09:32:20.934]                               next
[09:32:20.934]                             if (!grepl(pattern, name)) 
[09:32:20.934]                               next
[09:32:20.934]                             invokeRestart(restart)
[09:32:20.934]                             muffled <- TRUE
[09:32:20.934]                             break
[09:32:20.934]                           }
[09:32:20.934]                         }
[09:32:20.934]                       }
[09:32:20.934]                       invisible(muffled)
[09:32:20.934]                     }
[09:32:20.934]                     muffleCondition(cond, pattern = "^muffle")
[09:32:20.934]                   }
[09:32:20.934]                 }
[09:32:20.934]             }
[09:32:20.934]         }))
[09:32:20.934]     }, error = function(ex) {
[09:32:20.934]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:20.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:20.934]                 ...future.rng), started = ...future.startTime, 
[09:32:20.934]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:20.934]             version = "1.8"), class = "FutureResult")
[09:32:20.934]     }, finally = {
[09:32:20.934]         if (!identical(...future.workdir, getwd())) 
[09:32:20.934]             setwd(...future.workdir)
[09:32:20.934]         {
[09:32:20.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:20.934]                 ...future.oldOptions$nwarnings <- NULL
[09:32:20.934]             }
[09:32:20.934]             base::options(...future.oldOptions)
[09:32:20.934]             if (.Platform$OS.type == "windows") {
[09:32:20.934]                 old_names <- names(...future.oldEnvVars)
[09:32:20.934]                 envs <- base::Sys.getenv()
[09:32:20.934]                 names <- names(envs)
[09:32:20.934]                 common <- intersect(names, old_names)
[09:32:20.934]                 added <- setdiff(names, old_names)
[09:32:20.934]                 removed <- setdiff(old_names, names)
[09:32:20.934]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:20.934]                   envs[common]]
[09:32:20.934]                 NAMES <- toupper(changed)
[09:32:20.934]                 args <- list()
[09:32:20.934]                 for (kk in seq_along(NAMES)) {
[09:32:20.934]                   name <- changed[[kk]]
[09:32:20.934]                   NAME <- NAMES[[kk]]
[09:32:20.934]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.934]                     next
[09:32:20.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.934]                 }
[09:32:20.934]                 NAMES <- toupper(added)
[09:32:20.934]                 for (kk in seq_along(NAMES)) {
[09:32:20.934]                   name <- added[[kk]]
[09:32:20.934]                   NAME <- NAMES[[kk]]
[09:32:20.934]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.934]                     next
[09:32:20.934]                   args[[name]] <- ""
[09:32:20.934]                 }
[09:32:20.934]                 NAMES <- toupper(removed)
[09:32:20.934]                 for (kk in seq_along(NAMES)) {
[09:32:20.934]                   name <- removed[[kk]]
[09:32:20.934]                   NAME <- NAMES[[kk]]
[09:32:20.934]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:20.934]                     next
[09:32:20.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:20.934]                 }
[09:32:20.934]                 if (length(args) > 0) 
[09:32:20.934]                   base::do.call(base::Sys.setenv, args = args)
[09:32:20.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:20.934]             }
[09:32:20.934]             else {
[09:32:20.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:20.934]             }
[09:32:20.934]             {
[09:32:20.934]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:20.934]                   0L) {
[09:32:20.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:20.934]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:20.934]                   base::options(opts)
[09:32:20.934]                 }
[09:32:20.934]                 {
[09:32:20.934]                   {
[09:32:20.934]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:20.934]                     NULL
[09:32:20.934]                   }
[09:32:20.934]                   options(future.plan = NULL)
[09:32:20.934]                   if (is.na(NA_character_)) 
[09:32:20.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:20.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:20.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:20.934]                     .init = FALSE)
[09:32:20.934]                 }
[09:32:20.934]             }
[09:32:20.934]         }
[09:32:20.934]     })
[09:32:20.934]     if (TRUE) {
[09:32:20.934]         base::sink(type = "output", split = FALSE)
[09:32:20.934]         if (TRUE) {
[09:32:20.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:20.934]         }
[09:32:20.934]         else {
[09:32:20.934]             ...future.result["stdout"] <- base::list(NULL)
[09:32:20.934]         }
[09:32:20.934]         base::close(...future.stdout)
[09:32:20.934]         ...future.stdout <- NULL
[09:32:20.934]     }
[09:32:20.934]     ...future.result$conditions <- ...future.conditions
[09:32:20.934]     ...future.result$finished <- base::Sys.time()
[09:32:20.934]     ...future.result
[09:32:20.934] }
[09:32:20.937] assign_globals() ...
[09:32:20.937] List of 1
[09:32:20.937]  $ kk: int 3
[09:32:20.937]  - attr(*, "where")=List of 1
[09:32:20.937]   ..$ kk:<environment: R_EmptyEnv> 
[09:32:20.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[09:32:20.937]  - attr(*, "resolved")= logi FALSE
[09:32:20.937]  - attr(*, "total_size")= num 56
[09:32:20.937]  - attr(*, "already-done")= logi TRUE
[09:32:20.941] - copied ‘kk’ to environment
[09:32:20.941] assign_globals() ... done
[09:32:20.942] requestCore(): workers = 2
[09:32:20.942] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:20.970] plan(): Setting new future strategy stack:
[09:32:20.970] List of future strategies:
[09:32:20.970] 1. multicore:
[09:32:20.970]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:20.970]    - tweaked: FALSE
[09:32:20.970]    - call: plan(strategy)
[09:32:20.973] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[09:32:20.975] plan(): nbrOfWorkers() = 2
[09:32:20.984] result() for MulticoreFuture ...
[09:32:20.985] result() for MulticoreFuture ...
[09:32:20.985] result() for MulticoreFuture ... done
[09:32:20.985] result() for MulticoreFuture ... done
[09:32:20.985] result() for MulticoreFuture ...
[09:32:20.985] result() for MulticoreFuture ... done
[09:32:20.988] MulticoreFuture started
[09:32:20.988] - Launch lazy future ... done
[09:32:20.988] run() for ‘MulticoreFuture’ ... done
[09:32:20.989] plan(): Setting new future strategy stack:
[09:32:20.989] List of future strategies:
[09:32:20.989] 1. sequential:
[09:32:20.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:20.989]    - tweaked: FALSE
[09:32:20.989]    - call: NULL
[09:32:20.990] plan(): nbrOfWorkers() = 1
[09:32:21.009] Future #1
[09:32:21.010]  length: 2 (resolved future 1)
[09:32:21.016] plan(): Setting new future strategy stack:
[09:32:21.016] List of future strategies:
[09:32:21.016] 1. multicore:
[09:32:21.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.016]    - tweaked: FALSE
[09:32:21.016]    - call: plan(strategy)
[09:32:21.021] plan(): nbrOfWorkers() = 2
[09:32:21.041] Future #2
[09:32:21.041]  length: 1 (resolved future 2)
[09:32:21.093] plan(): Setting new future strategy stack:
[09:32:21.093] List of future strategies:
[09:32:21.093] 1. multicore:
[09:32:21.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.093]    - tweaked: FALSE
[09:32:21.093]    - call: plan(strategy)
[09:32:21.098] plan(): nbrOfWorkers() = 2
[09:32:21.102] Future #3
[09:32:21.103]  length: 0 (resolved future 3)
[09:32:21.103] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[09:32:21.104] resolve() on environment ...
[09:32:21.104]  recursive: 0
[09:32:21.105]  elements: [2] ‘a’, ‘b’
[09:32:21.105]  length: 1 (resolved future 1)
[09:32:21.105]  length: 0 (resolved future 2)
[09:32:21.110] resolve() on environment ... DONE
[09:32:21.111] getGlobalsAndPackages() ...
[09:32:21.111] Searching for globals...
[09:32:21.113] 
[09:32:21.113] Searching for globals ... DONE
[09:32:21.113] - globals: [0] <none>
[09:32:21.114] getGlobalsAndPackages() ... DONE
[09:32:21.114] run() for ‘Future’ ...
[09:32:21.115] - state: ‘created’
[09:32:21.115] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.120] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.120] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.120]   - Field: ‘label’
[09:32:21.120]   - Field: ‘local’
[09:32:21.120]   - Field: ‘owner’
[09:32:21.121]   - Field: ‘envir’
[09:32:21.121]   - Field: ‘workers’
[09:32:21.121]   - Field: ‘packages’
[09:32:21.121]   - Field: ‘gc’
[09:32:21.121]   - Field: ‘job’
[09:32:21.121]   - Field: ‘conditions’
[09:32:21.122]   - Field: ‘expr’
[09:32:21.122]   - Field: ‘uuid’
[09:32:21.122]   - Field: ‘seed’
[09:32:21.122]   - Field: ‘version’
[09:32:21.122]   - Field: ‘result’
[09:32:21.122]   - Field: ‘asynchronous’
[09:32:21.122]   - Field: ‘calls’
[09:32:21.122]   - Field: ‘globals’
[09:32:21.123]   - Field: ‘stdout’
[09:32:21.123]   - Field: ‘earlySignal’
[09:32:21.123]   - Field: ‘lazy’
[09:32:21.123]   - Field: ‘state’
[09:32:21.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.123] - Launch lazy future ...
[09:32:21.124] Packages needed by the future expression (n = 0): <none>
[09:32:21.124] Packages needed by future strategies (n = 0): <none>
[09:32:21.125] {
[09:32:21.125]     {
[09:32:21.125]         {
[09:32:21.125]             ...future.startTime <- base::Sys.time()
[09:32:21.125]             {
[09:32:21.125]                 {
[09:32:21.125]                   {
[09:32:21.125]                     {
[09:32:21.125]                       base::local({
[09:32:21.125]                         has_future <- base::requireNamespace("future", 
[09:32:21.125]                           quietly = TRUE)
[09:32:21.125]                         if (has_future) {
[09:32:21.125]                           ns <- base::getNamespace("future")
[09:32:21.125]                           version <- ns[[".package"]][["version"]]
[09:32:21.125]                           if (is.null(version)) 
[09:32:21.125]                             version <- utils::packageVersion("future")
[09:32:21.125]                         }
[09:32:21.125]                         else {
[09:32:21.125]                           version <- NULL
[09:32:21.125]                         }
[09:32:21.125]                         if (!has_future || version < "1.8.0") {
[09:32:21.125]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.125]                             "", base::R.version$version.string), 
[09:32:21.125]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.125]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.125]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.125]                               "release", "version")], collapse = " "), 
[09:32:21.125]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.125]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.125]                             info)
[09:32:21.125]                           info <- base::paste(info, collapse = "; ")
[09:32:21.125]                           if (!has_future) {
[09:32:21.125]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.125]                               info)
[09:32:21.125]                           }
[09:32:21.125]                           else {
[09:32:21.125]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.125]                               info, version)
[09:32:21.125]                           }
[09:32:21.125]                           base::stop(msg)
[09:32:21.125]                         }
[09:32:21.125]                       })
[09:32:21.125]                     }
[09:32:21.125]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.125]                     base::options(mc.cores = 1L)
[09:32:21.125]                   }
[09:32:21.125]                   ...future.strategy.old <- future::plan("list")
[09:32:21.125]                   options(future.plan = NULL)
[09:32:21.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.125]                 }
[09:32:21.125]                 ...future.workdir <- getwd()
[09:32:21.125]             }
[09:32:21.125]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.125]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.125]         }
[09:32:21.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.125]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.125]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.125]             base::names(...future.oldOptions))
[09:32:21.125]     }
[09:32:21.125]     if (FALSE) {
[09:32:21.125]     }
[09:32:21.125]     else {
[09:32:21.125]         if (TRUE) {
[09:32:21.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.125]                 open = "w")
[09:32:21.125]         }
[09:32:21.125]         else {
[09:32:21.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.125]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.125]         }
[09:32:21.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.125]             base::sink(type = "output", split = FALSE)
[09:32:21.125]             base::close(...future.stdout)
[09:32:21.125]         }, add = TRUE)
[09:32:21.125]     }
[09:32:21.125]     ...future.frame <- base::sys.nframe()
[09:32:21.125]     ...future.conditions <- base::list()
[09:32:21.125]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.125]     if (FALSE) {
[09:32:21.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.125]     }
[09:32:21.125]     ...future.result <- base::tryCatch({
[09:32:21.125]         base::withCallingHandlers({
[09:32:21.125]             ...future.value <- base::withVisible(base::local({
[09:32:21.125]                 withCallingHandlers({
[09:32:21.125]                   1
[09:32:21.125]                 }, immediateCondition = function(cond) {
[09:32:21.125]                   save_rds <- function (object, pathname, ...) 
[09:32:21.125]                   {
[09:32:21.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.125]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.125]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.125]                         fi_tmp[["mtime"]])
[09:32:21.125]                     }
[09:32:21.125]                     tryCatch({
[09:32:21.125]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.125]                     }, error = function(ex) {
[09:32:21.125]                       msg <- conditionMessage(ex)
[09:32:21.125]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.125]                         fi_tmp[["mtime"]], msg)
[09:32:21.125]                       ex$message <- msg
[09:32:21.125]                       stop(ex)
[09:32:21.125]                     })
[09:32:21.125]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.125]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.125]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.125]                       fi <- file.info(pathname)
[09:32:21.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.125]                         fi[["size"]], fi[["mtime"]])
[09:32:21.125]                       stop(msg)
[09:32:21.125]                     }
[09:32:21.125]                     invisible(pathname)
[09:32:21.125]                   }
[09:32:21.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.125]                     rootPath = tempdir()) 
[09:32:21.125]                   {
[09:32:21.125]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.125]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.125]                       tmpdir = path, fileext = ".rds")
[09:32:21.125]                     save_rds(obj, file)
[09:32:21.125]                   }
[09:32:21.125]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.125]                   {
[09:32:21.125]                     inherits <- base::inherits
[09:32:21.125]                     invokeRestart <- base::invokeRestart
[09:32:21.125]                     is.null <- base::is.null
[09:32:21.125]                     muffled <- FALSE
[09:32:21.125]                     if (inherits(cond, "message")) {
[09:32:21.125]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.125]                       if (muffled) 
[09:32:21.125]                         invokeRestart("muffleMessage")
[09:32:21.125]                     }
[09:32:21.125]                     else if (inherits(cond, "warning")) {
[09:32:21.125]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.125]                       if (muffled) 
[09:32:21.125]                         invokeRestart("muffleWarning")
[09:32:21.125]                     }
[09:32:21.125]                     else if (inherits(cond, "condition")) {
[09:32:21.125]                       if (!is.null(pattern)) {
[09:32:21.125]                         computeRestarts <- base::computeRestarts
[09:32:21.125]                         grepl <- base::grepl
[09:32:21.125]                         restarts <- computeRestarts(cond)
[09:32:21.125]                         for (restart in restarts) {
[09:32:21.125]                           name <- restart$name
[09:32:21.125]                           if (is.null(name)) 
[09:32:21.125]                             next
[09:32:21.125]                           if (!grepl(pattern, name)) 
[09:32:21.125]                             next
[09:32:21.125]                           invokeRestart(restart)
[09:32:21.125]                           muffled <- TRUE
[09:32:21.125]                           break
[09:32:21.125]                         }
[09:32:21.125]                       }
[09:32:21.125]                     }
[09:32:21.125]                     invisible(muffled)
[09:32:21.125]                   }
[09:32:21.125]                   muffleCondition(cond)
[09:32:21.125]                 })
[09:32:21.125]             }))
[09:32:21.125]             future::FutureResult(value = ...future.value$value, 
[09:32:21.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.125]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.125]                     ...future.globalenv.names))
[09:32:21.125]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.125]         }, condition = base::local({
[09:32:21.125]             c <- base::c
[09:32:21.125]             inherits <- base::inherits
[09:32:21.125]             invokeRestart <- base::invokeRestart
[09:32:21.125]             length <- base::length
[09:32:21.125]             list <- base::list
[09:32:21.125]             seq.int <- base::seq.int
[09:32:21.125]             signalCondition <- base::signalCondition
[09:32:21.125]             sys.calls <- base::sys.calls
[09:32:21.125]             `[[` <- base::`[[`
[09:32:21.125]             `+` <- base::`+`
[09:32:21.125]             `<<-` <- base::`<<-`
[09:32:21.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.125]                   3L)]
[09:32:21.125]             }
[09:32:21.125]             function(cond) {
[09:32:21.125]                 is_error <- inherits(cond, "error")
[09:32:21.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.125]                   NULL)
[09:32:21.125]                 if (is_error) {
[09:32:21.125]                   sessionInformation <- function() {
[09:32:21.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.125]                       search = base::search(), system = base::Sys.info())
[09:32:21.125]                   }
[09:32:21.125]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.125]                     cond$call), session = sessionInformation(), 
[09:32:21.125]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.125]                   signalCondition(cond)
[09:32:21.125]                 }
[09:32:21.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.125]                 "immediateCondition"))) {
[09:32:21.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.125]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.125]                   if (TRUE && !signal) {
[09:32:21.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.125]                     {
[09:32:21.125]                       inherits <- base::inherits
[09:32:21.125]                       invokeRestart <- base::invokeRestart
[09:32:21.125]                       is.null <- base::is.null
[09:32:21.125]                       muffled <- FALSE
[09:32:21.125]                       if (inherits(cond, "message")) {
[09:32:21.125]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.125]                         if (muffled) 
[09:32:21.125]                           invokeRestart("muffleMessage")
[09:32:21.125]                       }
[09:32:21.125]                       else if (inherits(cond, "warning")) {
[09:32:21.125]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.125]                         if (muffled) 
[09:32:21.125]                           invokeRestart("muffleWarning")
[09:32:21.125]                       }
[09:32:21.125]                       else if (inherits(cond, "condition")) {
[09:32:21.125]                         if (!is.null(pattern)) {
[09:32:21.125]                           computeRestarts <- base::computeRestarts
[09:32:21.125]                           grepl <- base::grepl
[09:32:21.125]                           restarts <- computeRestarts(cond)
[09:32:21.125]                           for (restart in restarts) {
[09:32:21.125]                             name <- restart$name
[09:32:21.125]                             if (is.null(name)) 
[09:32:21.125]                               next
[09:32:21.125]                             if (!grepl(pattern, name)) 
[09:32:21.125]                               next
[09:32:21.125]                             invokeRestart(restart)
[09:32:21.125]                             muffled <- TRUE
[09:32:21.125]                             break
[09:32:21.125]                           }
[09:32:21.125]                         }
[09:32:21.125]                       }
[09:32:21.125]                       invisible(muffled)
[09:32:21.125]                     }
[09:32:21.125]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.125]                   }
[09:32:21.125]                 }
[09:32:21.125]                 else {
[09:32:21.125]                   if (TRUE) {
[09:32:21.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.125]                     {
[09:32:21.125]                       inherits <- base::inherits
[09:32:21.125]                       invokeRestart <- base::invokeRestart
[09:32:21.125]                       is.null <- base::is.null
[09:32:21.125]                       muffled <- FALSE
[09:32:21.125]                       if (inherits(cond, "message")) {
[09:32:21.125]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.125]                         if (muffled) 
[09:32:21.125]                           invokeRestart("muffleMessage")
[09:32:21.125]                       }
[09:32:21.125]                       else if (inherits(cond, "warning")) {
[09:32:21.125]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.125]                         if (muffled) 
[09:32:21.125]                           invokeRestart("muffleWarning")
[09:32:21.125]                       }
[09:32:21.125]                       else if (inherits(cond, "condition")) {
[09:32:21.125]                         if (!is.null(pattern)) {
[09:32:21.125]                           computeRestarts <- base::computeRestarts
[09:32:21.125]                           grepl <- base::grepl
[09:32:21.125]                           restarts <- computeRestarts(cond)
[09:32:21.125]                           for (restart in restarts) {
[09:32:21.125]                             name <- restart$name
[09:32:21.125]                             if (is.null(name)) 
[09:32:21.125]                               next
[09:32:21.125]                             if (!grepl(pattern, name)) 
[09:32:21.125]                               next
[09:32:21.125]                             invokeRestart(restart)
[09:32:21.125]                             muffled <- TRUE
[09:32:21.125]                             break
[09:32:21.125]                           }
[09:32:21.125]                         }
[09:32:21.125]                       }
[09:32:21.125]                       invisible(muffled)
[09:32:21.125]                     }
[09:32:21.125]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.125]                   }
[09:32:21.125]                 }
[09:32:21.125]             }
[09:32:21.125]         }))
[09:32:21.125]     }, error = function(ex) {
[09:32:21.125]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.125]                 ...future.rng), started = ...future.startTime, 
[09:32:21.125]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.125]             version = "1.8"), class = "FutureResult")
[09:32:21.125]     }, finally = {
[09:32:21.125]         if (!identical(...future.workdir, getwd())) 
[09:32:21.125]             setwd(...future.workdir)
[09:32:21.125]         {
[09:32:21.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.125]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.125]             }
[09:32:21.125]             base::options(...future.oldOptions)
[09:32:21.125]             if (.Platform$OS.type == "windows") {
[09:32:21.125]                 old_names <- names(...future.oldEnvVars)
[09:32:21.125]                 envs <- base::Sys.getenv()
[09:32:21.125]                 names <- names(envs)
[09:32:21.125]                 common <- intersect(names, old_names)
[09:32:21.125]                 added <- setdiff(names, old_names)
[09:32:21.125]                 removed <- setdiff(old_names, names)
[09:32:21.125]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.125]                   envs[common]]
[09:32:21.125]                 NAMES <- toupper(changed)
[09:32:21.125]                 args <- list()
[09:32:21.125]                 for (kk in seq_along(NAMES)) {
[09:32:21.125]                   name <- changed[[kk]]
[09:32:21.125]                   NAME <- NAMES[[kk]]
[09:32:21.125]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.125]                     next
[09:32:21.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.125]                 }
[09:32:21.125]                 NAMES <- toupper(added)
[09:32:21.125]                 for (kk in seq_along(NAMES)) {
[09:32:21.125]                   name <- added[[kk]]
[09:32:21.125]                   NAME <- NAMES[[kk]]
[09:32:21.125]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.125]                     next
[09:32:21.125]                   args[[name]] <- ""
[09:32:21.125]                 }
[09:32:21.125]                 NAMES <- toupper(removed)
[09:32:21.125]                 for (kk in seq_along(NAMES)) {
[09:32:21.125]                   name <- removed[[kk]]
[09:32:21.125]                   NAME <- NAMES[[kk]]
[09:32:21.125]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.125]                     next
[09:32:21.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.125]                 }
[09:32:21.125]                 if (length(args) > 0) 
[09:32:21.125]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.125]             }
[09:32:21.125]             else {
[09:32:21.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.125]             }
[09:32:21.125]             {
[09:32:21.125]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.125]                   0L) {
[09:32:21.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.125]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.125]                   base::options(opts)
[09:32:21.125]                 }
[09:32:21.125]                 {
[09:32:21.125]                   {
[09:32:21.125]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.125]                     NULL
[09:32:21.125]                   }
[09:32:21.125]                   options(future.plan = NULL)
[09:32:21.125]                   if (is.na(NA_character_)) 
[09:32:21.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.125]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.125]                     .init = FALSE)
[09:32:21.125]                 }
[09:32:21.125]             }
[09:32:21.125]         }
[09:32:21.125]     })
[09:32:21.125]     if (TRUE) {
[09:32:21.125]         base::sink(type = "output", split = FALSE)
[09:32:21.125]         if (TRUE) {
[09:32:21.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.125]         }
[09:32:21.125]         else {
[09:32:21.125]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.125]         }
[09:32:21.125]         base::close(...future.stdout)
[09:32:21.125]         ...future.stdout <- NULL
[09:32:21.125]     }
[09:32:21.125]     ...future.result$conditions <- ...future.conditions
[09:32:21.125]     ...future.result$finished <- base::Sys.time()
[09:32:21.125]     ...future.result
[09:32:21.125] }
[09:32:21.127] requestCore(): workers = 2
[09:32:21.127] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.138] result() for MulticoreFuture ...
[09:32:21.139] result() for MulticoreFuture ...
[09:32:21.139] result() for MulticoreFuture ... done
[09:32:21.139] result() for MulticoreFuture ... done
[09:32:21.139] result() for MulticoreFuture ...
[09:32:21.139] result() for MulticoreFuture ... done
[09:32:21.142] MulticoreFuture started
[09:32:21.142] - Launch lazy future ... done
[09:32:21.143] run() for ‘MulticoreFuture’ ... done
[09:32:21.143] getGlobalsAndPackages() ...
[09:32:21.143] plan(): Setting new future strategy stack:
[09:32:21.143] Searching for globals...
[09:32:21.144] 
[09:32:21.143] List of future strategies:
[09:32:21.143] 1. sequential:
[09:32:21.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.143]    - tweaked: FALSE
[09:32:21.143]    - call: NULL
[09:32:21.144] Searching for globals ... DONE
[09:32:21.144] plan(): nbrOfWorkers() = 1
[09:32:21.144] - globals: [0] <none>
[09:32:21.145] getGlobalsAndPackages() ... DONE
[09:32:21.145] run() for ‘Future’ ...
[09:32:21.145] - state: ‘created’
[09:32:21.146] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.146] plan(): Setting new future strategy stack:
[09:32:21.146] List of future strategies:
[09:32:21.146] 1. multicore:
[09:32:21.146]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.146]    - tweaked: FALSE
[09:32:21.146]    - call: plan(strategy)
[09:32:21.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.151]   - Field: ‘label’
[09:32:21.151] plan(): nbrOfWorkers() = 2
[09:32:21.151]   - Field: ‘local’
[09:32:21.151]   - Field: ‘owner’
[09:32:21.151]   - Field: ‘envir’
[09:32:21.151]   - Field: ‘workers’
[09:32:21.151]   - Field: ‘packages’
[09:32:21.152]   - Field: ‘gc’
[09:32:21.152]   - Field: ‘job’
[09:32:21.152]   - Field: ‘conditions’
[09:32:21.152]   - Field: ‘expr’
[09:32:21.152]   - Field: ‘uuid’
[09:32:21.152]   - Field: ‘seed’
[09:32:21.153]   - Field: ‘version’
[09:32:21.153]   - Field: ‘result’
[09:32:21.153]   - Field: ‘asynchronous’
[09:32:21.153]   - Field: ‘calls’
[09:32:21.153]   - Field: ‘globals’
[09:32:21.153]   - Field: ‘stdout’
[09:32:21.153]   - Field: ‘earlySignal’
[09:32:21.154]   - Field: ‘lazy’
[09:32:21.154]   - Field: ‘state’
[09:32:21.154] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.154] - Launch lazy future ...
[09:32:21.154] Packages needed by the future expression (n = 0): <none>
[09:32:21.155] Packages needed by future strategies (n = 0): <none>
[09:32:21.155] {
[09:32:21.155]     {
[09:32:21.155]         {
[09:32:21.155]             ...future.startTime <- base::Sys.time()
[09:32:21.155]             {
[09:32:21.155]                 {
[09:32:21.155]                   {
[09:32:21.155]                     {
[09:32:21.155]                       base::local({
[09:32:21.155]                         has_future <- base::requireNamespace("future", 
[09:32:21.155]                           quietly = TRUE)
[09:32:21.155]                         if (has_future) {
[09:32:21.155]                           ns <- base::getNamespace("future")
[09:32:21.155]                           version <- ns[[".package"]][["version"]]
[09:32:21.155]                           if (is.null(version)) 
[09:32:21.155]                             version <- utils::packageVersion("future")
[09:32:21.155]                         }
[09:32:21.155]                         else {
[09:32:21.155]                           version <- NULL
[09:32:21.155]                         }
[09:32:21.155]                         if (!has_future || version < "1.8.0") {
[09:32:21.155]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.155]                             "", base::R.version$version.string), 
[09:32:21.155]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.155]                               "release", "version")], collapse = " "), 
[09:32:21.155]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.155]                             info)
[09:32:21.155]                           info <- base::paste(info, collapse = "; ")
[09:32:21.155]                           if (!has_future) {
[09:32:21.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.155]                               info)
[09:32:21.155]                           }
[09:32:21.155]                           else {
[09:32:21.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.155]                               info, version)
[09:32:21.155]                           }
[09:32:21.155]                           base::stop(msg)
[09:32:21.155]                         }
[09:32:21.155]                       })
[09:32:21.155]                     }
[09:32:21.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.155]                     base::options(mc.cores = 1L)
[09:32:21.155]                   }
[09:32:21.155]                   ...future.strategy.old <- future::plan("list")
[09:32:21.155]                   options(future.plan = NULL)
[09:32:21.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.155]                 }
[09:32:21.155]                 ...future.workdir <- getwd()
[09:32:21.155]             }
[09:32:21.155]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.155]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.155]         }
[09:32:21.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.155]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.155]             base::names(...future.oldOptions))
[09:32:21.155]     }
[09:32:21.155]     if (FALSE) {
[09:32:21.155]     }
[09:32:21.155]     else {
[09:32:21.155]         if (TRUE) {
[09:32:21.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.155]                 open = "w")
[09:32:21.155]         }
[09:32:21.155]         else {
[09:32:21.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.155]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.155]         }
[09:32:21.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.155]             base::sink(type = "output", split = FALSE)
[09:32:21.155]             base::close(...future.stdout)
[09:32:21.155]         }, add = TRUE)
[09:32:21.155]     }
[09:32:21.155]     ...future.frame <- base::sys.nframe()
[09:32:21.155]     ...future.conditions <- base::list()
[09:32:21.155]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.155]     if (FALSE) {
[09:32:21.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.155]     }
[09:32:21.155]     ...future.result <- base::tryCatch({
[09:32:21.155]         base::withCallingHandlers({
[09:32:21.155]             ...future.value <- base::withVisible(base::local({
[09:32:21.155]                 withCallingHandlers({
[09:32:21.155]                   2
[09:32:21.155]                 }, immediateCondition = function(cond) {
[09:32:21.155]                   save_rds <- function (object, pathname, ...) 
[09:32:21.155]                   {
[09:32:21.155]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.155]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.155]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.155]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.155]                         fi_tmp[["mtime"]])
[09:32:21.155]                     }
[09:32:21.155]                     tryCatch({
[09:32:21.155]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.155]                     }, error = function(ex) {
[09:32:21.155]                       msg <- conditionMessage(ex)
[09:32:21.155]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.155]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.155]                         fi_tmp[["mtime"]], msg)
[09:32:21.155]                       ex$message <- msg
[09:32:21.155]                       stop(ex)
[09:32:21.155]                     })
[09:32:21.155]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.155]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.155]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.155]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.155]                       fi <- file.info(pathname)
[09:32:21.155]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.155]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.155]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.155]                         fi[["size"]], fi[["mtime"]])
[09:32:21.155]                       stop(msg)
[09:32:21.155]                     }
[09:32:21.155]                     invisible(pathname)
[09:32:21.155]                   }
[09:32:21.155]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.155]                     rootPath = tempdir()) 
[09:32:21.155]                   {
[09:32:21.155]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.155]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.155]                       tmpdir = path, fileext = ".rds")
[09:32:21.155]                     save_rds(obj, file)
[09:32:21.155]                   }
[09:32:21.155]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.155]                   {
[09:32:21.155]                     inherits <- base::inherits
[09:32:21.155]                     invokeRestart <- base::invokeRestart
[09:32:21.155]                     is.null <- base::is.null
[09:32:21.155]                     muffled <- FALSE
[09:32:21.155]                     if (inherits(cond, "message")) {
[09:32:21.155]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.155]                       if (muffled) 
[09:32:21.155]                         invokeRestart("muffleMessage")
[09:32:21.155]                     }
[09:32:21.155]                     else if (inherits(cond, "warning")) {
[09:32:21.155]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.155]                       if (muffled) 
[09:32:21.155]                         invokeRestart("muffleWarning")
[09:32:21.155]                     }
[09:32:21.155]                     else if (inherits(cond, "condition")) {
[09:32:21.155]                       if (!is.null(pattern)) {
[09:32:21.155]                         computeRestarts <- base::computeRestarts
[09:32:21.155]                         grepl <- base::grepl
[09:32:21.155]                         restarts <- computeRestarts(cond)
[09:32:21.155]                         for (restart in restarts) {
[09:32:21.155]                           name <- restart$name
[09:32:21.155]                           if (is.null(name)) 
[09:32:21.155]                             next
[09:32:21.155]                           if (!grepl(pattern, name)) 
[09:32:21.155]                             next
[09:32:21.155]                           invokeRestart(restart)
[09:32:21.155]                           muffled <- TRUE
[09:32:21.155]                           break
[09:32:21.155]                         }
[09:32:21.155]                       }
[09:32:21.155]                     }
[09:32:21.155]                     invisible(muffled)
[09:32:21.155]                   }
[09:32:21.155]                   muffleCondition(cond)
[09:32:21.155]                 })
[09:32:21.155]             }))
[09:32:21.155]             future::FutureResult(value = ...future.value$value, 
[09:32:21.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.155]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.155]                     ...future.globalenv.names))
[09:32:21.155]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.155]         }, condition = base::local({
[09:32:21.155]             c <- base::c
[09:32:21.155]             inherits <- base::inherits
[09:32:21.155]             invokeRestart <- base::invokeRestart
[09:32:21.155]             length <- base::length
[09:32:21.155]             list <- base::list
[09:32:21.155]             seq.int <- base::seq.int
[09:32:21.155]             signalCondition <- base::signalCondition
[09:32:21.155]             sys.calls <- base::sys.calls
[09:32:21.155]             `[[` <- base::`[[`
[09:32:21.155]             `+` <- base::`+`
[09:32:21.155]             `<<-` <- base::`<<-`
[09:32:21.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.155]                   3L)]
[09:32:21.155]             }
[09:32:21.155]             function(cond) {
[09:32:21.155]                 is_error <- inherits(cond, "error")
[09:32:21.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.155]                   NULL)
[09:32:21.155]                 if (is_error) {
[09:32:21.155]                   sessionInformation <- function() {
[09:32:21.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.155]                       search = base::search(), system = base::Sys.info())
[09:32:21.155]                   }
[09:32:21.155]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.155]                     cond$call), session = sessionInformation(), 
[09:32:21.155]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.155]                   signalCondition(cond)
[09:32:21.155]                 }
[09:32:21.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.155]                 "immediateCondition"))) {
[09:32:21.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.155]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.155]                   if (TRUE && !signal) {
[09:32:21.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.155]                     {
[09:32:21.155]                       inherits <- base::inherits
[09:32:21.155]                       invokeRestart <- base::invokeRestart
[09:32:21.155]                       is.null <- base::is.null
[09:32:21.155]                       muffled <- FALSE
[09:32:21.155]                       if (inherits(cond, "message")) {
[09:32:21.155]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.155]                         if (muffled) 
[09:32:21.155]                           invokeRestart("muffleMessage")
[09:32:21.155]                       }
[09:32:21.155]                       else if (inherits(cond, "warning")) {
[09:32:21.155]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.155]                         if (muffled) 
[09:32:21.155]                           invokeRestart("muffleWarning")
[09:32:21.155]                       }
[09:32:21.155]                       else if (inherits(cond, "condition")) {
[09:32:21.155]                         if (!is.null(pattern)) {
[09:32:21.155]                           computeRestarts <- base::computeRestarts
[09:32:21.155]                           grepl <- base::grepl
[09:32:21.155]                           restarts <- computeRestarts(cond)
[09:32:21.155]                           for (restart in restarts) {
[09:32:21.155]                             name <- restart$name
[09:32:21.155]                             if (is.null(name)) 
[09:32:21.155]                               next
[09:32:21.155]                             if (!grepl(pattern, name)) 
[09:32:21.155]                               next
[09:32:21.155]                             invokeRestart(restart)
[09:32:21.155]                             muffled <- TRUE
[09:32:21.155]                             break
[09:32:21.155]                           }
[09:32:21.155]                         }
[09:32:21.155]                       }
[09:32:21.155]                       invisible(muffled)
[09:32:21.155]                     }
[09:32:21.155]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.155]                   }
[09:32:21.155]                 }
[09:32:21.155]                 else {
[09:32:21.155]                   if (TRUE) {
[09:32:21.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.155]                     {
[09:32:21.155]                       inherits <- base::inherits
[09:32:21.155]                       invokeRestart <- base::invokeRestart
[09:32:21.155]                       is.null <- base::is.null
[09:32:21.155]                       muffled <- FALSE
[09:32:21.155]                       if (inherits(cond, "message")) {
[09:32:21.155]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.155]                         if (muffled) 
[09:32:21.155]                           invokeRestart("muffleMessage")
[09:32:21.155]                       }
[09:32:21.155]                       else if (inherits(cond, "warning")) {
[09:32:21.155]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.155]                         if (muffled) 
[09:32:21.155]                           invokeRestart("muffleWarning")
[09:32:21.155]                       }
[09:32:21.155]                       else if (inherits(cond, "condition")) {
[09:32:21.155]                         if (!is.null(pattern)) {
[09:32:21.155]                           computeRestarts <- base::computeRestarts
[09:32:21.155]                           grepl <- base::grepl
[09:32:21.155]                           restarts <- computeRestarts(cond)
[09:32:21.155]                           for (restart in restarts) {
[09:32:21.155]                             name <- restart$name
[09:32:21.155]                             if (is.null(name)) 
[09:32:21.155]                               next
[09:32:21.155]                             if (!grepl(pattern, name)) 
[09:32:21.155]                               next
[09:32:21.155]                             invokeRestart(restart)
[09:32:21.155]                             muffled <- TRUE
[09:32:21.155]                             break
[09:32:21.155]                           }
[09:32:21.155]                         }
[09:32:21.155]                       }
[09:32:21.155]                       invisible(muffled)
[09:32:21.155]                     }
[09:32:21.155]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.155]                   }
[09:32:21.155]                 }
[09:32:21.155]             }
[09:32:21.155]         }))
[09:32:21.155]     }, error = function(ex) {
[09:32:21.155]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.155]                 ...future.rng), started = ...future.startTime, 
[09:32:21.155]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.155]             version = "1.8"), class = "FutureResult")
[09:32:21.155]     }, finally = {
[09:32:21.155]         if (!identical(...future.workdir, getwd())) 
[09:32:21.155]             setwd(...future.workdir)
[09:32:21.155]         {
[09:32:21.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.155]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.155]             }
[09:32:21.155]             base::options(...future.oldOptions)
[09:32:21.155]             if (.Platform$OS.type == "windows") {
[09:32:21.155]                 old_names <- names(...future.oldEnvVars)
[09:32:21.155]                 envs <- base::Sys.getenv()
[09:32:21.155]                 names <- names(envs)
[09:32:21.155]                 common <- intersect(names, old_names)
[09:32:21.155]                 added <- setdiff(names, old_names)
[09:32:21.155]                 removed <- setdiff(old_names, names)
[09:32:21.155]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.155]                   envs[common]]
[09:32:21.155]                 NAMES <- toupper(changed)
[09:32:21.155]                 args <- list()
[09:32:21.155]                 for (kk in seq_along(NAMES)) {
[09:32:21.155]                   name <- changed[[kk]]
[09:32:21.155]                   NAME <- NAMES[[kk]]
[09:32:21.155]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.155]                     next
[09:32:21.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.155]                 }
[09:32:21.155]                 NAMES <- toupper(added)
[09:32:21.155]                 for (kk in seq_along(NAMES)) {
[09:32:21.155]                   name <- added[[kk]]
[09:32:21.155]                   NAME <- NAMES[[kk]]
[09:32:21.155]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.155]                     next
[09:32:21.155]                   args[[name]] <- ""
[09:32:21.155]                 }
[09:32:21.155]                 NAMES <- toupper(removed)
[09:32:21.155]                 for (kk in seq_along(NAMES)) {
[09:32:21.155]                   name <- removed[[kk]]
[09:32:21.155]                   NAME <- NAMES[[kk]]
[09:32:21.155]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.155]                     next
[09:32:21.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.155]                 }
[09:32:21.155]                 if (length(args) > 0) 
[09:32:21.155]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.155]             }
[09:32:21.155]             else {
[09:32:21.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.155]             }
[09:32:21.155]             {
[09:32:21.155]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.155]                   0L) {
[09:32:21.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.155]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.155]                   base::options(opts)
[09:32:21.155]                 }
[09:32:21.155]                 {
[09:32:21.155]                   {
[09:32:21.155]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.155]                     NULL
[09:32:21.155]                   }
[09:32:21.155]                   options(future.plan = NULL)
[09:32:21.155]                   if (is.na(NA_character_)) 
[09:32:21.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.155]                     .init = FALSE)
[09:32:21.155]                 }
[09:32:21.155]             }
[09:32:21.155]         }
[09:32:21.155]     })
[09:32:21.155]     if (TRUE) {
[09:32:21.155]         base::sink(type = "output", split = FALSE)
[09:32:21.155]         if (TRUE) {
[09:32:21.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.155]         }
[09:32:21.155]         else {
[09:32:21.155]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.155]         }
[09:32:21.155]         base::close(...future.stdout)
[09:32:21.155]         ...future.stdout <- NULL
[09:32:21.155]     }
[09:32:21.155]     ...future.result$conditions <- ...future.conditions
[09:32:21.155]     ...future.result$finished <- base::Sys.time()
[09:32:21.155]     ...future.result
[09:32:21.155] }
[09:32:21.159] requestCore(): workers = 2
[09:32:21.159] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.170] result() for MulticoreFuture ...
[09:32:21.171] result() for MulticoreFuture ...
[09:32:21.171] result() for MulticoreFuture ... done
[09:32:21.171] result() for MulticoreFuture ... done
[09:32:21.171] result() for MulticoreFuture ...
[09:32:21.172] result() for MulticoreFuture ... done
[09:32:21.174] MulticoreFuture started
[09:32:21.175] - Launch lazy future ... done
[09:32:21.175] run() for ‘MulticoreFuture’ ... done
[09:32:21.175] plan(): Setting new future strategy stack:
[09:32:21.175] List of future strategies:
[09:32:21.175] 1. sequential:
[09:32:21.175]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.175]    - tweaked: FALSE
[09:32:21.175]    - call: NULL
[09:32:21.176] resolve() on environment ...
[09:32:21.176] plan(): nbrOfWorkers() = 1
[09:32:21.176]  recursive: 0
[09:32:21.177]  elements: [3] ‘a’, ‘b’, ‘c’
[09:32:21.178] Future #1
[09:32:21.178]  length: 2 (resolved future 1)
[09:32:21.178] plan(): Setting new future strategy stack:
[09:32:21.179] List of future strategies:
[09:32:21.179] 1. multicore:
[09:32:21.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.179]    - tweaked: FALSE
[09:32:21.179]    - call: plan(strategy)
[09:32:21.183] plan(): nbrOfWorkers() = 2
[09:32:21.184] Future #2
[09:32:21.184]  length: 1 (resolved future 2)
[09:32:21.184]  length: 0 (resolved future 3)
[09:32:21.184] resolve() on environment ... DONE
[09:32:21.185] getGlobalsAndPackages() ...
[09:32:21.186] Searching for globals...
[09:32:21.187] - globals found: [1] ‘{’
[09:32:21.187] Searching for globals ... DONE
[09:32:21.187] Resolving globals: FALSE
[09:32:21.188] 
[09:32:21.188] 
[09:32:21.188] getGlobalsAndPackages() ... DONE
[09:32:21.188] run() for ‘Future’ ...
[09:32:21.189] - state: ‘created’
[09:32:21.189] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.194]   - Field: ‘label’
[09:32:21.194]   - Field: ‘local’
[09:32:21.194]   - Field: ‘owner’
[09:32:21.194]   - Field: ‘envir’
[09:32:21.194]   - Field: ‘workers’
[09:32:21.194]   - Field: ‘packages’
[09:32:21.194]   - Field: ‘gc’
[09:32:21.195]   - Field: ‘job’
[09:32:21.195]   - Field: ‘conditions’
[09:32:21.195]   - Field: ‘expr’
[09:32:21.195]   - Field: ‘uuid’
[09:32:21.195]   - Field: ‘seed’
[09:32:21.195]   - Field: ‘version’
[09:32:21.195]   - Field: ‘result’
[09:32:21.196]   - Field: ‘asynchronous’
[09:32:21.196]   - Field: ‘calls’
[09:32:21.196]   - Field: ‘globals’
[09:32:21.196]   - Field: ‘stdout’
[09:32:21.196]   - Field: ‘earlySignal’
[09:32:21.196]   - Field: ‘lazy’
[09:32:21.196]   - Field: ‘state’
[09:32:21.197] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.197] - Launch lazy future ...
[09:32:21.201] Packages needed by the future expression (n = 0): <none>
[09:32:21.201] Packages needed by future strategies (n = 0): <none>
[09:32:21.203] {
[09:32:21.203]     {
[09:32:21.203]         {
[09:32:21.203]             ...future.startTime <- base::Sys.time()
[09:32:21.203]             {
[09:32:21.203]                 {
[09:32:21.203]                   {
[09:32:21.203]                     {
[09:32:21.203]                       base::local({
[09:32:21.203]                         has_future <- base::requireNamespace("future", 
[09:32:21.203]                           quietly = TRUE)
[09:32:21.203]                         if (has_future) {
[09:32:21.203]                           ns <- base::getNamespace("future")
[09:32:21.203]                           version <- ns[[".package"]][["version"]]
[09:32:21.203]                           if (is.null(version)) 
[09:32:21.203]                             version <- utils::packageVersion("future")
[09:32:21.203]                         }
[09:32:21.203]                         else {
[09:32:21.203]                           version <- NULL
[09:32:21.203]                         }
[09:32:21.203]                         if (!has_future || version < "1.8.0") {
[09:32:21.203]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.203]                             "", base::R.version$version.string), 
[09:32:21.203]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.203]                               "release", "version")], collapse = " "), 
[09:32:21.203]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.203]                             info)
[09:32:21.203]                           info <- base::paste(info, collapse = "; ")
[09:32:21.203]                           if (!has_future) {
[09:32:21.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.203]                               info)
[09:32:21.203]                           }
[09:32:21.203]                           else {
[09:32:21.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.203]                               info, version)
[09:32:21.203]                           }
[09:32:21.203]                           base::stop(msg)
[09:32:21.203]                         }
[09:32:21.203]                       })
[09:32:21.203]                     }
[09:32:21.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.203]                     base::options(mc.cores = 1L)
[09:32:21.203]                   }
[09:32:21.203]                   ...future.strategy.old <- future::plan("list")
[09:32:21.203]                   options(future.plan = NULL)
[09:32:21.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.203]                 }
[09:32:21.203]                 ...future.workdir <- getwd()
[09:32:21.203]             }
[09:32:21.203]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.203]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.203]         }
[09:32:21.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.203]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.203]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.203]             base::names(...future.oldOptions))
[09:32:21.203]     }
[09:32:21.203]     if (FALSE) {
[09:32:21.203]     }
[09:32:21.203]     else {
[09:32:21.203]         if (TRUE) {
[09:32:21.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.203]                 open = "w")
[09:32:21.203]         }
[09:32:21.203]         else {
[09:32:21.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.203]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.203]         }
[09:32:21.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.203]             base::sink(type = "output", split = FALSE)
[09:32:21.203]             base::close(...future.stdout)
[09:32:21.203]         }, add = TRUE)
[09:32:21.203]     }
[09:32:21.203]     ...future.frame <- base::sys.nframe()
[09:32:21.203]     ...future.conditions <- base::list()
[09:32:21.203]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.203]     if (FALSE) {
[09:32:21.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.203]     }
[09:32:21.203]     ...future.result <- base::tryCatch({
[09:32:21.203]         base::withCallingHandlers({
[09:32:21.203]             ...future.value <- base::withVisible(base::local({
[09:32:21.203]                 withCallingHandlers({
[09:32:21.203]                   {
[09:32:21.203]                     1
[09:32:21.203]                   }
[09:32:21.203]                 }, immediateCondition = function(cond) {
[09:32:21.203]                   save_rds <- function (object, pathname, ...) 
[09:32:21.203]                   {
[09:32:21.203]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.203]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.203]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.203]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.203]                         fi_tmp[["mtime"]])
[09:32:21.203]                     }
[09:32:21.203]                     tryCatch({
[09:32:21.203]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.203]                     }, error = function(ex) {
[09:32:21.203]                       msg <- conditionMessage(ex)
[09:32:21.203]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.203]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.203]                         fi_tmp[["mtime"]], msg)
[09:32:21.203]                       ex$message <- msg
[09:32:21.203]                       stop(ex)
[09:32:21.203]                     })
[09:32:21.203]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.203]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.203]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.203]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.203]                       fi <- file.info(pathname)
[09:32:21.203]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.203]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.203]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.203]                         fi[["size"]], fi[["mtime"]])
[09:32:21.203]                       stop(msg)
[09:32:21.203]                     }
[09:32:21.203]                     invisible(pathname)
[09:32:21.203]                   }
[09:32:21.203]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.203]                     rootPath = tempdir()) 
[09:32:21.203]                   {
[09:32:21.203]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.203]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.203]                       tmpdir = path, fileext = ".rds")
[09:32:21.203]                     save_rds(obj, file)
[09:32:21.203]                   }
[09:32:21.203]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.203]                   {
[09:32:21.203]                     inherits <- base::inherits
[09:32:21.203]                     invokeRestart <- base::invokeRestart
[09:32:21.203]                     is.null <- base::is.null
[09:32:21.203]                     muffled <- FALSE
[09:32:21.203]                     if (inherits(cond, "message")) {
[09:32:21.203]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.203]                       if (muffled) 
[09:32:21.203]                         invokeRestart("muffleMessage")
[09:32:21.203]                     }
[09:32:21.203]                     else if (inherits(cond, "warning")) {
[09:32:21.203]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.203]                       if (muffled) 
[09:32:21.203]                         invokeRestart("muffleWarning")
[09:32:21.203]                     }
[09:32:21.203]                     else if (inherits(cond, "condition")) {
[09:32:21.203]                       if (!is.null(pattern)) {
[09:32:21.203]                         computeRestarts <- base::computeRestarts
[09:32:21.203]                         grepl <- base::grepl
[09:32:21.203]                         restarts <- computeRestarts(cond)
[09:32:21.203]                         for (restart in restarts) {
[09:32:21.203]                           name <- restart$name
[09:32:21.203]                           if (is.null(name)) 
[09:32:21.203]                             next
[09:32:21.203]                           if (!grepl(pattern, name)) 
[09:32:21.203]                             next
[09:32:21.203]                           invokeRestart(restart)
[09:32:21.203]                           muffled <- TRUE
[09:32:21.203]                           break
[09:32:21.203]                         }
[09:32:21.203]                       }
[09:32:21.203]                     }
[09:32:21.203]                     invisible(muffled)
[09:32:21.203]                   }
[09:32:21.203]                   muffleCondition(cond)
[09:32:21.203]                 })
[09:32:21.203]             }))
[09:32:21.203]             future::FutureResult(value = ...future.value$value, 
[09:32:21.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.203]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.203]                     ...future.globalenv.names))
[09:32:21.203]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.203]         }, condition = base::local({
[09:32:21.203]             c <- base::c
[09:32:21.203]             inherits <- base::inherits
[09:32:21.203]             invokeRestart <- base::invokeRestart
[09:32:21.203]             length <- base::length
[09:32:21.203]             list <- base::list
[09:32:21.203]             seq.int <- base::seq.int
[09:32:21.203]             signalCondition <- base::signalCondition
[09:32:21.203]             sys.calls <- base::sys.calls
[09:32:21.203]             `[[` <- base::`[[`
[09:32:21.203]             `+` <- base::`+`
[09:32:21.203]             `<<-` <- base::`<<-`
[09:32:21.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.203]                   3L)]
[09:32:21.203]             }
[09:32:21.203]             function(cond) {
[09:32:21.203]                 is_error <- inherits(cond, "error")
[09:32:21.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.203]                   NULL)
[09:32:21.203]                 if (is_error) {
[09:32:21.203]                   sessionInformation <- function() {
[09:32:21.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.203]                       search = base::search(), system = base::Sys.info())
[09:32:21.203]                   }
[09:32:21.203]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.203]                     cond$call), session = sessionInformation(), 
[09:32:21.203]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.203]                   signalCondition(cond)
[09:32:21.203]                 }
[09:32:21.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.203]                 "immediateCondition"))) {
[09:32:21.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.203]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.203]                   if (TRUE && !signal) {
[09:32:21.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.203]                     {
[09:32:21.203]                       inherits <- base::inherits
[09:32:21.203]                       invokeRestart <- base::invokeRestart
[09:32:21.203]                       is.null <- base::is.null
[09:32:21.203]                       muffled <- FALSE
[09:32:21.203]                       if (inherits(cond, "message")) {
[09:32:21.203]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.203]                         if (muffled) 
[09:32:21.203]                           invokeRestart("muffleMessage")
[09:32:21.203]                       }
[09:32:21.203]                       else if (inherits(cond, "warning")) {
[09:32:21.203]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.203]                         if (muffled) 
[09:32:21.203]                           invokeRestart("muffleWarning")
[09:32:21.203]                       }
[09:32:21.203]                       else if (inherits(cond, "condition")) {
[09:32:21.203]                         if (!is.null(pattern)) {
[09:32:21.203]                           computeRestarts <- base::computeRestarts
[09:32:21.203]                           grepl <- base::grepl
[09:32:21.203]                           restarts <- computeRestarts(cond)
[09:32:21.203]                           for (restart in restarts) {
[09:32:21.203]                             name <- restart$name
[09:32:21.203]                             if (is.null(name)) 
[09:32:21.203]                               next
[09:32:21.203]                             if (!grepl(pattern, name)) 
[09:32:21.203]                               next
[09:32:21.203]                             invokeRestart(restart)
[09:32:21.203]                             muffled <- TRUE
[09:32:21.203]                             break
[09:32:21.203]                           }
[09:32:21.203]                         }
[09:32:21.203]                       }
[09:32:21.203]                       invisible(muffled)
[09:32:21.203]                     }
[09:32:21.203]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.203]                   }
[09:32:21.203]                 }
[09:32:21.203]                 else {
[09:32:21.203]                   if (TRUE) {
[09:32:21.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.203]                     {
[09:32:21.203]                       inherits <- base::inherits
[09:32:21.203]                       invokeRestart <- base::invokeRestart
[09:32:21.203]                       is.null <- base::is.null
[09:32:21.203]                       muffled <- FALSE
[09:32:21.203]                       if (inherits(cond, "message")) {
[09:32:21.203]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.203]                         if (muffled) 
[09:32:21.203]                           invokeRestart("muffleMessage")
[09:32:21.203]                       }
[09:32:21.203]                       else if (inherits(cond, "warning")) {
[09:32:21.203]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.203]                         if (muffled) 
[09:32:21.203]                           invokeRestart("muffleWarning")
[09:32:21.203]                       }
[09:32:21.203]                       else if (inherits(cond, "condition")) {
[09:32:21.203]                         if (!is.null(pattern)) {
[09:32:21.203]                           computeRestarts <- base::computeRestarts
[09:32:21.203]                           grepl <- base::grepl
[09:32:21.203]                           restarts <- computeRestarts(cond)
[09:32:21.203]                           for (restart in restarts) {
[09:32:21.203]                             name <- restart$name
[09:32:21.203]                             if (is.null(name)) 
[09:32:21.203]                               next
[09:32:21.203]                             if (!grepl(pattern, name)) 
[09:32:21.203]                               next
[09:32:21.203]                             invokeRestart(restart)
[09:32:21.203]                             muffled <- TRUE
[09:32:21.203]                             break
[09:32:21.203]                           }
[09:32:21.203]                         }
[09:32:21.203]                       }
[09:32:21.203]                       invisible(muffled)
[09:32:21.203]                     }
[09:32:21.203]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.203]                   }
[09:32:21.203]                 }
[09:32:21.203]             }
[09:32:21.203]         }))
[09:32:21.203]     }, error = function(ex) {
[09:32:21.203]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.203]                 ...future.rng), started = ...future.startTime, 
[09:32:21.203]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.203]             version = "1.8"), class = "FutureResult")
[09:32:21.203]     }, finally = {
[09:32:21.203]         if (!identical(...future.workdir, getwd())) 
[09:32:21.203]             setwd(...future.workdir)
[09:32:21.203]         {
[09:32:21.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.203]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.203]             }
[09:32:21.203]             base::options(...future.oldOptions)
[09:32:21.203]             if (.Platform$OS.type == "windows") {
[09:32:21.203]                 old_names <- names(...future.oldEnvVars)
[09:32:21.203]                 envs <- base::Sys.getenv()
[09:32:21.203]                 names <- names(envs)
[09:32:21.203]                 common <- intersect(names, old_names)
[09:32:21.203]                 added <- setdiff(names, old_names)
[09:32:21.203]                 removed <- setdiff(old_names, names)
[09:32:21.203]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.203]                   envs[common]]
[09:32:21.203]                 NAMES <- toupper(changed)
[09:32:21.203]                 args <- list()
[09:32:21.203]                 for (kk in seq_along(NAMES)) {
[09:32:21.203]                   name <- changed[[kk]]
[09:32:21.203]                   NAME <- NAMES[[kk]]
[09:32:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.203]                     next
[09:32:21.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.203]                 }
[09:32:21.203]                 NAMES <- toupper(added)
[09:32:21.203]                 for (kk in seq_along(NAMES)) {
[09:32:21.203]                   name <- added[[kk]]
[09:32:21.203]                   NAME <- NAMES[[kk]]
[09:32:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.203]                     next
[09:32:21.203]                   args[[name]] <- ""
[09:32:21.203]                 }
[09:32:21.203]                 NAMES <- toupper(removed)
[09:32:21.203]                 for (kk in seq_along(NAMES)) {
[09:32:21.203]                   name <- removed[[kk]]
[09:32:21.203]                   NAME <- NAMES[[kk]]
[09:32:21.203]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.203]                     next
[09:32:21.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.203]                 }
[09:32:21.203]                 if (length(args) > 0) 
[09:32:21.203]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.203]             }
[09:32:21.203]             else {
[09:32:21.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.203]             }
[09:32:21.203]             {
[09:32:21.203]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.203]                   0L) {
[09:32:21.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.203]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.203]                   base::options(opts)
[09:32:21.203]                 }
[09:32:21.203]                 {
[09:32:21.203]                   {
[09:32:21.203]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.203]                     NULL
[09:32:21.203]                   }
[09:32:21.203]                   options(future.plan = NULL)
[09:32:21.203]                   if (is.na(NA_character_)) 
[09:32:21.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.203]                     .init = FALSE)
[09:32:21.203]                 }
[09:32:21.203]             }
[09:32:21.203]         }
[09:32:21.203]     })
[09:32:21.203]     if (TRUE) {
[09:32:21.203]         base::sink(type = "output", split = FALSE)
[09:32:21.203]         if (TRUE) {
[09:32:21.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.203]         }
[09:32:21.203]         else {
[09:32:21.203]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.203]         }
[09:32:21.203]         base::close(...future.stdout)
[09:32:21.203]         ...future.stdout <- NULL
[09:32:21.203]     }
[09:32:21.203]     ...future.result$conditions <- ...future.conditions
[09:32:21.203]     ...future.result$finished <- base::Sys.time()
[09:32:21.203]     ...future.result
[09:32:21.203] }
[09:32:21.205] requestCore(): workers = 2
[09:32:21.206] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.217] result() for MulticoreFuture ...
[09:32:21.218] result() for MulticoreFuture ...
[09:32:21.218] result() for MulticoreFuture ... done
[09:32:21.218] result() for MulticoreFuture ... done
[09:32:21.218] result() for MulticoreFuture ...
[09:32:21.218] result() for MulticoreFuture ... done
[09:32:21.221] MulticoreFuture started
[09:32:21.221] - Launch lazy future ... done
[09:32:21.222] run() for ‘MulticoreFuture’ ... done
[09:32:21.222] plan(): Setting new future strategy stack:
[09:32:21.223] getGlobalsAndPackages() ...
[09:32:21.223] List of future strategies:
[09:32:21.223] 1. sequential:
[09:32:21.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.223]    - tweaked: FALSE
[09:32:21.223]    - call: NULL
[09:32:21.224] Searching for globals...
[09:32:21.224] plan(): nbrOfWorkers() = 1
[09:32:21.226] - globals found: [1] ‘{’
[09:32:21.227] Searching for globals ... DONE
[09:32:21.227] Resolving globals: FALSE
[09:32:21.227] plan(): Setting new future strategy stack:
[09:32:21.228] 
[09:32:21.228] 
[09:32:21.227] List of future strategies:
[09:32:21.227] 1. multicore:
[09:32:21.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.227]    - tweaked: FALSE
[09:32:21.227]    - call: plan(strategy)
[09:32:21.228] getGlobalsAndPackages() ... DONE
[09:32:21.229] run() for ‘Future’ ...
[09:32:21.229] - state: ‘created’
[09:32:21.229] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.234] plan(): nbrOfWorkers() = 2
[09:32:21.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.235]   - Field: ‘label’
[09:32:21.235]   - Field: ‘local’
[09:32:21.236]   - Field: ‘owner’
[09:32:21.236]   - Field: ‘envir’
[09:32:21.236]   - Field: ‘workers’
[09:32:21.236]   - Field: ‘packages’
[09:32:21.236]   - Field: ‘gc’
[09:32:21.236]   - Field: ‘job’
[09:32:21.236]   - Field: ‘conditions’
[09:32:21.237]   - Field: ‘expr’
[09:32:21.237]   - Field: ‘uuid’
[09:32:21.237]   - Field: ‘seed’
[09:32:21.237]   - Field: ‘version’
[09:32:21.237]   - Field: ‘result’
[09:32:21.237]   - Field: ‘asynchronous’
[09:32:21.237]   - Field: ‘calls’
[09:32:21.238]   - Field: ‘globals’
[09:32:21.238]   - Field: ‘stdout’
[09:32:21.238]   - Field: ‘earlySignal’
[09:32:21.238]   - Field: ‘lazy’
[09:32:21.238]   - Field: ‘state’
[09:32:21.238] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.238] - Launch lazy future ...
[09:32:21.239] Packages needed by the future expression (n = 0): <none>
[09:32:21.239] Packages needed by future strategies (n = 0): <none>
[09:32:21.240] {
[09:32:21.240]     {
[09:32:21.240]         {
[09:32:21.240]             ...future.startTime <- base::Sys.time()
[09:32:21.240]             {
[09:32:21.240]                 {
[09:32:21.240]                   {
[09:32:21.240]                     {
[09:32:21.240]                       base::local({
[09:32:21.240]                         has_future <- base::requireNamespace("future", 
[09:32:21.240]                           quietly = TRUE)
[09:32:21.240]                         if (has_future) {
[09:32:21.240]                           ns <- base::getNamespace("future")
[09:32:21.240]                           version <- ns[[".package"]][["version"]]
[09:32:21.240]                           if (is.null(version)) 
[09:32:21.240]                             version <- utils::packageVersion("future")
[09:32:21.240]                         }
[09:32:21.240]                         else {
[09:32:21.240]                           version <- NULL
[09:32:21.240]                         }
[09:32:21.240]                         if (!has_future || version < "1.8.0") {
[09:32:21.240]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.240]                             "", base::R.version$version.string), 
[09:32:21.240]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.240]                               "release", "version")], collapse = " "), 
[09:32:21.240]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.240]                             info)
[09:32:21.240]                           info <- base::paste(info, collapse = "; ")
[09:32:21.240]                           if (!has_future) {
[09:32:21.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.240]                               info)
[09:32:21.240]                           }
[09:32:21.240]                           else {
[09:32:21.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.240]                               info, version)
[09:32:21.240]                           }
[09:32:21.240]                           base::stop(msg)
[09:32:21.240]                         }
[09:32:21.240]                       })
[09:32:21.240]                     }
[09:32:21.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.240]                     base::options(mc.cores = 1L)
[09:32:21.240]                   }
[09:32:21.240]                   ...future.strategy.old <- future::plan("list")
[09:32:21.240]                   options(future.plan = NULL)
[09:32:21.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.240]                 }
[09:32:21.240]                 ...future.workdir <- getwd()
[09:32:21.240]             }
[09:32:21.240]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.240]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.240]         }
[09:32:21.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.240]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.240]             base::names(...future.oldOptions))
[09:32:21.240]     }
[09:32:21.240]     if (FALSE) {
[09:32:21.240]     }
[09:32:21.240]     else {
[09:32:21.240]         if (TRUE) {
[09:32:21.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.240]                 open = "w")
[09:32:21.240]         }
[09:32:21.240]         else {
[09:32:21.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.240]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.240]         }
[09:32:21.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.240]             base::sink(type = "output", split = FALSE)
[09:32:21.240]             base::close(...future.stdout)
[09:32:21.240]         }, add = TRUE)
[09:32:21.240]     }
[09:32:21.240]     ...future.frame <- base::sys.nframe()
[09:32:21.240]     ...future.conditions <- base::list()
[09:32:21.240]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.240]     if (FALSE) {
[09:32:21.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.240]     }
[09:32:21.240]     ...future.result <- base::tryCatch({
[09:32:21.240]         base::withCallingHandlers({
[09:32:21.240]             ...future.value <- base::withVisible(base::local({
[09:32:21.240]                 withCallingHandlers({
[09:32:21.240]                   {
[09:32:21.240]                     2
[09:32:21.240]                   }
[09:32:21.240]                 }, immediateCondition = function(cond) {
[09:32:21.240]                   save_rds <- function (object, pathname, ...) 
[09:32:21.240]                   {
[09:32:21.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.240]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.240]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.240]                         fi_tmp[["mtime"]])
[09:32:21.240]                     }
[09:32:21.240]                     tryCatch({
[09:32:21.240]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.240]                     }, error = function(ex) {
[09:32:21.240]                       msg <- conditionMessage(ex)
[09:32:21.240]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.240]                         fi_tmp[["mtime"]], msg)
[09:32:21.240]                       ex$message <- msg
[09:32:21.240]                       stop(ex)
[09:32:21.240]                     })
[09:32:21.240]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.240]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.240]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.240]                       fi <- file.info(pathname)
[09:32:21.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.240]                         fi[["size"]], fi[["mtime"]])
[09:32:21.240]                       stop(msg)
[09:32:21.240]                     }
[09:32:21.240]                     invisible(pathname)
[09:32:21.240]                   }
[09:32:21.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.240]                     rootPath = tempdir()) 
[09:32:21.240]                   {
[09:32:21.240]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.240]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.240]                       tmpdir = path, fileext = ".rds")
[09:32:21.240]                     save_rds(obj, file)
[09:32:21.240]                   }
[09:32:21.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.240]                   {
[09:32:21.240]                     inherits <- base::inherits
[09:32:21.240]                     invokeRestart <- base::invokeRestart
[09:32:21.240]                     is.null <- base::is.null
[09:32:21.240]                     muffled <- FALSE
[09:32:21.240]                     if (inherits(cond, "message")) {
[09:32:21.240]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.240]                       if (muffled) 
[09:32:21.240]                         invokeRestart("muffleMessage")
[09:32:21.240]                     }
[09:32:21.240]                     else if (inherits(cond, "warning")) {
[09:32:21.240]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.240]                       if (muffled) 
[09:32:21.240]                         invokeRestart("muffleWarning")
[09:32:21.240]                     }
[09:32:21.240]                     else if (inherits(cond, "condition")) {
[09:32:21.240]                       if (!is.null(pattern)) {
[09:32:21.240]                         computeRestarts <- base::computeRestarts
[09:32:21.240]                         grepl <- base::grepl
[09:32:21.240]                         restarts <- computeRestarts(cond)
[09:32:21.240]                         for (restart in restarts) {
[09:32:21.240]                           name <- restart$name
[09:32:21.240]                           if (is.null(name)) 
[09:32:21.240]                             next
[09:32:21.240]                           if (!grepl(pattern, name)) 
[09:32:21.240]                             next
[09:32:21.240]                           invokeRestart(restart)
[09:32:21.240]                           muffled <- TRUE
[09:32:21.240]                           break
[09:32:21.240]                         }
[09:32:21.240]                       }
[09:32:21.240]                     }
[09:32:21.240]                     invisible(muffled)
[09:32:21.240]                   }
[09:32:21.240]                   muffleCondition(cond)
[09:32:21.240]                 })
[09:32:21.240]             }))
[09:32:21.240]             future::FutureResult(value = ...future.value$value, 
[09:32:21.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.240]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.240]                     ...future.globalenv.names))
[09:32:21.240]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.240]         }, condition = base::local({
[09:32:21.240]             c <- base::c
[09:32:21.240]             inherits <- base::inherits
[09:32:21.240]             invokeRestart <- base::invokeRestart
[09:32:21.240]             length <- base::length
[09:32:21.240]             list <- base::list
[09:32:21.240]             seq.int <- base::seq.int
[09:32:21.240]             signalCondition <- base::signalCondition
[09:32:21.240]             sys.calls <- base::sys.calls
[09:32:21.240]             `[[` <- base::`[[`
[09:32:21.240]             `+` <- base::`+`
[09:32:21.240]             `<<-` <- base::`<<-`
[09:32:21.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.240]                   3L)]
[09:32:21.240]             }
[09:32:21.240]             function(cond) {
[09:32:21.240]                 is_error <- inherits(cond, "error")
[09:32:21.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.240]                   NULL)
[09:32:21.240]                 if (is_error) {
[09:32:21.240]                   sessionInformation <- function() {
[09:32:21.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.240]                       search = base::search(), system = base::Sys.info())
[09:32:21.240]                   }
[09:32:21.240]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.240]                     cond$call), session = sessionInformation(), 
[09:32:21.240]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.240]                   signalCondition(cond)
[09:32:21.240]                 }
[09:32:21.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.240]                 "immediateCondition"))) {
[09:32:21.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.240]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.240]                   if (TRUE && !signal) {
[09:32:21.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.240]                     {
[09:32:21.240]                       inherits <- base::inherits
[09:32:21.240]                       invokeRestart <- base::invokeRestart
[09:32:21.240]                       is.null <- base::is.null
[09:32:21.240]                       muffled <- FALSE
[09:32:21.240]                       if (inherits(cond, "message")) {
[09:32:21.240]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.240]                         if (muffled) 
[09:32:21.240]                           invokeRestart("muffleMessage")
[09:32:21.240]                       }
[09:32:21.240]                       else if (inherits(cond, "warning")) {
[09:32:21.240]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.240]                         if (muffled) 
[09:32:21.240]                           invokeRestart("muffleWarning")
[09:32:21.240]                       }
[09:32:21.240]                       else if (inherits(cond, "condition")) {
[09:32:21.240]                         if (!is.null(pattern)) {
[09:32:21.240]                           computeRestarts <- base::computeRestarts
[09:32:21.240]                           grepl <- base::grepl
[09:32:21.240]                           restarts <- computeRestarts(cond)
[09:32:21.240]                           for (restart in restarts) {
[09:32:21.240]                             name <- restart$name
[09:32:21.240]                             if (is.null(name)) 
[09:32:21.240]                               next
[09:32:21.240]                             if (!grepl(pattern, name)) 
[09:32:21.240]                               next
[09:32:21.240]                             invokeRestart(restart)
[09:32:21.240]                             muffled <- TRUE
[09:32:21.240]                             break
[09:32:21.240]                           }
[09:32:21.240]                         }
[09:32:21.240]                       }
[09:32:21.240]                       invisible(muffled)
[09:32:21.240]                     }
[09:32:21.240]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.240]                   }
[09:32:21.240]                 }
[09:32:21.240]                 else {
[09:32:21.240]                   if (TRUE) {
[09:32:21.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.240]                     {
[09:32:21.240]                       inherits <- base::inherits
[09:32:21.240]                       invokeRestart <- base::invokeRestart
[09:32:21.240]                       is.null <- base::is.null
[09:32:21.240]                       muffled <- FALSE
[09:32:21.240]                       if (inherits(cond, "message")) {
[09:32:21.240]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.240]                         if (muffled) 
[09:32:21.240]                           invokeRestart("muffleMessage")
[09:32:21.240]                       }
[09:32:21.240]                       else if (inherits(cond, "warning")) {
[09:32:21.240]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.240]                         if (muffled) 
[09:32:21.240]                           invokeRestart("muffleWarning")
[09:32:21.240]                       }
[09:32:21.240]                       else if (inherits(cond, "condition")) {
[09:32:21.240]                         if (!is.null(pattern)) {
[09:32:21.240]                           computeRestarts <- base::computeRestarts
[09:32:21.240]                           grepl <- base::grepl
[09:32:21.240]                           restarts <- computeRestarts(cond)
[09:32:21.240]                           for (restart in restarts) {
[09:32:21.240]                             name <- restart$name
[09:32:21.240]                             if (is.null(name)) 
[09:32:21.240]                               next
[09:32:21.240]                             if (!grepl(pattern, name)) 
[09:32:21.240]                               next
[09:32:21.240]                             invokeRestart(restart)
[09:32:21.240]                             muffled <- TRUE
[09:32:21.240]                             break
[09:32:21.240]                           }
[09:32:21.240]                         }
[09:32:21.240]                       }
[09:32:21.240]                       invisible(muffled)
[09:32:21.240]                     }
[09:32:21.240]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.240]                   }
[09:32:21.240]                 }
[09:32:21.240]             }
[09:32:21.240]         }))
[09:32:21.240]     }, error = function(ex) {
[09:32:21.240]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.240]                 ...future.rng), started = ...future.startTime, 
[09:32:21.240]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.240]             version = "1.8"), class = "FutureResult")
[09:32:21.240]     }, finally = {
[09:32:21.240]         if (!identical(...future.workdir, getwd())) 
[09:32:21.240]             setwd(...future.workdir)
[09:32:21.240]         {
[09:32:21.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.240]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.240]             }
[09:32:21.240]             base::options(...future.oldOptions)
[09:32:21.240]             if (.Platform$OS.type == "windows") {
[09:32:21.240]                 old_names <- names(...future.oldEnvVars)
[09:32:21.240]                 envs <- base::Sys.getenv()
[09:32:21.240]                 names <- names(envs)
[09:32:21.240]                 common <- intersect(names, old_names)
[09:32:21.240]                 added <- setdiff(names, old_names)
[09:32:21.240]                 removed <- setdiff(old_names, names)
[09:32:21.240]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.240]                   envs[common]]
[09:32:21.240]                 NAMES <- toupper(changed)
[09:32:21.240]                 args <- list()
[09:32:21.240]                 for (kk in seq_along(NAMES)) {
[09:32:21.240]                   name <- changed[[kk]]
[09:32:21.240]                   NAME <- NAMES[[kk]]
[09:32:21.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.240]                     next
[09:32:21.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.240]                 }
[09:32:21.240]                 NAMES <- toupper(added)
[09:32:21.240]                 for (kk in seq_along(NAMES)) {
[09:32:21.240]                   name <- added[[kk]]
[09:32:21.240]                   NAME <- NAMES[[kk]]
[09:32:21.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.240]                     next
[09:32:21.240]                   args[[name]] <- ""
[09:32:21.240]                 }
[09:32:21.240]                 NAMES <- toupper(removed)
[09:32:21.240]                 for (kk in seq_along(NAMES)) {
[09:32:21.240]                   name <- removed[[kk]]
[09:32:21.240]                   NAME <- NAMES[[kk]]
[09:32:21.240]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.240]                     next
[09:32:21.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.240]                 }
[09:32:21.240]                 if (length(args) > 0) 
[09:32:21.240]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.240]             }
[09:32:21.240]             else {
[09:32:21.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.240]             }
[09:32:21.240]             {
[09:32:21.240]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.240]                   0L) {
[09:32:21.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.240]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.240]                   base::options(opts)
[09:32:21.240]                 }
[09:32:21.240]                 {
[09:32:21.240]                   {
[09:32:21.240]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.240]                     NULL
[09:32:21.240]                   }
[09:32:21.240]                   options(future.plan = NULL)
[09:32:21.240]                   if (is.na(NA_character_)) 
[09:32:21.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.240]                     .init = FALSE)
[09:32:21.240]                 }
[09:32:21.240]             }
[09:32:21.240]         }
[09:32:21.240]     })
[09:32:21.240]     if (TRUE) {
[09:32:21.240]         base::sink(type = "output", split = FALSE)
[09:32:21.240]         if (TRUE) {
[09:32:21.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.240]         }
[09:32:21.240]         else {
[09:32:21.240]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.240]         }
[09:32:21.240]         base::close(...future.stdout)
[09:32:21.240]         ...future.stdout <- NULL
[09:32:21.240]     }
[09:32:21.240]     ...future.result$conditions <- ...future.conditions
[09:32:21.240]     ...future.result$finished <- base::Sys.time()
[09:32:21.240]     ...future.result
[09:32:21.240] }
[09:32:21.243] requestCore(): workers = 2
[09:32:21.244] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.254] result() for MulticoreFuture ...
[09:32:21.255] result() for MulticoreFuture ...
[09:32:21.255] result() for MulticoreFuture ... done
[09:32:21.255] result() for MulticoreFuture ... done
[09:32:21.256] result() for MulticoreFuture ...
[09:32:21.256] result() for MulticoreFuture ... done
[09:32:21.258] MulticoreFuture started
[09:32:21.258] - Launch lazy future ... done
[09:32:21.259] run() for ‘MulticoreFuture’ ... done
[09:32:21.259] plan(): Setting new future strategy stack:
[09:32:21.259] List of future strategies:
[09:32:21.259] 1. sequential:
[09:32:21.259]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.259]    - tweaked: FALSE
[09:32:21.259]    - call: NULL
[09:32:21.261] resolve() on environment ...
[09:32:21.261]  recursive: 0
[09:32:21.261] plan(): nbrOfWorkers() = 1
[09:32:21.262]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:21.263] Future #1
[09:32:21.263]  length: 2 (resolved future 1)
[09:32:21.264] plan(): Setting new future strategy stack:
[09:32:21.264] List of future strategies:
[09:32:21.264] 1. multicore:
[09:32:21.264]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.264]    - tweaked: FALSE
[09:32:21.264]    - call: plan(strategy)
[09:32:21.269] plan(): nbrOfWorkers() = 2
[09:32:21.269] Future #2
[09:32:21.269]  length: 1 (resolved future 2)
[09:32:21.269]  length: 0 (resolved future 3)
[09:32:21.270] resolve() on environment ... DONE
[09:32:21.270] getGlobalsAndPackages() ...
[09:32:21.270] Searching for globals...
[09:32:21.272] - globals found: [1] ‘{’
[09:32:21.272] Searching for globals ... DONE
[09:32:21.272] Resolving globals: FALSE
[09:32:21.273] 
[09:32:21.273] 
[09:32:21.273] getGlobalsAndPackages() ... DONE
[09:32:21.273] run() for ‘Future’ ...
[09:32:21.273] - state: ‘created’
[09:32:21.274] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.278] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.278] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.278]   - Field: ‘label’
[09:32:21.279]   - Field: ‘local’
[09:32:21.279]   - Field: ‘owner’
[09:32:21.279]   - Field: ‘envir’
[09:32:21.279]   - Field: ‘workers’
[09:32:21.279]   - Field: ‘packages’
[09:32:21.279]   - Field: ‘gc’
[09:32:21.279]   - Field: ‘job’
[09:32:21.280]   - Field: ‘conditions’
[09:32:21.280]   - Field: ‘expr’
[09:32:21.280]   - Field: ‘uuid’
[09:32:21.280]   - Field: ‘seed’
[09:32:21.280]   - Field: ‘version’
[09:32:21.280]   - Field: ‘result’
[09:32:21.280]   - Field: ‘asynchronous’
[09:32:21.281]   - Field: ‘calls’
[09:32:21.281]   - Field: ‘globals’
[09:32:21.281]   - Field: ‘stdout’
[09:32:21.281]   - Field: ‘earlySignal’
[09:32:21.281]   - Field: ‘lazy’
[09:32:21.281]   - Field: ‘state’
[09:32:21.281] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.282] - Launch lazy future ...
[09:32:21.282] Packages needed by the future expression (n = 0): <none>
[09:32:21.282] Packages needed by future strategies (n = 0): <none>
[09:32:21.283] {
[09:32:21.283]     {
[09:32:21.283]         {
[09:32:21.283]             ...future.startTime <- base::Sys.time()
[09:32:21.283]             {
[09:32:21.283]                 {
[09:32:21.283]                   {
[09:32:21.283]                     {
[09:32:21.283]                       base::local({
[09:32:21.283]                         has_future <- base::requireNamespace("future", 
[09:32:21.283]                           quietly = TRUE)
[09:32:21.283]                         if (has_future) {
[09:32:21.283]                           ns <- base::getNamespace("future")
[09:32:21.283]                           version <- ns[[".package"]][["version"]]
[09:32:21.283]                           if (is.null(version)) 
[09:32:21.283]                             version <- utils::packageVersion("future")
[09:32:21.283]                         }
[09:32:21.283]                         else {
[09:32:21.283]                           version <- NULL
[09:32:21.283]                         }
[09:32:21.283]                         if (!has_future || version < "1.8.0") {
[09:32:21.283]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.283]                             "", base::R.version$version.string), 
[09:32:21.283]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.283]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.283]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.283]                               "release", "version")], collapse = " "), 
[09:32:21.283]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.283]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.283]                             info)
[09:32:21.283]                           info <- base::paste(info, collapse = "; ")
[09:32:21.283]                           if (!has_future) {
[09:32:21.283]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.283]                               info)
[09:32:21.283]                           }
[09:32:21.283]                           else {
[09:32:21.283]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.283]                               info, version)
[09:32:21.283]                           }
[09:32:21.283]                           base::stop(msg)
[09:32:21.283]                         }
[09:32:21.283]                       })
[09:32:21.283]                     }
[09:32:21.283]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.283]                     base::options(mc.cores = 1L)
[09:32:21.283]                   }
[09:32:21.283]                   ...future.strategy.old <- future::plan("list")
[09:32:21.283]                   options(future.plan = NULL)
[09:32:21.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.283]                 }
[09:32:21.283]                 ...future.workdir <- getwd()
[09:32:21.283]             }
[09:32:21.283]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.283]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.283]         }
[09:32:21.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.283]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.283]             base::names(...future.oldOptions))
[09:32:21.283]     }
[09:32:21.283]     if (FALSE) {
[09:32:21.283]     }
[09:32:21.283]     else {
[09:32:21.283]         if (TRUE) {
[09:32:21.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.283]                 open = "w")
[09:32:21.283]         }
[09:32:21.283]         else {
[09:32:21.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.283]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.283]         }
[09:32:21.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.283]             base::sink(type = "output", split = FALSE)
[09:32:21.283]             base::close(...future.stdout)
[09:32:21.283]         }, add = TRUE)
[09:32:21.283]     }
[09:32:21.283]     ...future.frame <- base::sys.nframe()
[09:32:21.283]     ...future.conditions <- base::list()
[09:32:21.283]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.283]     if (FALSE) {
[09:32:21.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.283]     }
[09:32:21.283]     ...future.result <- base::tryCatch({
[09:32:21.283]         base::withCallingHandlers({
[09:32:21.283]             ...future.value <- base::withVisible(base::local({
[09:32:21.283]                 withCallingHandlers({
[09:32:21.283]                   {
[09:32:21.283]                     1
[09:32:21.283]                   }
[09:32:21.283]                 }, immediateCondition = function(cond) {
[09:32:21.283]                   save_rds <- function (object, pathname, ...) 
[09:32:21.283]                   {
[09:32:21.283]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.283]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.283]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.283]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.283]                         fi_tmp[["mtime"]])
[09:32:21.283]                     }
[09:32:21.283]                     tryCatch({
[09:32:21.283]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.283]                     }, error = function(ex) {
[09:32:21.283]                       msg <- conditionMessage(ex)
[09:32:21.283]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.283]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.283]                         fi_tmp[["mtime"]], msg)
[09:32:21.283]                       ex$message <- msg
[09:32:21.283]                       stop(ex)
[09:32:21.283]                     })
[09:32:21.283]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.283]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.283]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.283]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.283]                       fi <- file.info(pathname)
[09:32:21.283]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.283]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.283]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.283]                         fi[["size"]], fi[["mtime"]])
[09:32:21.283]                       stop(msg)
[09:32:21.283]                     }
[09:32:21.283]                     invisible(pathname)
[09:32:21.283]                   }
[09:32:21.283]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.283]                     rootPath = tempdir()) 
[09:32:21.283]                   {
[09:32:21.283]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.283]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.283]                       tmpdir = path, fileext = ".rds")
[09:32:21.283]                     save_rds(obj, file)
[09:32:21.283]                   }
[09:32:21.283]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.283]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.283]                   {
[09:32:21.283]                     inherits <- base::inherits
[09:32:21.283]                     invokeRestart <- base::invokeRestart
[09:32:21.283]                     is.null <- base::is.null
[09:32:21.283]                     muffled <- FALSE
[09:32:21.283]                     if (inherits(cond, "message")) {
[09:32:21.283]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.283]                       if (muffled) 
[09:32:21.283]                         invokeRestart("muffleMessage")
[09:32:21.283]                     }
[09:32:21.283]                     else if (inherits(cond, "warning")) {
[09:32:21.283]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.283]                       if (muffled) 
[09:32:21.283]                         invokeRestart("muffleWarning")
[09:32:21.283]                     }
[09:32:21.283]                     else if (inherits(cond, "condition")) {
[09:32:21.283]                       if (!is.null(pattern)) {
[09:32:21.283]                         computeRestarts <- base::computeRestarts
[09:32:21.283]                         grepl <- base::grepl
[09:32:21.283]                         restarts <- computeRestarts(cond)
[09:32:21.283]                         for (restart in restarts) {
[09:32:21.283]                           name <- restart$name
[09:32:21.283]                           if (is.null(name)) 
[09:32:21.283]                             next
[09:32:21.283]                           if (!grepl(pattern, name)) 
[09:32:21.283]                             next
[09:32:21.283]                           invokeRestart(restart)
[09:32:21.283]                           muffled <- TRUE
[09:32:21.283]                           break
[09:32:21.283]                         }
[09:32:21.283]                       }
[09:32:21.283]                     }
[09:32:21.283]                     invisible(muffled)
[09:32:21.283]                   }
[09:32:21.283]                   muffleCondition(cond)
[09:32:21.283]                 })
[09:32:21.283]             }))
[09:32:21.283]             future::FutureResult(value = ...future.value$value, 
[09:32:21.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.283]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.283]                     ...future.globalenv.names))
[09:32:21.283]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.283]         }, condition = base::local({
[09:32:21.283]             c <- base::c
[09:32:21.283]             inherits <- base::inherits
[09:32:21.283]             invokeRestart <- base::invokeRestart
[09:32:21.283]             length <- base::length
[09:32:21.283]             list <- base::list
[09:32:21.283]             seq.int <- base::seq.int
[09:32:21.283]             signalCondition <- base::signalCondition
[09:32:21.283]             sys.calls <- base::sys.calls
[09:32:21.283]             `[[` <- base::`[[`
[09:32:21.283]             `+` <- base::`+`
[09:32:21.283]             `<<-` <- base::`<<-`
[09:32:21.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.283]                   3L)]
[09:32:21.283]             }
[09:32:21.283]             function(cond) {
[09:32:21.283]                 is_error <- inherits(cond, "error")
[09:32:21.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.283]                   NULL)
[09:32:21.283]                 if (is_error) {
[09:32:21.283]                   sessionInformation <- function() {
[09:32:21.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.283]                       search = base::search(), system = base::Sys.info())
[09:32:21.283]                   }
[09:32:21.283]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.283]                     cond$call), session = sessionInformation(), 
[09:32:21.283]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.283]                   signalCondition(cond)
[09:32:21.283]                 }
[09:32:21.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.283]                 "immediateCondition"))) {
[09:32:21.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.283]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.283]                   if (TRUE && !signal) {
[09:32:21.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.283]                     {
[09:32:21.283]                       inherits <- base::inherits
[09:32:21.283]                       invokeRestart <- base::invokeRestart
[09:32:21.283]                       is.null <- base::is.null
[09:32:21.283]                       muffled <- FALSE
[09:32:21.283]                       if (inherits(cond, "message")) {
[09:32:21.283]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.283]                         if (muffled) 
[09:32:21.283]                           invokeRestart("muffleMessage")
[09:32:21.283]                       }
[09:32:21.283]                       else if (inherits(cond, "warning")) {
[09:32:21.283]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.283]                         if (muffled) 
[09:32:21.283]                           invokeRestart("muffleWarning")
[09:32:21.283]                       }
[09:32:21.283]                       else if (inherits(cond, "condition")) {
[09:32:21.283]                         if (!is.null(pattern)) {
[09:32:21.283]                           computeRestarts <- base::computeRestarts
[09:32:21.283]                           grepl <- base::grepl
[09:32:21.283]                           restarts <- computeRestarts(cond)
[09:32:21.283]                           for (restart in restarts) {
[09:32:21.283]                             name <- restart$name
[09:32:21.283]                             if (is.null(name)) 
[09:32:21.283]                               next
[09:32:21.283]                             if (!grepl(pattern, name)) 
[09:32:21.283]                               next
[09:32:21.283]                             invokeRestart(restart)
[09:32:21.283]                             muffled <- TRUE
[09:32:21.283]                             break
[09:32:21.283]                           }
[09:32:21.283]                         }
[09:32:21.283]                       }
[09:32:21.283]                       invisible(muffled)
[09:32:21.283]                     }
[09:32:21.283]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.283]                   }
[09:32:21.283]                 }
[09:32:21.283]                 else {
[09:32:21.283]                   if (TRUE) {
[09:32:21.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.283]                     {
[09:32:21.283]                       inherits <- base::inherits
[09:32:21.283]                       invokeRestart <- base::invokeRestart
[09:32:21.283]                       is.null <- base::is.null
[09:32:21.283]                       muffled <- FALSE
[09:32:21.283]                       if (inherits(cond, "message")) {
[09:32:21.283]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.283]                         if (muffled) 
[09:32:21.283]                           invokeRestart("muffleMessage")
[09:32:21.283]                       }
[09:32:21.283]                       else if (inherits(cond, "warning")) {
[09:32:21.283]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.283]                         if (muffled) 
[09:32:21.283]                           invokeRestart("muffleWarning")
[09:32:21.283]                       }
[09:32:21.283]                       else if (inherits(cond, "condition")) {
[09:32:21.283]                         if (!is.null(pattern)) {
[09:32:21.283]                           computeRestarts <- base::computeRestarts
[09:32:21.283]                           grepl <- base::grepl
[09:32:21.283]                           restarts <- computeRestarts(cond)
[09:32:21.283]                           for (restart in restarts) {
[09:32:21.283]                             name <- restart$name
[09:32:21.283]                             if (is.null(name)) 
[09:32:21.283]                               next
[09:32:21.283]                             if (!grepl(pattern, name)) 
[09:32:21.283]                               next
[09:32:21.283]                             invokeRestart(restart)
[09:32:21.283]                             muffled <- TRUE
[09:32:21.283]                             break
[09:32:21.283]                           }
[09:32:21.283]                         }
[09:32:21.283]                       }
[09:32:21.283]                       invisible(muffled)
[09:32:21.283]                     }
[09:32:21.283]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.283]                   }
[09:32:21.283]                 }
[09:32:21.283]             }
[09:32:21.283]         }))
[09:32:21.283]     }, error = function(ex) {
[09:32:21.283]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.283]                 ...future.rng), started = ...future.startTime, 
[09:32:21.283]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.283]             version = "1.8"), class = "FutureResult")
[09:32:21.283]     }, finally = {
[09:32:21.283]         if (!identical(...future.workdir, getwd())) 
[09:32:21.283]             setwd(...future.workdir)
[09:32:21.283]         {
[09:32:21.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.283]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.283]             }
[09:32:21.283]             base::options(...future.oldOptions)
[09:32:21.283]             if (.Platform$OS.type == "windows") {
[09:32:21.283]                 old_names <- names(...future.oldEnvVars)
[09:32:21.283]                 envs <- base::Sys.getenv()
[09:32:21.283]                 names <- names(envs)
[09:32:21.283]                 common <- intersect(names, old_names)
[09:32:21.283]                 added <- setdiff(names, old_names)
[09:32:21.283]                 removed <- setdiff(old_names, names)
[09:32:21.283]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.283]                   envs[common]]
[09:32:21.283]                 NAMES <- toupper(changed)
[09:32:21.283]                 args <- list()
[09:32:21.283]                 for (kk in seq_along(NAMES)) {
[09:32:21.283]                   name <- changed[[kk]]
[09:32:21.283]                   NAME <- NAMES[[kk]]
[09:32:21.283]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.283]                     next
[09:32:21.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.283]                 }
[09:32:21.283]                 NAMES <- toupper(added)
[09:32:21.283]                 for (kk in seq_along(NAMES)) {
[09:32:21.283]                   name <- added[[kk]]
[09:32:21.283]                   NAME <- NAMES[[kk]]
[09:32:21.283]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.283]                     next
[09:32:21.283]                   args[[name]] <- ""
[09:32:21.283]                 }
[09:32:21.283]                 NAMES <- toupper(removed)
[09:32:21.283]                 for (kk in seq_along(NAMES)) {
[09:32:21.283]                   name <- removed[[kk]]
[09:32:21.283]                   NAME <- NAMES[[kk]]
[09:32:21.283]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.283]                     next
[09:32:21.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.283]                 }
[09:32:21.283]                 if (length(args) > 0) 
[09:32:21.283]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.283]             }
[09:32:21.283]             else {
[09:32:21.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.283]             }
[09:32:21.283]             {
[09:32:21.283]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.283]                   0L) {
[09:32:21.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.283]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.283]                   base::options(opts)
[09:32:21.283]                 }
[09:32:21.283]                 {
[09:32:21.283]                   {
[09:32:21.283]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.283]                     NULL
[09:32:21.283]                   }
[09:32:21.283]                   options(future.plan = NULL)
[09:32:21.283]                   if (is.na(NA_character_)) 
[09:32:21.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.283]                     .init = FALSE)
[09:32:21.283]                 }
[09:32:21.283]             }
[09:32:21.283]         }
[09:32:21.283]     })
[09:32:21.283]     if (TRUE) {
[09:32:21.283]         base::sink(type = "output", split = FALSE)
[09:32:21.283]         if (TRUE) {
[09:32:21.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.283]         }
[09:32:21.283]         else {
[09:32:21.283]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.283]         }
[09:32:21.283]         base::close(...future.stdout)
[09:32:21.283]         ...future.stdout <- NULL
[09:32:21.283]     }
[09:32:21.283]     ...future.result$conditions <- ...future.conditions
[09:32:21.283]     ...future.result$finished <- base::Sys.time()
[09:32:21.283]     ...future.result
[09:32:21.283] }
[09:32:21.286] requestCore(): workers = 2
[09:32:21.286] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.297] result() for MulticoreFuture ...
[09:32:21.298] result() for MulticoreFuture ...
[09:32:21.298] result() for MulticoreFuture ... done
[09:32:21.298] result() for MulticoreFuture ... done
[09:32:21.298] result() for MulticoreFuture ...
[09:32:21.298] result() for MulticoreFuture ... done
[09:32:21.300] MulticoreFuture started
[09:32:21.301] - Launch lazy future ... done
[09:32:21.301] run() for ‘MulticoreFuture’ ... done
[09:32:21.302] plan(): Setting new future strategy stack:
[09:32:21.302] getGlobalsAndPackages() ...
[09:32:21.303] Searching for globals...
[09:32:21.302] List of future strategies:
[09:32:21.302] 1. sequential:
[09:32:21.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.302]    - tweaked: FALSE
[09:32:21.302]    - call: NULL
[09:32:21.303] plan(): nbrOfWorkers() = 1
[09:32:21.304] - globals found: [1] ‘{’
[09:32:21.305] Searching for globals ... DONE
[09:32:21.305] Resolving globals: FALSE
[09:32:21.306] 
[09:32:21.306] 
[09:32:21.306] plan(): Setting new future strategy stack:
[09:32:21.306] getGlobalsAndPackages() ... DONE
[09:32:21.306] List of future strategies:
[09:32:21.306] 1. multicore:
[09:32:21.306]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.306]    - tweaked: FALSE
[09:32:21.306]    - call: plan(strategy)
[09:32:21.307] run() for ‘Future’ ...
[09:32:21.313] - state: ‘created’
[09:32:21.313] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.317] plan(): nbrOfWorkers() = 2
[09:32:21.321] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.321]   - Field: ‘label’
[09:32:21.321]   - Field: ‘local’
[09:32:21.322]   - Field: ‘owner’
[09:32:21.322]   - Field: ‘envir’
[09:32:21.322]   - Field: ‘workers’
[09:32:21.322]   - Field: ‘packages’
[09:32:21.322]   - Field: ‘gc’
[09:32:21.322]   - Field: ‘job’
[09:32:21.323]   - Field: ‘conditions’
[09:32:21.323]   - Field: ‘expr’
[09:32:21.323]   - Field: ‘uuid’
[09:32:21.323]   - Field: ‘seed’
[09:32:21.323]   - Field: ‘version’
[09:32:21.323]   - Field: ‘result’
[09:32:21.324]   - Field: ‘asynchronous’
[09:32:21.324]   - Field: ‘calls’
[09:32:21.324]   - Field: ‘globals’
[09:32:21.324]   - Field: ‘stdout’
[09:32:21.324]   - Field: ‘earlySignal’
[09:32:21.324]   - Field: ‘lazy’
[09:32:21.325]   - Field: ‘state’
[09:32:21.325] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.325] - Launch lazy future ...
[09:32:21.325] Packages needed by the future expression (n = 0): <none>
[09:32:21.325] Packages needed by future strategies (n = 0): <none>
[09:32:21.326] {
[09:32:21.326]     {
[09:32:21.326]         {
[09:32:21.326]             ...future.startTime <- base::Sys.time()
[09:32:21.326]             {
[09:32:21.326]                 {
[09:32:21.326]                   {
[09:32:21.326]                     {
[09:32:21.326]                       base::local({
[09:32:21.326]                         has_future <- base::requireNamespace("future", 
[09:32:21.326]                           quietly = TRUE)
[09:32:21.326]                         if (has_future) {
[09:32:21.326]                           ns <- base::getNamespace("future")
[09:32:21.326]                           version <- ns[[".package"]][["version"]]
[09:32:21.326]                           if (is.null(version)) 
[09:32:21.326]                             version <- utils::packageVersion("future")
[09:32:21.326]                         }
[09:32:21.326]                         else {
[09:32:21.326]                           version <- NULL
[09:32:21.326]                         }
[09:32:21.326]                         if (!has_future || version < "1.8.0") {
[09:32:21.326]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.326]                             "", base::R.version$version.string), 
[09:32:21.326]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.326]                               "release", "version")], collapse = " "), 
[09:32:21.326]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.326]                             info)
[09:32:21.326]                           info <- base::paste(info, collapse = "; ")
[09:32:21.326]                           if (!has_future) {
[09:32:21.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.326]                               info)
[09:32:21.326]                           }
[09:32:21.326]                           else {
[09:32:21.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.326]                               info, version)
[09:32:21.326]                           }
[09:32:21.326]                           base::stop(msg)
[09:32:21.326]                         }
[09:32:21.326]                       })
[09:32:21.326]                     }
[09:32:21.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.326]                     base::options(mc.cores = 1L)
[09:32:21.326]                   }
[09:32:21.326]                   ...future.strategy.old <- future::plan("list")
[09:32:21.326]                   options(future.plan = NULL)
[09:32:21.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.326]                 }
[09:32:21.326]                 ...future.workdir <- getwd()
[09:32:21.326]             }
[09:32:21.326]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.326]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.326]         }
[09:32:21.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.326]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.326]             base::names(...future.oldOptions))
[09:32:21.326]     }
[09:32:21.326]     if (FALSE) {
[09:32:21.326]     }
[09:32:21.326]     else {
[09:32:21.326]         if (TRUE) {
[09:32:21.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.326]                 open = "w")
[09:32:21.326]         }
[09:32:21.326]         else {
[09:32:21.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.326]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.326]         }
[09:32:21.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.326]             base::sink(type = "output", split = FALSE)
[09:32:21.326]             base::close(...future.stdout)
[09:32:21.326]         }, add = TRUE)
[09:32:21.326]     }
[09:32:21.326]     ...future.frame <- base::sys.nframe()
[09:32:21.326]     ...future.conditions <- base::list()
[09:32:21.326]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.326]     if (FALSE) {
[09:32:21.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.326]     }
[09:32:21.326]     ...future.result <- base::tryCatch({
[09:32:21.326]         base::withCallingHandlers({
[09:32:21.326]             ...future.value <- base::withVisible(base::local({
[09:32:21.326]                 withCallingHandlers({
[09:32:21.326]                   {
[09:32:21.326]                     2
[09:32:21.326]                   }
[09:32:21.326]                 }, immediateCondition = function(cond) {
[09:32:21.326]                   save_rds <- function (object, pathname, ...) 
[09:32:21.326]                   {
[09:32:21.326]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.326]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.326]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.326]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.326]                         fi_tmp[["mtime"]])
[09:32:21.326]                     }
[09:32:21.326]                     tryCatch({
[09:32:21.326]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.326]                     }, error = function(ex) {
[09:32:21.326]                       msg <- conditionMessage(ex)
[09:32:21.326]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.326]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.326]                         fi_tmp[["mtime"]], msg)
[09:32:21.326]                       ex$message <- msg
[09:32:21.326]                       stop(ex)
[09:32:21.326]                     })
[09:32:21.326]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.326]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.326]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.326]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.326]                       fi <- file.info(pathname)
[09:32:21.326]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.326]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.326]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.326]                         fi[["size"]], fi[["mtime"]])
[09:32:21.326]                       stop(msg)
[09:32:21.326]                     }
[09:32:21.326]                     invisible(pathname)
[09:32:21.326]                   }
[09:32:21.326]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.326]                     rootPath = tempdir()) 
[09:32:21.326]                   {
[09:32:21.326]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.326]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.326]                       tmpdir = path, fileext = ".rds")
[09:32:21.326]                     save_rds(obj, file)
[09:32:21.326]                   }
[09:32:21.326]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.326]                   {
[09:32:21.326]                     inherits <- base::inherits
[09:32:21.326]                     invokeRestart <- base::invokeRestart
[09:32:21.326]                     is.null <- base::is.null
[09:32:21.326]                     muffled <- FALSE
[09:32:21.326]                     if (inherits(cond, "message")) {
[09:32:21.326]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.326]                       if (muffled) 
[09:32:21.326]                         invokeRestart("muffleMessage")
[09:32:21.326]                     }
[09:32:21.326]                     else if (inherits(cond, "warning")) {
[09:32:21.326]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.326]                       if (muffled) 
[09:32:21.326]                         invokeRestart("muffleWarning")
[09:32:21.326]                     }
[09:32:21.326]                     else if (inherits(cond, "condition")) {
[09:32:21.326]                       if (!is.null(pattern)) {
[09:32:21.326]                         computeRestarts <- base::computeRestarts
[09:32:21.326]                         grepl <- base::grepl
[09:32:21.326]                         restarts <- computeRestarts(cond)
[09:32:21.326]                         for (restart in restarts) {
[09:32:21.326]                           name <- restart$name
[09:32:21.326]                           if (is.null(name)) 
[09:32:21.326]                             next
[09:32:21.326]                           if (!grepl(pattern, name)) 
[09:32:21.326]                             next
[09:32:21.326]                           invokeRestart(restart)
[09:32:21.326]                           muffled <- TRUE
[09:32:21.326]                           break
[09:32:21.326]                         }
[09:32:21.326]                       }
[09:32:21.326]                     }
[09:32:21.326]                     invisible(muffled)
[09:32:21.326]                   }
[09:32:21.326]                   muffleCondition(cond)
[09:32:21.326]                 })
[09:32:21.326]             }))
[09:32:21.326]             future::FutureResult(value = ...future.value$value, 
[09:32:21.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.326]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.326]                     ...future.globalenv.names))
[09:32:21.326]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.326]         }, condition = base::local({
[09:32:21.326]             c <- base::c
[09:32:21.326]             inherits <- base::inherits
[09:32:21.326]             invokeRestart <- base::invokeRestart
[09:32:21.326]             length <- base::length
[09:32:21.326]             list <- base::list
[09:32:21.326]             seq.int <- base::seq.int
[09:32:21.326]             signalCondition <- base::signalCondition
[09:32:21.326]             sys.calls <- base::sys.calls
[09:32:21.326]             `[[` <- base::`[[`
[09:32:21.326]             `+` <- base::`+`
[09:32:21.326]             `<<-` <- base::`<<-`
[09:32:21.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.326]                   3L)]
[09:32:21.326]             }
[09:32:21.326]             function(cond) {
[09:32:21.326]                 is_error <- inherits(cond, "error")
[09:32:21.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.326]                   NULL)
[09:32:21.326]                 if (is_error) {
[09:32:21.326]                   sessionInformation <- function() {
[09:32:21.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.326]                       search = base::search(), system = base::Sys.info())
[09:32:21.326]                   }
[09:32:21.326]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.326]                     cond$call), session = sessionInformation(), 
[09:32:21.326]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.326]                   signalCondition(cond)
[09:32:21.326]                 }
[09:32:21.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.326]                 "immediateCondition"))) {
[09:32:21.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.326]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.326]                   if (TRUE && !signal) {
[09:32:21.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.326]                     {
[09:32:21.326]                       inherits <- base::inherits
[09:32:21.326]                       invokeRestart <- base::invokeRestart
[09:32:21.326]                       is.null <- base::is.null
[09:32:21.326]                       muffled <- FALSE
[09:32:21.326]                       if (inherits(cond, "message")) {
[09:32:21.326]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.326]                         if (muffled) 
[09:32:21.326]                           invokeRestart("muffleMessage")
[09:32:21.326]                       }
[09:32:21.326]                       else if (inherits(cond, "warning")) {
[09:32:21.326]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.326]                         if (muffled) 
[09:32:21.326]                           invokeRestart("muffleWarning")
[09:32:21.326]                       }
[09:32:21.326]                       else if (inherits(cond, "condition")) {
[09:32:21.326]                         if (!is.null(pattern)) {
[09:32:21.326]                           computeRestarts <- base::computeRestarts
[09:32:21.326]                           grepl <- base::grepl
[09:32:21.326]                           restarts <- computeRestarts(cond)
[09:32:21.326]                           for (restart in restarts) {
[09:32:21.326]                             name <- restart$name
[09:32:21.326]                             if (is.null(name)) 
[09:32:21.326]                               next
[09:32:21.326]                             if (!grepl(pattern, name)) 
[09:32:21.326]                               next
[09:32:21.326]                             invokeRestart(restart)
[09:32:21.326]                             muffled <- TRUE
[09:32:21.326]                             break
[09:32:21.326]                           }
[09:32:21.326]                         }
[09:32:21.326]                       }
[09:32:21.326]                       invisible(muffled)
[09:32:21.326]                     }
[09:32:21.326]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.326]                   }
[09:32:21.326]                 }
[09:32:21.326]                 else {
[09:32:21.326]                   if (TRUE) {
[09:32:21.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.326]                     {
[09:32:21.326]                       inherits <- base::inherits
[09:32:21.326]                       invokeRestart <- base::invokeRestart
[09:32:21.326]                       is.null <- base::is.null
[09:32:21.326]                       muffled <- FALSE
[09:32:21.326]                       if (inherits(cond, "message")) {
[09:32:21.326]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.326]                         if (muffled) 
[09:32:21.326]                           invokeRestart("muffleMessage")
[09:32:21.326]                       }
[09:32:21.326]                       else if (inherits(cond, "warning")) {
[09:32:21.326]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.326]                         if (muffled) 
[09:32:21.326]                           invokeRestart("muffleWarning")
[09:32:21.326]                       }
[09:32:21.326]                       else if (inherits(cond, "condition")) {
[09:32:21.326]                         if (!is.null(pattern)) {
[09:32:21.326]                           computeRestarts <- base::computeRestarts
[09:32:21.326]                           grepl <- base::grepl
[09:32:21.326]                           restarts <- computeRestarts(cond)
[09:32:21.326]                           for (restart in restarts) {
[09:32:21.326]                             name <- restart$name
[09:32:21.326]                             if (is.null(name)) 
[09:32:21.326]                               next
[09:32:21.326]                             if (!grepl(pattern, name)) 
[09:32:21.326]                               next
[09:32:21.326]                             invokeRestart(restart)
[09:32:21.326]                             muffled <- TRUE
[09:32:21.326]                             break
[09:32:21.326]                           }
[09:32:21.326]                         }
[09:32:21.326]                       }
[09:32:21.326]                       invisible(muffled)
[09:32:21.326]                     }
[09:32:21.326]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.326]                   }
[09:32:21.326]                 }
[09:32:21.326]             }
[09:32:21.326]         }))
[09:32:21.326]     }, error = function(ex) {
[09:32:21.326]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.326]                 ...future.rng), started = ...future.startTime, 
[09:32:21.326]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.326]             version = "1.8"), class = "FutureResult")
[09:32:21.326]     }, finally = {
[09:32:21.326]         if (!identical(...future.workdir, getwd())) 
[09:32:21.326]             setwd(...future.workdir)
[09:32:21.326]         {
[09:32:21.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.326]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.326]             }
[09:32:21.326]             base::options(...future.oldOptions)
[09:32:21.326]             if (.Platform$OS.type == "windows") {
[09:32:21.326]                 old_names <- names(...future.oldEnvVars)
[09:32:21.326]                 envs <- base::Sys.getenv()
[09:32:21.326]                 names <- names(envs)
[09:32:21.326]                 common <- intersect(names, old_names)
[09:32:21.326]                 added <- setdiff(names, old_names)
[09:32:21.326]                 removed <- setdiff(old_names, names)
[09:32:21.326]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.326]                   envs[common]]
[09:32:21.326]                 NAMES <- toupper(changed)
[09:32:21.326]                 args <- list()
[09:32:21.326]                 for (kk in seq_along(NAMES)) {
[09:32:21.326]                   name <- changed[[kk]]
[09:32:21.326]                   NAME <- NAMES[[kk]]
[09:32:21.326]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.326]                     next
[09:32:21.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.326]                 }
[09:32:21.326]                 NAMES <- toupper(added)
[09:32:21.326]                 for (kk in seq_along(NAMES)) {
[09:32:21.326]                   name <- added[[kk]]
[09:32:21.326]                   NAME <- NAMES[[kk]]
[09:32:21.326]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.326]                     next
[09:32:21.326]                   args[[name]] <- ""
[09:32:21.326]                 }
[09:32:21.326]                 NAMES <- toupper(removed)
[09:32:21.326]                 for (kk in seq_along(NAMES)) {
[09:32:21.326]                   name <- removed[[kk]]
[09:32:21.326]                   NAME <- NAMES[[kk]]
[09:32:21.326]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.326]                     next
[09:32:21.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.326]                 }
[09:32:21.326]                 if (length(args) > 0) 
[09:32:21.326]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.326]             }
[09:32:21.326]             else {
[09:32:21.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.326]             }
[09:32:21.326]             {
[09:32:21.326]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.326]                   0L) {
[09:32:21.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.326]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.326]                   base::options(opts)
[09:32:21.326]                 }
[09:32:21.326]                 {
[09:32:21.326]                   {
[09:32:21.326]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.326]                     NULL
[09:32:21.326]                   }
[09:32:21.326]                   options(future.plan = NULL)
[09:32:21.326]                   if (is.na(NA_character_)) 
[09:32:21.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.326]                     .init = FALSE)
[09:32:21.326]                 }
[09:32:21.326]             }
[09:32:21.326]         }
[09:32:21.326]     })
[09:32:21.326]     if (TRUE) {
[09:32:21.326]         base::sink(type = "output", split = FALSE)
[09:32:21.326]         if (TRUE) {
[09:32:21.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.326]         }
[09:32:21.326]         else {
[09:32:21.326]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.326]         }
[09:32:21.326]         base::close(...future.stdout)
[09:32:21.326]         ...future.stdout <- NULL
[09:32:21.326]     }
[09:32:21.326]     ...future.result$conditions <- ...future.conditions
[09:32:21.326]     ...future.result$finished <- base::Sys.time()
[09:32:21.326]     ...future.result
[09:32:21.326] }
[09:32:21.329] requestCore(): workers = 2
[09:32:21.329] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.340] result() for MulticoreFuture ...
[09:32:21.340] result() for MulticoreFuture ...
[09:32:21.341] result() for MulticoreFuture ... done
[09:32:21.341] result() for MulticoreFuture ... done
[09:32:21.341] result() for MulticoreFuture ...
[09:32:21.341] result() for MulticoreFuture ... done
[09:32:21.343] MulticoreFuture started
[09:32:21.344] - Launch lazy future ... done
[09:32:21.344] run() for ‘MulticoreFuture’ ... done
[09:32:21.345] plan(): Setting new future strategy stack:
[09:32:21.345] List of future strategies:
[09:32:21.345] 1. sequential:
[09:32:21.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.345]    - tweaked: FALSE
[09:32:21.345]    - call: NULL
[09:32:21.346] resolve() on environment ...
[09:32:21.346] plan(): nbrOfWorkers() = 1
[09:32:21.346]  recursive: 0
[09:32:21.348]  elements: [3] ‘a’
[09:32:21.348] Future #1
[09:32:21.349]  length: 2 (resolved future 1)
[09:32:21.349] plan(): Setting new future strategy stack:
[09:32:21.349] List of future strategies:
[09:32:21.349] 1. multicore:
[09:32:21.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.349]    - tweaked: FALSE
[09:32:21.349]    - call: plan(strategy)
[09:32:21.354] plan(): nbrOfWorkers() = 2
[09:32:21.355] Future #2
[09:32:21.355]  length: 1 (resolved future 2)
[09:32:21.355]  length: 0 (resolved future 3)
[09:32:21.355] resolve() on environment ... DONE
[09:32:21.356] resolve() on environment ...
[09:32:21.356]  recursive: 0
[09:32:21.357]  elements: [3] ‘b’
[09:32:21.357] Future #1
[09:32:21.357]  length: 2 (resolved future 1)
[09:32:21.358] Future #2
[09:32:21.358]  length: 1 (resolved future 2)
[09:32:21.358]  length: 0 (resolved future 3)
[09:32:21.358] resolve() on environment ... DONE
[09:32:21.359] resolve() on environment ...
[09:32:21.359]  recursive: 0
[09:32:21.360]  elements: [3] ‘c’
[09:32:21.360] Future #1
[09:32:21.360]  length: 2 (resolved future 1)
[09:32:21.361] Future #2
[09:32:21.361]  length: 1 (resolved future 2)
[09:32:21.361]  length: 0 (resolved future 3)
[09:32:21.361] resolve() on environment ... DONE
[09:32:21.362] resolve() on environment ...
[09:32:21.362]  recursive: 0
[09:32:21.363]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[09:32:21.363] Future #1
[09:32:21.363] result() for MulticoreFuture ...
[09:32:21.364] result() for MulticoreFuture ...
[09:32:21.364] result() for MulticoreFuture ... done
[09:32:21.364] result() for MulticoreFuture ... done
[09:32:21.364] result() for MulticoreFuture ...
[09:32:21.365] result() for MulticoreFuture ... done
[09:32:21.365]  length: 2 (resolved future 1)
[09:32:21.365] Future #2
[09:32:21.365] result() for MulticoreFuture ...
[09:32:21.366] result() for MulticoreFuture ...
[09:32:21.366] result() for MulticoreFuture ... done
[09:32:21.366] result() for MulticoreFuture ... done
[09:32:21.366] result() for MulticoreFuture ...
[09:32:21.366] result() for MulticoreFuture ... done
[09:32:21.367]  length: 1 (resolved future 2)
[09:32:21.367]  length: 0 (resolved future 3)
[09:32:21.367] resolve() on environment ... DONE
[09:32:21.368] resolve() on environment ...
[09:32:21.368]  recursive: 99
[09:32:21.368]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:21.368] Future #1
[09:32:21.369] result() for MulticoreFuture ...
[09:32:21.369] result() for MulticoreFuture ... done
[09:32:21.369] result() for MulticoreFuture ...
[09:32:21.369] result() for MulticoreFuture ... done
[09:32:21.369] A MulticoreFuture was resolved
[09:32:21.369]  length: 2 (resolved future 1)
[09:32:21.369] Future #2
[09:32:21.369] result() for MulticoreFuture ...
[09:32:21.370] result() for MulticoreFuture ... done
[09:32:21.370] result() for MulticoreFuture ...
[09:32:21.370] result() for MulticoreFuture ... done
[09:32:21.370] A MulticoreFuture was resolved
[09:32:21.370]  length: 1 (resolved future 2)
[09:32:21.370]  length: 0 (resolved future 3)
[09:32:21.370] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[09:32:21.371] resolve() on list environment ...
[09:32:21.371]  recursive: 0
[09:32:21.372]  length: 2
[09:32:21.372]  elements: ‘a’, ‘b’
[09:32:21.372]  length: 1 (resolved future 1)
[09:32:21.372]  length: 0 (resolved future 2)
[09:32:21.372] resolve() on list environment ... DONE
[09:32:21.372] getGlobalsAndPackages() ...
[09:32:21.373] Searching for globals...
[09:32:21.373] 
[09:32:21.373] Searching for globals ... DONE
[09:32:21.373] - globals: [0] <none>
[09:32:21.373] getGlobalsAndPackages() ... DONE
[09:32:21.374] run() for ‘Future’ ...
[09:32:21.374] - state: ‘created’
[09:32:21.374] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.378]   - Field: ‘label’
[09:32:21.378]   - Field: ‘local’
[09:32:21.378]   - Field: ‘owner’
[09:32:21.378]   - Field: ‘envir’
[09:32:21.381]   - Field: ‘workers’
[09:32:21.381]   - Field: ‘packages’
[09:32:21.381]   - Field: ‘gc’
[09:32:21.381]   - Field: ‘job’
[09:32:21.381]   - Field: ‘conditions’
[09:32:21.381]   - Field: ‘expr’
[09:32:21.382]   - Field: ‘uuid’
[09:32:21.382]   - Field: ‘seed’
[09:32:21.382]   - Field: ‘version’
[09:32:21.382]   - Field: ‘result’
[09:32:21.382]   - Field: ‘asynchronous’
[09:32:21.382]   - Field: ‘calls’
[09:32:21.382]   - Field: ‘globals’
[09:32:21.383]   - Field: ‘stdout’
[09:32:21.383]   - Field: ‘earlySignal’
[09:32:21.383]   - Field: ‘lazy’
[09:32:21.383]   - Field: ‘state’
[09:32:21.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.383] - Launch lazy future ...
[09:32:21.383] Packages needed by the future expression (n = 0): <none>
[09:32:21.384] Packages needed by future strategies (n = 0): <none>
[09:32:21.384] {
[09:32:21.384]     {
[09:32:21.384]         {
[09:32:21.384]             ...future.startTime <- base::Sys.time()
[09:32:21.384]             {
[09:32:21.384]                 {
[09:32:21.384]                   {
[09:32:21.384]                     {
[09:32:21.384]                       base::local({
[09:32:21.384]                         has_future <- base::requireNamespace("future", 
[09:32:21.384]                           quietly = TRUE)
[09:32:21.384]                         if (has_future) {
[09:32:21.384]                           ns <- base::getNamespace("future")
[09:32:21.384]                           version <- ns[[".package"]][["version"]]
[09:32:21.384]                           if (is.null(version)) 
[09:32:21.384]                             version <- utils::packageVersion("future")
[09:32:21.384]                         }
[09:32:21.384]                         else {
[09:32:21.384]                           version <- NULL
[09:32:21.384]                         }
[09:32:21.384]                         if (!has_future || version < "1.8.0") {
[09:32:21.384]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.384]                             "", base::R.version$version.string), 
[09:32:21.384]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.384]                               "release", "version")], collapse = " "), 
[09:32:21.384]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.384]                             info)
[09:32:21.384]                           info <- base::paste(info, collapse = "; ")
[09:32:21.384]                           if (!has_future) {
[09:32:21.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.384]                               info)
[09:32:21.384]                           }
[09:32:21.384]                           else {
[09:32:21.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.384]                               info, version)
[09:32:21.384]                           }
[09:32:21.384]                           base::stop(msg)
[09:32:21.384]                         }
[09:32:21.384]                       })
[09:32:21.384]                     }
[09:32:21.384]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.384]                     base::options(mc.cores = 1L)
[09:32:21.384]                   }
[09:32:21.384]                   ...future.strategy.old <- future::plan("list")
[09:32:21.384]                   options(future.plan = NULL)
[09:32:21.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.384]                 }
[09:32:21.384]                 ...future.workdir <- getwd()
[09:32:21.384]             }
[09:32:21.384]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.384]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.384]         }
[09:32:21.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.384]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.384]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.384]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.384]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.384]             base::names(...future.oldOptions))
[09:32:21.384]     }
[09:32:21.384]     if (FALSE) {
[09:32:21.384]     }
[09:32:21.384]     else {
[09:32:21.384]         if (TRUE) {
[09:32:21.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.384]                 open = "w")
[09:32:21.384]         }
[09:32:21.384]         else {
[09:32:21.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.384]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.384]         }
[09:32:21.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.384]             base::sink(type = "output", split = FALSE)
[09:32:21.384]             base::close(...future.stdout)
[09:32:21.384]         }, add = TRUE)
[09:32:21.384]     }
[09:32:21.384]     ...future.frame <- base::sys.nframe()
[09:32:21.384]     ...future.conditions <- base::list()
[09:32:21.384]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.384]     if (FALSE) {
[09:32:21.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.384]     }
[09:32:21.384]     ...future.result <- base::tryCatch({
[09:32:21.384]         base::withCallingHandlers({
[09:32:21.384]             ...future.value <- base::withVisible(base::local({
[09:32:21.384]                 withCallingHandlers({
[09:32:21.384]                   1
[09:32:21.384]                 }, immediateCondition = function(cond) {
[09:32:21.384]                   save_rds <- function (object, pathname, ...) 
[09:32:21.384]                   {
[09:32:21.384]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.384]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.384]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.384]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.384]                         fi_tmp[["mtime"]])
[09:32:21.384]                     }
[09:32:21.384]                     tryCatch({
[09:32:21.384]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.384]                     }, error = function(ex) {
[09:32:21.384]                       msg <- conditionMessage(ex)
[09:32:21.384]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.384]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.384]                         fi_tmp[["mtime"]], msg)
[09:32:21.384]                       ex$message <- msg
[09:32:21.384]                       stop(ex)
[09:32:21.384]                     })
[09:32:21.384]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.384]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.384]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.384]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.384]                       fi <- file.info(pathname)
[09:32:21.384]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.384]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.384]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.384]                         fi[["size"]], fi[["mtime"]])
[09:32:21.384]                       stop(msg)
[09:32:21.384]                     }
[09:32:21.384]                     invisible(pathname)
[09:32:21.384]                   }
[09:32:21.384]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.384]                     rootPath = tempdir()) 
[09:32:21.384]                   {
[09:32:21.384]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.384]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.384]                       tmpdir = path, fileext = ".rds")
[09:32:21.384]                     save_rds(obj, file)
[09:32:21.384]                   }
[09:32:21.384]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.384]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.384]                   {
[09:32:21.384]                     inherits <- base::inherits
[09:32:21.384]                     invokeRestart <- base::invokeRestart
[09:32:21.384]                     is.null <- base::is.null
[09:32:21.384]                     muffled <- FALSE
[09:32:21.384]                     if (inherits(cond, "message")) {
[09:32:21.384]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.384]                       if (muffled) 
[09:32:21.384]                         invokeRestart("muffleMessage")
[09:32:21.384]                     }
[09:32:21.384]                     else if (inherits(cond, "warning")) {
[09:32:21.384]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.384]                       if (muffled) 
[09:32:21.384]                         invokeRestart("muffleWarning")
[09:32:21.384]                     }
[09:32:21.384]                     else if (inherits(cond, "condition")) {
[09:32:21.384]                       if (!is.null(pattern)) {
[09:32:21.384]                         computeRestarts <- base::computeRestarts
[09:32:21.384]                         grepl <- base::grepl
[09:32:21.384]                         restarts <- computeRestarts(cond)
[09:32:21.384]                         for (restart in restarts) {
[09:32:21.384]                           name <- restart$name
[09:32:21.384]                           if (is.null(name)) 
[09:32:21.384]                             next
[09:32:21.384]                           if (!grepl(pattern, name)) 
[09:32:21.384]                             next
[09:32:21.384]                           invokeRestart(restart)
[09:32:21.384]                           muffled <- TRUE
[09:32:21.384]                           break
[09:32:21.384]                         }
[09:32:21.384]                       }
[09:32:21.384]                     }
[09:32:21.384]                     invisible(muffled)
[09:32:21.384]                   }
[09:32:21.384]                   muffleCondition(cond)
[09:32:21.384]                 })
[09:32:21.384]             }))
[09:32:21.384]             future::FutureResult(value = ...future.value$value, 
[09:32:21.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.384]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.384]                     ...future.globalenv.names))
[09:32:21.384]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.384]         }, condition = base::local({
[09:32:21.384]             c <- base::c
[09:32:21.384]             inherits <- base::inherits
[09:32:21.384]             invokeRestart <- base::invokeRestart
[09:32:21.384]             length <- base::length
[09:32:21.384]             list <- base::list
[09:32:21.384]             seq.int <- base::seq.int
[09:32:21.384]             signalCondition <- base::signalCondition
[09:32:21.384]             sys.calls <- base::sys.calls
[09:32:21.384]             `[[` <- base::`[[`
[09:32:21.384]             `+` <- base::`+`
[09:32:21.384]             `<<-` <- base::`<<-`
[09:32:21.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.384]                   3L)]
[09:32:21.384]             }
[09:32:21.384]             function(cond) {
[09:32:21.384]                 is_error <- inherits(cond, "error")
[09:32:21.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.384]                   NULL)
[09:32:21.384]                 if (is_error) {
[09:32:21.384]                   sessionInformation <- function() {
[09:32:21.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.384]                       search = base::search(), system = base::Sys.info())
[09:32:21.384]                   }
[09:32:21.384]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.384]                     cond$call), session = sessionInformation(), 
[09:32:21.384]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.384]                   signalCondition(cond)
[09:32:21.384]                 }
[09:32:21.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.384]                 "immediateCondition"))) {
[09:32:21.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.384]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.384]                   if (TRUE && !signal) {
[09:32:21.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.384]                     {
[09:32:21.384]                       inherits <- base::inherits
[09:32:21.384]                       invokeRestart <- base::invokeRestart
[09:32:21.384]                       is.null <- base::is.null
[09:32:21.384]                       muffled <- FALSE
[09:32:21.384]                       if (inherits(cond, "message")) {
[09:32:21.384]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.384]                         if (muffled) 
[09:32:21.384]                           invokeRestart("muffleMessage")
[09:32:21.384]                       }
[09:32:21.384]                       else if (inherits(cond, "warning")) {
[09:32:21.384]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.384]                         if (muffled) 
[09:32:21.384]                           invokeRestart("muffleWarning")
[09:32:21.384]                       }
[09:32:21.384]                       else if (inherits(cond, "condition")) {
[09:32:21.384]                         if (!is.null(pattern)) {
[09:32:21.384]                           computeRestarts <- base::computeRestarts
[09:32:21.384]                           grepl <- base::grepl
[09:32:21.384]                           restarts <- computeRestarts(cond)
[09:32:21.384]                           for (restart in restarts) {
[09:32:21.384]                             name <- restart$name
[09:32:21.384]                             if (is.null(name)) 
[09:32:21.384]                               next
[09:32:21.384]                             if (!grepl(pattern, name)) 
[09:32:21.384]                               next
[09:32:21.384]                             invokeRestart(restart)
[09:32:21.384]                             muffled <- TRUE
[09:32:21.384]                             break
[09:32:21.384]                           }
[09:32:21.384]                         }
[09:32:21.384]                       }
[09:32:21.384]                       invisible(muffled)
[09:32:21.384]                     }
[09:32:21.384]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.384]                   }
[09:32:21.384]                 }
[09:32:21.384]                 else {
[09:32:21.384]                   if (TRUE) {
[09:32:21.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.384]                     {
[09:32:21.384]                       inherits <- base::inherits
[09:32:21.384]                       invokeRestart <- base::invokeRestart
[09:32:21.384]                       is.null <- base::is.null
[09:32:21.384]                       muffled <- FALSE
[09:32:21.384]                       if (inherits(cond, "message")) {
[09:32:21.384]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.384]                         if (muffled) 
[09:32:21.384]                           invokeRestart("muffleMessage")
[09:32:21.384]                       }
[09:32:21.384]                       else if (inherits(cond, "warning")) {
[09:32:21.384]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.384]                         if (muffled) 
[09:32:21.384]                           invokeRestart("muffleWarning")
[09:32:21.384]                       }
[09:32:21.384]                       else if (inherits(cond, "condition")) {
[09:32:21.384]                         if (!is.null(pattern)) {
[09:32:21.384]                           computeRestarts <- base::computeRestarts
[09:32:21.384]                           grepl <- base::grepl
[09:32:21.384]                           restarts <- computeRestarts(cond)
[09:32:21.384]                           for (restart in restarts) {
[09:32:21.384]                             name <- restart$name
[09:32:21.384]                             if (is.null(name)) 
[09:32:21.384]                               next
[09:32:21.384]                             if (!grepl(pattern, name)) 
[09:32:21.384]                               next
[09:32:21.384]                             invokeRestart(restart)
[09:32:21.384]                             muffled <- TRUE
[09:32:21.384]                             break
[09:32:21.384]                           }
[09:32:21.384]                         }
[09:32:21.384]                       }
[09:32:21.384]                       invisible(muffled)
[09:32:21.384]                     }
[09:32:21.384]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.384]                   }
[09:32:21.384]                 }
[09:32:21.384]             }
[09:32:21.384]         }))
[09:32:21.384]     }, error = function(ex) {
[09:32:21.384]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.384]                 ...future.rng), started = ...future.startTime, 
[09:32:21.384]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.384]             version = "1.8"), class = "FutureResult")
[09:32:21.384]     }, finally = {
[09:32:21.384]         if (!identical(...future.workdir, getwd())) 
[09:32:21.384]             setwd(...future.workdir)
[09:32:21.384]         {
[09:32:21.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.384]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.384]             }
[09:32:21.384]             base::options(...future.oldOptions)
[09:32:21.384]             if (.Platform$OS.type == "windows") {
[09:32:21.384]                 old_names <- names(...future.oldEnvVars)
[09:32:21.384]                 envs <- base::Sys.getenv()
[09:32:21.384]                 names <- names(envs)
[09:32:21.384]                 common <- intersect(names, old_names)
[09:32:21.384]                 added <- setdiff(names, old_names)
[09:32:21.384]                 removed <- setdiff(old_names, names)
[09:32:21.384]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.384]                   envs[common]]
[09:32:21.384]                 NAMES <- toupper(changed)
[09:32:21.384]                 args <- list()
[09:32:21.384]                 for (kk in seq_along(NAMES)) {
[09:32:21.384]                   name <- changed[[kk]]
[09:32:21.384]                   NAME <- NAMES[[kk]]
[09:32:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.384]                     next
[09:32:21.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.384]                 }
[09:32:21.384]                 NAMES <- toupper(added)
[09:32:21.384]                 for (kk in seq_along(NAMES)) {
[09:32:21.384]                   name <- added[[kk]]
[09:32:21.384]                   NAME <- NAMES[[kk]]
[09:32:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.384]                     next
[09:32:21.384]                   args[[name]] <- ""
[09:32:21.384]                 }
[09:32:21.384]                 NAMES <- toupper(removed)
[09:32:21.384]                 for (kk in seq_along(NAMES)) {
[09:32:21.384]                   name <- removed[[kk]]
[09:32:21.384]                   NAME <- NAMES[[kk]]
[09:32:21.384]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.384]                     next
[09:32:21.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.384]                 }
[09:32:21.384]                 if (length(args) > 0) 
[09:32:21.384]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.384]             }
[09:32:21.384]             else {
[09:32:21.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.384]             }
[09:32:21.384]             {
[09:32:21.384]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.384]                   0L) {
[09:32:21.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.384]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.384]                   base::options(opts)
[09:32:21.384]                 }
[09:32:21.384]                 {
[09:32:21.384]                   {
[09:32:21.384]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.384]                     NULL
[09:32:21.384]                   }
[09:32:21.384]                   options(future.plan = NULL)
[09:32:21.384]                   if (is.na(NA_character_)) 
[09:32:21.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.384]                     .init = FALSE)
[09:32:21.384]                 }
[09:32:21.384]             }
[09:32:21.384]         }
[09:32:21.384]     })
[09:32:21.384]     if (TRUE) {
[09:32:21.384]         base::sink(type = "output", split = FALSE)
[09:32:21.384]         if (TRUE) {
[09:32:21.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.384]         }
[09:32:21.384]         else {
[09:32:21.384]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.384]         }
[09:32:21.384]         base::close(...future.stdout)
[09:32:21.384]         ...future.stdout <- NULL
[09:32:21.384]     }
[09:32:21.384]     ...future.result$conditions <- ...future.conditions
[09:32:21.384]     ...future.result$finished <- base::Sys.time()
[09:32:21.384]     ...future.result
[09:32:21.384] }
[09:32:21.387] requestCore(): workers = 2
[09:32:21.388] MulticoreFuture started
[09:32:21.389] - Launch lazy future ... done
[09:32:21.389] run() for ‘MulticoreFuture’ ... done
[09:32:21.389] plan(): Setting new future strategy stack:
[09:32:21.390] getGlobalsAndPackages() ...
[09:32:21.390] Searching for globals...
[09:32:21.390] List of future strategies:
[09:32:21.390] 1. sequential:
[09:32:21.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.390]    - tweaked: FALSE
[09:32:21.390]    - call: NULL
[09:32:21.391] 
[09:32:21.391] plan(): nbrOfWorkers() = 1
[09:32:21.391] Searching for globals ... DONE
[09:32:21.391] - globals: [0] <none>
[09:32:21.391] getGlobalsAndPackages() ... DONE
[09:32:21.392] run() for ‘Future’ ...
[09:32:21.392] - state: ‘created’
[09:32:21.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.393] plan(): Setting new future strategy stack:
[09:32:21.393] List of future strategies:
[09:32:21.393] 1. multicore:
[09:32:21.393]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.393]    - tweaked: FALSE
[09:32:21.393]    - call: plan(strategy)
[09:32:21.397] plan(): nbrOfWorkers() = 2
[09:32:21.397] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.398] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.398]   - Field: ‘label’
[09:32:21.398]   - Field: ‘local’
[09:32:21.398]   - Field: ‘owner’
[09:32:21.398]   - Field: ‘envir’
[09:32:21.398]   - Field: ‘workers’
[09:32:21.399]   - Field: ‘packages’
[09:32:21.399]   - Field: ‘gc’
[09:32:21.399]   - Field: ‘job’
[09:32:21.399]   - Field: ‘conditions’
[09:32:21.399]   - Field: ‘expr’
[09:32:21.399]   - Field: ‘uuid’
[09:32:21.399]   - Field: ‘seed’
[09:32:21.400]   - Field: ‘version’
[09:32:21.400]   - Field: ‘result’
[09:32:21.400]   - Field: ‘asynchronous’
[09:32:21.400]   - Field: ‘calls’
[09:32:21.400]   - Field: ‘globals’
[09:32:21.400]   - Field: ‘stdout’
[09:32:21.400]   - Field: ‘earlySignal’
[09:32:21.401]   - Field: ‘lazy’
[09:32:21.401]   - Field: ‘state’
[09:32:21.401] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.401] - Launch lazy future ...
[09:32:21.401] Packages needed by the future expression (n = 0): <none>
[09:32:21.402] Packages needed by future strategies (n = 0): <none>
[09:32:21.402] {
[09:32:21.402]     {
[09:32:21.402]         {
[09:32:21.402]             ...future.startTime <- base::Sys.time()
[09:32:21.402]             {
[09:32:21.402]                 {
[09:32:21.402]                   {
[09:32:21.402]                     {
[09:32:21.402]                       base::local({
[09:32:21.402]                         has_future <- base::requireNamespace("future", 
[09:32:21.402]                           quietly = TRUE)
[09:32:21.402]                         if (has_future) {
[09:32:21.402]                           ns <- base::getNamespace("future")
[09:32:21.402]                           version <- ns[[".package"]][["version"]]
[09:32:21.402]                           if (is.null(version)) 
[09:32:21.402]                             version <- utils::packageVersion("future")
[09:32:21.402]                         }
[09:32:21.402]                         else {
[09:32:21.402]                           version <- NULL
[09:32:21.402]                         }
[09:32:21.402]                         if (!has_future || version < "1.8.0") {
[09:32:21.402]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.402]                             "", base::R.version$version.string), 
[09:32:21.402]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.402]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.402]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.402]                               "release", "version")], collapse = " "), 
[09:32:21.402]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.402]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.402]                             info)
[09:32:21.402]                           info <- base::paste(info, collapse = "; ")
[09:32:21.402]                           if (!has_future) {
[09:32:21.402]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.402]                               info)
[09:32:21.402]                           }
[09:32:21.402]                           else {
[09:32:21.402]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.402]                               info, version)
[09:32:21.402]                           }
[09:32:21.402]                           base::stop(msg)
[09:32:21.402]                         }
[09:32:21.402]                       })
[09:32:21.402]                     }
[09:32:21.402]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.402]                     base::options(mc.cores = 1L)
[09:32:21.402]                   }
[09:32:21.402]                   ...future.strategy.old <- future::plan("list")
[09:32:21.402]                   options(future.plan = NULL)
[09:32:21.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.402]                 }
[09:32:21.402]                 ...future.workdir <- getwd()
[09:32:21.402]             }
[09:32:21.402]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.402]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.402]         }
[09:32:21.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.402]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.402]             base::names(...future.oldOptions))
[09:32:21.402]     }
[09:32:21.402]     if (FALSE) {
[09:32:21.402]     }
[09:32:21.402]     else {
[09:32:21.402]         if (TRUE) {
[09:32:21.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.402]                 open = "w")
[09:32:21.402]         }
[09:32:21.402]         else {
[09:32:21.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.402]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.402]         }
[09:32:21.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.402]             base::sink(type = "output", split = FALSE)
[09:32:21.402]             base::close(...future.stdout)
[09:32:21.402]         }, add = TRUE)
[09:32:21.402]     }
[09:32:21.402]     ...future.frame <- base::sys.nframe()
[09:32:21.402]     ...future.conditions <- base::list()
[09:32:21.402]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.402]     if (FALSE) {
[09:32:21.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.402]     }
[09:32:21.402]     ...future.result <- base::tryCatch({
[09:32:21.402]         base::withCallingHandlers({
[09:32:21.402]             ...future.value <- base::withVisible(base::local({
[09:32:21.402]                 withCallingHandlers({
[09:32:21.402]                   2
[09:32:21.402]                 }, immediateCondition = function(cond) {
[09:32:21.402]                   save_rds <- function (object, pathname, ...) 
[09:32:21.402]                   {
[09:32:21.402]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.402]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.402]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.402]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.402]                         fi_tmp[["mtime"]])
[09:32:21.402]                     }
[09:32:21.402]                     tryCatch({
[09:32:21.402]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.402]                     }, error = function(ex) {
[09:32:21.402]                       msg <- conditionMessage(ex)
[09:32:21.402]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.402]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.402]                         fi_tmp[["mtime"]], msg)
[09:32:21.402]                       ex$message <- msg
[09:32:21.402]                       stop(ex)
[09:32:21.402]                     })
[09:32:21.402]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.402]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.402]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.402]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.402]                       fi <- file.info(pathname)
[09:32:21.402]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.402]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.402]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.402]                         fi[["size"]], fi[["mtime"]])
[09:32:21.402]                       stop(msg)
[09:32:21.402]                     }
[09:32:21.402]                     invisible(pathname)
[09:32:21.402]                   }
[09:32:21.402]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.402]                     rootPath = tempdir()) 
[09:32:21.402]                   {
[09:32:21.402]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.402]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.402]                       tmpdir = path, fileext = ".rds")
[09:32:21.402]                     save_rds(obj, file)
[09:32:21.402]                   }
[09:32:21.402]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.402]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.402]                   {
[09:32:21.402]                     inherits <- base::inherits
[09:32:21.402]                     invokeRestart <- base::invokeRestart
[09:32:21.402]                     is.null <- base::is.null
[09:32:21.402]                     muffled <- FALSE
[09:32:21.402]                     if (inherits(cond, "message")) {
[09:32:21.402]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.402]                       if (muffled) 
[09:32:21.402]                         invokeRestart("muffleMessage")
[09:32:21.402]                     }
[09:32:21.402]                     else if (inherits(cond, "warning")) {
[09:32:21.402]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.402]                       if (muffled) 
[09:32:21.402]                         invokeRestart("muffleWarning")
[09:32:21.402]                     }
[09:32:21.402]                     else if (inherits(cond, "condition")) {
[09:32:21.402]                       if (!is.null(pattern)) {
[09:32:21.402]                         computeRestarts <- base::computeRestarts
[09:32:21.402]                         grepl <- base::grepl
[09:32:21.402]                         restarts <- computeRestarts(cond)
[09:32:21.402]                         for (restart in restarts) {
[09:32:21.402]                           name <- restart$name
[09:32:21.402]                           if (is.null(name)) 
[09:32:21.402]                             next
[09:32:21.402]                           if (!grepl(pattern, name)) 
[09:32:21.402]                             next
[09:32:21.402]                           invokeRestart(restart)
[09:32:21.402]                           muffled <- TRUE
[09:32:21.402]                           break
[09:32:21.402]                         }
[09:32:21.402]                       }
[09:32:21.402]                     }
[09:32:21.402]                     invisible(muffled)
[09:32:21.402]                   }
[09:32:21.402]                   muffleCondition(cond)
[09:32:21.402]                 })
[09:32:21.402]             }))
[09:32:21.402]             future::FutureResult(value = ...future.value$value, 
[09:32:21.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.402]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.402]                     ...future.globalenv.names))
[09:32:21.402]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.402]         }, condition = base::local({
[09:32:21.402]             c <- base::c
[09:32:21.402]             inherits <- base::inherits
[09:32:21.402]             invokeRestart <- base::invokeRestart
[09:32:21.402]             length <- base::length
[09:32:21.402]             list <- base::list
[09:32:21.402]             seq.int <- base::seq.int
[09:32:21.402]             signalCondition <- base::signalCondition
[09:32:21.402]             sys.calls <- base::sys.calls
[09:32:21.402]             `[[` <- base::`[[`
[09:32:21.402]             `+` <- base::`+`
[09:32:21.402]             `<<-` <- base::`<<-`
[09:32:21.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.402]                   3L)]
[09:32:21.402]             }
[09:32:21.402]             function(cond) {
[09:32:21.402]                 is_error <- inherits(cond, "error")
[09:32:21.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.402]                   NULL)
[09:32:21.402]                 if (is_error) {
[09:32:21.402]                   sessionInformation <- function() {
[09:32:21.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.402]                       search = base::search(), system = base::Sys.info())
[09:32:21.402]                   }
[09:32:21.402]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.402]                     cond$call), session = sessionInformation(), 
[09:32:21.402]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.402]                   signalCondition(cond)
[09:32:21.402]                 }
[09:32:21.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.402]                 "immediateCondition"))) {
[09:32:21.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.402]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.402]                   if (TRUE && !signal) {
[09:32:21.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.402]                     {
[09:32:21.402]                       inherits <- base::inherits
[09:32:21.402]                       invokeRestart <- base::invokeRestart
[09:32:21.402]                       is.null <- base::is.null
[09:32:21.402]                       muffled <- FALSE
[09:32:21.402]                       if (inherits(cond, "message")) {
[09:32:21.402]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.402]                         if (muffled) 
[09:32:21.402]                           invokeRestart("muffleMessage")
[09:32:21.402]                       }
[09:32:21.402]                       else if (inherits(cond, "warning")) {
[09:32:21.402]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.402]                         if (muffled) 
[09:32:21.402]                           invokeRestart("muffleWarning")
[09:32:21.402]                       }
[09:32:21.402]                       else if (inherits(cond, "condition")) {
[09:32:21.402]                         if (!is.null(pattern)) {
[09:32:21.402]                           computeRestarts <- base::computeRestarts
[09:32:21.402]                           grepl <- base::grepl
[09:32:21.402]                           restarts <- computeRestarts(cond)
[09:32:21.402]                           for (restart in restarts) {
[09:32:21.402]                             name <- restart$name
[09:32:21.402]                             if (is.null(name)) 
[09:32:21.402]                               next
[09:32:21.402]                             if (!grepl(pattern, name)) 
[09:32:21.402]                               next
[09:32:21.402]                             invokeRestart(restart)
[09:32:21.402]                             muffled <- TRUE
[09:32:21.402]                             break
[09:32:21.402]                           }
[09:32:21.402]                         }
[09:32:21.402]                       }
[09:32:21.402]                       invisible(muffled)
[09:32:21.402]                     }
[09:32:21.402]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.402]                   }
[09:32:21.402]                 }
[09:32:21.402]                 else {
[09:32:21.402]                   if (TRUE) {
[09:32:21.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.402]                     {
[09:32:21.402]                       inherits <- base::inherits
[09:32:21.402]                       invokeRestart <- base::invokeRestart
[09:32:21.402]                       is.null <- base::is.null
[09:32:21.402]                       muffled <- FALSE
[09:32:21.402]                       if (inherits(cond, "message")) {
[09:32:21.402]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.402]                         if (muffled) 
[09:32:21.402]                           invokeRestart("muffleMessage")
[09:32:21.402]                       }
[09:32:21.402]                       else if (inherits(cond, "warning")) {
[09:32:21.402]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.402]                         if (muffled) 
[09:32:21.402]                           invokeRestart("muffleWarning")
[09:32:21.402]                       }
[09:32:21.402]                       else if (inherits(cond, "condition")) {
[09:32:21.402]                         if (!is.null(pattern)) {
[09:32:21.402]                           computeRestarts <- base::computeRestarts
[09:32:21.402]                           grepl <- base::grepl
[09:32:21.402]                           restarts <- computeRestarts(cond)
[09:32:21.402]                           for (restart in restarts) {
[09:32:21.402]                             name <- restart$name
[09:32:21.402]                             if (is.null(name)) 
[09:32:21.402]                               next
[09:32:21.402]                             if (!grepl(pattern, name)) 
[09:32:21.402]                               next
[09:32:21.402]                             invokeRestart(restart)
[09:32:21.402]                             muffled <- TRUE
[09:32:21.402]                             break
[09:32:21.402]                           }
[09:32:21.402]                         }
[09:32:21.402]                       }
[09:32:21.402]                       invisible(muffled)
[09:32:21.402]                     }
[09:32:21.402]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.402]                   }
[09:32:21.402]                 }
[09:32:21.402]             }
[09:32:21.402]         }))
[09:32:21.402]     }, error = function(ex) {
[09:32:21.402]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.402]                 ...future.rng), started = ...future.startTime, 
[09:32:21.402]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.402]             version = "1.8"), class = "FutureResult")
[09:32:21.402]     }, finally = {
[09:32:21.402]         if (!identical(...future.workdir, getwd())) 
[09:32:21.402]             setwd(...future.workdir)
[09:32:21.402]         {
[09:32:21.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.402]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.402]             }
[09:32:21.402]             base::options(...future.oldOptions)
[09:32:21.402]             if (.Platform$OS.type == "windows") {
[09:32:21.402]                 old_names <- names(...future.oldEnvVars)
[09:32:21.402]                 envs <- base::Sys.getenv()
[09:32:21.402]                 names <- names(envs)
[09:32:21.402]                 common <- intersect(names, old_names)
[09:32:21.402]                 added <- setdiff(names, old_names)
[09:32:21.402]                 removed <- setdiff(old_names, names)
[09:32:21.402]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.402]                   envs[common]]
[09:32:21.402]                 NAMES <- toupper(changed)
[09:32:21.402]                 args <- list()
[09:32:21.402]                 for (kk in seq_along(NAMES)) {
[09:32:21.402]                   name <- changed[[kk]]
[09:32:21.402]                   NAME <- NAMES[[kk]]
[09:32:21.402]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.402]                     next
[09:32:21.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.402]                 }
[09:32:21.402]                 NAMES <- toupper(added)
[09:32:21.402]                 for (kk in seq_along(NAMES)) {
[09:32:21.402]                   name <- added[[kk]]
[09:32:21.402]                   NAME <- NAMES[[kk]]
[09:32:21.402]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.402]                     next
[09:32:21.402]                   args[[name]] <- ""
[09:32:21.402]                 }
[09:32:21.402]                 NAMES <- toupper(removed)
[09:32:21.402]                 for (kk in seq_along(NAMES)) {
[09:32:21.402]                   name <- removed[[kk]]
[09:32:21.402]                   NAME <- NAMES[[kk]]
[09:32:21.402]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.402]                     next
[09:32:21.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.402]                 }
[09:32:21.402]                 if (length(args) > 0) 
[09:32:21.402]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.402]             }
[09:32:21.402]             else {
[09:32:21.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.402]             }
[09:32:21.402]             {
[09:32:21.402]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.402]                   0L) {
[09:32:21.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.402]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.402]                   base::options(opts)
[09:32:21.402]                 }
[09:32:21.402]                 {
[09:32:21.402]                   {
[09:32:21.402]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.402]                     NULL
[09:32:21.402]                   }
[09:32:21.402]                   options(future.plan = NULL)
[09:32:21.402]                   if (is.na(NA_character_)) 
[09:32:21.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.402]                     .init = FALSE)
[09:32:21.402]                 }
[09:32:21.402]             }
[09:32:21.402]         }
[09:32:21.402]     })
[09:32:21.402]     if (TRUE) {
[09:32:21.402]         base::sink(type = "output", split = FALSE)
[09:32:21.402]         if (TRUE) {
[09:32:21.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.402]         }
[09:32:21.402]         else {
[09:32:21.402]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.402]         }
[09:32:21.402]         base::close(...future.stdout)
[09:32:21.402]         ...future.stdout <- NULL
[09:32:21.402]     }
[09:32:21.402]     ...future.result$conditions <- ...future.conditions
[09:32:21.402]     ...future.result$finished <- base::Sys.time()
[09:32:21.402]     ...future.result
[09:32:21.402] }
[09:32:21.406] requestCore(): workers = 2
[09:32:21.408] MulticoreFuture started
[09:32:21.408] - Launch lazy future ... done
[09:32:21.408] run() for ‘MulticoreFuture’ ... done
[09:32:21.409] plan(): Setting new future strategy stack:
[09:32:21.409] resolve() on list environment ...
[09:32:21.410]  recursive: 0
[09:32:21.409] List of future strategies:
[09:32:21.409] 1. sequential:
[09:32:21.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.409]    - tweaked: FALSE
[09:32:21.409]    - call: NULL
[09:32:21.410] plan(): nbrOfWorkers() = 1
[09:32:21.411]  length: 3
[09:32:21.411]  elements: ‘a’, ‘b’, ‘c’
[09:32:21.411] Future #1
[09:32:21.412]  length: 2 (resolved future 1)
[09:32:21.412] plan(): Setting new future strategy stack:
[09:32:21.412] List of future strategies:
[09:32:21.412] 1. multicore:
[09:32:21.412]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.412]    - tweaked: FALSE
[09:32:21.412]    - call: plan(strategy)
[09:32:21.417] plan(): nbrOfWorkers() = 2
[09:32:21.418] Future #2
[09:32:21.418]  length: 1 (resolved future 2)
[09:32:21.418]  length: 0 (resolved future 3)
[09:32:21.418] resolve() on list environment ... DONE
[09:32:21.419] getGlobalsAndPackages() ...
[09:32:21.419] Searching for globals...
[09:32:21.421] - globals found: [1] ‘{’
[09:32:21.421] Searching for globals ... DONE
[09:32:21.421] Resolving globals: FALSE
[09:32:21.421] 
[09:32:21.422] 
[09:32:21.422] getGlobalsAndPackages() ... DONE
[09:32:21.422] run() for ‘Future’ ...
[09:32:21.422] - state: ‘created’
[09:32:21.423] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.427] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.427] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.427]   - Field: ‘label’
[09:32:21.428]   - Field: ‘local’
[09:32:21.428]   - Field: ‘owner’
[09:32:21.428]   - Field: ‘envir’
[09:32:21.428]   - Field: ‘workers’
[09:32:21.428]   - Field: ‘packages’
[09:32:21.428]   - Field: ‘gc’
[09:32:21.429]   - Field: ‘job’
[09:32:21.429]   - Field: ‘conditions’
[09:32:21.429]   - Field: ‘expr’
[09:32:21.429]   - Field: ‘uuid’
[09:32:21.429]   - Field: ‘seed’
[09:32:21.429]   - Field: ‘version’
[09:32:21.429]   - Field: ‘result’
[09:32:21.429]   - Field: ‘asynchronous’
[09:32:21.430]   - Field: ‘calls’
[09:32:21.430]   - Field: ‘globals’
[09:32:21.430]   - Field: ‘stdout’
[09:32:21.430]   - Field: ‘earlySignal’
[09:32:21.430]   - Field: ‘lazy’
[09:32:21.430]   - Field: ‘state’
[09:32:21.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.431] - Launch lazy future ...
[09:32:21.431] Packages needed by the future expression (n = 0): <none>
[09:32:21.431] Packages needed by future strategies (n = 0): <none>
[09:32:21.432] {
[09:32:21.432]     {
[09:32:21.432]         {
[09:32:21.432]             ...future.startTime <- base::Sys.time()
[09:32:21.432]             {
[09:32:21.432]                 {
[09:32:21.432]                   {
[09:32:21.432]                     {
[09:32:21.432]                       base::local({
[09:32:21.432]                         has_future <- base::requireNamespace("future", 
[09:32:21.432]                           quietly = TRUE)
[09:32:21.432]                         if (has_future) {
[09:32:21.432]                           ns <- base::getNamespace("future")
[09:32:21.432]                           version <- ns[[".package"]][["version"]]
[09:32:21.432]                           if (is.null(version)) 
[09:32:21.432]                             version <- utils::packageVersion("future")
[09:32:21.432]                         }
[09:32:21.432]                         else {
[09:32:21.432]                           version <- NULL
[09:32:21.432]                         }
[09:32:21.432]                         if (!has_future || version < "1.8.0") {
[09:32:21.432]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.432]                             "", base::R.version$version.string), 
[09:32:21.432]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.432]                               "release", "version")], collapse = " "), 
[09:32:21.432]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.432]                             info)
[09:32:21.432]                           info <- base::paste(info, collapse = "; ")
[09:32:21.432]                           if (!has_future) {
[09:32:21.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.432]                               info)
[09:32:21.432]                           }
[09:32:21.432]                           else {
[09:32:21.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.432]                               info, version)
[09:32:21.432]                           }
[09:32:21.432]                           base::stop(msg)
[09:32:21.432]                         }
[09:32:21.432]                       })
[09:32:21.432]                     }
[09:32:21.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.432]                     base::options(mc.cores = 1L)
[09:32:21.432]                   }
[09:32:21.432]                   ...future.strategy.old <- future::plan("list")
[09:32:21.432]                   options(future.plan = NULL)
[09:32:21.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.432]                 }
[09:32:21.432]                 ...future.workdir <- getwd()
[09:32:21.432]             }
[09:32:21.432]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.432]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.432]         }
[09:32:21.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.432]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.432]             base::names(...future.oldOptions))
[09:32:21.432]     }
[09:32:21.432]     if (FALSE) {
[09:32:21.432]     }
[09:32:21.432]     else {
[09:32:21.432]         if (TRUE) {
[09:32:21.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.432]                 open = "w")
[09:32:21.432]         }
[09:32:21.432]         else {
[09:32:21.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.432]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.432]         }
[09:32:21.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.432]             base::sink(type = "output", split = FALSE)
[09:32:21.432]             base::close(...future.stdout)
[09:32:21.432]         }, add = TRUE)
[09:32:21.432]     }
[09:32:21.432]     ...future.frame <- base::sys.nframe()
[09:32:21.432]     ...future.conditions <- base::list()
[09:32:21.432]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.432]     if (FALSE) {
[09:32:21.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.432]     }
[09:32:21.432]     ...future.result <- base::tryCatch({
[09:32:21.432]         base::withCallingHandlers({
[09:32:21.432]             ...future.value <- base::withVisible(base::local({
[09:32:21.432]                 withCallingHandlers({
[09:32:21.432]                   {
[09:32:21.432]                     1
[09:32:21.432]                   }
[09:32:21.432]                 }, immediateCondition = function(cond) {
[09:32:21.432]                   save_rds <- function (object, pathname, ...) 
[09:32:21.432]                   {
[09:32:21.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.432]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.432]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.432]                         fi_tmp[["mtime"]])
[09:32:21.432]                     }
[09:32:21.432]                     tryCatch({
[09:32:21.432]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.432]                     }, error = function(ex) {
[09:32:21.432]                       msg <- conditionMessage(ex)
[09:32:21.432]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.432]                         fi_tmp[["mtime"]], msg)
[09:32:21.432]                       ex$message <- msg
[09:32:21.432]                       stop(ex)
[09:32:21.432]                     })
[09:32:21.432]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.432]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.432]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.432]                       fi <- file.info(pathname)
[09:32:21.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.432]                         fi[["size"]], fi[["mtime"]])
[09:32:21.432]                       stop(msg)
[09:32:21.432]                     }
[09:32:21.432]                     invisible(pathname)
[09:32:21.432]                   }
[09:32:21.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.432]                     rootPath = tempdir()) 
[09:32:21.432]                   {
[09:32:21.432]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.432]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.432]                       tmpdir = path, fileext = ".rds")
[09:32:21.432]                     save_rds(obj, file)
[09:32:21.432]                   }
[09:32:21.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.432]                   {
[09:32:21.432]                     inherits <- base::inherits
[09:32:21.432]                     invokeRestart <- base::invokeRestart
[09:32:21.432]                     is.null <- base::is.null
[09:32:21.432]                     muffled <- FALSE
[09:32:21.432]                     if (inherits(cond, "message")) {
[09:32:21.432]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.432]                       if (muffled) 
[09:32:21.432]                         invokeRestart("muffleMessage")
[09:32:21.432]                     }
[09:32:21.432]                     else if (inherits(cond, "warning")) {
[09:32:21.432]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.432]                       if (muffled) 
[09:32:21.432]                         invokeRestart("muffleWarning")
[09:32:21.432]                     }
[09:32:21.432]                     else if (inherits(cond, "condition")) {
[09:32:21.432]                       if (!is.null(pattern)) {
[09:32:21.432]                         computeRestarts <- base::computeRestarts
[09:32:21.432]                         grepl <- base::grepl
[09:32:21.432]                         restarts <- computeRestarts(cond)
[09:32:21.432]                         for (restart in restarts) {
[09:32:21.432]                           name <- restart$name
[09:32:21.432]                           if (is.null(name)) 
[09:32:21.432]                             next
[09:32:21.432]                           if (!grepl(pattern, name)) 
[09:32:21.432]                             next
[09:32:21.432]                           invokeRestart(restart)
[09:32:21.432]                           muffled <- TRUE
[09:32:21.432]                           break
[09:32:21.432]                         }
[09:32:21.432]                       }
[09:32:21.432]                     }
[09:32:21.432]                     invisible(muffled)
[09:32:21.432]                   }
[09:32:21.432]                   muffleCondition(cond)
[09:32:21.432]                 })
[09:32:21.432]             }))
[09:32:21.432]             future::FutureResult(value = ...future.value$value, 
[09:32:21.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.432]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.432]                     ...future.globalenv.names))
[09:32:21.432]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.432]         }, condition = base::local({
[09:32:21.432]             c <- base::c
[09:32:21.432]             inherits <- base::inherits
[09:32:21.432]             invokeRestart <- base::invokeRestart
[09:32:21.432]             length <- base::length
[09:32:21.432]             list <- base::list
[09:32:21.432]             seq.int <- base::seq.int
[09:32:21.432]             signalCondition <- base::signalCondition
[09:32:21.432]             sys.calls <- base::sys.calls
[09:32:21.432]             `[[` <- base::`[[`
[09:32:21.432]             `+` <- base::`+`
[09:32:21.432]             `<<-` <- base::`<<-`
[09:32:21.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.432]                   3L)]
[09:32:21.432]             }
[09:32:21.432]             function(cond) {
[09:32:21.432]                 is_error <- inherits(cond, "error")
[09:32:21.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.432]                   NULL)
[09:32:21.432]                 if (is_error) {
[09:32:21.432]                   sessionInformation <- function() {
[09:32:21.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.432]                       search = base::search(), system = base::Sys.info())
[09:32:21.432]                   }
[09:32:21.432]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.432]                     cond$call), session = sessionInformation(), 
[09:32:21.432]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.432]                   signalCondition(cond)
[09:32:21.432]                 }
[09:32:21.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.432]                 "immediateCondition"))) {
[09:32:21.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.432]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.432]                   if (TRUE && !signal) {
[09:32:21.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.432]                     {
[09:32:21.432]                       inherits <- base::inherits
[09:32:21.432]                       invokeRestart <- base::invokeRestart
[09:32:21.432]                       is.null <- base::is.null
[09:32:21.432]                       muffled <- FALSE
[09:32:21.432]                       if (inherits(cond, "message")) {
[09:32:21.432]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.432]                         if (muffled) 
[09:32:21.432]                           invokeRestart("muffleMessage")
[09:32:21.432]                       }
[09:32:21.432]                       else if (inherits(cond, "warning")) {
[09:32:21.432]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.432]                         if (muffled) 
[09:32:21.432]                           invokeRestart("muffleWarning")
[09:32:21.432]                       }
[09:32:21.432]                       else if (inherits(cond, "condition")) {
[09:32:21.432]                         if (!is.null(pattern)) {
[09:32:21.432]                           computeRestarts <- base::computeRestarts
[09:32:21.432]                           grepl <- base::grepl
[09:32:21.432]                           restarts <- computeRestarts(cond)
[09:32:21.432]                           for (restart in restarts) {
[09:32:21.432]                             name <- restart$name
[09:32:21.432]                             if (is.null(name)) 
[09:32:21.432]                               next
[09:32:21.432]                             if (!grepl(pattern, name)) 
[09:32:21.432]                               next
[09:32:21.432]                             invokeRestart(restart)
[09:32:21.432]                             muffled <- TRUE
[09:32:21.432]                             break
[09:32:21.432]                           }
[09:32:21.432]                         }
[09:32:21.432]                       }
[09:32:21.432]                       invisible(muffled)
[09:32:21.432]                     }
[09:32:21.432]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.432]                   }
[09:32:21.432]                 }
[09:32:21.432]                 else {
[09:32:21.432]                   if (TRUE) {
[09:32:21.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.432]                     {
[09:32:21.432]                       inherits <- base::inherits
[09:32:21.432]                       invokeRestart <- base::invokeRestart
[09:32:21.432]                       is.null <- base::is.null
[09:32:21.432]                       muffled <- FALSE
[09:32:21.432]                       if (inherits(cond, "message")) {
[09:32:21.432]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.432]                         if (muffled) 
[09:32:21.432]                           invokeRestart("muffleMessage")
[09:32:21.432]                       }
[09:32:21.432]                       else if (inherits(cond, "warning")) {
[09:32:21.432]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.432]                         if (muffled) 
[09:32:21.432]                           invokeRestart("muffleWarning")
[09:32:21.432]                       }
[09:32:21.432]                       else if (inherits(cond, "condition")) {
[09:32:21.432]                         if (!is.null(pattern)) {
[09:32:21.432]                           computeRestarts <- base::computeRestarts
[09:32:21.432]                           grepl <- base::grepl
[09:32:21.432]                           restarts <- computeRestarts(cond)
[09:32:21.432]                           for (restart in restarts) {
[09:32:21.432]                             name <- restart$name
[09:32:21.432]                             if (is.null(name)) 
[09:32:21.432]                               next
[09:32:21.432]                             if (!grepl(pattern, name)) 
[09:32:21.432]                               next
[09:32:21.432]                             invokeRestart(restart)
[09:32:21.432]                             muffled <- TRUE
[09:32:21.432]                             break
[09:32:21.432]                           }
[09:32:21.432]                         }
[09:32:21.432]                       }
[09:32:21.432]                       invisible(muffled)
[09:32:21.432]                     }
[09:32:21.432]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.432]                   }
[09:32:21.432]                 }
[09:32:21.432]             }
[09:32:21.432]         }))
[09:32:21.432]     }, error = function(ex) {
[09:32:21.432]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.432]                 ...future.rng), started = ...future.startTime, 
[09:32:21.432]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.432]             version = "1.8"), class = "FutureResult")
[09:32:21.432]     }, finally = {
[09:32:21.432]         if (!identical(...future.workdir, getwd())) 
[09:32:21.432]             setwd(...future.workdir)
[09:32:21.432]         {
[09:32:21.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.432]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.432]             }
[09:32:21.432]             base::options(...future.oldOptions)
[09:32:21.432]             if (.Platform$OS.type == "windows") {
[09:32:21.432]                 old_names <- names(...future.oldEnvVars)
[09:32:21.432]                 envs <- base::Sys.getenv()
[09:32:21.432]                 names <- names(envs)
[09:32:21.432]                 common <- intersect(names, old_names)
[09:32:21.432]                 added <- setdiff(names, old_names)
[09:32:21.432]                 removed <- setdiff(old_names, names)
[09:32:21.432]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.432]                   envs[common]]
[09:32:21.432]                 NAMES <- toupper(changed)
[09:32:21.432]                 args <- list()
[09:32:21.432]                 for (kk in seq_along(NAMES)) {
[09:32:21.432]                   name <- changed[[kk]]
[09:32:21.432]                   NAME <- NAMES[[kk]]
[09:32:21.432]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.432]                     next
[09:32:21.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.432]                 }
[09:32:21.432]                 NAMES <- toupper(added)
[09:32:21.432]                 for (kk in seq_along(NAMES)) {
[09:32:21.432]                   name <- added[[kk]]
[09:32:21.432]                   NAME <- NAMES[[kk]]
[09:32:21.432]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.432]                     next
[09:32:21.432]                   args[[name]] <- ""
[09:32:21.432]                 }
[09:32:21.432]                 NAMES <- toupper(removed)
[09:32:21.432]                 for (kk in seq_along(NAMES)) {
[09:32:21.432]                   name <- removed[[kk]]
[09:32:21.432]                   NAME <- NAMES[[kk]]
[09:32:21.432]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.432]                     next
[09:32:21.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.432]                 }
[09:32:21.432]                 if (length(args) > 0) 
[09:32:21.432]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.432]             }
[09:32:21.432]             else {
[09:32:21.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.432]             }
[09:32:21.432]             {
[09:32:21.432]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.432]                   0L) {
[09:32:21.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.432]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.432]                   base::options(opts)
[09:32:21.432]                 }
[09:32:21.432]                 {
[09:32:21.432]                   {
[09:32:21.432]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.432]                     NULL
[09:32:21.432]                   }
[09:32:21.432]                   options(future.plan = NULL)
[09:32:21.432]                   if (is.na(NA_character_)) 
[09:32:21.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.432]                     .init = FALSE)
[09:32:21.432]                 }
[09:32:21.432]             }
[09:32:21.432]         }
[09:32:21.432]     })
[09:32:21.432]     if (TRUE) {
[09:32:21.432]         base::sink(type = "output", split = FALSE)
[09:32:21.432]         if (TRUE) {
[09:32:21.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.432]         }
[09:32:21.432]         else {
[09:32:21.432]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.432]         }
[09:32:21.432]         base::close(...future.stdout)
[09:32:21.432]         ...future.stdout <- NULL
[09:32:21.432]     }
[09:32:21.432]     ...future.result$conditions <- ...future.conditions
[09:32:21.432]     ...future.result$finished <- base::Sys.time()
[09:32:21.432]     ...future.result
[09:32:21.432] }
[09:32:21.435] requestCore(): workers = 2
[09:32:21.435] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.446] result() for MulticoreFuture ...
[09:32:21.447] result() for MulticoreFuture ...
[09:32:21.447] result() for MulticoreFuture ... done
[09:32:21.447] result() for MulticoreFuture ... done
[09:32:21.447] result() for MulticoreFuture ...
[09:32:21.448] result() for MulticoreFuture ... done
[09:32:21.450] MulticoreFuture started
[09:32:21.450] - Launch lazy future ... done
[09:32:21.450] run() for ‘MulticoreFuture’ ... done
[09:32:21.450] plan(): Setting new future strategy stack:
[09:32:21.451] getGlobalsAndPackages() ...
[09:32:21.451] Searching for globals...
[09:32:21.451] List of future strategies:
[09:32:21.451] 1. sequential:
[09:32:21.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.451]    - tweaked: FALSE
[09:32:21.451]    - call: NULL
[09:32:21.452] plan(): nbrOfWorkers() = 1
[09:32:21.453] - globals found: [1] ‘{’
[09:32:21.453] Searching for globals ... DONE
[09:32:21.453] Resolving globals: FALSE
[09:32:21.453] 
[09:32:21.454] 
[09:32:21.454] plan(): Setting new future strategy stack:
[09:32:21.454] getGlobalsAndPackages() ... DONE
[09:32:21.454] run() for ‘Future’ ...
[09:32:21.454] List of future strategies:
[09:32:21.454] 1. multicore:
[09:32:21.454]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.454]    - tweaked: FALSE
[09:32:21.454]    - call: plan(strategy)
[09:32:21.454] - state: ‘created’
[09:32:21.455] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.462] plan(): nbrOfWorkers() = 2
[09:32:21.465] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.466] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.466]   - Field: ‘label’
[09:32:21.466]   - Field: ‘local’
[09:32:21.467]   - Field: ‘owner’
[09:32:21.467]   - Field: ‘envir’
[09:32:21.467]   - Field: ‘workers’
[09:32:21.467]   - Field: ‘packages’
[09:32:21.467]   - Field: ‘gc’
[09:32:21.468]   - Field: ‘job’
[09:32:21.468]   - Field: ‘conditions’
[09:32:21.468]   - Field: ‘expr’
[09:32:21.468]   - Field: ‘uuid’
[09:32:21.468]   - Field: ‘seed’
[09:32:21.468]   - Field: ‘version’
[09:32:21.469]   - Field: ‘result’
[09:32:21.469]   - Field: ‘asynchronous’
[09:32:21.469]   - Field: ‘calls’
[09:32:21.469]   - Field: ‘globals’
[09:32:21.469]   - Field: ‘stdout’
[09:32:21.469]   - Field: ‘earlySignal’
[09:32:21.470]   - Field: ‘lazy’
[09:32:21.470]   - Field: ‘state’
[09:32:21.470] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.470] - Launch lazy future ...
[09:32:21.470] Packages needed by the future expression (n = 0): <none>
[09:32:21.471] Packages needed by future strategies (n = 0): <none>
[09:32:21.471] {
[09:32:21.471]     {
[09:32:21.471]         {
[09:32:21.471]             ...future.startTime <- base::Sys.time()
[09:32:21.471]             {
[09:32:21.471]                 {
[09:32:21.471]                   {
[09:32:21.471]                     {
[09:32:21.471]                       base::local({
[09:32:21.471]                         has_future <- base::requireNamespace("future", 
[09:32:21.471]                           quietly = TRUE)
[09:32:21.471]                         if (has_future) {
[09:32:21.471]                           ns <- base::getNamespace("future")
[09:32:21.471]                           version <- ns[[".package"]][["version"]]
[09:32:21.471]                           if (is.null(version)) 
[09:32:21.471]                             version <- utils::packageVersion("future")
[09:32:21.471]                         }
[09:32:21.471]                         else {
[09:32:21.471]                           version <- NULL
[09:32:21.471]                         }
[09:32:21.471]                         if (!has_future || version < "1.8.0") {
[09:32:21.471]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.471]                             "", base::R.version$version.string), 
[09:32:21.471]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.471]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.471]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.471]                               "release", "version")], collapse = " "), 
[09:32:21.471]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.471]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.471]                             info)
[09:32:21.471]                           info <- base::paste(info, collapse = "; ")
[09:32:21.471]                           if (!has_future) {
[09:32:21.471]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.471]                               info)
[09:32:21.471]                           }
[09:32:21.471]                           else {
[09:32:21.471]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.471]                               info, version)
[09:32:21.471]                           }
[09:32:21.471]                           base::stop(msg)
[09:32:21.471]                         }
[09:32:21.471]                       })
[09:32:21.471]                     }
[09:32:21.471]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.471]                     base::options(mc.cores = 1L)
[09:32:21.471]                   }
[09:32:21.471]                   ...future.strategy.old <- future::plan("list")
[09:32:21.471]                   options(future.plan = NULL)
[09:32:21.471]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.471]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.471]                 }
[09:32:21.471]                 ...future.workdir <- getwd()
[09:32:21.471]             }
[09:32:21.471]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.471]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.471]         }
[09:32:21.471]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.471]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.471]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.471]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.471]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.471]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.471]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.471]             base::names(...future.oldOptions))
[09:32:21.471]     }
[09:32:21.471]     if (FALSE) {
[09:32:21.471]     }
[09:32:21.471]     else {
[09:32:21.471]         if (TRUE) {
[09:32:21.471]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.471]                 open = "w")
[09:32:21.471]         }
[09:32:21.471]         else {
[09:32:21.471]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.471]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.471]         }
[09:32:21.471]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.471]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.471]             base::sink(type = "output", split = FALSE)
[09:32:21.471]             base::close(...future.stdout)
[09:32:21.471]         }, add = TRUE)
[09:32:21.471]     }
[09:32:21.471]     ...future.frame <- base::sys.nframe()
[09:32:21.471]     ...future.conditions <- base::list()
[09:32:21.471]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.471]     if (FALSE) {
[09:32:21.471]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.471]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.471]     }
[09:32:21.471]     ...future.result <- base::tryCatch({
[09:32:21.471]         base::withCallingHandlers({
[09:32:21.471]             ...future.value <- base::withVisible(base::local({
[09:32:21.471]                 withCallingHandlers({
[09:32:21.471]                   {
[09:32:21.471]                     2
[09:32:21.471]                   }
[09:32:21.471]                 }, immediateCondition = function(cond) {
[09:32:21.471]                   save_rds <- function (object, pathname, ...) 
[09:32:21.471]                   {
[09:32:21.471]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.471]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.471]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.471]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.471]                         fi_tmp[["mtime"]])
[09:32:21.471]                     }
[09:32:21.471]                     tryCatch({
[09:32:21.471]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.471]                     }, error = function(ex) {
[09:32:21.471]                       msg <- conditionMessage(ex)
[09:32:21.471]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.471]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.471]                         fi_tmp[["mtime"]], msg)
[09:32:21.471]                       ex$message <- msg
[09:32:21.471]                       stop(ex)
[09:32:21.471]                     })
[09:32:21.471]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.471]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.471]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.471]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.471]                       fi <- file.info(pathname)
[09:32:21.471]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.471]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.471]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.471]                         fi[["size"]], fi[["mtime"]])
[09:32:21.471]                       stop(msg)
[09:32:21.471]                     }
[09:32:21.471]                     invisible(pathname)
[09:32:21.471]                   }
[09:32:21.471]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.471]                     rootPath = tempdir()) 
[09:32:21.471]                   {
[09:32:21.471]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.471]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.471]                       tmpdir = path, fileext = ".rds")
[09:32:21.471]                     save_rds(obj, file)
[09:32:21.471]                   }
[09:32:21.471]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.471]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.471]                   {
[09:32:21.471]                     inherits <- base::inherits
[09:32:21.471]                     invokeRestart <- base::invokeRestart
[09:32:21.471]                     is.null <- base::is.null
[09:32:21.471]                     muffled <- FALSE
[09:32:21.471]                     if (inherits(cond, "message")) {
[09:32:21.471]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.471]                       if (muffled) 
[09:32:21.471]                         invokeRestart("muffleMessage")
[09:32:21.471]                     }
[09:32:21.471]                     else if (inherits(cond, "warning")) {
[09:32:21.471]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.471]                       if (muffled) 
[09:32:21.471]                         invokeRestart("muffleWarning")
[09:32:21.471]                     }
[09:32:21.471]                     else if (inherits(cond, "condition")) {
[09:32:21.471]                       if (!is.null(pattern)) {
[09:32:21.471]                         computeRestarts <- base::computeRestarts
[09:32:21.471]                         grepl <- base::grepl
[09:32:21.471]                         restarts <- computeRestarts(cond)
[09:32:21.471]                         for (restart in restarts) {
[09:32:21.471]                           name <- restart$name
[09:32:21.471]                           if (is.null(name)) 
[09:32:21.471]                             next
[09:32:21.471]                           if (!grepl(pattern, name)) 
[09:32:21.471]                             next
[09:32:21.471]                           invokeRestart(restart)
[09:32:21.471]                           muffled <- TRUE
[09:32:21.471]                           break
[09:32:21.471]                         }
[09:32:21.471]                       }
[09:32:21.471]                     }
[09:32:21.471]                     invisible(muffled)
[09:32:21.471]                   }
[09:32:21.471]                   muffleCondition(cond)
[09:32:21.471]                 })
[09:32:21.471]             }))
[09:32:21.471]             future::FutureResult(value = ...future.value$value, 
[09:32:21.471]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.471]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.471]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.471]                     ...future.globalenv.names))
[09:32:21.471]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.471]         }, condition = base::local({
[09:32:21.471]             c <- base::c
[09:32:21.471]             inherits <- base::inherits
[09:32:21.471]             invokeRestart <- base::invokeRestart
[09:32:21.471]             length <- base::length
[09:32:21.471]             list <- base::list
[09:32:21.471]             seq.int <- base::seq.int
[09:32:21.471]             signalCondition <- base::signalCondition
[09:32:21.471]             sys.calls <- base::sys.calls
[09:32:21.471]             `[[` <- base::`[[`
[09:32:21.471]             `+` <- base::`+`
[09:32:21.471]             `<<-` <- base::`<<-`
[09:32:21.471]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.471]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.471]                   3L)]
[09:32:21.471]             }
[09:32:21.471]             function(cond) {
[09:32:21.471]                 is_error <- inherits(cond, "error")
[09:32:21.471]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.471]                   NULL)
[09:32:21.471]                 if (is_error) {
[09:32:21.471]                   sessionInformation <- function() {
[09:32:21.471]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.471]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.471]                       search = base::search(), system = base::Sys.info())
[09:32:21.471]                   }
[09:32:21.471]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.471]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.471]                     cond$call), session = sessionInformation(), 
[09:32:21.471]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.471]                   signalCondition(cond)
[09:32:21.471]                 }
[09:32:21.471]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.471]                 "immediateCondition"))) {
[09:32:21.471]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.471]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.471]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.471]                   if (TRUE && !signal) {
[09:32:21.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.471]                     {
[09:32:21.471]                       inherits <- base::inherits
[09:32:21.471]                       invokeRestart <- base::invokeRestart
[09:32:21.471]                       is.null <- base::is.null
[09:32:21.471]                       muffled <- FALSE
[09:32:21.471]                       if (inherits(cond, "message")) {
[09:32:21.471]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.471]                         if (muffled) 
[09:32:21.471]                           invokeRestart("muffleMessage")
[09:32:21.471]                       }
[09:32:21.471]                       else if (inherits(cond, "warning")) {
[09:32:21.471]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.471]                         if (muffled) 
[09:32:21.471]                           invokeRestart("muffleWarning")
[09:32:21.471]                       }
[09:32:21.471]                       else if (inherits(cond, "condition")) {
[09:32:21.471]                         if (!is.null(pattern)) {
[09:32:21.471]                           computeRestarts <- base::computeRestarts
[09:32:21.471]                           grepl <- base::grepl
[09:32:21.471]                           restarts <- computeRestarts(cond)
[09:32:21.471]                           for (restart in restarts) {
[09:32:21.471]                             name <- restart$name
[09:32:21.471]                             if (is.null(name)) 
[09:32:21.471]                               next
[09:32:21.471]                             if (!grepl(pattern, name)) 
[09:32:21.471]                               next
[09:32:21.471]                             invokeRestart(restart)
[09:32:21.471]                             muffled <- TRUE
[09:32:21.471]                             break
[09:32:21.471]                           }
[09:32:21.471]                         }
[09:32:21.471]                       }
[09:32:21.471]                       invisible(muffled)
[09:32:21.471]                     }
[09:32:21.471]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.471]                   }
[09:32:21.471]                 }
[09:32:21.471]                 else {
[09:32:21.471]                   if (TRUE) {
[09:32:21.471]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.471]                     {
[09:32:21.471]                       inherits <- base::inherits
[09:32:21.471]                       invokeRestart <- base::invokeRestart
[09:32:21.471]                       is.null <- base::is.null
[09:32:21.471]                       muffled <- FALSE
[09:32:21.471]                       if (inherits(cond, "message")) {
[09:32:21.471]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.471]                         if (muffled) 
[09:32:21.471]                           invokeRestart("muffleMessage")
[09:32:21.471]                       }
[09:32:21.471]                       else if (inherits(cond, "warning")) {
[09:32:21.471]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.471]                         if (muffled) 
[09:32:21.471]                           invokeRestart("muffleWarning")
[09:32:21.471]                       }
[09:32:21.471]                       else if (inherits(cond, "condition")) {
[09:32:21.471]                         if (!is.null(pattern)) {
[09:32:21.471]                           computeRestarts <- base::computeRestarts
[09:32:21.471]                           grepl <- base::grepl
[09:32:21.471]                           restarts <- computeRestarts(cond)
[09:32:21.471]                           for (restart in restarts) {
[09:32:21.471]                             name <- restart$name
[09:32:21.471]                             if (is.null(name)) 
[09:32:21.471]                               next
[09:32:21.471]                             if (!grepl(pattern, name)) 
[09:32:21.471]                               next
[09:32:21.471]                             invokeRestart(restart)
[09:32:21.471]                             muffled <- TRUE
[09:32:21.471]                             break
[09:32:21.471]                           }
[09:32:21.471]                         }
[09:32:21.471]                       }
[09:32:21.471]                       invisible(muffled)
[09:32:21.471]                     }
[09:32:21.471]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.471]                   }
[09:32:21.471]                 }
[09:32:21.471]             }
[09:32:21.471]         }))
[09:32:21.471]     }, error = function(ex) {
[09:32:21.471]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.471]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.471]                 ...future.rng), started = ...future.startTime, 
[09:32:21.471]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.471]             version = "1.8"), class = "FutureResult")
[09:32:21.471]     }, finally = {
[09:32:21.471]         if (!identical(...future.workdir, getwd())) 
[09:32:21.471]             setwd(...future.workdir)
[09:32:21.471]         {
[09:32:21.471]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.471]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.471]             }
[09:32:21.471]             base::options(...future.oldOptions)
[09:32:21.471]             if (.Platform$OS.type == "windows") {
[09:32:21.471]                 old_names <- names(...future.oldEnvVars)
[09:32:21.471]                 envs <- base::Sys.getenv()
[09:32:21.471]                 names <- names(envs)
[09:32:21.471]                 common <- intersect(names, old_names)
[09:32:21.471]                 added <- setdiff(names, old_names)
[09:32:21.471]                 removed <- setdiff(old_names, names)
[09:32:21.471]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.471]                   envs[common]]
[09:32:21.471]                 NAMES <- toupper(changed)
[09:32:21.471]                 args <- list()
[09:32:21.471]                 for (kk in seq_along(NAMES)) {
[09:32:21.471]                   name <- changed[[kk]]
[09:32:21.471]                   NAME <- NAMES[[kk]]
[09:32:21.471]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.471]                     next
[09:32:21.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.471]                 }
[09:32:21.471]                 NAMES <- toupper(added)
[09:32:21.471]                 for (kk in seq_along(NAMES)) {
[09:32:21.471]                   name <- added[[kk]]
[09:32:21.471]                   NAME <- NAMES[[kk]]
[09:32:21.471]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.471]                     next
[09:32:21.471]                   args[[name]] <- ""
[09:32:21.471]                 }
[09:32:21.471]                 NAMES <- toupper(removed)
[09:32:21.471]                 for (kk in seq_along(NAMES)) {
[09:32:21.471]                   name <- removed[[kk]]
[09:32:21.471]                   NAME <- NAMES[[kk]]
[09:32:21.471]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.471]                     next
[09:32:21.471]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.471]                 }
[09:32:21.471]                 if (length(args) > 0) 
[09:32:21.471]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.471]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.471]             }
[09:32:21.471]             else {
[09:32:21.471]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.471]             }
[09:32:21.471]             {
[09:32:21.471]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.471]                   0L) {
[09:32:21.471]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.471]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.471]                   base::options(opts)
[09:32:21.471]                 }
[09:32:21.471]                 {
[09:32:21.471]                   {
[09:32:21.471]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.471]                     NULL
[09:32:21.471]                   }
[09:32:21.471]                   options(future.plan = NULL)
[09:32:21.471]                   if (is.na(NA_character_)) 
[09:32:21.471]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.471]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.471]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.471]                     .init = FALSE)
[09:32:21.471]                 }
[09:32:21.471]             }
[09:32:21.471]         }
[09:32:21.471]     })
[09:32:21.471]     if (TRUE) {
[09:32:21.471]         base::sink(type = "output", split = FALSE)
[09:32:21.471]         if (TRUE) {
[09:32:21.471]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.471]         }
[09:32:21.471]         else {
[09:32:21.471]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.471]         }
[09:32:21.471]         base::close(...future.stdout)
[09:32:21.471]         ...future.stdout <- NULL
[09:32:21.471]     }
[09:32:21.471]     ...future.result$conditions <- ...future.conditions
[09:32:21.471]     ...future.result$finished <- base::Sys.time()
[09:32:21.471]     ...future.result
[09:32:21.471] }
[09:32:21.474] requestCore(): workers = 2
[09:32:21.474] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.485] result() for MulticoreFuture ...
[09:32:21.486] result() for MulticoreFuture ...
[09:32:21.486] result() for MulticoreFuture ... done
[09:32:21.486] result() for MulticoreFuture ... done
[09:32:21.486] result() for MulticoreFuture ...
[09:32:21.486] result() for MulticoreFuture ... done
[09:32:21.488] MulticoreFuture started
[09:32:21.489] - Launch lazy future ... done
[09:32:21.489] run() for ‘MulticoreFuture’ ... done
[09:32:21.490] plan(): Setting new future strategy stack:
[09:32:21.491] resolve() on list environment ...
[09:32:21.490] List of future strategies:
[09:32:21.490] 1. sequential:
[09:32:21.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.490]    - tweaked: FALSE
[09:32:21.490]    - call: NULL
[09:32:21.491]  recursive: 0
[09:32:21.491] plan(): nbrOfWorkers() = 1
[09:32:21.493]  length: 3
[09:32:21.493]  elements: ‘a’, ‘b’, ‘c’
[09:32:21.494] Future #1
[09:32:21.494] plan(): Setting new future strategy stack:
[09:32:21.494]  length: 2 (resolved future 1)
[09:32:21.494] List of future strategies:
[09:32:21.494] 1. multicore:
[09:32:21.494]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.494]    - tweaked: FALSE
[09:32:21.494]    - call: plan(strategy)
[09:32:21.499] plan(): nbrOfWorkers() = 2
[09:32:21.500] Future #2
[09:32:21.500]  length: 1 (resolved future 2)
[09:32:21.500]  length: 0 (resolved future 3)
[09:32:21.500] resolve() on list environment ... DONE
[09:32:21.501] getGlobalsAndPackages() ...
[09:32:21.501] Searching for globals...
[09:32:21.502] - globals found: [1] ‘{’
[09:32:21.503] Searching for globals ... DONE
[09:32:21.503] Resolving globals: FALSE
[09:32:21.503] 
[09:32:21.504] 
[09:32:21.504] getGlobalsAndPackages() ... DONE
[09:32:21.504] run() for ‘Future’ ...
[09:32:21.504] - state: ‘created’
[09:32:21.505] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.510] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.510]   - Field: ‘label’
[09:32:21.510]   - Field: ‘local’
[09:32:21.510]   - Field: ‘owner’
[09:32:21.510]   - Field: ‘envir’
[09:32:21.511]   - Field: ‘workers’
[09:32:21.511]   - Field: ‘packages’
[09:32:21.511]   - Field: ‘gc’
[09:32:21.511]   - Field: ‘job’
[09:32:21.511]   - Field: ‘conditions’
[09:32:21.511]   - Field: ‘expr’
[09:32:21.511]   - Field: ‘uuid’
[09:32:21.512]   - Field: ‘seed’
[09:32:21.512]   - Field: ‘version’
[09:32:21.512]   - Field: ‘result’
[09:32:21.512]   - Field: ‘asynchronous’
[09:32:21.512]   - Field: ‘calls’
[09:32:21.512]   - Field: ‘globals’
[09:32:21.512]   - Field: ‘stdout’
[09:32:21.513]   - Field: ‘earlySignal’
[09:32:21.513]   - Field: ‘lazy’
[09:32:21.513]   - Field: ‘state’
[09:32:21.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.513] - Launch lazy future ...
[09:32:21.514] Packages needed by the future expression (n = 0): <none>
[09:32:21.514] Packages needed by future strategies (n = 0): <none>
[09:32:21.515] {
[09:32:21.515]     {
[09:32:21.515]         {
[09:32:21.515]             ...future.startTime <- base::Sys.time()
[09:32:21.515]             {
[09:32:21.515]                 {
[09:32:21.515]                   {
[09:32:21.515]                     {
[09:32:21.515]                       base::local({
[09:32:21.515]                         has_future <- base::requireNamespace("future", 
[09:32:21.515]                           quietly = TRUE)
[09:32:21.515]                         if (has_future) {
[09:32:21.515]                           ns <- base::getNamespace("future")
[09:32:21.515]                           version <- ns[[".package"]][["version"]]
[09:32:21.515]                           if (is.null(version)) 
[09:32:21.515]                             version <- utils::packageVersion("future")
[09:32:21.515]                         }
[09:32:21.515]                         else {
[09:32:21.515]                           version <- NULL
[09:32:21.515]                         }
[09:32:21.515]                         if (!has_future || version < "1.8.0") {
[09:32:21.515]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.515]                             "", base::R.version$version.string), 
[09:32:21.515]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.515]                               "release", "version")], collapse = " "), 
[09:32:21.515]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.515]                             info)
[09:32:21.515]                           info <- base::paste(info, collapse = "; ")
[09:32:21.515]                           if (!has_future) {
[09:32:21.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.515]                               info)
[09:32:21.515]                           }
[09:32:21.515]                           else {
[09:32:21.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.515]                               info, version)
[09:32:21.515]                           }
[09:32:21.515]                           base::stop(msg)
[09:32:21.515]                         }
[09:32:21.515]                       })
[09:32:21.515]                     }
[09:32:21.515]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.515]                     base::options(mc.cores = 1L)
[09:32:21.515]                   }
[09:32:21.515]                   ...future.strategy.old <- future::plan("list")
[09:32:21.515]                   options(future.plan = NULL)
[09:32:21.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.515]                 }
[09:32:21.515]                 ...future.workdir <- getwd()
[09:32:21.515]             }
[09:32:21.515]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.515]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.515]         }
[09:32:21.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.515]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.515]             base::names(...future.oldOptions))
[09:32:21.515]     }
[09:32:21.515]     if (FALSE) {
[09:32:21.515]     }
[09:32:21.515]     else {
[09:32:21.515]         if (TRUE) {
[09:32:21.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.515]                 open = "w")
[09:32:21.515]         }
[09:32:21.515]         else {
[09:32:21.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.515]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.515]         }
[09:32:21.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.515]             base::sink(type = "output", split = FALSE)
[09:32:21.515]             base::close(...future.stdout)
[09:32:21.515]         }, add = TRUE)
[09:32:21.515]     }
[09:32:21.515]     ...future.frame <- base::sys.nframe()
[09:32:21.515]     ...future.conditions <- base::list()
[09:32:21.515]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.515]     if (FALSE) {
[09:32:21.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.515]     }
[09:32:21.515]     ...future.result <- base::tryCatch({
[09:32:21.515]         base::withCallingHandlers({
[09:32:21.515]             ...future.value <- base::withVisible(base::local({
[09:32:21.515]                 withCallingHandlers({
[09:32:21.515]                   {
[09:32:21.515]                     1
[09:32:21.515]                   }
[09:32:21.515]                 }, immediateCondition = function(cond) {
[09:32:21.515]                   save_rds <- function (object, pathname, ...) 
[09:32:21.515]                   {
[09:32:21.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.515]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.515]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.515]                         fi_tmp[["mtime"]])
[09:32:21.515]                     }
[09:32:21.515]                     tryCatch({
[09:32:21.515]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.515]                     }, error = function(ex) {
[09:32:21.515]                       msg <- conditionMessage(ex)
[09:32:21.515]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.515]                         fi_tmp[["mtime"]], msg)
[09:32:21.515]                       ex$message <- msg
[09:32:21.515]                       stop(ex)
[09:32:21.515]                     })
[09:32:21.515]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.515]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.515]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.515]                       fi <- file.info(pathname)
[09:32:21.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.515]                         fi[["size"]], fi[["mtime"]])
[09:32:21.515]                       stop(msg)
[09:32:21.515]                     }
[09:32:21.515]                     invisible(pathname)
[09:32:21.515]                   }
[09:32:21.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.515]                     rootPath = tempdir()) 
[09:32:21.515]                   {
[09:32:21.515]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.515]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.515]                       tmpdir = path, fileext = ".rds")
[09:32:21.515]                     save_rds(obj, file)
[09:32:21.515]                   }
[09:32:21.515]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.515]                   {
[09:32:21.515]                     inherits <- base::inherits
[09:32:21.515]                     invokeRestart <- base::invokeRestart
[09:32:21.515]                     is.null <- base::is.null
[09:32:21.515]                     muffled <- FALSE
[09:32:21.515]                     if (inherits(cond, "message")) {
[09:32:21.515]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.515]                       if (muffled) 
[09:32:21.515]                         invokeRestart("muffleMessage")
[09:32:21.515]                     }
[09:32:21.515]                     else if (inherits(cond, "warning")) {
[09:32:21.515]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.515]                       if (muffled) 
[09:32:21.515]                         invokeRestart("muffleWarning")
[09:32:21.515]                     }
[09:32:21.515]                     else if (inherits(cond, "condition")) {
[09:32:21.515]                       if (!is.null(pattern)) {
[09:32:21.515]                         computeRestarts <- base::computeRestarts
[09:32:21.515]                         grepl <- base::grepl
[09:32:21.515]                         restarts <- computeRestarts(cond)
[09:32:21.515]                         for (restart in restarts) {
[09:32:21.515]                           name <- restart$name
[09:32:21.515]                           if (is.null(name)) 
[09:32:21.515]                             next
[09:32:21.515]                           if (!grepl(pattern, name)) 
[09:32:21.515]                             next
[09:32:21.515]                           invokeRestart(restart)
[09:32:21.515]                           muffled <- TRUE
[09:32:21.515]                           break
[09:32:21.515]                         }
[09:32:21.515]                       }
[09:32:21.515]                     }
[09:32:21.515]                     invisible(muffled)
[09:32:21.515]                   }
[09:32:21.515]                   muffleCondition(cond)
[09:32:21.515]                 })
[09:32:21.515]             }))
[09:32:21.515]             future::FutureResult(value = ...future.value$value, 
[09:32:21.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.515]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.515]                     ...future.globalenv.names))
[09:32:21.515]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.515]         }, condition = base::local({
[09:32:21.515]             c <- base::c
[09:32:21.515]             inherits <- base::inherits
[09:32:21.515]             invokeRestart <- base::invokeRestart
[09:32:21.515]             length <- base::length
[09:32:21.515]             list <- base::list
[09:32:21.515]             seq.int <- base::seq.int
[09:32:21.515]             signalCondition <- base::signalCondition
[09:32:21.515]             sys.calls <- base::sys.calls
[09:32:21.515]             `[[` <- base::`[[`
[09:32:21.515]             `+` <- base::`+`
[09:32:21.515]             `<<-` <- base::`<<-`
[09:32:21.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.515]                   3L)]
[09:32:21.515]             }
[09:32:21.515]             function(cond) {
[09:32:21.515]                 is_error <- inherits(cond, "error")
[09:32:21.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.515]                   NULL)
[09:32:21.515]                 if (is_error) {
[09:32:21.515]                   sessionInformation <- function() {
[09:32:21.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.515]                       search = base::search(), system = base::Sys.info())
[09:32:21.515]                   }
[09:32:21.515]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.515]                     cond$call), session = sessionInformation(), 
[09:32:21.515]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.515]                   signalCondition(cond)
[09:32:21.515]                 }
[09:32:21.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.515]                 "immediateCondition"))) {
[09:32:21.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.515]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.515]                   if (TRUE && !signal) {
[09:32:21.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.515]                     {
[09:32:21.515]                       inherits <- base::inherits
[09:32:21.515]                       invokeRestart <- base::invokeRestart
[09:32:21.515]                       is.null <- base::is.null
[09:32:21.515]                       muffled <- FALSE
[09:32:21.515]                       if (inherits(cond, "message")) {
[09:32:21.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.515]                         if (muffled) 
[09:32:21.515]                           invokeRestart("muffleMessage")
[09:32:21.515]                       }
[09:32:21.515]                       else if (inherits(cond, "warning")) {
[09:32:21.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.515]                         if (muffled) 
[09:32:21.515]                           invokeRestart("muffleWarning")
[09:32:21.515]                       }
[09:32:21.515]                       else if (inherits(cond, "condition")) {
[09:32:21.515]                         if (!is.null(pattern)) {
[09:32:21.515]                           computeRestarts <- base::computeRestarts
[09:32:21.515]                           grepl <- base::grepl
[09:32:21.515]                           restarts <- computeRestarts(cond)
[09:32:21.515]                           for (restart in restarts) {
[09:32:21.515]                             name <- restart$name
[09:32:21.515]                             if (is.null(name)) 
[09:32:21.515]                               next
[09:32:21.515]                             if (!grepl(pattern, name)) 
[09:32:21.515]                               next
[09:32:21.515]                             invokeRestart(restart)
[09:32:21.515]                             muffled <- TRUE
[09:32:21.515]                             break
[09:32:21.515]                           }
[09:32:21.515]                         }
[09:32:21.515]                       }
[09:32:21.515]                       invisible(muffled)
[09:32:21.515]                     }
[09:32:21.515]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.515]                   }
[09:32:21.515]                 }
[09:32:21.515]                 else {
[09:32:21.515]                   if (TRUE) {
[09:32:21.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.515]                     {
[09:32:21.515]                       inherits <- base::inherits
[09:32:21.515]                       invokeRestart <- base::invokeRestart
[09:32:21.515]                       is.null <- base::is.null
[09:32:21.515]                       muffled <- FALSE
[09:32:21.515]                       if (inherits(cond, "message")) {
[09:32:21.515]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.515]                         if (muffled) 
[09:32:21.515]                           invokeRestart("muffleMessage")
[09:32:21.515]                       }
[09:32:21.515]                       else if (inherits(cond, "warning")) {
[09:32:21.515]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.515]                         if (muffled) 
[09:32:21.515]                           invokeRestart("muffleWarning")
[09:32:21.515]                       }
[09:32:21.515]                       else if (inherits(cond, "condition")) {
[09:32:21.515]                         if (!is.null(pattern)) {
[09:32:21.515]                           computeRestarts <- base::computeRestarts
[09:32:21.515]                           grepl <- base::grepl
[09:32:21.515]                           restarts <- computeRestarts(cond)
[09:32:21.515]                           for (restart in restarts) {
[09:32:21.515]                             name <- restart$name
[09:32:21.515]                             if (is.null(name)) 
[09:32:21.515]                               next
[09:32:21.515]                             if (!grepl(pattern, name)) 
[09:32:21.515]                               next
[09:32:21.515]                             invokeRestart(restart)
[09:32:21.515]                             muffled <- TRUE
[09:32:21.515]                             break
[09:32:21.515]                           }
[09:32:21.515]                         }
[09:32:21.515]                       }
[09:32:21.515]                       invisible(muffled)
[09:32:21.515]                     }
[09:32:21.515]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.515]                   }
[09:32:21.515]                 }
[09:32:21.515]             }
[09:32:21.515]         }))
[09:32:21.515]     }, error = function(ex) {
[09:32:21.515]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.515]                 ...future.rng), started = ...future.startTime, 
[09:32:21.515]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.515]             version = "1.8"), class = "FutureResult")
[09:32:21.515]     }, finally = {
[09:32:21.515]         if (!identical(...future.workdir, getwd())) 
[09:32:21.515]             setwd(...future.workdir)
[09:32:21.515]         {
[09:32:21.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.515]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.515]             }
[09:32:21.515]             base::options(...future.oldOptions)
[09:32:21.515]             if (.Platform$OS.type == "windows") {
[09:32:21.515]                 old_names <- names(...future.oldEnvVars)
[09:32:21.515]                 envs <- base::Sys.getenv()
[09:32:21.515]                 names <- names(envs)
[09:32:21.515]                 common <- intersect(names, old_names)
[09:32:21.515]                 added <- setdiff(names, old_names)
[09:32:21.515]                 removed <- setdiff(old_names, names)
[09:32:21.515]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.515]                   envs[common]]
[09:32:21.515]                 NAMES <- toupper(changed)
[09:32:21.515]                 args <- list()
[09:32:21.515]                 for (kk in seq_along(NAMES)) {
[09:32:21.515]                   name <- changed[[kk]]
[09:32:21.515]                   NAME <- NAMES[[kk]]
[09:32:21.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.515]                     next
[09:32:21.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.515]                 }
[09:32:21.515]                 NAMES <- toupper(added)
[09:32:21.515]                 for (kk in seq_along(NAMES)) {
[09:32:21.515]                   name <- added[[kk]]
[09:32:21.515]                   NAME <- NAMES[[kk]]
[09:32:21.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.515]                     next
[09:32:21.515]                   args[[name]] <- ""
[09:32:21.515]                 }
[09:32:21.515]                 NAMES <- toupper(removed)
[09:32:21.515]                 for (kk in seq_along(NAMES)) {
[09:32:21.515]                   name <- removed[[kk]]
[09:32:21.515]                   NAME <- NAMES[[kk]]
[09:32:21.515]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.515]                     next
[09:32:21.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.515]                 }
[09:32:21.515]                 if (length(args) > 0) 
[09:32:21.515]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.515]             }
[09:32:21.515]             else {
[09:32:21.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.515]             }
[09:32:21.515]             {
[09:32:21.515]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.515]                   0L) {
[09:32:21.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.515]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.515]                   base::options(opts)
[09:32:21.515]                 }
[09:32:21.515]                 {
[09:32:21.515]                   {
[09:32:21.515]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.515]                     NULL
[09:32:21.515]                   }
[09:32:21.515]                   options(future.plan = NULL)
[09:32:21.515]                   if (is.na(NA_character_)) 
[09:32:21.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.515]                     .init = FALSE)
[09:32:21.515]                 }
[09:32:21.515]             }
[09:32:21.515]         }
[09:32:21.515]     })
[09:32:21.515]     if (TRUE) {
[09:32:21.515]         base::sink(type = "output", split = FALSE)
[09:32:21.515]         if (TRUE) {
[09:32:21.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.515]         }
[09:32:21.515]         else {
[09:32:21.515]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.515]         }
[09:32:21.515]         base::close(...future.stdout)
[09:32:21.515]         ...future.stdout <- NULL
[09:32:21.515]     }
[09:32:21.515]     ...future.result$conditions <- ...future.conditions
[09:32:21.515]     ...future.result$finished <- base::Sys.time()
[09:32:21.515]     ...future.result
[09:32:21.515] }
[09:32:21.518] requestCore(): workers = 2
[09:32:21.518] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.529] result() for MulticoreFuture ...
[09:32:21.530] result() for MulticoreFuture ...
[09:32:21.530] result() for MulticoreFuture ... done
[09:32:21.530] result() for MulticoreFuture ... done
[09:32:21.530] result() for MulticoreFuture ...
[09:32:21.531] result() for MulticoreFuture ... done
[09:32:21.533] MulticoreFuture started
[09:32:21.534] - Launch lazy future ... done
[09:32:21.534] run() for ‘MulticoreFuture’ ... done
[09:32:21.534] plan(): Setting new future strategy stack:
[09:32:21.535] getGlobalsAndPackages() ...
[09:32:21.535] Searching for globals...
[09:32:21.535] List of future strategies:
[09:32:21.535] 1. sequential:
[09:32:21.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.535]    - tweaked: FALSE
[09:32:21.535]    - call: NULL
[09:32:21.536] plan(): nbrOfWorkers() = 1
[09:32:21.537] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:21.538] Searching for globals ... DONE
[09:32:21.538] Resolving globals: FALSE
[09:32:21.538] plan(): Setting new future strategy stack:
[09:32:21.538] List of future strategies:
[09:32:21.538] 1. multicore:
[09:32:21.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.538]    - tweaked: FALSE
[09:32:21.538]    - call: plan(strategy)
[09:32:21.538] 
[09:32:21.539] 
[09:32:21.539] getGlobalsAndPackages() ... DONE
[09:32:21.539] run() for ‘Future’ ...
[09:32:21.539] - state: ‘created’
[09:32:21.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.543] plan(): nbrOfWorkers() = 2
[09:32:21.544] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.545]   - Field: ‘label’
[09:32:21.545]   - Field: ‘local’
[09:32:21.545]   - Field: ‘owner’
[09:32:21.545]   - Field: ‘envir’
[09:32:21.545]   - Field: ‘workers’
[09:32:21.546]   - Field: ‘packages’
[09:32:21.546]   - Field: ‘gc’
[09:32:21.546]   - Field: ‘job’
[09:32:21.546]   - Field: ‘conditions’
[09:32:21.546]   - Field: ‘expr’
[09:32:21.546]   - Field: ‘uuid’
[09:32:21.546]   - Field: ‘seed’
[09:32:21.547]   - Field: ‘version’
[09:32:21.547]   - Field: ‘result’
[09:32:21.547]   - Field: ‘asynchronous’
[09:32:21.547]   - Field: ‘calls’
[09:32:21.547]   - Field: ‘globals’
[09:32:21.547]   - Field: ‘stdout’
[09:32:21.551]   - Field: ‘earlySignal’
[09:32:21.552]   - Field: ‘lazy’
[09:32:21.552]   - Field: ‘state’
[09:32:21.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.553] - Launch lazy future ...
[09:32:21.553] Packages needed by the future expression (n = 0): <none>
[09:32:21.554] Packages needed by future strategies (n = 0): <none>
[09:32:21.555] {
[09:32:21.555]     {
[09:32:21.555]         {
[09:32:21.555]             ...future.startTime <- base::Sys.time()
[09:32:21.555]             {
[09:32:21.555]                 {
[09:32:21.555]                   {
[09:32:21.555]                     {
[09:32:21.555]                       base::local({
[09:32:21.555]                         has_future <- base::requireNamespace("future", 
[09:32:21.555]                           quietly = TRUE)
[09:32:21.555]                         if (has_future) {
[09:32:21.555]                           ns <- base::getNamespace("future")
[09:32:21.555]                           version <- ns[[".package"]][["version"]]
[09:32:21.555]                           if (is.null(version)) 
[09:32:21.555]                             version <- utils::packageVersion("future")
[09:32:21.555]                         }
[09:32:21.555]                         else {
[09:32:21.555]                           version <- NULL
[09:32:21.555]                         }
[09:32:21.555]                         if (!has_future || version < "1.8.0") {
[09:32:21.555]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.555]                             "", base::R.version$version.string), 
[09:32:21.555]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.555]                               "release", "version")], collapse = " "), 
[09:32:21.555]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.555]                             info)
[09:32:21.555]                           info <- base::paste(info, collapse = "; ")
[09:32:21.555]                           if (!has_future) {
[09:32:21.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.555]                               info)
[09:32:21.555]                           }
[09:32:21.555]                           else {
[09:32:21.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.555]                               info, version)
[09:32:21.555]                           }
[09:32:21.555]                           base::stop(msg)
[09:32:21.555]                         }
[09:32:21.555]                       })
[09:32:21.555]                     }
[09:32:21.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.555]                     base::options(mc.cores = 1L)
[09:32:21.555]                   }
[09:32:21.555]                   ...future.strategy.old <- future::plan("list")
[09:32:21.555]                   options(future.plan = NULL)
[09:32:21.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.555]                 }
[09:32:21.555]                 ...future.workdir <- getwd()
[09:32:21.555]             }
[09:32:21.555]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.555]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.555]         }
[09:32:21.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.555]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.555]             base::names(...future.oldOptions))
[09:32:21.555]     }
[09:32:21.555]     if (FALSE) {
[09:32:21.555]     }
[09:32:21.555]     else {
[09:32:21.555]         if (TRUE) {
[09:32:21.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.555]                 open = "w")
[09:32:21.555]         }
[09:32:21.555]         else {
[09:32:21.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.555]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.555]         }
[09:32:21.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.555]             base::sink(type = "output", split = FALSE)
[09:32:21.555]             base::close(...future.stdout)
[09:32:21.555]         }, add = TRUE)
[09:32:21.555]     }
[09:32:21.555]     ...future.frame <- base::sys.nframe()
[09:32:21.555]     ...future.conditions <- base::list()
[09:32:21.555]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.555]     if (FALSE) {
[09:32:21.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.555]     }
[09:32:21.555]     ...future.result <- base::tryCatch({
[09:32:21.555]         base::withCallingHandlers({
[09:32:21.555]             ...future.value <- base::withVisible(base::local({
[09:32:21.555]                 withCallingHandlers({
[09:32:21.555]                   {
[09:32:21.555]                     Sys.sleep(0.5)
[09:32:21.555]                     2
[09:32:21.555]                   }
[09:32:21.555]                 }, immediateCondition = function(cond) {
[09:32:21.555]                   save_rds <- function (object, pathname, ...) 
[09:32:21.555]                   {
[09:32:21.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.555]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.555]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.555]                         fi_tmp[["mtime"]])
[09:32:21.555]                     }
[09:32:21.555]                     tryCatch({
[09:32:21.555]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.555]                     }, error = function(ex) {
[09:32:21.555]                       msg <- conditionMessage(ex)
[09:32:21.555]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.555]                         fi_tmp[["mtime"]], msg)
[09:32:21.555]                       ex$message <- msg
[09:32:21.555]                       stop(ex)
[09:32:21.555]                     })
[09:32:21.555]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.555]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.555]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.555]                       fi <- file.info(pathname)
[09:32:21.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.555]                         fi[["size"]], fi[["mtime"]])
[09:32:21.555]                       stop(msg)
[09:32:21.555]                     }
[09:32:21.555]                     invisible(pathname)
[09:32:21.555]                   }
[09:32:21.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.555]                     rootPath = tempdir()) 
[09:32:21.555]                   {
[09:32:21.555]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.555]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.555]                       tmpdir = path, fileext = ".rds")
[09:32:21.555]                     save_rds(obj, file)
[09:32:21.555]                   }
[09:32:21.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.555]                   {
[09:32:21.555]                     inherits <- base::inherits
[09:32:21.555]                     invokeRestart <- base::invokeRestart
[09:32:21.555]                     is.null <- base::is.null
[09:32:21.555]                     muffled <- FALSE
[09:32:21.555]                     if (inherits(cond, "message")) {
[09:32:21.555]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.555]                       if (muffled) 
[09:32:21.555]                         invokeRestart("muffleMessage")
[09:32:21.555]                     }
[09:32:21.555]                     else if (inherits(cond, "warning")) {
[09:32:21.555]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.555]                       if (muffled) 
[09:32:21.555]                         invokeRestart("muffleWarning")
[09:32:21.555]                     }
[09:32:21.555]                     else if (inherits(cond, "condition")) {
[09:32:21.555]                       if (!is.null(pattern)) {
[09:32:21.555]                         computeRestarts <- base::computeRestarts
[09:32:21.555]                         grepl <- base::grepl
[09:32:21.555]                         restarts <- computeRestarts(cond)
[09:32:21.555]                         for (restart in restarts) {
[09:32:21.555]                           name <- restart$name
[09:32:21.555]                           if (is.null(name)) 
[09:32:21.555]                             next
[09:32:21.555]                           if (!grepl(pattern, name)) 
[09:32:21.555]                             next
[09:32:21.555]                           invokeRestart(restart)
[09:32:21.555]                           muffled <- TRUE
[09:32:21.555]                           break
[09:32:21.555]                         }
[09:32:21.555]                       }
[09:32:21.555]                     }
[09:32:21.555]                     invisible(muffled)
[09:32:21.555]                   }
[09:32:21.555]                   muffleCondition(cond)
[09:32:21.555]                 })
[09:32:21.555]             }))
[09:32:21.555]             future::FutureResult(value = ...future.value$value, 
[09:32:21.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.555]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.555]                     ...future.globalenv.names))
[09:32:21.555]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.555]         }, condition = base::local({
[09:32:21.555]             c <- base::c
[09:32:21.555]             inherits <- base::inherits
[09:32:21.555]             invokeRestart <- base::invokeRestart
[09:32:21.555]             length <- base::length
[09:32:21.555]             list <- base::list
[09:32:21.555]             seq.int <- base::seq.int
[09:32:21.555]             signalCondition <- base::signalCondition
[09:32:21.555]             sys.calls <- base::sys.calls
[09:32:21.555]             `[[` <- base::`[[`
[09:32:21.555]             `+` <- base::`+`
[09:32:21.555]             `<<-` <- base::`<<-`
[09:32:21.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.555]                   3L)]
[09:32:21.555]             }
[09:32:21.555]             function(cond) {
[09:32:21.555]                 is_error <- inherits(cond, "error")
[09:32:21.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.555]                   NULL)
[09:32:21.555]                 if (is_error) {
[09:32:21.555]                   sessionInformation <- function() {
[09:32:21.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.555]                       search = base::search(), system = base::Sys.info())
[09:32:21.555]                   }
[09:32:21.555]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.555]                     cond$call), session = sessionInformation(), 
[09:32:21.555]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.555]                   signalCondition(cond)
[09:32:21.555]                 }
[09:32:21.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.555]                 "immediateCondition"))) {
[09:32:21.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.555]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.555]                   if (TRUE && !signal) {
[09:32:21.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.555]                     {
[09:32:21.555]                       inherits <- base::inherits
[09:32:21.555]                       invokeRestart <- base::invokeRestart
[09:32:21.555]                       is.null <- base::is.null
[09:32:21.555]                       muffled <- FALSE
[09:32:21.555]                       if (inherits(cond, "message")) {
[09:32:21.555]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.555]                         if (muffled) 
[09:32:21.555]                           invokeRestart("muffleMessage")
[09:32:21.555]                       }
[09:32:21.555]                       else if (inherits(cond, "warning")) {
[09:32:21.555]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.555]                         if (muffled) 
[09:32:21.555]                           invokeRestart("muffleWarning")
[09:32:21.555]                       }
[09:32:21.555]                       else if (inherits(cond, "condition")) {
[09:32:21.555]                         if (!is.null(pattern)) {
[09:32:21.555]                           computeRestarts <- base::computeRestarts
[09:32:21.555]                           grepl <- base::grepl
[09:32:21.555]                           restarts <- computeRestarts(cond)
[09:32:21.555]                           for (restart in restarts) {
[09:32:21.555]                             name <- restart$name
[09:32:21.555]                             if (is.null(name)) 
[09:32:21.555]                               next
[09:32:21.555]                             if (!grepl(pattern, name)) 
[09:32:21.555]                               next
[09:32:21.555]                             invokeRestart(restart)
[09:32:21.555]                             muffled <- TRUE
[09:32:21.555]                             break
[09:32:21.555]                           }
[09:32:21.555]                         }
[09:32:21.555]                       }
[09:32:21.555]                       invisible(muffled)
[09:32:21.555]                     }
[09:32:21.555]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.555]                   }
[09:32:21.555]                 }
[09:32:21.555]                 else {
[09:32:21.555]                   if (TRUE) {
[09:32:21.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.555]                     {
[09:32:21.555]                       inherits <- base::inherits
[09:32:21.555]                       invokeRestart <- base::invokeRestart
[09:32:21.555]                       is.null <- base::is.null
[09:32:21.555]                       muffled <- FALSE
[09:32:21.555]                       if (inherits(cond, "message")) {
[09:32:21.555]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.555]                         if (muffled) 
[09:32:21.555]                           invokeRestart("muffleMessage")
[09:32:21.555]                       }
[09:32:21.555]                       else if (inherits(cond, "warning")) {
[09:32:21.555]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.555]                         if (muffled) 
[09:32:21.555]                           invokeRestart("muffleWarning")
[09:32:21.555]                       }
[09:32:21.555]                       else if (inherits(cond, "condition")) {
[09:32:21.555]                         if (!is.null(pattern)) {
[09:32:21.555]                           computeRestarts <- base::computeRestarts
[09:32:21.555]                           grepl <- base::grepl
[09:32:21.555]                           restarts <- computeRestarts(cond)
[09:32:21.555]                           for (restart in restarts) {
[09:32:21.555]                             name <- restart$name
[09:32:21.555]                             if (is.null(name)) 
[09:32:21.555]                               next
[09:32:21.555]                             if (!grepl(pattern, name)) 
[09:32:21.555]                               next
[09:32:21.555]                             invokeRestart(restart)
[09:32:21.555]                             muffled <- TRUE
[09:32:21.555]                             break
[09:32:21.555]                           }
[09:32:21.555]                         }
[09:32:21.555]                       }
[09:32:21.555]                       invisible(muffled)
[09:32:21.555]                     }
[09:32:21.555]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.555]                   }
[09:32:21.555]                 }
[09:32:21.555]             }
[09:32:21.555]         }))
[09:32:21.555]     }, error = function(ex) {
[09:32:21.555]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.555]                 ...future.rng), started = ...future.startTime, 
[09:32:21.555]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.555]             version = "1.8"), class = "FutureResult")
[09:32:21.555]     }, finally = {
[09:32:21.555]         if (!identical(...future.workdir, getwd())) 
[09:32:21.555]             setwd(...future.workdir)
[09:32:21.555]         {
[09:32:21.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.555]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.555]             }
[09:32:21.555]             base::options(...future.oldOptions)
[09:32:21.555]             if (.Platform$OS.type == "windows") {
[09:32:21.555]                 old_names <- names(...future.oldEnvVars)
[09:32:21.555]                 envs <- base::Sys.getenv()
[09:32:21.555]                 names <- names(envs)
[09:32:21.555]                 common <- intersect(names, old_names)
[09:32:21.555]                 added <- setdiff(names, old_names)
[09:32:21.555]                 removed <- setdiff(old_names, names)
[09:32:21.555]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.555]                   envs[common]]
[09:32:21.555]                 NAMES <- toupper(changed)
[09:32:21.555]                 args <- list()
[09:32:21.555]                 for (kk in seq_along(NAMES)) {
[09:32:21.555]                   name <- changed[[kk]]
[09:32:21.555]                   NAME <- NAMES[[kk]]
[09:32:21.555]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.555]                     next
[09:32:21.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.555]                 }
[09:32:21.555]                 NAMES <- toupper(added)
[09:32:21.555]                 for (kk in seq_along(NAMES)) {
[09:32:21.555]                   name <- added[[kk]]
[09:32:21.555]                   NAME <- NAMES[[kk]]
[09:32:21.555]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.555]                     next
[09:32:21.555]                   args[[name]] <- ""
[09:32:21.555]                 }
[09:32:21.555]                 NAMES <- toupper(removed)
[09:32:21.555]                 for (kk in seq_along(NAMES)) {
[09:32:21.555]                   name <- removed[[kk]]
[09:32:21.555]                   NAME <- NAMES[[kk]]
[09:32:21.555]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.555]                     next
[09:32:21.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.555]                 }
[09:32:21.555]                 if (length(args) > 0) 
[09:32:21.555]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.555]             }
[09:32:21.555]             else {
[09:32:21.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.555]             }
[09:32:21.555]             {
[09:32:21.555]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.555]                   0L) {
[09:32:21.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.555]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.555]                   base::options(opts)
[09:32:21.555]                 }
[09:32:21.555]                 {
[09:32:21.555]                   {
[09:32:21.555]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.555]                     NULL
[09:32:21.555]                   }
[09:32:21.555]                   options(future.plan = NULL)
[09:32:21.555]                   if (is.na(NA_character_)) 
[09:32:21.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.555]                     .init = FALSE)
[09:32:21.555]                 }
[09:32:21.555]             }
[09:32:21.555]         }
[09:32:21.555]     })
[09:32:21.555]     if (TRUE) {
[09:32:21.555]         base::sink(type = "output", split = FALSE)
[09:32:21.555]         if (TRUE) {
[09:32:21.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.555]         }
[09:32:21.555]         else {
[09:32:21.555]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.555]         }
[09:32:21.555]         base::close(...future.stdout)
[09:32:21.555]         ...future.stdout <- NULL
[09:32:21.555]     }
[09:32:21.555]     ...future.result$conditions <- ...future.conditions
[09:32:21.555]     ...future.result$finished <- base::Sys.time()
[09:32:21.555]     ...future.result
[09:32:21.555] }
[09:32:21.558] requestCore(): workers = 2
[09:32:21.559] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.569] result() for MulticoreFuture ...
[09:32:21.570] result() for MulticoreFuture ...
[09:32:21.570] result() for MulticoreFuture ... done
[09:32:21.571] result() for MulticoreFuture ... done
[09:32:21.571] result() for MulticoreFuture ...
[09:32:21.571] result() for MulticoreFuture ... done
[09:32:21.574] MulticoreFuture started
[09:32:21.574] - Launch lazy future ... done
[09:32:21.574] run() for ‘MulticoreFuture’ ... done
[09:32:21.575] plan(): Setting new future strategy stack:
[09:32:21.576] getGlobalsAndPackages() ...
[09:32:21.576] Searching for globals...
[09:32:21.575] List of future strategies:
[09:32:21.575] 1. sequential:
[09:32:21.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.575]    - tweaked: FALSE
[09:32:21.575]    - call: NULL
[09:32:21.576] plan(): nbrOfWorkers() = 1
[09:32:21.577] - globals found: [1] ‘{’
[09:32:21.578] Searching for globals ... DONE
[09:32:21.578] Resolving globals: FALSE
[09:32:21.579] 
[09:32:21.579] 
[09:32:21.579] getGlobalsAndPackages() ... DONE
[09:32:21.579] run() for ‘Future’ ...
[09:32:21.580] - state: ‘created’
[09:32:21.580] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[09:32:21.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:21.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[09:32:21.586]   - Field: ‘label’
[09:32:21.586]   - Field: ‘local’
[09:32:21.586]   - Field: ‘owner’
[09:32:21.586]   - Field: ‘envir’
[09:32:21.586]   - Field: ‘workers’
[09:32:21.586]   - Field: ‘packages’
[09:32:21.586]   - Field: ‘gc’
[09:32:21.587]   - Field: ‘job’
[09:32:21.587]   - Field: ‘conditions’
[09:32:21.587]   - Field: ‘expr’
[09:32:21.587]   - Field: ‘uuid’
[09:32:21.587]   - Field: ‘seed’
[09:32:21.587]   - Field: ‘version’
[09:32:21.587]   - Field: ‘result’
[09:32:21.588]   - Field: ‘asynchronous’
[09:32:21.588]   - Field: ‘calls’
[09:32:21.588]   - Field: ‘globals’
[09:32:21.588]   - Field: ‘stdout’
[09:32:21.588]   - Field: ‘earlySignal’
[09:32:21.588]   - Field: ‘lazy’
[09:32:21.588]   - Field: ‘state’
[09:32:21.589] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[09:32:21.589] - Launch lazy future ...
[09:32:21.589] Packages needed by the future expression (n = 0): <none>
[09:32:21.589] Packages needed by future strategies (n = 0): <none>
[09:32:21.590] {
[09:32:21.590]     {
[09:32:21.590]         {
[09:32:21.590]             ...future.startTime <- base::Sys.time()
[09:32:21.590]             {
[09:32:21.590]                 {
[09:32:21.590]                   {
[09:32:21.590]                     {
[09:32:21.590]                       base::local({
[09:32:21.590]                         has_future <- base::requireNamespace("future", 
[09:32:21.590]                           quietly = TRUE)
[09:32:21.590]                         if (has_future) {
[09:32:21.590]                           ns <- base::getNamespace("future")
[09:32:21.590]                           version <- ns[[".package"]][["version"]]
[09:32:21.590]                           if (is.null(version)) 
[09:32:21.590]                             version <- utils::packageVersion("future")
[09:32:21.590]                         }
[09:32:21.590]                         else {
[09:32:21.590]                           version <- NULL
[09:32:21.590]                         }
[09:32:21.590]                         if (!has_future || version < "1.8.0") {
[09:32:21.590]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:21.590]                             "", base::R.version$version.string), 
[09:32:21.590]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:21.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:21.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:21.590]                               "release", "version")], collapse = " "), 
[09:32:21.590]                             hostname = base::Sys.info()[["nodename"]])
[09:32:21.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:21.590]                             info)
[09:32:21.590]                           info <- base::paste(info, collapse = "; ")
[09:32:21.590]                           if (!has_future) {
[09:32:21.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:21.590]                               info)
[09:32:21.590]                           }
[09:32:21.590]                           else {
[09:32:21.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:21.590]                               info, version)
[09:32:21.590]                           }
[09:32:21.590]                           base::stop(msg)
[09:32:21.590]                         }
[09:32:21.590]                       })
[09:32:21.590]                     }
[09:32:21.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:21.590]                     base::options(mc.cores = 1L)
[09:32:21.590]                   }
[09:32:21.590]                   ...future.strategy.old <- future::plan("list")
[09:32:21.590]                   options(future.plan = NULL)
[09:32:21.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:21.590]                 }
[09:32:21.590]                 ...future.workdir <- getwd()
[09:32:21.590]             }
[09:32:21.590]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:21.590]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:21.590]         }
[09:32:21.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:21.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:21.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:21.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:21.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:21.590]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:21.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:21.590]             base::names(...future.oldOptions))
[09:32:21.590]     }
[09:32:21.590]     if (FALSE) {
[09:32:21.590]     }
[09:32:21.590]     else {
[09:32:21.590]         if (TRUE) {
[09:32:21.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:21.590]                 open = "w")
[09:32:21.590]         }
[09:32:21.590]         else {
[09:32:21.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:21.590]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:21.590]         }
[09:32:21.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:21.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:21.590]             base::sink(type = "output", split = FALSE)
[09:32:21.590]             base::close(...future.stdout)
[09:32:21.590]         }, add = TRUE)
[09:32:21.590]     }
[09:32:21.590]     ...future.frame <- base::sys.nframe()
[09:32:21.590]     ...future.conditions <- base::list()
[09:32:21.590]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:21.590]     if (FALSE) {
[09:32:21.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:21.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:21.590]     }
[09:32:21.590]     ...future.result <- base::tryCatch({
[09:32:21.590]         base::withCallingHandlers({
[09:32:21.590]             ...future.value <- base::withVisible(base::local({
[09:32:21.590]                 withCallingHandlers({
[09:32:21.590]                   {
[09:32:21.590]                     3
[09:32:21.590]                   }
[09:32:21.590]                 }, immediateCondition = function(cond) {
[09:32:21.590]                   save_rds <- function (object, pathname, ...) 
[09:32:21.590]                   {
[09:32:21.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[09:32:21.590]                     if (file_test("-f", pathname_tmp)) {
[09:32:21.590]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[09:32:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.590]                         fi_tmp[["mtime"]])
[09:32:21.590]                     }
[09:32:21.590]                     tryCatch({
[09:32:21.590]                       saveRDS(object, file = pathname_tmp, ...)
[09:32:21.590]                     }, error = function(ex) {
[09:32:21.590]                       msg <- conditionMessage(ex)
[09:32:21.590]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[09:32:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.590]                         fi_tmp[["mtime"]], msg)
[09:32:21.590]                       ex$message <- msg
[09:32:21.590]                       stop(ex)
[09:32:21.590]                     })
[09:32:21.590]                     stopifnot(file_test("-f", pathname_tmp))
[09:32:21.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[09:32:21.590]                     if (!res || file_test("-f", pathname_tmp)) {
[09:32:21.590]                       fi_tmp <- file.info(pathname_tmp)
[09:32:21.590]                       fi <- file.info(pathname)
[09:32:21.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[09:32:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[09:32:21.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[09:32:21.590]                         fi[["size"]], fi[["mtime"]])
[09:32:21.590]                       stop(msg)
[09:32:21.590]                     }
[09:32:21.590]                     invisible(pathname)
[09:32:21.590]                   }
[09:32:21.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[09:32:21.590]                     rootPath = tempdir()) 
[09:32:21.590]                   {
[09:32:21.590]                     obj <- list(time = Sys.time(), condition = cond)
[09:32:21.590]                     file <- tempfile(pattern = class(cond)[1], 
[09:32:21.590]                       tmpdir = path, fileext = ".rds")
[09:32:21.590]                     save_rds(obj, file)
[09:32:21.590]                   }
[09:32:21.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpVxcHlm/.future/immediateConditions")
[09:32:21.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.590]                   {
[09:32:21.590]                     inherits <- base::inherits
[09:32:21.590]                     invokeRestart <- base::invokeRestart
[09:32:21.590]                     is.null <- base::is.null
[09:32:21.590]                     muffled <- FALSE
[09:32:21.590]                     if (inherits(cond, "message")) {
[09:32:21.590]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:21.590]                       if (muffled) 
[09:32:21.590]                         invokeRestart("muffleMessage")
[09:32:21.590]                     }
[09:32:21.590]                     else if (inherits(cond, "warning")) {
[09:32:21.590]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:21.590]                       if (muffled) 
[09:32:21.590]                         invokeRestart("muffleWarning")
[09:32:21.590]                     }
[09:32:21.590]                     else if (inherits(cond, "condition")) {
[09:32:21.590]                       if (!is.null(pattern)) {
[09:32:21.590]                         computeRestarts <- base::computeRestarts
[09:32:21.590]                         grepl <- base::grepl
[09:32:21.590]                         restarts <- computeRestarts(cond)
[09:32:21.590]                         for (restart in restarts) {
[09:32:21.590]                           name <- restart$name
[09:32:21.590]                           if (is.null(name)) 
[09:32:21.590]                             next
[09:32:21.590]                           if (!grepl(pattern, name)) 
[09:32:21.590]                             next
[09:32:21.590]                           invokeRestart(restart)
[09:32:21.590]                           muffled <- TRUE
[09:32:21.590]                           break
[09:32:21.590]                         }
[09:32:21.590]                       }
[09:32:21.590]                     }
[09:32:21.590]                     invisible(muffled)
[09:32:21.590]                   }
[09:32:21.590]                   muffleCondition(cond)
[09:32:21.590]                 })
[09:32:21.590]             }))
[09:32:21.590]             future::FutureResult(value = ...future.value$value, 
[09:32:21.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.590]                   ...future.rng), globalenv = if (FALSE) 
[09:32:21.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:21.590]                     ...future.globalenv.names))
[09:32:21.590]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:21.590]         }, condition = base::local({
[09:32:21.590]             c <- base::c
[09:32:21.590]             inherits <- base::inherits
[09:32:21.590]             invokeRestart <- base::invokeRestart
[09:32:21.590]             length <- base::length
[09:32:21.590]             list <- base::list
[09:32:21.590]             seq.int <- base::seq.int
[09:32:21.590]             signalCondition <- base::signalCondition
[09:32:21.590]             sys.calls <- base::sys.calls
[09:32:21.590]             `[[` <- base::`[[`
[09:32:21.590]             `+` <- base::`+`
[09:32:21.590]             `<<-` <- base::`<<-`
[09:32:21.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:21.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:21.590]                   3L)]
[09:32:21.590]             }
[09:32:21.590]             function(cond) {
[09:32:21.590]                 is_error <- inherits(cond, "error")
[09:32:21.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:21.590]                   NULL)
[09:32:21.590]                 if (is_error) {
[09:32:21.590]                   sessionInformation <- function() {
[09:32:21.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:21.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:21.590]                       search = base::search(), system = base::Sys.info())
[09:32:21.590]                   }
[09:32:21.590]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:21.590]                     cond$call), session = sessionInformation(), 
[09:32:21.590]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:21.590]                   signalCondition(cond)
[09:32:21.590]                 }
[09:32:21.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:21.590]                 "immediateCondition"))) {
[09:32:21.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:21.590]                   ...future.conditions[[length(...future.conditions) + 
[09:32:21.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:21.590]                   if (TRUE && !signal) {
[09:32:21.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.590]                     {
[09:32:21.590]                       inherits <- base::inherits
[09:32:21.590]                       invokeRestart <- base::invokeRestart
[09:32:21.590]                       is.null <- base::is.null
[09:32:21.590]                       muffled <- FALSE
[09:32:21.590]                       if (inherits(cond, "message")) {
[09:32:21.590]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.590]                         if (muffled) 
[09:32:21.590]                           invokeRestart("muffleMessage")
[09:32:21.590]                       }
[09:32:21.590]                       else if (inherits(cond, "warning")) {
[09:32:21.590]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.590]                         if (muffled) 
[09:32:21.590]                           invokeRestart("muffleWarning")
[09:32:21.590]                       }
[09:32:21.590]                       else if (inherits(cond, "condition")) {
[09:32:21.590]                         if (!is.null(pattern)) {
[09:32:21.590]                           computeRestarts <- base::computeRestarts
[09:32:21.590]                           grepl <- base::grepl
[09:32:21.590]                           restarts <- computeRestarts(cond)
[09:32:21.590]                           for (restart in restarts) {
[09:32:21.590]                             name <- restart$name
[09:32:21.590]                             if (is.null(name)) 
[09:32:21.590]                               next
[09:32:21.590]                             if (!grepl(pattern, name)) 
[09:32:21.590]                               next
[09:32:21.590]                             invokeRestart(restart)
[09:32:21.590]                             muffled <- TRUE
[09:32:21.590]                             break
[09:32:21.590]                           }
[09:32:21.590]                         }
[09:32:21.590]                       }
[09:32:21.590]                       invisible(muffled)
[09:32:21.590]                     }
[09:32:21.590]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.590]                   }
[09:32:21.590]                 }
[09:32:21.590]                 else {
[09:32:21.590]                   if (TRUE) {
[09:32:21.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:21.590]                     {
[09:32:21.590]                       inherits <- base::inherits
[09:32:21.590]                       invokeRestart <- base::invokeRestart
[09:32:21.590]                       is.null <- base::is.null
[09:32:21.590]                       muffled <- FALSE
[09:32:21.590]                       if (inherits(cond, "message")) {
[09:32:21.590]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:21.590]                         if (muffled) 
[09:32:21.590]                           invokeRestart("muffleMessage")
[09:32:21.590]                       }
[09:32:21.590]                       else if (inherits(cond, "warning")) {
[09:32:21.590]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:21.590]                         if (muffled) 
[09:32:21.590]                           invokeRestart("muffleWarning")
[09:32:21.590]                       }
[09:32:21.590]                       else if (inherits(cond, "condition")) {
[09:32:21.590]                         if (!is.null(pattern)) {
[09:32:21.590]                           computeRestarts <- base::computeRestarts
[09:32:21.590]                           grepl <- base::grepl
[09:32:21.590]                           restarts <- computeRestarts(cond)
[09:32:21.590]                           for (restart in restarts) {
[09:32:21.590]                             name <- restart$name
[09:32:21.590]                             if (is.null(name)) 
[09:32:21.590]                               next
[09:32:21.590]                             if (!grepl(pattern, name)) 
[09:32:21.590]                               next
[09:32:21.590]                             invokeRestart(restart)
[09:32:21.590]                             muffled <- TRUE
[09:32:21.590]                             break
[09:32:21.590]                           }
[09:32:21.590]                         }
[09:32:21.590]                       }
[09:32:21.590]                       invisible(muffled)
[09:32:21.590]                     }
[09:32:21.590]                     muffleCondition(cond, pattern = "^muffle")
[09:32:21.590]                   }
[09:32:21.590]                 }
[09:32:21.590]             }
[09:32:21.590]         }))
[09:32:21.590]     }, error = function(ex) {
[09:32:21.590]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:21.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:21.590]                 ...future.rng), started = ...future.startTime, 
[09:32:21.590]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:21.590]             version = "1.8"), class = "FutureResult")
[09:32:21.590]     }, finally = {
[09:32:21.590]         if (!identical(...future.workdir, getwd())) 
[09:32:21.590]             setwd(...future.workdir)
[09:32:21.590]         {
[09:32:21.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:21.590]                 ...future.oldOptions$nwarnings <- NULL
[09:32:21.590]             }
[09:32:21.590]             base::options(...future.oldOptions)
[09:32:21.590]             if (.Platform$OS.type == "windows") {
[09:32:21.590]                 old_names <- names(...future.oldEnvVars)
[09:32:21.590]                 envs <- base::Sys.getenv()
[09:32:21.590]                 names <- names(envs)
[09:32:21.590]                 common <- intersect(names, old_names)
[09:32:21.590]                 added <- setdiff(names, old_names)
[09:32:21.590]                 removed <- setdiff(old_names, names)
[09:32:21.590]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:21.590]                   envs[common]]
[09:32:21.590]                 NAMES <- toupper(changed)
[09:32:21.590]                 args <- list()
[09:32:21.590]                 for (kk in seq_along(NAMES)) {
[09:32:21.590]                   name <- changed[[kk]]
[09:32:21.590]                   NAME <- NAMES[[kk]]
[09:32:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.590]                     next
[09:32:21.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.590]                 }
[09:32:21.590]                 NAMES <- toupper(added)
[09:32:21.590]                 for (kk in seq_along(NAMES)) {
[09:32:21.590]                   name <- added[[kk]]
[09:32:21.590]                   NAME <- NAMES[[kk]]
[09:32:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.590]                     next
[09:32:21.590]                   args[[name]] <- ""
[09:32:21.590]                 }
[09:32:21.590]                 NAMES <- toupper(removed)
[09:32:21.590]                 for (kk in seq_along(NAMES)) {
[09:32:21.590]                   name <- removed[[kk]]
[09:32:21.590]                   NAME <- NAMES[[kk]]
[09:32:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:21.590]                     next
[09:32:21.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:21.590]                 }
[09:32:21.590]                 if (length(args) > 0) 
[09:32:21.590]                   base::do.call(base::Sys.setenv, args = args)
[09:32:21.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:21.590]             }
[09:32:21.590]             else {
[09:32:21.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:21.590]             }
[09:32:21.590]             {
[09:32:21.590]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:21.590]                   0L) {
[09:32:21.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:21.590]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:21.590]                   base::options(opts)
[09:32:21.590]                 }
[09:32:21.590]                 {
[09:32:21.590]                   {
[09:32:21.590]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:21.590]                     NULL
[09:32:21.590]                   }
[09:32:21.590]                   options(future.plan = NULL)
[09:32:21.590]                   if (is.na(NA_character_)) 
[09:32:21.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:21.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:21.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:21.590]                     .init = FALSE)
[09:32:21.590]                 }
[09:32:21.590]             }
[09:32:21.590]         }
[09:32:21.590]     })
[09:32:21.590]     if (TRUE) {
[09:32:21.590]         base::sink(type = "output", split = FALSE)
[09:32:21.590]         if (TRUE) {
[09:32:21.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:21.590]         }
[09:32:21.590]         else {
[09:32:21.590]             ...future.result["stdout"] <- base::list(NULL)
[09:32:21.590]         }
[09:32:21.590]         base::close(...future.stdout)
[09:32:21.590]         ...future.stdout <- NULL
[09:32:21.590]     }
[09:32:21.590]     ...future.result$conditions <- ...future.conditions
[09:32:21.590]     ...future.result$finished <- base::Sys.time()
[09:32:21.590]     ...future.result
[09:32:21.590] }
[09:32:21.593] requestCore(): workers = 2
[09:32:21.594] Poll #1 (0): usedCores() = 2, workers = 2
[09:32:21.604] result() for MulticoreFuture ...
[09:32:21.605] result() for MulticoreFuture ...
[09:32:21.605] result() for MulticoreFuture ... done
[09:32:21.605] result() for MulticoreFuture ... done
[09:32:21.606] result() for MulticoreFuture ...
[09:32:21.606] result() for MulticoreFuture ... done
[09:32:21.608] MulticoreFuture started
[09:32:21.608] - Launch lazy future ... done
[09:32:21.609] run() for ‘MulticoreFuture’ ... done
[09:32:21.609] plan(): Setting new future strategy stack:
[09:32:21.609] List of future strategies:
[09:32:21.609] 1. sequential:
[09:32:21.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:21.609]    - tweaked: FALSE
[09:32:21.609]    - call: NULL
[09:32:21.611] resolve() on list environment ...
[09:32:21.611] plan(): nbrOfWorkers() = 1
[09:32:21.611]  recursive: 0
[09:32:21.613]  length: 4
[09:32:21.613]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:21.613] Future #1
[09:32:21.613]  length: 3 (resolved future 1)
[09:32:21.614] plan(): Setting new future strategy stack:
[09:32:21.614] List of future strategies:
[09:32:21.614] 1. multicore:
[09:32:21.614]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:21.614]    - tweaked: FALSE
[09:32:21.614]    - call: plan(strategy)
[09:32:21.619] plan(): nbrOfWorkers() = 2
[09:32:21.624] Future #3
[09:32:21.625]  length: 2 (resolved future 3)
[09:32:21.625]  length: 1 (resolved future 4)
[09:32:22.079] plan(): Setting new future strategy stack:
[09:32:22.079] List of future strategies:
[09:32:22.079] 1. multicore:
[09:32:22.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[09:32:22.079]    - tweaked: FALSE
[09:32:22.079]    - call: plan(strategy)
[09:32:22.084] plan(): nbrOfWorkers() = 2
[09:32:22.084] Future #2
[09:32:22.085]  length: 0 (resolved future 2)
[09:32:22.085] resolve() on list environment ... DONE
[09:32:22.085] resolve() on list environment ...
[09:32:22.086]  recursive: 0
[09:32:22.087]  length: 4
[09:32:22.087]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:22.087] Future #1
[09:32:22.087]  length: 3 (resolved future 1)
[09:32:22.087] Future #2
[09:32:22.088]  length: 2 (resolved future 2)
[09:32:22.088] Future #3
[09:32:22.088]  length: 1 (resolved future 3)
[09:32:22.088]  length: 0 (resolved future 4)
[09:32:22.088] resolve() on list environment ... DONE
[09:32:22.089] resolve() on list environment ...
[09:32:22.089]  recursive: 0
[09:32:22.090]  length: 4
[09:32:22.090]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:22.091] Future #1
[09:32:22.091]  length: 3 (resolved future 1)
[09:32:22.091] Future #2
[09:32:22.091]  length: 2 (resolved future 2)
[09:32:22.092] Future #3
[09:32:22.092]  length: 1 (resolved future 3)
[09:32:22.092]  length: 0 (resolved future 4)
[09:32:22.092] resolve() on list environment ... DONE
[09:32:22.093] resolve() on list environment ...
[09:32:22.093]  recursive: 0
[09:32:22.094]  length: 4
[09:32:22.094]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:22.098] Future #1
[09:32:22.098]  length: 3 (resolved future 1)
[09:32:22.099] Future #2
[09:32:22.099]  length: 2 (resolved future 2)
[09:32:22.100] Future #3
[09:32:22.100]  length: 1 (resolved future 3)
[09:32:22.101]  length: 0 (resolved future 4)
[09:32:22.101] resolve() on list environment ... DONE
[09:32:22.102] resolve() on list environment ...
[09:32:22.102]  recursive: 0
[09:32:22.104]  length: 4
[09:32:22.104]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:22.104] Future #1
[09:32:22.104] result() for MulticoreFuture ...
[09:32:22.104] result() for MulticoreFuture ... done
[09:32:22.105] result() for MulticoreFuture ...
[09:32:22.105] result() for MulticoreFuture ... done
[09:32:22.105]  length: 3 (resolved future 1)
[09:32:22.105] Future #2
[09:32:22.105] result() for MulticoreFuture ...
[09:32:22.106] result() for MulticoreFuture ...
[09:32:22.106] result() for MulticoreFuture ... done
[09:32:22.107] result() for MulticoreFuture ... done
[09:32:22.107] result() for MulticoreFuture ...
[09:32:22.107] result() for MulticoreFuture ... done
[09:32:22.107]  length: 2 (resolved future 2)
[09:32:22.107] Future #3
[09:32:22.107] result() for MulticoreFuture ...
[09:32:22.108] result() for MulticoreFuture ...
[09:32:22.108] result() for MulticoreFuture ... done
[09:32:22.108] result() for MulticoreFuture ... done
[09:32:22.109] result() for MulticoreFuture ...
[09:32:22.109] result() for MulticoreFuture ... done
[09:32:22.109]  length: 1 (resolved future 3)
[09:32:22.109]  length: 0 (resolved future 4)
[09:32:22.109] resolve() on list environment ... DONE
[09:32:22.110] resolve() on list environment ...
[09:32:22.110]  recursive: 99
[09:32:22.111]  length: 4
[09:32:22.112]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:22.112] Future #1
[09:32:22.112] result() for MulticoreFuture ...
[09:32:22.112] result() for MulticoreFuture ... done
[09:32:22.112] result() for MulticoreFuture ...
[09:32:22.112] result() for MulticoreFuture ... done
[09:32:22.112] A MulticoreFuture was resolved
[09:32:22.112]  length: 3 (resolved future 1)
[09:32:22.113] Future #2
[09:32:22.113] result() for MulticoreFuture ...
[09:32:22.113] result() for MulticoreFuture ... done
[09:32:22.113] result() for MulticoreFuture ...
[09:32:22.113] result() for MulticoreFuture ... done
[09:32:22.113] A MulticoreFuture was resolved
[09:32:22.113]  length: 2 (resolved future 2)
[09:32:22.113] Future #3
[09:32:22.114] result() for MulticoreFuture ...
[09:32:22.114] result() for MulticoreFuture ... done
[09:32:22.114] result() for MulticoreFuture ...
[09:32:22.114] result() for MulticoreFuture ... done
[09:32:22.114] A MulticoreFuture was resolved
[09:32:22.114]  length: 1 (resolved future 3)
[09:32:22.114]  length: 0 (resolved future 4)
[09:32:22.114] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[09:32:22.115] plan(): Setting new future strategy stack:
[09:32:22.115] List of future strategies:
[09:32:22.115] 1. multisession:
[09:32:22.115]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:32:22.115]    - tweaked: FALSE
[09:32:22.115]    - call: plan(strategy)
[09:32:22.116] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[09:32:22.116] multisession:
[09:32:22.116] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[09:32:22.116] - tweaked: FALSE
[09:32:22.116] - call: plan(strategy)
[09:32:22.122] getGlobalsAndPackages() ...
[09:32:22.122] Not searching for globals
[09:32:22.122] - globals: [0] <none>
[09:32:22.122] getGlobalsAndPackages() ... DONE
[09:32:22.123] [local output] makeClusterPSOCK() ...
[09:32:22.164] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[09:32:22.165] [local output] Base port: 11420
[09:32:22.165] [local output] Getting setup options for 2 cluster nodes ...
[09:32:22.165] [local output]  - Node 1 of 2 ...
[09:32:22.166] [local output] localMachine=TRUE => revtunnel=FALSE

[09:32:22.166] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVxcHlm/worker.rank=1.parallelly.parent=48731.be5b18a19011.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpVxcHlm/worker.rank=1.parallelly.parent=48731.be5b18a19011.pid")'’
[09:32:22.351] - Possible to infer worker's PID: TRUE
[09:32:22.352] [local output] Rscript port: 11420

[09:32:22.352] [local output]  - Node 2 of 2 ...
[09:32:22.352] [local output] localMachine=TRUE => revtunnel=FALSE

[09:32:22.353] [local output] Rscript port: 11420

[09:32:22.353] [local output] Getting setup options for 2 cluster nodes ... done
[09:32:22.353] [local output]  - Parallel setup requested for some PSOCK nodes
[09:32:22.354] [local output] Setting up PSOCK nodes in parallel
[09:32:22.354] List of 36
[09:32:22.354]  $ worker          : chr "localhost"
[09:32:22.354]   ..- attr(*, "localhost")= logi TRUE
[09:32:22.354]  $ master          : chr "localhost"
[09:32:22.354]  $ port            : int 11420
[09:32:22.354]  $ connectTimeout  : num 120
[09:32:22.354]  $ timeout         : num 2592000
[09:32:22.354]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[09:32:22.354]  $ homogeneous     : logi TRUE
[09:32:22.354]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[09:32:22.354]  $ rscript_envs    : NULL
[09:32:22.354]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:32:22.354]  $ rscript_startup : NULL
[09:32:22.354]  $ rscript_sh      : chr "sh"
[09:32:22.354]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:32:22.354]  $ methods         : logi TRUE
[09:32:22.354]  $ socketOptions   : chr "no-delay"
[09:32:22.354]  $ useXDR          : logi FALSE
[09:32:22.354]  $ outfile         : chr "/dev/null"
[09:32:22.354]  $ renice          : int NA
[09:32:22.354]  $ rshcmd          : NULL
[09:32:22.354]  $ user            : chr(0) 
[09:32:22.354]  $ revtunnel       : logi FALSE
[09:32:22.354]  $ rshlogfile      : NULL
[09:32:22.354]  $ rshopts         : chr(0) 
[09:32:22.354]  $ rank            : int 1
[09:32:22.354]  $ manual          : logi FALSE
[09:32:22.354]  $ dryrun          : logi FALSE
[09:32:22.354]  $ quiet           : logi FALSE
[09:32:22.354]  $ setup_strategy  : chr "parallel"
[09:32:22.354]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:32:22.354]  $ pidfile         : chr "/tmp/RtmpVxcHlm/worker.rank=1.parallelly.parent=48731.be5b18a19011.pid"
[09:32:22.354]  $ rshcmd_label    : NULL
[09:32:22.354]  $ rsh_call        : NULL
[09:32:22.354]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[09:32:22.354]  $ localMachine    : logi TRUE
[09:32:22.354]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[09:32:22.354]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[09:32:22.354]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[09:32:22.354]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[09:32:22.354]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[09:32:22.354]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[09:32:22.354]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[09:32:22.354]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[09:32:22.354]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[09:32:22.354]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[09:32:22.354]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[09:32:22.354]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[09:32:22.354]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[09:32:22.354]  $ arguments       :List of 28
[09:32:22.354]   ..$ worker          : chr "localhost"
[09:32:22.354]   ..$ master          : NULL
[09:32:22.354]   ..$ port            : int 11420
[09:32:22.354]   ..$ connectTimeout  : num 120
[09:32:22.354]   ..$ timeout         : num 2592000
[09:32:22.354]   ..$ rscript         : NULL
[09:32:22.354]   ..$ homogeneous     : NULL
[09:32:22.354]   ..$ rscript_args    : NULL
[09:32:22.354]   ..$ rscript_envs    : NULL
[09:32:22.354]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[09:32:22.354]   ..$ rscript_startup : NULL
[09:32:22.354]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[09:32:22.354]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[09:32:22.354]   ..$ methods         : logi TRUE
[09:32:22.354]   ..$ socketOptions   : chr "no-delay"
[09:32:22.354]   ..$ useXDR          : logi FALSE
[09:32:22.354]   ..$ outfile         : chr "/dev/null"
[09:32:22.354]   ..$ renice          : int NA
[09:32:22.354]   ..$ rshcmd          : NULL
[09:32:22.354]   ..$ user            : NULL
[09:32:22.354]   ..$ revtunnel       : logi NA
[09:32:22.354]   ..$ rshlogfile      : NULL
[09:32:22.354]   ..$ rshopts         : NULL
[09:32:22.354]   ..$ rank            : int 1
[09:32:22.354]   ..$ manual          : logi FALSE
[09:32:22.354]   ..$ dryrun          : logi FALSE
[09:32:22.354]   ..$ quiet           : logi FALSE
[09:32:22.354]   ..$ setup_strategy  : chr "parallel"
[09:32:22.354]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[09:32:22.370] [local output] System call to launch all workers:
[09:32:22.371] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpVxcHlm/worker.rank=1.parallelly.parent=48731.be5b18a19011.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11420 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[09:32:22.371] [local output] Starting PSOCK main server
[09:32:22.377] [local output] Workers launched
[09:32:22.377] [local output] Waiting for workers to connect back
[09:32:22.377]  - [local output] 0 workers out of 2 ready
[09:32:22.632]  - [local output] 0 workers out of 2 ready
[09:32:22.633]  - [local output] 1 workers out of 2 ready
[09:32:22.633]  - [local output] 2 workers out of 2 ready
[09:32:22.633] [local output] Launching of workers completed
[09:32:22.633] [local output] Collecting session information from workers
[09:32:22.634] [local output]  - Worker #1 of 2
[09:32:22.635] [local output]  - Worker #2 of 2
[09:32:22.635] [local output] makeClusterPSOCK() ... done
[09:32:22.646] Packages needed by the future expression (n = 0): <none>
[09:32:22.646] Packages needed by future strategies (n = 0): <none>
[09:32:22.647] {
[09:32:22.647]     {
[09:32:22.647]         {
[09:32:22.647]             ...future.startTime <- base::Sys.time()
[09:32:22.647]             {
[09:32:22.647]                 {
[09:32:22.647]                   {
[09:32:22.647]                     {
[09:32:22.647]                       base::local({
[09:32:22.647]                         has_future <- base::requireNamespace("future", 
[09:32:22.647]                           quietly = TRUE)
[09:32:22.647]                         if (has_future) {
[09:32:22.647]                           ns <- base::getNamespace("future")
[09:32:22.647]                           version <- ns[[".package"]][["version"]]
[09:32:22.647]                           if (is.null(version)) 
[09:32:22.647]                             version <- utils::packageVersion("future")
[09:32:22.647]                         }
[09:32:22.647]                         else {
[09:32:22.647]                           version <- NULL
[09:32:22.647]                         }
[09:32:22.647]                         if (!has_future || version < "1.8.0") {
[09:32:22.647]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:22.647]                             "", base::R.version$version.string), 
[09:32:22.647]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:22.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:22.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:22.647]                               "release", "version")], collapse = " "), 
[09:32:22.647]                             hostname = base::Sys.info()[["nodename"]])
[09:32:22.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:22.647]                             info)
[09:32:22.647]                           info <- base::paste(info, collapse = "; ")
[09:32:22.647]                           if (!has_future) {
[09:32:22.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:22.647]                               info)
[09:32:22.647]                           }
[09:32:22.647]                           else {
[09:32:22.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:22.647]                               info, version)
[09:32:22.647]                           }
[09:32:22.647]                           base::stop(msg)
[09:32:22.647]                         }
[09:32:22.647]                       })
[09:32:22.647]                     }
[09:32:22.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:22.647]                     base::options(mc.cores = 1L)
[09:32:22.647]                   }
[09:32:22.647]                   ...future.strategy.old <- future::plan("list")
[09:32:22.647]                   options(future.plan = NULL)
[09:32:22.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:22.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:22.647]                 }
[09:32:22.647]                 ...future.workdir <- getwd()
[09:32:22.647]             }
[09:32:22.647]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:22.647]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:22.647]         }
[09:32:22.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:22.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:22.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:22.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:22.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:22.647]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:22.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:22.647]             base::names(...future.oldOptions))
[09:32:22.647]     }
[09:32:22.647]     if (FALSE) {
[09:32:22.647]     }
[09:32:22.647]     else {
[09:32:22.647]         if (TRUE) {
[09:32:22.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:22.647]                 open = "w")
[09:32:22.647]         }
[09:32:22.647]         else {
[09:32:22.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:22.647]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:22.647]         }
[09:32:22.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:22.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:22.647]             base::sink(type = "output", split = FALSE)
[09:32:22.647]             base::close(...future.stdout)
[09:32:22.647]         }, add = TRUE)
[09:32:22.647]     }
[09:32:22.647]     ...future.frame <- base::sys.nframe()
[09:32:22.647]     ...future.conditions <- base::list()
[09:32:22.647]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:22.647]     if (FALSE) {
[09:32:22.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:22.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:22.647]     }
[09:32:22.647]     ...future.result <- base::tryCatch({
[09:32:22.647]         base::withCallingHandlers({
[09:32:22.647]             ...future.value <- base::withVisible(base::local({
[09:32:22.647]                 ...future.makeSendCondition <- base::local({
[09:32:22.647]                   sendCondition <- NULL
[09:32:22.647]                   function(frame = 1L) {
[09:32:22.647]                     if (is.function(sendCondition)) 
[09:32:22.647]                       return(sendCondition)
[09:32:22.647]                     ns <- getNamespace("parallel")
[09:32:22.647]                     if (exists("sendData", mode = "function", 
[09:32:22.647]                       envir = ns)) {
[09:32:22.647]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:22.647]                         envir = ns)
[09:32:22.647]                       envir <- sys.frame(frame)
[09:32:22.647]                       master <- NULL
[09:32:22.647]                       while (!identical(envir, .GlobalEnv) && 
[09:32:22.647]                         !identical(envir, emptyenv())) {
[09:32:22.647]                         if (exists("master", mode = "list", envir = envir, 
[09:32:22.647]                           inherits = FALSE)) {
[09:32:22.647]                           master <- get("master", mode = "list", 
[09:32:22.647]                             envir = envir, inherits = FALSE)
[09:32:22.647]                           if (inherits(master, c("SOCKnode", 
[09:32:22.647]                             "SOCK0node"))) {
[09:32:22.647]                             sendCondition <<- function(cond) {
[09:32:22.647]                               data <- list(type = "VALUE", value = cond, 
[09:32:22.647]                                 success = TRUE)
[09:32:22.647]                               parallel_sendData(master, data)
[09:32:22.647]                             }
[09:32:22.647]                             return(sendCondition)
[09:32:22.647]                           }
[09:32:22.647]                         }
[09:32:22.647]                         frame <- frame + 1L
[09:32:22.647]                         envir <- sys.frame(frame)
[09:32:22.647]                       }
[09:32:22.647]                     }
[09:32:22.647]                     sendCondition <<- function(cond) NULL
[09:32:22.647]                   }
[09:32:22.647]                 })
[09:32:22.647]                 withCallingHandlers({
[09:32:22.647]                   NA
[09:32:22.647]                 }, immediateCondition = function(cond) {
[09:32:22.647]                   sendCondition <- ...future.makeSendCondition()
[09:32:22.647]                   sendCondition(cond)
[09:32:22.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.647]                   {
[09:32:22.647]                     inherits <- base::inherits
[09:32:22.647]                     invokeRestart <- base::invokeRestart
[09:32:22.647]                     is.null <- base::is.null
[09:32:22.647]                     muffled <- FALSE
[09:32:22.647]                     if (inherits(cond, "message")) {
[09:32:22.647]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:22.647]                       if (muffled) 
[09:32:22.647]                         invokeRestart("muffleMessage")
[09:32:22.647]                     }
[09:32:22.647]                     else if (inherits(cond, "warning")) {
[09:32:22.647]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:22.647]                       if (muffled) 
[09:32:22.647]                         invokeRestart("muffleWarning")
[09:32:22.647]                     }
[09:32:22.647]                     else if (inherits(cond, "condition")) {
[09:32:22.647]                       if (!is.null(pattern)) {
[09:32:22.647]                         computeRestarts <- base::computeRestarts
[09:32:22.647]                         grepl <- base::grepl
[09:32:22.647]                         restarts <- computeRestarts(cond)
[09:32:22.647]                         for (restart in restarts) {
[09:32:22.647]                           name <- restart$name
[09:32:22.647]                           if (is.null(name)) 
[09:32:22.647]                             next
[09:32:22.647]                           if (!grepl(pattern, name)) 
[09:32:22.647]                             next
[09:32:22.647]                           invokeRestart(restart)
[09:32:22.647]                           muffled <- TRUE
[09:32:22.647]                           break
[09:32:22.647]                         }
[09:32:22.647]                       }
[09:32:22.647]                     }
[09:32:22.647]                     invisible(muffled)
[09:32:22.647]                   }
[09:32:22.647]                   muffleCondition(cond)
[09:32:22.647]                 })
[09:32:22.647]             }))
[09:32:22.647]             future::FutureResult(value = ...future.value$value, 
[09:32:22.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:22.647]                   ...future.rng), globalenv = if (FALSE) 
[09:32:22.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:22.647]                     ...future.globalenv.names))
[09:32:22.647]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:22.647]         }, condition = base::local({
[09:32:22.647]             c <- base::c
[09:32:22.647]             inherits <- base::inherits
[09:32:22.647]             invokeRestart <- base::invokeRestart
[09:32:22.647]             length <- base::length
[09:32:22.647]             list <- base::list
[09:32:22.647]             seq.int <- base::seq.int
[09:32:22.647]             signalCondition <- base::signalCondition
[09:32:22.647]             sys.calls <- base::sys.calls
[09:32:22.647]             `[[` <- base::`[[`
[09:32:22.647]             `+` <- base::`+`
[09:32:22.647]             `<<-` <- base::`<<-`
[09:32:22.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:22.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:22.647]                   3L)]
[09:32:22.647]             }
[09:32:22.647]             function(cond) {
[09:32:22.647]                 is_error <- inherits(cond, "error")
[09:32:22.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:22.647]                   NULL)
[09:32:22.647]                 if (is_error) {
[09:32:22.647]                   sessionInformation <- function() {
[09:32:22.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:22.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:22.647]                       search = base::search(), system = base::Sys.info())
[09:32:22.647]                   }
[09:32:22.647]                   ...future.conditions[[length(...future.conditions) + 
[09:32:22.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:22.647]                     cond$call), session = sessionInformation(), 
[09:32:22.647]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:22.647]                   signalCondition(cond)
[09:32:22.647]                 }
[09:32:22.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:22.647]                 "immediateCondition"))) {
[09:32:22.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:22.647]                   ...future.conditions[[length(...future.conditions) + 
[09:32:22.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:22.647]                   if (TRUE && !signal) {
[09:32:22.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.647]                     {
[09:32:22.647]                       inherits <- base::inherits
[09:32:22.647]                       invokeRestart <- base::invokeRestart
[09:32:22.647]                       is.null <- base::is.null
[09:32:22.647]                       muffled <- FALSE
[09:32:22.647]                       if (inherits(cond, "message")) {
[09:32:22.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:22.647]                         if (muffled) 
[09:32:22.647]                           invokeRestart("muffleMessage")
[09:32:22.647]                       }
[09:32:22.647]                       else if (inherits(cond, "warning")) {
[09:32:22.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:22.647]                         if (muffled) 
[09:32:22.647]                           invokeRestart("muffleWarning")
[09:32:22.647]                       }
[09:32:22.647]                       else if (inherits(cond, "condition")) {
[09:32:22.647]                         if (!is.null(pattern)) {
[09:32:22.647]                           computeRestarts <- base::computeRestarts
[09:32:22.647]                           grepl <- base::grepl
[09:32:22.647]                           restarts <- computeRestarts(cond)
[09:32:22.647]                           for (restart in restarts) {
[09:32:22.647]                             name <- restart$name
[09:32:22.647]                             if (is.null(name)) 
[09:32:22.647]                               next
[09:32:22.647]                             if (!grepl(pattern, name)) 
[09:32:22.647]                               next
[09:32:22.647]                             invokeRestart(restart)
[09:32:22.647]                             muffled <- TRUE
[09:32:22.647]                             break
[09:32:22.647]                           }
[09:32:22.647]                         }
[09:32:22.647]                       }
[09:32:22.647]                       invisible(muffled)
[09:32:22.647]                     }
[09:32:22.647]                     muffleCondition(cond, pattern = "^muffle")
[09:32:22.647]                   }
[09:32:22.647]                 }
[09:32:22.647]                 else {
[09:32:22.647]                   if (TRUE) {
[09:32:22.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.647]                     {
[09:32:22.647]                       inherits <- base::inherits
[09:32:22.647]                       invokeRestart <- base::invokeRestart
[09:32:22.647]                       is.null <- base::is.null
[09:32:22.647]                       muffled <- FALSE
[09:32:22.647]                       if (inherits(cond, "message")) {
[09:32:22.647]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:22.647]                         if (muffled) 
[09:32:22.647]                           invokeRestart("muffleMessage")
[09:32:22.647]                       }
[09:32:22.647]                       else if (inherits(cond, "warning")) {
[09:32:22.647]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:22.647]                         if (muffled) 
[09:32:22.647]                           invokeRestart("muffleWarning")
[09:32:22.647]                       }
[09:32:22.647]                       else if (inherits(cond, "condition")) {
[09:32:22.647]                         if (!is.null(pattern)) {
[09:32:22.647]                           computeRestarts <- base::computeRestarts
[09:32:22.647]                           grepl <- base::grepl
[09:32:22.647]                           restarts <- computeRestarts(cond)
[09:32:22.647]                           for (restart in restarts) {
[09:32:22.647]                             name <- restart$name
[09:32:22.647]                             if (is.null(name)) 
[09:32:22.647]                               next
[09:32:22.647]                             if (!grepl(pattern, name)) 
[09:32:22.647]                               next
[09:32:22.647]                             invokeRestart(restart)
[09:32:22.647]                             muffled <- TRUE
[09:32:22.647]                             break
[09:32:22.647]                           }
[09:32:22.647]                         }
[09:32:22.647]                       }
[09:32:22.647]                       invisible(muffled)
[09:32:22.647]                     }
[09:32:22.647]                     muffleCondition(cond, pattern = "^muffle")
[09:32:22.647]                   }
[09:32:22.647]                 }
[09:32:22.647]             }
[09:32:22.647]         }))
[09:32:22.647]     }, error = function(ex) {
[09:32:22.647]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:22.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:22.647]                 ...future.rng), started = ...future.startTime, 
[09:32:22.647]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:22.647]             version = "1.8"), class = "FutureResult")
[09:32:22.647]     }, finally = {
[09:32:22.647]         if (!identical(...future.workdir, getwd())) 
[09:32:22.647]             setwd(...future.workdir)
[09:32:22.647]         {
[09:32:22.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:22.647]                 ...future.oldOptions$nwarnings <- NULL
[09:32:22.647]             }
[09:32:22.647]             base::options(...future.oldOptions)
[09:32:22.647]             if (.Platform$OS.type == "windows") {
[09:32:22.647]                 old_names <- names(...future.oldEnvVars)
[09:32:22.647]                 envs <- base::Sys.getenv()
[09:32:22.647]                 names <- names(envs)
[09:32:22.647]                 common <- intersect(names, old_names)
[09:32:22.647]                 added <- setdiff(names, old_names)
[09:32:22.647]                 removed <- setdiff(old_names, names)
[09:32:22.647]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:22.647]                   envs[common]]
[09:32:22.647]                 NAMES <- toupper(changed)
[09:32:22.647]                 args <- list()
[09:32:22.647]                 for (kk in seq_along(NAMES)) {
[09:32:22.647]                   name <- changed[[kk]]
[09:32:22.647]                   NAME <- NAMES[[kk]]
[09:32:22.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.647]                     next
[09:32:22.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:22.647]                 }
[09:32:22.647]                 NAMES <- toupper(added)
[09:32:22.647]                 for (kk in seq_along(NAMES)) {
[09:32:22.647]                   name <- added[[kk]]
[09:32:22.647]                   NAME <- NAMES[[kk]]
[09:32:22.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.647]                     next
[09:32:22.647]                   args[[name]] <- ""
[09:32:22.647]                 }
[09:32:22.647]                 NAMES <- toupper(removed)
[09:32:22.647]                 for (kk in seq_along(NAMES)) {
[09:32:22.647]                   name <- removed[[kk]]
[09:32:22.647]                   NAME <- NAMES[[kk]]
[09:32:22.647]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.647]                     next
[09:32:22.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:22.647]                 }
[09:32:22.647]                 if (length(args) > 0) 
[09:32:22.647]                   base::do.call(base::Sys.setenv, args = args)
[09:32:22.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:22.647]             }
[09:32:22.647]             else {
[09:32:22.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:22.647]             }
[09:32:22.647]             {
[09:32:22.647]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:22.647]                   0L) {
[09:32:22.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:22.647]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:22.647]                   base::options(opts)
[09:32:22.647]                 }
[09:32:22.647]                 {
[09:32:22.647]                   {
[09:32:22.647]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:22.647]                     NULL
[09:32:22.647]                   }
[09:32:22.647]                   options(future.plan = NULL)
[09:32:22.647]                   if (is.na(NA_character_)) 
[09:32:22.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:22.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:22.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:22.647]                     .init = FALSE)
[09:32:22.647]                 }
[09:32:22.647]             }
[09:32:22.647]         }
[09:32:22.647]     })
[09:32:22.647]     if (TRUE) {
[09:32:22.647]         base::sink(type = "output", split = FALSE)
[09:32:22.647]         if (TRUE) {
[09:32:22.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:22.647]         }
[09:32:22.647]         else {
[09:32:22.647]             ...future.result["stdout"] <- base::list(NULL)
[09:32:22.647]         }
[09:32:22.647]         base::close(...future.stdout)
[09:32:22.647]         ...future.stdout <- NULL
[09:32:22.647]     }
[09:32:22.647]     ...future.result$conditions <- ...future.conditions
[09:32:22.647]     ...future.result$finished <- base::Sys.time()
[09:32:22.647]     ...future.result
[09:32:22.647] }
[09:32:22.697] MultisessionFuture started
[09:32:22.698] result() for ClusterFuture ...
[09:32:22.698] receiveMessageFromWorker() for ClusterFuture ...
[09:32:22.698] - Validating connection of MultisessionFuture
[09:32:22.729] - received message: FutureResult
[09:32:22.729] - Received FutureResult
[09:32:22.729] - Erased future from FutureRegistry
[09:32:22.729] result() for ClusterFuture ...
[09:32:22.729] - result already collected: FutureResult
[09:32:22.729] result() for ClusterFuture ... done
[09:32:22.730] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:22.730] result() for ClusterFuture ... done
[09:32:22.730] result() for ClusterFuture ...
[09:32:22.730] - result already collected: FutureResult
[09:32:22.730] result() for ClusterFuture ... done
[09:32:22.730] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[09:32:22.734] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[09:32:22.737] getGlobalsAndPackages() ...
[09:32:22.737] Searching for globals...
[09:32:22.739] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:22.739] Searching for globals ... DONE
[09:32:22.739] Resolving globals: FALSE
[09:32:22.740] 
[09:32:22.740] 
[09:32:22.740] getGlobalsAndPackages() ... DONE
[09:32:22.740] run() for ‘Future’ ...
[09:32:22.740] - state: ‘created’
[09:32:22.740] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:22.755] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:22.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:22.755]   - Field: ‘node’
[09:32:22.755]   - Field: ‘label’
[09:32:22.755]   - Field: ‘local’
[09:32:22.755]   - Field: ‘owner’
[09:32:22.755]   - Field: ‘envir’
[09:32:22.755]   - Field: ‘workers’
[09:32:22.755]   - Field: ‘packages’
[09:32:22.755]   - Field: ‘gc’
[09:32:22.756]   - Field: ‘conditions’
[09:32:22.756]   - Field: ‘persistent’
[09:32:22.756]   - Field: ‘expr’
[09:32:22.756]   - Field: ‘uuid’
[09:32:22.756]   - Field: ‘seed’
[09:32:22.756]   - Field: ‘version’
[09:32:22.756]   - Field: ‘result’
[09:32:22.756]   - Field: ‘asynchronous’
[09:32:22.756]   - Field: ‘calls’
[09:32:22.757]   - Field: ‘globals’
[09:32:22.757]   - Field: ‘stdout’
[09:32:22.757]   - Field: ‘earlySignal’
[09:32:22.757]   - Field: ‘lazy’
[09:32:22.757]   - Field: ‘state’
[09:32:22.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:22.757] - Launch lazy future ...
[09:32:22.758] Packages needed by the future expression (n = 0): <none>
[09:32:22.758] Packages needed by future strategies (n = 0): <none>
[09:32:22.758] {
[09:32:22.758]     {
[09:32:22.758]         {
[09:32:22.758]             ...future.startTime <- base::Sys.time()
[09:32:22.758]             {
[09:32:22.758]                 {
[09:32:22.758]                   {
[09:32:22.758]                     {
[09:32:22.758]                       base::local({
[09:32:22.758]                         has_future <- base::requireNamespace("future", 
[09:32:22.758]                           quietly = TRUE)
[09:32:22.758]                         if (has_future) {
[09:32:22.758]                           ns <- base::getNamespace("future")
[09:32:22.758]                           version <- ns[[".package"]][["version"]]
[09:32:22.758]                           if (is.null(version)) 
[09:32:22.758]                             version <- utils::packageVersion("future")
[09:32:22.758]                         }
[09:32:22.758]                         else {
[09:32:22.758]                           version <- NULL
[09:32:22.758]                         }
[09:32:22.758]                         if (!has_future || version < "1.8.0") {
[09:32:22.758]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:22.758]                             "", base::R.version$version.string), 
[09:32:22.758]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:22.758]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:22.758]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:22.758]                               "release", "version")], collapse = " "), 
[09:32:22.758]                             hostname = base::Sys.info()[["nodename"]])
[09:32:22.758]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:22.758]                             info)
[09:32:22.758]                           info <- base::paste(info, collapse = "; ")
[09:32:22.758]                           if (!has_future) {
[09:32:22.758]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:22.758]                               info)
[09:32:22.758]                           }
[09:32:22.758]                           else {
[09:32:22.758]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:22.758]                               info, version)
[09:32:22.758]                           }
[09:32:22.758]                           base::stop(msg)
[09:32:22.758]                         }
[09:32:22.758]                       })
[09:32:22.758]                     }
[09:32:22.758]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:22.758]                     base::options(mc.cores = 1L)
[09:32:22.758]                   }
[09:32:22.758]                   ...future.strategy.old <- future::plan("list")
[09:32:22.758]                   options(future.plan = NULL)
[09:32:22.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:22.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:22.758]                 }
[09:32:22.758]                 ...future.workdir <- getwd()
[09:32:22.758]             }
[09:32:22.758]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:22.758]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:22.758]         }
[09:32:22.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:22.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:22.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:22.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:22.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:22.758]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:22.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:22.758]             base::names(...future.oldOptions))
[09:32:22.758]     }
[09:32:22.758]     if (FALSE) {
[09:32:22.758]     }
[09:32:22.758]     else {
[09:32:22.758]         if (TRUE) {
[09:32:22.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:22.758]                 open = "w")
[09:32:22.758]         }
[09:32:22.758]         else {
[09:32:22.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:22.758]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:22.758]         }
[09:32:22.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:22.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:22.758]             base::sink(type = "output", split = FALSE)
[09:32:22.758]             base::close(...future.stdout)
[09:32:22.758]         }, add = TRUE)
[09:32:22.758]     }
[09:32:22.758]     ...future.frame <- base::sys.nframe()
[09:32:22.758]     ...future.conditions <- base::list()
[09:32:22.758]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:22.758]     if (FALSE) {
[09:32:22.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:22.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:22.758]     }
[09:32:22.758]     ...future.result <- base::tryCatch({
[09:32:22.758]         base::withCallingHandlers({
[09:32:22.758]             ...future.value <- base::withVisible(base::local({
[09:32:22.758]                 ...future.makeSendCondition <- base::local({
[09:32:22.758]                   sendCondition <- NULL
[09:32:22.758]                   function(frame = 1L) {
[09:32:22.758]                     if (is.function(sendCondition)) 
[09:32:22.758]                       return(sendCondition)
[09:32:22.758]                     ns <- getNamespace("parallel")
[09:32:22.758]                     if (exists("sendData", mode = "function", 
[09:32:22.758]                       envir = ns)) {
[09:32:22.758]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:22.758]                         envir = ns)
[09:32:22.758]                       envir <- sys.frame(frame)
[09:32:22.758]                       master <- NULL
[09:32:22.758]                       while (!identical(envir, .GlobalEnv) && 
[09:32:22.758]                         !identical(envir, emptyenv())) {
[09:32:22.758]                         if (exists("master", mode = "list", envir = envir, 
[09:32:22.758]                           inherits = FALSE)) {
[09:32:22.758]                           master <- get("master", mode = "list", 
[09:32:22.758]                             envir = envir, inherits = FALSE)
[09:32:22.758]                           if (inherits(master, c("SOCKnode", 
[09:32:22.758]                             "SOCK0node"))) {
[09:32:22.758]                             sendCondition <<- function(cond) {
[09:32:22.758]                               data <- list(type = "VALUE", value = cond, 
[09:32:22.758]                                 success = TRUE)
[09:32:22.758]                               parallel_sendData(master, data)
[09:32:22.758]                             }
[09:32:22.758]                             return(sendCondition)
[09:32:22.758]                           }
[09:32:22.758]                         }
[09:32:22.758]                         frame <- frame + 1L
[09:32:22.758]                         envir <- sys.frame(frame)
[09:32:22.758]                       }
[09:32:22.758]                     }
[09:32:22.758]                     sendCondition <<- function(cond) NULL
[09:32:22.758]                   }
[09:32:22.758]                 })
[09:32:22.758]                 withCallingHandlers({
[09:32:22.758]                   {
[09:32:22.758]                     Sys.sleep(0.5)
[09:32:22.758]                     list(a = 1, b = 42L)
[09:32:22.758]                   }
[09:32:22.758]                 }, immediateCondition = function(cond) {
[09:32:22.758]                   sendCondition <- ...future.makeSendCondition()
[09:32:22.758]                   sendCondition(cond)
[09:32:22.758]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.758]                   {
[09:32:22.758]                     inherits <- base::inherits
[09:32:22.758]                     invokeRestart <- base::invokeRestart
[09:32:22.758]                     is.null <- base::is.null
[09:32:22.758]                     muffled <- FALSE
[09:32:22.758]                     if (inherits(cond, "message")) {
[09:32:22.758]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:22.758]                       if (muffled) 
[09:32:22.758]                         invokeRestart("muffleMessage")
[09:32:22.758]                     }
[09:32:22.758]                     else if (inherits(cond, "warning")) {
[09:32:22.758]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:22.758]                       if (muffled) 
[09:32:22.758]                         invokeRestart("muffleWarning")
[09:32:22.758]                     }
[09:32:22.758]                     else if (inherits(cond, "condition")) {
[09:32:22.758]                       if (!is.null(pattern)) {
[09:32:22.758]                         computeRestarts <- base::computeRestarts
[09:32:22.758]                         grepl <- base::grepl
[09:32:22.758]                         restarts <- computeRestarts(cond)
[09:32:22.758]                         for (restart in restarts) {
[09:32:22.758]                           name <- restart$name
[09:32:22.758]                           if (is.null(name)) 
[09:32:22.758]                             next
[09:32:22.758]                           if (!grepl(pattern, name)) 
[09:32:22.758]                             next
[09:32:22.758]                           invokeRestart(restart)
[09:32:22.758]                           muffled <- TRUE
[09:32:22.758]                           break
[09:32:22.758]                         }
[09:32:22.758]                       }
[09:32:22.758]                     }
[09:32:22.758]                     invisible(muffled)
[09:32:22.758]                   }
[09:32:22.758]                   muffleCondition(cond)
[09:32:22.758]                 })
[09:32:22.758]             }))
[09:32:22.758]             future::FutureResult(value = ...future.value$value, 
[09:32:22.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:22.758]                   ...future.rng), globalenv = if (FALSE) 
[09:32:22.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:22.758]                     ...future.globalenv.names))
[09:32:22.758]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:22.758]         }, condition = base::local({
[09:32:22.758]             c <- base::c
[09:32:22.758]             inherits <- base::inherits
[09:32:22.758]             invokeRestart <- base::invokeRestart
[09:32:22.758]             length <- base::length
[09:32:22.758]             list <- base::list
[09:32:22.758]             seq.int <- base::seq.int
[09:32:22.758]             signalCondition <- base::signalCondition
[09:32:22.758]             sys.calls <- base::sys.calls
[09:32:22.758]             `[[` <- base::`[[`
[09:32:22.758]             `+` <- base::`+`
[09:32:22.758]             `<<-` <- base::`<<-`
[09:32:22.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:22.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:22.758]                   3L)]
[09:32:22.758]             }
[09:32:22.758]             function(cond) {
[09:32:22.758]                 is_error <- inherits(cond, "error")
[09:32:22.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:22.758]                   NULL)
[09:32:22.758]                 if (is_error) {
[09:32:22.758]                   sessionInformation <- function() {
[09:32:22.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:22.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:22.758]                       search = base::search(), system = base::Sys.info())
[09:32:22.758]                   }
[09:32:22.758]                   ...future.conditions[[length(...future.conditions) + 
[09:32:22.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:22.758]                     cond$call), session = sessionInformation(), 
[09:32:22.758]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:22.758]                   signalCondition(cond)
[09:32:22.758]                 }
[09:32:22.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:22.758]                 "immediateCondition"))) {
[09:32:22.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:22.758]                   ...future.conditions[[length(...future.conditions) + 
[09:32:22.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:22.758]                   if (TRUE && !signal) {
[09:32:22.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.758]                     {
[09:32:22.758]                       inherits <- base::inherits
[09:32:22.758]                       invokeRestart <- base::invokeRestart
[09:32:22.758]                       is.null <- base::is.null
[09:32:22.758]                       muffled <- FALSE
[09:32:22.758]                       if (inherits(cond, "message")) {
[09:32:22.758]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:22.758]                         if (muffled) 
[09:32:22.758]                           invokeRestart("muffleMessage")
[09:32:22.758]                       }
[09:32:22.758]                       else if (inherits(cond, "warning")) {
[09:32:22.758]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:22.758]                         if (muffled) 
[09:32:22.758]                           invokeRestart("muffleWarning")
[09:32:22.758]                       }
[09:32:22.758]                       else if (inherits(cond, "condition")) {
[09:32:22.758]                         if (!is.null(pattern)) {
[09:32:22.758]                           computeRestarts <- base::computeRestarts
[09:32:22.758]                           grepl <- base::grepl
[09:32:22.758]                           restarts <- computeRestarts(cond)
[09:32:22.758]                           for (restart in restarts) {
[09:32:22.758]                             name <- restart$name
[09:32:22.758]                             if (is.null(name)) 
[09:32:22.758]                               next
[09:32:22.758]                             if (!grepl(pattern, name)) 
[09:32:22.758]                               next
[09:32:22.758]                             invokeRestart(restart)
[09:32:22.758]                             muffled <- TRUE
[09:32:22.758]                             break
[09:32:22.758]                           }
[09:32:22.758]                         }
[09:32:22.758]                       }
[09:32:22.758]                       invisible(muffled)
[09:32:22.758]                     }
[09:32:22.758]                     muffleCondition(cond, pattern = "^muffle")
[09:32:22.758]                   }
[09:32:22.758]                 }
[09:32:22.758]                 else {
[09:32:22.758]                   if (TRUE) {
[09:32:22.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:22.758]                     {
[09:32:22.758]                       inherits <- base::inherits
[09:32:22.758]                       invokeRestart <- base::invokeRestart
[09:32:22.758]                       is.null <- base::is.null
[09:32:22.758]                       muffled <- FALSE
[09:32:22.758]                       if (inherits(cond, "message")) {
[09:32:22.758]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:22.758]                         if (muffled) 
[09:32:22.758]                           invokeRestart("muffleMessage")
[09:32:22.758]                       }
[09:32:22.758]                       else if (inherits(cond, "warning")) {
[09:32:22.758]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:22.758]                         if (muffled) 
[09:32:22.758]                           invokeRestart("muffleWarning")
[09:32:22.758]                       }
[09:32:22.758]                       else if (inherits(cond, "condition")) {
[09:32:22.758]                         if (!is.null(pattern)) {
[09:32:22.758]                           computeRestarts <- base::computeRestarts
[09:32:22.758]                           grepl <- base::grepl
[09:32:22.758]                           restarts <- computeRestarts(cond)
[09:32:22.758]                           for (restart in restarts) {
[09:32:22.758]                             name <- restart$name
[09:32:22.758]                             if (is.null(name)) 
[09:32:22.758]                               next
[09:32:22.758]                             if (!grepl(pattern, name)) 
[09:32:22.758]                               next
[09:32:22.758]                             invokeRestart(restart)
[09:32:22.758]                             muffled <- TRUE
[09:32:22.758]                             break
[09:32:22.758]                           }
[09:32:22.758]                         }
[09:32:22.758]                       }
[09:32:22.758]                       invisible(muffled)
[09:32:22.758]                     }
[09:32:22.758]                     muffleCondition(cond, pattern = "^muffle")
[09:32:22.758]                   }
[09:32:22.758]                 }
[09:32:22.758]             }
[09:32:22.758]         }))
[09:32:22.758]     }, error = function(ex) {
[09:32:22.758]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:22.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:22.758]                 ...future.rng), started = ...future.startTime, 
[09:32:22.758]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:22.758]             version = "1.8"), class = "FutureResult")
[09:32:22.758]     }, finally = {
[09:32:22.758]         if (!identical(...future.workdir, getwd())) 
[09:32:22.758]             setwd(...future.workdir)
[09:32:22.758]         {
[09:32:22.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:22.758]                 ...future.oldOptions$nwarnings <- NULL
[09:32:22.758]             }
[09:32:22.758]             base::options(...future.oldOptions)
[09:32:22.758]             if (.Platform$OS.type == "windows") {
[09:32:22.758]                 old_names <- names(...future.oldEnvVars)
[09:32:22.758]                 envs <- base::Sys.getenv()
[09:32:22.758]                 names <- names(envs)
[09:32:22.758]                 common <- intersect(names, old_names)
[09:32:22.758]                 added <- setdiff(names, old_names)
[09:32:22.758]                 removed <- setdiff(old_names, names)
[09:32:22.758]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:22.758]                   envs[common]]
[09:32:22.758]                 NAMES <- toupper(changed)
[09:32:22.758]                 args <- list()
[09:32:22.758]                 for (kk in seq_along(NAMES)) {
[09:32:22.758]                   name <- changed[[kk]]
[09:32:22.758]                   NAME <- NAMES[[kk]]
[09:32:22.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.758]                     next
[09:32:22.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:22.758]                 }
[09:32:22.758]                 NAMES <- toupper(added)
[09:32:22.758]                 for (kk in seq_along(NAMES)) {
[09:32:22.758]                   name <- added[[kk]]
[09:32:22.758]                   NAME <- NAMES[[kk]]
[09:32:22.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.758]                     next
[09:32:22.758]                   args[[name]] <- ""
[09:32:22.758]                 }
[09:32:22.758]                 NAMES <- toupper(removed)
[09:32:22.758]                 for (kk in seq_along(NAMES)) {
[09:32:22.758]                   name <- removed[[kk]]
[09:32:22.758]                   NAME <- NAMES[[kk]]
[09:32:22.758]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:22.758]                     next
[09:32:22.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:22.758]                 }
[09:32:22.758]                 if (length(args) > 0) 
[09:32:22.758]                   base::do.call(base::Sys.setenv, args = args)
[09:32:22.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:22.758]             }
[09:32:22.758]             else {
[09:32:22.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:22.758]             }
[09:32:22.758]             {
[09:32:22.758]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:22.758]                   0L) {
[09:32:22.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:22.758]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:22.758]                   base::options(opts)
[09:32:22.758]                 }
[09:32:22.758]                 {
[09:32:22.758]                   {
[09:32:22.758]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:22.758]                     NULL
[09:32:22.758]                   }
[09:32:22.758]                   options(future.plan = NULL)
[09:32:22.758]                   if (is.na(NA_character_)) 
[09:32:22.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:22.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:22.758]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:22.758]                     .init = FALSE)
[09:32:22.758]                 }
[09:32:22.758]             }
[09:32:22.758]         }
[09:32:22.758]     })
[09:32:22.758]     if (TRUE) {
[09:32:22.758]         base::sink(type = "output", split = FALSE)
[09:32:22.758]         if (TRUE) {
[09:32:22.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:22.758]         }
[09:32:22.758]         else {
[09:32:22.758]             ...future.result["stdout"] <- base::list(NULL)
[09:32:22.758]         }
[09:32:22.758]         base::close(...future.stdout)
[09:32:22.758]         ...future.stdout <- NULL
[09:32:22.758]     }
[09:32:22.758]     ...future.result$conditions <- ...future.conditions
[09:32:22.758]     ...future.result$finished <- base::Sys.time()
[09:32:22.758]     ...future.result
[09:32:22.758] }
[09:32:22.762] MultisessionFuture started
[09:32:22.762] - Launch lazy future ... done
[09:32:22.762] run() for ‘MultisessionFuture’ ... done
[09:32:23.264] receiveMessageFromWorker() for ClusterFuture ...
[09:32:23.264] - Validating connection of MultisessionFuture
[09:32:23.264] - received message: FutureResult
[09:32:23.264] - Received FutureResult
[09:32:23.265] - Erased future from FutureRegistry
[09:32:23.265] result() for ClusterFuture ...
[09:32:23.265] - result already collected: FutureResult
[09:32:23.265] result() for ClusterFuture ... done
[09:32:23.265] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:23.265] A MultisessionFuture was resolved (result was not collected)
[09:32:23.265] getGlobalsAndPackages() ...
[09:32:23.265] Searching for globals...
[09:32:23.267] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:23.267] Searching for globals ... DONE
[09:32:23.267] Resolving globals: FALSE
[09:32:23.267] 
[09:32:23.268] 
[09:32:23.268] getGlobalsAndPackages() ... DONE
[09:32:23.268] run() for ‘Future’ ...
[09:32:23.268] - state: ‘created’
[09:32:23.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:23.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:23.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:23.283]   - Field: ‘node’
[09:32:23.283]   - Field: ‘label’
[09:32:23.284]   - Field: ‘local’
[09:32:23.284]   - Field: ‘owner’
[09:32:23.284]   - Field: ‘envir’
[09:32:23.284]   - Field: ‘workers’
[09:32:23.284]   - Field: ‘packages’
[09:32:23.284]   - Field: ‘gc’
[09:32:23.284]   - Field: ‘conditions’
[09:32:23.284]   - Field: ‘persistent’
[09:32:23.284]   - Field: ‘expr’
[09:32:23.285]   - Field: ‘uuid’
[09:32:23.285]   - Field: ‘seed’
[09:32:23.285]   - Field: ‘version’
[09:32:23.285]   - Field: ‘result’
[09:32:23.285]   - Field: ‘asynchronous’
[09:32:23.285]   - Field: ‘calls’
[09:32:23.285]   - Field: ‘globals’
[09:32:23.285]   - Field: ‘stdout’
[09:32:23.285]   - Field: ‘earlySignal’
[09:32:23.286]   - Field: ‘lazy’
[09:32:23.286]   - Field: ‘state’
[09:32:23.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:23.286] - Launch lazy future ...
[09:32:23.286] Packages needed by the future expression (n = 0): <none>
[09:32:23.286] Packages needed by future strategies (n = 0): <none>
[09:32:23.287] {
[09:32:23.287]     {
[09:32:23.287]         {
[09:32:23.287]             ...future.startTime <- base::Sys.time()
[09:32:23.287]             {
[09:32:23.287]                 {
[09:32:23.287]                   {
[09:32:23.287]                     {
[09:32:23.287]                       base::local({
[09:32:23.287]                         has_future <- base::requireNamespace("future", 
[09:32:23.287]                           quietly = TRUE)
[09:32:23.287]                         if (has_future) {
[09:32:23.287]                           ns <- base::getNamespace("future")
[09:32:23.287]                           version <- ns[[".package"]][["version"]]
[09:32:23.287]                           if (is.null(version)) 
[09:32:23.287]                             version <- utils::packageVersion("future")
[09:32:23.287]                         }
[09:32:23.287]                         else {
[09:32:23.287]                           version <- NULL
[09:32:23.287]                         }
[09:32:23.287]                         if (!has_future || version < "1.8.0") {
[09:32:23.287]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:23.287]                             "", base::R.version$version.string), 
[09:32:23.287]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:23.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:23.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:23.287]                               "release", "version")], collapse = " "), 
[09:32:23.287]                             hostname = base::Sys.info()[["nodename"]])
[09:32:23.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:23.287]                             info)
[09:32:23.287]                           info <- base::paste(info, collapse = "; ")
[09:32:23.287]                           if (!has_future) {
[09:32:23.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:23.287]                               info)
[09:32:23.287]                           }
[09:32:23.287]                           else {
[09:32:23.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:23.287]                               info, version)
[09:32:23.287]                           }
[09:32:23.287]                           base::stop(msg)
[09:32:23.287]                         }
[09:32:23.287]                       })
[09:32:23.287]                     }
[09:32:23.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:23.287]                     base::options(mc.cores = 1L)
[09:32:23.287]                   }
[09:32:23.287]                   ...future.strategy.old <- future::plan("list")
[09:32:23.287]                   options(future.plan = NULL)
[09:32:23.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:23.287]                 }
[09:32:23.287]                 ...future.workdir <- getwd()
[09:32:23.287]             }
[09:32:23.287]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:23.287]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:23.287]         }
[09:32:23.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:23.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:23.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:23.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:23.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:23.287]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:23.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:23.287]             base::names(...future.oldOptions))
[09:32:23.287]     }
[09:32:23.287]     if (FALSE) {
[09:32:23.287]     }
[09:32:23.287]     else {
[09:32:23.287]         if (TRUE) {
[09:32:23.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:23.287]                 open = "w")
[09:32:23.287]         }
[09:32:23.287]         else {
[09:32:23.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:23.287]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:23.287]         }
[09:32:23.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:23.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:23.287]             base::sink(type = "output", split = FALSE)
[09:32:23.287]             base::close(...future.stdout)
[09:32:23.287]         }, add = TRUE)
[09:32:23.287]     }
[09:32:23.287]     ...future.frame <- base::sys.nframe()
[09:32:23.287]     ...future.conditions <- base::list()
[09:32:23.287]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:23.287]     if (FALSE) {
[09:32:23.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:23.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:23.287]     }
[09:32:23.287]     ...future.result <- base::tryCatch({
[09:32:23.287]         base::withCallingHandlers({
[09:32:23.287]             ...future.value <- base::withVisible(base::local({
[09:32:23.287]                 ...future.makeSendCondition <- base::local({
[09:32:23.287]                   sendCondition <- NULL
[09:32:23.287]                   function(frame = 1L) {
[09:32:23.287]                     if (is.function(sendCondition)) 
[09:32:23.287]                       return(sendCondition)
[09:32:23.287]                     ns <- getNamespace("parallel")
[09:32:23.287]                     if (exists("sendData", mode = "function", 
[09:32:23.287]                       envir = ns)) {
[09:32:23.287]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:23.287]                         envir = ns)
[09:32:23.287]                       envir <- sys.frame(frame)
[09:32:23.287]                       master <- NULL
[09:32:23.287]                       while (!identical(envir, .GlobalEnv) && 
[09:32:23.287]                         !identical(envir, emptyenv())) {
[09:32:23.287]                         if (exists("master", mode = "list", envir = envir, 
[09:32:23.287]                           inherits = FALSE)) {
[09:32:23.287]                           master <- get("master", mode = "list", 
[09:32:23.287]                             envir = envir, inherits = FALSE)
[09:32:23.287]                           if (inherits(master, c("SOCKnode", 
[09:32:23.287]                             "SOCK0node"))) {
[09:32:23.287]                             sendCondition <<- function(cond) {
[09:32:23.287]                               data <- list(type = "VALUE", value = cond, 
[09:32:23.287]                                 success = TRUE)
[09:32:23.287]                               parallel_sendData(master, data)
[09:32:23.287]                             }
[09:32:23.287]                             return(sendCondition)
[09:32:23.287]                           }
[09:32:23.287]                         }
[09:32:23.287]                         frame <- frame + 1L
[09:32:23.287]                         envir <- sys.frame(frame)
[09:32:23.287]                       }
[09:32:23.287]                     }
[09:32:23.287]                     sendCondition <<- function(cond) NULL
[09:32:23.287]                   }
[09:32:23.287]                 })
[09:32:23.287]                 withCallingHandlers({
[09:32:23.287]                   {
[09:32:23.287]                     Sys.sleep(0.5)
[09:32:23.287]                     list(a = 1, b = 42L)
[09:32:23.287]                   }
[09:32:23.287]                 }, immediateCondition = function(cond) {
[09:32:23.287]                   sendCondition <- ...future.makeSendCondition()
[09:32:23.287]                   sendCondition(cond)
[09:32:23.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.287]                   {
[09:32:23.287]                     inherits <- base::inherits
[09:32:23.287]                     invokeRestart <- base::invokeRestart
[09:32:23.287]                     is.null <- base::is.null
[09:32:23.287]                     muffled <- FALSE
[09:32:23.287]                     if (inherits(cond, "message")) {
[09:32:23.287]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:23.287]                       if (muffled) 
[09:32:23.287]                         invokeRestart("muffleMessage")
[09:32:23.287]                     }
[09:32:23.287]                     else if (inherits(cond, "warning")) {
[09:32:23.287]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:23.287]                       if (muffled) 
[09:32:23.287]                         invokeRestart("muffleWarning")
[09:32:23.287]                     }
[09:32:23.287]                     else if (inherits(cond, "condition")) {
[09:32:23.287]                       if (!is.null(pattern)) {
[09:32:23.287]                         computeRestarts <- base::computeRestarts
[09:32:23.287]                         grepl <- base::grepl
[09:32:23.287]                         restarts <- computeRestarts(cond)
[09:32:23.287]                         for (restart in restarts) {
[09:32:23.287]                           name <- restart$name
[09:32:23.287]                           if (is.null(name)) 
[09:32:23.287]                             next
[09:32:23.287]                           if (!grepl(pattern, name)) 
[09:32:23.287]                             next
[09:32:23.287]                           invokeRestart(restart)
[09:32:23.287]                           muffled <- TRUE
[09:32:23.287]                           break
[09:32:23.287]                         }
[09:32:23.287]                       }
[09:32:23.287]                     }
[09:32:23.287]                     invisible(muffled)
[09:32:23.287]                   }
[09:32:23.287]                   muffleCondition(cond)
[09:32:23.287]                 })
[09:32:23.287]             }))
[09:32:23.287]             future::FutureResult(value = ...future.value$value, 
[09:32:23.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.287]                   ...future.rng), globalenv = if (FALSE) 
[09:32:23.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:23.287]                     ...future.globalenv.names))
[09:32:23.287]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:23.287]         }, condition = base::local({
[09:32:23.287]             c <- base::c
[09:32:23.287]             inherits <- base::inherits
[09:32:23.287]             invokeRestart <- base::invokeRestart
[09:32:23.287]             length <- base::length
[09:32:23.287]             list <- base::list
[09:32:23.287]             seq.int <- base::seq.int
[09:32:23.287]             signalCondition <- base::signalCondition
[09:32:23.287]             sys.calls <- base::sys.calls
[09:32:23.287]             `[[` <- base::`[[`
[09:32:23.287]             `+` <- base::`+`
[09:32:23.287]             `<<-` <- base::`<<-`
[09:32:23.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:23.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:23.287]                   3L)]
[09:32:23.287]             }
[09:32:23.287]             function(cond) {
[09:32:23.287]                 is_error <- inherits(cond, "error")
[09:32:23.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:23.287]                   NULL)
[09:32:23.287]                 if (is_error) {
[09:32:23.287]                   sessionInformation <- function() {
[09:32:23.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:23.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:23.287]                       search = base::search(), system = base::Sys.info())
[09:32:23.287]                   }
[09:32:23.287]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:23.287]                     cond$call), session = sessionInformation(), 
[09:32:23.287]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:23.287]                   signalCondition(cond)
[09:32:23.287]                 }
[09:32:23.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:23.287]                 "immediateCondition"))) {
[09:32:23.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:23.287]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:23.287]                   if (TRUE && !signal) {
[09:32:23.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.287]                     {
[09:32:23.287]                       inherits <- base::inherits
[09:32:23.287]                       invokeRestart <- base::invokeRestart
[09:32:23.287]                       is.null <- base::is.null
[09:32:23.287]                       muffled <- FALSE
[09:32:23.287]                       if (inherits(cond, "message")) {
[09:32:23.287]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.287]                         if (muffled) 
[09:32:23.287]                           invokeRestart("muffleMessage")
[09:32:23.287]                       }
[09:32:23.287]                       else if (inherits(cond, "warning")) {
[09:32:23.287]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.287]                         if (muffled) 
[09:32:23.287]                           invokeRestart("muffleWarning")
[09:32:23.287]                       }
[09:32:23.287]                       else if (inherits(cond, "condition")) {
[09:32:23.287]                         if (!is.null(pattern)) {
[09:32:23.287]                           computeRestarts <- base::computeRestarts
[09:32:23.287]                           grepl <- base::grepl
[09:32:23.287]                           restarts <- computeRestarts(cond)
[09:32:23.287]                           for (restart in restarts) {
[09:32:23.287]                             name <- restart$name
[09:32:23.287]                             if (is.null(name)) 
[09:32:23.287]                               next
[09:32:23.287]                             if (!grepl(pattern, name)) 
[09:32:23.287]                               next
[09:32:23.287]                             invokeRestart(restart)
[09:32:23.287]                             muffled <- TRUE
[09:32:23.287]                             break
[09:32:23.287]                           }
[09:32:23.287]                         }
[09:32:23.287]                       }
[09:32:23.287]                       invisible(muffled)
[09:32:23.287]                     }
[09:32:23.287]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.287]                   }
[09:32:23.287]                 }
[09:32:23.287]                 else {
[09:32:23.287]                   if (TRUE) {
[09:32:23.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.287]                     {
[09:32:23.287]                       inherits <- base::inherits
[09:32:23.287]                       invokeRestart <- base::invokeRestart
[09:32:23.287]                       is.null <- base::is.null
[09:32:23.287]                       muffled <- FALSE
[09:32:23.287]                       if (inherits(cond, "message")) {
[09:32:23.287]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.287]                         if (muffled) 
[09:32:23.287]                           invokeRestart("muffleMessage")
[09:32:23.287]                       }
[09:32:23.287]                       else if (inherits(cond, "warning")) {
[09:32:23.287]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.287]                         if (muffled) 
[09:32:23.287]                           invokeRestart("muffleWarning")
[09:32:23.287]                       }
[09:32:23.287]                       else if (inherits(cond, "condition")) {
[09:32:23.287]                         if (!is.null(pattern)) {
[09:32:23.287]                           computeRestarts <- base::computeRestarts
[09:32:23.287]                           grepl <- base::grepl
[09:32:23.287]                           restarts <- computeRestarts(cond)
[09:32:23.287]                           for (restart in restarts) {
[09:32:23.287]                             name <- restart$name
[09:32:23.287]                             if (is.null(name)) 
[09:32:23.287]                               next
[09:32:23.287]                             if (!grepl(pattern, name)) 
[09:32:23.287]                               next
[09:32:23.287]                             invokeRestart(restart)
[09:32:23.287]                             muffled <- TRUE
[09:32:23.287]                             break
[09:32:23.287]                           }
[09:32:23.287]                         }
[09:32:23.287]                       }
[09:32:23.287]                       invisible(muffled)
[09:32:23.287]                     }
[09:32:23.287]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.287]                   }
[09:32:23.287]                 }
[09:32:23.287]             }
[09:32:23.287]         }))
[09:32:23.287]     }, error = function(ex) {
[09:32:23.287]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:23.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.287]                 ...future.rng), started = ...future.startTime, 
[09:32:23.287]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:23.287]             version = "1.8"), class = "FutureResult")
[09:32:23.287]     }, finally = {
[09:32:23.287]         if (!identical(...future.workdir, getwd())) 
[09:32:23.287]             setwd(...future.workdir)
[09:32:23.287]         {
[09:32:23.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:23.287]                 ...future.oldOptions$nwarnings <- NULL
[09:32:23.287]             }
[09:32:23.287]             base::options(...future.oldOptions)
[09:32:23.287]             if (.Platform$OS.type == "windows") {
[09:32:23.287]                 old_names <- names(...future.oldEnvVars)
[09:32:23.287]                 envs <- base::Sys.getenv()
[09:32:23.287]                 names <- names(envs)
[09:32:23.287]                 common <- intersect(names, old_names)
[09:32:23.287]                 added <- setdiff(names, old_names)
[09:32:23.287]                 removed <- setdiff(old_names, names)
[09:32:23.287]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:23.287]                   envs[common]]
[09:32:23.287]                 NAMES <- toupper(changed)
[09:32:23.287]                 args <- list()
[09:32:23.287]                 for (kk in seq_along(NAMES)) {
[09:32:23.287]                   name <- changed[[kk]]
[09:32:23.287]                   NAME <- NAMES[[kk]]
[09:32:23.287]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.287]                     next
[09:32:23.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.287]                 }
[09:32:23.287]                 NAMES <- toupper(added)
[09:32:23.287]                 for (kk in seq_along(NAMES)) {
[09:32:23.287]                   name <- added[[kk]]
[09:32:23.287]                   NAME <- NAMES[[kk]]
[09:32:23.287]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.287]                     next
[09:32:23.287]                   args[[name]] <- ""
[09:32:23.287]                 }
[09:32:23.287]                 NAMES <- toupper(removed)
[09:32:23.287]                 for (kk in seq_along(NAMES)) {
[09:32:23.287]                   name <- removed[[kk]]
[09:32:23.287]                   NAME <- NAMES[[kk]]
[09:32:23.287]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.287]                     next
[09:32:23.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.287]                 }
[09:32:23.287]                 if (length(args) > 0) 
[09:32:23.287]                   base::do.call(base::Sys.setenv, args = args)
[09:32:23.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:23.287]             }
[09:32:23.287]             else {
[09:32:23.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:23.287]             }
[09:32:23.287]             {
[09:32:23.287]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:23.287]                   0L) {
[09:32:23.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:23.287]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:23.287]                   base::options(opts)
[09:32:23.287]                 }
[09:32:23.287]                 {
[09:32:23.287]                   {
[09:32:23.287]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:23.287]                     NULL
[09:32:23.287]                   }
[09:32:23.287]                   options(future.plan = NULL)
[09:32:23.287]                   if (is.na(NA_character_)) 
[09:32:23.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:23.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:23.287]                     .init = FALSE)
[09:32:23.287]                 }
[09:32:23.287]             }
[09:32:23.287]         }
[09:32:23.287]     })
[09:32:23.287]     if (TRUE) {
[09:32:23.287]         base::sink(type = "output", split = FALSE)
[09:32:23.287]         if (TRUE) {
[09:32:23.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:23.287]         }
[09:32:23.287]         else {
[09:32:23.287]             ...future.result["stdout"] <- base::list(NULL)
[09:32:23.287]         }
[09:32:23.287]         base::close(...future.stdout)
[09:32:23.287]         ...future.stdout <- NULL
[09:32:23.287]     }
[09:32:23.287]     ...future.result$conditions <- ...future.conditions
[09:32:23.287]     ...future.result$finished <- base::Sys.time()
[09:32:23.287]     ...future.result
[09:32:23.287] }
[09:32:23.290] MultisessionFuture started
[09:32:23.290] - Launch lazy future ... done
[09:32:23.290] run() for ‘MultisessionFuture’ ... done
[09:32:23.796] receiveMessageFromWorker() for ClusterFuture ...
[09:32:23.796] - Validating connection of MultisessionFuture
[09:32:23.796] - received message: FutureResult
[09:32:23.796] - Received FutureResult
[09:32:23.797] - Erased future from FutureRegistry
[09:32:23.797] result() for ClusterFuture ...
[09:32:23.797] - result already collected: FutureResult
[09:32:23.797] result() for ClusterFuture ... done
[09:32:23.797] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:23.797] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:23.797] getGlobalsAndPackages() ...
[09:32:23.797] Searching for globals...
[09:32:23.798] - globals found: [2] ‘list’, ‘stop’
[09:32:23.798] Searching for globals ... DONE
[09:32:23.799] Resolving globals: FALSE
[09:32:23.799] 
[09:32:23.799] 
[09:32:23.799] getGlobalsAndPackages() ... DONE
[09:32:23.799] run() for ‘Future’ ...
[09:32:23.800] - state: ‘created’
[09:32:23.800] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:23.814] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:23.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:23.817]   - Field: ‘node’
[09:32:23.817]   - Field: ‘label’
[09:32:23.817]   - Field: ‘local’
[09:32:23.817]   - Field: ‘owner’
[09:32:23.817]   - Field: ‘envir’
[09:32:23.817]   - Field: ‘workers’
[09:32:23.817]   - Field: ‘packages’
[09:32:23.817]   - Field: ‘gc’
[09:32:23.817]   - Field: ‘conditions’
[09:32:23.817]   - Field: ‘persistent’
[09:32:23.817]   - Field: ‘expr’
[09:32:23.817]   - Field: ‘uuid’
[09:32:23.818]   - Field: ‘seed’
[09:32:23.818]   - Field: ‘version’
[09:32:23.818]   - Field: ‘result’
[09:32:23.818]   - Field: ‘asynchronous’
[09:32:23.818]   - Field: ‘calls’
[09:32:23.818]   - Field: ‘globals’
[09:32:23.818]   - Field: ‘stdout’
[09:32:23.818]   - Field: ‘earlySignal’
[09:32:23.818]   - Field: ‘lazy’
[09:32:23.818]   - Field: ‘state’
[09:32:23.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:23.819] - Launch lazy future ...
[09:32:23.819] Packages needed by the future expression (n = 0): <none>
[09:32:23.819] Packages needed by future strategies (n = 0): <none>
[09:32:23.819] {
[09:32:23.819]     {
[09:32:23.819]         {
[09:32:23.819]             ...future.startTime <- base::Sys.time()
[09:32:23.819]             {
[09:32:23.819]                 {
[09:32:23.819]                   {
[09:32:23.819]                     {
[09:32:23.819]                       base::local({
[09:32:23.819]                         has_future <- base::requireNamespace("future", 
[09:32:23.819]                           quietly = TRUE)
[09:32:23.819]                         if (has_future) {
[09:32:23.819]                           ns <- base::getNamespace("future")
[09:32:23.819]                           version <- ns[[".package"]][["version"]]
[09:32:23.819]                           if (is.null(version)) 
[09:32:23.819]                             version <- utils::packageVersion("future")
[09:32:23.819]                         }
[09:32:23.819]                         else {
[09:32:23.819]                           version <- NULL
[09:32:23.819]                         }
[09:32:23.819]                         if (!has_future || version < "1.8.0") {
[09:32:23.819]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:23.819]                             "", base::R.version$version.string), 
[09:32:23.819]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:23.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:23.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:23.819]                               "release", "version")], collapse = " "), 
[09:32:23.819]                             hostname = base::Sys.info()[["nodename"]])
[09:32:23.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:23.819]                             info)
[09:32:23.819]                           info <- base::paste(info, collapse = "; ")
[09:32:23.819]                           if (!has_future) {
[09:32:23.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:23.819]                               info)
[09:32:23.819]                           }
[09:32:23.819]                           else {
[09:32:23.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:23.819]                               info, version)
[09:32:23.819]                           }
[09:32:23.819]                           base::stop(msg)
[09:32:23.819]                         }
[09:32:23.819]                       })
[09:32:23.819]                     }
[09:32:23.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:23.819]                     base::options(mc.cores = 1L)
[09:32:23.819]                   }
[09:32:23.819]                   ...future.strategy.old <- future::plan("list")
[09:32:23.819]                   options(future.plan = NULL)
[09:32:23.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:23.819]                 }
[09:32:23.819]                 ...future.workdir <- getwd()
[09:32:23.819]             }
[09:32:23.819]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:23.819]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:23.819]         }
[09:32:23.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:23.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:23.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:23.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:23.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:23.819]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:23.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:23.819]             base::names(...future.oldOptions))
[09:32:23.819]     }
[09:32:23.819]     if (FALSE) {
[09:32:23.819]     }
[09:32:23.819]     else {
[09:32:23.819]         if (TRUE) {
[09:32:23.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:23.819]                 open = "w")
[09:32:23.819]         }
[09:32:23.819]         else {
[09:32:23.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:23.819]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:23.819]         }
[09:32:23.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:23.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:23.819]             base::sink(type = "output", split = FALSE)
[09:32:23.819]             base::close(...future.stdout)
[09:32:23.819]         }, add = TRUE)
[09:32:23.819]     }
[09:32:23.819]     ...future.frame <- base::sys.nframe()
[09:32:23.819]     ...future.conditions <- base::list()
[09:32:23.819]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:23.819]     if (FALSE) {
[09:32:23.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:23.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:23.819]     }
[09:32:23.819]     ...future.result <- base::tryCatch({
[09:32:23.819]         base::withCallingHandlers({
[09:32:23.819]             ...future.value <- base::withVisible(base::local({
[09:32:23.819]                 ...future.makeSendCondition <- base::local({
[09:32:23.819]                   sendCondition <- NULL
[09:32:23.819]                   function(frame = 1L) {
[09:32:23.819]                     if (is.function(sendCondition)) 
[09:32:23.819]                       return(sendCondition)
[09:32:23.819]                     ns <- getNamespace("parallel")
[09:32:23.819]                     if (exists("sendData", mode = "function", 
[09:32:23.819]                       envir = ns)) {
[09:32:23.819]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:23.819]                         envir = ns)
[09:32:23.819]                       envir <- sys.frame(frame)
[09:32:23.819]                       master <- NULL
[09:32:23.819]                       while (!identical(envir, .GlobalEnv) && 
[09:32:23.819]                         !identical(envir, emptyenv())) {
[09:32:23.819]                         if (exists("master", mode = "list", envir = envir, 
[09:32:23.819]                           inherits = FALSE)) {
[09:32:23.819]                           master <- get("master", mode = "list", 
[09:32:23.819]                             envir = envir, inherits = FALSE)
[09:32:23.819]                           if (inherits(master, c("SOCKnode", 
[09:32:23.819]                             "SOCK0node"))) {
[09:32:23.819]                             sendCondition <<- function(cond) {
[09:32:23.819]                               data <- list(type = "VALUE", value = cond, 
[09:32:23.819]                                 success = TRUE)
[09:32:23.819]                               parallel_sendData(master, data)
[09:32:23.819]                             }
[09:32:23.819]                             return(sendCondition)
[09:32:23.819]                           }
[09:32:23.819]                         }
[09:32:23.819]                         frame <- frame + 1L
[09:32:23.819]                         envir <- sys.frame(frame)
[09:32:23.819]                       }
[09:32:23.819]                     }
[09:32:23.819]                     sendCondition <<- function(cond) NULL
[09:32:23.819]                   }
[09:32:23.819]                 })
[09:32:23.819]                 withCallingHandlers({
[09:32:23.819]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:23.819]                 }, immediateCondition = function(cond) {
[09:32:23.819]                   sendCondition <- ...future.makeSendCondition()
[09:32:23.819]                   sendCondition(cond)
[09:32:23.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.819]                   {
[09:32:23.819]                     inherits <- base::inherits
[09:32:23.819]                     invokeRestart <- base::invokeRestart
[09:32:23.819]                     is.null <- base::is.null
[09:32:23.819]                     muffled <- FALSE
[09:32:23.819]                     if (inherits(cond, "message")) {
[09:32:23.819]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:23.819]                       if (muffled) 
[09:32:23.819]                         invokeRestart("muffleMessage")
[09:32:23.819]                     }
[09:32:23.819]                     else if (inherits(cond, "warning")) {
[09:32:23.819]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:23.819]                       if (muffled) 
[09:32:23.819]                         invokeRestart("muffleWarning")
[09:32:23.819]                     }
[09:32:23.819]                     else if (inherits(cond, "condition")) {
[09:32:23.819]                       if (!is.null(pattern)) {
[09:32:23.819]                         computeRestarts <- base::computeRestarts
[09:32:23.819]                         grepl <- base::grepl
[09:32:23.819]                         restarts <- computeRestarts(cond)
[09:32:23.819]                         for (restart in restarts) {
[09:32:23.819]                           name <- restart$name
[09:32:23.819]                           if (is.null(name)) 
[09:32:23.819]                             next
[09:32:23.819]                           if (!grepl(pattern, name)) 
[09:32:23.819]                             next
[09:32:23.819]                           invokeRestart(restart)
[09:32:23.819]                           muffled <- TRUE
[09:32:23.819]                           break
[09:32:23.819]                         }
[09:32:23.819]                       }
[09:32:23.819]                     }
[09:32:23.819]                     invisible(muffled)
[09:32:23.819]                   }
[09:32:23.819]                   muffleCondition(cond)
[09:32:23.819]                 })
[09:32:23.819]             }))
[09:32:23.819]             future::FutureResult(value = ...future.value$value, 
[09:32:23.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.819]                   ...future.rng), globalenv = if (FALSE) 
[09:32:23.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:23.819]                     ...future.globalenv.names))
[09:32:23.819]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:23.819]         }, condition = base::local({
[09:32:23.819]             c <- base::c
[09:32:23.819]             inherits <- base::inherits
[09:32:23.819]             invokeRestart <- base::invokeRestart
[09:32:23.819]             length <- base::length
[09:32:23.819]             list <- base::list
[09:32:23.819]             seq.int <- base::seq.int
[09:32:23.819]             signalCondition <- base::signalCondition
[09:32:23.819]             sys.calls <- base::sys.calls
[09:32:23.819]             `[[` <- base::`[[`
[09:32:23.819]             `+` <- base::`+`
[09:32:23.819]             `<<-` <- base::`<<-`
[09:32:23.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:23.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:23.819]                   3L)]
[09:32:23.819]             }
[09:32:23.819]             function(cond) {
[09:32:23.819]                 is_error <- inherits(cond, "error")
[09:32:23.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:23.819]                   NULL)
[09:32:23.819]                 if (is_error) {
[09:32:23.819]                   sessionInformation <- function() {
[09:32:23.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:23.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:23.819]                       search = base::search(), system = base::Sys.info())
[09:32:23.819]                   }
[09:32:23.819]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:23.819]                     cond$call), session = sessionInformation(), 
[09:32:23.819]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:23.819]                   signalCondition(cond)
[09:32:23.819]                 }
[09:32:23.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:23.819]                 "immediateCondition"))) {
[09:32:23.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:23.819]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:23.819]                   if (TRUE && !signal) {
[09:32:23.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.819]                     {
[09:32:23.819]                       inherits <- base::inherits
[09:32:23.819]                       invokeRestart <- base::invokeRestart
[09:32:23.819]                       is.null <- base::is.null
[09:32:23.819]                       muffled <- FALSE
[09:32:23.819]                       if (inherits(cond, "message")) {
[09:32:23.819]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.819]                         if (muffled) 
[09:32:23.819]                           invokeRestart("muffleMessage")
[09:32:23.819]                       }
[09:32:23.819]                       else if (inherits(cond, "warning")) {
[09:32:23.819]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.819]                         if (muffled) 
[09:32:23.819]                           invokeRestart("muffleWarning")
[09:32:23.819]                       }
[09:32:23.819]                       else if (inherits(cond, "condition")) {
[09:32:23.819]                         if (!is.null(pattern)) {
[09:32:23.819]                           computeRestarts <- base::computeRestarts
[09:32:23.819]                           grepl <- base::grepl
[09:32:23.819]                           restarts <- computeRestarts(cond)
[09:32:23.819]                           for (restart in restarts) {
[09:32:23.819]                             name <- restart$name
[09:32:23.819]                             if (is.null(name)) 
[09:32:23.819]                               next
[09:32:23.819]                             if (!grepl(pattern, name)) 
[09:32:23.819]                               next
[09:32:23.819]                             invokeRestart(restart)
[09:32:23.819]                             muffled <- TRUE
[09:32:23.819]                             break
[09:32:23.819]                           }
[09:32:23.819]                         }
[09:32:23.819]                       }
[09:32:23.819]                       invisible(muffled)
[09:32:23.819]                     }
[09:32:23.819]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.819]                   }
[09:32:23.819]                 }
[09:32:23.819]                 else {
[09:32:23.819]                   if (TRUE) {
[09:32:23.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.819]                     {
[09:32:23.819]                       inherits <- base::inherits
[09:32:23.819]                       invokeRestart <- base::invokeRestart
[09:32:23.819]                       is.null <- base::is.null
[09:32:23.819]                       muffled <- FALSE
[09:32:23.819]                       if (inherits(cond, "message")) {
[09:32:23.819]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.819]                         if (muffled) 
[09:32:23.819]                           invokeRestart("muffleMessage")
[09:32:23.819]                       }
[09:32:23.819]                       else if (inherits(cond, "warning")) {
[09:32:23.819]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.819]                         if (muffled) 
[09:32:23.819]                           invokeRestart("muffleWarning")
[09:32:23.819]                       }
[09:32:23.819]                       else if (inherits(cond, "condition")) {
[09:32:23.819]                         if (!is.null(pattern)) {
[09:32:23.819]                           computeRestarts <- base::computeRestarts
[09:32:23.819]                           grepl <- base::grepl
[09:32:23.819]                           restarts <- computeRestarts(cond)
[09:32:23.819]                           for (restart in restarts) {
[09:32:23.819]                             name <- restart$name
[09:32:23.819]                             if (is.null(name)) 
[09:32:23.819]                               next
[09:32:23.819]                             if (!grepl(pattern, name)) 
[09:32:23.819]                               next
[09:32:23.819]                             invokeRestart(restart)
[09:32:23.819]                             muffled <- TRUE
[09:32:23.819]                             break
[09:32:23.819]                           }
[09:32:23.819]                         }
[09:32:23.819]                       }
[09:32:23.819]                       invisible(muffled)
[09:32:23.819]                     }
[09:32:23.819]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.819]                   }
[09:32:23.819]                 }
[09:32:23.819]             }
[09:32:23.819]         }))
[09:32:23.819]     }, error = function(ex) {
[09:32:23.819]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:23.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.819]                 ...future.rng), started = ...future.startTime, 
[09:32:23.819]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:23.819]             version = "1.8"), class = "FutureResult")
[09:32:23.819]     }, finally = {
[09:32:23.819]         if (!identical(...future.workdir, getwd())) 
[09:32:23.819]             setwd(...future.workdir)
[09:32:23.819]         {
[09:32:23.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:23.819]                 ...future.oldOptions$nwarnings <- NULL
[09:32:23.819]             }
[09:32:23.819]             base::options(...future.oldOptions)
[09:32:23.819]             if (.Platform$OS.type == "windows") {
[09:32:23.819]                 old_names <- names(...future.oldEnvVars)
[09:32:23.819]                 envs <- base::Sys.getenv()
[09:32:23.819]                 names <- names(envs)
[09:32:23.819]                 common <- intersect(names, old_names)
[09:32:23.819]                 added <- setdiff(names, old_names)
[09:32:23.819]                 removed <- setdiff(old_names, names)
[09:32:23.819]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:23.819]                   envs[common]]
[09:32:23.819]                 NAMES <- toupper(changed)
[09:32:23.819]                 args <- list()
[09:32:23.819]                 for (kk in seq_along(NAMES)) {
[09:32:23.819]                   name <- changed[[kk]]
[09:32:23.819]                   NAME <- NAMES[[kk]]
[09:32:23.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.819]                     next
[09:32:23.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.819]                 }
[09:32:23.819]                 NAMES <- toupper(added)
[09:32:23.819]                 for (kk in seq_along(NAMES)) {
[09:32:23.819]                   name <- added[[kk]]
[09:32:23.819]                   NAME <- NAMES[[kk]]
[09:32:23.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.819]                     next
[09:32:23.819]                   args[[name]] <- ""
[09:32:23.819]                 }
[09:32:23.819]                 NAMES <- toupper(removed)
[09:32:23.819]                 for (kk in seq_along(NAMES)) {
[09:32:23.819]                   name <- removed[[kk]]
[09:32:23.819]                   NAME <- NAMES[[kk]]
[09:32:23.819]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.819]                     next
[09:32:23.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.819]                 }
[09:32:23.819]                 if (length(args) > 0) 
[09:32:23.819]                   base::do.call(base::Sys.setenv, args = args)
[09:32:23.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:23.819]             }
[09:32:23.819]             else {
[09:32:23.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:23.819]             }
[09:32:23.819]             {
[09:32:23.819]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:23.819]                   0L) {
[09:32:23.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:23.819]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:23.819]                   base::options(opts)
[09:32:23.819]                 }
[09:32:23.819]                 {
[09:32:23.819]                   {
[09:32:23.819]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:23.819]                     NULL
[09:32:23.819]                   }
[09:32:23.819]                   options(future.plan = NULL)
[09:32:23.819]                   if (is.na(NA_character_)) 
[09:32:23.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:23.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:23.819]                     .init = FALSE)
[09:32:23.819]                 }
[09:32:23.819]             }
[09:32:23.819]         }
[09:32:23.819]     })
[09:32:23.819]     if (TRUE) {
[09:32:23.819]         base::sink(type = "output", split = FALSE)
[09:32:23.819]         if (TRUE) {
[09:32:23.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:23.819]         }
[09:32:23.819]         else {
[09:32:23.819]             ...future.result["stdout"] <- base::list(NULL)
[09:32:23.819]         }
[09:32:23.819]         base::close(...future.stdout)
[09:32:23.819]         ...future.stdout <- NULL
[09:32:23.819]     }
[09:32:23.819]     ...future.result$conditions <- ...future.conditions
[09:32:23.819]     ...future.result$finished <- base::Sys.time()
[09:32:23.819]     ...future.result
[09:32:23.819] }
[09:32:23.822] MultisessionFuture started
[09:32:23.822] - Launch lazy future ... done
[09:32:23.822] run() for ‘MultisessionFuture’ ... done
[09:32:23.824] receiveMessageFromWorker() for ClusterFuture ...
[09:32:23.824] - Validating connection of MultisessionFuture
[09:32:23.824] - received message: FutureResult
[09:32:23.825] - Received FutureResult
[09:32:23.825] - Erased future from FutureRegistry
[09:32:23.825] result() for ClusterFuture ...
[09:32:23.825] - result already collected: FutureResult
[09:32:23.825] result() for ClusterFuture ... done
[09:32:23.825] signalConditions() ...
[09:32:23.825]  - include = ‘immediateCondition’
[09:32:23.825]  - exclude = 
[09:32:23.825]  - resignal = FALSE
[09:32:23.825]  - Number of conditions: 1
[09:32:23.825] signalConditions() ... done
[09:32:23.826] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:23.826] A MultisessionFuture was resolved (result was not collected)
[09:32:23.826] getGlobalsAndPackages() ...
[09:32:23.826] Searching for globals...
[09:32:23.826] - globals found: [2] ‘list’, ‘stop’
[09:32:23.826] Searching for globals ... DONE
[09:32:23.827] Resolving globals: FALSE
[09:32:23.827] 
[09:32:23.827] 
[09:32:23.827] getGlobalsAndPackages() ... DONE
[09:32:23.827] run() for ‘Future’ ...
[09:32:23.827] - state: ‘created’
[09:32:23.827] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:23.840] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:23.841] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:23.841]   - Field: ‘node’
[09:32:23.841]   - Field: ‘label’
[09:32:23.841]   - Field: ‘local’
[09:32:23.841]   - Field: ‘owner’
[09:32:23.841]   - Field: ‘envir’
[09:32:23.841]   - Field: ‘workers’
[09:32:23.841]   - Field: ‘packages’
[09:32:23.841]   - Field: ‘gc’
[09:32:23.841]   - Field: ‘conditions’
[09:32:23.841]   - Field: ‘persistent’
[09:32:23.842]   - Field: ‘expr’
[09:32:23.842]   - Field: ‘uuid’
[09:32:23.842]   - Field: ‘seed’
[09:32:23.842]   - Field: ‘version’
[09:32:23.842]   - Field: ‘result’
[09:32:23.842]   - Field: ‘asynchronous’
[09:32:23.842]   - Field: ‘calls’
[09:32:23.842]   - Field: ‘globals’
[09:32:23.842]   - Field: ‘stdout’
[09:32:23.842]   - Field: ‘earlySignal’
[09:32:23.842]   - Field: ‘lazy’
[09:32:23.843]   - Field: ‘state’
[09:32:23.843] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:23.843] - Launch lazy future ...
[09:32:23.843] Packages needed by the future expression (n = 0): <none>
[09:32:23.843] Packages needed by future strategies (n = 0): <none>
[09:32:23.843] {
[09:32:23.843]     {
[09:32:23.843]         {
[09:32:23.843]             ...future.startTime <- base::Sys.time()
[09:32:23.843]             {
[09:32:23.843]                 {
[09:32:23.843]                   {
[09:32:23.843]                     {
[09:32:23.843]                       base::local({
[09:32:23.843]                         has_future <- base::requireNamespace("future", 
[09:32:23.843]                           quietly = TRUE)
[09:32:23.843]                         if (has_future) {
[09:32:23.843]                           ns <- base::getNamespace("future")
[09:32:23.843]                           version <- ns[[".package"]][["version"]]
[09:32:23.843]                           if (is.null(version)) 
[09:32:23.843]                             version <- utils::packageVersion("future")
[09:32:23.843]                         }
[09:32:23.843]                         else {
[09:32:23.843]                           version <- NULL
[09:32:23.843]                         }
[09:32:23.843]                         if (!has_future || version < "1.8.0") {
[09:32:23.843]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:23.843]                             "", base::R.version$version.string), 
[09:32:23.843]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:23.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:23.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:23.843]                               "release", "version")], collapse = " "), 
[09:32:23.843]                             hostname = base::Sys.info()[["nodename"]])
[09:32:23.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:23.843]                             info)
[09:32:23.843]                           info <- base::paste(info, collapse = "; ")
[09:32:23.843]                           if (!has_future) {
[09:32:23.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:23.843]                               info)
[09:32:23.843]                           }
[09:32:23.843]                           else {
[09:32:23.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:23.843]                               info, version)
[09:32:23.843]                           }
[09:32:23.843]                           base::stop(msg)
[09:32:23.843]                         }
[09:32:23.843]                       })
[09:32:23.843]                     }
[09:32:23.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:23.843]                     base::options(mc.cores = 1L)
[09:32:23.843]                   }
[09:32:23.843]                   ...future.strategy.old <- future::plan("list")
[09:32:23.843]                   options(future.plan = NULL)
[09:32:23.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:23.843]                 }
[09:32:23.843]                 ...future.workdir <- getwd()
[09:32:23.843]             }
[09:32:23.843]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:23.843]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:23.843]         }
[09:32:23.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:23.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:23.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:23.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:23.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:23.843]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:23.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:23.843]             base::names(...future.oldOptions))
[09:32:23.843]     }
[09:32:23.843]     if (FALSE) {
[09:32:23.843]     }
[09:32:23.843]     else {
[09:32:23.843]         if (TRUE) {
[09:32:23.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:23.843]                 open = "w")
[09:32:23.843]         }
[09:32:23.843]         else {
[09:32:23.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:23.843]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:23.843]         }
[09:32:23.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:23.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:23.843]             base::sink(type = "output", split = FALSE)
[09:32:23.843]             base::close(...future.stdout)
[09:32:23.843]         }, add = TRUE)
[09:32:23.843]     }
[09:32:23.843]     ...future.frame <- base::sys.nframe()
[09:32:23.843]     ...future.conditions <- base::list()
[09:32:23.843]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:23.843]     if (FALSE) {
[09:32:23.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:23.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:23.843]     }
[09:32:23.843]     ...future.result <- base::tryCatch({
[09:32:23.843]         base::withCallingHandlers({
[09:32:23.843]             ...future.value <- base::withVisible(base::local({
[09:32:23.843]                 ...future.makeSendCondition <- base::local({
[09:32:23.843]                   sendCondition <- NULL
[09:32:23.843]                   function(frame = 1L) {
[09:32:23.843]                     if (is.function(sendCondition)) 
[09:32:23.843]                       return(sendCondition)
[09:32:23.843]                     ns <- getNamespace("parallel")
[09:32:23.843]                     if (exists("sendData", mode = "function", 
[09:32:23.843]                       envir = ns)) {
[09:32:23.843]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:23.843]                         envir = ns)
[09:32:23.843]                       envir <- sys.frame(frame)
[09:32:23.843]                       master <- NULL
[09:32:23.843]                       while (!identical(envir, .GlobalEnv) && 
[09:32:23.843]                         !identical(envir, emptyenv())) {
[09:32:23.843]                         if (exists("master", mode = "list", envir = envir, 
[09:32:23.843]                           inherits = FALSE)) {
[09:32:23.843]                           master <- get("master", mode = "list", 
[09:32:23.843]                             envir = envir, inherits = FALSE)
[09:32:23.843]                           if (inherits(master, c("SOCKnode", 
[09:32:23.843]                             "SOCK0node"))) {
[09:32:23.843]                             sendCondition <<- function(cond) {
[09:32:23.843]                               data <- list(type = "VALUE", value = cond, 
[09:32:23.843]                                 success = TRUE)
[09:32:23.843]                               parallel_sendData(master, data)
[09:32:23.843]                             }
[09:32:23.843]                             return(sendCondition)
[09:32:23.843]                           }
[09:32:23.843]                         }
[09:32:23.843]                         frame <- frame + 1L
[09:32:23.843]                         envir <- sys.frame(frame)
[09:32:23.843]                       }
[09:32:23.843]                     }
[09:32:23.843]                     sendCondition <<- function(cond) NULL
[09:32:23.843]                   }
[09:32:23.843]                 })
[09:32:23.843]                 withCallingHandlers({
[09:32:23.843]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:23.843]                 }, immediateCondition = function(cond) {
[09:32:23.843]                   sendCondition <- ...future.makeSendCondition()
[09:32:23.843]                   sendCondition(cond)
[09:32:23.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.843]                   {
[09:32:23.843]                     inherits <- base::inherits
[09:32:23.843]                     invokeRestart <- base::invokeRestart
[09:32:23.843]                     is.null <- base::is.null
[09:32:23.843]                     muffled <- FALSE
[09:32:23.843]                     if (inherits(cond, "message")) {
[09:32:23.843]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:23.843]                       if (muffled) 
[09:32:23.843]                         invokeRestart("muffleMessage")
[09:32:23.843]                     }
[09:32:23.843]                     else if (inherits(cond, "warning")) {
[09:32:23.843]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:23.843]                       if (muffled) 
[09:32:23.843]                         invokeRestart("muffleWarning")
[09:32:23.843]                     }
[09:32:23.843]                     else if (inherits(cond, "condition")) {
[09:32:23.843]                       if (!is.null(pattern)) {
[09:32:23.843]                         computeRestarts <- base::computeRestarts
[09:32:23.843]                         grepl <- base::grepl
[09:32:23.843]                         restarts <- computeRestarts(cond)
[09:32:23.843]                         for (restart in restarts) {
[09:32:23.843]                           name <- restart$name
[09:32:23.843]                           if (is.null(name)) 
[09:32:23.843]                             next
[09:32:23.843]                           if (!grepl(pattern, name)) 
[09:32:23.843]                             next
[09:32:23.843]                           invokeRestart(restart)
[09:32:23.843]                           muffled <- TRUE
[09:32:23.843]                           break
[09:32:23.843]                         }
[09:32:23.843]                       }
[09:32:23.843]                     }
[09:32:23.843]                     invisible(muffled)
[09:32:23.843]                   }
[09:32:23.843]                   muffleCondition(cond)
[09:32:23.843]                 })
[09:32:23.843]             }))
[09:32:23.843]             future::FutureResult(value = ...future.value$value, 
[09:32:23.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.843]                   ...future.rng), globalenv = if (FALSE) 
[09:32:23.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:23.843]                     ...future.globalenv.names))
[09:32:23.843]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:23.843]         }, condition = base::local({
[09:32:23.843]             c <- base::c
[09:32:23.843]             inherits <- base::inherits
[09:32:23.843]             invokeRestart <- base::invokeRestart
[09:32:23.843]             length <- base::length
[09:32:23.843]             list <- base::list
[09:32:23.843]             seq.int <- base::seq.int
[09:32:23.843]             signalCondition <- base::signalCondition
[09:32:23.843]             sys.calls <- base::sys.calls
[09:32:23.843]             `[[` <- base::`[[`
[09:32:23.843]             `+` <- base::`+`
[09:32:23.843]             `<<-` <- base::`<<-`
[09:32:23.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:23.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:23.843]                   3L)]
[09:32:23.843]             }
[09:32:23.843]             function(cond) {
[09:32:23.843]                 is_error <- inherits(cond, "error")
[09:32:23.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:23.843]                   NULL)
[09:32:23.843]                 if (is_error) {
[09:32:23.843]                   sessionInformation <- function() {
[09:32:23.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:23.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:23.843]                       search = base::search(), system = base::Sys.info())
[09:32:23.843]                   }
[09:32:23.843]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:23.843]                     cond$call), session = sessionInformation(), 
[09:32:23.843]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:23.843]                   signalCondition(cond)
[09:32:23.843]                 }
[09:32:23.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:23.843]                 "immediateCondition"))) {
[09:32:23.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:23.843]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:23.843]                   if (TRUE && !signal) {
[09:32:23.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.843]                     {
[09:32:23.843]                       inherits <- base::inherits
[09:32:23.843]                       invokeRestart <- base::invokeRestart
[09:32:23.843]                       is.null <- base::is.null
[09:32:23.843]                       muffled <- FALSE
[09:32:23.843]                       if (inherits(cond, "message")) {
[09:32:23.843]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.843]                         if (muffled) 
[09:32:23.843]                           invokeRestart("muffleMessage")
[09:32:23.843]                       }
[09:32:23.843]                       else if (inherits(cond, "warning")) {
[09:32:23.843]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.843]                         if (muffled) 
[09:32:23.843]                           invokeRestart("muffleWarning")
[09:32:23.843]                       }
[09:32:23.843]                       else if (inherits(cond, "condition")) {
[09:32:23.843]                         if (!is.null(pattern)) {
[09:32:23.843]                           computeRestarts <- base::computeRestarts
[09:32:23.843]                           grepl <- base::grepl
[09:32:23.843]                           restarts <- computeRestarts(cond)
[09:32:23.843]                           for (restart in restarts) {
[09:32:23.843]                             name <- restart$name
[09:32:23.843]                             if (is.null(name)) 
[09:32:23.843]                               next
[09:32:23.843]                             if (!grepl(pattern, name)) 
[09:32:23.843]                               next
[09:32:23.843]                             invokeRestart(restart)
[09:32:23.843]                             muffled <- TRUE
[09:32:23.843]                             break
[09:32:23.843]                           }
[09:32:23.843]                         }
[09:32:23.843]                       }
[09:32:23.843]                       invisible(muffled)
[09:32:23.843]                     }
[09:32:23.843]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.843]                   }
[09:32:23.843]                 }
[09:32:23.843]                 else {
[09:32:23.843]                   if (TRUE) {
[09:32:23.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.843]                     {
[09:32:23.843]                       inherits <- base::inherits
[09:32:23.843]                       invokeRestart <- base::invokeRestart
[09:32:23.843]                       is.null <- base::is.null
[09:32:23.843]                       muffled <- FALSE
[09:32:23.843]                       if (inherits(cond, "message")) {
[09:32:23.843]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.843]                         if (muffled) 
[09:32:23.843]                           invokeRestart("muffleMessage")
[09:32:23.843]                       }
[09:32:23.843]                       else if (inherits(cond, "warning")) {
[09:32:23.843]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.843]                         if (muffled) 
[09:32:23.843]                           invokeRestart("muffleWarning")
[09:32:23.843]                       }
[09:32:23.843]                       else if (inherits(cond, "condition")) {
[09:32:23.843]                         if (!is.null(pattern)) {
[09:32:23.843]                           computeRestarts <- base::computeRestarts
[09:32:23.843]                           grepl <- base::grepl
[09:32:23.843]                           restarts <- computeRestarts(cond)
[09:32:23.843]                           for (restart in restarts) {
[09:32:23.843]                             name <- restart$name
[09:32:23.843]                             if (is.null(name)) 
[09:32:23.843]                               next
[09:32:23.843]                             if (!grepl(pattern, name)) 
[09:32:23.843]                               next
[09:32:23.843]                             invokeRestart(restart)
[09:32:23.843]                             muffled <- TRUE
[09:32:23.843]                             break
[09:32:23.843]                           }
[09:32:23.843]                         }
[09:32:23.843]                       }
[09:32:23.843]                       invisible(muffled)
[09:32:23.843]                     }
[09:32:23.843]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.843]                   }
[09:32:23.843]                 }
[09:32:23.843]             }
[09:32:23.843]         }))
[09:32:23.843]     }, error = function(ex) {
[09:32:23.843]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:23.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.843]                 ...future.rng), started = ...future.startTime, 
[09:32:23.843]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:23.843]             version = "1.8"), class = "FutureResult")
[09:32:23.843]     }, finally = {
[09:32:23.843]         if (!identical(...future.workdir, getwd())) 
[09:32:23.843]             setwd(...future.workdir)
[09:32:23.843]         {
[09:32:23.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:23.843]                 ...future.oldOptions$nwarnings <- NULL
[09:32:23.843]             }
[09:32:23.843]             base::options(...future.oldOptions)
[09:32:23.843]             if (.Platform$OS.type == "windows") {
[09:32:23.843]                 old_names <- names(...future.oldEnvVars)
[09:32:23.843]                 envs <- base::Sys.getenv()
[09:32:23.843]                 names <- names(envs)
[09:32:23.843]                 common <- intersect(names, old_names)
[09:32:23.843]                 added <- setdiff(names, old_names)
[09:32:23.843]                 removed <- setdiff(old_names, names)
[09:32:23.843]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:23.843]                   envs[common]]
[09:32:23.843]                 NAMES <- toupper(changed)
[09:32:23.843]                 args <- list()
[09:32:23.843]                 for (kk in seq_along(NAMES)) {
[09:32:23.843]                   name <- changed[[kk]]
[09:32:23.843]                   NAME <- NAMES[[kk]]
[09:32:23.843]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.843]                     next
[09:32:23.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.843]                 }
[09:32:23.843]                 NAMES <- toupper(added)
[09:32:23.843]                 for (kk in seq_along(NAMES)) {
[09:32:23.843]                   name <- added[[kk]]
[09:32:23.843]                   NAME <- NAMES[[kk]]
[09:32:23.843]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.843]                     next
[09:32:23.843]                   args[[name]] <- ""
[09:32:23.843]                 }
[09:32:23.843]                 NAMES <- toupper(removed)
[09:32:23.843]                 for (kk in seq_along(NAMES)) {
[09:32:23.843]                   name <- removed[[kk]]
[09:32:23.843]                   NAME <- NAMES[[kk]]
[09:32:23.843]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.843]                     next
[09:32:23.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.843]                 }
[09:32:23.843]                 if (length(args) > 0) 
[09:32:23.843]                   base::do.call(base::Sys.setenv, args = args)
[09:32:23.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:23.843]             }
[09:32:23.843]             else {
[09:32:23.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:23.843]             }
[09:32:23.843]             {
[09:32:23.843]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:23.843]                   0L) {
[09:32:23.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:23.843]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:23.843]                   base::options(opts)
[09:32:23.843]                 }
[09:32:23.843]                 {
[09:32:23.843]                   {
[09:32:23.843]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:23.843]                     NULL
[09:32:23.843]                   }
[09:32:23.843]                   options(future.plan = NULL)
[09:32:23.843]                   if (is.na(NA_character_)) 
[09:32:23.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:23.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:23.843]                     .init = FALSE)
[09:32:23.843]                 }
[09:32:23.843]             }
[09:32:23.843]         }
[09:32:23.843]     })
[09:32:23.843]     if (TRUE) {
[09:32:23.843]         base::sink(type = "output", split = FALSE)
[09:32:23.843]         if (TRUE) {
[09:32:23.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:23.843]         }
[09:32:23.843]         else {
[09:32:23.843]             ...future.result["stdout"] <- base::list(NULL)
[09:32:23.843]         }
[09:32:23.843]         base::close(...future.stdout)
[09:32:23.843]         ...future.stdout <- NULL
[09:32:23.843]     }
[09:32:23.843]     ...future.result$conditions <- ...future.conditions
[09:32:23.843]     ...future.result$finished <- base::Sys.time()
[09:32:23.843]     ...future.result
[09:32:23.843] }
[09:32:23.846] MultisessionFuture started
[09:32:23.846] - Launch lazy future ... done
[09:32:23.846] run() for ‘MultisessionFuture’ ... done
[09:32:23.848] receiveMessageFromWorker() for ClusterFuture ...
[09:32:23.848] - Validating connection of MultisessionFuture
[09:32:23.848] - received message: FutureResult
[09:32:23.848] - Received FutureResult
[09:32:23.848] - Erased future from FutureRegistry
[09:32:23.848] result() for ClusterFuture ...
[09:32:23.849] - result already collected: FutureResult
[09:32:23.849] result() for ClusterFuture ... done
[09:32:23.849] signalConditions() ...
[09:32:23.849]  - include = ‘immediateCondition’
[09:32:23.849]  - exclude = 
[09:32:23.849]  - resignal = FALSE
[09:32:23.849]  - Number of conditions: 1
[09:32:23.849] signalConditions() ... done
[09:32:23.849] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:23.849] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[09:32:23.849] getGlobalsAndPackages() ...
[09:32:23.850] Searching for globals...
[09:32:23.851] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:23.851] Searching for globals ... DONE
[09:32:23.851] Resolving globals: FALSE
[09:32:23.851] 
[09:32:23.851] 
[09:32:23.851] getGlobalsAndPackages() ... DONE
[09:32:23.851] run() for ‘Future’ ...
[09:32:23.852] - state: ‘created’
[09:32:23.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:23.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:23.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:23.866]   - Field: ‘node’
[09:32:23.866]   - Field: ‘label’
[09:32:23.866]   - Field: ‘local’
[09:32:23.867]   - Field: ‘owner’
[09:32:23.867]   - Field: ‘envir’
[09:32:23.867]   - Field: ‘workers’
[09:32:23.867]   - Field: ‘packages’
[09:32:23.867]   - Field: ‘gc’
[09:32:23.867]   - Field: ‘conditions’
[09:32:23.867]   - Field: ‘persistent’
[09:32:23.867]   - Field: ‘expr’
[09:32:23.867]   - Field: ‘uuid’
[09:32:23.867]   - Field: ‘seed’
[09:32:23.867]   - Field: ‘version’
[09:32:23.868]   - Field: ‘result’
[09:32:23.868]   - Field: ‘asynchronous’
[09:32:23.868]   - Field: ‘calls’
[09:32:23.868]   - Field: ‘globals’
[09:32:23.868]   - Field: ‘stdout’
[09:32:23.868]   - Field: ‘earlySignal’
[09:32:23.868]   - Field: ‘lazy’
[09:32:23.868]   - Field: ‘state’
[09:32:23.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:23.868] - Launch lazy future ...
[09:32:23.869] Packages needed by the future expression (n = 0): <none>
[09:32:23.869] Packages needed by future strategies (n = 0): <none>
[09:32:23.869] {
[09:32:23.869]     {
[09:32:23.869]         {
[09:32:23.869]             ...future.startTime <- base::Sys.time()
[09:32:23.869]             {
[09:32:23.869]                 {
[09:32:23.869]                   {
[09:32:23.869]                     {
[09:32:23.869]                       base::local({
[09:32:23.869]                         has_future <- base::requireNamespace("future", 
[09:32:23.869]                           quietly = TRUE)
[09:32:23.869]                         if (has_future) {
[09:32:23.869]                           ns <- base::getNamespace("future")
[09:32:23.869]                           version <- ns[[".package"]][["version"]]
[09:32:23.869]                           if (is.null(version)) 
[09:32:23.869]                             version <- utils::packageVersion("future")
[09:32:23.869]                         }
[09:32:23.869]                         else {
[09:32:23.869]                           version <- NULL
[09:32:23.869]                         }
[09:32:23.869]                         if (!has_future || version < "1.8.0") {
[09:32:23.869]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:23.869]                             "", base::R.version$version.string), 
[09:32:23.869]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:23.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:23.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:23.869]                               "release", "version")], collapse = " "), 
[09:32:23.869]                             hostname = base::Sys.info()[["nodename"]])
[09:32:23.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:23.869]                             info)
[09:32:23.869]                           info <- base::paste(info, collapse = "; ")
[09:32:23.869]                           if (!has_future) {
[09:32:23.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:23.869]                               info)
[09:32:23.869]                           }
[09:32:23.869]                           else {
[09:32:23.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:23.869]                               info, version)
[09:32:23.869]                           }
[09:32:23.869]                           base::stop(msg)
[09:32:23.869]                         }
[09:32:23.869]                       })
[09:32:23.869]                     }
[09:32:23.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:23.869]                     base::options(mc.cores = 1L)
[09:32:23.869]                   }
[09:32:23.869]                   ...future.strategy.old <- future::plan("list")
[09:32:23.869]                   options(future.plan = NULL)
[09:32:23.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:23.869]                 }
[09:32:23.869]                 ...future.workdir <- getwd()
[09:32:23.869]             }
[09:32:23.869]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:23.869]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:23.869]         }
[09:32:23.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:23.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:23.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:23.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:23.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:23.869]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:23.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:23.869]             base::names(...future.oldOptions))
[09:32:23.869]     }
[09:32:23.869]     if (FALSE) {
[09:32:23.869]     }
[09:32:23.869]     else {
[09:32:23.869]         if (TRUE) {
[09:32:23.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:23.869]                 open = "w")
[09:32:23.869]         }
[09:32:23.869]         else {
[09:32:23.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:23.869]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:23.869]         }
[09:32:23.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:23.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:23.869]             base::sink(type = "output", split = FALSE)
[09:32:23.869]             base::close(...future.stdout)
[09:32:23.869]         }, add = TRUE)
[09:32:23.869]     }
[09:32:23.869]     ...future.frame <- base::sys.nframe()
[09:32:23.869]     ...future.conditions <- base::list()
[09:32:23.869]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:23.869]     if (FALSE) {
[09:32:23.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:23.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:23.869]     }
[09:32:23.869]     ...future.result <- base::tryCatch({
[09:32:23.869]         base::withCallingHandlers({
[09:32:23.869]             ...future.value <- base::withVisible(base::local({
[09:32:23.869]                 ...future.makeSendCondition <- base::local({
[09:32:23.869]                   sendCondition <- NULL
[09:32:23.869]                   function(frame = 1L) {
[09:32:23.869]                     if (is.function(sendCondition)) 
[09:32:23.869]                       return(sendCondition)
[09:32:23.869]                     ns <- getNamespace("parallel")
[09:32:23.869]                     if (exists("sendData", mode = "function", 
[09:32:23.869]                       envir = ns)) {
[09:32:23.869]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:23.869]                         envir = ns)
[09:32:23.869]                       envir <- sys.frame(frame)
[09:32:23.869]                       master <- NULL
[09:32:23.869]                       while (!identical(envir, .GlobalEnv) && 
[09:32:23.869]                         !identical(envir, emptyenv())) {
[09:32:23.869]                         if (exists("master", mode = "list", envir = envir, 
[09:32:23.869]                           inherits = FALSE)) {
[09:32:23.869]                           master <- get("master", mode = "list", 
[09:32:23.869]                             envir = envir, inherits = FALSE)
[09:32:23.869]                           if (inherits(master, c("SOCKnode", 
[09:32:23.869]                             "SOCK0node"))) {
[09:32:23.869]                             sendCondition <<- function(cond) {
[09:32:23.869]                               data <- list(type = "VALUE", value = cond, 
[09:32:23.869]                                 success = TRUE)
[09:32:23.869]                               parallel_sendData(master, data)
[09:32:23.869]                             }
[09:32:23.869]                             return(sendCondition)
[09:32:23.869]                           }
[09:32:23.869]                         }
[09:32:23.869]                         frame <- frame + 1L
[09:32:23.869]                         envir <- sys.frame(frame)
[09:32:23.869]                       }
[09:32:23.869]                     }
[09:32:23.869]                     sendCondition <<- function(cond) NULL
[09:32:23.869]                   }
[09:32:23.869]                 })
[09:32:23.869]                 withCallingHandlers({
[09:32:23.869]                   {
[09:32:23.869]                     Sys.sleep(0.5)
[09:32:23.869]                     list(a = 1, b = 42L)
[09:32:23.869]                   }
[09:32:23.869]                 }, immediateCondition = function(cond) {
[09:32:23.869]                   sendCondition <- ...future.makeSendCondition()
[09:32:23.869]                   sendCondition(cond)
[09:32:23.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.869]                   {
[09:32:23.869]                     inherits <- base::inherits
[09:32:23.869]                     invokeRestart <- base::invokeRestart
[09:32:23.869]                     is.null <- base::is.null
[09:32:23.869]                     muffled <- FALSE
[09:32:23.869]                     if (inherits(cond, "message")) {
[09:32:23.869]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:23.869]                       if (muffled) 
[09:32:23.869]                         invokeRestart("muffleMessage")
[09:32:23.869]                     }
[09:32:23.869]                     else if (inherits(cond, "warning")) {
[09:32:23.869]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:23.869]                       if (muffled) 
[09:32:23.869]                         invokeRestart("muffleWarning")
[09:32:23.869]                     }
[09:32:23.869]                     else if (inherits(cond, "condition")) {
[09:32:23.869]                       if (!is.null(pattern)) {
[09:32:23.869]                         computeRestarts <- base::computeRestarts
[09:32:23.869]                         grepl <- base::grepl
[09:32:23.869]                         restarts <- computeRestarts(cond)
[09:32:23.869]                         for (restart in restarts) {
[09:32:23.869]                           name <- restart$name
[09:32:23.869]                           if (is.null(name)) 
[09:32:23.869]                             next
[09:32:23.869]                           if (!grepl(pattern, name)) 
[09:32:23.869]                             next
[09:32:23.869]                           invokeRestart(restart)
[09:32:23.869]                           muffled <- TRUE
[09:32:23.869]                           break
[09:32:23.869]                         }
[09:32:23.869]                       }
[09:32:23.869]                     }
[09:32:23.869]                     invisible(muffled)
[09:32:23.869]                   }
[09:32:23.869]                   muffleCondition(cond)
[09:32:23.869]                 })
[09:32:23.869]             }))
[09:32:23.869]             future::FutureResult(value = ...future.value$value, 
[09:32:23.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.869]                   ...future.rng), globalenv = if (FALSE) 
[09:32:23.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:23.869]                     ...future.globalenv.names))
[09:32:23.869]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:23.869]         }, condition = base::local({
[09:32:23.869]             c <- base::c
[09:32:23.869]             inherits <- base::inherits
[09:32:23.869]             invokeRestart <- base::invokeRestart
[09:32:23.869]             length <- base::length
[09:32:23.869]             list <- base::list
[09:32:23.869]             seq.int <- base::seq.int
[09:32:23.869]             signalCondition <- base::signalCondition
[09:32:23.869]             sys.calls <- base::sys.calls
[09:32:23.869]             `[[` <- base::`[[`
[09:32:23.869]             `+` <- base::`+`
[09:32:23.869]             `<<-` <- base::`<<-`
[09:32:23.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:23.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:23.869]                   3L)]
[09:32:23.869]             }
[09:32:23.869]             function(cond) {
[09:32:23.869]                 is_error <- inherits(cond, "error")
[09:32:23.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:23.869]                   NULL)
[09:32:23.869]                 if (is_error) {
[09:32:23.869]                   sessionInformation <- function() {
[09:32:23.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:23.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:23.869]                       search = base::search(), system = base::Sys.info())
[09:32:23.869]                   }
[09:32:23.869]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:23.869]                     cond$call), session = sessionInformation(), 
[09:32:23.869]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:23.869]                   signalCondition(cond)
[09:32:23.869]                 }
[09:32:23.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:23.869]                 "immediateCondition"))) {
[09:32:23.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:23.869]                   ...future.conditions[[length(...future.conditions) + 
[09:32:23.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:23.869]                   if (TRUE && !signal) {
[09:32:23.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.869]                     {
[09:32:23.869]                       inherits <- base::inherits
[09:32:23.869]                       invokeRestart <- base::invokeRestart
[09:32:23.869]                       is.null <- base::is.null
[09:32:23.869]                       muffled <- FALSE
[09:32:23.869]                       if (inherits(cond, "message")) {
[09:32:23.869]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.869]                         if (muffled) 
[09:32:23.869]                           invokeRestart("muffleMessage")
[09:32:23.869]                       }
[09:32:23.869]                       else if (inherits(cond, "warning")) {
[09:32:23.869]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.869]                         if (muffled) 
[09:32:23.869]                           invokeRestart("muffleWarning")
[09:32:23.869]                       }
[09:32:23.869]                       else if (inherits(cond, "condition")) {
[09:32:23.869]                         if (!is.null(pattern)) {
[09:32:23.869]                           computeRestarts <- base::computeRestarts
[09:32:23.869]                           grepl <- base::grepl
[09:32:23.869]                           restarts <- computeRestarts(cond)
[09:32:23.869]                           for (restart in restarts) {
[09:32:23.869]                             name <- restart$name
[09:32:23.869]                             if (is.null(name)) 
[09:32:23.869]                               next
[09:32:23.869]                             if (!grepl(pattern, name)) 
[09:32:23.869]                               next
[09:32:23.869]                             invokeRestart(restart)
[09:32:23.869]                             muffled <- TRUE
[09:32:23.869]                             break
[09:32:23.869]                           }
[09:32:23.869]                         }
[09:32:23.869]                       }
[09:32:23.869]                       invisible(muffled)
[09:32:23.869]                     }
[09:32:23.869]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.869]                   }
[09:32:23.869]                 }
[09:32:23.869]                 else {
[09:32:23.869]                   if (TRUE) {
[09:32:23.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:23.869]                     {
[09:32:23.869]                       inherits <- base::inherits
[09:32:23.869]                       invokeRestart <- base::invokeRestart
[09:32:23.869]                       is.null <- base::is.null
[09:32:23.869]                       muffled <- FALSE
[09:32:23.869]                       if (inherits(cond, "message")) {
[09:32:23.869]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:23.869]                         if (muffled) 
[09:32:23.869]                           invokeRestart("muffleMessage")
[09:32:23.869]                       }
[09:32:23.869]                       else if (inherits(cond, "warning")) {
[09:32:23.869]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:23.869]                         if (muffled) 
[09:32:23.869]                           invokeRestart("muffleWarning")
[09:32:23.869]                       }
[09:32:23.869]                       else if (inherits(cond, "condition")) {
[09:32:23.869]                         if (!is.null(pattern)) {
[09:32:23.869]                           computeRestarts <- base::computeRestarts
[09:32:23.869]                           grepl <- base::grepl
[09:32:23.869]                           restarts <- computeRestarts(cond)
[09:32:23.869]                           for (restart in restarts) {
[09:32:23.869]                             name <- restart$name
[09:32:23.869]                             if (is.null(name)) 
[09:32:23.869]                               next
[09:32:23.869]                             if (!grepl(pattern, name)) 
[09:32:23.869]                               next
[09:32:23.869]                             invokeRestart(restart)
[09:32:23.869]                             muffled <- TRUE
[09:32:23.869]                             break
[09:32:23.869]                           }
[09:32:23.869]                         }
[09:32:23.869]                       }
[09:32:23.869]                       invisible(muffled)
[09:32:23.869]                     }
[09:32:23.869]                     muffleCondition(cond, pattern = "^muffle")
[09:32:23.869]                   }
[09:32:23.869]                 }
[09:32:23.869]             }
[09:32:23.869]         }))
[09:32:23.869]     }, error = function(ex) {
[09:32:23.869]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:23.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:23.869]                 ...future.rng), started = ...future.startTime, 
[09:32:23.869]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:23.869]             version = "1.8"), class = "FutureResult")
[09:32:23.869]     }, finally = {
[09:32:23.869]         if (!identical(...future.workdir, getwd())) 
[09:32:23.869]             setwd(...future.workdir)
[09:32:23.869]         {
[09:32:23.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:23.869]                 ...future.oldOptions$nwarnings <- NULL
[09:32:23.869]             }
[09:32:23.869]             base::options(...future.oldOptions)
[09:32:23.869]             if (.Platform$OS.type == "windows") {
[09:32:23.869]                 old_names <- names(...future.oldEnvVars)
[09:32:23.869]                 envs <- base::Sys.getenv()
[09:32:23.869]                 names <- names(envs)
[09:32:23.869]                 common <- intersect(names, old_names)
[09:32:23.869]                 added <- setdiff(names, old_names)
[09:32:23.869]                 removed <- setdiff(old_names, names)
[09:32:23.869]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:23.869]                   envs[common]]
[09:32:23.869]                 NAMES <- toupper(changed)
[09:32:23.869]                 args <- list()
[09:32:23.869]                 for (kk in seq_along(NAMES)) {
[09:32:23.869]                   name <- changed[[kk]]
[09:32:23.869]                   NAME <- NAMES[[kk]]
[09:32:23.869]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.869]                     next
[09:32:23.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.869]                 }
[09:32:23.869]                 NAMES <- toupper(added)
[09:32:23.869]                 for (kk in seq_along(NAMES)) {
[09:32:23.869]                   name <- added[[kk]]
[09:32:23.869]                   NAME <- NAMES[[kk]]
[09:32:23.869]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.869]                     next
[09:32:23.869]                   args[[name]] <- ""
[09:32:23.869]                 }
[09:32:23.869]                 NAMES <- toupper(removed)
[09:32:23.869]                 for (kk in seq_along(NAMES)) {
[09:32:23.869]                   name <- removed[[kk]]
[09:32:23.869]                   NAME <- NAMES[[kk]]
[09:32:23.869]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:23.869]                     next
[09:32:23.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:23.869]                 }
[09:32:23.869]                 if (length(args) > 0) 
[09:32:23.869]                   base::do.call(base::Sys.setenv, args = args)
[09:32:23.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:23.869]             }
[09:32:23.869]             else {
[09:32:23.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:23.869]             }
[09:32:23.869]             {
[09:32:23.869]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:23.869]                   0L) {
[09:32:23.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:23.869]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:23.869]                   base::options(opts)
[09:32:23.869]                 }
[09:32:23.869]                 {
[09:32:23.869]                   {
[09:32:23.869]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:23.869]                     NULL
[09:32:23.869]                   }
[09:32:23.869]                   options(future.plan = NULL)
[09:32:23.869]                   if (is.na(NA_character_)) 
[09:32:23.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:23.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:23.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:23.869]                     .init = FALSE)
[09:32:23.869]                 }
[09:32:23.869]             }
[09:32:23.869]         }
[09:32:23.869]     })
[09:32:23.869]     if (TRUE) {
[09:32:23.869]         base::sink(type = "output", split = FALSE)
[09:32:23.869]         if (TRUE) {
[09:32:23.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:23.869]         }
[09:32:23.869]         else {
[09:32:23.869]             ...future.result["stdout"] <- base::list(NULL)
[09:32:23.869]         }
[09:32:23.869]         base::close(...future.stdout)
[09:32:23.869]         ...future.stdout <- NULL
[09:32:23.869]     }
[09:32:23.869]     ...future.result$conditions <- ...future.conditions
[09:32:23.869]     ...future.result$finished <- base::Sys.time()
[09:32:23.869]     ...future.result
[09:32:23.869] }
[09:32:23.872] MultisessionFuture started
[09:32:23.872] - Launch lazy future ... done
[09:32:23.872] run() for ‘MultisessionFuture’ ... done
[09:32:24.374] receiveMessageFromWorker() for ClusterFuture ...
[09:32:24.374] - Validating connection of MultisessionFuture
[09:32:24.375] - received message: FutureResult
[09:32:24.375] - Received FutureResult
[09:32:24.375] - Erased future from FutureRegistry
[09:32:24.375] result() for ClusterFuture ...
[09:32:24.375] - result already collected: FutureResult
[09:32:24.375] result() for ClusterFuture ... done
[09:32:24.375] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:24.375] A MultisessionFuture was resolved (result was not collected)
[09:32:24.376] getGlobalsAndPackages() ...
[09:32:24.376] Searching for globals...
[09:32:24.377] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:24.377] Searching for globals ... DONE
[09:32:24.377] Resolving globals: FALSE
[09:32:24.377] 
[09:32:24.377] 
[09:32:24.377] getGlobalsAndPackages() ... DONE
[09:32:24.378] run() for ‘Future’ ...
[09:32:24.378] - state: ‘created’
[09:32:24.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:24.392] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:24.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:24.392]   - Field: ‘node’
[09:32:24.392]   - Field: ‘label’
[09:32:24.392]   - Field: ‘local’
[09:32:24.392]   - Field: ‘owner’
[09:32:24.392]   - Field: ‘envir’
[09:32:24.392]   - Field: ‘workers’
[09:32:24.393]   - Field: ‘packages’
[09:32:24.393]   - Field: ‘gc’
[09:32:24.393]   - Field: ‘conditions’
[09:32:24.393]   - Field: ‘persistent’
[09:32:24.393]   - Field: ‘expr’
[09:32:24.393]   - Field: ‘uuid’
[09:32:24.393]   - Field: ‘seed’
[09:32:24.393]   - Field: ‘version’
[09:32:24.393]   - Field: ‘result’
[09:32:24.393]   - Field: ‘asynchronous’
[09:32:24.393]   - Field: ‘calls’
[09:32:24.394]   - Field: ‘globals’
[09:32:24.394]   - Field: ‘stdout’
[09:32:24.394]   - Field: ‘earlySignal’
[09:32:24.394]   - Field: ‘lazy’
[09:32:24.394]   - Field: ‘state’
[09:32:24.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:24.394] - Launch lazy future ...
[09:32:24.394] Packages needed by the future expression (n = 0): <none>
[09:32:24.394] Packages needed by future strategies (n = 0): <none>
[09:32:24.395] {
[09:32:24.395]     {
[09:32:24.395]         {
[09:32:24.395]             ...future.startTime <- base::Sys.time()
[09:32:24.395]             {
[09:32:24.395]                 {
[09:32:24.395]                   {
[09:32:24.395]                     {
[09:32:24.395]                       base::local({
[09:32:24.395]                         has_future <- base::requireNamespace("future", 
[09:32:24.395]                           quietly = TRUE)
[09:32:24.395]                         if (has_future) {
[09:32:24.395]                           ns <- base::getNamespace("future")
[09:32:24.395]                           version <- ns[[".package"]][["version"]]
[09:32:24.395]                           if (is.null(version)) 
[09:32:24.395]                             version <- utils::packageVersion("future")
[09:32:24.395]                         }
[09:32:24.395]                         else {
[09:32:24.395]                           version <- NULL
[09:32:24.395]                         }
[09:32:24.395]                         if (!has_future || version < "1.8.0") {
[09:32:24.395]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:24.395]                             "", base::R.version$version.string), 
[09:32:24.395]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:24.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:24.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:24.395]                               "release", "version")], collapse = " "), 
[09:32:24.395]                             hostname = base::Sys.info()[["nodename"]])
[09:32:24.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:24.395]                             info)
[09:32:24.395]                           info <- base::paste(info, collapse = "; ")
[09:32:24.395]                           if (!has_future) {
[09:32:24.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:24.395]                               info)
[09:32:24.395]                           }
[09:32:24.395]                           else {
[09:32:24.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:24.395]                               info, version)
[09:32:24.395]                           }
[09:32:24.395]                           base::stop(msg)
[09:32:24.395]                         }
[09:32:24.395]                       })
[09:32:24.395]                     }
[09:32:24.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:24.395]                     base::options(mc.cores = 1L)
[09:32:24.395]                   }
[09:32:24.395]                   ...future.strategy.old <- future::plan("list")
[09:32:24.395]                   options(future.plan = NULL)
[09:32:24.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:24.395]                 }
[09:32:24.395]                 ...future.workdir <- getwd()
[09:32:24.395]             }
[09:32:24.395]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:24.395]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:24.395]         }
[09:32:24.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:24.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:24.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:24.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:24.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:24.395]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:24.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:24.395]             base::names(...future.oldOptions))
[09:32:24.395]     }
[09:32:24.395]     if (FALSE) {
[09:32:24.395]     }
[09:32:24.395]     else {
[09:32:24.395]         if (TRUE) {
[09:32:24.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:24.395]                 open = "w")
[09:32:24.395]         }
[09:32:24.395]         else {
[09:32:24.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:24.395]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:24.395]         }
[09:32:24.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:24.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:24.395]             base::sink(type = "output", split = FALSE)
[09:32:24.395]             base::close(...future.stdout)
[09:32:24.395]         }, add = TRUE)
[09:32:24.395]     }
[09:32:24.395]     ...future.frame <- base::sys.nframe()
[09:32:24.395]     ...future.conditions <- base::list()
[09:32:24.395]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:24.395]     if (FALSE) {
[09:32:24.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:24.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:24.395]     }
[09:32:24.395]     ...future.result <- base::tryCatch({
[09:32:24.395]         base::withCallingHandlers({
[09:32:24.395]             ...future.value <- base::withVisible(base::local({
[09:32:24.395]                 ...future.makeSendCondition <- base::local({
[09:32:24.395]                   sendCondition <- NULL
[09:32:24.395]                   function(frame = 1L) {
[09:32:24.395]                     if (is.function(sendCondition)) 
[09:32:24.395]                       return(sendCondition)
[09:32:24.395]                     ns <- getNamespace("parallel")
[09:32:24.395]                     if (exists("sendData", mode = "function", 
[09:32:24.395]                       envir = ns)) {
[09:32:24.395]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:24.395]                         envir = ns)
[09:32:24.395]                       envir <- sys.frame(frame)
[09:32:24.395]                       master <- NULL
[09:32:24.395]                       while (!identical(envir, .GlobalEnv) && 
[09:32:24.395]                         !identical(envir, emptyenv())) {
[09:32:24.395]                         if (exists("master", mode = "list", envir = envir, 
[09:32:24.395]                           inherits = FALSE)) {
[09:32:24.395]                           master <- get("master", mode = "list", 
[09:32:24.395]                             envir = envir, inherits = FALSE)
[09:32:24.395]                           if (inherits(master, c("SOCKnode", 
[09:32:24.395]                             "SOCK0node"))) {
[09:32:24.395]                             sendCondition <<- function(cond) {
[09:32:24.395]                               data <- list(type = "VALUE", value = cond, 
[09:32:24.395]                                 success = TRUE)
[09:32:24.395]                               parallel_sendData(master, data)
[09:32:24.395]                             }
[09:32:24.395]                             return(sendCondition)
[09:32:24.395]                           }
[09:32:24.395]                         }
[09:32:24.395]                         frame <- frame + 1L
[09:32:24.395]                         envir <- sys.frame(frame)
[09:32:24.395]                       }
[09:32:24.395]                     }
[09:32:24.395]                     sendCondition <<- function(cond) NULL
[09:32:24.395]                   }
[09:32:24.395]                 })
[09:32:24.395]                 withCallingHandlers({
[09:32:24.395]                   {
[09:32:24.395]                     Sys.sleep(0.5)
[09:32:24.395]                     list(a = 1, b = 42L)
[09:32:24.395]                   }
[09:32:24.395]                 }, immediateCondition = function(cond) {
[09:32:24.395]                   sendCondition <- ...future.makeSendCondition()
[09:32:24.395]                   sendCondition(cond)
[09:32:24.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.395]                   {
[09:32:24.395]                     inherits <- base::inherits
[09:32:24.395]                     invokeRestart <- base::invokeRestart
[09:32:24.395]                     is.null <- base::is.null
[09:32:24.395]                     muffled <- FALSE
[09:32:24.395]                     if (inherits(cond, "message")) {
[09:32:24.395]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:24.395]                       if (muffled) 
[09:32:24.395]                         invokeRestart("muffleMessage")
[09:32:24.395]                     }
[09:32:24.395]                     else if (inherits(cond, "warning")) {
[09:32:24.395]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:24.395]                       if (muffled) 
[09:32:24.395]                         invokeRestart("muffleWarning")
[09:32:24.395]                     }
[09:32:24.395]                     else if (inherits(cond, "condition")) {
[09:32:24.395]                       if (!is.null(pattern)) {
[09:32:24.395]                         computeRestarts <- base::computeRestarts
[09:32:24.395]                         grepl <- base::grepl
[09:32:24.395]                         restarts <- computeRestarts(cond)
[09:32:24.395]                         for (restart in restarts) {
[09:32:24.395]                           name <- restart$name
[09:32:24.395]                           if (is.null(name)) 
[09:32:24.395]                             next
[09:32:24.395]                           if (!grepl(pattern, name)) 
[09:32:24.395]                             next
[09:32:24.395]                           invokeRestart(restart)
[09:32:24.395]                           muffled <- TRUE
[09:32:24.395]                           break
[09:32:24.395]                         }
[09:32:24.395]                       }
[09:32:24.395]                     }
[09:32:24.395]                     invisible(muffled)
[09:32:24.395]                   }
[09:32:24.395]                   muffleCondition(cond)
[09:32:24.395]                 })
[09:32:24.395]             }))
[09:32:24.395]             future::FutureResult(value = ...future.value$value, 
[09:32:24.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.395]                   ...future.rng), globalenv = if (FALSE) 
[09:32:24.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:24.395]                     ...future.globalenv.names))
[09:32:24.395]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:24.395]         }, condition = base::local({
[09:32:24.395]             c <- base::c
[09:32:24.395]             inherits <- base::inherits
[09:32:24.395]             invokeRestart <- base::invokeRestart
[09:32:24.395]             length <- base::length
[09:32:24.395]             list <- base::list
[09:32:24.395]             seq.int <- base::seq.int
[09:32:24.395]             signalCondition <- base::signalCondition
[09:32:24.395]             sys.calls <- base::sys.calls
[09:32:24.395]             `[[` <- base::`[[`
[09:32:24.395]             `+` <- base::`+`
[09:32:24.395]             `<<-` <- base::`<<-`
[09:32:24.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:24.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:24.395]                   3L)]
[09:32:24.395]             }
[09:32:24.395]             function(cond) {
[09:32:24.395]                 is_error <- inherits(cond, "error")
[09:32:24.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:24.395]                   NULL)
[09:32:24.395]                 if (is_error) {
[09:32:24.395]                   sessionInformation <- function() {
[09:32:24.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:24.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:24.395]                       search = base::search(), system = base::Sys.info())
[09:32:24.395]                   }
[09:32:24.395]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:24.395]                     cond$call), session = sessionInformation(), 
[09:32:24.395]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:24.395]                   signalCondition(cond)
[09:32:24.395]                 }
[09:32:24.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:24.395]                 "immediateCondition"))) {
[09:32:24.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:24.395]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:24.395]                   if (TRUE && !signal) {
[09:32:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.395]                     {
[09:32:24.395]                       inherits <- base::inherits
[09:32:24.395]                       invokeRestart <- base::invokeRestart
[09:32:24.395]                       is.null <- base::is.null
[09:32:24.395]                       muffled <- FALSE
[09:32:24.395]                       if (inherits(cond, "message")) {
[09:32:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.395]                         if (muffled) 
[09:32:24.395]                           invokeRestart("muffleMessage")
[09:32:24.395]                       }
[09:32:24.395]                       else if (inherits(cond, "warning")) {
[09:32:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.395]                         if (muffled) 
[09:32:24.395]                           invokeRestart("muffleWarning")
[09:32:24.395]                       }
[09:32:24.395]                       else if (inherits(cond, "condition")) {
[09:32:24.395]                         if (!is.null(pattern)) {
[09:32:24.395]                           computeRestarts <- base::computeRestarts
[09:32:24.395]                           grepl <- base::grepl
[09:32:24.395]                           restarts <- computeRestarts(cond)
[09:32:24.395]                           for (restart in restarts) {
[09:32:24.395]                             name <- restart$name
[09:32:24.395]                             if (is.null(name)) 
[09:32:24.395]                               next
[09:32:24.395]                             if (!grepl(pattern, name)) 
[09:32:24.395]                               next
[09:32:24.395]                             invokeRestart(restart)
[09:32:24.395]                             muffled <- TRUE
[09:32:24.395]                             break
[09:32:24.395]                           }
[09:32:24.395]                         }
[09:32:24.395]                       }
[09:32:24.395]                       invisible(muffled)
[09:32:24.395]                     }
[09:32:24.395]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.395]                   }
[09:32:24.395]                 }
[09:32:24.395]                 else {
[09:32:24.395]                   if (TRUE) {
[09:32:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.395]                     {
[09:32:24.395]                       inherits <- base::inherits
[09:32:24.395]                       invokeRestart <- base::invokeRestart
[09:32:24.395]                       is.null <- base::is.null
[09:32:24.395]                       muffled <- FALSE
[09:32:24.395]                       if (inherits(cond, "message")) {
[09:32:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.395]                         if (muffled) 
[09:32:24.395]                           invokeRestart("muffleMessage")
[09:32:24.395]                       }
[09:32:24.395]                       else if (inherits(cond, "warning")) {
[09:32:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.395]                         if (muffled) 
[09:32:24.395]                           invokeRestart("muffleWarning")
[09:32:24.395]                       }
[09:32:24.395]                       else if (inherits(cond, "condition")) {
[09:32:24.395]                         if (!is.null(pattern)) {
[09:32:24.395]                           computeRestarts <- base::computeRestarts
[09:32:24.395]                           grepl <- base::grepl
[09:32:24.395]                           restarts <- computeRestarts(cond)
[09:32:24.395]                           for (restart in restarts) {
[09:32:24.395]                             name <- restart$name
[09:32:24.395]                             if (is.null(name)) 
[09:32:24.395]                               next
[09:32:24.395]                             if (!grepl(pattern, name)) 
[09:32:24.395]                               next
[09:32:24.395]                             invokeRestart(restart)
[09:32:24.395]                             muffled <- TRUE
[09:32:24.395]                             break
[09:32:24.395]                           }
[09:32:24.395]                         }
[09:32:24.395]                       }
[09:32:24.395]                       invisible(muffled)
[09:32:24.395]                     }
[09:32:24.395]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.395]                   }
[09:32:24.395]                 }
[09:32:24.395]             }
[09:32:24.395]         }))
[09:32:24.395]     }, error = function(ex) {
[09:32:24.395]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:24.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.395]                 ...future.rng), started = ...future.startTime, 
[09:32:24.395]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:24.395]             version = "1.8"), class = "FutureResult")
[09:32:24.395]     }, finally = {
[09:32:24.395]         if (!identical(...future.workdir, getwd())) 
[09:32:24.395]             setwd(...future.workdir)
[09:32:24.395]         {
[09:32:24.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:24.395]                 ...future.oldOptions$nwarnings <- NULL
[09:32:24.395]             }
[09:32:24.395]             base::options(...future.oldOptions)
[09:32:24.395]             if (.Platform$OS.type == "windows") {
[09:32:24.395]                 old_names <- names(...future.oldEnvVars)
[09:32:24.395]                 envs <- base::Sys.getenv()
[09:32:24.395]                 names <- names(envs)
[09:32:24.395]                 common <- intersect(names, old_names)
[09:32:24.395]                 added <- setdiff(names, old_names)
[09:32:24.395]                 removed <- setdiff(old_names, names)
[09:32:24.395]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:24.395]                   envs[common]]
[09:32:24.395]                 NAMES <- toupper(changed)
[09:32:24.395]                 args <- list()
[09:32:24.395]                 for (kk in seq_along(NAMES)) {
[09:32:24.395]                   name <- changed[[kk]]
[09:32:24.395]                   NAME <- NAMES[[kk]]
[09:32:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.395]                     next
[09:32:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.395]                 }
[09:32:24.395]                 NAMES <- toupper(added)
[09:32:24.395]                 for (kk in seq_along(NAMES)) {
[09:32:24.395]                   name <- added[[kk]]
[09:32:24.395]                   NAME <- NAMES[[kk]]
[09:32:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.395]                     next
[09:32:24.395]                   args[[name]] <- ""
[09:32:24.395]                 }
[09:32:24.395]                 NAMES <- toupper(removed)
[09:32:24.395]                 for (kk in seq_along(NAMES)) {
[09:32:24.395]                   name <- removed[[kk]]
[09:32:24.395]                   NAME <- NAMES[[kk]]
[09:32:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.395]                     next
[09:32:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.395]                 }
[09:32:24.395]                 if (length(args) > 0) 
[09:32:24.395]                   base::do.call(base::Sys.setenv, args = args)
[09:32:24.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:24.395]             }
[09:32:24.395]             else {
[09:32:24.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:24.395]             }
[09:32:24.395]             {
[09:32:24.395]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:24.395]                   0L) {
[09:32:24.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:24.395]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:24.395]                   base::options(opts)
[09:32:24.395]                 }
[09:32:24.395]                 {
[09:32:24.395]                   {
[09:32:24.395]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:24.395]                     NULL
[09:32:24.395]                   }
[09:32:24.395]                   options(future.plan = NULL)
[09:32:24.395]                   if (is.na(NA_character_)) 
[09:32:24.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:24.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:24.395]                     .init = FALSE)
[09:32:24.395]                 }
[09:32:24.395]             }
[09:32:24.395]         }
[09:32:24.395]     })
[09:32:24.395]     if (TRUE) {
[09:32:24.395]         base::sink(type = "output", split = FALSE)
[09:32:24.395]         if (TRUE) {
[09:32:24.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:24.395]         }
[09:32:24.395]         else {
[09:32:24.395]             ...future.result["stdout"] <- base::list(NULL)
[09:32:24.395]         }
[09:32:24.395]         base::close(...future.stdout)
[09:32:24.395]         ...future.stdout <- NULL
[09:32:24.395]     }
[09:32:24.395]     ...future.result$conditions <- ...future.conditions
[09:32:24.395]     ...future.result$finished <- base::Sys.time()
[09:32:24.395]     ...future.result
[09:32:24.395] }
[09:32:24.398] MultisessionFuture started
[09:32:24.398] - Launch lazy future ... done
[09:32:24.398] run() for ‘MultisessionFuture’ ... done
[09:32:24.900] receiveMessageFromWorker() for ClusterFuture ...
[09:32:24.900] - Validating connection of MultisessionFuture
[09:32:24.901] - received message: FutureResult
[09:32:24.901] - Received FutureResult
[09:32:24.901] - Erased future from FutureRegistry
[09:32:24.901] result() for ClusterFuture ...
[09:32:24.901] - result already collected: FutureResult
[09:32:24.901] result() for ClusterFuture ... done
[09:32:24.901] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:24.901] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:24.902] getGlobalsAndPackages() ...
[09:32:24.902] Searching for globals...
[09:32:24.902] - globals found: [2] ‘list’, ‘stop’
[09:32:24.902] Searching for globals ... DONE
[09:32:24.903] Resolving globals: FALSE
[09:32:24.903] 
[09:32:24.903] 
[09:32:24.903] getGlobalsAndPackages() ... DONE
[09:32:24.903] run() for ‘Future’ ...
[09:32:24.903] - state: ‘created’
[09:32:24.904] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:24.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:24.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:24.917]   - Field: ‘node’
[09:32:24.917]   - Field: ‘label’
[09:32:24.917]   - Field: ‘local’
[09:32:24.917]   - Field: ‘owner’
[09:32:24.918]   - Field: ‘envir’
[09:32:24.918]   - Field: ‘workers’
[09:32:24.918]   - Field: ‘packages’
[09:32:24.918]   - Field: ‘gc’
[09:32:24.918]   - Field: ‘conditions’
[09:32:24.918]   - Field: ‘persistent’
[09:32:24.918]   - Field: ‘expr’
[09:32:24.918]   - Field: ‘uuid’
[09:32:24.918]   - Field: ‘seed’
[09:32:24.918]   - Field: ‘version’
[09:32:24.919]   - Field: ‘result’
[09:32:24.919]   - Field: ‘asynchronous’
[09:32:24.919]   - Field: ‘calls’
[09:32:24.919]   - Field: ‘globals’
[09:32:24.919]   - Field: ‘stdout’
[09:32:24.919]   - Field: ‘earlySignal’
[09:32:24.919]   - Field: ‘lazy’
[09:32:24.919]   - Field: ‘state’
[09:32:24.919] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:24.919] - Launch lazy future ...
[09:32:24.920] Packages needed by the future expression (n = 0): <none>
[09:32:24.920] Packages needed by future strategies (n = 0): <none>
[09:32:24.920] {
[09:32:24.920]     {
[09:32:24.920]         {
[09:32:24.920]             ...future.startTime <- base::Sys.time()
[09:32:24.920]             {
[09:32:24.920]                 {
[09:32:24.920]                   {
[09:32:24.920]                     {
[09:32:24.920]                       base::local({
[09:32:24.920]                         has_future <- base::requireNamespace("future", 
[09:32:24.920]                           quietly = TRUE)
[09:32:24.920]                         if (has_future) {
[09:32:24.920]                           ns <- base::getNamespace("future")
[09:32:24.920]                           version <- ns[[".package"]][["version"]]
[09:32:24.920]                           if (is.null(version)) 
[09:32:24.920]                             version <- utils::packageVersion("future")
[09:32:24.920]                         }
[09:32:24.920]                         else {
[09:32:24.920]                           version <- NULL
[09:32:24.920]                         }
[09:32:24.920]                         if (!has_future || version < "1.8.0") {
[09:32:24.920]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:24.920]                             "", base::R.version$version.string), 
[09:32:24.920]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:24.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:24.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:24.920]                               "release", "version")], collapse = " "), 
[09:32:24.920]                             hostname = base::Sys.info()[["nodename"]])
[09:32:24.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:24.920]                             info)
[09:32:24.920]                           info <- base::paste(info, collapse = "; ")
[09:32:24.920]                           if (!has_future) {
[09:32:24.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:24.920]                               info)
[09:32:24.920]                           }
[09:32:24.920]                           else {
[09:32:24.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:24.920]                               info, version)
[09:32:24.920]                           }
[09:32:24.920]                           base::stop(msg)
[09:32:24.920]                         }
[09:32:24.920]                       })
[09:32:24.920]                     }
[09:32:24.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:24.920]                     base::options(mc.cores = 1L)
[09:32:24.920]                   }
[09:32:24.920]                   ...future.strategy.old <- future::plan("list")
[09:32:24.920]                   options(future.plan = NULL)
[09:32:24.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:24.920]                 }
[09:32:24.920]                 ...future.workdir <- getwd()
[09:32:24.920]             }
[09:32:24.920]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:24.920]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:24.920]         }
[09:32:24.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:24.920]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:24.920]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:24.920]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:24.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:24.920]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:24.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:24.920]             base::names(...future.oldOptions))
[09:32:24.920]     }
[09:32:24.920]     if (FALSE) {
[09:32:24.920]     }
[09:32:24.920]     else {
[09:32:24.920]         if (TRUE) {
[09:32:24.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:24.920]                 open = "w")
[09:32:24.920]         }
[09:32:24.920]         else {
[09:32:24.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:24.920]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:24.920]         }
[09:32:24.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:24.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:24.920]             base::sink(type = "output", split = FALSE)
[09:32:24.920]             base::close(...future.stdout)
[09:32:24.920]         }, add = TRUE)
[09:32:24.920]     }
[09:32:24.920]     ...future.frame <- base::sys.nframe()
[09:32:24.920]     ...future.conditions <- base::list()
[09:32:24.920]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:24.920]     if (FALSE) {
[09:32:24.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:24.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:24.920]     }
[09:32:24.920]     ...future.result <- base::tryCatch({
[09:32:24.920]         base::withCallingHandlers({
[09:32:24.920]             ...future.value <- base::withVisible(base::local({
[09:32:24.920]                 ...future.makeSendCondition <- base::local({
[09:32:24.920]                   sendCondition <- NULL
[09:32:24.920]                   function(frame = 1L) {
[09:32:24.920]                     if (is.function(sendCondition)) 
[09:32:24.920]                       return(sendCondition)
[09:32:24.920]                     ns <- getNamespace("parallel")
[09:32:24.920]                     if (exists("sendData", mode = "function", 
[09:32:24.920]                       envir = ns)) {
[09:32:24.920]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:24.920]                         envir = ns)
[09:32:24.920]                       envir <- sys.frame(frame)
[09:32:24.920]                       master <- NULL
[09:32:24.920]                       while (!identical(envir, .GlobalEnv) && 
[09:32:24.920]                         !identical(envir, emptyenv())) {
[09:32:24.920]                         if (exists("master", mode = "list", envir = envir, 
[09:32:24.920]                           inherits = FALSE)) {
[09:32:24.920]                           master <- get("master", mode = "list", 
[09:32:24.920]                             envir = envir, inherits = FALSE)
[09:32:24.920]                           if (inherits(master, c("SOCKnode", 
[09:32:24.920]                             "SOCK0node"))) {
[09:32:24.920]                             sendCondition <<- function(cond) {
[09:32:24.920]                               data <- list(type = "VALUE", value = cond, 
[09:32:24.920]                                 success = TRUE)
[09:32:24.920]                               parallel_sendData(master, data)
[09:32:24.920]                             }
[09:32:24.920]                             return(sendCondition)
[09:32:24.920]                           }
[09:32:24.920]                         }
[09:32:24.920]                         frame <- frame + 1L
[09:32:24.920]                         envir <- sys.frame(frame)
[09:32:24.920]                       }
[09:32:24.920]                     }
[09:32:24.920]                     sendCondition <<- function(cond) NULL
[09:32:24.920]                   }
[09:32:24.920]                 })
[09:32:24.920]                 withCallingHandlers({
[09:32:24.920]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:24.920]                 }, immediateCondition = function(cond) {
[09:32:24.920]                   sendCondition <- ...future.makeSendCondition()
[09:32:24.920]                   sendCondition(cond)
[09:32:24.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.920]                   {
[09:32:24.920]                     inherits <- base::inherits
[09:32:24.920]                     invokeRestart <- base::invokeRestart
[09:32:24.920]                     is.null <- base::is.null
[09:32:24.920]                     muffled <- FALSE
[09:32:24.920]                     if (inherits(cond, "message")) {
[09:32:24.920]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:24.920]                       if (muffled) 
[09:32:24.920]                         invokeRestart("muffleMessage")
[09:32:24.920]                     }
[09:32:24.920]                     else if (inherits(cond, "warning")) {
[09:32:24.920]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:24.920]                       if (muffled) 
[09:32:24.920]                         invokeRestart("muffleWarning")
[09:32:24.920]                     }
[09:32:24.920]                     else if (inherits(cond, "condition")) {
[09:32:24.920]                       if (!is.null(pattern)) {
[09:32:24.920]                         computeRestarts <- base::computeRestarts
[09:32:24.920]                         grepl <- base::grepl
[09:32:24.920]                         restarts <- computeRestarts(cond)
[09:32:24.920]                         for (restart in restarts) {
[09:32:24.920]                           name <- restart$name
[09:32:24.920]                           if (is.null(name)) 
[09:32:24.920]                             next
[09:32:24.920]                           if (!grepl(pattern, name)) 
[09:32:24.920]                             next
[09:32:24.920]                           invokeRestart(restart)
[09:32:24.920]                           muffled <- TRUE
[09:32:24.920]                           break
[09:32:24.920]                         }
[09:32:24.920]                       }
[09:32:24.920]                     }
[09:32:24.920]                     invisible(muffled)
[09:32:24.920]                   }
[09:32:24.920]                   muffleCondition(cond)
[09:32:24.920]                 })
[09:32:24.920]             }))
[09:32:24.920]             future::FutureResult(value = ...future.value$value, 
[09:32:24.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.920]                   ...future.rng), globalenv = if (FALSE) 
[09:32:24.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:24.920]                     ...future.globalenv.names))
[09:32:24.920]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:24.920]         }, condition = base::local({
[09:32:24.920]             c <- base::c
[09:32:24.920]             inherits <- base::inherits
[09:32:24.920]             invokeRestart <- base::invokeRestart
[09:32:24.920]             length <- base::length
[09:32:24.920]             list <- base::list
[09:32:24.920]             seq.int <- base::seq.int
[09:32:24.920]             signalCondition <- base::signalCondition
[09:32:24.920]             sys.calls <- base::sys.calls
[09:32:24.920]             `[[` <- base::`[[`
[09:32:24.920]             `+` <- base::`+`
[09:32:24.920]             `<<-` <- base::`<<-`
[09:32:24.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:24.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:24.920]                   3L)]
[09:32:24.920]             }
[09:32:24.920]             function(cond) {
[09:32:24.920]                 is_error <- inherits(cond, "error")
[09:32:24.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:24.920]                   NULL)
[09:32:24.920]                 if (is_error) {
[09:32:24.920]                   sessionInformation <- function() {
[09:32:24.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:24.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:24.920]                       search = base::search(), system = base::Sys.info())
[09:32:24.920]                   }
[09:32:24.920]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:24.920]                     cond$call), session = sessionInformation(), 
[09:32:24.920]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:24.920]                   signalCondition(cond)
[09:32:24.920]                 }
[09:32:24.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:24.920]                 "immediateCondition"))) {
[09:32:24.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:24.920]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:24.920]                   if (TRUE && !signal) {
[09:32:24.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.920]                     {
[09:32:24.920]                       inherits <- base::inherits
[09:32:24.920]                       invokeRestart <- base::invokeRestart
[09:32:24.920]                       is.null <- base::is.null
[09:32:24.920]                       muffled <- FALSE
[09:32:24.920]                       if (inherits(cond, "message")) {
[09:32:24.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.920]                         if (muffled) 
[09:32:24.920]                           invokeRestart("muffleMessage")
[09:32:24.920]                       }
[09:32:24.920]                       else if (inherits(cond, "warning")) {
[09:32:24.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.920]                         if (muffled) 
[09:32:24.920]                           invokeRestart("muffleWarning")
[09:32:24.920]                       }
[09:32:24.920]                       else if (inherits(cond, "condition")) {
[09:32:24.920]                         if (!is.null(pattern)) {
[09:32:24.920]                           computeRestarts <- base::computeRestarts
[09:32:24.920]                           grepl <- base::grepl
[09:32:24.920]                           restarts <- computeRestarts(cond)
[09:32:24.920]                           for (restart in restarts) {
[09:32:24.920]                             name <- restart$name
[09:32:24.920]                             if (is.null(name)) 
[09:32:24.920]                               next
[09:32:24.920]                             if (!grepl(pattern, name)) 
[09:32:24.920]                               next
[09:32:24.920]                             invokeRestart(restart)
[09:32:24.920]                             muffled <- TRUE
[09:32:24.920]                             break
[09:32:24.920]                           }
[09:32:24.920]                         }
[09:32:24.920]                       }
[09:32:24.920]                       invisible(muffled)
[09:32:24.920]                     }
[09:32:24.920]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.920]                   }
[09:32:24.920]                 }
[09:32:24.920]                 else {
[09:32:24.920]                   if (TRUE) {
[09:32:24.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.920]                     {
[09:32:24.920]                       inherits <- base::inherits
[09:32:24.920]                       invokeRestart <- base::invokeRestart
[09:32:24.920]                       is.null <- base::is.null
[09:32:24.920]                       muffled <- FALSE
[09:32:24.920]                       if (inherits(cond, "message")) {
[09:32:24.920]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.920]                         if (muffled) 
[09:32:24.920]                           invokeRestart("muffleMessage")
[09:32:24.920]                       }
[09:32:24.920]                       else if (inherits(cond, "warning")) {
[09:32:24.920]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.920]                         if (muffled) 
[09:32:24.920]                           invokeRestart("muffleWarning")
[09:32:24.920]                       }
[09:32:24.920]                       else if (inherits(cond, "condition")) {
[09:32:24.920]                         if (!is.null(pattern)) {
[09:32:24.920]                           computeRestarts <- base::computeRestarts
[09:32:24.920]                           grepl <- base::grepl
[09:32:24.920]                           restarts <- computeRestarts(cond)
[09:32:24.920]                           for (restart in restarts) {
[09:32:24.920]                             name <- restart$name
[09:32:24.920]                             if (is.null(name)) 
[09:32:24.920]                               next
[09:32:24.920]                             if (!grepl(pattern, name)) 
[09:32:24.920]                               next
[09:32:24.920]                             invokeRestart(restart)
[09:32:24.920]                             muffled <- TRUE
[09:32:24.920]                             break
[09:32:24.920]                           }
[09:32:24.920]                         }
[09:32:24.920]                       }
[09:32:24.920]                       invisible(muffled)
[09:32:24.920]                     }
[09:32:24.920]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.920]                   }
[09:32:24.920]                 }
[09:32:24.920]             }
[09:32:24.920]         }))
[09:32:24.920]     }, error = function(ex) {
[09:32:24.920]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:24.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.920]                 ...future.rng), started = ...future.startTime, 
[09:32:24.920]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:24.920]             version = "1.8"), class = "FutureResult")
[09:32:24.920]     }, finally = {
[09:32:24.920]         if (!identical(...future.workdir, getwd())) 
[09:32:24.920]             setwd(...future.workdir)
[09:32:24.920]         {
[09:32:24.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:24.920]                 ...future.oldOptions$nwarnings <- NULL
[09:32:24.920]             }
[09:32:24.920]             base::options(...future.oldOptions)
[09:32:24.920]             if (.Platform$OS.type == "windows") {
[09:32:24.920]                 old_names <- names(...future.oldEnvVars)
[09:32:24.920]                 envs <- base::Sys.getenv()
[09:32:24.920]                 names <- names(envs)
[09:32:24.920]                 common <- intersect(names, old_names)
[09:32:24.920]                 added <- setdiff(names, old_names)
[09:32:24.920]                 removed <- setdiff(old_names, names)
[09:32:24.920]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:24.920]                   envs[common]]
[09:32:24.920]                 NAMES <- toupper(changed)
[09:32:24.920]                 args <- list()
[09:32:24.920]                 for (kk in seq_along(NAMES)) {
[09:32:24.920]                   name <- changed[[kk]]
[09:32:24.920]                   NAME <- NAMES[[kk]]
[09:32:24.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.920]                     next
[09:32:24.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.920]                 }
[09:32:24.920]                 NAMES <- toupper(added)
[09:32:24.920]                 for (kk in seq_along(NAMES)) {
[09:32:24.920]                   name <- added[[kk]]
[09:32:24.920]                   NAME <- NAMES[[kk]]
[09:32:24.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.920]                     next
[09:32:24.920]                   args[[name]] <- ""
[09:32:24.920]                 }
[09:32:24.920]                 NAMES <- toupper(removed)
[09:32:24.920]                 for (kk in seq_along(NAMES)) {
[09:32:24.920]                   name <- removed[[kk]]
[09:32:24.920]                   NAME <- NAMES[[kk]]
[09:32:24.920]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.920]                     next
[09:32:24.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.920]                 }
[09:32:24.920]                 if (length(args) > 0) 
[09:32:24.920]                   base::do.call(base::Sys.setenv, args = args)
[09:32:24.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:24.920]             }
[09:32:24.920]             else {
[09:32:24.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:24.920]             }
[09:32:24.920]             {
[09:32:24.920]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:24.920]                   0L) {
[09:32:24.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:24.920]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:24.920]                   base::options(opts)
[09:32:24.920]                 }
[09:32:24.920]                 {
[09:32:24.920]                   {
[09:32:24.920]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:24.920]                     NULL
[09:32:24.920]                   }
[09:32:24.920]                   options(future.plan = NULL)
[09:32:24.920]                   if (is.na(NA_character_)) 
[09:32:24.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:24.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:24.920]                     .init = FALSE)
[09:32:24.920]                 }
[09:32:24.920]             }
[09:32:24.920]         }
[09:32:24.920]     })
[09:32:24.920]     if (TRUE) {
[09:32:24.920]         base::sink(type = "output", split = FALSE)
[09:32:24.920]         if (TRUE) {
[09:32:24.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:24.920]         }
[09:32:24.920]         else {
[09:32:24.920]             ...future.result["stdout"] <- base::list(NULL)
[09:32:24.920]         }
[09:32:24.920]         base::close(...future.stdout)
[09:32:24.920]         ...future.stdout <- NULL
[09:32:24.920]     }
[09:32:24.920]     ...future.result$conditions <- ...future.conditions
[09:32:24.920]     ...future.result$finished <- base::Sys.time()
[09:32:24.920]     ...future.result
[09:32:24.920] }
[09:32:24.923] MultisessionFuture started
[09:32:24.923] - Launch lazy future ... done
[09:32:24.923] run() for ‘MultisessionFuture’ ... done
[09:32:24.925] receiveMessageFromWorker() for ClusterFuture ...
[09:32:24.925] - Validating connection of MultisessionFuture
[09:32:24.925] - received message: FutureResult
[09:32:24.926] - Received FutureResult
[09:32:24.926] - Erased future from FutureRegistry
[09:32:24.926] result() for ClusterFuture ...
[09:32:24.926] - result already collected: FutureResult
[09:32:24.926] result() for ClusterFuture ... done
[09:32:24.926] signalConditions() ...
[09:32:24.926]  - include = ‘immediateCondition’
[09:32:24.926]  - exclude = 
[09:32:24.926]  - resignal = FALSE
[09:32:24.926]  - Number of conditions: 1
[09:32:24.926] signalConditions() ... done
[09:32:24.927] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:24.927] A MultisessionFuture was resolved (result was not collected)
[09:32:24.927] getGlobalsAndPackages() ...
[09:32:24.927] Searching for globals...
[09:32:24.927] - globals found: [2] ‘list’, ‘stop’
[09:32:24.928] Searching for globals ... DONE
[09:32:24.928] Resolving globals: FALSE
[09:32:24.928] 
[09:32:24.928] 
[09:32:24.928] getGlobalsAndPackages() ... DONE
[09:32:24.928] run() for ‘Future’ ...
[09:32:24.928] - state: ‘created’
[09:32:24.929] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:24.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:24.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:24.942]   - Field: ‘node’
[09:32:24.943]   - Field: ‘label’
[09:32:24.943]   - Field: ‘local’
[09:32:24.943]   - Field: ‘owner’
[09:32:24.943]   - Field: ‘envir’
[09:32:24.943]   - Field: ‘workers’
[09:32:24.943]   - Field: ‘packages’
[09:32:24.943]   - Field: ‘gc’
[09:32:24.943]   - Field: ‘conditions’
[09:32:24.943]   - Field: ‘persistent’
[09:32:24.943]   - Field: ‘expr’
[09:32:24.943]   - Field: ‘uuid’
[09:32:24.943]   - Field: ‘seed’
[09:32:24.944]   - Field: ‘version’
[09:32:24.944]   - Field: ‘result’
[09:32:24.944]   - Field: ‘asynchronous’
[09:32:24.944]   - Field: ‘calls’
[09:32:24.944]   - Field: ‘globals’
[09:32:24.944]   - Field: ‘stdout’
[09:32:24.944]   - Field: ‘earlySignal’
[09:32:24.944]   - Field: ‘lazy’
[09:32:24.944]   - Field: ‘state’
[09:32:24.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:24.944] - Launch lazy future ...
[09:32:24.945] Packages needed by the future expression (n = 0): <none>
[09:32:24.945] Packages needed by future strategies (n = 0): <none>
[09:32:24.945] {
[09:32:24.945]     {
[09:32:24.945]         {
[09:32:24.945]             ...future.startTime <- base::Sys.time()
[09:32:24.945]             {
[09:32:24.945]                 {
[09:32:24.945]                   {
[09:32:24.945]                     {
[09:32:24.945]                       base::local({
[09:32:24.945]                         has_future <- base::requireNamespace("future", 
[09:32:24.945]                           quietly = TRUE)
[09:32:24.945]                         if (has_future) {
[09:32:24.945]                           ns <- base::getNamespace("future")
[09:32:24.945]                           version <- ns[[".package"]][["version"]]
[09:32:24.945]                           if (is.null(version)) 
[09:32:24.945]                             version <- utils::packageVersion("future")
[09:32:24.945]                         }
[09:32:24.945]                         else {
[09:32:24.945]                           version <- NULL
[09:32:24.945]                         }
[09:32:24.945]                         if (!has_future || version < "1.8.0") {
[09:32:24.945]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:24.945]                             "", base::R.version$version.string), 
[09:32:24.945]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:24.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:24.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:24.945]                               "release", "version")], collapse = " "), 
[09:32:24.945]                             hostname = base::Sys.info()[["nodename"]])
[09:32:24.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:24.945]                             info)
[09:32:24.945]                           info <- base::paste(info, collapse = "; ")
[09:32:24.945]                           if (!has_future) {
[09:32:24.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:24.945]                               info)
[09:32:24.945]                           }
[09:32:24.945]                           else {
[09:32:24.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:24.945]                               info, version)
[09:32:24.945]                           }
[09:32:24.945]                           base::stop(msg)
[09:32:24.945]                         }
[09:32:24.945]                       })
[09:32:24.945]                     }
[09:32:24.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:24.945]                     base::options(mc.cores = 1L)
[09:32:24.945]                   }
[09:32:24.945]                   ...future.strategy.old <- future::plan("list")
[09:32:24.945]                   options(future.plan = NULL)
[09:32:24.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:24.945]                 }
[09:32:24.945]                 ...future.workdir <- getwd()
[09:32:24.945]             }
[09:32:24.945]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:24.945]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:24.945]         }
[09:32:24.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:24.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:24.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:24.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:24.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:24.945]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:24.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:24.945]             base::names(...future.oldOptions))
[09:32:24.945]     }
[09:32:24.945]     if (FALSE) {
[09:32:24.945]     }
[09:32:24.945]     else {
[09:32:24.945]         if (TRUE) {
[09:32:24.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:24.945]                 open = "w")
[09:32:24.945]         }
[09:32:24.945]         else {
[09:32:24.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:24.945]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:24.945]         }
[09:32:24.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:24.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:24.945]             base::sink(type = "output", split = FALSE)
[09:32:24.945]             base::close(...future.stdout)
[09:32:24.945]         }, add = TRUE)
[09:32:24.945]     }
[09:32:24.945]     ...future.frame <- base::sys.nframe()
[09:32:24.945]     ...future.conditions <- base::list()
[09:32:24.945]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:24.945]     if (FALSE) {
[09:32:24.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:24.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:24.945]     }
[09:32:24.945]     ...future.result <- base::tryCatch({
[09:32:24.945]         base::withCallingHandlers({
[09:32:24.945]             ...future.value <- base::withVisible(base::local({
[09:32:24.945]                 ...future.makeSendCondition <- base::local({
[09:32:24.945]                   sendCondition <- NULL
[09:32:24.945]                   function(frame = 1L) {
[09:32:24.945]                     if (is.function(sendCondition)) 
[09:32:24.945]                       return(sendCondition)
[09:32:24.945]                     ns <- getNamespace("parallel")
[09:32:24.945]                     if (exists("sendData", mode = "function", 
[09:32:24.945]                       envir = ns)) {
[09:32:24.945]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:24.945]                         envir = ns)
[09:32:24.945]                       envir <- sys.frame(frame)
[09:32:24.945]                       master <- NULL
[09:32:24.945]                       while (!identical(envir, .GlobalEnv) && 
[09:32:24.945]                         !identical(envir, emptyenv())) {
[09:32:24.945]                         if (exists("master", mode = "list", envir = envir, 
[09:32:24.945]                           inherits = FALSE)) {
[09:32:24.945]                           master <- get("master", mode = "list", 
[09:32:24.945]                             envir = envir, inherits = FALSE)
[09:32:24.945]                           if (inherits(master, c("SOCKnode", 
[09:32:24.945]                             "SOCK0node"))) {
[09:32:24.945]                             sendCondition <<- function(cond) {
[09:32:24.945]                               data <- list(type = "VALUE", value = cond, 
[09:32:24.945]                                 success = TRUE)
[09:32:24.945]                               parallel_sendData(master, data)
[09:32:24.945]                             }
[09:32:24.945]                             return(sendCondition)
[09:32:24.945]                           }
[09:32:24.945]                         }
[09:32:24.945]                         frame <- frame + 1L
[09:32:24.945]                         envir <- sys.frame(frame)
[09:32:24.945]                       }
[09:32:24.945]                     }
[09:32:24.945]                     sendCondition <<- function(cond) NULL
[09:32:24.945]                   }
[09:32:24.945]                 })
[09:32:24.945]                 withCallingHandlers({
[09:32:24.945]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:24.945]                 }, immediateCondition = function(cond) {
[09:32:24.945]                   sendCondition <- ...future.makeSendCondition()
[09:32:24.945]                   sendCondition(cond)
[09:32:24.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.945]                   {
[09:32:24.945]                     inherits <- base::inherits
[09:32:24.945]                     invokeRestart <- base::invokeRestart
[09:32:24.945]                     is.null <- base::is.null
[09:32:24.945]                     muffled <- FALSE
[09:32:24.945]                     if (inherits(cond, "message")) {
[09:32:24.945]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:24.945]                       if (muffled) 
[09:32:24.945]                         invokeRestart("muffleMessage")
[09:32:24.945]                     }
[09:32:24.945]                     else if (inherits(cond, "warning")) {
[09:32:24.945]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:24.945]                       if (muffled) 
[09:32:24.945]                         invokeRestart("muffleWarning")
[09:32:24.945]                     }
[09:32:24.945]                     else if (inherits(cond, "condition")) {
[09:32:24.945]                       if (!is.null(pattern)) {
[09:32:24.945]                         computeRestarts <- base::computeRestarts
[09:32:24.945]                         grepl <- base::grepl
[09:32:24.945]                         restarts <- computeRestarts(cond)
[09:32:24.945]                         for (restart in restarts) {
[09:32:24.945]                           name <- restart$name
[09:32:24.945]                           if (is.null(name)) 
[09:32:24.945]                             next
[09:32:24.945]                           if (!grepl(pattern, name)) 
[09:32:24.945]                             next
[09:32:24.945]                           invokeRestart(restart)
[09:32:24.945]                           muffled <- TRUE
[09:32:24.945]                           break
[09:32:24.945]                         }
[09:32:24.945]                       }
[09:32:24.945]                     }
[09:32:24.945]                     invisible(muffled)
[09:32:24.945]                   }
[09:32:24.945]                   muffleCondition(cond)
[09:32:24.945]                 })
[09:32:24.945]             }))
[09:32:24.945]             future::FutureResult(value = ...future.value$value, 
[09:32:24.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.945]                   ...future.rng), globalenv = if (FALSE) 
[09:32:24.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:24.945]                     ...future.globalenv.names))
[09:32:24.945]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:24.945]         }, condition = base::local({
[09:32:24.945]             c <- base::c
[09:32:24.945]             inherits <- base::inherits
[09:32:24.945]             invokeRestart <- base::invokeRestart
[09:32:24.945]             length <- base::length
[09:32:24.945]             list <- base::list
[09:32:24.945]             seq.int <- base::seq.int
[09:32:24.945]             signalCondition <- base::signalCondition
[09:32:24.945]             sys.calls <- base::sys.calls
[09:32:24.945]             `[[` <- base::`[[`
[09:32:24.945]             `+` <- base::`+`
[09:32:24.945]             `<<-` <- base::`<<-`
[09:32:24.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:24.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:24.945]                   3L)]
[09:32:24.945]             }
[09:32:24.945]             function(cond) {
[09:32:24.945]                 is_error <- inherits(cond, "error")
[09:32:24.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:24.945]                   NULL)
[09:32:24.945]                 if (is_error) {
[09:32:24.945]                   sessionInformation <- function() {
[09:32:24.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:24.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:24.945]                       search = base::search(), system = base::Sys.info())
[09:32:24.945]                   }
[09:32:24.945]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:24.945]                     cond$call), session = sessionInformation(), 
[09:32:24.945]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:24.945]                   signalCondition(cond)
[09:32:24.945]                 }
[09:32:24.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:24.945]                 "immediateCondition"))) {
[09:32:24.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:24.945]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:24.945]                   if (TRUE && !signal) {
[09:32:24.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.945]                     {
[09:32:24.945]                       inherits <- base::inherits
[09:32:24.945]                       invokeRestart <- base::invokeRestart
[09:32:24.945]                       is.null <- base::is.null
[09:32:24.945]                       muffled <- FALSE
[09:32:24.945]                       if (inherits(cond, "message")) {
[09:32:24.945]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.945]                         if (muffled) 
[09:32:24.945]                           invokeRestart("muffleMessage")
[09:32:24.945]                       }
[09:32:24.945]                       else if (inherits(cond, "warning")) {
[09:32:24.945]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.945]                         if (muffled) 
[09:32:24.945]                           invokeRestart("muffleWarning")
[09:32:24.945]                       }
[09:32:24.945]                       else if (inherits(cond, "condition")) {
[09:32:24.945]                         if (!is.null(pattern)) {
[09:32:24.945]                           computeRestarts <- base::computeRestarts
[09:32:24.945]                           grepl <- base::grepl
[09:32:24.945]                           restarts <- computeRestarts(cond)
[09:32:24.945]                           for (restart in restarts) {
[09:32:24.945]                             name <- restart$name
[09:32:24.945]                             if (is.null(name)) 
[09:32:24.945]                               next
[09:32:24.945]                             if (!grepl(pattern, name)) 
[09:32:24.945]                               next
[09:32:24.945]                             invokeRestart(restart)
[09:32:24.945]                             muffled <- TRUE
[09:32:24.945]                             break
[09:32:24.945]                           }
[09:32:24.945]                         }
[09:32:24.945]                       }
[09:32:24.945]                       invisible(muffled)
[09:32:24.945]                     }
[09:32:24.945]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.945]                   }
[09:32:24.945]                 }
[09:32:24.945]                 else {
[09:32:24.945]                   if (TRUE) {
[09:32:24.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.945]                     {
[09:32:24.945]                       inherits <- base::inherits
[09:32:24.945]                       invokeRestart <- base::invokeRestart
[09:32:24.945]                       is.null <- base::is.null
[09:32:24.945]                       muffled <- FALSE
[09:32:24.945]                       if (inherits(cond, "message")) {
[09:32:24.945]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.945]                         if (muffled) 
[09:32:24.945]                           invokeRestart("muffleMessage")
[09:32:24.945]                       }
[09:32:24.945]                       else if (inherits(cond, "warning")) {
[09:32:24.945]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.945]                         if (muffled) 
[09:32:24.945]                           invokeRestart("muffleWarning")
[09:32:24.945]                       }
[09:32:24.945]                       else if (inherits(cond, "condition")) {
[09:32:24.945]                         if (!is.null(pattern)) {
[09:32:24.945]                           computeRestarts <- base::computeRestarts
[09:32:24.945]                           grepl <- base::grepl
[09:32:24.945]                           restarts <- computeRestarts(cond)
[09:32:24.945]                           for (restart in restarts) {
[09:32:24.945]                             name <- restart$name
[09:32:24.945]                             if (is.null(name)) 
[09:32:24.945]                               next
[09:32:24.945]                             if (!grepl(pattern, name)) 
[09:32:24.945]                               next
[09:32:24.945]                             invokeRestart(restart)
[09:32:24.945]                             muffled <- TRUE
[09:32:24.945]                             break
[09:32:24.945]                           }
[09:32:24.945]                         }
[09:32:24.945]                       }
[09:32:24.945]                       invisible(muffled)
[09:32:24.945]                     }
[09:32:24.945]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.945]                   }
[09:32:24.945]                 }
[09:32:24.945]             }
[09:32:24.945]         }))
[09:32:24.945]     }, error = function(ex) {
[09:32:24.945]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:24.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.945]                 ...future.rng), started = ...future.startTime, 
[09:32:24.945]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:24.945]             version = "1.8"), class = "FutureResult")
[09:32:24.945]     }, finally = {
[09:32:24.945]         if (!identical(...future.workdir, getwd())) 
[09:32:24.945]             setwd(...future.workdir)
[09:32:24.945]         {
[09:32:24.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:24.945]                 ...future.oldOptions$nwarnings <- NULL
[09:32:24.945]             }
[09:32:24.945]             base::options(...future.oldOptions)
[09:32:24.945]             if (.Platform$OS.type == "windows") {
[09:32:24.945]                 old_names <- names(...future.oldEnvVars)
[09:32:24.945]                 envs <- base::Sys.getenv()
[09:32:24.945]                 names <- names(envs)
[09:32:24.945]                 common <- intersect(names, old_names)
[09:32:24.945]                 added <- setdiff(names, old_names)
[09:32:24.945]                 removed <- setdiff(old_names, names)
[09:32:24.945]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:24.945]                   envs[common]]
[09:32:24.945]                 NAMES <- toupper(changed)
[09:32:24.945]                 args <- list()
[09:32:24.945]                 for (kk in seq_along(NAMES)) {
[09:32:24.945]                   name <- changed[[kk]]
[09:32:24.945]                   NAME <- NAMES[[kk]]
[09:32:24.945]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.945]                     next
[09:32:24.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.945]                 }
[09:32:24.945]                 NAMES <- toupper(added)
[09:32:24.945]                 for (kk in seq_along(NAMES)) {
[09:32:24.945]                   name <- added[[kk]]
[09:32:24.945]                   NAME <- NAMES[[kk]]
[09:32:24.945]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.945]                     next
[09:32:24.945]                   args[[name]] <- ""
[09:32:24.945]                 }
[09:32:24.945]                 NAMES <- toupper(removed)
[09:32:24.945]                 for (kk in seq_along(NAMES)) {
[09:32:24.945]                   name <- removed[[kk]]
[09:32:24.945]                   NAME <- NAMES[[kk]]
[09:32:24.945]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.945]                     next
[09:32:24.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.945]                 }
[09:32:24.945]                 if (length(args) > 0) 
[09:32:24.945]                   base::do.call(base::Sys.setenv, args = args)
[09:32:24.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:24.945]             }
[09:32:24.945]             else {
[09:32:24.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:24.945]             }
[09:32:24.945]             {
[09:32:24.945]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:24.945]                   0L) {
[09:32:24.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:24.945]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:24.945]                   base::options(opts)
[09:32:24.945]                 }
[09:32:24.945]                 {
[09:32:24.945]                   {
[09:32:24.945]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:24.945]                     NULL
[09:32:24.945]                   }
[09:32:24.945]                   options(future.plan = NULL)
[09:32:24.945]                   if (is.na(NA_character_)) 
[09:32:24.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:24.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:24.945]                     .init = FALSE)
[09:32:24.945]                 }
[09:32:24.945]             }
[09:32:24.945]         }
[09:32:24.945]     })
[09:32:24.945]     if (TRUE) {
[09:32:24.945]         base::sink(type = "output", split = FALSE)
[09:32:24.945]         if (TRUE) {
[09:32:24.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:24.945]         }
[09:32:24.945]         else {
[09:32:24.945]             ...future.result["stdout"] <- base::list(NULL)
[09:32:24.945]         }
[09:32:24.945]         base::close(...future.stdout)
[09:32:24.945]         ...future.stdout <- NULL
[09:32:24.945]     }
[09:32:24.945]     ...future.result$conditions <- ...future.conditions
[09:32:24.945]     ...future.result$finished <- base::Sys.time()
[09:32:24.945]     ...future.result
[09:32:24.945] }
[09:32:24.948] MultisessionFuture started
[09:32:24.948] - Launch lazy future ... done
[09:32:24.948] run() for ‘MultisessionFuture’ ... done
[09:32:24.950] receiveMessageFromWorker() for ClusterFuture ...
[09:32:24.950] - Validating connection of MultisessionFuture
[09:32:24.950] - received message: FutureResult
[09:32:24.950] - Received FutureResult
[09:32:24.950] - Erased future from FutureRegistry
[09:32:24.953] result() for ClusterFuture ...
[09:32:24.953] - result already collected: FutureResult
[09:32:24.953] result() for ClusterFuture ... done
[09:32:24.953] signalConditions() ...
[09:32:24.953]  - include = ‘immediateCondition’
[09:32:24.953]  - exclude = 
[09:32:24.953]  - resignal = FALSE
[09:32:24.953]  - Number of conditions: 1
[09:32:24.953] signalConditions() ... done
[09:32:24.954] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:24.954] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[09:32:24.954] getGlobalsAndPackages() ...
[09:32:24.954] Searching for globals...
[09:32:24.955] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:24.955] Searching for globals ... DONE
[09:32:24.955] Resolving globals: FALSE
[09:32:24.955] 
[09:32:24.956] 
[09:32:24.956] getGlobalsAndPackages() ... DONE
[09:32:24.956] run() for ‘Future’ ...
[09:32:24.956] - state: ‘created’
[09:32:24.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:24.970] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:24.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:24.970]   - Field: ‘node’
[09:32:24.970]   - Field: ‘label’
[09:32:24.970]   - Field: ‘local’
[09:32:24.970]   - Field: ‘owner’
[09:32:24.970]   - Field: ‘envir’
[09:32:24.970]   - Field: ‘workers’
[09:32:24.970]   - Field: ‘packages’
[09:32:24.970]   - Field: ‘gc’
[09:32:24.971]   - Field: ‘conditions’
[09:32:24.971]   - Field: ‘persistent’
[09:32:24.971]   - Field: ‘expr’
[09:32:24.971]   - Field: ‘uuid’
[09:32:24.971]   - Field: ‘seed’
[09:32:24.971]   - Field: ‘version’
[09:32:24.971]   - Field: ‘result’
[09:32:24.971]   - Field: ‘asynchronous’
[09:32:24.971]   - Field: ‘calls’
[09:32:24.971]   - Field: ‘globals’
[09:32:24.971]   - Field: ‘stdout’
[09:32:24.972]   - Field: ‘earlySignal’
[09:32:24.972]   - Field: ‘lazy’
[09:32:24.972]   - Field: ‘state’
[09:32:24.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:24.972] - Launch lazy future ...
[09:32:24.972] Packages needed by the future expression (n = 0): <none>
[09:32:24.972] Packages needed by future strategies (n = 0): <none>
[09:32:24.973] {
[09:32:24.973]     {
[09:32:24.973]         {
[09:32:24.973]             ...future.startTime <- base::Sys.time()
[09:32:24.973]             {
[09:32:24.973]                 {
[09:32:24.973]                   {
[09:32:24.973]                     {
[09:32:24.973]                       base::local({
[09:32:24.973]                         has_future <- base::requireNamespace("future", 
[09:32:24.973]                           quietly = TRUE)
[09:32:24.973]                         if (has_future) {
[09:32:24.973]                           ns <- base::getNamespace("future")
[09:32:24.973]                           version <- ns[[".package"]][["version"]]
[09:32:24.973]                           if (is.null(version)) 
[09:32:24.973]                             version <- utils::packageVersion("future")
[09:32:24.973]                         }
[09:32:24.973]                         else {
[09:32:24.973]                           version <- NULL
[09:32:24.973]                         }
[09:32:24.973]                         if (!has_future || version < "1.8.0") {
[09:32:24.973]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:24.973]                             "", base::R.version$version.string), 
[09:32:24.973]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:24.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:24.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:24.973]                               "release", "version")], collapse = " "), 
[09:32:24.973]                             hostname = base::Sys.info()[["nodename"]])
[09:32:24.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:24.973]                             info)
[09:32:24.973]                           info <- base::paste(info, collapse = "; ")
[09:32:24.973]                           if (!has_future) {
[09:32:24.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:24.973]                               info)
[09:32:24.973]                           }
[09:32:24.973]                           else {
[09:32:24.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:24.973]                               info, version)
[09:32:24.973]                           }
[09:32:24.973]                           base::stop(msg)
[09:32:24.973]                         }
[09:32:24.973]                       })
[09:32:24.973]                     }
[09:32:24.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:24.973]                     base::options(mc.cores = 1L)
[09:32:24.973]                   }
[09:32:24.973]                   ...future.strategy.old <- future::plan("list")
[09:32:24.973]                   options(future.plan = NULL)
[09:32:24.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:24.973]                 }
[09:32:24.973]                 ...future.workdir <- getwd()
[09:32:24.973]             }
[09:32:24.973]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:24.973]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:24.973]         }
[09:32:24.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:24.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:24.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:24.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:24.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:24.973]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:24.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:24.973]             base::names(...future.oldOptions))
[09:32:24.973]     }
[09:32:24.973]     if (FALSE) {
[09:32:24.973]     }
[09:32:24.973]     else {
[09:32:24.973]         if (TRUE) {
[09:32:24.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:24.973]                 open = "w")
[09:32:24.973]         }
[09:32:24.973]         else {
[09:32:24.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:24.973]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:24.973]         }
[09:32:24.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:24.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:24.973]             base::sink(type = "output", split = FALSE)
[09:32:24.973]             base::close(...future.stdout)
[09:32:24.973]         }, add = TRUE)
[09:32:24.973]     }
[09:32:24.973]     ...future.frame <- base::sys.nframe()
[09:32:24.973]     ...future.conditions <- base::list()
[09:32:24.973]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:24.973]     if (FALSE) {
[09:32:24.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:24.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:24.973]     }
[09:32:24.973]     ...future.result <- base::tryCatch({
[09:32:24.973]         base::withCallingHandlers({
[09:32:24.973]             ...future.value <- base::withVisible(base::local({
[09:32:24.973]                 ...future.makeSendCondition <- base::local({
[09:32:24.973]                   sendCondition <- NULL
[09:32:24.973]                   function(frame = 1L) {
[09:32:24.973]                     if (is.function(sendCondition)) 
[09:32:24.973]                       return(sendCondition)
[09:32:24.973]                     ns <- getNamespace("parallel")
[09:32:24.973]                     if (exists("sendData", mode = "function", 
[09:32:24.973]                       envir = ns)) {
[09:32:24.973]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:24.973]                         envir = ns)
[09:32:24.973]                       envir <- sys.frame(frame)
[09:32:24.973]                       master <- NULL
[09:32:24.973]                       while (!identical(envir, .GlobalEnv) && 
[09:32:24.973]                         !identical(envir, emptyenv())) {
[09:32:24.973]                         if (exists("master", mode = "list", envir = envir, 
[09:32:24.973]                           inherits = FALSE)) {
[09:32:24.973]                           master <- get("master", mode = "list", 
[09:32:24.973]                             envir = envir, inherits = FALSE)
[09:32:24.973]                           if (inherits(master, c("SOCKnode", 
[09:32:24.973]                             "SOCK0node"))) {
[09:32:24.973]                             sendCondition <<- function(cond) {
[09:32:24.973]                               data <- list(type = "VALUE", value = cond, 
[09:32:24.973]                                 success = TRUE)
[09:32:24.973]                               parallel_sendData(master, data)
[09:32:24.973]                             }
[09:32:24.973]                             return(sendCondition)
[09:32:24.973]                           }
[09:32:24.973]                         }
[09:32:24.973]                         frame <- frame + 1L
[09:32:24.973]                         envir <- sys.frame(frame)
[09:32:24.973]                       }
[09:32:24.973]                     }
[09:32:24.973]                     sendCondition <<- function(cond) NULL
[09:32:24.973]                   }
[09:32:24.973]                 })
[09:32:24.973]                 withCallingHandlers({
[09:32:24.973]                   {
[09:32:24.973]                     Sys.sleep(0.5)
[09:32:24.973]                     list(a = 1, b = 42L)
[09:32:24.973]                   }
[09:32:24.973]                 }, immediateCondition = function(cond) {
[09:32:24.973]                   sendCondition <- ...future.makeSendCondition()
[09:32:24.973]                   sendCondition(cond)
[09:32:24.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.973]                   {
[09:32:24.973]                     inherits <- base::inherits
[09:32:24.973]                     invokeRestart <- base::invokeRestart
[09:32:24.973]                     is.null <- base::is.null
[09:32:24.973]                     muffled <- FALSE
[09:32:24.973]                     if (inherits(cond, "message")) {
[09:32:24.973]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:24.973]                       if (muffled) 
[09:32:24.973]                         invokeRestart("muffleMessage")
[09:32:24.973]                     }
[09:32:24.973]                     else if (inherits(cond, "warning")) {
[09:32:24.973]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:24.973]                       if (muffled) 
[09:32:24.973]                         invokeRestart("muffleWarning")
[09:32:24.973]                     }
[09:32:24.973]                     else if (inherits(cond, "condition")) {
[09:32:24.973]                       if (!is.null(pattern)) {
[09:32:24.973]                         computeRestarts <- base::computeRestarts
[09:32:24.973]                         grepl <- base::grepl
[09:32:24.973]                         restarts <- computeRestarts(cond)
[09:32:24.973]                         for (restart in restarts) {
[09:32:24.973]                           name <- restart$name
[09:32:24.973]                           if (is.null(name)) 
[09:32:24.973]                             next
[09:32:24.973]                           if (!grepl(pattern, name)) 
[09:32:24.973]                             next
[09:32:24.973]                           invokeRestart(restart)
[09:32:24.973]                           muffled <- TRUE
[09:32:24.973]                           break
[09:32:24.973]                         }
[09:32:24.973]                       }
[09:32:24.973]                     }
[09:32:24.973]                     invisible(muffled)
[09:32:24.973]                   }
[09:32:24.973]                   muffleCondition(cond)
[09:32:24.973]                 })
[09:32:24.973]             }))
[09:32:24.973]             future::FutureResult(value = ...future.value$value, 
[09:32:24.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.973]                   ...future.rng), globalenv = if (FALSE) 
[09:32:24.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:24.973]                     ...future.globalenv.names))
[09:32:24.973]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:24.973]         }, condition = base::local({
[09:32:24.973]             c <- base::c
[09:32:24.973]             inherits <- base::inherits
[09:32:24.973]             invokeRestart <- base::invokeRestart
[09:32:24.973]             length <- base::length
[09:32:24.973]             list <- base::list
[09:32:24.973]             seq.int <- base::seq.int
[09:32:24.973]             signalCondition <- base::signalCondition
[09:32:24.973]             sys.calls <- base::sys.calls
[09:32:24.973]             `[[` <- base::`[[`
[09:32:24.973]             `+` <- base::`+`
[09:32:24.973]             `<<-` <- base::`<<-`
[09:32:24.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:24.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:24.973]                   3L)]
[09:32:24.973]             }
[09:32:24.973]             function(cond) {
[09:32:24.973]                 is_error <- inherits(cond, "error")
[09:32:24.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:24.973]                   NULL)
[09:32:24.973]                 if (is_error) {
[09:32:24.973]                   sessionInformation <- function() {
[09:32:24.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:24.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:24.973]                       search = base::search(), system = base::Sys.info())
[09:32:24.973]                   }
[09:32:24.973]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:24.973]                     cond$call), session = sessionInformation(), 
[09:32:24.973]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:24.973]                   signalCondition(cond)
[09:32:24.973]                 }
[09:32:24.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:24.973]                 "immediateCondition"))) {
[09:32:24.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:24.973]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:24.973]                   if (TRUE && !signal) {
[09:32:24.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.973]                     {
[09:32:24.973]                       inherits <- base::inherits
[09:32:24.973]                       invokeRestart <- base::invokeRestart
[09:32:24.973]                       is.null <- base::is.null
[09:32:24.973]                       muffled <- FALSE
[09:32:24.973]                       if (inherits(cond, "message")) {
[09:32:24.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.973]                         if (muffled) 
[09:32:24.973]                           invokeRestart("muffleMessage")
[09:32:24.973]                       }
[09:32:24.973]                       else if (inherits(cond, "warning")) {
[09:32:24.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.973]                         if (muffled) 
[09:32:24.973]                           invokeRestart("muffleWarning")
[09:32:24.973]                       }
[09:32:24.973]                       else if (inherits(cond, "condition")) {
[09:32:24.973]                         if (!is.null(pattern)) {
[09:32:24.973]                           computeRestarts <- base::computeRestarts
[09:32:24.973]                           grepl <- base::grepl
[09:32:24.973]                           restarts <- computeRestarts(cond)
[09:32:24.973]                           for (restart in restarts) {
[09:32:24.973]                             name <- restart$name
[09:32:24.973]                             if (is.null(name)) 
[09:32:24.973]                               next
[09:32:24.973]                             if (!grepl(pattern, name)) 
[09:32:24.973]                               next
[09:32:24.973]                             invokeRestart(restart)
[09:32:24.973]                             muffled <- TRUE
[09:32:24.973]                             break
[09:32:24.973]                           }
[09:32:24.973]                         }
[09:32:24.973]                       }
[09:32:24.973]                       invisible(muffled)
[09:32:24.973]                     }
[09:32:24.973]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.973]                   }
[09:32:24.973]                 }
[09:32:24.973]                 else {
[09:32:24.973]                   if (TRUE) {
[09:32:24.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.973]                     {
[09:32:24.973]                       inherits <- base::inherits
[09:32:24.973]                       invokeRestart <- base::invokeRestart
[09:32:24.973]                       is.null <- base::is.null
[09:32:24.973]                       muffled <- FALSE
[09:32:24.973]                       if (inherits(cond, "message")) {
[09:32:24.973]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.973]                         if (muffled) 
[09:32:24.973]                           invokeRestart("muffleMessage")
[09:32:24.973]                       }
[09:32:24.973]                       else if (inherits(cond, "warning")) {
[09:32:24.973]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.973]                         if (muffled) 
[09:32:24.973]                           invokeRestart("muffleWarning")
[09:32:24.973]                       }
[09:32:24.973]                       else if (inherits(cond, "condition")) {
[09:32:24.973]                         if (!is.null(pattern)) {
[09:32:24.973]                           computeRestarts <- base::computeRestarts
[09:32:24.973]                           grepl <- base::grepl
[09:32:24.973]                           restarts <- computeRestarts(cond)
[09:32:24.973]                           for (restart in restarts) {
[09:32:24.973]                             name <- restart$name
[09:32:24.973]                             if (is.null(name)) 
[09:32:24.973]                               next
[09:32:24.973]                             if (!grepl(pattern, name)) 
[09:32:24.973]                               next
[09:32:24.973]                             invokeRestart(restart)
[09:32:24.973]                             muffled <- TRUE
[09:32:24.973]                             break
[09:32:24.973]                           }
[09:32:24.973]                         }
[09:32:24.973]                       }
[09:32:24.973]                       invisible(muffled)
[09:32:24.973]                     }
[09:32:24.973]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.973]                   }
[09:32:24.973]                 }
[09:32:24.973]             }
[09:32:24.973]         }))
[09:32:24.973]     }, error = function(ex) {
[09:32:24.973]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:24.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.973]                 ...future.rng), started = ...future.startTime, 
[09:32:24.973]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:24.973]             version = "1.8"), class = "FutureResult")
[09:32:24.973]     }, finally = {
[09:32:24.973]         if (!identical(...future.workdir, getwd())) 
[09:32:24.973]             setwd(...future.workdir)
[09:32:24.973]         {
[09:32:24.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:24.973]                 ...future.oldOptions$nwarnings <- NULL
[09:32:24.973]             }
[09:32:24.973]             base::options(...future.oldOptions)
[09:32:24.973]             if (.Platform$OS.type == "windows") {
[09:32:24.973]                 old_names <- names(...future.oldEnvVars)
[09:32:24.973]                 envs <- base::Sys.getenv()
[09:32:24.973]                 names <- names(envs)
[09:32:24.973]                 common <- intersect(names, old_names)
[09:32:24.973]                 added <- setdiff(names, old_names)
[09:32:24.973]                 removed <- setdiff(old_names, names)
[09:32:24.973]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:24.973]                   envs[common]]
[09:32:24.973]                 NAMES <- toupper(changed)
[09:32:24.973]                 args <- list()
[09:32:24.973]                 for (kk in seq_along(NAMES)) {
[09:32:24.973]                   name <- changed[[kk]]
[09:32:24.973]                   NAME <- NAMES[[kk]]
[09:32:24.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.973]                     next
[09:32:24.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.973]                 }
[09:32:24.973]                 NAMES <- toupper(added)
[09:32:24.973]                 for (kk in seq_along(NAMES)) {
[09:32:24.973]                   name <- added[[kk]]
[09:32:24.973]                   NAME <- NAMES[[kk]]
[09:32:24.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.973]                     next
[09:32:24.973]                   args[[name]] <- ""
[09:32:24.973]                 }
[09:32:24.973]                 NAMES <- toupper(removed)
[09:32:24.973]                 for (kk in seq_along(NAMES)) {
[09:32:24.973]                   name <- removed[[kk]]
[09:32:24.973]                   NAME <- NAMES[[kk]]
[09:32:24.973]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.973]                     next
[09:32:24.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.973]                 }
[09:32:24.973]                 if (length(args) > 0) 
[09:32:24.973]                   base::do.call(base::Sys.setenv, args = args)
[09:32:24.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:24.973]             }
[09:32:24.973]             else {
[09:32:24.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:24.973]             }
[09:32:24.973]             {
[09:32:24.973]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:24.973]                   0L) {
[09:32:24.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:24.973]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:24.973]                   base::options(opts)
[09:32:24.973]                 }
[09:32:24.973]                 {
[09:32:24.973]                   {
[09:32:24.973]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:24.973]                     NULL
[09:32:24.973]                   }
[09:32:24.973]                   options(future.plan = NULL)
[09:32:24.973]                   if (is.na(NA_character_)) 
[09:32:24.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:24.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:24.973]                     .init = FALSE)
[09:32:24.973]                 }
[09:32:24.973]             }
[09:32:24.973]         }
[09:32:24.973]     })
[09:32:24.973]     if (TRUE) {
[09:32:24.973]         base::sink(type = "output", split = FALSE)
[09:32:24.973]         if (TRUE) {
[09:32:24.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:24.973]         }
[09:32:24.973]         else {
[09:32:24.973]             ...future.result["stdout"] <- base::list(NULL)
[09:32:24.973]         }
[09:32:24.973]         base::close(...future.stdout)
[09:32:24.973]         ...future.stdout <- NULL
[09:32:24.973]     }
[09:32:24.973]     ...future.result$conditions <- ...future.conditions
[09:32:24.973]     ...future.result$finished <- base::Sys.time()
[09:32:24.973]     ...future.result
[09:32:24.973] }
[09:32:24.975] MultisessionFuture started
[09:32:24.976] - Launch lazy future ... done
[09:32:24.976] run() for ‘MultisessionFuture’ ... done
[09:32:24.976] getGlobalsAndPackages() ...
[09:32:24.976] Searching for globals...
[09:32:24.977] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:24.977] Searching for globals ... DONE
[09:32:24.977] Resolving globals: FALSE
[09:32:24.977] 
[09:32:24.978] 
[09:32:24.978] getGlobalsAndPackages() ... DONE
- w/ exception ...
[09:32:24.978] getGlobalsAndPackages() ...
[09:32:24.978] Searching for globals...
[09:32:24.979] - globals found: [2] ‘list’, ‘stop’
[09:32:24.979] Searching for globals ... DONE
[09:32:24.979] Resolving globals: FALSE
[09:32:24.979] 
[09:32:24.979] 
[09:32:24.979] getGlobalsAndPackages() ... DONE
[09:32:24.979] run() for ‘Future’ ...
[09:32:24.979] - state: ‘created’
[09:32:24.980] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:24.994] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:24.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:24.995]   - Field: ‘node’
[09:32:24.995]   - Field: ‘label’
[09:32:24.995]   - Field: ‘local’
[09:32:24.995]   - Field: ‘owner’
[09:32:24.995]   - Field: ‘envir’
[09:32:24.995]   - Field: ‘workers’
[09:32:24.995]   - Field: ‘packages’
[09:32:24.995]   - Field: ‘gc’
[09:32:24.996]   - Field: ‘conditions’
[09:32:24.996]   - Field: ‘persistent’
[09:32:24.996]   - Field: ‘expr’
[09:32:24.996]   - Field: ‘uuid’
[09:32:24.996]   - Field: ‘seed’
[09:32:24.996]   - Field: ‘version’
[09:32:24.996]   - Field: ‘result’
[09:32:24.997]   - Field: ‘asynchronous’
[09:32:24.997]   - Field: ‘calls’
[09:32:24.997]   - Field: ‘globals’
[09:32:24.997]   - Field: ‘stdout’
[09:32:24.997]   - Field: ‘earlySignal’
[09:32:24.997]   - Field: ‘lazy’
[09:32:24.997]   - Field: ‘state’
[09:32:24.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:24.998] - Launch lazy future ...
[09:32:24.998] Packages needed by the future expression (n = 0): <none>
[09:32:24.998] Packages needed by future strategies (n = 0): <none>
[09:32:24.999] {
[09:32:24.999]     {
[09:32:24.999]         {
[09:32:24.999]             ...future.startTime <- base::Sys.time()
[09:32:24.999]             {
[09:32:24.999]                 {
[09:32:24.999]                   {
[09:32:24.999]                     {
[09:32:24.999]                       base::local({
[09:32:24.999]                         has_future <- base::requireNamespace("future", 
[09:32:24.999]                           quietly = TRUE)
[09:32:24.999]                         if (has_future) {
[09:32:24.999]                           ns <- base::getNamespace("future")
[09:32:24.999]                           version <- ns[[".package"]][["version"]]
[09:32:24.999]                           if (is.null(version)) 
[09:32:24.999]                             version <- utils::packageVersion("future")
[09:32:24.999]                         }
[09:32:24.999]                         else {
[09:32:24.999]                           version <- NULL
[09:32:24.999]                         }
[09:32:24.999]                         if (!has_future || version < "1.8.0") {
[09:32:24.999]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:24.999]                             "", base::R.version$version.string), 
[09:32:24.999]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:24.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:24.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:24.999]                               "release", "version")], collapse = " "), 
[09:32:24.999]                             hostname = base::Sys.info()[["nodename"]])
[09:32:24.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:24.999]                             info)
[09:32:24.999]                           info <- base::paste(info, collapse = "; ")
[09:32:24.999]                           if (!has_future) {
[09:32:24.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:24.999]                               info)
[09:32:24.999]                           }
[09:32:24.999]                           else {
[09:32:24.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:24.999]                               info, version)
[09:32:24.999]                           }
[09:32:24.999]                           base::stop(msg)
[09:32:24.999]                         }
[09:32:24.999]                       })
[09:32:24.999]                     }
[09:32:24.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:24.999]                     base::options(mc.cores = 1L)
[09:32:24.999]                   }
[09:32:24.999]                   ...future.strategy.old <- future::plan("list")
[09:32:24.999]                   options(future.plan = NULL)
[09:32:24.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:24.999]                 }
[09:32:24.999]                 ...future.workdir <- getwd()
[09:32:24.999]             }
[09:32:24.999]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:24.999]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:24.999]         }
[09:32:24.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:24.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:24.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:24.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:24.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:24.999]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:24.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:24.999]             base::names(...future.oldOptions))
[09:32:24.999]     }
[09:32:24.999]     if (FALSE) {
[09:32:24.999]     }
[09:32:24.999]     else {
[09:32:24.999]         if (TRUE) {
[09:32:24.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:24.999]                 open = "w")
[09:32:24.999]         }
[09:32:24.999]         else {
[09:32:24.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:24.999]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:24.999]         }
[09:32:24.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:24.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:24.999]             base::sink(type = "output", split = FALSE)
[09:32:24.999]             base::close(...future.stdout)
[09:32:24.999]         }, add = TRUE)
[09:32:24.999]     }
[09:32:24.999]     ...future.frame <- base::sys.nframe()
[09:32:24.999]     ...future.conditions <- base::list()
[09:32:24.999]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:24.999]     if (FALSE) {
[09:32:24.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:24.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:24.999]     }
[09:32:24.999]     ...future.result <- base::tryCatch({
[09:32:24.999]         base::withCallingHandlers({
[09:32:24.999]             ...future.value <- base::withVisible(base::local({
[09:32:24.999]                 ...future.makeSendCondition <- base::local({
[09:32:24.999]                   sendCondition <- NULL
[09:32:24.999]                   function(frame = 1L) {
[09:32:24.999]                     if (is.function(sendCondition)) 
[09:32:24.999]                       return(sendCondition)
[09:32:24.999]                     ns <- getNamespace("parallel")
[09:32:24.999]                     if (exists("sendData", mode = "function", 
[09:32:24.999]                       envir = ns)) {
[09:32:24.999]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:24.999]                         envir = ns)
[09:32:24.999]                       envir <- sys.frame(frame)
[09:32:24.999]                       master <- NULL
[09:32:24.999]                       while (!identical(envir, .GlobalEnv) && 
[09:32:24.999]                         !identical(envir, emptyenv())) {
[09:32:24.999]                         if (exists("master", mode = "list", envir = envir, 
[09:32:24.999]                           inherits = FALSE)) {
[09:32:24.999]                           master <- get("master", mode = "list", 
[09:32:24.999]                             envir = envir, inherits = FALSE)
[09:32:24.999]                           if (inherits(master, c("SOCKnode", 
[09:32:24.999]                             "SOCK0node"))) {
[09:32:24.999]                             sendCondition <<- function(cond) {
[09:32:24.999]                               data <- list(type = "VALUE", value = cond, 
[09:32:24.999]                                 success = TRUE)
[09:32:24.999]                               parallel_sendData(master, data)
[09:32:24.999]                             }
[09:32:24.999]                             return(sendCondition)
[09:32:24.999]                           }
[09:32:24.999]                         }
[09:32:24.999]                         frame <- frame + 1L
[09:32:24.999]                         envir <- sys.frame(frame)
[09:32:24.999]                       }
[09:32:24.999]                     }
[09:32:24.999]                     sendCondition <<- function(cond) NULL
[09:32:24.999]                   }
[09:32:24.999]                 })
[09:32:24.999]                 withCallingHandlers({
[09:32:24.999]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:24.999]                 }, immediateCondition = function(cond) {
[09:32:24.999]                   sendCondition <- ...future.makeSendCondition()
[09:32:24.999]                   sendCondition(cond)
[09:32:24.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.999]                   {
[09:32:24.999]                     inherits <- base::inherits
[09:32:24.999]                     invokeRestart <- base::invokeRestart
[09:32:24.999]                     is.null <- base::is.null
[09:32:24.999]                     muffled <- FALSE
[09:32:24.999]                     if (inherits(cond, "message")) {
[09:32:24.999]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:24.999]                       if (muffled) 
[09:32:24.999]                         invokeRestart("muffleMessage")
[09:32:24.999]                     }
[09:32:24.999]                     else if (inherits(cond, "warning")) {
[09:32:24.999]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:24.999]                       if (muffled) 
[09:32:24.999]                         invokeRestart("muffleWarning")
[09:32:24.999]                     }
[09:32:24.999]                     else if (inherits(cond, "condition")) {
[09:32:24.999]                       if (!is.null(pattern)) {
[09:32:24.999]                         computeRestarts <- base::computeRestarts
[09:32:24.999]                         grepl <- base::grepl
[09:32:24.999]                         restarts <- computeRestarts(cond)
[09:32:24.999]                         for (restart in restarts) {
[09:32:24.999]                           name <- restart$name
[09:32:24.999]                           if (is.null(name)) 
[09:32:24.999]                             next
[09:32:24.999]                           if (!grepl(pattern, name)) 
[09:32:24.999]                             next
[09:32:24.999]                           invokeRestart(restart)
[09:32:24.999]                           muffled <- TRUE
[09:32:24.999]                           break
[09:32:24.999]                         }
[09:32:24.999]                       }
[09:32:24.999]                     }
[09:32:24.999]                     invisible(muffled)
[09:32:24.999]                   }
[09:32:24.999]                   muffleCondition(cond)
[09:32:24.999]                 })
[09:32:24.999]             }))
[09:32:24.999]             future::FutureResult(value = ...future.value$value, 
[09:32:24.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.999]                   ...future.rng), globalenv = if (FALSE) 
[09:32:24.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:24.999]                     ...future.globalenv.names))
[09:32:24.999]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:24.999]         }, condition = base::local({
[09:32:24.999]             c <- base::c
[09:32:24.999]             inherits <- base::inherits
[09:32:24.999]             invokeRestart <- base::invokeRestart
[09:32:24.999]             length <- base::length
[09:32:24.999]             list <- base::list
[09:32:24.999]             seq.int <- base::seq.int
[09:32:24.999]             signalCondition <- base::signalCondition
[09:32:24.999]             sys.calls <- base::sys.calls
[09:32:24.999]             `[[` <- base::`[[`
[09:32:24.999]             `+` <- base::`+`
[09:32:24.999]             `<<-` <- base::`<<-`
[09:32:24.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:24.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:24.999]                   3L)]
[09:32:24.999]             }
[09:32:24.999]             function(cond) {
[09:32:24.999]                 is_error <- inherits(cond, "error")
[09:32:24.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:24.999]                   NULL)
[09:32:24.999]                 if (is_error) {
[09:32:24.999]                   sessionInformation <- function() {
[09:32:24.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:24.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:24.999]                       search = base::search(), system = base::Sys.info())
[09:32:24.999]                   }
[09:32:24.999]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:24.999]                     cond$call), session = sessionInformation(), 
[09:32:24.999]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:24.999]                   signalCondition(cond)
[09:32:24.999]                 }
[09:32:24.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:24.999]                 "immediateCondition"))) {
[09:32:24.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:24.999]                   ...future.conditions[[length(...future.conditions) + 
[09:32:24.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:24.999]                   if (TRUE && !signal) {
[09:32:24.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.999]                     {
[09:32:24.999]                       inherits <- base::inherits
[09:32:24.999]                       invokeRestart <- base::invokeRestart
[09:32:24.999]                       is.null <- base::is.null
[09:32:24.999]                       muffled <- FALSE
[09:32:24.999]                       if (inherits(cond, "message")) {
[09:32:24.999]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.999]                         if (muffled) 
[09:32:24.999]                           invokeRestart("muffleMessage")
[09:32:24.999]                       }
[09:32:24.999]                       else if (inherits(cond, "warning")) {
[09:32:24.999]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.999]                         if (muffled) 
[09:32:24.999]                           invokeRestart("muffleWarning")
[09:32:24.999]                       }
[09:32:24.999]                       else if (inherits(cond, "condition")) {
[09:32:24.999]                         if (!is.null(pattern)) {
[09:32:24.999]                           computeRestarts <- base::computeRestarts
[09:32:24.999]                           grepl <- base::grepl
[09:32:24.999]                           restarts <- computeRestarts(cond)
[09:32:24.999]                           for (restart in restarts) {
[09:32:24.999]                             name <- restart$name
[09:32:24.999]                             if (is.null(name)) 
[09:32:24.999]                               next
[09:32:24.999]                             if (!grepl(pattern, name)) 
[09:32:24.999]                               next
[09:32:24.999]                             invokeRestart(restart)
[09:32:24.999]                             muffled <- TRUE
[09:32:24.999]                             break
[09:32:24.999]                           }
[09:32:24.999]                         }
[09:32:24.999]                       }
[09:32:24.999]                       invisible(muffled)
[09:32:24.999]                     }
[09:32:24.999]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.999]                   }
[09:32:24.999]                 }
[09:32:24.999]                 else {
[09:32:24.999]                   if (TRUE) {
[09:32:24.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:24.999]                     {
[09:32:24.999]                       inherits <- base::inherits
[09:32:24.999]                       invokeRestart <- base::invokeRestart
[09:32:24.999]                       is.null <- base::is.null
[09:32:24.999]                       muffled <- FALSE
[09:32:24.999]                       if (inherits(cond, "message")) {
[09:32:24.999]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:24.999]                         if (muffled) 
[09:32:24.999]                           invokeRestart("muffleMessage")
[09:32:24.999]                       }
[09:32:24.999]                       else if (inherits(cond, "warning")) {
[09:32:24.999]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:24.999]                         if (muffled) 
[09:32:24.999]                           invokeRestart("muffleWarning")
[09:32:24.999]                       }
[09:32:24.999]                       else if (inherits(cond, "condition")) {
[09:32:24.999]                         if (!is.null(pattern)) {
[09:32:24.999]                           computeRestarts <- base::computeRestarts
[09:32:24.999]                           grepl <- base::grepl
[09:32:24.999]                           restarts <- computeRestarts(cond)
[09:32:24.999]                           for (restart in restarts) {
[09:32:24.999]                             name <- restart$name
[09:32:24.999]                             if (is.null(name)) 
[09:32:24.999]                               next
[09:32:24.999]                             if (!grepl(pattern, name)) 
[09:32:24.999]                               next
[09:32:24.999]                             invokeRestart(restart)
[09:32:24.999]                             muffled <- TRUE
[09:32:24.999]                             break
[09:32:24.999]                           }
[09:32:24.999]                         }
[09:32:24.999]                       }
[09:32:24.999]                       invisible(muffled)
[09:32:24.999]                     }
[09:32:24.999]                     muffleCondition(cond, pattern = "^muffle")
[09:32:24.999]                   }
[09:32:24.999]                 }
[09:32:24.999]             }
[09:32:24.999]         }))
[09:32:24.999]     }, error = function(ex) {
[09:32:24.999]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:24.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:24.999]                 ...future.rng), started = ...future.startTime, 
[09:32:24.999]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:24.999]             version = "1.8"), class = "FutureResult")
[09:32:24.999]     }, finally = {
[09:32:24.999]         if (!identical(...future.workdir, getwd())) 
[09:32:24.999]             setwd(...future.workdir)
[09:32:24.999]         {
[09:32:24.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:24.999]                 ...future.oldOptions$nwarnings <- NULL
[09:32:24.999]             }
[09:32:24.999]             base::options(...future.oldOptions)
[09:32:24.999]             if (.Platform$OS.type == "windows") {
[09:32:24.999]                 old_names <- names(...future.oldEnvVars)
[09:32:24.999]                 envs <- base::Sys.getenv()
[09:32:24.999]                 names <- names(envs)
[09:32:24.999]                 common <- intersect(names, old_names)
[09:32:24.999]                 added <- setdiff(names, old_names)
[09:32:24.999]                 removed <- setdiff(old_names, names)
[09:32:24.999]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:24.999]                   envs[common]]
[09:32:24.999]                 NAMES <- toupper(changed)
[09:32:24.999]                 args <- list()
[09:32:24.999]                 for (kk in seq_along(NAMES)) {
[09:32:24.999]                   name <- changed[[kk]]
[09:32:24.999]                   NAME <- NAMES[[kk]]
[09:32:24.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.999]                     next
[09:32:24.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.999]                 }
[09:32:24.999]                 NAMES <- toupper(added)
[09:32:24.999]                 for (kk in seq_along(NAMES)) {
[09:32:24.999]                   name <- added[[kk]]
[09:32:24.999]                   NAME <- NAMES[[kk]]
[09:32:24.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.999]                     next
[09:32:24.999]                   args[[name]] <- ""
[09:32:24.999]                 }
[09:32:24.999]                 NAMES <- toupper(removed)
[09:32:24.999]                 for (kk in seq_along(NAMES)) {
[09:32:24.999]                   name <- removed[[kk]]
[09:32:24.999]                   NAME <- NAMES[[kk]]
[09:32:24.999]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:24.999]                     next
[09:32:24.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:24.999]                 }
[09:32:24.999]                 if (length(args) > 0) 
[09:32:24.999]                   base::do.call(base::Sys.setenv, args = args)
[09:32:24.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:24.999]             }
[09:32:24.999]             else {
[09:32:24.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:24.999]             }
[09:32:24.999]             {
[09:32:24.999]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:24.999]                   0L) {
[09:32:24.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:24.999]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:24.999]                   base::options(opts)
[09:32:24.999]                 }
[09:32:24.999]                 {
[09:32:24.999]                   {
[09:32:24.999]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:24.999]                     NULL
[09:32:24.999]                   }
[09:32:24.999]                   options(future.plan = NULL)
[09:32:24.999]                   if (is.na(NA_character_)) 
[09:32:24.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:24.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:24.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:24.999]                     .init = FALSE)
[09:32:24.999]                 }
[09:32:24.999]             }
[09:32:24.999]         }
[09:32:24.999]     })
[09:32:24.999]     if (TRUE) {
[09:32:24.999]         base::sink(type = "output", split = FALSE)
[09:32:24.999]         if (TRUE) {
[09:32:24.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:24.999]         }
[09:32:24.999]         else {
[09:32:24.999]             ...future.result["stdout"] <- base::list(NULL)
[09:32:24.999]         }
[09:32:24.999]         base::close(...future.stdout)
[09:32:24.999]         ...future.stdout <- NULL
[09:32:24.999]     }
[09:32:24.999]     ...future.result$conditions <- ...future.conditions
[09:32:24.999]     ...future.result$finished <- base::Sys.time()
[09:32:24.999]     ...future.result
[09:32:24.999] }
[09:32:25.072] MultisessionFuture started
[09:32:25.072] - Launch lazy future ... done
[09:32:25.072] run() for ‘MultisessionFuture’ ... done
[09:32:25.073] getGlobalsAndPackages() ...
[09:32:25.073] Searching for globals...
[09:32:25.074] - globals found: [2] ‘list’, ‘stop’
[09:32:25.074] Searching for globals ... DONE
[09:32:25.074] Resolving globals: FALSE
[09:32:25.075] 
[09:32:25.075] 
[09:32:25.075] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[09:32:25.076] getGlobalsAndPackages() ...
[09:32:25.076] Searching for globals...
[09:32:25.077] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:25.078] Searching for globals ... DONE
[09:32:25.078] Resolving globals: FALSE
[09:32:25.078] 
[09:32:25.078] 
[09:32:25.079] getGlobalsAndPackages() ... DONE
[09:32:25.079] run() for ‘Future’ ...
[09:32:25.079] - state: ‘created’
[09:32:25.079] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:25.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:25.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:25.097]   - Field: ‘node’
[09:32:25.097]   - Field: ‘label’
[09:32:25.097]   - Field: ‘local’
[09:32:25.097]   - Field: ‘owner’
[09:32:25.097]   - Field: ‘envir’
[09:32:25.097]   - Field: ‘workers’
[09:32:25.098]   - Field: ‘packages’
[09:32:25.098]   - Field: ‘gc’
[09:32:25.098]   - Field: ‘conditions’
[09:32:25.098]   - Field: ‘persistent’
[09:32:25.098]   - Field: ‘expr’
[09:32:25.098]   - Field: ‘uuid’
[09:32:25.099]   - Field: ‘seed’
[09:32:25.099]   - Field: ‘version’
[09:32:25.099]   - Field: ‘result’
[09:32:25.099]   - Field: ‘asynchronous’
[09:32:25.099]   - Field: ‘calls’
[09:32:25.099]   - Field: ‘globals’
[09:32:25.099]   - Field: ‘stdout’
[09:32:25.100]   - Field: ‘earlySignal’
[09:32:25.100]   - Field: ‘lazy’
[09:32:25.100]   - Field: ‘state’
[09:32:25.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:25.100] - Launch lazy future ...
[09:32:25.101] Packages needed by the future expression (n = 0): <none>
[09:32:25.101] Packages needed by future strategies (n = 0): <none>
[09:32:25.102] {
[09:32:25.102]     {
[09:32:25.102]         {
[09:32:25.102]             ...future.startTime <- base::Sys.time()
[09:32:25.102]             {
[09:32:25.102]                 {
[09:32:25.102]                   {
[09:32:25.102]                     {
[09:32:25.102]                       base::local({
[09:32:25.102]                         has_future <- base::requireNamespace("future", 
[09:32:25.102]                           quietly = TRUE)
[09:32:25.102]                         if (has_future) {
[09:32:25.102]                           ns <- base::getNamespace("future")
[09:32:25.102]                           version <- ns[[".package"]][["version"]]
[09:32:25.102]                           if (is.null(version)) 
[09:32:25.102]                             version <- utils::packageVersion("future")
[09:32:25.102]                         }
[09:32:25.102]                         else {
[09:32:25.102]                           version <- NULL
[09:32:25.102]                         }
[09:32:25.102]                         if (!has_future || version < "1.8.0") {
[09:32:25.102]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:25.102]                             "", base::R.version$version.string), 
[09:32:25.102]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:25.102]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:25.102]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:25.102]                               "release", "version")], collapse = " "), 
[09:32:25.102]                             hostname = base::Sys.info()[["nodename"]])
[09:32:25.102]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:25.102]                             info)
[09:32:25.102]                           info <- base::paste(info, collapse = "; ")
[09:32:25.102]                           if (!has_future) {
[09:32:25.102]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:25.102]                               info)
[09:32:25.102]                           }
[09:32:25.102]                           else {
[09:32:25.102]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:25.102]                               info, version)
[09:32:25.102]                           }
[09:32:25.102]                           base::stop(msg)
[09:32:25.102]                         }
[09:32:25.102]                       })
[09:32:25.102]                     }
[09:32:25.102]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:25.102]                     base::options(mc.cores = 1L)
[09:32:25.102]                   }
[09:32:25.102]                   ...future.strategy.old <- future::plan("list")
[09:32:25.102]                   options(future.plan = NULL)
[09:32:25.102]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:25.102]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:25.102]                 }
[09:32:25.102]                 ...future.workdir <- getwd()
[09:32:25.102]             }
[09:32:25.102]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:25.102]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:25.102]         }
[09:32:25.102]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:25.102]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:25.102]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:25.102]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:25.102]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:25.102]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:25.102]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:25.102]             base::names(...future.oldOptions))
[09:32:25.102]     }
[09:32:25.102]     if (FALSE) {
[09:32:25.102]     }
[09:32:25.102]     else {
[09:32:25.102]         if (TRUE) {
[09:32:25.102]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:25.102]                 open = "w")
[09:32:25.102]         }
[09:32:25.102]         else {
[09:32:25.102]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:25.102]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:25.102]         }
[09:32:25.102]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:25.102]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:25.102]             base::sink(type = "output", split = FALSE)
[09:32:25.102]             base::close(...future.stdout)
[09:32:25.102]         }, add = TRUE)
[09:32:25.102]     }
[09:32:25.102]     ...future.frame <- base::sys.nframe()
[09:32:25.102]     ...future.conditions <- base::list()
[09:32:25.102]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:25.102]     if (FALSE) {
[09:32:25.102]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:25.102]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:25.102]     }
[09:32:25.102]     ...future.result <- base::tryCatch({
[09:32:25.102]         base::withCallingHandlers({
[09:32:25.102]             ...future.value <- base::withVisible(base::local({
[09:32:25.102]                 ...future.makeSendCondition <- base::local({
[09:32:25.102]                   sendCondition <- NULL
[09:32:25.102]                   function(frame = 1L) {
[09:32:25.102]                     if (is.function(sendCondition)) 
[09:32:25.102]                       return(sendCondition)
[09:32:25.102]                     ns <- getNamespace("parallel")
[09:32:25.102]                     if (exists("sendData", mode = "function", 
[09:32:25.102]                       envir = ns)) {
[09:32:25.102]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:25.102]                         envir = ns)
[09:32:25.102]                       envir <- sys.frame(frame)
[09:32:25.102]                       master <- NULL
[09:32:25.102]                       while (!identical(envir, .GlobalEnv) && 
[09:32:25.102]                         !identical(envir, emptyenv())) {
[09:32:25.102]                         if (exists("master", mode = "list", envir = envir, 
[09:32:25.102]                           inherits = FALSE)) {
[09:32:25.102]                           master <- get("master", mode = "list", 
[09:32:25.102]                             envir = envir, inherits = FALSE)
[09:32:25.102]                           if (inherits(master, c("SOCKnode", 
[09:32:25.102]                             "SOCK0node"))) {
[09:32:25.102]                             sendCondition <<- function(cond) {
[09:32:25.102]                               data <- list(type = "VALUE", value = cond, 
[09:32:25.102]                                 success = TRUE)
[09:32:25.102]                               parallel_sendData(master, data)
[09:32:25.102]                             }
[09:32:25.102]                             return(sendCondition)
[09:32:25.102]                           }
[09:32:25.102]                         }
[09:32:25.102]                         frame <- frame + 1L
[09:32:25.102]                         envir <- sys.frame(frame)
[09:32:25.102]                       }
[09:32:25.102]                     }
[09:32:25.102]                     sendCondition <<- function(cond) NULL
[09:32:25.102]                   }
[09:32:25.102]                 })
[09:32:25.102]                 withCallingHandlers({
[09:32:25.102]                   {
[09:32:25.102]                     Sys.sleep(0.5)
[09:32:25.102]                     list(a = 1, b = 42L)
[09:32:25.102]                   }
[09:32:25.102]                 }, immediateCondition = function(cond) {
[09:32:25.102]                   sendCondition <- ...future.makeSendCondition()
[09:32:25.102]                   sendCondition(cond)
[09:32:25.102]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.102]                   {
[09:32:25.102]                     inherits <- base::inherits
[09:32:25.102]                     invokeRestart <- base::invokeRestart
[09:32:25.102]                     is.null <- base::is.null
[09:32:25.102]                     muffled <- FALSE
[09:32:25.102]                     if (inherits(cond, "message")) {
[09:32:25.102]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:25.102]                       if (muffled) 
[09:32:25.102]                         invokeRestart("muffleMessage")
[09:32:25.102]                     }
[09:32:25.102]                     else if (inherits(cond, "warning")) {
[09:32:25.102]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:25.102]                       if (muffled) 
[09:32:25.102]                         invokeRestart("muffleWarning")
[09:32:25.102]                     }
[09:32:25.102]                     else if (inherits(cond, "condition")) {
[09:32:25.102]                       if (!is.null(pattern)) {
[09:32:25.102]                         computeRestarts <- base::computeRestarts
[09:32:25.102]                         grepl <- base::grepl
[09:32:25.102]                         restarts <- computeRestarts(cond)
[09:32:25.102]                         for (restart in restarts) {
[09:32:25.102]                           name <- restart$name
[09:32:25.102]                           if (is.null(name)) 
[09:32:25.102]                             next
[09:32:25.102]                           if (!grepl(pattern, name)) 
[09:32:25.102]                             next
[09:32:25.102]                           invokeRestart(restart)
[09:32:25.102]                           muffled <- TRUE
[09:32:25.102]                           break
[09:32:25.102]                         }
[09:32:25.102]                       }
[09:32:25.102]                     }
[09:32:25.102]                     invisible(muffled)
[09:32:25.102]                   }
[09:32:25.102]                   muffleCondition(cond)
[09:32:25.102]                 })
[09:32:25.102]             }))
[09:32:25.102]             future::FutureResult(value = ...future.value$value, 
[09:32:25.102]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:25.102]                   ...future.rng), globalenv = if (FALSE) 
[09:32:25.102]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:25.102]                     ...future.globalenv.names))
[09:32:25.102]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:25.102]         }, condition = base::local({
[09:32:25.102]             c <- base::c
[09:32:25.102]             inherits <- base::inherits
[09:32:25.102]             invokeRestart <- base::invokeRestart
[09:32:25.102]             length <- base::length
[09:32:25.102]             list <- base::list
[09:32:25.102]             seq.int <- base::seq.int
[09:32:25.102]             signalCondition <- base::signalCondition
[09:32:25.102]             sys.calls <- base::sys.calls
[09:32:25.102]             `[[` <- base::`[[`
[09:32:25.102]             `+` <- base::`+`
[09:32:25.102]             `<<-` <- base::`<<-`
[09:32:25.102]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:25.102]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:25.102]                   3L)]
[09:32:25.102]             }
[09:32:25.102]             function(cond) {
[09:32:25.102]                 is_error <- inherits(cond, "error")
[09:32:25.102]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:25.102]                   NULL)
[09:32:25.102]                 if (is_error) {
[09:32:25.102]                   sessionInformation <- function() {
[09:32:25.102]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:25.102]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:25.102]                       search = base::search(), system = base::Sys.info())
[09:32:25.102]                   }
[09:32:25.102]                   ...future.conditions[[length(...future.conditions) + 
[09:32:25.102]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:25.102]                     cond$call), session = sessionInformation(), 
[09:32:25.102]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:25.102]                   signalCondition(cond)
[09:32:25.102]                 }
[09:32:25.102]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:25.102]                 "immediateCondition"))) {
[09:32:25.102]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:25.102]                   ...future.conditions[[length(...future.conditions) + 
[09:32:25.102]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:25.102]                   if (TRUE && !signal) {
[09:32:25.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.102]                     {
[09:32:25.102]                       inherits <- base::inherits
[09:32:25.102]                       invokeRestart <- base::invokeRestart
[09:32:25.102]                       is.null <- base::is.null
[09:32:25.102]                       muffled <- FALSE
[09:32:25.102]                       if (inherits(cond, "message")) {
[09:32:25.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:25.102]                         if (muffled) 
[09:32:25.102]                           invokeRestart("muffleMessage")
[09:32:25.102]                       }
[09:32:25.102]                       else if (inherits(cond, "warning")) {
[09:32:25.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:25.102]                         if (muffled) 
[09:32:25.102]                           invokeRestart("muffleWarning")
[09:32:25.102]                       }
[09:32:25.102]                       else if (inherits(cond, "condition")) {
[09:32:25.102]                         if (!is.null(pattern)) {
[09:32:25.102]                           computeRestarts <- base::computeRestarts
[09:32:25.102]                           grepl <- base::grepl
[09:32:25.102]                           restarts <- computeRestarts(cond)
[09:32:25.102]                           for (restart in restarts) {
[09:32:25.102]                             name <- restart$name
[09:32:25.102]                             if (is.null(name)) 
[09:32:25.102]                               next
[09:32:25.102]                             if (!grepl(pattern, name)) 
[09:32:25.102]                               next
[09:32:25.102]                             invokeRestart(restart)
[09:32:25.102]                             muffled <- TRUE
[09:32:25.102]                             break
[09:32:25.102]                           }
[09:32:25.102]                         }
[09:32:25.102]                       }
[09:32:25.102]                       invisible(muffled)
[09:32:25.102]                     }
[09:32:25.102]                     muffleCondition(cond, pattern = "^muffle")
[09:32:25.102]                   }
[09:32:25.102]                 }
[09:32:25.102]                 else {
[09:32:25.102]                   if (TRUE) {
[09:32:25.102]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.102]                     {
[09:32:25.102]                       inherits <- base::inherits
[09:32:25.102]                       invokeRestart <- base::invokeRestart
[09:32:25.102]                       is.null <- base::is.null
[09:32:25.102]                       muffled <- FALSE
[09:32:25.102]                       if (inherits(cond, "message")) {
[09:32:25.102]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:25.102]                         if (muffled) 
[09:32:25.102]                           invokeRestart("muffleMessage")
[09:32:25.102]                       }
[09:32:25.102]                       else if (inherits(cond, "warning")) {
[09:32:25.102]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:25.102]                         if (muffled) 
[09:32:25.102]                           invokeRestart("muffleWarning")
[09:32:25.102]                       }
[09:32:25.102]                       else if (inherits(cond, "condition")) {
[09:32:25.102]                         if (!is.null(pattern)) {
[09:32:25.102]                           computeRestarts <- base::computeRestarts
[09:32:25.102]                           grepl <- base::grepl
[09:32:25.102]                           restarts <- computeRestarts(cond)
[09:32:25.102]                           for (restart in restarts) {
[09:32:25.102]                             name <- restart$name
[09:32:25.102]                             if (is.null(name)) 
[09:32:25.102]                               next
[09:32:25.102]                             if (!grepl(pattern, name)) 
[09:32:25.102]                               next
[09:32:25.102]                             invokeRestart(restart)
[09:32:25.102]                             muffled <- TRUE
[09:32:25.102]                             break
[09:32:25.102]                           }
[09:32:25.102]                         }
[09:32:25.102]                       }
[09:32:25.102]                       invisible(muffled)
[09:32:25.102]                     }
[09:32:25.102]                     muffleCondition(cond, pattern = "^muffle")
[09:32:25.102]                   }
[09:32:25.102]                 }
[09:32:25.102]             }
[09:32:25.102]         }))
[09:32:25.102]     }, error = function(ex) {
[09:32:25.102]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:25.102]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:25.102]                 ...future.rng), started = ...future.startTime, 
[09:32:25.102]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:25.102]             version = "1.8"), class = "FutureResult")
[09:32:25.102]     }, finally = {
[09:32:25.102]         if (!identical(...future.workdir, getwd())) 
[09:32:25.102]             setwd(...future.workdir)
[09:32:25.102]         {
[09:32:25.102]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:25.102]                 ...future.oldOptions$nwarnings <- NULL
[09:32:25.102]             }
[09:32:25.102]             base::options(...future.oldOptions)
[09:32:25.102]             if (.Platform$OS.type == "windows") {
[09:32:25.102]                 old_names <- names(...future.oldEnvVars)
[09:32:25.102]                 envs <- base::Sys.getenv()
[09:32:25.102]                 names <- names(envs)
[09:32:25.102]                 common <- intersect(names, old_names)
[09:32:25.102]                 added <- setdiff(names, old_names)
[09:32:25.102]                 removed <- setdiff(old_names, names)
[09:32:25.102]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:25.102]                   envs[common]]
[09:32:25.102]                 NAMES <- toupper(changed)
[09:32:25.102]                 args <- list()
[09:32:25.102]                 for (kk in seq_along(NAMES)) {
[09:32:25.102]                   name <- changed[[kk]]
[09:32:25.102]                   NAME <- NAMES[[kk]]
[09:32:25.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.102]                     next
[09:32:25.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:25.102]                 }
[09:32:25.102]                 NAMES <- toupper(added)
[09:32:25.102]                 for (kk in seq_along(NAMES)) {
[09:32:25.102]                   name <- added[[kk]]
[09:32:25.102]                   NAME <- NAMES[[kk]]
[09:32:25.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.102]                     next
[09:32:25.102]                   args[[name]] <- ""
[09:32:25.102]                 }
[09:32:25.102]                 NAMES <- toupper(removed)
[09:32:25.102]                 for (kk in seq_along(NAMES)) {
[09:32:25.102]                   name <- removed[[kk]]
[09:32:25.102]                   NAME <- NAMES[[kk]]
[09:32:25.102]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.102]                     next
[09:32:25.102]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:25.102]                 }
[09:32:25.102]                 if (length(args) > 0) 
[09:32:25.102]                   base::do.call(base::Sys.setenv, args = args)
[09:32:25.102]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:25.102]             }
[09:32:25.102]             else {
[09:32:25.102]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:25.102]             }
[09:32:25.102]             {
[09:32:25.102]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:25.102]                   0L) {
[09:32:25.102]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:25.102]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:25.102]                   base::options(opts)
[09:32:25.102]                 }
[09:32:25.102]                 {
[09:32:25.102]                   {
[09:32:25.102]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:25.102]                     NULL
[09:32:25.102]                   }
[09:32:25.102]                   options(future.plan = NULL)
[09:32:25.102]                   if (is.na(NA_character_)) 
[09:32:25.102]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:25.102]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:25.102]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:25.102]                     .init = FALSE)
[09:32:25.102]                 }
[09:32:25.102]             }
[09:32:25.102]         }
[09:32:25.102]     })
[09:32:25.102]     if (TRUE) {
[09:32:25.102]         base::sink(type = "output", split = FALSE)
[09:32:25.102]         if (TRUE) {
[09:32:25.102]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:25.102]         }
[09:32:25.102]         else {
[09:32:25.102]             ...future.result["stdout"] <- base::list(NULL)
[09:32:25.102]         }
[09:32:25.102]         base::close(...future.stdout)
[09:32:25.102]         ...future.stdout <- NULL
[09:32:25.102]     }
[09:32:25.102]     ...future.result$conditions <- ...future.conditions
[09:32:25.102]     ...future.result$finished <- base::Sys.time()
[09:32:25.102]     ...future.result
[09:32:25.102] }
[09:32:25.105] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:25.127] receiveMessageFromWorker() for ClusterFuture ...
[09:32:25.127] - Validating connection of MultisessionFuture
[09:32:25.128] - received message: FutureResult
[09:32:25.128] - Received FutureResult
[09:32:25.128] - Erased future from FutureRegistry
[09:32:25.128] result() for ClusterFuture ...
[09:32:25.128] - result already collected: FutureResult
[09:32:25.128] result() for ClusterFuture ... done
[09:32:25.128] signalConditions() ...
[09:32:25.128]  - include = ‘immediateCondition’
[09:32:25.128]  - exclude = 
[09:32:25.128]  - resignal = FALSE
[09:32:25.129]  - Number of conditions: 1
[09:32:25.129] signalConditions() ... done
[09:32:25.129] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:25.129] result() for ClusterFuture ...
[09:32:25.129] - result already collected: FutureResult
[09:32:25.129] result() for ClusterFuture ... done
[09:32:25.129] result() for ClusterFuture ...
[09:32:25.129] - result already collected: FutureResult
[09:32:25.129] result() for ClusterFuture ... done
[09:32:25.129] signalConditions() ...
[09:32:25.129]  - include = ‘immediateCondition’
[09:32:25.129]  - exclude = 
[09:32:25.130]  - resignal = FALSE
[09:32:25.130]  - Number of conditions: 1
[09:32:25.130] signalConditions() ... done
[09:32:25.131] MultisessionFuture started
[09:32:25.131] - Launch lazy future ... done
[09:32:25.131] run() for ‘MultisessionFuture’ ... done
[09:32:25.634] receiveMessageFromWorker() for ClusterFuture ...
[09:32:25.634] - Validating connection of MultisessionFuture
[09:32:25.635] - received message: FutureResult
[09:32:25.635] - Received FutureResult
[09:32:25.636] - Erased future from FutureRegistry
[09:32:25.636] result() for ClusterFuture ...
[09:32:25.636] - result already collected: FutureResult
[09:32:25.636] result() for ClusterFuture ... done
[09:32:25.636] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:25.636] A MultisessionFuture was resolved (result was not collected)
[09:32:25.636] getGlobalsAndPackages() ...
[09:32:25.636] Searching for globals...
[09:32:25.637] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:25.638] Searching for globals ... DONE
[09:32:25.638] Resolving globals: FALSE
[09:32:25.638] 
[09:32:25.638] 
[09:32:25.638] getGlobalsAndPackages() ... DONE
[09:32:25.638] run() for ‘Future’ ...
[09:32:25.639] - state: ‘created’
[09:32:25.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:25.652] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:25.653] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:25.653]   - Field: ‘node’
[09:32:25.653]   - Field: ‘label’
[09:32:25.653]   - Field: ‘local’
[09:32:25.653]   - Field: ‘owner’
[09:32:25.653]   - Field: ‘envir’
[09:32:25.653]   - Field: ‘workers’
[09:32:25.653]   - Field: ‘packages’
[09:32:25.653]   - Field: ‘gc’
[09:32:25.653]   - Field: ‘conditions’
[09:32:25.654]   - Field: ‘persistent’
[09:32:25.654]   - Field: ‘expr’
[09:32:25.654]   - Field: ‘uuid’
[09:32:25.654]   - Field: ‘seed’
[09:32:25.654]   - Field: ‘version’
[09:32:25.654]   - Field: ‘result’
[09:32:25.654]   - Field: ‘asynchronous’
[09:32:25.654]   - Field: ‘calls’
[09:32:25.654]   - Field: ‘globals’
[09:32:25.654]   - Field: ‘stdout’
[09:32:25.654]   - Field: ‘earlySignal’
[09:32:25.655]   - Field: ‘lazy’
[09:32:25.655]   - Field: ‘state’
[09:32:25.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:25.655] - Launch lazy future ...
[09:32:25.655] Packages needed by the future expression (n = 0): <none>
[09:32:25.655] Packages needed by future strategies (n = 0): <none>
[09:32:25.656] {
[09:32:25.656]     {
[09:32:25.656]         {
[09:32:25.656]             ...future.startTime <- base::Sys.time()
[09:32:25.656]             {
[09:32:25.656]                 {
[09:32:25.656]                   {
[09:32:25.656]                     {
[09:32:25.656]                       base::local({
[09:32:25.656]                         has_future <- base::requireNamespace("future", 
[09:32:25.656]                           quietly = TRUE)
[09:32:25.656]                         if (has_future) {
[09:32:25.656]                           ns <- base::getNamespace("future")
[09:32:25.656]                           version <- ns[[".package"]][["version"]]
[09:32:25.656]                           if (is.null(version)) 
[09:32:25.656]                             version <- utils::packageVersion("future")
[09:32:25.656]                         }
[09:32:25.656]                         else {
[09:32:25.656]                           version <- NULL
[09:32:25.656]                         }
[09:32:25.656]                         if (!has_future || version < "1.8.0") {
[09:32:25.656]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:25.656]                             "", base::R.version$version.string), 
[09:32:25.656]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:25.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:25.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:25.656]                               "release", "version")], collapse = " "), 
[09:32:25.656]                             hostname = base::Sys.info()[["nodename"]])
[09:32:25.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:25.656]                             info)
[09:32:25.656]                           info <- base::paste(info, collapse = "; ")
[09:32:25.656]                           if (!has_future) {
[09:32:25.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:25.656]                               info)
[09:32:25.656]                           }
[09:32:25.656]                           else {
[09:32:25.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:25.656]                               info, version)
[09:32:25.656]                           }
[09:32:25.656]                           base::stop(msg)
[09:32:25.656]                         }
[09:32:25.656]                       })
[09:32:25.656]                     }
[09:32:25.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:25.656]                     base::options(mc.cores = 1L)
[09:32:25.656]                   }
[09:32:25.656]                   ...future.strategy.old <- future::plan("list")
[09:32:25.656]                   options(future.plan = NULL)
[09:32:25.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:25.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:25.656]                 }
[09:32:25.656]                 ...future.workdir <- getwd()
[09:32:25.656]             }
[09:32:25.656]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:25.656]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:25.656]         }
[09:32:25.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:25.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:25.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:25.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:25.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:25.656]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:25.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:25.656]             base::names(...future.oldOptions))
[09:32:25.656]     }
[09:32:25.656]     if (FALSE) {
[09:32:25.656]     }
[09:32:25.656]     else {
[09:32:25.656]         if (TRUE) {
[09:32:25.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:25.656]                 open = "w")
[09:32:25.656]         }
[09:32:25.656]         else {
[09:32:25.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:25.656]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:25.656]         }
[09:32:25.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:25.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:25.656]             base::sink(type = "output", split = FALSE)
[09:32:25.656]             base::close(...future.stdout)
[09:32:25.656]         }, add = TRUE)
[09:32:25.656]     }
[09:32:25.656]     ...future.frame <- base::sys.nframe()
[09:32:25.656]     ...future.conditions <- base::list()
[09:32:25.656]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:25.656]     if (FALSE) {
[09:32:25.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:25.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:25.656]     }
[09:32:25.656]     ...future.result <- base::tryCatch({
[09:32:25.656]         base::withCallingHandlers({
[09:32:25.656]             ...future.value <- base::withVisible(base::local({
[09:32:25.656]                 ...future.makeSendCondition <- base::local({
[09:32:25.656]                   sendCondition <- NULL
[09:32:25.656]                   function(frame = 1L) {
[09:32:25.656]                     if (is.function(sendCondition)) 
[09:32:25.656]                       return(sendCondition)
[09:32:25.656]                     ns <- getNamespace("parallel")
[09:32:25.656]                     if (exists("sendData", mode = "function", 
[09:32:25.656]                       envir = ns)) {
[09:32:25.656]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:25.656]                         envir = ns)
[09:32:25.656]                       envir <- sys.frame(frame)
[09:32:25.656]                       master <- NULL
[09:32:25.656]                       while (!identical(envir, .GlobalEnv) && 
[09:32:25.656]                         !identical(envir, emptyenv())) {
[09:32:25.656]                         if (exists("master", mode = "list", envir = envir, 
[09:32:25.656]                           inherits = FALSE)) {
[09:32:25.656]                           master <- get("master", mode = "list", 
[09:32:25.656]                             envir = envir, inherits = FALSE)
[09:32:25.656]                           if (inherits(master, c("SOCKnode", 
[09:32:25.656]                             "SOCK0node"))) {
[09:32:25.656]                             sendCondition <<- function(cond) {
[09:32:25.656]                               data <- list(type = "VALUE", value = cond, 
[09:32:25.656]                                 success = TRUE)
[09:32:25.656]                               parallel_sendData(master, data)
[09:32:25.656]                             }
[09:32:25.656]                             return(sendCondition)
[09:32:25.656]                           }
[09:32:25.656]                         }
[09:32:25.656]                         frame <- frame + 1L
[09:32:25.656]                         envir <- sys.frame(frame)
[09:32:25.656]                       }
[09:32:25.656]                     }
[09:32:25.656]                     sendCondition <<- function(cond) NULL
[09:32:25.656]                   }
[09:32:25.656]                 })
[09:32:25.656]                 withCallingHandlers({
[09:32:25.656]                   {
[09:32:25.656]                     Sys.sleep(0.5)
[09:32:25.656]                     list(a = 1, b = 42L)
[09:32:25.656]                   }
[09:32:25.656]                 }, immediateCondition = function(cond) {
[09:32:25.656]                   sendCondition <- ...future.makeSendCondition()
[09:32:25.656]                   sendCondition(cond)
[09:32:25.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.656]                   {
[09:32:25.656]                     inherits <- base::inherits
[09:32:25.656]                     invokeRestart <- base::invokeRestart
[09:32:25.656]                     is.null <- base::is.null
[09:32:25.656]                     muffled <- FALSE
[09:32:25.656]                     if (inherits(cond, "message")) {
[09:32:25.656]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:25.656]                       if (muffled) 
[09:32:25.656]                         invokeRestart("muffleMessage")
[09:32:25.656]                     }
[09:32:25.656]                     else if (inherits(cond, "warning")) {
[09:32:25.656]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:25.656]                       if (muffled) 
[09:32:25.656]                         invokeRestart("muffleWarning")
[09:32:25.656]                     }
[09:32:25.656]                     else if (inherits(cond, "condition")) {
[09:32:25.656]                       if (!is.null(pattern)) {
[09:32:25.656]                         computeRestarts <- base::computeRestarts
[09:32:25.656]                         grepl <- base::grepl
[09:32:25.656]                         restarts <- computeRestarts(cond)
[09:32:25.656]                         for (restart in restarts) {
[09:32:25.656]                           name <- restart$name
[09:32:25.656]                           if (is.null(name)) 
[09:32:25.656]                             next
[09:32:25.656]                           if (!grepl(pattern, name)) 
[09:32:25.656]                             next
[09:32:25.656]                           invokeRestart(restart)
[09:32:25.656]                           muffled <- TRUE
[09:32:25.656]                           break
[09:32:25.656]                         }
[09:32:25.656]                       }
[09:32:25.656]                     }
[09:32:25.656]                     invisible(muffled)
[09:32:25.656]                   }
[09:32:25.656]                   muffleCondition(cond)
[09:32:25.656]                 })
[09:32:25.656]             }))
[09:32:25.656]             future::FutureResult(value = ...future.value$value, 
[09:32:25.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:25.656]                   ...future.rng), globalenv = if (FALSE) 
[09:32:25.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:25.656]                     ...future.globalenv.names))
[09:32:25.656]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:25.656]         }, condition = base::local({
[09:32:25.656]             c <- base::c
[09:32:25.656]             inherits <- base::inherits
[09:32:25.656]             invokeRestart <- base::invokeRestart
[09:32:25.656]             length <- base::length
[09:32:25.656]             list <- base::list
[09:32:25.656]             seq.int <- base::seq.int
[09:32:25.656]             signalCondition <- base::signalCondition
[09:32:25.656]             sys.calls <- base::sys.calls
[09:32:25.656]             `[[` <- base::`[[`
[09:32:25.656]             `+` <- base::`+`
[09:32:25.656]             `<<-` <- base::`<<-`
[09:32:25.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:25.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:25.656]                   3L)]
[09:32:25.656]             }
[09:32:25.656]             function(cond) {
[09:32:25.656]                 is_error <- inherits(cond, "error")
[09:32:25.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:25.656]                   NULL)
[09:32:25.656]                 if (is_error) {
[09:32:25.656]                   sessionInformation <- function() {
[09:32:25.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:25.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:25.656]                       search = base::search(), system = base::Sys.info())
[09:32:25.656]                   }
[09:32:25.656]                   ...future.conditions[[length(...future.conditions) + 
[09:32:25.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:25.656]                     cond$call), session = sessionInformation(), 
[09:32:25.656]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:25.656]                   signalCondition(cond)
[09:32:25.656]                 }
[09:32:25.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:25.656]                 "immediateCondition"))) {
[09:32:25.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:25.656]                   ...future.conditions[[length(...future.conditions) + 
[09:32:25.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:25.656]                   if (TRUE && !signal) {
[09:32:25.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.656]                     {
[09:32:25.656]                       inherits <- base::inherits
[09:32:25.656]                       invokeRestart <- base::invokeRestart
[09:32:25.656]                       is.null <- base::is.null
[09:32:25.656]                       muffled <- FALSE
[09:32:25.656]                       if (inherits(cond, "message")) {
[09:32:25.656]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:25.656]                         if (muffled) 
[09:32:25.656]                           invokeRestart("muffleMessage")
[09:32:25.656]                       }
[09:32:25.656]                       else if (inherits(cond, "warning")) {
[09:32:25.656]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:25.656]                         if (muffled) 
[09:32:25.656]                           invokeRestart("muffleWarning")
[09:32:25.656]                       }
[09:32:25.656]                       else if (inherits(cond, "condition")) {
[09:32:25.656]                         if (!is.null(pattern)) {
[09:32:25.656]                           computeRestarts <- base::computeRestarts
[09:32:25.656]                           grepl <- base::grepl
[09:32:25.656]                           restarts <- computeRestarts(cond)
[09:32:25.656]                           for (restart in restarts) {
[09:32:25.656]                             name <- restart$name
[09:32:25.656]                             if (is.null(name)) 
[09:32:25.656]                               next
[09:32:25.656]                             if (!grepl(pattern, name)) 
[09:32:25.656]                               next
[09:32:25.656]                             invokeRestart(restart)
[09:32:25.656]                             muffled <- TRUE
[09:32:25.656]                             break
[09:32:25.656]                           }
[09:32:25.656]                         }
[09:32:25.656]                       }
[09:32:25.656]                       invisible(muffled)
[09:32:25.656]                     }
[09:32:25.656]                     muffleCondition(cond, pattern = "^muffle")
[09:32:25.656]                   }
[09:32:25.656]                 }
[09:32:25.656]                 else {
[09:32:25.656]                   if (TRUE) {
[09:32:25.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:25.656]                     {
[09:32:25.656]                       inherits <- base::inherits
[09:32:25.656]                       invokeRestart <- base::invokeRestart
[09:32:25.656]                       is.null <- base::is.null
[09:32:25.656]                       muffled <- FALSE
[09:32:25.656]                       if (inherits(cond, "message")) {
[09:32:25.656]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:25.656]                         if (muffled) 
[09:32:25.656]                           invokeRestart("muffleMessage")
[09:32:25.656]                       }
[09:32:25.656]                       else if (inherits(cond, "warning")) {
[09:32:25.656]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:25.656]                         if (muffled) 
[09:32:25.656]                           invokeRestart("muffleWarning")
[09:32:25.656]                       }
[09:32:25.656]                       else if (inherits(cond, "condition")) {
[09:32:25.656]                         if (!is.null(pattern)) {
[09:32:25.656]                           computeRestarts <- base::computeRestarts
[09:32:25.656]                           grepl <- base::grepl
[09:32:25.656]                           restarts <- computeRestarts(cond)
[09:32:25.656]                           for (restart in restarts) {
[09:32:25.656]                             name <- restart$name
[09:32:25.656]                             if (is.null(name)) 
[09:32:25.656]                               next
[09:32:25.656]                             if (!grepl(pattern, name)) 
[09:32:25.656]                               next
[09:32:25.656]                             invokeRestart(restart)
[09:32:25.656]                             muffled <- TRUE
[09:32:25.656]                             break
[09:32:25.656]                           }
[09:32:25.656]                         }
[09:32:25.656]                       }
[09:32:25.656]                       invisible(muffled)
[09:32:25.656]                     }
[09:32:25.656]                     muffleCondition(cond, pattern = "^muffle")
[09:32:25.656]                   }
[09:32:25.656]                 }
[09:32:25.656]             }
[09:32:25.656]         }))
[09:32:25.656]     }, error = function(ex) {
[09:32:25.656]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:25.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:25.656]                 ...future.rng), started = ...future.startTime, 
[09:32:25.656]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:25.656]             version = "1.8"), class = "FutureResult")
[09:32:25.656]     }, finally = {
[09:32:25.656]         if (!identical(...future.workdir, getwd())) 
[09:32:25.656]             setwd(...future.workdir)
[09:32:25.656]         {
[09:32:25.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:25.656]                 ...future.oldOptions$nwarnings <- NULL
[09:32:25.656]             }
[09:32:25.656]             base::options(...future.oldOptions)
[09:32:25.656]             if (.Platform$OS.type == "windows") {
[09:32:25.656]                 old_names <- names(...future.oldEnvVars)
[09:32:25.656]                 envs <- base::Sys.getenv()
[09:32:25.656]                 names <- names(envs)
[09:32:25.656]                 common <- intersect(names, old_names)
[09:32:25.656]                 added <- setdiff(names, old_names)
[09:32:25.656]                 removed <- setdiff(old_names, names)
[09:32:25.656]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:25.656]                   envs[common]]
[09:32:25.656]                 NAMES <- toupper(changed)
[09:32:25.656]                 args <- list()
[09:32:25.656]                 for (kk in seq_along(NAMES)) {
[09:32:25.656]                   name <- changed[[kk]]
[09:32:25.656]                   NAME <- NAMES[[kk]]
[09:32:25.656]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.656]                     next
[09:32:25.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:25.656]                 }
[09:32:25.656]                 NAMES <- toupper(added)
[09:32:25.656]                 for (kk in seq_along(NAMES)) {
[09:32:25.656]                   name <- added[[kk]]
[09:32:25.656]                   NAME <- NAMES[[kk]]
[09:32:25.656]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.656]                     next
[09:32:25.656]                   args[[name]] <- ""
[09:32:25.656]                 }
[09:32:25.656]                 NAMES <- toupper(removed)
[09:32:25.656]                 for (kk in seq_along(NAMES)) {
[09:32:25.656]                   name <- removed[[kk]]
[09:32:25.656]                   NAME <- NAMES[[kk]]
[09:32:25.656]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:25.656]                     next
[09:32:25.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:25.656]                 }
[09:32:25.656]                 if (length(args) > 0) 
[09:32:25.656]                   base::do.call(base::Sys.setenv, args = args)
[09:32:25.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:25.656]             }
[09:32:25.656]             else {
[09:32:25.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:25.656]             }
[09:32:25.656]             {
[09:32:25.656]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:25.656]                   0L) {
[09:32:25.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:25.656]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:25.656]                   base::options(opts)
[09:32:25.656]                 }
[09:32:25.656]                 {
[09:32:25.656]                   {
[09:32:25.656]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:25.656]                     NULL
[09:32:25.656]                   }
[09:32:25.656]                   options(future.plan = NULL)
[09:32:25.656]                   if (is.na(NA_character_)) 
[09:32:25.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:25.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:25.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:25.656]                     .init = FALSE)
[09:32:25.656]                 }
[09:32:25.656]             }
[09:32:25.656]         }
[09:32:25.656]     })
[09:32:25.656]     if (TRUE) {
[09:32:25.656]         base::sink(type = "output", split = FALSE)
[09:32:25.656]         if (TRUE) {
[09:32:25.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:25.656]         }
[09:32:25.656]         else {
[09:32:25.656]             ...future.result["stdout"] <- base::list(NULL)
[09:32:25.656]         }
[09:32:25.656]         base::close(...future.stdout)
[09:32:25.656]         ...future.stdout <- NULL
[09:32:25.656]     }
[09:32:25.656]     ...future.result$conditions <- ...future.conditions
[09:32:25.656]     ...future.result$finished <- base::Sys.time()
[09:32:25.656]     ...future.result
[09:32:25.656] }
[09:32:25.658] MultisessionFuture started
[09:32:25.659] - Launch lazy future ... done
[09:32:25.659] run() for ‘MultisessionFuture’ ... done
[09:32:26.164] receiveMessageFromWorker() for ClusterFuture ...
[09:32:26.164] - Validating connection of MultisessionFuture
[09:32:26.164] - received message: FutureResult
[09:32:26.165] - Received FutureResult
[09:32:26.165] - Erased future from FutureRegistry
[09:32:26.165] result() for ClusterFuture ...
[09:32:26.165] - result already collected: FutureResult
[09:32:26.165] result() for ClusterFuture ... done
[09:32:26.165] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:26.165] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:26.165] getGlobalsAndPackages() ...
[09:32:26.165] Searching for globals...
[09:32:26.166] - globals found: [2] ‘list’, ‘stop’
[09:32:26.166] Searching for globals ... DONE
[09:32:26.166] Resolving globals: FALSE
[09:32:26.167] 
[09:32:26.167] 
[09:32:26.167] getGlobalsAndPackages() ... DONE
[09:32:26.167] run() for ‘Future’ ...
[09:32:26.167] - state: ‘created’
[09:32:26.167] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:26.181] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:26.181] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:26.181]   - Field: ‘node’
[09:32:26.181]   - Field: ‘label’
[09:32:26.181]   - Field: ‘local’
[09:32:26.181]   - Field: ‘owner’
[09:32:26.182]   - Field: ‘envir’
[09:32:26.182]   - Field: ‘workers’
[09:32:26.182]   - Field: ‘packages’
[09:32:26.182]   - Field: ‘gc’
[09:32:26.182]   - Field: ‘conditions’
[09:32:26.182]   - Field: ‘persistent’
[09:32:26.182]   - Field: ‘expr’
[09:32:26.182]   - Field: ‘uuid’
[09:32:26.182]   - Field: ‘seed’
[09:32:26.182]   - Field: ‘version’
[09:32:26.182]   - Field: ‘result’
[09:32:26.182]   - Field: ‘asynchronous’
[09:32:26.183]   - Field: ‘calls’
[09:32:26.183]   - Field: ‘globals’
[09:32:26.183]   - Field: ‘stdout’
[09:32:26.183]   - Field: ‘earlySignal’
[09:32:26.183]   - Field: ‘lazy’
[09:32:26.183]   - Field: ‘state’
[09:32:26.183] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:26.183] - Launch lazy future ...
[09:32:26.183] Packages needed by the future expression (n = 0): <none>
[09:32:26.184] Packages needed by future strategies (n = 0): <none>
[09:32:26.184] {
[09:32:26.184]     {
[09:32:26.184]         {
[09:32:26.184]             ...future.startTime <- base::Sys.time()
[09:32:26.184]             {
[09:32:26.184]                 {
[09:32:26.184]                   {
[09:32:26.184]                     {
[09:32:26.184]                       base::local({
[09:32:26.184]                         has_future <- base::requireNamespace("future", 
[09:32:26.184]                           quietly = TRUE)
[09:32:26.184]                         if (has_future) {
[09:32:26.184]                           ns <- base::getNamespace("future")
[09:32:26.184]                           version <- ns[[".package"]][["version"]]
[09:32:26.184]                           if (is.null(version)) 
[09:32:26.184]                             version <- utils::packageVersion("future")
[09:32:26.184]                         }
[09:32:26.184]                         else {
[09:32:26.184]                           version <- NULL
[09:32:26.184]                         }
[09:32:26.184]                         if (!has_future || version < "1.8.0") {
[09:32:26.184]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:26.184]                             "", base::R.version$version.string), 
[09:32:26.184]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:26.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:26.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:26.184]                               "release", "version")], collapse = " "), 
[09:32:26.184]                             hostname = base::Sys.info()[["nodename"]])
[09:32:26.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:26.184]                             info)
[09:32:26.184]                           info <- base::paste(info, collapse = "; ")
[09:32:26.184]                           if (!has_future) {
[09:32:26.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:26.184]                               info)
[09:32:26.184]                           }
[09:32:26.184]                           else {
[09:32:26.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:26.184]                               info, version)
[09:32:26.184]                           }
[09:32:26.184]                           base::stop(msg)
[09:32:26.184]                         }
[09:32:26.184]                       })
[09:32:26.184]                     }
[09:32:26.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:26.184]                     base::options(mc.cores = 1L)
[09:32:26.184]                   }
[09:32:26.184]                   ...future.strategy.old <- future::plan("list")
[09:32:26.184]                   options(future.plan = NULL)
[09:32:26.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:26.184]                 }
[09:32:26.184]                 ...future.workdir <- getwd()
[09:32:26.184]             }
[09:32:26.184]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:26.184]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:26.184]         }
[09:32:26.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:26.184]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:26.184]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:26.184]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:26.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:26.184]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:26.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:26.184]             base::names(...future.oldOptions))
[09:32:26.184]     }
[09:32:26.184]     if (FALSE) {
[09:32:26.184]     }
[09:32:26.184]     else {
[09:32:26.184]         if (TRUE) {
[09:32:26.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:26.184]                 open = "w")
[09:32:26.184]         }
[09:32:26.184]         else {
[09:32:26.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:26.184]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:26.184]         }
[09:32:26.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:26.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:26.184]             base::sink(type = "output", split = FALSE)
[09:32:26.184]             base::close(...future.stdout)
[09:32:26.184]         }, add = TRUE)
[09:32:26.184]     }
[09:32:26.184]     ...future.frame <- base::sys.nframe()
[09:32:26.184]     ...future.conditions <- base::list()
[09:32:26.184]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:26.184]     if (FALSE) {
[09:32:26.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:26.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:26.184]     }
[09:32:26.184]     ...future.result <- base::tryCatch({
[09:32:26.184]         base::withCallingHandlers({
[09:32:26.184]             ...future.value <- base::withVisible(base::local({
[09:32:26.184]                 ...future.makeSendCondition <- base::local({
[09:32:26.184]                   sendCondition <- NULL
[09:32:26.184]                   function(frame = 1L) {
[09:32:26.184]                     if (is.function(sendCondition)) 
[09:32:26.184]                       return(sendCondition)
[09:32:26.184]                     ns <- getNamespace("parallel")
[09:32:26.184]                     if (exists("sendData", mode = "function", 
[09:32:26.184]                       envir = ns)) {
[09:32:26.184]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:26.184]                         envir = ns)
[09:32:26.184]                       envir <- sys.frame(frame)
[09:32:26.184]                       master <- NULL
[09:32:26.184]                       while (!identical(envir, .GlobalEnv) && 
[09:32:26.184]                         !identical(envir, emptyenv())) {
[09:32:26.184]                         if (exists("master", mode = "list", envir = envir, 
[09:32:26.184]                           inherits = FALSE)) {
[09:32:26.184]                           master <- get("master", mode = "list", 
[09:32:26.184]                             envir = envir, inherits = FALSE)
[09:32:26.184]                           if (inherits(master, c("SOCKnode", 
[09:32:26.184]                             "SOCK0node"))) {
[09:32:26.184]                             sendCondition <<- function(cond) {
[09:32:26.184]                               data <- list(type = "VALUE", value = cond, 
[09:32:26.184]                                 success = TRUE)
[09:32:26.184]                               parallel_sendData(master, data)
[09:32:26.184]                             }
[09:32:26.184]                             return(sendCondition)
[09:32:26.184]                           }
[09:32:26.184]                         }
[09:32:26.184]                         frame <- frame + 1L
[09:32:26.184]                         envir <- sys.frame(frame)
[09:32:26.184]                       }
[09:32:26.184]                     }
[09:32:26.184]                     sendCondition <<- function(cond) NULL
[09:32:26.184]                   }
[09:32:26.184]                 })
[09:32:26.184]                 withCallingHandlers({
[09:32:26.184]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:26.184]                 }, immediateCondition = function(cond) {
[09:32:26.184]                   sendCondition <- ...future.makeSendCondition()
[09:32:26.184]                   sendCondition(cond)
[09:32:26.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.184]                   {
[09:32:26.184]                     inherits <- base::inherits
[09:32:26.184]                     invokeRestart <- base::invokeRestart
[09:32:26.184]                     is.null <- base::is.null
[09:32:26.184]                     muffled <- FALSE
[09:32:26.184]                     if (inherits(cond, "message")) {
[09:32:26.184]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:26.184]                       if (muffled) 
[09:32:26.184]                         invokeRestart("muffleMessage")
[09:32:26.184]                     }
[09:32:26.184]                     else if (inherits(cond, "warning")) {
[09:32:26.184]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:26.184]                       if (muffled) 
[09:32:26.184]                         invokeRestart("muffleWarning")
[09:32:26.184]                     }
[09:32:26.184]                     else if (inherits(cond, "condition")) {
[09:32:26.184]                       if (!is.null(pattern)) {
[09:32:26.184]                         computeRestarts <- base::computeRestarts
[09:32:26.184]                         grepl <- base::grepl
[09:32:26.184]                         restarts <- computeRestarts(cond)
[09:32:26.184]                         for (restart in restarts) {
[09:32:26.184]                           name <- restart$name
[09:32:26.184]                           if (is.null(name)) 
[09:32:26.184]                             next
[09:32:26.184]                           if (!grepl(pattern, name)) 
[09:32:26.184]                             next
[09:32:26.184]                           invokeRestart(restart)
[09:32:26.184]                           muffled <- TRUE
[09:32:26.184]                           break
[09:32:26.184]                         }
[09:32:26.184]                       }
[09:32:26.184]                     }
[09:32:26.184]                     invisible(muffled)
[09:32:26.184]                   }
[09:32:26.184]                   muffleCondition(cond)
[09:32:26.184]                 })
[09:32:26.184]             }))
[09:32:26.184]             future::FutureResult(value = ...future.value$value, 
[09:32:26.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.184]                   ...future.rng), globalenv = if (FALSE) 
[09:32:26.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:26.184]                     ...future.globalenv.names))
[09:32:26.184]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:26.184]         }, condition = base::local({
[09:32:26.184]             c <- base::c
[09:32:26.184]             inherits <- base::inherits
[09:32:26.184]             invokeRestart <- base::invokeRestart
[09:32:26.184]             length <- base::length
[09:32:26.184]             list <- base::list
[09:32:26.184]             seq.int <- base::seq.int
[09:32:26.184]             signalCondition <- base::signalCondition
[09:32:26.184]             sys.calls <- base::sys.calls
[09:32:26.184]             `[[` <- base::`[[`
[09:32:26.184]             `+` <- base::`+`
[09:32:26.184]             `<<-` <- base::`<<-`
[09:32:26.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:26.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:26.184]                   3L)]
[09:32:26.184]             }
[09:32:26.184]             function(cond) {
[09:32:26.184]                 is_error <- inherits(cond, "error")
[09:32:26.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:26.184]                   NULL)
[09:32:26.184]                 if (is_error) {
[09:32:26.184]                   sessionInformation <- function() {
[09:32:26.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:26.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:26.184]                       search = base::search(), system = base::Sys.info())
[09:32:26.184]                   }
[09:32:26.184]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:26.184]                     cond$call), session = sessionInformation(), 
[09:32:26.184]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:26.184]                   signalCondition(cond)
[09:32:26.184]                 }
[09:32:26.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:26.184]                 "immediateCondition"))) {
[09:32:26.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:26.184]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:26.184]                   if (TRUE && !signal) {
[09:32:26.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.184]                     {
[09:32:26.184]                       inherits <- base::inherits
[09:32:26.184]                       invokeRestart <- base::invokeRestart
[09:32:26.184]                       is.null <- base::is.null
[09:32:26.184]                       muffled <- FALSE
[09:32:26.184]                       if (inherits(cond, "message")) {
[09:32:26.184]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.184]                         if (muffled) 
[09:32:26.184]                           invokeRestart("muffleMessage")
[09:32:26.184]                       }
[09:32:26.184]                       else if (inherits(cond, "warning")) {
[09:32:26.184]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.184]                         if (muffled) 
[09:32:26.184]                           invokeRestart("muffleWarning")
[09:32:26.184]                       }
[09:32:26.184]                       else if (inherits(cond, "condition")) {
[09:32:26.184]                         if (!is.null(pattern)) {
[09:32:26.184]                           computeRestarts <- base::computeRestarts
[09:32:26.184]                           grepl <- base::grepl
[09:32:26.184]                           restarts <- computeRestarts(cond)
[09:32:26.184]                           for (restart in restarts) {
[09:32:26.184]                             name <- restart$name
[09:32:26.184]                             if (is.null(name)) 
[09:32:26.184]                               next
[09:32:26.184]                             if (!grepl(pattern, name)) 
[09:32:26.184]                               next
[09:32:26.184]                             invokeRestart(restart)
[09:32:26.184]                             muffled <- TRUE
[09:32:26.184]                             break
[09:32:26.184]                           }
[09:32:26.184]                         }
[09:32:26.184]                       }
[09:32:26.184]                       invisible(muffled)
[09:32:26.184]                     }
[09:32:26.184]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.184]                   }
[09:32:26.184]                 }
[09:32:26.184]                 else {
[09:32:26.184]                   if (TRUE) {
[09:32:26.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.184]                     {
[09:32:26.184]                       inherits <- base::inherits
[09:32:26.184]                       invokeRestart <- base::invokeRestart
[09:32:26.184]                       is.null <- base::is.null
[09:32:26.184]                       muffled <- FALSE
[09:32:26.184]                       if (inherits(cond, "message")) {
[09:32:26.184]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.184]                         if (muffled) 
[09:32:26.184]                           invokeRestart("muffleMessage")
[09:32:26.184]                       }
[09:32:26.184]                       else if (inherits(cond, "warning")) {
[09:32:26.184]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.184]                         if (muffled) 
[09:32:26.184]                           invokeRestart("muffleWarning")
[09:32:26.184]                       }
[09:32:26.184]                       else if (inherits(cond, "condition")) {
[09:32:26.184]                         if (!is.null(pattern)) {
[09:32:26.184]                           computeRestarts <- base::computeRestarts
[09:32:26.184]                           grepl <- base::grepl
[09:32:26.184]                           restarts <- computeRestarts(cond)
[09:32:26.184]                           for (restart in restarts) {
[09:32:26.184]                             name <- restart$name
[09:32:26.184]                             if (is.null(name)) 
[09:32:26.184]                               next
[09:32:26.184]                             if (!grepl(pattern, name)) 
[09:32:26.184]                               next
[09:32:26.184]                             invokeRestart(restart)
[09:32:26.184]                             muffled <- TRUE
[09:32:26.184]                             break
[09:32:26.184]                           }
[09:32:26.184]                         }
[09:32:26.184]                       }
[09:32:26.184]                       invisible(muffled)
[09:32:26.184]                     }
[09:32:26.184]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.184]                   }
[09:32:26.184]                 }
[09:32:26.184]             }
[09:32:26.184]         }))
[09:32:26.184]     }, error = function(ex) {
[09:32:26.184]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:26.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.184]                 ...future.rng), started = ...future.startTime, 
[09:32:26.184]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:26.184]             version = "1.8"), class = "FutureResult")
[09:32:26.184]     }, finally = {
[09:32:26.184]         if (!identical(...future.workdir, getwd())) 
[09:32:26.184]             setwd(...future.workdir)
[09:32:26.184]         {
[09:32:26.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:26.184]                 ...future.oldOptions$nwarnings <- NULL
[09:32:26.184]             }
[09:32:26.184]             base::options(...future.oldOptions)
[09:32:26.184]             if (.Platform$OS.type == "windows") {
[09:32:26.184]                 old_names <- names(...future.oldEnvVars)
[09:32:26.184]                 envs <- base::Sys.getenv()
[09:32:26.184]                 names <- names(envs)
[09:32:26.184]                 common <- intersect(names, old_names)
[09:32:26.184]                 added <- setdiff(names, old_names)
[09:32:26.184]                 removed <- setdiff(old_names, names)
[09:32:26.184]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:26.184]                   envs[common]]
[09:32:26.184]                 NAMES <- toupper(changed)
[09:32:26.184]                 args <- list()
[09:32:26.184]                 for (kk in seq_along(NAMES)) {
[09:32:26.184]                   name <- changed[[kk]]
[09:32:26.184]                   NAME <- NAMES[[kk]]
[09:32:26.184]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.184]                     next
[09:32:26.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.184]                 }
[09:32:26.184]                 NAMES <- toupper(added)
[09:32:26.184]                 for (kk in seq_along(NAMES)) {
[09:32:26.184]                   name <- added[[kk]]
[09:32:26.184]                   NAME <- NAMES[[kk]]
[09:32:26.184]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.184]                     next
[09:32:26.184]                   args[[name]] <- ""
[09:32:26.184]                 }
[09:32:26.184]                 NAMES <- toupper(removed)
[09:32:26.184]                 for (kk in seq_along(NAMES)) {
[09:32:26.184]                   name <- removed[[kk]]
[09:32:26.184]                   NAME <- NAMES[[kk]]
[09:32:26.184]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.184]                     next
[09:32:26.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.184]                 }
[09:32:26.184]                 if (length(args) > 0) 
[09:32:26.184]                   base::do.call(base::Sys.setenv, args = args)
[09:32:26.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:26.184]             }
[09:32:26.184]             else {
[09:32:26.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:26.184]             }
[09:32:26.184]             {
[09:32:26.184]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:26.184]                   0L) {
[09:32:26.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:26.184]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:26.184]                   base::options(opts)
[09:32:26.184]                 }
[09:32:26.184]                 {
[09:32:26.184]                   {
[09:32:26.184]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:26.184]                     NULL
[09:32:26.184]                   }
[09:32:26.184]                   options(future.plan = NULL)
[09:32:26.184]                   if (is.na(NA_character_)) 
[09:32:26.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:26.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:26.184]                     .init = FALSE)
[09:32:26.184]                 }
[09:32:26.184]             }
[09:32:26.184]         }
[09:32:26.184]     })
[09:32:26.184]     if (TRUE) {
[09:32:26.184]         base::sink(type = "output", split = FALSE)
[09:32:26.184]         if (TRUE) {
[09:32:26.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:26.184]         }
[09:32:26.184]         else {
[09:32:26.184]             ...future.result["stdout"] <- base::list(NULL)
[09:32:26.184]         }
[09:32:26.184]         base::close(...future.stdout)
[09:32:26.184]         ...future.stdout <- NULL
[09:32:26.184]     }
[09:32:26.184]     ...future.result$conditions <- ...future.conditions
[09:32:26.184]     ...future.result$finished <- base::Sys.time()
[09:32:26.184]     ...future.result
[09:32:26.184] }
[09:32:26.187] MultisessionFuture started
[09:32:26.187] - Launch lazy future ... done
[09:32:26.187] run() for ‘MultisessionFuture’ ... done
[09:32:26.188] receiveMessageFromWorker() for ClusterFuture ...
[09:32:26.189] - Validating connection of MultisessionFuture
[09:32:26.189] - received message: FutureResult
[09:32:26.189] - Received FutureResult
[09:32:26.191] - Erased future from FutureRegistry
[09:32:26.191] result() for ClusterFuture ...
[09:32:26.191] - result already collected: FutureResult
[09:32:26.191] result() for ClusterFuture ... done
[09:32:26.191] signalConditions() ...
[09:32:26.192]  - include = ‘immediateCondition’
[09:32:26.192]  - exclude = 
[09:32:26.192]  - resignal = FALSE
[09:32:26.192]  - Number of conditions: 1
[09:32:26.192] signalConditions() ... done
[09:32:26.192] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:26.192] A MultisessionFuture was resolved (result was not collected)
[09:32:26.192] getGlobalsAndPackages() ...
[09:32:26.192] Searching for globals...
[09:32:26.193] - globals found: [2] ‘list’, ‘stop’
[09:32:26.193] Searching for globals ... DONE
[09:32:26.193] Resolving globals: FALSE
[09:32:26.193] 
[09:32:26.194] 
[09:32:26.194] getGlobalsAndPackages() ... DONE
[09:32:26.194] run() for ‘Future’ ...
[09:32:26.194] - state: ‘created’
[09:32:26.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:26.208] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:26.208] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:26.208]   - Field: ‘node’
[09:32:26.208]   - Field: ‘label’
[09:32:26.208]   - Field: ‘local’
[09:32:26.208]   - Field: ‘owner’
[09:32:26.208]   - Field: ‘envir’
[09:32:26.208]   - Field: ‘workers’
[09:32:26.209]   - Field: ‘packages’
[09:32:26.209]   - Field: ‘gc’
[09:32:26.209]   - Field: ‘conditions’
[09:32:26.209]   - Field: ‘persistent’
[09:32:26.209]   - Field: ‘expr’
[09:32:26.209]   - Field: ‘uuid’
[09:32:26.209]   - Field: ‘seed’
[09:32:26.209]   - Field: ‘version’
[09:32:26.209]   - Field: ‘result’
[09:32:26.209]   - Field: ‘asynchronous’
[09:32:26.209]   - Field: ‘calls’
[09:32:26.209]   - Field: ‘globals’
[09:32:26.210]   - Field: ‘stdout’
[09:32:26.210]   - Field: ‘earlySignal’
[09:32:26.210]   - Field: ‘lazy’
[09:32:26.210]   - Field: ‘state’
[09:32:26.210] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:26.210] - Launch lazy future ...
[09:32:26.210] Packages needed by the future expression (n = 0): <none>
[09:32:26.210] Packages needed by future strategies (n = 0): <none>
[09:32:26.211] {
[09:32:26.211]     {
[09:32:26.211]         {
[09:32:26.211]             ...future.startTime <- base::Sys.time()
[09:32:26.211]             {
[09:32:26.211]                 {
[09:32:26.211]                   {
[09:32:26.211]                     {
[09:32:26.211]                       base::local({
[09:32:26.211]                         has_future <- base::requireNamespace("future", 
[09:32:26.211]                           quietly = TRUE)
[09:32:26.211]                         if (has_future) {
[09:32:26.211]                           ns <- base::getNamespace("future")
[09:32:26.211]                           version <- ns[[".package"]][["version"]]
[09:32:26.211]                           if (is.null(version)) 
[09:32:26.211]                             version <- utils::packageVersion("future")
[09:32:26.211]                         }
[09:32:26.211]                         else {
[09:32:26.211]                           version <- NULL
[09:32:26.211]                         }
[09:32:26.211]                         if (!has_future || version < "1.8.0") {
[09:32:26.211]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:26.211]                             "", base::R.version$version.string), 
[09:32:26.211]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:26.211]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:26.211]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:26.211]                               "release", "version")], collapse = " "), 
[09:32:26.211]                             hostname = base::Sys.info()[["nodename"]])
[09:32:26.211]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:26.211]                             info)
[09:32:26.211]                           info <- base::paste(info, collapse = "; ")
[09:32:26.211]                           if (!has_future) {
[09:32:26.211]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:26.211]                               info)
[09:32:26.211]                           }
[09:32:26.211]                           else {
[09:32:26.211]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:26.211]                               info, version)
[09:32:26.211]                           }
[09:32:26.211]                           base::stop(msg)
[09:32:26.211]                         }
[09:32:26.211]                       })
[09:32:26.211]                     }
[09:32:26.211]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:26.211]                     base::options(mc.cores = 1L)
[09:32:26.211]                   }
[09:32:26.211]                   ...future.strategy.old <- future::plan("list")
[09:32:26.211]                   options(future.plan = NULL)
[09:32:26.211]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.211]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:26.211]                 }
[09:32:26.211]                 ...future.workdir <- getwd()
[09:32:26.211]             }
[09:32:26.211]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:26.211]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:26.211]         }
[09:32:26.211]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:26.211]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:26.211]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:26.211]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:26.211]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:26.211]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:26.211]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:26.211]             base::names(...future.oldOptions))
[09:32:26.211]     }
[09:32:26.211]     if (FALSE) {
[09:32:26.211]     }
[09:32:26.211]     else {
[09:32:26.211]         if (TRUE) {
[09:32:26.211]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:26.211]                 open = "w")
[09:32:26.211]         }
[09:32:26.211]         else {
[09:32:26.211]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:26.211]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:26.211]         }
[09:32:26.211]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:26.211]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:26.211]             base::sink(type = "output", split = FALSE)
[09:32:26.211]             base::close(...future.stdout)
[09:32:26.211]         }, add = TRUE)
[09:32:26.211]     }
[09:32:26.211]     ...future.frame <- base::sys.nframe()
[09:32:26.211]     ...future.conditions <- base::list()
[09:32:26.211]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:26.211]     if (FALSE) {
[09:32:26.211]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:26.211]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:26.211]     }
[09:32:26.211]     ...future.result <- base::tryCatch({
[09:32:26.211]         base::withCallingHandlers({
[09:32:26.211]             ...future.value <- base::withVisible(base::local({
[09:32:26.211]                 ...future.makeSendCondition <- base::local({
[09:32:26.211]                   sendCondition <- NULL
[09:32:26.211]                   function(frame = 1L) {
[09:32:26.211]                     if (is.function(sendCondition)) 
[09:32:26.211]                       return(sendCondition)
[09:32:26.211]                     ns <- getNamespace("parallel")
[09:32:26.211]                     if (exists("sendData", mode = "function", 
[09:32:26.211]                       envir = ns)) {
[09:32:26.211]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:26.211]                         envir = ns)
[09:32:26.211]                       envir <- sys.frame(frame)
[09:32:26.211]                       master <- NULL
[09:32:26.211]                       while (!identical(envir, .GlobalEnv) && 
[09:32:26.211]                         !identical(envir, emptyenv())) {
[09:32:26.211]                         if (exists("master", mode = "list", envir = envir, 
[09:32:26.211]                           inherits = FALSE)) {
[09:32:26.211]                           master <- get("master", mode = "list", 
[09:32:26.211]                             envir = envir, inherits = FALSE)
[09:32:26.211]                           if (inherits(master, c("SOCKnode", 
[09:32:26.211]                             "SOCK0node"))) {
[09:32:26.211]                             sendCondition <<- function(cond) {
[09:32:26.211]                               data <- list(type = "VALUE", value = cond, 
[09:32:26.211]                                 success = TRUE)
[09:32:26.211]                               parallel_sendData(master, data)
[09:32:26.211]                             }
[09:32:26.211]                             return(sendCondition)
[09:32:26.211]                           }
[09:32:26.211]                         }
[09:32:26.211]                         frame <- frame + 1L
[09:32:26.211]                         envir <- sys.frame(frame)
[09:32:26.211]                       }
[09:32:26.211]                     }
[09:32:26.211]                     sendCondition <<- function(cond) NULL
[09:32:26.211]                   }
[09:32:26.211]                 })
[09:32:26.211]                 withCallingHandlers({
[09:32:26.211]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:26.211]                 }, immediateCondition = function(cond) {
[09:32:26.211]                   sendCondition <- ...future.makeSendCondition()
[09:32:26.211]                   sendCondition(cond)
[09:32:26.211]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.211]                   {
[09:32:26.211]                     inherits <- base::inherits
[09:32:26.211]                     invokeRestart <- base::invokeRestart
[09:32:26.211]                     is.null <- base::is.null
[09:32:26.211]                     muffled <- FALSE
[09:32:26.211]                     if (inherits(cond, "message")) {
[09:32:26.211]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:26.211]                       if (muffled) 
[09:32:26.211]                         invokeRestart("muffleMessage")
[09:32:26.211]                     }
[09:32:26.211]                     else if (inherits(cond, "warning")) {
[09:32:26.211]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:26.211]                       if (muffled) 
[09:32:26.211]                         invokeRestart("muffleWarning")
[09:32:26.211]                     }
[09:32:26.211]                     else if (inherits(cond, "condition")) {
[09:32:26.211]                       if (!is.null(pattern)) {
[09:32:26.211]                         computeRestarts <- base::computeRestarts
[09:32:26.211]                         grepl <- base::grepl
[09:32:26.211]                         restarts <- computeRestarts(cond)
[09:32:26.211]                         for (restart in restarts) {
[09:32:26.211]                           name <- restart$name
[09:32:26.211]                           if (is.null(name)) 
[09:32:26.211]                             next
[09:32:26.211]                           if (!grepl(pattern, name)) 
[09:32:26.211]                             next
[09:32:26.211]                           invokeRestart(restart)
[09:32:26.211]                           muffled <- TRUE
[09:32:26.211]                           break
[09:32:26.211]                         }
[09:32:26.211]                       }
[09:32:26.211]                     }
[09:32:26.211]                     invisible(muffled)
[09:32:26.211]                   }
[09:32:26.211]                   muffleCondition(cond)
[09:32:26.211]                 })
[09:32:26.211]             }))
[09:32:26.211]             future::FutureResult(value = ...future.value$value, 
[09:32:26.211]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.211]                   ...future.rng), globalenv = if (FALSE) 
[09:32:26.211]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:26.211]                     ...future.globalenv.names))
[09:32:26.211]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:26.211]         }, condition = base::local({
[09:32:26.211]             c <- base::c
[09:32:26.211]             inherits <- base::inherits
[09:32:26.211]             invokeRestart <- base::invokeRestart
[09:32:26.211]             length <- base::length
[09:32:26.211]             list <- base::list
[09:32:26.211]             seq.int <- base::seq.int
[09:32:26.211]             signalCondition <- base::signalCondition
[09:32:26.211]             sys.calls <- base::sys.calls
[09:32:26.211]             `[[` <- base::`[[`
[09:32:26.211]             `+` <- base::`+`
[09:32:26.211]             `<<-` <- base::`<<-`
[09:32:26.211]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:26.211]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:26.211]                   3L)]
[09:32:26.211]             }
[09:32:26.211]             function(cond) {
[09:32:26.211]                 is_error <- inherits(cond, "error")
[09:32:26.211]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:26.211]                   NULL)
[09:32:26.211]                 if (is_error) {
[09:32:26.211]                   sessionInformation <- function() {
[09:32:26.211]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:26.211]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:26.211]                       search = base::search(), system = base::Sys.info())
[09:32:26.211]                   }
[09:32:26.211]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.211]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:26.211]                     cond$call), session = sessionInformation(), 
[09:32:26.211]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:26.211]                   signalCondition(cond)
[09:32:26.211]                 }
[09:32:26.211]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:26.211]                 "immediateCondition"))) {
[09:32:26.211]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:26.211]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.211]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:26.211]                   if (TRUE && !signal) {
[09:32:26.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.211]                     {
[09:32:26.211]                       inherits <- base::inherits
[09:32:26.211]                       invokeRestart <- base::invokeRestart
[09:32:26.211]                       is.null <- base::is.null
[09:32:26.211]                       muffled <- FALSE
[09:32:26.211]                       if (inherits(cond, "message")) {
[09:32:26.211]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.211]                         if (muffled) 
[09:32:26.211]                           invokeRestart("muffleMessage")
[09:32:26.211]                       }
[09:32:26.211]                       else if (inherits(cond, "warning")) {
[09:32:26.211]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.211]                         if (muffled) 
[09:32:26.211]                           invokeRestart("muffleWarning")
[09:32:26.211]                       }
[09:32:26.211]                       else if (inherits(cond, "condition")) {
[09:32:26.211]                         if (!is.null(pattern)) {
[09:32:26.211]                           computeRestarts <- base::computeRestarts
[09:32:26.211]                           grepl <- base::grepl
[09:32:26.211]                           restarts <- computeRestarts(cond)
[09:32:26.211]                           for (restart in restarts) {
[09:32:26.211]                             name <- restart$name
[09:32:26.211]                             if (is.null(name)) 
[09:32:26.211]                               next
[09:32:26.211]                             if (!grepl(pattern, name)) 
[09:32:26.211]                               next
[09:32:26.211]                             invokeRestart(restart)
[09:32:26.211]                             muffled <- TRUE
[09:32:26.211]                             break
[09:32:26.211]                           }
[09:32:26.211]                         }
[09:32:26.211]                       }
[09:32:26.211]                       invisible(muffled)
[09:32:26.211]                     }
[09:32:26.211]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.211]                   }
[09:32:26.211]                 }
[09:32:26.211]                 else {
[09:32:26.211]                   if (TRUE) {
[09:32:26.211]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.211]                     {
[09:32:26.211]                       inherits <- base::inherits
[09:32:26.211]                       invokeRestart <- base::invokeRestart
[09:32:26.211]                       is.null <- base::is.null
[09:32:26.211]                       muffled <- FALSE
[09:32:26.211]                       if (inherits(cond, "message")) {
[09:32:26.211]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.211]                         if (muffled) 
[09:32:26.211]                           invokeRestart("muffleMessage")
[09:32:26.211]                       }
[09:32:26.211]                       else if (inherits(cond, "warning")) {
[09:32:26.211]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.211]                         if (muffled) 
[09:32:26.211]                           invokeRestart("muffleWarning")
[09:32:26.211]                       }
[09:32:26.211]                       else if (inherits(cond, "condition")) {
[09:32:26.211]                         if (!is.null(pattern)) {
[09:32:26.211]                           computeRestarts <- base::computeRestarts
[09:32:26.211]                           grepl <- base::grepl
[09:32:26.211]                           restarts <- computeRestarts(cond)
[09:32:26.211]                           for (restart in restarts) {
[09:32:26.211]                             name <- restart$name
[09:32:26.211]                             if (is.null(name)) 
[09:32:26.211]                               next
[09:32:26.211]                             if (!grepl(pattern, name)) 
[09:32:26.211]                               next
[09:32:26.211]                             invokeRestart(restart)
[09:32:26.211]                             muffled <- TRUE
[09:32:26.211]                             break
[09:32:26.211]                           }
[09:32:26.211]                         }
[09:32:26.211]                       }
[09:32:26.211]                       invisible(muffled)
[09:32:26.211]                     }
[09:32:26.211]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.211]                   }
[09:32:26.211]                 }
[09:32:26.211]             }
[09:32:26.211]         }))
[09:32:26.211]     }, error = function(ex) {
[09:32:26.211]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:26.211]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.211]                 ...future.rng), started = ...future.startTime, 
[09:32:26.211]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:26.211]             version = "1.8"), class = "FutureResult")
[09:32:26.211]     }, finally = {
[09:32:26.211]         if (!identical(...future.workdir, getwd())) 
[09:32:26.211]             setwd(...future.workdir)
[09:32:26.211]         {
[09:32:26.211]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:26.211]                 ...future.oldOptions$nwarnings <- NULL
[09:32:26.211]             }
[09:32:26.211]             base::options(...future.oldOptions)
[09:32:26.211]             if (.Platform$OS.type == "windows") {
[09:32:26.211]                 old_names <- names(...future.oldEnvVars)
[09:32:26.211]                 envs <- base::Sys.getenv()
[09:32:26.211]                 names <- names(envs)
[09:32:26.211]                 common <- intersect(names, old_names)
[09:32:26.211]                 added <- setdiff(names, old_names)
[09:32:26.211]                 removed <- setdiff(old_names, names)
[09:32:26.211]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:26.211]                   envs[common]]
[09:32:26.211]                 NAMES <- toupper(changed)
[09:32:26.211]                 args <- list()
[09:32:26.211]                 for (kk in seq_along(NAMES)) {
[09:32:26.211]                   name <- changed[[kk]]
[09:32:26.211]                   NAME <- NAMES[[kk]]
[09:32:26.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.211]                     next
[09:32:26.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.211]                 }
[09:32:26.211]                 NAMES <- toupper(added)
[09:32:26.211]                 for (kk in seq_along(NAMES)) {
[09:32:26.211]                   name <- added[[kk]]
[09:32:26.211]                   NAME <- NAMES[[kk]]
[09:32:26.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.211]                     next
[09:32:26.211]                   args[[name]] <- ""
[09:32:26.211]                 }
[09:32:26.211]                 NAMES <- toupper(removed)
[09:32:26.211]                 for (kk in seq_along(NAMES)) {
[09:32:26.211]                   name <- removed[[kk]]
[09:32:26.211]                   NAME <- NAMES[[kk]]
[09:32:26.211]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.211]                     next
[09:32:26.211]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.211]                 }
[09:32:26.211]                 if (length(args) > 0) 
[09:32:26.211]                   base::do.call(base::Sys.setenv, args = args)
[09:32:26.211]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:26.211]             }
[09:32:26.211]             else {
[09:32:26.211]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:26.211]             }
[09:32:26.211]             {
[09:32:26.211]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:26.211]                   0L) {
[09:32:26.211]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:26.211]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:26.211]                   base::options(opts)
[09:32:26.211]                 }
[09:32:26.211]                 {
[09:32:26.211]                   {
[09:32:26.211]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:26.211]                     NULL
[09:32:26.211]                   }
[09:32:26.211]                   options(future.plan = NULL)
[09:32:26.211]                   if (is.na(NA_character_)) 
[09:32:26.211]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.211]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:26.211]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:26.211]                     .init = FALSE)
[09:32:26.211]                 }
[09:32:26.211]             }
[09:32:26.211]         }
[09:32:26.211]     })
[09:32:26.211]     if (TRUE) {
[09:32:26.211]         base::sink(type = "output", split = FALSE)
[09:32:26.211]         if (TRUE) {
[09:32:26.211]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:26.211]         }
[09:32:26.211]         else {
[09:32:26.211]             ...future.result["stdout"] <- base::list(NULL)
[09:32:26.211]         }
[09:32:26.211]         base::close(...future.stdout)
[09:32:26.211]         ...future.stdout <- NULL
[09:32:26.211]     }
[09:32:26.211]     ...future.result$conditions <- ...future.conditions
[09:32:26.211]     ...future.result$finished <- base::Sys.time()
[09:32:26.211]     ...future.result
[09:32:26.211] }
[09:32:26.213] MultisessionFuture started
[09:32:26.214] - Launch lazy future ... done
[09:32:26.214] run() for ‘MultisessionFuture’ ... done
[09:32:26.215] receiveMessageFromWorker() for ClusterFuture ...
[09:32:26.215] - Validating connection of MultisessionFuture
[09:32:26.215] - received message: FutureResult
[09:32:26.216] - Received FutureResult
[09:32:26.216] - Erased future from FutureRegistry
[09:32:26.216] result() for ClusterFuture ...
[09:32:26.216] - result already collected: FutureResult
[09:32:26.216] result() for ClusterFuture ... done
[09:32:26.216] signalConditions() ...
[09:32:26.216]  - include = ‘immediateCondition’
[09:32:26.216]  - exclude = 
[09:32:26.216]  - resignal = FALSE
[09:32:26.216]  - Number of conditions: 1
[09:32:26.217] signalConditions() ... done
[09:32:26.217] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:26.217] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[09:32:26.217] getGlobalsAndPackages() ...
[09:32:26.217] Searching for globals...
[09:32:26.218] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:26.218] Searching for globals ... DONE
[09:32:26.218] Resolving globals: FALSE
[09:32:26.219] 
[09:32:26.219] 
[09:32:26.219] getGlobalsAndPackages() ... DONE
[09:32:26.219] run() for ‘Future’ ...
[09:32:26.219] - state: ‘created’
[09:32:26.219] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:26.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:26.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:26.233]   - Field: ‘node’
[09:32:26.233]   - Field: ‘label’
[09:32:26.233]   - Field: ‘local’
[09:32:26.233]   - Field: ‘owner’
[09:32:26.233]   - Field: ‘envir’
[09:32:26.233]   - Field: ‘workers’
[09:32:26.234]   - Field: ‘packages’
[09:32:26.234]   - Field: ‘gc’
[09:32:26.234]   - Field: ‘conditions’
[09:32:26.234]   - Field: ‘persistent’
[09:32:26.234]   - Field: ‘expr’
[09:32:26.234]   - Field: ‘uuid’
[09:32:26.234]   - Field: ‘seed’
[09:32:26.234]   - Field: ‘version’
[09:32:26.234]   - Field: ‘result’
[09:32:26.234]   - Field: ‘asynchronous’
[09:32:26.234]   - Field: ‘calls’
[09:32:26.235]   - Field: ‘globals’
[09:32:26.235]   - Field: ‘stdout’
[09:32:26.235]   - Field: ‘earlySignal’
[09:32:26.235]   - Field: ‘lazy’
[09:32:26.235]   - Field: ‘state’
[09:32:26.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:26.235] - Launch lazy future ...
[09:32:26.235] Packages needed by the future expression (n = 0): <none>
[09:32:26.235] Packages needed by future strategies (n = 0): <none>
[09:32:26.236] {
[09:32:26.236]     {
[09:32:26.236]         {
[09:32:26.236]             ...future.startTime <- base::Sys.time()
[09:32:26.236]             {
[09:32:26.236]                 {
[09:32:26.236]                   {
[09:32:26.236]                     {
[09:32:26.236]                       base::local({
[09:32:26.236]                         has_future <- base::requireNamespace("future", 
[09:32:26.236]                           quietly = TRUE)
[09:32:26.236]                         if (has_future) {
[09:32:26.236]                           ns <- base::getNamespace("future")
[09:32:26.236]                           version <- ns[[".package"]][["version"]]
[09:32:26.236]                           if (is.null(version)) 
[09:32:26.236]                             version <- utils::packageVersion("future")
[09:32:26.236]                         }
[09:32:26.236]                         else {
[09:32:26.236]                           version <- NULL
[09:32:26.236]                         }
[09:32:26.236]                         if (!has_future || version < "1.8.0") {
[09:32:26.236]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:26.236]                             "", base::R.version$version.string), 
[09:32:26.236]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:26.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:26.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:26.236]                               "release", "version")], collapse = " "), 
[09:32:26.236]                             hostname = base::Sys.info()[["nodename"]])
[09:32:26.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:26.236]                             info)
[09:32:26.236]                           info <- base::paste(info, collapse = "; ")
[09:32:26.236]                           if (!has_future) {
[09:32:26.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:26.236]                               info)
[09:32:26.236]                           }
[09:32:26.236]                           else {
[09:32:26.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:26.236]                               info, version)
[09:32:26.236]                           }
[09:32:26.236]                           base::stop(msg)
[09:32:26.236]                         }
[09:32:26.236]                       })
[09:32:26.236]                     }
[09:32:26.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:26.236]                     base::options(mc.cores = 1L)
[09:32:26.236]                   }
[09:32:26.236]                   ...future.strategy.old <- future::plan("list")
[09:32:26.236]                   options(future.plan = NULL)
[09:32:26.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:26.236]                 }
[09:32:26.236]                 ...future.workdir <- getwd()
[09:32:26.236]             }
[09:32:26.236]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:26.236]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:26.236]         }
[09:32:26.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:26.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:26.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:26.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:26.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:26.236]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:26.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:26.236]             base::names(...future.oldOptions))
[09:32:26.236]     }
[09:32:26.236]     if (FALSE) {
[09:32:26.236]     }
[09:32:26.236]     else {
[09:32:26.236]         if (TRUE) {
[09:32:26.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:26.236]                 open = "w")
[09:32:26.236]         }
[09:32:26.236]         else {
[09:32:26.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:26.236]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:26.236]         }
[09:32:26.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:26.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:26.236]             base::sink(type = "output", split = FALSE)
[09:32:26.236]             base::close(...future.stdout)
[09:32:26.236]         }, add = TRUE)
[09:32:26.236]     }
[09:32:26.236]     ...future.frame <- base::sys.nframe()
[09:32:26.236]     ...future.conditions <- base::list()
[09:32:26.236]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:26.236]     if (FALSE) {
[09:32:26.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:26.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:26.236]     }
[09:32:26.236]     ...future.result <- base::tryCatch({
[09:32:26.236]         base::withCallingHandlers({
[09:32:26.236]             ...future.value <- base::withVisible(base::local({
[09:32:26.236]                 ...future.makeSendCondition <- base::local({
[09:32:26.236]                   sendCondition <- NULL
[09:32:26.236]                   function(frame = 1L) {
[09:32:26.236]                     if (is.function(sendCondition)) 
[09:32:26.236]                       return(sendCondition)
[09:32:26.236]                     ns <- getNamespace("parallel")
[09:32:26.236]                     if (exists("sendData", mode = "function", 
[09:32:26.236]                       envir = ns)) {
[09:32:26.236]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:26.236]                         envir = ns)
[09:32:26.236]                       envir <- sys.frame(frame)
[09:32:26.236]                       master <- NULL
[09:32:26.236]                       while (!identical(envir, .GlobalEnv) && 
[09:32:26.236]                         !identical(envir, emptyenv())) {
[09:32:26.236]                         if (exists("master", mode = "list", envir = envir, 
[09:32:26.236]                           inherits = FALSE)) {
[09:32:26.236]                           master <- get("master", mode = "list", 
[09:32:26.236]                             envir = envir, inherits = FALSE)
[09:32:26.236]                           if (inherits(master, c("SOCKnode", 
[09:32:26.236]                             "SOCK0node"))) {
[09:32:26.236]                             sendCondition <<- function(cond) {
[09:32:26.236]                               data <- list(type = "VALUE", value = cond, 
[09:32:26.236]                                 success = TRUE)
[09:32:26.236]                               parallel_sendData(master, data)
[09:32:26.236]                             }
[09:32:26.236]                             return(sendCondition)
[09:32:26.236]                           }
[09:32:26.236]                         }
[09:32:26.236]                         frame <- frame + 1L
[09:32:26.236]                         envir <- sys.frame(frame)
[09:32:26.236]                       }
[09:32:26.236]                     }
[09:32:26.236]                     sendCondition <<- function(cond) NULL
[09:32:26.236]                   }
[09:32:26.236]                 })
[09:32:26.236]                 withCallingHandlers({
[09:32:26.236]                   {
[09:32:26.236]                     Sys.sleep(0.5)
[09:32:26.236]                     list(a = 1, b = 42L)
[09:32:26.236]                   }
[09:32:26.236]                 }, immediateCondition = function(cond) {
[09:32:26.236]                   sendCondition <- ...future.makeSendCondition()
[09:32:26.236]                   sendCondition(cond)
[09:32:26.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.236]                   {
[09:32:26.236]                     inherits <- base::inherits
[09:32:26.236]                     invokeRestart <- base::invokeRestart
[09:32:26.236]                     is.null <- base::is.null
[09:32:26.236]                     muffled <- FALSE
[09:32:26.236]                     if (inherits(cond, "message")) {
[09:32:26.236]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:26.236]                       if (muffled) 
[09:32:26.236]                         invokeRestart("muffleMessage")
[09:32:26.236]                     }
[09:32:26.236]                     else if (inherits(cond, "warning")) {
[09:32:26.236]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:26.236]                       if (muffled) 
[09:32:26.236]                         invokeRestart("muffleWarning")
[09:32:26.236]                     }
[09:32:26.236]                     else if (inherits(cond, "condition")) {
[09:32:26.236]                       if (!is.null(pattern)) {
[09:32:26.236]                         computeRestarts <- base::computeRestarts
[09:32:26.236]                         grepl <- base::grepl
[09:32:26.236]                         restarts <- computeRestarts(cond)
[09:32:26.236]                         for (restart in restarts) {
[09:32:26.236]                           name <- restart$name
[09:32:26.236]                           if (is.null(name)) 
[09:32:26.236]                             next
[09:32:26.236]                           if (!grepl(pattern, name)) 
[09:32:26.236]                             next
[09:32:26.236]                           invokeRestart(restart)
[09:32:26.236]                           muffled <- TRUE
[09:32:26.236]                           break
[09:32:26.236]                         }
[09:32:26.236]                       }
[09:32:26.236]                     }
[09:32:26.236]                     invisible(muffled)
[09:32:26.236]                   }
[09:32:26.236]                   muffleCondition(cond)
[09:32:26.236]                 })
[09:32:26.236]             }))
[09:32:26.236]             future::FutureResult(value = ...future.value$value, 
[09:32:26.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.236]                   ...future.rng), globalenv = if (FALSE) 
[09:32:26.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:26.236]                     ...future.globalenv.names))
[09:32:26.236]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:26.236]         }, condition = base::local({
[09:32:26.236]             c <- base::c
[09:32:26.236]             inherits <- base::inherits
[09:32:26.236]             invokeRestart <- base::invokeRestart
[09:32:26.236]             length <- base::length
[09:32:26.236]             list <- base::list
[09:32:26.236]             seq.int <- base::seq.int
[09:32:26.236]             signalCondition <- base::signalCondition
[09:32:26.236]             sys.calls <- base::sys.calls
[09:32:26.236]             `[[` <- base::`[[`
[09:32:26.236]             `+` <- base::`+`
[09:32:26.236]             `<<-` <- base::`<<-`
[09:32:26.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:26.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:26.236]                   3L)]
[09:32:26.236]             }
[09:32:26.236]             function(cond) {
[09:32:26.236]                 is_error <- inherits(cond, "error")
[09:32:26.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:26.236]                   NULL)
[09:32:26.236]                 if (is_error) {
[09:32:26.236]                   sessionInformation <- function() {
[09:32:26.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:26.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:26.236]                       search = base::search(), system = base::Sys.info())
[09:32:26.236]                   }
[09:32:26.236]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:26.236]                     cond$call), session = sessionInformation(), 
[09:32:26.236]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:26.236]                   signalCondition(cond)
[09:32:26.236]                 }
[09:32:26.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:26.236]                 "immediateCondition"))) {
[09:32:26.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:26.236]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:26.236]                   if (TRUE && !signal) {
[09:32:26.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.236]                     {
[09:32:26.236]                       inherits <- base::inherits
[09:32:26.236]                       invokeRestart <- base::invokeRestart
[09:32:26.236]                       is.null <- base::is.null
[09:32:26.236]                       muffled <- FALSE
[09:32:26.236]                       if (inherits(cond, "message")) {
[09:32:26.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.236]                         if (muffled) 
[09:32:26.236]                           invokeRestart("muffleMessage")
[09:32:26.236]                       }
[09:32:26.236]                       else if (inherits(cond, "warning")) {
[09:32:26.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.236]                         if (muffled) 
[09:32:26.236]                           invokeRestart("muffleWarning")
[09:32:26.236]                       }
[09:32:26.236]                       else if (inherits(cond, "condition")) {
[09:32:26.236]                         if (!is.null(pattern)) {
[09:32:26.236]                           computeRestarts <- base::computeRestarts
[09:32:26.236]                           grepl <- base::grepl
[09:32:26.236]                           restarts <- computeRestarts(cond)
[09:32:26.236]                           for (restart in restarts) {
[09:32:26.236]                             name <- restart$name
[09:32:26.236]                             if (is.null(name)) 
[09:32:26.236]                               next
[09:32:26.236]                             if (!grepl(pattern, name)) 
[09:32:26.236]                               next
[09:32:26.236]                             invokeRestart(restart)
[09:32:26.236]                             muffled <- TRUE
[09:32:26.236]                             break
[09:32:26.236]                           }
[09:32:26.236]                         }
[09:32:26.236]                       }
[09:32:26.236]                       invisible(muffled)
[09:32:26.236]                     }
[09:32:26.236]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.236]                   }
[09:32:26.236]                 }
[09:32:26.236]                 else {
[09:32:26.236]                   if (TRUE) {
[09:32:26.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.236]                     {
[09:32:26.236]                       inherits <- base::inherits
[09:32:26.236]                       invokeRestart <- base::invokeRestart
[09:32:26.236]                       is.null <- base::is.null
[09:32:26.236]                       muffled <- FALSE
[09:32:26.236]                       if (inherits(cond, "message")) {
[09:32:26.236]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.236]                         if (muffled) 
[09:32:26.236]                           invokeRestart("muffleMessage")
[09:32:26.236]                       }
[09:32:26.236]                       else if (inherits(cond, "warning")) {
[09:32:26.236]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.236]                         if (muffled) 
[09:32:26.236]                           invokeRestart("muffleWarning")
[09:32:26.236]                       }
[09:32:26.236]                       else if (inherits(cond, "condition")) {
[09:32:26.236]                         if (!is.null(pattern)) {
[09:32:26.236]                           computeRestarts <- base::computeRestarts
[09:32:26.236]                           grepl <- base::grepl
[09:32:26.236]                           restarts <- computeRestarts(cond)
[09:32:26.236]                           for (restart in restarts) {
[09:32:26.236]                             name <- restart$name
[09:32:26.236]                             if (is.null(name)) 
[09:32:26.236]                               next
[09:32:26.236]                             if (!grepl(pattern, name)) 
[09:32:26.236]                               next
[09:32:26.236]                             invokeRestart(restart)
[09:32:26.236]                             muffled <- TRUE
[09:32:26.236]                             break
[09:32:26.236]                           }
[09:32:26.236]                         }
[09:32:26.236]                       }
[09:32:26.236]                       invisible(muffled)
[09:32:26.236]                     }
[09:32:26.236]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.236]                   }
[09:32:26.236]                 }
[09:32:26.236]             }
[09:32:26.236]         }))
[09:32:26.236]     }, error = function(ex) {
[09:32:26.236]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:26.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.236]                 ...future.rng), started = ...future.startTime, 
[09:32:26.236]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:26.236]             version = "1.8"), class = "FutureResult")
[09:32:26.236]     }, finally = {
[09:32:26.236]         if (!identical(...future.workdir, getwd())) 
[09:32:26.236]             setwd(...future.workdir)
[09:32:26.236]         {
[09:32:26.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:26.236]                 ...future.oldOptions$nwarnings <- NULL
[09:32:26.236]             }
[09:32:26.236]             base::options(...future.oldOptions)
[09:32:26.236]             if (.Platform$OS.type == "windows") {
[09:32:26.236]                 old_names <- names(...future.oldEnvVars)
[09:32:26.236]                 envs <- base::Sys.getenv()
[09:32:26.236]                 names <- names(envs)
[09:32:26.236]                 common <- intersect(names, old_names)
[09:32:26.236]                 added <- setdiff(names, old_names)
[09:32:26.236]                 removed <- setdiff(old_names, names)
[09:32:26.236]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:26.236]                   envs[common]]
[09:32:26.236]                 NAMES <- toupper(changed)
[09:32:26.236]                 args <- list()
[09:32:26.236]                 for (kk in seq_along(NAMES)) {
[09:32:26.236]                   name <- changed[[kk]]
[09:32:26.236]                   NAME <- NAMES[[kk]]
[09:32:26.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.236]                     next
[09:32:26.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.236]                 }
[09:32:26.236]                 NAMES <- toupper(added)
[09:32:26.236]                 for (kk in seq_along(NAMES)) {
[09:32:26.236]                   name <- added[[kk]]
[09:32:26.236]                   NAME <- NAMES[[kk]]
[09:32:26.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.236]                     next
[09:32:26.236]                   args[[name]] <- ""
[09:32:26.236]                 }
[09:32:26.236]                 NAMES <- toupper(removed)
[09:32:26.236]                 for (kk in seq_along(NAMES)) {
[09:32:26.236]                   name <- removed[[kk]]
[09:32:26.236]                   NAME <- NAMES[[kk]]
[09:32:26.236]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.236]                     next
[09:32:26.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.236]                 }
[09:32:26.236]                 if (length(args) > 0) 
[09:32:26.236]                   base::do.call(base::Sys.setenv, args = args)
[09:32:26.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:26.236]             }
[09:32:26.236]             else {
[09:32:26.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:26.236]             }
[09:32:26.236]             {
[09:32:26.236]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:26.236]                   0L) {
[09:32:26.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:26.236]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:26.236]                   base::options(opts)
[09:32:26.236]                 }
[09:32:26.236]                 {
[09:32:26.236]                   {
[09:32:26.236]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:26.236]                     NULL
[09:32:26.236]                   }
[09:32:26.236]                   options(future.plan = NULL)
[09:32:26.236]                   if (is.na(NA_character_)) 
[09:32:26.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:26.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:26.236]                     .init = FALSE)
[09:32:26.236]                 }
[09:32:26.236]             }
[09:32:26.236]         }
[09:32:26.236]     })
[09:32:26.236]     if (TRUE) {
[09:32:26.236]         base::sink(type = "output", split = FALSE)
[09:32:26.236]         if (TRUE) {
[09:32:26.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:26.236]         }
[09:32:26.236]         else {
[09:32:26.236]             ...future.result["stdout"] <- base::list(NULL)
[09:32:26.236]         }
[09:32:26.236]         base::close(...future.stdout)
[09:32:26.236]         ...future.stdout <- NULL
[09:32:26.236]     }
[09:32:26.236]     ...future.result$conditions <- ...future.conditions
[09:32:26.236]     ...future.result$finished <- base::Sys.time()
[09:32:26.236]     ...future.result
[09:32:26.236] }
[09:32:26.239] MultisessionFuture started
[09:32:26.239] - Launch lazy future ... done
[09:32:26.239] run() for ‘MultisessionFuture’ ... done
[09:32:26.741] receiveMessageFromWorker() for ClusterFuture ...
[09:32:26.741] - Validating connection of MultisessionFuture
[09:32:26.741] - received message: FutureResult
[09:32:26.742] - Received FutureResult
[09:32:26.742] - Erased future from FutureRegistry
[09:32:26.742] result() for ClusterFuture ...
[09:32:26.742] - result already collected: FutureResult
[09:32:26.742] result() for ClusterFuture ... done
[09:32:26.742] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:26.742] A MultisessionFuture was resolved (result was not collected)
[09:32:26.742] getGlobalsAndPackages() ...
[09:32:26.742] Searching for globals...
[09:32:26.744] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:26.744] Searching for globals ... DONE
[09:32:26.744] Resolving globals: FALSE
[09:32:26.744] 
[09:32:26.744] 
[09:32:26.744] getGlobalsAndPackages() ... DONE
[09:32:26.745] run() for ‘Future’ ...
[09:32:26.745] - state: ‘created’
[09:32:26.745] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:26.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:26.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:26.759]   - Field: ‘node’
[09:32:26.759]   - Field: ‘label’
[09:32:26.759]   - Field: ‘local’
[09:32:26.759]   - Field: ‘owner’
[09:32:26.760]   - Field: ‘envir’
[09:32:26.760]   - Field: ‘workers’
[09:32:26.760]   - Field: ‘packages’
[09:32:26.760]   - Field: ‘gc’
[09:32:26.760]   - Field: ‘conditions’
[09:32:26.760]   - Field: ‘persistent’
[09:32:26.760]   - Field: ‘expr’
[09:32:26.760]   - Field: ‘uuid’
[09:32:26.760]   - Field: ‘seed’
[09:32:26.760]   - Field: ‘version’
[09:32:26.761]   - Field: ‘result’
[09:32:26.761]   - Field: ‘asynchronous’
[09:32:26.761]   - Field: ‘calls’
[09:32:26.761]   - Field: ‘globals’
[09:32:26.761]   - Field: ‘stdout’
[09:32:26.761]   - Field: ‘earlySignal’
[09:32:26.761]   - Field: ‘lazy’
[09:32:26.761]   - Field: ‘state’
[09:32:26.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:26.761] - Launch lazy future ...
[09:32:26.762] Packages needed by the future expression (n = 0): <none>
[09:32:26.762] Packages needed by future strategies (n = 0): <none>
[09:32:26.762] {
[09:32:26.762]     {
[09:32:26.762]         {
[09:32:26.762]             ...future.startTime <- base::Sys.time()
[09:32:26.762]             {
[09:32:26.762]                 {
[09:32:26.762]                   {
[09:32:26.762]                     {
[09:32:26.762]                       base::local({
[09:32:26.762]                         has_future <- base::requireNamespace("future", 
[09:32:26.762]                           quietly = TRUE)
[09:32:26.762]                         if (has_future) {
[09:32:26.762]                           ns <- base::getNamespace("future")
[09:32:26.762]                           version <- ns[[".package"]][["version"]]
[09:32:26.762]                           if (is.null(version)) 
[09:32:26.762]                             version <- utils::packageVersion("future")
[09:32:26.762]                         }
[09:32:26.762]                         else {
[09:32:26.762]                           version <- NULL
[09:32:26.762]                         }
[09:32:26.762]                         if (!has_future || version < "1.8.0") {
[09:32:26.762]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:26.762]                             "", base::R.version$version.string), 
[09:32:26.762]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:26.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:26.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:26.762]                               "release", "version")], collapse = " "), 
[09:32:26.762]                             hostname = base::Sys.info()[["nodename"]])
[09:32:26.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:26.762]                             info)
[09:32:26.762]                           info <- base::paste(info, collapse = "; ")
[09:32:26.762]                           if (!has_future) {
[09:32:26.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:26.762]                               info)
[09:32:26.762]                           }
[09:32:26.762]                           else {
[09:32:26.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:26.762]                               info, version)
[09:32:26.762]                           }
[09:32:26.762]                           base::stop(msg)
[09:32:26.762]                         }
[09:32:26.762]                       })
[09:32:26.762]                     }
[09:32:26.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:26.762]                     base::options(mc.cores = 1L)
[09:32:26.762]                   }
[09:32:26.762]                   ...future.strategy.old <- future::plan("list")
[09:32:26.762]                   options(future.plan = NULL)
[09:32:26.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:26.762]                 }
[09:32:26.762]                 ...future.workdir <- getwd()
[09:32:26.762]             }
[09:32:26.762]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:26.762]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:26.762]         }
[09:32:26.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:26.762]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:26.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:26.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:26.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:26.762]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:26.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:26.762]             base::names(...future.oldOptions))
[09:32:26.762]     }
[09:32:26.762]     if (FALSE) {
[09:32:26.762]     }
[09:32:26.762]     else {
[09:32:26.762]         if (TRUE) {
[09:32:26.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:26.762]                 open = "w")
[09:32:26.762]         }
[09:32:26.762]         else {
[09:32:26.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:26.762]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:26.762]         }
[09:32:26.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:26.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:26.762]             base::sink(type = "output", split = FALSE)
[09:32:26.762]             base::close(...future.stdout)
[09:32:26.762]         }, add = TRUE)
[09:32:26.762]     }
[09:32:26.762]     ...future.frame <- base::sys.nframe()
[09:32:26.762]     ...future.conditions <- base::list()
[09:32:26.762]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:26.762]     if (FALSE) {
[09:32:26.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:26.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:26.762]     }
[09:32:26.762]     ...future.result <- base::tryCatch({
[09:32:26.762]         base::withCallingHandlers({
[09:32:26.762]             ...future.value <- base::withVisible(base::local({
[09:32:26.762]                 ...future.makeSendCondition <- base::local({
[09:32:26.762]                   sendCondition <- NULL
[09:32:26.762]                   function(frame = 1L) {
[09:32:26.762]                     if (is.function(sendCondition)) 
[09:32:26.762]                       return(sendCondition)
[09:32:26.762]                     ns <- getNamespace("parallel")
[09:32:26.762]                     if (exists("sendData", mode = "function", 
[09:32:26.762]                       envir = ns)) {
[09:32:26.762]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:26.762]                         envir = ns)
[09:32:26.762]                       envir <- sys.frame(frame)
[09:32:26.762]                       master <- NULL
[09:32:26.762]                       while (!identical(envir, .GlobalEnv) && 
[09:32:26.762]                         !identical(envir, emptyenv())) {
[09:32:26.762]                         if (exists("master", mode = "list", envir = envir, 
[09:32:26.762]                           inherits = FALSE)) {
[09:32:26.762]                           master <- get("master", mode = "list", 
[09:32:26.762]                             envir = envir, inherits = FALSE)
[09:32:26.762]                           if (inherits(master, c("SOCKnode", 
[09:32:26.762]                             "SOCK0node"))) {
[09:32:26.762]                             sendCondition <<- function(cond) {
[09:32:26.762]                               data <- list(type = "VALUE", value = cond, 
[09:32:26.762]                                 success = TRUE)
[09:32:26.762]                               parallel_sendData(master, data)
[09:32:26.762]                             }
[09:32:26.762]                             return(sendCondition)
[09:32:26.762]                           }
[09:32:26.762]                         }
[09:32:26.762]                         frame <- frame + 1L
[09:32:26.762]                         envir <- sys.frame(frame)
[09:32:26.762]                       }
[09:32:26.762]                     }
[09:32:26.762]                     sendCondition <<- function(cond) NULL
[09:32:26.762]                   }
[09:32:26.762]                 })
[09:32:26.762]                 withCallingHandlers({
[09:32:26.762]                   {
[09:32:26.762]                     Sys.sleep(0.5)
[09:32:26.762]                     list(a = 1, b = 42L)
[09:32:26.762]                   }
[09:32:26.762]                 }, immediateCondition = function(cond) {
[09:32:26.762]                   sendCondition <- ...future.makeSendCondition()
[09:32:26.762]                   sendCondition(cond)
[09:32:26.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.762]                   {
[09:32:26.762]                     inherits <- base::inherits
[09:32:26.762]                     invokeRestart <- base::invokeRestart
[09:32:26.762]                     is.null <- base::is.null
[09:32:26.762]                     muffled <- FALSE
[09:32:26.762]                     if (inherits(cond, "message")) {
[09:32:26.762]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:26.762]                       if (muffled) 
[09:32:26.762]                         invokeRestart("muffleMessage")
[09:32:26.762]                     }
[09:32:26.762]                     else if (inherits(cond, "warning")) {
[09:32:26.762]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:26.762]                       if (muffled) 
[09:32:26.762]                         invokeRestart("muffleWarning")
[09:32:26.762]                     }
[09:32:26.762]                     else if (inherits(cond, "condition")) {
[09:32:26.762]                       if (!is.null(pattern)) {
[09:32:26.762]                         computeRestarts <- base::computeRestarts
[09:32:26.762]                         grepl <- base::grepl
[09:32:26.762]                         restarts <- computeRestarts(cond)
[09:32:26.762]                         for (restart in restarts) {
[09:32:26.762]                           name <- restart$name
[09:32:26.762]                           if (is.null(name)) 
[09:32:26.762]                             next
[09:32:26.762]                           if (!grepl(pattern, name)) 
[09:32:26.762]                             next
[09:32:26.762]                           invokeRestart(restart)
[09:32:26.762]                           muffled <- TRUE
[09:32:26.762]                           break
[09:32:26.762]                         }
[09:32:26.762]                       }
[09:32:26.762]                     }
[09:32:26.762]                     invisible(muffled)
[09:32:26.762]                   }
[09:32:26.762]                   muffleCondition(cond)
[09:32:26.762]                 })
[09:32:26.762]             }))
[09:32:26.762]             future::FutureResult(value = ...future.value$value, 
[09:32:26.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.762]                   ...future.rng), globalenv = if (FALSE) 
[09:32:26.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:26.762]                     ...future.globalenv.names))
[09:32:26.762]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:26.762]         }, condition = base::local({
[09:32:26.762]             c <- base::c
[09:32:26.762]             inherits <- base::inherits
[09:32:26.762]             invokeRestart <- base::invokeRestart
[09:32:26.762]             length <- base::length
[09:32:26.762]             list <- base::list
[09:32:26.762]             seq.int <- base::seq.int
[09:32:26.762]             signalCondition <- base::signalCondition
[09:32:26.762]             sys.calls <- base::sys.calls
[09:32:26.762]             `[[` <- base::`[[`
[09:32:26.762]             `+` <- base::`+`
[09:32:26.762]             `<<-` <- base::`<<-`
[09:32:26.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:26.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:26.762]                   3L)]
[09:32:26.762]             }
[09:32:26.762]             function(cond) {
[09:32:26.762]                 is_error <- inherits(cond, "error")
[09:32:26.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:26.762]                   NULL)
[09:32:26.762]                 if (is_error) {
[09:32:26.762]                   sessionInformation <- function() {
[09:32:26.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:26.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:26.762]                       search = base::search(), system = base::Sys.info())
[09:32:26.762]                   }
[09:32:26.762]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:26.762]                     cond$call), session = sessionInformation(), 
[09:32:26.762]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:26.762]                   signalCondition(cond)
[09:32:26.762]                 }
[09:32:26.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:26.762]                 "immediateCondition"))) {
[09:32:26.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:26.762]                   ...future.conditions[[length(...future.conditions) + 
[09:32:26.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:26.762]                   if (TRUE && !signal) {
[09:32:26.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.762]                     {
[09:32:26.762]                       inherits <- base::inherits
[09:32:26.762]                       invokeRestart <- base::invokeRestart
[09:32:26.762]                       is.null <- base::is.null
[09:32:26.762]                       muffled <- FALSE
[09:32:26.762]                       if (inherits(cond, "message")) {
[09:32:26.762]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.762]                         if (muffled) 
[09:32:26.762]                           invokeRestart("muffleMessage")
[09:32:26.762]                       }
[09:32:26.762]                       else if (inherits(cond, "warning")) {
[09:32:26.762]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.762]                         if (muffled) 
[09:32:26.762]                           invokeRestart("muffleWarning")
[09:32:26.762]                       }
[09:32:26.762]                       else if (inherits(cond, "condition")) {
[09:32:26.762]                         if (!is.null(pattern)) {
[09:32:26.762]                           computeRestarts <- base::computeRestarts
[09:32:26.762]                           grepl <- base::grepl
[09:32:26.762]                           restarts <- computeRestarts(cond)
[09:32:26.762]                           for (restart in restarts) {
[09:32:26.762]                             name <- restart$name
[09:32:26.762]                             if (is.null(name)) 
[09:32:26.762]                               next
[09:32:26.762]                             if (!grepl(pattern, name)) 
[09:32:26.762]                               next
[09:32:26.762]                             invokeRestart(restart)
[09:32:26.762]                             muffled <- TRUE
[09:32:26.762]                             break
[09:32:26.762]                           }
[09:32:26.762]                         }
[09:32:26.762]                       }
[09:32:26.762]                       invisible(muffled)
[09:32:26.762]                     }
[09:32:26.762]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.762]                   }
[09:32:26.762]                 }
[09:32:26.762]                 else {
[09:32:26.762]                   if (TRUE) {
[09:32:26.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:26.762]                     {
[09:32:26.762]                       inherits <- base::inherits
[09:32:26.762]                       invokeRestart <- base::invokeRestart
[09:32:26.762]                       is.null <- base::is.null
[09:32:26.762]                       muffled <- FALSE
[09:32:26.762]                       if (inherits(cond, "message")) {
[09:32:26.762]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:26.762]                         if (muffled) 
[09:32:26.762]                           invokeRestart("muffleMessage")
[09:32:26.762]                       }
[09:32:26.762]                       else if (inherits(cond, "warning")) {
[09:32:26.762]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:26.762]                         if (muffled) 
[09:32:26.762]                           invokeRestart("muffleWarning")
[09:32:26.762]                       }
[09:32:26.762]                       else if (inherits(cond, "condition")) {
[09:32:26.762]                         if (!is.null(pattern)) {
[09:32:26.762]                           computeRestarts <- base::computeRestarts
[09:32:26.762]                           grepl <- base::grepl
[09:32:26.762]                           restarts <- computeRestarts(cond)
[09:32:26.762]                           for (restart in restarts) {
[09:32:26.762]                             name <- restart$name
[09:32:26.762]                             if (is.null(name)) 
[09:32:26.762]                               next
[09:32:26.762]                             if (!grepl(pattern, name)) 
[09:32:26.762]                               next
[09:32:26.762]                             invokeRestart(restart)
[09:32:26.762]                             muffled <- TRUE
[09:32:26.762]                             break
[09:32:26.762]                           }
[09:32:26.762]                         }
[09:32:26.762]                       }
[09:32:26.762]                       invisible(muffled)
[09:32:26.762]                     }
[09:32:26.762]                     muffleCondition(cond, pattern = "^muffle")
[09:32:26.762]                   }
[09:32:26.762]                 }
[09:32:26.762]             }
[09:32:26.762]         }))
[09:32:26.762]     }, error = function(ex) {
[09:32:26.762]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:26.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:26.762]                 ...future.rng), started = ...future.startTime, 
[09:32:26.762]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:26.762]             version = "1.8"), class = "FutureResult")
[09:32:26.762]     }, finally = {
[09:32:26.762]         if (!identical(...future.workdir, getwd())) 
[09:32:26.762]             setwd(...future.workdir)
[09:32:26.762]         {
[09:32:26.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:26.762]                 ...future.oldOptions$nwarnings <- NULL
[09:32:26.762]             }
[09:32:26.762]             base::options(...future.oldOptions)
[09:32:26.762]             if (.Platform$OS.type == "windows") {
[09:32:26.762]                 old_names <- names(...future.oldEnvVars)
[09:32:26.762]                 envs <- base::Sys.getenv()
[09:32:26.762]                 names <- names(envs)
[09:32:26.762]                 common <- intersect(names, old_names)
[09:32:26.762]                 added <- setdiff(names, old_names)
[09:32:26.762]                 removed <- setdiff(old_names, names)
[09:32:26.762]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:26.762]                   envs[common]]
[09:32:26.762]                 NAMES <- toupper(changed)
[09:32:26.762]                 args <- list()
[09:32:26.762]                 for (kk in seq_along(NAMES)) {
[09:32:26.762]                   name <- changed[[kk]]
[09:32:26.762]                   NAME <- NAMES[[kk]]
[09:32:26.762]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.762]                     next
[09:32:26.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.762]                 }
[09:32:26.762]                 NAMES <- toupper(added)
[09:32:26.762]                 for (kk in seq_along(NAMES)) {
[09:32:26.762]                   name <- added[[kk]]
[09:32:26.762]                   NAME <- NAMES[[kk]]
[09:32:26.762]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.762]                     next
[09:32:26.762]                   args[[name]] <- ""
[09:32:26.762]                 }
[09:32:26.762]                 NAMES <- toupper(removed)
[09:32:26.762]                 for (kk in seq_along(NAMES)) {
[09:32:26.762]                   name <- removed[[kk]]
[09:32:26.762]                   NAME <- NAMES[[kk]]
[09:32:26.762]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:26.762]                     next
[09:32:26.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:26.762]                 }
[09:32:26.762]                 if (length(args) > 0) 
[09:32:26.762]                   base::do.call(base::Sys.setenv, args = args)
[09:32:26.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:26.762]             }
[09:32:26.762]             else {
[09:32:26.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:26.762]             }
[09:32:26.762]             {
[09:32:26.762]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:26.762]                   0L) {
[09:32:26.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:26.762]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:26.762]                   base::options(opts)
[09:32:26.762]                 }
[09:32:26.762]                 {
[09:32:26.762]                   {
[09:32:26.762]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:26.762]                     NULL
[09:32:26.762]                   }
[09:32:26.762]                   options(future.plan = NULL)
[09:32:26.762]                   if (is.na(NA_character_)) 
[09:32:26.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:26.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:26.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:26.762]                     .init = FALSE)
[09:32:26.762]                 }
[09:32:26.762]             }
[09:32:26.762]         }
[09:32:26.762]     })
[09:32:26.762]     if (TRUE) {
[09:32:26.762]         base::sink(type = "output", split = FALSE)
[09:32:26.762]         if (TRUE) {
[09:32:26.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:26.762]         }
[09:32:26.762]         else {
[09:32:26.762]             ...future.result["stdout"] <- base::list(NULL)
[09:32:26.762]         }
[09:32:26.762]         base::close(...future.stdout)
[09:32:26.762]         ...future.stdout <- NULL
[09:32:26.762]     }
[09:32:26.762]     ...future.result$conditions <- ...future.conditions
[09:32:26.762]     ...future.result$finished <- base::Sys.time()
[09:32:26.762]     ...future.result
[09:32:26.762] }
[09:32:26.765] MultisessionFuture started
[09:32:26.765] - Launch lazy future ... done
[09:32:26.765] run() for ‘MultisessionFuture’ ... done
[09:32:27.267] receiveMessageFromWorker() for ClusterFuture ...
[09:32:27.268] - Validating connection of MultisessionFuture
[09:32:27.268] - received message: FutureResult
[09:32:27.268] - Received FutureResult
[09:32:27.268] - Erased future from FutureRegistry
[09:32:27.268] result() for ClusterFuture ...
[09:32:27.268] - result already collected: FutureResult
[09:32:27.268] result() for ClusterFuture ... done
[09:32:27.269] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:27.269] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:27.269] getGlobalsAndPackages() ...
[09:32:27.269] Searching for globals...
[09:32:27.270] - globals found: [2] ‘list’, ‘stop’
[09:32:27.270] Searching for globals ... DONE
[09:32:27.270] Resolving globals: FALSE
[09:32:27.270] 
[09:32:27.270] 
[09:32:27.270] getGlobalsAndPackages() ... DONE
[09:32:27.270] run() for ‘Future’ ...
[09:32:27.271] - state: ‘created’
[09:32:27.271] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:27.285] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:27.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:27.285]   - Field: ‘node’
[09:32:27.285]   - Field: ‘label’
[09:32:27.285]   - Field: ‘local’
[09:32:27.285]   - Field: ‘owner’
[09:32:27.285]   - Field: ‘envir’
[09:32:27.285]   - Field: ‘workers’
[09:32:27.285]   - Field: ‘packages’
[09:32:27.286]   - Field: ‘gc’
[09:32:27.286]   - Field: ‘conditions’
[09:32:27.286]   - Field: ‘persistent’
[09:32:27.286]   - Field: ‘expr’
[09:32:27.286]   - Field: ‘uuid’
[09:32:27.286]   - Field: ‘seed’
[09:32:27.286]   - Field: ‘version’
[09:32:27.286]   - Field: ‘result’
[09:32:27.286]   - Field: ‘asynchronous’
[09:32:27.286]   - Field: ‘calls’
[09:32:27.286]   - Field: ‘globals’
[09:32:27.287]   - Field: ‘stdout’
[09:32:27.287]   - Field: ‘earlySignal’
[09:32:27.287]   - Field: ‘lazy’
[09:32:27.287]   - Field: ‘state’
[09:32:27.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:27.287] - Launch lazy future ...
[09:32:27.287] Packages needed by the future expression (n = 0): <none>
[09:32:27.287] Packages needed by future strategies (n = 0): <none>
[09:32:27.288] {
[09:32:27.288]     {
[09:32:27.288]         {
[09:32:27.288]             ...future.startTime <- base::Sys.time()
[09:32:27.288]             {
[09:32:27.288]                 {
[09:32:27.288]                   {
[09:32:27.288]                     {
[09:32:27.288]                       base::local({
[09:32:27.288]                         has_future <- base::requireNamespace("future", 
[09:32:27.288]                           quietly = TRUE)
[09:32:27.288]                         if (has_future) {
[09:32:27.288]                           ns <- base::getNamespace("future")
[09:32:27.288]                           version <- ns[[".package"]][["version"]]
[09:32:27.288]                           if (is.null(version)) 
[09:32:27.288]                             version <- utils::packageVersion("future")
[09:32:27.288]                         }
[09:32:27.288]                         else {
[09:32:27.288]                           version <- NULL
[09:32:27.288]                         }
[09:32:27.288]                         if (!has_future || version < "1.8.0") {
[09:32:27.288]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:27.288]                             "", base::R.version$version.string), 
[09:32:27.288]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:27.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:27.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:27.288]                               "release", "version")], collapse = " "), 
[09:32:27.288]                             hostname = base::Sys.info()[["nodename"]])
[09:32:27.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:27.288]                             info)
[09:32:27.288]                           info <- base::paste(info, collapse = "; ")
[09:32:27.288]                           if (!has_future) {
[09:32:27.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:27.288]                               info)
[09:32:27.288]                           }
[09:32:27.288]                           else {
[09:32:27.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:27.288]                               info, version)
[09:32:27.288]                           }
[09:32:27.288]                           base::stop(msg)
[09:32:27.288]                         }
[09:32:27.288]                       })
[09:32:27.288]                     }
[09:32:27.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:27.288]                     base::options(mc.cores = 1L)
[09:32:27.288]                   }
[09:32:27.288]                   ...future.strategy.old <- future::plan("list")
[09:32:27.288]                   options(future.plan = NULL)
[09:32:27.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:27.288]                 }
[09:32:27.288]                 ...future.workdir <- getwd()
[09:32:27.288]             }
[09:32:27.288]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:27.288]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:27.288]         }
[09:32:27.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:27.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:27.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:27.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:27.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:27.288]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:27.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:27.288]             base::names(...future.oldOptions))
[09:32:27.288]     }
[09:32:27.288]     if (FALSE) {
[09:32:27.288]     }
[09:32:27.288]     else {
[09:32:27.288]         if (TRUE) {
[09:32:27.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:27.288]                 open = "w")
[09:32:27.288]         }
[09:32:27.288]         else {
[09:32:27.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:27.288]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:27.288]         }
[09:32:27.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:27.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:27.288]             base::sink(type = "output", split = FALSE)
[09:32:27.288]             base::close(...future.stdout)
[09:32:27.288]         }, add = TRUE)
[09:32:27.288]     }
[09:32:27.288]     ...future.frame <- base::sys.nframe()
[09:32:27.288]     ...future.conditions <- base::list()
[09:32:27.288]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:27.288]     if (FALSE) {
[09:32:27.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:27.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:27.288]     }
[09:32:27.288]     ...future.result <- base::tryCatch({
[09:32:27.288]         base::withCallingHandlers({
[09:32:27.288]             ...future.value <- base::withVisible(base::local({
[09:32:27.288]                 ...future.makeSendCondition <- base::local({
[09:32:27.288]                   sendCondition <- NULL
[09:32:27.288]                   function(frame = 1L) {
[09:32:27.288]                     if (is.function(sendCondition)) 
[09:32:27.288]                       return(sendCondition)
[09:32:27.288]                     ns <- getNamespace("parallel")
[09:32:27.288]                     if (exists("sendData", mode = "function", 
[09:32:27.288]                       envir = ns)) {
[09:32:27.288]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:27.288]                         envir = ns)
[09:32:27.288]                       envir <- sys.frame(frame)
[09:32:27.288]                       master <- NULL
[09:32:27.288]                       while (!identical(envir, .GlobalEnv) && 
[09:32:27.288]                         !identical(envir, emptyenv())) {
[09:32:27.288]                         if (exists("master", mode = "list", envir = envir, 
[09:32:27.288]                           inherits = FALSE)) {
[09:32:27.288]                           master <- get("master", mode = "list", 
[09:32:27.288]                             envir = envir, inherits = FALSE)
[09:32:27.288]                           if (inherits(master, c("SOCKnode", 
[09:32:27.288]                             "SOCK0node"))) {
[09:32:27.288]                             sendCondition <<- function(cond) {
[09:32:27.288]                               data <- list(type = "VALUE", value = cond, 
[09:32:27.288]                                 success = TRUE)
[09:32:27.288]                               parallel_sendData(master, data)
[09:32:27.288]                             }
[09:32:27.288]                             return(sendCondition)
[09:32:27.288]                           }
[09:32:27.288]                         }
[09:32:27.288]                         frame <- frame + 1L
[09:32:27.288]                         envir <- sys.frame(frame)
[09:32:27.288]                       }
[09:32:27.288]                     }
[09:32:27.288]                     sendCondition <<- function(cond) NULL
[09:32:27.288]                   }
[09:32:27.288]                 })
[09:32:27.288]                 withCallingHandlers({
[09:32:27.288]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:27.288]                 }, immediateCondition = function(cond) {
[09:32:27.288]                   sendCondition <- ...future.makeSendCondition()
[09:32:27.288]                   sendCondition(cond)
[09:32:27.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.288]                   {
[09:32:27.288]                     inherits <- base::inherits
[09:32:27.288]                     invokeRestart <- base::invokeRestart
[09:32:27.288]                     is.null <- base::is.null
[09:32:27.288]                     muffled <- FALSE
[09:32:27.288]                     if (inherits(cond, "message")) {
[09:32:27.288]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:27.288]                       if (muffled) 
[09:32:27.288]                         invokeRestart("muffleMessage")
[09:32:27.288]                     }
[09:32:27.288]                     else if (inherits(cond, "warning")) {
[09:32:27.288]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:27.288]                       if (muffled) 
[09:32:27.288]                         invokeRestart("muffleWarning")
[09:32:27.288]                     }
[09:32:27.288]                     else if (inherits(cond, "condition")) {
[09:32:27.288]                       if (!is.null(pattern)) {
[09:32:27.288]                         computeRestarts <- base::computeRestarts
[09:32:27.288]                         grepl <- base::grepl
[09:32:27.288]                         restarts <- computeRestarts(cond)
[09:32:27.288]                         for (restart in restarts) {
[09:32:27.288]                           name <- restart$name
[09:32:27.288]                           if (is.null(name)) 
[09:32:27.288]                             next
[09:32:27.288]                           if (!grepl(pattern, name)) 
[09:32:27.288]                             next
[09:32:27.288]                           invokeRestart(restart)
[09:32:27.288]                           muffled <- TRUE
[09:32:27.288]                           break
[09:32:27.288]                         }
[09:32:27.288]                       }
[09:32:27.288]                     }
[09:32:27.288]                     invisible(muffled)
[09:32:27.288]                   }
[09:32:27.288]                   muffleCondition(cond)
[09:32:27.288]                 })
[09:32:27.288]             }))
[09:32:27.288]             future::FutureResult(value = ...future.value$value, 
[09:32:27.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.288]                   ...future.rng), globalenv = if (FALSE) 
[09:32:27.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:27.288]                     ...future.globalenv.names))
[09:32:27.288]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:27.288]         }, condition = base::local({
[09:32:27.288]             c <- base::c
[09:32:27.288]             inherits <- base::inherits
[09:32:27.288]             invokeRestart <- base::invokeRestart
[09:32:27.288]             length <- base::length
[09:32:27.288]             list <- base::list
[09:32:27.288]             seq.int <- base::seq.int
[09:32:27.288]             signalCondition <- base::signalCondition
[09:32:27.288]             sys.calls <- base::sys.calls
[09:32:27.288]             `[[` <- base::`[[`
[09:32:27.288]             `+` <- base::`+`
[09:32:27.288]             `<<-` <- base::`<<-`
[09:32:27.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:27.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:27.288]                   3L)]
[09:32:27.288]             }
[09:32:27.288]             function(cond) {
[09:32:27.288]                 is_error <- inherits(cond, "error")
[09:32:27.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:27.288]                   NULL)
[09:32:27.288]                 if (is_error) {
[09:32:27.288]                   sessionInformation <- function() {
[09:32:27.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:27.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:27.288]                       search = base::search(), system = base::Sys.info())
[09:32:27.288]                   }
[09:32:27.288]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:27.288]                     cond$call), session = sessionInformation(), 
[09:32:27.288]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:27.288]                   signalCondition(cond)
[09:32:27.288]                 }
[09:32:27.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:27.288]                 "immediateCondition"))) {
[09:32:27.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:27.288]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:27.288]                   if (TRUE && !signal) {
[09:32:27.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.288]                     {
[09:32:27.288]                       inherits <- base::inherits
[09:32:27.288]                       invokeRestart <- base::invokeRestart
[09:32:27.288]                       is.null <- base::is.null
[09:32:27.288]                       muffled <- FALSE
[09:32:27.288]                       if (inherits(cond, "message")) {
[09:32:27.288]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.288]                         if (muffled) 
[09:32:27.288]                           invokeRestart("muffleMessage")
[09:32:27.288]                       }
[09:32:27.288]                       else if (inherits(cond, "warning")) {
[09:32:27.288]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.288]                         if (muffled) 
[09:32:27.288]                           invokeRestart("muffleWarning")
[09:32:27.288]                       }
[09:32:27.288]                       else if (inherits(cond, "condition")) {
[09:32:27.288]                         if (!is.null(pattern)) {
[09:32:27.288]                           computeRestarts <- base::computeRestarts
[09:32:27.288]                           grepl <- base::grepl
[09:32:27.288]                           restarts <- computeRestarts(cond)
[09:32:27.288]                           for (restart in restarts) {
[09:32:27.288]                             name <- restart$name
[09:32:27.288]                             if (is.null(name)) 
[09:32:27.288]                               next
[09:32:27.288]                             if (!grepl(pattern, name)) 
[09:32:27.288]                               next
[09:32:27.288]                             invokeRestart(restart)
[09:32:27.288]                             muffled <- TRUE
[09:32:27.288]                             break
[09:32:27.288]                           }
[09:32:27.288]                         }
[09:32:27.288]                       }
[09:32:27.288]                       invisible(muffled)
[09:32:27.288]                     }
[09:32:27.288]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.288]                   }
[09:32:27.288]                 }
[09:32:27.288]                 else {
[09:32:27.288]                   if (TRUE) {
[09:32:27.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.288]                     {
[09:32:27.288]                       inherits <- base::inherits
[09:32:27.288]                       invokeRestart <- base::invokeRestart
[09:32:27.288]                       is.null <- base::is.null
[09:32:27.288]                       muffled <- FALSE
[09:32:27.288]                       if (inherits(cond, "message")) {
[09:32:27.288]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.288]                         if (muffled) 
[09:32:27.288]                           invokeRestart("muffleMessage")
[09:32:27.288]                       }
[09:32:27.288]                       else if (inherits(cond, "warning")) {
[09:32:27.288]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.288]                         if (muffled) 
[09:32:27.288]                           invokeRestart("muffleWarning")
[09:32:27.288]                       }
[09:32:27.288]                       else if (inherits(cond, "condition")) {
[09:32:27.288]                         if (!is.null(pattern)) {
[09:32:27.288]                           computeRestarts <- base::computeRestarts
[09:32:27.288]                           grepl <- base::grepl
[09:32:27.288]                           restarts <- computeRestarts(cond)
[09:32:27.288]                           for (restart in restarts) {
[09:32:27.288]                             name <- restart$name
[09:32:27.288]                             if (is.null(name)) 
[09:32:27.288]                               next
[09:32:27.288]                             if (!grepl(pattern, name)) 
[09:32:27.288]                               next
[09:32:27.288]                             invokeRestart(restart)
[09:32:27.288]                             muffled <- TRUE
[09:32:27.288]                             break
[09:32:27.288]                           }
[09:32:27.288]                         }
[09:32:27.288]                       }
[09:32:27.288]                       invisible(muffled)
[09:32:27.288]                     }
[09:32:27.288]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.288]                   }
[09:32:27.288]                 }
[09:32:27.288]             }
[09:32:27.288]         }))
[09:32:27.288]     }, error = function(ex) {
[09:32:27.288]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:27.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.288]                 ...future.rng), started = ...future.startTime, 
[09:32:27.288]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:27.288]             version = "1.8"), class = "FutureResult")
[09:32:27.288]     }, finally = {
[09:32:27.288]         if (!identical(...future.workdir, getwd())) 
[09:32:27.288]             setwd(...future.workdir)
[09:32:27.288]         {
[09:32:27.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:27.288]                 ...future.oldOptions$nwarnings <- NULL
[09:32:27.288]             }
[09:32:27.288]             base::options(...future.oldOptions)
[09:32:27.288]             if (.Platform$OS.type == "windows") {
[09:32:27.288]                 old_names <- names(...future.oldEnvVars)
[09:32:27.288]                 envs <- base::Sys.getenv()
[09:32:27.288]                 names <- names(envs)
[09:32:27.288]                 common <- intersect(names, old_names)
[09:32:27.288]                 added <- setdiff(names, old_names)
[09:32:27.288]                 removed <- setdiff(old_names, names)
[09:32:27.288]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:27.288]                   envs[common]]
[09:32:27.288]                 NAMES <- toupper(changed)
[09:32:27.288]                 args <- list()
[09:32:27.288]                 for (kk in seq_along(NAMES)) {
[09:32:27.288]                   name <- changed[[kk]]
[09:32:27.288]                   NAME <- NAMES[[kk]]
[09:32:27.288]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.288]                     next
[09:32:27.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.288]                 }
[09:32:27.288]                 NAMES <- toupper(added)
[09:32:27.288]                 for (kk in seq_along(NAMES)) {
[09:32:27.288]                   name <- added[[kk]]
[09:32:27.288]                   NAME <- NAMES[[kk]]
[09:32:27.288]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.288]                     next
[09:32:27.288]                   args[[name]] <- ""
[09:32:27.288]                 }
[09:32:27.288]                 NAMES <- toupper(removed)
[09:32:27.288]                 for (kk in seq_along(NAMES)) {
[09:32:27.288]                   name <- removed[[kk]]
[09:32:27.288]                   NAME <- NAMES[[kk]]
[09:32:27.288]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.288]                     next
[09:32:27.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.288]                 }
[09:32:27.288]                 if (length(args) > 0) 
[09:32:27.288]                   base::do.call(base::Sys.setenv, args = args)
[09:32:27.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:27.288]             }
[09:32:27.288]             else {
[09:32:27.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:27.288]             }
[09:32:27.288]             {
[09:32:27.288]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:27.288]                   0L) {
[09:32:27.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:27.288]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:27.288]                   base::options(opts)
[09:32:27.288]                 }
[09:32:27.288]                 {
[09:32:27.288]                   {
[09:32:27.288]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:27.288]                     NULL
[09:32:27.288]                   }
[09:32:27.288]                   options(future.plan = NULL)
[09:32:27.288]                   if (is.na(NA_character_)) 
[09:32:27.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:27.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:27.288]                     .init = FALSE)
[09:32:27.288]                 }
[09:32:27.288]             }
[09:32:27.288]         }
[09:32:27.288]     })
[09:32:27.288]     if (TRUE) {
[09:32:27.288]         base::sink(type = "output", split = FALSE)
[09:32:27.288]         if (TRUE) {
[09:32:27.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:27.288]         }
[09:32:27.288]         else {
[09:32:27.288]             ...future.result["stdout"] <- base::list(NULL)
[09:32:27.288]         }
[09:32:27.288]         base::close(...future.stdout)
[09:32:27.288]         ...future.stdout <- NULL
[09:32:27.288]     }
[09:32:27.288]     ...future.result$conditions <- ...future.conditions
[09:32:27.288]     ...future.result$finished <- base::Sys.time()
[09:32:27.288]     ...future.result
[09:32:27.288] }
[09:32:27.291] MultisessionFuture started
[09:32:27.291] - Launch lazy future ... done
[09:32:27.291] run() for ‘MultisessionFuture’ ... done
[09:32:27.292] receiveMessageFromWorker() for ClusterFuture ...
[09:32:27.292] - Validating connection of MultisessionFuture
[09:32:27.293] - received message: FutureResult
[09:32:27.293] - Received FutureResult
[09:32:27.293] - Erased future from FutureRegistry
[09:32:27.293] result() for ClusterFuture ...
[09:32:27.293] - result already collected: FutureResult
[09:32:27.293] result() for ClusterFuture ... done
[09:32:27.293] signalConditions() ...
[09:32:27.294]  - include = ‘immediateCondition’
[09:32:27.294]  - exclude = 
[09:32:27.294]  - resignal = FALSE
[09:32:27.294]  - Number of conditions: 1
[09:32:27.294] signalConditions() ... done
[09:32:27.294] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:27.294] A MultisessionFuture was resolved (result was not collected)
[09:32:27.294] getGlobalsAndPackages() ...
[09:32:27.294] Searching for globals...
[09:32:27.295] - globals found: [2] ‘list’, ‘stop’
[09:32:27.295] Searching for globals ... DONE
[09:32:27.295] Resolving globals: FALSE
[09:32:27.295] 
[09:32:27.295] 
[09:32:27.295] getGlobalsAndPackages() ... DONE
[09:32:27.296] run() for ‘Future’ ...
[09:32:27.296] - state: ‘created’
[09:32:27.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:27.309] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:27.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:27.309]   - Field: ‘node’
[09:32:27.310]   - Field: ‘label’
[09:32:27.310]   - Field: ‘local’
[09:32:27.310]   - Field: ‘owner’
[09:32:27.310]   - Field: ‘envir’
[09:32:27.310]   - Field: ‘workers’
[09:32:27.310]   - Field: ‘packages’
[09:32:27.310]   - Field: ‘gc’
[09:32:27.310]   - Field: ‘conditions’
[09:32:27.310]   - Field: ‘persistent’
[09:32:27.310]   - Field: ‘expr’
[09:32:27.310]   - Field: ‘uuid’
[09:32:27.311]   - Field: ‘seed’
[09:32:27.311]   - Field: ‘version’
[09:32:27.311]   - Field: ‘result’
[09:32:27.311]   - Field: ‘asynchronous’
[09:32:27.311]   - Field: ‘calls’
[09:32:27.311]   - Field: ‘globals’
[09:32:27.311]   - Field: ‘stdout’
[09:32:27.311]   - Field: ‘earlySignal’
[09:32:27.311]   - Field: ‘lazy’
[09:32:27.311]   - Field: ‘state’
[09:32:27.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:27.312] - Launch lazy future ...
[09:32:27.312] Packages needed by the future expression (n = 0): <none>
[09:32:27.312] Packages needed by future strategies (n = 0): <none>
[09:32:27.312] {
[09:32:27.312]     {
[09:32:27.312]         {
[09:32:27.312]             ...future.startTime <- base::Sys.time()
[09:32:27.312]             {
[09:32:27.312]                 {
[09:32:27.312]                   {
[09:32:27.312]                     {
[09:32:27.312]                       base::local({
[09:32:27.312]                         has_future <- base::requireNamespace("future", 
[09:32:27.312]                           quietly = TRUE)
[09:32:27.312]                         if (has_future) {
[09:32:27.312]                           ns <- base::getNamespace("future")
[09:32:27.312]                           version <- ns[[".package"]][["version"]]
[09:32:27.312]                           if (is.null(version)) 
[09:32:27.312]                             version <- utils::packageVersion("future")
[09:32:27.312]                         }
[09:32:27.312]                         else {
[09:32:27.312]                           version <- NULL
[09:32:27.312]                         }
[09:32:27.312]                         if (!has_future || version < "1.8.0") {
[09:32:27.312]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:27.312]                             "", base::R.version$version.string), 
[09:32:27.312]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:27.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:27.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:27.312]                               "release", "version")], collapse = " "), 
[09:32:27.312]                             hostname = base::Sys.info()[["nodename"]])
[09:32:27.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:27.312]                             info)
[09:32:27.312]                           info <- base::paste(info, collapse = "; ")
[09:32:27.312]                           if (!has_future) {
[09:32:27.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:27.312]                               info)
[09:32:27.312]                           }
[09:32:27.312]                           else {
[09:32:27.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:27.312]                               info, version)
[09:32:27.312]                           }
[09:32:27.312]                           base::stop(msg)
[09:32:27.312]                         }
[09:32:27.312]                       })
[09:32:27.312]                     }
[09:32:27.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:27.312]                     base::options(mc.cores = 1L)
[09:32:27.312]                   }
[09:32:27.312]                   ...future.strategy.old <- future::plan("list")
[09:32:27.312]                   options(future.plan = NULL)
[09:32:27.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:27.312]                 }
[09:32:27.312]                 ...future.workdir <- getwd()
[09:32:27.312]             }
[09:32:27.312]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:27.312]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:27.312]         }
[09:32:27.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:27.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:27.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:27.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:27.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:27.312]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:27.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:27.312]             base::names(...future.oldOptions))
[09:32:27.312]     }
[09:32:27.312]     if (FALSE) {
[09:32:27.312]     }
[09:32:27.312]     else {
[09:32:27.312]         if (TRUE) {
[09:32:27.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:27.312]                 open = "w")
[09:32:27.312]         }
[09:32:27.312]         else {
[09:32:27.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:27.312]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:27.312]         }
[09:32:27.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:27.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:27.312]             base::sink(type = "output", split = FALSE)
[09:32:27.312]             base::close(...future.stdout)
[09:32:27.312]         }, add = TRUE)
[09:32:27.312]     }
[09:32:27.312]     ...future.frame <- base::sys.nframe()
[09:32:27.312]     ...future.conditions <- base::list()
[09:32:27.312]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:27.312]     if (FALSE) {
[09:32:27.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:27.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:27.312]     }
[09:32:27.312]     ...future.result <- base::tryCatch({
[09:32:27.312]         base::withCallingHandlers({
[09:32:27.312]             ...future.value <- base::withVisible(base::local({
[09:32:27.312]                 ...future.makeSendCondition <- base::local({
[09:32:27.312]                   sendCondition <- NULL
[09:32:27.312]                   function(frame = 1L) {
[09:32:27.312]                     if (is.function(sendCondition)) 
[09:32:27.312]                       return(sendCondition)
[09:32:27.312]                     ns <- getNamespace("parallel")
[09:32:27.312]                     if (exists("sendData", mode = "function", 
[09:32:27.312]                       envir = ns)) {
[09:32:27.312]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:27.312]                         envir = ns)
[09:32:27.312]                       envir <- sys.frame(frame)
[09:32:27.312]                       master <- NULL
[09:32:27.312]                       while (!identical(envir, .GlobalEnv) && 
[09:32:27.312]                         !identical(envir, emptyenv())) {
[09:32:27.312]                         if (exists("master", mode = "list", envir = envir, 
[09:32:27.312]                           inherits = FALSE)) {
[09:32:27.312]                           master <- get("master", mode = "list", 
[09:32:27.312]                             envir = envir, inherits = FALSE)
[09:32:27.312]                           if (inherits(master, c("SOCKnode", 
[09:32:27.312]                             "SOCK0node"))) {
[09:32:27.312]                             sendCondition <<- function(cond) {
[09:32:27.312]                               data <- list(type = "VALUE", value = cond, 
[09:32:27.312]                                 success = TRUE)
[09:32:27.312]                               parallel_sendData(master, data)
[09:32:27.312]                             }
[09:32:27.312]                             return(sendCondition)
[09:32:27.312]                           }
[09:32:27.312]                         }
[09:32:27.312]                         frame <- frame + 1L
[09:32:27.312]                         envir <- sys.frame(frame)
[09:32:27.312]                       }
[09:32:27.312]                     }
[09:32:27.312]                     sendCondition <<- function(cond) NULL
[09:32:27.312]                   }
[09:32:27.312]                 })
[09:32:27.312]                 withCallingHandlers({
[09:32:27.312]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:27.312]                 }, immediateCondition = function(cond) {
[09:32:27.312]                   sendCondition <- ...future.makeSendCondition()
[09:32:27.312]                   sendCondition(cond)
[09:32:27.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.312]                   {
[09:32:27.312]                     inherits <- base::inherits
[09:32:27.312]                     invokeRestart <- base::invokeRestart
[09:32:27.312]                     is.null <- base::is.null
[09:32:27.312]                     muffled <- FALSE
[09:32:27.312]                     if (inherits(cond, "message")) {
[09:32:27.312]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:27.312]                       if (muffled) 
[09:32:27.312]                         invokeRestart("muffleMessage")
[09:32:27.312]                     }
[09:32:27.312]                     else if (inherits(cond, "warning")) {
[09:32:27.312]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:27.312]                       if (muffled) 
[09:32:27.312]                         invokeRestart("muffleWarning")
[09:32:27.312]                     }
[09:32:27.312]                     else if (inherits(cond, "condition")) {
[09:32:27.312]                       if (!is.null(pattern)) {
[09:32:27.312]                         computeRestarts <- base::computeRestarts
[09:32:27.312]                         grepl <- base::grepl
[09:32:27.312]                         restarts <- computeRestarts(cond)
[09:32:27.312]                         for (restart in restarts) {
[09:32:27.312]                           name <- restart$name
[09:32:27.312]                           if (is.null(name)) 
[09:32:27.312]                             next
[09:32:27.312]                           if (!grepl(pattern, name)) 
[09:32:27.312]                             next
[09:32:27.312]                           invokeRestart(restart)
[09:32:27.312]                           muffled <- TRUE
[09:32:27.312]                           break
[09:32:27.312]                         }
[09:32:27.312]                       }
[09:32:27.312]                     }
[09:32:27.312]                     invisible(muffled)
[09:32:27.312]                   }
[09:32:27.312]                   muffleCondition(cond)
[09:32:27.312]                 })
[09:32:27.312]             }))
[09:32:27.312]             future::FutureResult(value = ...future.value$value, 
[09:32:27.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.312]                   ...future.rng), globalenv = if (FALSE) 
[09:32:27.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:27.312]                     ...future.globalenv.names))
[09:32:27.312]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:27.312]         }, condition = base::local({
[09:32:27.312]             c <- base::c
[09:32:27.312]             inherits <- base::inherits
[09:32:27.312]             invokeRestart <- base::invokeRestart
[09:32:27.312]             length <- base::length
[09:32:27.312]             list <- base::list
[09:32:27.312]             seq.int <- base::seq.int
[09:32:27.312]             signalCondition <- base::signalCondition
[09:32:27.312]             sys.calls <- base::sys.calls
[09:32:27.312]             `[[` <- base::`[[`
[09:32:27.312]             `+` <- base::`+`
[09:32:27.312]             `<<-` <- base::`<<-`
[09:32:27.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:27.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:27.312]                   3L)]
[09:32:27.312]             }
[09:32:27.312]             function(cond) {
[09:32:27.312]                 is_error <- inherits(cond, "error")
[09:32:27.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:27.312]                   NULL)
[09:32:27.312]                 if (is_error) {
[09:32:27.312]                   sessionInformation <- function() {
[09:32:27.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:27.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:27.312]                       search = base::search(), system = base::Sys.info())
[09:32:27.312]                   }
[09:32:27.312]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:27.312]                     cond$call), session = sessionInformation(), 
[09:32:27.312]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:27.312]                   signalCondition(cond)
[09:32:27.312]                 }
[09:32:27.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:27.312]                 "immediateCondition"))) {
[09:32:27.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:27.312]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:27.312]                   if (TRUE && !signal) {
[09:32:27.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.312]                     {
[09:32:27.312]                       inherits <- base::inherits
[09:32:27.312]                       invokeRestart <- base::invokeRestart
[09:32:27.312]                       is.null <- base::is.null
[09:32:27.312]                       muffled <- FALSE
[09:32:27.312]                       if (inherits(cond, "message")) {
[09:32:27.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.312]                         if (muffled) 
[09:32:27.312]                           invokeRestart("muffleMessage")
[09:32:27.312]                       }
[09:32:27.312]                       else if (inherits(cond, "warning")) {
[09:32:27.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.312]                         if (muffled) 
[09:32:27.312]                           invokeRestart("muffleWarning")
[09:32:27.312]                       }
[09:32:27.312]                       else if (inherits(cond, "condition")) {
[09:32:27.312]                         if (!is.null(pattern)) {
[09:32:27.312]                           computeRestarts <- base::computeRestarts
[09:32:27.312]                           grepl <- base::grepl
[09:32:27.312]                           restarts <- computeRestarts(cond)
[09:32:27.312]                           for (restart in restarts) {
[09:32:27.312]                             name <- restart$name
[09:32:27.312]                             if (is.null(name)) 
[09:32:27.312]                               next
[09:32:27.312]                             if (!grepl(pattern, name)) 
[09:32:27.312]                               next
[09:32:27.312]                             invokeRestart(restart)
[09:32:27.312]                             muffled <- TRUE
[09:32:27.312]                             break
[09:32:27.312]                           }
[09:32:27.312]                         }
[09:32:27.312]                       }
[09:32:27.312]                       invisible(muffled)
[09:32:27.312]                     }
[09:32:27.312]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.312]                   }
[09:32:27.312]                 }
[09:32:27.312]                 else {
[09:32:27.312]                   if (TRUE) {
[09:32:27.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.312]                     {
[09:32:27.312]                       inherits <- base::inherits
[09:32:27.312]                       invokeRestart <- base::invokeRestart
[09:32:27.312]                       is.null <- base::is.null
[09:32:27.312]                       muffled <- FALSE
[09:32:27.312]                       if (inherits(cond, "message")) {
[09:32:27.312]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.312]                         if (muffled) 
[09:32:27.312]                           invokeRestart("muffleMessage")
[09:32:27.312]                       }
[09:32:27.312]                       else if (inherits(cond, "warning")) {
[09:32:27.312]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.312]                         if (muffled) 
[09:32:27.312]                           invokeRestart("muffleWarning")
[09:32:27.312]                       }
[09:32:27.312]                       else if (inherits(cond, "condition")) {
[09:32:27.312]                         if (!is.null(pattern)) {
[09:32:27.312]                           computeRestarts <- base::computeRestarts
[09:32:27.312]                           grepl <- base::grepl
[09:32:27.312]                           restarts <- computeRestarts(cond)
[09:32:27.312]                           for (restart in restarts) {
[09:32:27.312]                             name <- restart$name
[09:32:27.312]                             if (is.null(name)) 
[09:32:27.312]                               next
[09:32:27.312]                             if (!grepl(pattern, name)) 
[09:32:27.312]                               next
[09:32:27.312]                             invokeRestart(restart)
[09:32:27.312]                             muffled <- TRUE
[09:32:27.312]                             break
[09:32:27.312]                           }
[09:32:27.312]                         }
[09:32:27.312]                       }
[09:32:27.312]                       invisible(muffled)
[09:32:27.312]                     }
[09:32:27.312]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.312]                   }
[09:32:27.312]                 }
[09:32:27.312]             }
[09:32:27.312]         }))
[09:32:27.312]     }, error = function(ex) {
[09:32:27.312]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:27.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.312]                 ...future.rng), started = ...future.startTime, 
[09:32:27.312]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:27.312]             version = "1.8"), class = "FutureResult")
[09:32:27.312]     }, finally = {
[09:32:27.312]         if (!identical(...future.workdir, getwd())) 
[09:32:27.312]             setwd(...future.workdir)
[09:32:27.312]         {
[09:32:27.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:27.312]                 ...future.oldOptions$nwarnings <- NULL
[09:32:27.312]             }
[09:32:27.312]             base::options(...future.oldOptions)
[09:32:27.312]             if (.Platform$OS.type == "windows") {
[09:32:27.312]                 old_names <- names(...future.oldEnvVars)
[09:32:27.312]                 envs <- base::Sys.getenv()
[09:32:27.312]                 names <- names(envs)
[09:32:27.312]                 common <- intersect(names, old_names)
[09:32:27.312]                 added <- setdiff(names, old_names)
[09:32:27.312]                 removed <- setdiff(old_names, names)
[09:32:27.312]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:27.312]                   envs[common]]
[09:32:27.312]                 NAMES <- toupper(changed)
[09:32:27.312]                 args <- list()
[09:32:27.312]                 for (kk in seq_along(NAMES)) {
[09:32:27.312]                   name <- changed[[kk]]
[09:32:27.312]                   NAME <- NAMES[[kk]]
[09:32:27.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.312]                     next
[09:32:27.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.312]                 }
[09:32:27.312]                 NAMES <- toupper(added)
[09:32:27.312]                 for (kk in seq_along(NAMES)) {
[09:32:27.312]                   name <- added[[kk]]
[09:32:27.312]                   NAME <- NAMES[[kk]]
[09:32:27.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.312]                     next
[09:32:27.312]                   args[[name]] <- ""
[09:32:27.312]                 }
[09:32:27.312]                 NAMES <- toupper(removed)
[09:32:27.312]                 for (kk in seq_along(NAMES)) {
[09:32:27.312]                   name <- removed[[kk]]
[09:32:27.312]                   NAME <- NAMES[[kk]]
[09:32:27.312]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.312]                     next
[09:32:27.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.312]                 }
[09:32:27.312]                 if (length(args) > 0) 
[09:32:27.312]                   base::do.call(base::Sys.setenv, args = args)
[09:32:27.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:27.312]             }
[09:32:27.312]             else {
[09:32:27.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:27.312]             }
[09:32:27.312]             {
[09:32:27.312]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:27.312]                   0L) {
[09:32:27.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:27.312]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:27.312]                   base::options(opts)
[09:32:27.312]                 }
[09:32:27.312]                 {
[09:32:27.312]                   {
[09:32:27.312]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:27.312]                     NULL
[09:32:27.312]                   }
[09:32:27.312]                   options(future.plan = NULL)
[09:32:27.312]                   if (is.na(NA_character_)) 
[09:32:27.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:27.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:27.312]                     .init = FALSE)
[09:32:27.312]                 }
[09:32:27.312]             }
[09:32:27.312]         }
[09:32:27.312]     })
[09:32:27.312]     if (TRUE) {
[09:32:27.312]         base::sink(type = "output", split = FALSE)
[09:32:27.312]         if (TRUE) {
[09:32:27.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:27.312]         }
[09:32:27.312]         else {
[09:32:27.312]             ...future.result["stdout"] <- base::list(NULL)
[09:32:27.312]         }
[09:32:27.312]         base::close(...future.stdout)
[09:32:27.312]         ...future.stdout <- NULL
[09:32:27.312]     }
[09:32:27.312]     ...future.result$conditions <- ...future.conditions
[09:32:27.312]     ...future.result$finished <- base::Sys.time()
[09:32:27.312]     ...future.result
[09:32:27.312] }
[09:32:27.315] MultisessionFuture started
[09:32:27.315] - Launch lazy future ... done
[09:32:27.315] run() for ‘MultisessionFuture’ ... done
[09:32:27.316] receiveMessageFromWorker() for ClusterFuture ...
[09:32:27.317] - Validating connection of MultisessionFuture
[09:32:27.317] - received message: FutureResult
[09:32:27.317] - Received FutureResult
[09:32:27.317] - Erased future from FutureRegistry
[09:32:27.317] result() for ClusterFuture ...
[09:32:27.317] - result already collected: FutureResult
[09:32:27.317] result() for ClusterFuture ... done
[09:32:27.318] signalConditions() ...
[09:32:27.318]  - include = ‘immediateCondition’
[09:32:27.318]  - exclude = 
[09:32:27.318]  - resignal = FALSE
[09:32:27.318]  - Number of conditions: 1
[09:32:27.318] signalConditions() ... done
[09:32:27.318] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:27.318] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[09:32:27.318] getGlobalsAndPackages() ...
[09:32:27.318] Searching for globals...
[09:32:27.319] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:27.320] Searching for globals ... DONE
[09:32:27.320] Resolving globals: FALSE
[09:32:27.320] 
[09:32:27.320] 
[09:32:27.320] getGlobalsAndPackages() ... DONE
[09:32:27.320] run() for ‘Future’ ...
[09:32:27.321] - state: ‘created’
[09:32:27.323] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:27.336] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:27.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:27.336]   - Field: ‘node’
[09:32:27.336]   - Field: ‘label’
[09:32:27.337]   - Field: ‘local’
[09:32:27.337]   - Field: ‘owner’
[09:32:27.337]   - Field: ‘envir’
[09:32:27.337]   - Field: ‘workers’
[09:32:27.337]   - Field: ‘packages’
[09:32:27.337]   - Field: ‘gc’
[09:32:27.337]   - Field: ‘conditions’
[09:32:27.337]   - Field: ‘persistent’
[09:32:27.337]   - Field: ‘expr’
[09:32:27.337]   - Field: ‘uuid’
[09:32:27.337]   - Field: ‘seed’
[09:32:27.337]   - Field: ‘version’
[09:32:27.338]   - Field: ‘result’
[09:32:27.338]   - Field: ‘asynchronous’
[09:32:27.338]   - Field: ‘calls’
[09:32:27.338]   - Field: ‘globals’
[09:32:27.338]   - Field: ‘stdout’
[09:32:27.338]   - Field: ‘earlySignal’
[09:32:27.338]   - Field: ‘lazy’
[09:32:27.338]   - Field: ‘state’
[09:32:27.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:27.338] - Launch lazy future ...
[09:32:27.339] Packages needed by the future expression (n = 0): <none>
[09:32:27.339] Packages needed by future strategies (n = 0): <none>
[09:32:27.339] {
[09:32:27.339]     {
[09:32:27.339]         {
[09:32:27.339]             ...future.startTime <- base::Sys.time()
[09:32:27.339]             {
[09:32:27.339]                 {
[09:32:27.339]                   {
[09:32:27.339]                     {
[09:32:27.339]                       base::local({
[09:32:27.339]                         has_future <- base::requireNamespace("future", 
[09:32:27.339]                           quietly = TRUE)
[09:32:27.339]                         if (has_future) {
[09:32:27.339]                           ns <- base::getNamespace("future")
[09:32:27.339]                           version <- ns[[".package"]][["version"]]
[09:32:27.339]                           if (is.null(version)) 
[09:32:27.339]                             version <- utils::packageVersion("future")
[09:32:27.339]                         }
[09:32:27.339]                         else {
[09:32:27.339]                           version <- NULL
[09:32:27.339]                         }
[09:32:27.339]                         if (!has_future || version < "1.8.0") {
[09:32:27.339]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:27.339]                             "", base::R.version$version.string), 
[09:32:27.339]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:27.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:27.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:27.339]                               "release", "version")], collapse = " "), 
[09:32:27.339]                             hostname = base::Sys.info()[["nodename"]])
[09:32:27.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:27.339]                             info)
[09:32:27.339]                           info <- base::paste(info, collapse = "; ")
[09:32:27.339]                           if (!has_future) {
[09:32:27.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:27.339]                               info)
[09:32:27.339]                           }
[09:32:27.339]                           else {
[09:32:27.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:27.339]                               info, version)
[09:32:27.339]                           }
[09:32:27.339]                           base::stop(msg)
[09:32:27.339]                         }
[09:32:27.339]                       })
[09:32:27.339]                     }
[09:32:27.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:27.339]                     base::options(mc.cores = 1L)
[09:32:27.339]                   }
[09:32:27.339]                   ...future.strategy.old <- future::plan("list")
[09:32:27.339]                   options(future.plan = NULL)
[09:32:27.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:27.339]                 }
[09:32:27.339]                 ...future.workdir <- getwd()
[09:32:27.339]             }
[09:32:27.339]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:27.339]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:27.339]         }
[09:32:27.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:27.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:27.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:27.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:27.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:27.339]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:27.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:27.339]             base::names(...future.oldOptions))
[09:32:27.339]     }
[09:32:27.339]     if (FALSE) {
[09:32:27.339]     }
[09:32:27.339]     else {
[09:32:27.339]         if (TRUE) {
[09:32:27.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:27.339]                 open = "w")
[09:32:27.339]         }
[09:32:27.339]         else {
[09:32:27.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:27.339]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:27.339]         }
[09:32:27.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:27.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:27.339]             base::sink(type = "output", split = FALSE)
[09:32:27.339]             base::close(...future.stdout)
[09:32:27.339]         }, add = TRUE)
[09:32:27.339]     }
[09:32:27.339]     ...future.frame <- base::sys.nframe()
[09:32:27.339]     ...future.conditions <- base::list()
[09:32:27.339]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:27.339]     if (FALSE) {
[09:32:27.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:27.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:27.339]     }
[09:32:27.339]     ...future.result <- base::tryCatch({
[09:32:27.339]         base::withCallingHandlers({
[09:32:27.339]             ...future.value <- base::withVisible(base::local({
[09:32:27.339]                 ...future.makeSendCondition <- base::local({
[09:32:27.339]                   sendCondition <- NULL
[09:32:27.339]                   function(frame = 1L) {
[09:32:27.339]                     if (is.function(sendCondition)) 
[09:32:27.339]                       return(sendCondition)
[09:32:27.339]                     ns <- getNamespace("parallel")
[09:32:27.339]                     if (exists("sendData", mode = "function", 
[09:32:27.339]                       envir = ns)) {
[09:32:27.339]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:27.339]                         envir = ns)
[09:32:27.339]                       envir <- sys.frame(frame)
[09:32:27.339]                       master <- NULL
[09:32:27.339]                       while (!identical(envir, .GlobalEnv) && 
[09:32:27.339]                         !identical(envir, emptyenv())) {
[09:32:27.339]                         if (exists("master", mode = "list", envir = envir, 
[09:32:27.339]                           inherits = FALSE)) {
[09:32:27.339]                           master <- get("master", mode = "list", 
[09:32:27.339]                             envir = envir, inherits = FALSE)
[09:32:27.339]                           if (inherits(master, c("SOCKnode", 
[09:32:27.339]                             "SOCK0node"))) {
[09:32:27.339]                             sendCondition <<- function(cond) {
[09:32:27.339]                               data <- list(type = "VALUE", value = cond, 
[09:32:27.339]                                 success = TRUE)
[09:32:27.339]                               parallel_sendData(master, data)
[09:32:27.339]                             }
[09:32:27.339]                             return(sendCondition)
[09:32:27.339]                           }
[09:32:27.339]                         }
[09:32:27.339]                         frame <- frame + 1L
[09:32:27.339]                         envir <- sys.frame(frame)
[09:32:27.339]                       }
[09:32:27.339]                     }
[09:32:27.339]                     sendCondition <<- function(cond) NULL
[09:32:27.339]                   }
[09:32:27.339]                 })
[09:32:27.339]                 withCallingHandlers({
[09:32:27.339]                   {
[09:32:27.339]                     Sys.sleep(0.5)
[09:32:27.339]                     list(a = 1, b = 42L)
[09:32:27.339]                   }
[09:32:27.339]                 }, immediateCondition = function(cond) {
[09:32:27.339]                   sendCondition <- ...future.makeSendCondition()
[09:32:27.339]                   sendCondition(cond)
[09:32:27.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.339]                   {
[09:32:27.339]                     inherits <- base::inherits
[09:32:27.339]                     invokeRestart <- base::invokeRestart
[09:32:27.339]                     is.null <- base::is.null
[09:32:27.339]                     muffled <- FALSE
[09:32:27.339]                     if (inherits(cond, "message")) {
[09:32:27.339]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:27.339]                       if (muffled) 
[09:32:27.339]                         invokeRestart("muffleMessage")
[09:32:27.339]                     }
[09:32:27.339]                     else if (inherits(cond, "warning")) {
[09:32:27.339]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:27.339]                       if (muffled) 
[09:32:27.339]                         invokeRestart("muffleWarning")
[09:32:27.339]                     }
[09:32:27.339]                     else if (inherits(cond, "condition")) {
[09:32:27.339]                       if (!is.null(pattern)) {
[09:32:27.339]                         computeRestarts <- base::computeRestarts
[09:32:27.339]                         grepl <- base::grepl
[09:32:27.339]                         restarts <- computeRestarts(cond)
[09:32:27.339]                         for (restart in restarts) {
[09:32:27.339]                           name <- restart$name
[09:32:27.339]                           if (is.null(name)) 
[09:32:27.339]                             next
[09:32:27.339]                           if (!grepl(pattern, name)) 
[09:32:27.339]                             next
[09:32:27.339]                           invokeRestart(restart)
[09:32:27.339]                           muffled <- TRUE
[09:32:27.339]                           break
[09:32:27.339]                         }
[09:32:27.339]                       }
[09:32:27.339]                     }
[09:32:27.339]                     invisible(muffled)
[09:32:27.339]                   }
[09:32:27.339]                   muffleCondition(cond)
[09:32:27.339]                 })
[09:32:27.339]             }))
[09:32:27.339]             future::FutureResult(value = ...future.value$value, 
[09:32:27.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.339]                   ...future.rng), globalenv = if (FALSE) 
[09:32:27.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:27.339]                     ...future.globalenv.names))
[09:32:27.339]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:27.339]         }, condition = base::local({
[09:32:27.339]             c <- base::c
[09:32:27.339]             inherits <- base::inherits
[09:32:27.339]             invokeRestart <- base::invokeRestart
[09:32:27.339]             length <- base::length
[09:32:27.339]             list <- base::list
[09:32:27.339]             seq.int <- base::seq.int
[09:32:27.339]             signalCondition <- base::signalCondition
[09:32:27.339]             sys.calls <- base::sys.calls
[09:32:27.339]             `[[` <- base::`[[`
[09:32:27.339]             `+` <- base::`+`
[09:32:27.339]             `<<-` <- base::`<<-`
[09:32:27.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:27.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:27.339]                   3L)]
[09:32:27.339]             }
[09:32:27.339]             function(cond) {
[09:32:27.339]                 is_error <- inherits(cond, "error")
[09:32:27.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:27.339]                   NULL)
[09:32:27.339]                 if (is_error) {
[09:32:27.339]                   sessionInformation <- function() {
[09:32:27.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:27.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:27.339]                       search = base::search(), system = base::Sys.info())
[09:32:27.339]                   }
[09:32:27.339]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:27.339]                     cond$call), session = sessionInformation(), 
[09:32:27.339]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:27.339]                   signalCondition(cond)
[09:32:27.339]                 }
[09:32:27.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:27.339]                 "immediateCondition"))) {
[09:32:27.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:27.339]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:27.339]                   if (TRUE && !signal) {
[09:32:27.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.339]                     {
[09:32:27.339]                       inherits <- base::inherits
[09:32:27.339]                       invokeRestart <- base::invokeRestart
[09:32:27.339]                       is.null <- base::is.null
[09:32:27.339]                       muffled <- FALSE
[09:32:27.339]                       if (inherits(cond, "message")) {
[09:32:27.339]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.339]                         if (muffled) 
[09:32:27.339]                           invokeRestart("muffleMessage")
[09:32:27.339]                       }
[09:32:27.339]                       else if (inherits(cond, "warning")) {
[09:32:27.339]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.339]                         if (muffled) 
[09:32:27.339]                           invokeRestart("muffleWarning")
[09:32:27.339]                       }
[09:32:27.339]                       else if (inherits(cond, "condition")) {
[09:32:27.339]                         if (!is.null(pattern)) {
[09:32:27.339]                           computeRestarts <- base::computeRestarts
[09:32:27.339]                           grepl <- base::grepl
[09:32:27.339]                           restarts <- computeRestarts(cond)
[09:32:27.339]                           for (restart in restarts) {
[09:32:27.339]                             name <- restart$name
[09:32:27.339]                             if (is.null(name)) 
[09:32:27.339]                               next
[09:32:27.339]                             if (!grepl(pattern, name)) 
[09:32:27.339]                               next
[09:32:27.339]                             invokeRestart(restart)
[09:32:27.339]                             muffled <- TRUE
[09:32:27.339]                             break
[09:32:27.339]                           }
[09:32:27.339]                         }
[09:32:27.339]                       }
[09:32:27.339]                       invisible(muffled)
[09:32:27.339]                     }
[09:32:27.339]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.339]                   }
[09:32:27.339]                 }
[09:32:27.339]                 else {
[09:32:27.339]                   if (TRUE) {
[09:32:27.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.339]                     {
[09:32:27.339]                       inherits <- base::inherits
[09:32:27.339]                       invokeRestart <- base::invokeRestart
[09:32:27.339]                       is.null <- base::is.null
[09:32:27.339]                       muffled <- FALSE
[09:32:27.339]                       if (inherits(cond, "message")) {
[09:32:27.339]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.339]                         if (muffled) 
[09:32:27.339]                           invokeRestart("muffleMessage")
[09:32:27.339]                       }
[09:32:27.339]                       else if (inherits(cond, "warning")) {
[09:32:27.339]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.339]                         if (muffled) 
[09:32:27.339]                           invokeRestart("muffleWarning")
[09:32:27.339]                       }
[09:32:27.339]                       else if (inherits(cond, "condition")) {
[09:32:27.339]                         if (!is.null(pattern)) {
[09:32:27.339]                           computeRestarts <- base::computeRestarts
[09:32:27.339]                           grepl <- base::grepl
[09:32:27.339]                           restarts <- computeRestarts(cond)
[09:32:27.339]                           for (restart in restarts) {
[09:32:27.339]                             name <- restart$name
[09:32:27.339]                             if (is.null(name)) 
[09:32:27.339]                               next
[09:32:27.339]                             if (!grepl(pattern, name)) 
[09:32:27.339]                               next
[09:32:27.339]                             invokeRestart(restart)
[09:32:27.339]                             muffled <- TRUE
[09:32:27.339]                             break
[09:32:27.339]                           }
[09:32:27.339]                         }
[09:32:27.339]                       }
[09:32:27.339]                       invisible(muffled)
[09:32:27.339]                     }
[09:32:27.339]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.339]                   }
[09:32:27.339]                 }
[09:32:27.339]             }
[09:32:27.339]         }))
[09:32:27.339]     }, error = function(ex) {
[09:32:27.339]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:27.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.339]                 ...future.rng), started = ...future.startTime, 
[09:32:27.339]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:27.339]             version = "1.8"), class = "FutureResult")
[09:32:27.339]     }, finally = {
[09:32:27.339]         if (!identical(...future.workdir, getwd())) 
[09:32:27.339]             setwd(...future.workdir)
[09:32:27.339]         {
[09:32:27.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:27.339]                 ...future.oldOptions$nwarnings <- NULL
[09:32:27.339]             }
[09:32:27.339]             base::options(...future.oldOptions)
[09:32:27.339]             if (.Platform$OS.type == "windows") {
[09:32:27.339]                 old_names <- names(...future.oldEnvVars)
[09:32:27.339]                 envs <- base::Sys.getenv()
[09:32:27.339]                 names <- names(envs)
[09:32:27.339]                 common <- intersect(names, old_names)
[09:32:27.339]                 added <- setdiff(names, old_names)
[09:32:27.339]                 removed <- setdiff(old_names, names)
[09:32:27.339]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:27.339]                   envs[common]]
[09:32:27.339]                 NAMES <- toupper(changed)
[09:32:27.339]                 args <- list()
[09:32:27.339]                 for (kk in seq_along(NAMES)) {
[09:32:27.339]                   name <- changed[[kk]]
[09:32:27.339]                   NAME <- NAMES[[kk]]
[09:32:27.339]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.339]                     next
[09:32:27.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.339]                 }
[09:32:27.339]                 NAMES <- toupper(added)
[09:32:27.339]                 for (kk in seq_along(NAMES)) {
[09:32:27.339]                   name <- added[[kk]]
[09:32:27.339]                   NAME <- NAMES[[kk]]
[09:32:27.339]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.339]                     next
[09:32:27.339]                   args[[name]] <- ""
[09:32:27.339]                 }
[09:32:27.339]                 NAMES <- toupper(removed)
[09:32:27.339]                 for (kk in seq_along(NAMES)) {
[09:32:27.339]                   name <- removed[[kk]]
[09:32:27.339]                   NAME <- NAMES[[kk]]
[09:32:27.339]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.339]                     next
[09:32:27.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.339]                 }
[09:32:27.339]                 if (length(args) > 0) 
[09:32:27.339]                   base::do.call(base::Sys.setenv, args = args)
[09:32:27.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:27.339]             }
[09:32:27.339]             else {
[09:32:27.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:27.339]             }
[09:32:27.339]             {
[09:32:27.339]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:27.339]                   0L) {
[09:32:27.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:27.339]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:27.339]                   base::options(opts)
[09:32:27.339]                 }
[09:32:27.339]                 {
[09:32:27.339]                   {
[09:32:27.339]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:27.339]                     NULL
[09:32:27.339]                   }
[09:32:27.339]                   options(future.plan = NULL)
[09:32:27.339]                   if (is.na(NA_character_)) 
[09:32:27.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:27.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:27.339]                     .init = FALSE)
[09:32:27.339]                 }
[09:32:27.339]             }
[09:32:27.339]         }
[09:32:27.339]     })
[09:32:27.339]     if (TRUE) {
[09:32:27.339]         base::sink(type = "output", split = FALSE)
[09:32:27.339]         if (TRUE) {
[09:32:27.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:27.339]         }
[09:32:27.339]         else {
[09:32:27.339]             ...future.result["stdout"] <- base::list(NULL)
[09:32:27.339]         }
[09:32:27.339]         base::close(...future.stdout)
[09:32:27.339]         ...future.stdout <- NULL
[09:32:27.339]     }
[09:32:27.339]     ...future.result$conditions <- ...future.conditions
[09:32:27.339]     ...future.result$finished <- base::Sys.time()
[09:32:27.339]     ...future.result
[09:32:27.339] }
[09:32:27.342] MultisessionFuture started
[09:32:27.342] - Launch lazy future ... done
[09:32:27.342] run() for ‘MultisessionFuture’ ... done
[09:32:27.844] receiveMessageFromWorker() for ClusterFuture ...
[09:32:27.844] - Validating connection of MultisessionFuture
[09:32:27.844] - received message: FutureResult
[09:32:27.844] - Received FutureResult
[09:32:27.845] - Erased future from FutureRegistry
[09:32:27.845] result() for ClusterFuture ...
[09:32:27.845] - result already collected: FutureResult
[09:32:27.845] result() for ClusterFuture ... done
[09:32:27.845] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:27.845] A MultisessionFuture was resolved (result was not collected)
[09:32:27.845] getGlobalsAndPackages() ...
[09:32:27.845] Searching for globals...
[09:32:27.846] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:27.846] Searching for globals ... DONE
[09:32:27.847] Resolving globals: FALSE
[09:32:27.847] 
[09:32:27.847] 
[09:32:27.847] getGlobalsAndPackages() ... DONE
[09:32:27.847] run() for ‘Future’ ...
[09:32:27.847] - state: ‘created’
[09:32:27.847] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:27.861] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:27.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:27.861]   - Field: ‘node’
[09:32:27.861]   - Field: ‘label’
[09:32:27.861]   - Field: ‘local’
[09:32:27.861]   - Field: ‘owner’
[09:32:27.862]   - Field: ‘envir’
[09:32:27.862]   - Field: ‘workers’
[09:32:27.862]   - Field: ‘packages’
[09:32:27.862]   - Field: ‘gc’
[09:32:27.862]   - Field: ‘conditions’
[09:32:27.862]   - Field: ‘persistent’
[09:32:27.862]   - Field: ‘expr’
[09:32:27.862]   - Field: ‘uuid’
[09:32:27.862]   - Field: ‘seed’
[09:32:27.862]   - Field: ‘version’
[09:32:27.862]   - Field: ‘result’
[09:32:27.863]   - Field: ‘asynchronous’
[09:32:27.863]   - Field: ‘calls’
[09:32:27.863]   - Field: ‘globals’
[09:32:27.863]   - Field: ‘stdout’
[09:32:27.863]   - Field: ‘earlySignal’
[09:32:27.863]   - Field: ‘lazy’
[09:32:27.863]   - Field: ‘state’
[09:32:27.863] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:27.863] - Launch lazy future ...
[09:32:27.864] Packages needed by the future expression (n = 0): <none>
[09:32:27.864] Packages needed by future strategies (n = 0): <none>
[09:32:27.864] {
[09:32:27.864]     {
[09:32:27.864]         {
[09:32:27.864]             ...future.startTime <- base::Sys.time()
[09:32:27.864]             {
[09:32:27.864]                 {
[09:32:27.864]                   {
[09:32:27.864]                     {
[09:32:27.864]                       base::local({
[09:32:27.864]                         has_future <- base::requireNamespace("future", 
[09:32:27.864]                           quietly = TRUE)
[09:32:27.864]                         if (has_future) {
[09:32:27.864]                           ns <- base::getNamespace("future")
[09:32:27.864]                           version <- ns[[".package"]][["version"]]
[09:32:27.864]                           if (is.null(version)) 
[09:32:27.864]                             version <- utils::packageVersion("future")
[09:32:27.864]                         }
[09:32:27.864]                         else {
[09:32:27.864]                           version <- NULL
[09:32:27.864]                         }
[09:32:27.864]                         if (!has_future || version < "1.8.0") {
[09:32:27.864]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:27.864]                             "", base::R.version$version.string), 
[09:32:27.864]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:27.864]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:27.864]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:27.864]                               "release", "version")], collapse = " "), 
[09:32:27.864]                             hostname = base::Sys.info()[["nodename"]])
[09:32:27.864]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:27.864]                             info)
[09:32:27.864]                           info <- base::paste(info, collapse = "; ")
[09:32:27.864]                           if (!has_future) {
[09:32:27.864]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:27.864]                               info)
[09:32:27.864]                           }
[09:32:27.864]                           else {
[09:32:27.864]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:27.864]                               info, version)
[09:32:27.864]                           }
[09:32:27.864]                           base::stop(msg)
[09:32:27.864]                         }
[09:32:27.864]                       })
[09:32:27.864]                     }
[09:32:27.864]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:27.864]                     base::options(mc.cores = 1L)
[09:32:27.864]                   }
[09:32:27.864]                   ...future.strategy.old <- future::plan("list")
[09:32:27.864]                   options(future.plan = NULL)
[09:32:27.864]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.864]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:27.864]                 }
[09:32:27.864]                 ...future.workdir <- getwd()
[09:32:27.864]             }
[09:32:27.864]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:27.864]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:27.864]         }
[09:32:27.864]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:27.864]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:27.864]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:27.864]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:27.864]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:27.864]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:27.864]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:27.864]             base::names(...future.oldOptions))
[09:32:27.864]     }
[09:32:27.864]     if (FALSE) {
[09:32:27.864]     }
[09:32:27.864]     else {
[09:32:27.864]         if (TRUE) {
[09:32:27.864]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:27.864]                 open = "w")
[09:32:27.864]         }
[09:32:27.864]         else {
[09:32:27.864]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:27.864]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:27.864]         }
[09:32:27.864]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:27.864]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:27.864]             base::sink(type = "output", split = FALSE)
[09:32:27.864]             base::close(...future.stdout)
[09:32:27.864]         }, add = TRUE)
[09:32:27.864]     }
[09:32:27.864]     ...future.frame <- base::sys.nframe()
[09:32:27.864]     ...future.conditions <- base::list()
[09:32:27.864]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:27.864]     if (FALSE) {
[09:32:27.864]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:27.864]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:27.864]     }
[09:32:27.864]     ...future.result <- base::tryCatch({
[09:32:27.864]         base::withCallingHandlers({
[09:32:27.864]             ...future.value <- base::withVisible(base::local({
[09:32:27.864]                 ...future.makeSendCondition <- base::local({
[09:32:27.864]                   sendCondition <- NULL
[09:32:27.864]                   function(frame = 1L) {
[09:32:27.864]                     if (is.function(sendCondition)) 
[09:32:27.864]                       return(sendCondition)
[09:32:27.864]                     ns <- getNamespace("parallel")
[09:32:27.864]                     if (exists("sendData", mode = "function", 
[09:32:27.864]                       envir = ns)) {
[09:32:27.864]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:27.864]                         envir = ns)
[09:32:27.864]                       envir <- sys.frame(frame)
[09:32:27.864]                       master <- NULL
[09:32:27.864]                       while (!identical(envir, .GlobalEnv) && 
[09:32:27.864]                         !identical(envir, emptyenv())) {
[09:32:27.864]                         if (exists("master", mode = "list", envir = envir, 
[09:32:27.864]                           inherits = FALSE)) {
[09:32:27.864]                           master <- get("master", mode = "list", 
[09:32:27.864]                             envir = envir, inherits = FALSE)
[09:32:27.864]                           if (inherits(master, c("SOCKnode", 
[09:32:27.864]                             "SOCK0node"))) {
[09:32:27.864]                             sendCondition <<- function(cond) {
[09:32:27.864]                               data <- list(type = "VALUE", value = cond, 
[09:32:27.864]                                 success = TRUE)
[09:32:27.864]                               parallel_sendData(master, data)
[09:32:27.864]                             }
[09:32:27.864]                             return(sendCondition)
[09:32:27.864]                           }
[09:32:27.864]                         }
[09:32:27.864]                         frame <- frame + 1L
[09:32:27.864]                         envir <- sys.frame(frame)
[09:32:27.864]                       }
[09:32:27.864]                     }
[09:32:27.864]                     sendCondition <<- function(cond) NULL
[09:32:27.864]                   }
[09:32:27.864]                 })
[09:32:27.864]                 withCallingHandlers({
[09:32:27.864]                   {
[09:32:27.864]                     Sys.sleep(0.5)
[09:32:27.864]                     list(a = 1, b = 42L)
[09:32:27.864]                   }
[09:32:27.864]                 }, immediateCondition = function(cond) {
[09:32:27.864]                   sendCondition <- ...future.makeSendCondition()
[09:32:27.864]                   sendCondition(cond)
[09:32:27.864]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.864]                   {
[09:32:27.864]                     inherits <- base::inherits
[09:32:27.864]                     invokeRestart <- base::invokeRestart
[09:32:27.864]                     is.null <- base::is.null
[09:32:27.864]                     muffled <- FALSE
[09:32:27.864]                     if (inherits(cond, "message")) {
[09:32:27.864]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:27.864]                       if (muffled) 
[09:32:27.864]                         invokeRestart("muffleMessage")
[09:32:27.864]                     }
[09:32:27.864]                     else if (inherits(cond, "warning")) {
[09:32:27.864]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:27.864]                       if (muffled) 
[09:32:27.864]                         invokeRestart("muffleWarning")
[09:32:27.864]                     }
[09:32:27.864]                     else if (inherits(cond, "condition")) {
[09:32:27.864]                       if (!is.null(pattern)) {
[09:32:27.864]                         computeRestarts <- base::computeRestarts
[09:32:27.864]                         grepl <- base::grepl
[09:32:27.864]                         restarts <- computeRestarts(cond)
[09:32:27.864]                         for (restart in restarts) {
[09:32:27.864]                           name <- restart$name
[09:32:27.864]                           if (is.null(name)) 
[09:32:27.864]                             next
[09:32:27.864]                           if (!grepl(pattern, name)) 
[09:32:27.864]                             next
[09:32:27.864]                           invokeRestart(restart)
[09:32:27.864]                           muffled <- TRUE
[09:32:27.864]                           break
[09:32:27.864]                         }
[09:32:27.864]                       }
[09:32:27.864]                     }
[09:32:27.864]                     invisible(muffled)
[09:32:27.864]                   }
[09:32:27.864]                   muffleCondition(cond)
[09:32:27.864]                 })
[09:32:27.864]             }))
[09:32:27.864]             future::FutureResult(value = ...future.value$value, 
[09:32:27.864]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.864]                   ...future.rng), globalenv = if (FALSE) 
[09:32:27.864]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:27.864]                     ...future.globalenv.names))
[09:32:27.864]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:27.864]         }, condition = base::local({
[09:32:27.864]             c <- base::c
[09:32:27.864]             inherits <- base::inherits
[09:32:27.864]             invokeRestart <- base::invokeRestart
[09:32:27.864]             length <- base::length
[09:32:27.864]             list <- base::list
[09:32:27.864]             seq.int <- base::seq.int
[09:32:27.864]             signalCondition <- base::signalCondition
[09:32:27.864]             sys.calls <- base::sys.calls
[09:32:27.864]             `[[` <- base::`[[`
[09:32:27.864]             `+` <- base::`+`
[09:32:27.864]             `<<-` <- base::`<<-`
[09:32:27.864]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:27.864]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:27.864]                   3L)]
[09:32:27.864]             }
[09:32:27.864]             function(cond) {
[09:32:27.864]                 is_error <- inherits(cond, "error")
[09:32:27.864]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:27.864]                   NULL)
[09:32:27.864]                 if (is_error) {
[09:32:27.864]                   sessionInformation <- function() {
[09:32:27.864]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:27.864]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:27.864]                       search = base::search(), system = base::Sys.info())
[09:32:27.864]                   }
[09:32:27.864]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.864]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:27.864]                     cond$call), session = sessionInformation(), 
[09:32:27.864]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:27.864]                   signalCondition(cond)
[09:32:27.864]                 }
[09:32:27.864]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:27.864]                 "immediateCondition"))) {
[09:32:27.864]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:27.864]                   ...future.conditions[[length(...future.conditions) + 
[09:32:27.864]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:27.864]                   if (TRUE && !signal) {
[09:32:27.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.864]                     {
[09:32:27.864]                       inherits <- base::inherits
[09:32:27.864]                       invokeRestart <- base::invokeRestart
[09:32:27.864]                       is.null <- base::is.null
[09:32:27.864]                       muffled <- FALSE
[09:32:27.864]                       if (inherits(cond, "message")) {
[09:32:27.864]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.864]                         if (muffled) 
[09:32:27.864]                           invokeRestart("muffleMessage")
[09:32:27.864]                       }
[09:32:27.864]                       else if (inherits(cond, "warning")) {
[09:32:27.864]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.864]                         if (muffled) 
[09:32:27.864]                           invokeRestart("muffleWarning")
[09:32:27.864]                       }
[09:32:27.864]                       else if (inherits(cond, "condition")) {
[09:32:27.864]                         if (!is.null(pattern)) {
[09:32:27.864]                           computeRestarts <- base::computeRestarts
[09:32:27.864]                           grepl <- base::grepl
[09:32:27.864]                           restarts <- computeRestarts(cond)
[09:32:27.864]                           for (restart in restarts) {
[09:32:27.864]                             name <- restart$name
[09:32:27.864]                             if (is.null(name)) 
[09:32:27.864]                               next
[09:32:27.864]                             if (!grepl(pattern, name)) 
[09:32:27.864]                               next
[09:32:27.864]                             invokeRestart(restart)
[09:32:27.864]                             muffled <- TRUE
[09:32:27.864]                             break
[09:32:27.864]                           }
[09:32:27.864]                         }
[09:32:27.864]                       }
[09:32:27.864]                       invisible(muffled)
[09:32:27.864]                     }
[09:32:27.864]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.864]                   }
[09:32:27.864]                 }
[09:32:27.864]                 else {
[09:32:27.864]                   if (TRUE) {
[09:32:27.864]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:27.864]                     {
[09:32:27.864]                       inherits <- base::inherits
[09:32:27.864]                       invokeRestart <- base::invokeRestart
[09:32:27.864]                       is.null <- base::is.null
[09:32:27.864]                       muffled <- FALSE
[09:32:27.864]                       if (inherits(cond, "message")) {
[09:32:27.864]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:27.864]                         if (muffled) 
[09:32:27.864]                           invokeRestart("muffleMessage")
[09:32:27.864]                       }
[09:32:27.864]                       else if (inherits(cond, "warning")) {
[09:32:27.864]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:27.864]                         if (muffled) 
[09:32:27.864]                           invokeRestart("muffleWarning")
[09:32:27.864]                       }
[09:32:27.864]                       else if (inherits(cond, "condition")) {
[09:32:27.864]                         if (!is.null(pattern)) {
[09:32:27.864]                           computeRestarts <- base::computeRestarts
[09:32:27.864]                           grepl <- base::grepl
[09:32:27.864]                           restarts <- computeRestarts(cond)
[09:32:27.864]                           for (restart in restarts) {
[09:32:27.864]                             name <- restart$name
[09:32:27.864]                             if (is.null(name)) 
[09:32:27.864]                               next
[09:32:27.864]                             if (!grepl(pattern, name)) 
[09:32:27.864]                               next
[09:32:27.864]                             invokeRestart(restart)
[09:32:27.864]                             muffled <- TRUE
[09:32:27.864]                             break
[09:32:27.864]                           }
[09:32:27.864]                         }
[09:32:27.864]                       }
[09:32:27.864]                       invisible(muffled)
[09:32:27.864]                     }
[09:32:27.864]                     muffleCondition(cond, pattern = "^muffle")
[09:32:27.864]                   }
[09:32:27.864]                 }
[09:32:27.864]             }
[09:32:27.864]         }))
[09:32:27.864]     }, error = function(ex) {
[09:32:27.864]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:27.864]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:27.864]                 ...future.rng), started = ...future.startTime, 
[09:32:27.864]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:27.864]             version = "1.8"), class = "FutureResult")
[09:32:27.864]     }, finally = {
[09:32:27.864]         if (!identical(...future.workdir, getwd())) 
[09:32:27.864]             setwd(...future.workdir)
[09:32:27.864]         {
[09:32:27.864]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:27.864]                 ...future.oldOptions$nwarnings <- NULL
[09:32:27.864]             }
[09:32:27.864]             base::options(...future.oldOptions)
[09:32:27.864]             if (.Platform$OS.type == "windows") {
[09:32:27.864]                 old_names <- names(...future.oldEnvVars)
[09:32:27.864]                 envs <- base::Sys.getenv()
[09:32:27.864]                 names <- names(envs)
[09:32:27.864]                 common <- intersect(names, old_names)
[09:32:27.864]                 added <- setdiff(names, old_names)
[09:32:27.864]                 removed <- setdiff(old_names, names)
[09:32:27.864]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:27.864]                   envs[common]]
[09:32:27.864]                 NAMES <- toupper(changed)
[09:32:27.864]                 args <- list()
[09:32:27.864]                 for (kk in seq_along(NAMES)) {
[09:32:27.864]                   name <- changed[[kk]]
[09:32:27.864]                   NAME <- NAMES[[kk]]
[09:32:27.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.864]                     next
[09:32:27.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.864]                 }
[09:32:27.864]                 NAMES <- toupper(added)
[09:32:27.864]                 for (kk in seq_along(NAMES)) {
[09:32:27.864]                   name <- added[[kk]]
[09:32:27.864]                   NAME <- NAMES[[kk]]
[09:32:27.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.864]                     next
[09:32:27.864]                   args[[name]] <- ""
[09:32:27.864]                 }
[09:32:27.864]                 NAMES <- toupper(removed)
[09:32:27.864]                 for (kk in seq_along(NAMES)) {
[09:32:27.864]                   name <- removed[[kk]]
[09:32:27.864]                   NAME <- NAMES[[kk]]
[09:32:27.864]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:27.864]                     next
[09:32:27.864]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:27.864]                 }
[09:32:27.864]                 if (length(args) > 0) 
[09:32:27.864]                   base::do.call(base::Sys.setenv, args = args)
[09:32:27.864]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:27.864]             }
[09:32:27.864]             else {
[09:32:27.864]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:27.864]             }
[09:32:27.864]             {
[09:32:27.864]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:27.864]                   0L) {
[09:32:27.864]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:27.864]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:27.864]                   base::options(opts)
[09:32:27.864]                 }
[09:32:27.864]                 {
[09:32:27.864]                   {
[09:32:27.864]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:27.864]                     NULL
[09:32:27.864]                   }
[09:32:27.864]                   options(future.plan = NULL)
[09:32:27.864]                   if (is.na(NA_character_)) 
[09:32:27.864]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:27.864]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:27.864]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:27.864]                     .init = FALSE)
[09:32:27.864]                 }
[09:32:27.864]             }
[09:32:27.864]         }
[09:32:27.864]     })
[09:32:27.864]     if (TRUE) {
[09:32:27.864]         base::sink(type = "output", split = FALSE)
[09:32:27.864]         if (TRUE) {
[09:32:27.864]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:27.864]         }
[09:32:27.864]         else {
[09:32:27.864]             ...future.result["stdout"] <- base::list(NULL)
[09:32:27.864]         }
[09:32:27.864]         base::close(...future.stdout)
[09:32:27.864]         ...future.stdout <- NULL
[09:32:27.864]     }
[09:32:27.864]     ...future.result$conditions <- ...future.conditions
[09:32:27.864]     ...future.result$finished <- base::Sys.time()
[09:32:27.864]     ...future.result
[09:32:27.864] }
[09:32:27.867] MultisessionFuture started
[09:32:27.867] - Launch lazy future ... done
[09:32:27.867] run() for ‘MultisessionFuture’ ... done
[09:32:28.369] receiveMessageFromWorker() for ClusterFuture ...
[09:32:28.370] - Validating connection of MultisessionFuture
[09:32:28.370] - received message: FutureResult
[09:32:28.370] - Received FutureResult
[09:32:28.370] - Erased future from FutureRegistry
[09:32:28.370] result() for ClusterFuture ...
[09:32:28.370] - result already collected: FutureResult
[09:32:28.370] result() for ClusterFuture ... done
[09:32:28.370] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:28.371] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:28.371] getGlobalsAndPackages() ...
[09:32:28.371] Searching for globals...
[09:32:28.372] - globals found: [2] ‘list’, ‘stop’
[09:32:28.372] Searching for globals ... DONE
[09:32:28.372] Resolving globals: FALSE
[09:32:28.372] 
[09:32:28.372] 
[09:32:28.372] getGlobalsAndPackages() ... DONE
[09:32:28.373] run() for ‘Future’ ...
[09:32:28.373] - state: ‘created’
[09:32:28.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:28.386] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:28.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:28.387]   - Field: ‘node’
[09:32:28.387]   - Field: ‘label’
[09:32:28.387]   - Field: ‘local’
[09:32:28.387]   - Field: ‘owner’
[09:32:28.387]   - Field: ‘envir’
[09:32:28.387]   - Field: ‘workers’
[09:32:28.387]   - Field: ‘packages’
[09:32:28.387]   - Field: ‘gc’
[09:32:28.387]   - Field: ‘conditions’
[09:32:28.387]   - Field: ‘persistent’
[09:32:28.388]   - Field: ‘expr’
[09:32:28.388]   - Field: ‘uuid’
[09:32:28.388]   - Field: ‘seed’
[09:32:28.388]   - Field: ‘version’
[09:32:28.388]   - Field: ‘result’
[09:32:28.388]   - Field: ‘asynchronous’
[09:32:28.388]   - Field: ‘calls’
[09:32:28.388]   - Field: ‘globals’
[09:32:28.388]   - Field: ‘stdout’
[09:32:28.388]   - Field: ‘earlySignal’
[09:32:28.388]   - Field: ‘lazy’
[09:32:28.389]   - Field: ‘state’
[09:32:28.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:28.389] - Launch lazy future ...
[09:32:28.389] Packages needed by the future expression (n = 0): <none>
[09:32:28.389] Packages needed by future strategies (n = 0): <none>
[09:32:28.390] {
[09:32:28.390]     {
[09:32:28.390]         {
[09:32:28.390]             ...future.startTime <- base::Sys.time()
[09:32:28.390]             {
[09:32:28.390]                 {
[09:32:28.390]                   {
[09:32:28.390]                     {
[09:32:28.390]                       base::local({
[09:32:28.390]                         has_future <- base::requireNamespace("future", 
[09:32:28.390]                           quietly = TRUE)
[09:32:28.390]                         if (has_future) {
[09:32:28.390]                           ns <- base::getNamespace("future")
[09:32:28.390]                           version <- ns[[".package"]][["version"]]
[09:32:28.390]                           if (is.null(version)) 
[09:32:28.390]                             version <- utils::packageVersion("future")
[09:32:28.390]                         }
[09:32:28.390]                         else {
[09:32:28.390]                           version <- NULL
[09:32:28.390]                         }
[09:32:28.390]                         if (!has_future || version < "1.8.0") {
[09:32:28.390]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:28.390]                             "", base::R.version$version.string), 
[09:32:28.390]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:28.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:28.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:28.390]                               "release", "version")], collapse = " "), 
[09:32:28.390]                             hostname = base::Sys.info()[["nodename"]])
[09:32:28.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:28.390]                             info)
[09:32:28.390]                           info <- base::paste(info, collapse = "; ")
[09:32:28.390]                           if (!has_future) {
[09:32:28.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:28.390]                               info)
[09:32:28.390]                           }
[09:32:28.390]                           else {
[09:32:28.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:28.390]                               info, version)
[09:32:28.390]                           }
[09:32:28.390]                           base::stop(msg)
[09:32:28.390]                         }
[09:32:28.390]                       })
[09:32:28.390]                     }
[09:32:28.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:28.390]                     base::options(mc.cores = 1L)
[09:32:28.390]                   }
[09:32:28.390]                   ...future.strategy.old <- future::plan("list")
[09:32:28.390]                   options(future.plan = NULL)
[09:32:28.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:28.390]                 }
[09:32:28.390]                 ...future.workdir <- getwd()
[09:32:28.390]             }
[09:32:28.390]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:28.390]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:28.390]         }
[09:32:28.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:28.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:28.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:28.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:28.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:28.390]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:28.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:28.390]             base::names(...future.oldOptions))
[09:32:28.390]     }
[09:32:28.390]     if (FALSE) {
[09:32:28.390]     }
[09:32:28.390]     else {
[09:32:28.390]         if (TRUE) {
[09:32:28.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:28.390]                 open = "w")
[09:32:28.390]         }
[09:32:28.390]         else {
[09:32:28.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:28.390]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:28.390]         }
[09:32:28.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:28.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:28.390]             base::sink(type = "output", split = FALSE)
[09:32:28.390]             base::close(...future.stdout)
[09:32:28.390]         }, add = TRUE)
[09:32:28.390]     }
[09:32:28.390]     ...future.frame <- base::sys.nframe()
[09:32:28.390]     ...future.conditions <- base::list()
[09:32:28.390]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:28.390]     if (FALSE) {
[09:32:28.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:28.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:28.390]     }
[09:32:28.390]     ...future.result <- base::tryCatch({
[09:32:28.390]         base::withCallingHandlers({
[09:32:28.390]             ...future.value <- base::withVisible(base::local({
[09:32:28.390]                 ...future.makeSendCondition <- base::local({
[09:32:28.390]                   sendCondition <- NULL
[09:32:28.390]                   function(frame = 1L) {
[09:32:28.390]                     if (is.function(sendCondition)) 
[09:32:28.390]                       return(sendCondition)
[09:32:28.390]                     ns <- getNamespace("parallel")
[09:32:28.390]                     if (exists("sendData", mode = "function", 
[09:32:28.390]                       envir = ns)) {
[09:32:28.390]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:28.390]                         envir = ns)
[09:32:28.390]                       envir <- sys.frame(frame)
[09:32:28.390]                       master <- NULL
[09:32:28.390]                       while (!identical(envir, .GlobalEnv) && 
[09:32:28.390]                         !identical(envir, emptyenv())) {
[09:32:28.390]                         if (exists("master", mode = "list", envir = envir, 
[09:32:28.390]                           inherits = FALSE)) {
[09:32:28.390]                           master <- get("master", mode = "list", 
[09:32:28.390]                             envir = envir, inherits = FALSE)
[09:32:28.390]                           if (inherits(master, c("SOCKnode", 
[09:32:28.390]                             "SOCK0node"))) {
[09:32:28.390]                             sendCondition <<- function(cond) {
[09:32:28.390]                               data <- list(type = "VALUE", value = cond, 
[09:32:28.390]                                 success = TRUE)
[09:32:28.390]                               parallel_sendData(master, data)
[09:32:28.390]                             }
[09:32:28.390]                             return(sendCondition)
[09:32:28.390]                           }
[09:32:28.390]                         }
[09:32:28.390]                         frame <- frame + 1L
[09:32:28.390]                         envir <- sys.frame(frame)
[09:32:28.390]                       }
[09:32:28.390]                     }
[09:32:28.390]                     sendCondition <<- function(cond) NULL
[09:32:28.390]                   }
[09:32:28.390]                 })
[09:32:28.390]                 withCallingHandlers({
[09:32:28.390]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:28.390]                 }, immediateCondition = function(cond) {
[09:32:28.390]                   sendCondition <- ...future.makeSendCondition()
[09:32:28.390]                   sendCondition(cond)
[09:32:28.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.390]                   {
[09:32:28.390]                     inherits <- base::inherits
[09:32:28.390]                     invokeRestart <- base::invokeRestart
[09:32:28.390]                     is.null <- base::is.null
[09:32:28.390]                     muffled <- FALSE
[09:32:28.390]                     if (inherits(cond, "message")) {
[09:32:28.390]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:28.390]                       if (muffled) 
[09:32:28.390]                         invokeRestart("muffleMessage")
[09:32:28.390]                     }
[09:32:28.390]                     else if (inherits(cond, "warning")) {
[09:32:28.390]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:28.390]                       if (muffled) 
[09:32:28.390]                         invokeRestart("muffleWarning")
[09:32:28.390]                     }
[09:32:28.390]                     else if (inherits(cond, "condition")) {
[09:32:28.390]                       if (!is.null(pattern)) {
[09:32:28.390]                         computeRestarts <- base::computeRestarts
[09:32:28.390]                         grepl <- base::grepl
[09:32:28.390]                         restarts <- computeRestarts(cond)
[09:32:28.390]                         for (restart in restarts) {
[09:32:28.390]                           name <- restart$name
[09:32:28.390]                           if (is.null(name)) 
[09:32:28.390]                             next
[09:32:28.390]                           if (!grepl(pattern, name)) 
[09:32:28.390]                             next
[09:32:28.390]                           invokeRestart(restart)
[09:32:28.390]                           muffled <- TRUE
[09:32:28.390]                           break
[09:32:28.390]                         }
[09:32:28.390]                       }
[09:32:28.390]                     }
[09:32:28.390]                     invisible(muffled)
[09:32:28.390]                   }
[09:32:28.390]                   muffleCondition(cond)
[09:32:28.390]                 })
[09:32:28.390]             }))
[09:32:28.390]             future::FutureResult(value = ...future.value$value, 
[09:32:28.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.390]                   ...future.rng), globalenv = if (FALSE) 
[09:32:28.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:28.390]                     ...future.globalenv.names))
[09:32:28.390]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:28.390]         }, condition = base::local({
[09:32:28.390]             c <- base::c
[09:32:28.390]             inherits <- base::inherits
[09:32:28.390]             invokeRestart <- base::invokeRestart
[09:32:28.390]             length <- base::length
[09:32:28.390]             list <- base::list
[09:32:28.390]             seq.int <- base::seq.int
[09:32:28.390]             signalCondition <- base::signalCondition
[09:32:28.390]             sys.calls <- base::sys.calls
[09:32:28.390]             `[[` <- base::`[[`
[09:32:28.390]             `+` <- base::`+`
[09:32:28.390]             `<<-` <- base::`<<-`
[09:32:28.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:28.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:28.390]                   3L)]
[09:32:28.390]             }
[09:32:28.390]             function(cond) {
[09:32:28.390]                 is_error <- inherits(cond, "error")
[09:32:28.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:28.390]                   NULL)
[09:32:28.390]                 if (is_error) {
[09:32:28.390]                   sessionInformation <- function() {
[09:32:28.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:28.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:28.390]                       search = base::search(), system = base::Sys.info())
[09:32:28.390]                   }
[09:32:28.390]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:28.390]                     cond$call), session = sessionInformation(), 
[09:32:28.390]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:28.390]                   signalCondition(cond)
[09:32:28.390]                 }
[09:32:28.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:28.390]                 "immediateCondition"))) {
[09:32:28.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:28.390]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:28.390]                   if (TRUE && !signal) {
[09:32:28.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.390]                     {
[09:32:28.390]                       inherits <- base::inherits
[09:32:28.390]                       invokeRestart <- base::invokeRestart
[09:32:28.390]                       is.null <- base::is.null
[09:32:28.390]                       muffled <- FALSE
[09:32:28.390]                       if (inherits(cond, "message")) {
[09:32:28.390]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.390]                         if (muffled) 
[09:32:28.390]                           invokeRestart("muffleMessage")
[09:32:28.390]                       }
[09:32:28.390]                       else if (inherits(cond, "warning")) {
[09:32:28.390]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.390]                         if (muffled) 
[09:32:28.390]                           invokeRestart("muffleWarning")
[09:32:28.390]                       }
[09:32:28.390]                       else if (inherits(cond, "condition")) {
[09:32:28.390]                         if (!is.null(pattern)) {
[09:32:28.390]                           computeRestarts <- base::computeRestarts
[09:32:28.390]                           grepl <- base::grepl
[09:32:28.390]                           restarts <- computeRestarts(cond)
[09:32:28.390]                           for (restart in restarts) {
[09:32:28.390]                             name <- restart$name
[09:32:28.390]                             if (is.null(name)) 
[09:32:28.390]                               next
[09:32:28.390]                             if (!grepl(pattern, name)) 
[09:32:28.390]                               next
[09:32:28.390]                             invokeRestart(restart)
[09:32:28.390]                             muffled <- TRUE
[09:32:28.390]                             break
[09:32:28.390]                           }
[09:32:28.390]                         }
[09:32:28.390]                       }
[09:32:28.390]                       invisible(muffled)
[09:32:28.390]                     }
[09:32:28.390]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.390]                   }
[09:32:28.390]                 }
[09:32:28.390]                 else {
[09:32:28.390]                   if (TRUE) {
[09:32:28.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.390]                     {
[09:32:28.390]                       inherits <- base::inherits
[09:32:28.390]                       invokeRestart <- base::invokeRestart
[09:32:28.390]                       is.null <- base::is.null
[09:32:28.390]                       muffled <- FALSE
[09:32:28.390]                       if (inherits(cond, "message")) {
[09:32:28.390]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.390]                         if (muffled) 
[09:32:28.390]                           invokeRestart("muffleMessage")
[09:32:28.390]                       }
[09:32:28.390]                       else if (inherits(cond, "warning")) {
[09:32:28.390]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.390]                         if (muffled) 
[09:32:28.390]                           invokeRestart("muffleWarning")
[09:32:28.390]                       }
[09:32:28.390]                       else if (inherits(cond, "condition")) {
[09:32:28.390]                         if (!is.null(pattern)) {
[09:32:28.390]                           computeRestarts <- base::computeRestarts
[09:32:28.390]                           grepl <- base::grepl
[09:32:28.390]                           restarts <- computeRestarts(cond)
[09:32:28.390]                           for (restart in restarts) {
[09:32:28.390]                             name <- restart$name
[09:32:28.390]                             if (is.null(name)) 
[09:32:28.390]                               next
[09:32:28.390]                             if (!grepl(pattern, name)) 
[09:32:28.390]                               next
[09:32:28.390]                             invokeRestart(restart)
[09:32:28.390]                             muffled <- TRUE
[09:32:28.390]                             break
[09:32:28.390]                           }
[09:32:28.390]                         }
[09:32:28.390]                       }
[09:32:28.390]                       invisible(muffled)
[09:32:28.390]                     }
[09:32:28.390]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.390]                   }
[09:32:28.390]                 }
[09:32:28.390]             }
[09:32:28.390]         }))
[09:32:28.390]     }, error = function(ex) {
[09:32:28.390]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:28.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.390]                 ...future.rng), started = ...future.startTime, 
[09:32:28.390]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:28.390]             version = "1.8"), class = "FutureResult")
[09:32:28.390]     }, finally = {
[09:32:28.390]         if (!identical(...future.workdir, getwd())) 
[09:32:28.390]             setwd(...future.workdir)
[09:32:28.390]         {
[09:32:28.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:28.390]                 ...future.oldOptions$nwarnings <- NULL
[09:32:28.390]             }
[09:32:28.390]             base::options(...future.oldOptions)
[09:32:28.390]             if (.Platform$OS.type == "windows") {
[09:32:28.390]                 old_names <- names(...future.oldEnvVars)
[09:32:28.390]                 envs <- base::Sys.getenv()
[09:32:28.390]                 names <- names(envs)
[09:32:28.390]                 common <- intersect(names, old_names)
[09:32:28.390]                 added <- setdiff(names, old_names)
[09:32:28.390]                 removed <- setdiff(old_names, names)
[09:32:28.390]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:28.390]                   envs[common]]
[09:32:28.390]                 NAMES <- toupper(changed)
[09:32:28.390]                 args <- list()
[09:32:28.390]                 for (kk in seq_along(NAMES)) {
[09:32:28.390]                   name <- changed[[kk]]
[09:32:28.390]                   NAME <- NAMES[[kk]]
[09:32:28.390]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.390]                     next
[09:32:28.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.390]                 }
[09:32:28.390]                 NAMES <- toupper(added)
[09:32:28.390]                 for (kk in seq_along(NAMES)) {
[09:32:28.390]                   name <- added[[kk]]
[09:32:28.390]                   NAME <- NAMES[[kk]]
[09:32:28.390]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.390]                     next
[09:32:28.390]                   args[[name]] <- ""
[09:32:28.390]                 }
[09:32:28.390]                 NAMES <- toupper(removed)
[09:32:28.390]                 for (kk in seq_along(NAMES)) {
[09:32:28.390]                   name <- removed[[kk]]
[09:32:28.390]                   NAME <- NAMES[[kk]]
[09:32:28.390]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.390]                     next
[09:32:28.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.390]                 }
[09:32:28.390]                 if (length(args) > 0) 
[09:32:28.390]                   base::do.call(base::Sys.setenv, args = args)
[09:32:28.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:28.390]             }
[09:32:28.390]             else {
[09:32:28.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:28.390]             }
[09:32:28.390]             {
[09:32:28.390]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:28.390]                   0L) {
[09:32:28.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:28.390]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:28.390]                   base::options(opts)
[09:32:28.390]                 }
[09:32:28.390]                 {
[09:32:28.390]                   {
[09:32:28.390]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:28.390]                     NULL
[09:32:28.390]                   }
[09:32:28.390]                   options(future.plan = NULL)
[09:32:28.390]                   if (is.na(NA_character_)) 
[09:32:28.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:28.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:28.390]                     .init = FALSE)
[09:32:28.390]                 }
[09:32:28.390]             }
[09:32:28.390]         }
[09:32:28.390]     })
[09:32:28.390]     if (TRUE) {
[09:32:28.390]         base::sink(type = "output", split = FALSE)
[09:32:28.390]         if (TRUE) {
[09:32:28.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:28.390]         }
[09:32:28.390]         else {
[09:32:28.390]             ...future.result["stdout"] <- base::list(NULL)
[09:32:28.390]         }
[09:32:28.390]         base::close(...future.stdout)
[09:32:28.390]         ...future.stdout <- NULL
[09:32:28.390]     }
[09:32:28.390]     ...future.result$conditions <- ...future.conditions
[09:32:28.390]     ...future.result$finished <- base::Sys.time()
[09:32:28.390]     ...future.result
[09:32:28.390] }
[09:32:28.392] MultisessionFuture started
[09:32:28.393] - Launch lazy future ... done
[09:32:28.393] run() for ‘MultisessionFuture’ ... done
[09:32:28.394] receiveMessageFromWorker() for ClusterFuture ...
[09:32:28.394] - Validating connection of MultisessionFuture
[09:32:28.395] - received message: FutureResult
[09:32:28.395] - Received FutureResult
[09:32:28.395] - Erased future from FutureRegistry
[09:32:28.395] result() for ClusterFuture ...
[09:32:28.395] - result already collected: FutureResult
[09:32:28.395] result() for ClusterFuture ... done
[09:32:28.395] signalConditions() ...
[09:32:28.395]  - include = ‘immediateCondition’
[09:32:28.395]  - exclude = 
[09:32:28.396]  - resignal = FALSE
[09:32:28.396]  - Number of conditions: 1
[09:32:28.396] signalConditions() ... done
[09:32:28.396] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:28.396] A MultisessionFuture was resolved (result was not collected)
[09:32:28.396] getGlobalsAndPackages() ...
[09:32:28.396] Searching for globals...
[09:32:28.397] - globals found: [2] ‘list’, ‘stop’
[09:32:28.397] Searching for globals ... DONE
[09:32:28.397] Resolving globals: FALSE
[09:32:28.397] 
[09:32:28.397] 
[09:32:28.397] getGlobalsAndPackages() ... DONE
[09:32:28.398] run() for ‘Future’ ...
[09:32:28.398] - state: ‘created’
[09:32:28.398] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:28.411] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:28.411] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:28.411]   - Field: ‘node’
[09:32:28.412]   - Field: ‘label’
[09:32:28.412]   - Field: ‘local’
[09:32:28.412]   - Field: ‘owner’
[09:32:28.412]   - Field: ‘envir’
[09:32:28.412]   - Field: ‘workers’
[09:32:28.412]   - Field: ‘packages’
[09:32:28.412]   - Field: ‘gc’
[09:32:28.412]   - Field: ‘conditions’
[09:32:28.412]   - Field: ‘persistent’
[09:32:28.412]   - Field: ‘expr’
[09:32:28.412]   - Field: ‘uuid’
[09:32:28.413]   - Field: ‘seed’
[09:32:28.413]   - Field: ‘version’
[09:32:28.413]   - Field: ‘result’
[09:32:28.413]   - Field: ‘asynchronous’
[09:32:28.413]   - Field: ‘calls’
[09:32:28.413]   - Field: ‘globals’
[09:32:28.413]   - Field: ‘stdout’
[09:32:28.413]   - Field: ‘earlySignal’
[09:32:28.413]   - Field: ‘lazy’
[09:32:28.413]   - Field: ‘state’
[09:32:28.413] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:28.414] - Launch lazy future ...
[09:32:28.414] Packages needed by the future expression (n = 0): <none>
[09:32:28.414] Packages needed by future strategies (n = 0): <none>
[09:32:28.414] {
[09:32:28.414]     {
[09:32:28.414]         {
[09:32:28.414]             ...future.startTime <- base::Sys.time()
[09:32:28.414]             {
[09:32:28.414]                 {
[09:32:28.414]                   {
[09:32:28.414]                     {
[09:32:28.414]                       base::local({
[09:32:28.414]                         has_future <- base::requireNamespace("future", 
[09:32:28.414]                           quietly = TRUE)
[09:32:28.414]                         if (has_future) {
[09:32:28.414]                           ns <- base::getNamespace("future")
[09:32:28.414]                           version <- ns[[".package"]][["version"]]
[09:32:28.414]                           if (is.null(version)) 
[09:32:28.414]                             version <- utils::packageVersion("future")
[09:32:28.414]                         }
[09:32:28.414]                         else {
[09:32:28.414]                           version <- NULL
[09:32:28.414]                         }
[09:32:28.414]                         if (!has_future || version < "1.8.0") {
[09:32:28.414]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:28.414]                             "", base::R.version$version.string), 
[09:32:28.414]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:28.414]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:28.414]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:28.414]                               "release", "version")], collapse = " "), 
[09:32:28.414]                             hostname = base::Sys.info()[["nodename"]])
[09:32:28.414]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:28.414]                             info)
[09:32:28.414]                           info <- base::paste(info, collapse = "; ")
[09:32:28.414]                           if (!has_future) {
[09:32:28.414]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:28.414]                               info)
[09:32:28.414]                           }
[09:32:28.414]                           else {
[09:32:28.414]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:28.414]                               info, version)
[09:32:28.414]                           }
[09:32:28.414]                           base::stop(msg)
[09:32:28.414]                         }
[09:32:28.414]                       })
[09:32:28.414]                     }
[09:32:28.414]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:28.414]                     base::options(mc.cores = 1L)
[09:32:28.414]                   }
[09:32:28.414]                   ...future.strategy.old <- future::plan("list")
[09:32:28.414]                   options(future.plan = NULL)
[09:32:28.414]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.414]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:28.414]                 }
[09:32:28.414]                 ...future.workdir <- getwd()
[09:32:28.414]             }
[09:32:28.414]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:28.414]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:28.414]         }
[09:32:28.414]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:28.414]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:28.414]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:28.414]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:28.414]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:28.414]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:28.414]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:28.414]             base::names(...future.oldOptions))
[09:32:28.414]     }
[09:32:28.414]     if (FALSE) {
[09:32:28.414]     }
[09:32:28.414]     else {
[09:32:28.414]         if (TRUE) {
[09:32:28.414]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:28.414]                 open = "w")
[09:32:28.414]         }
[09:32:28.414]         else {
[09:32:28.414]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:28.414]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:28.414]         }
[09:32:28.414]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:28.414]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:28.414]             base::sink(type = "output", split = FALSE)
[09:32:28.414]             base::close(...future.stdout)
[09:32:28.414]         }, add = TRUE)
[09:32:28.414]     }
[09:32:28.414]     ...future.frame <- base::sys.nframe()
[09:32:28.414]     ...future.conditions <- base::list()
[09:32:28.414]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:28.414]     if (FALSE) {
[09:32:28.414]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:28.414]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:28.414]     }
[09:32:28.414]     ...future.result <- base::tryCatch({
[09:32:28.414]         base::withCallingHandlers({
[09:32:28.414]             ...future.value <- base::withVisible(base::local({
[09:32:28.414]                 ...future.makeSendCondition <- base::local({
[09:32:28.414]                   sendCondition <- NULL
[09:32:28.414]                   function(frame = 1L) {
[09:32:28.414]                     if (is.function(sendCondition)) 
[09:32:28.414]                       return(sendCondition)
[09:32:28.414]                     ns <- getNamespace("parallel")
[09:32:28.414]                     if (exists("sendData", mode = "function", 
[09:32:28.414]                       envir = ns)) {
[09:32:28.414]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:28.414]                         envir = ns)
[09:32:28.414]                       envir <- sys.frame(frame)
[09:32:28.414]                       master <- NULL
[09:32:28.414]                       while (!identical(envir, .GlobalEnv) && 
[09:32:28.414]                         !identical(envir, emptyenv())) {
[09:32:28.414]                         if (exists("master", mode = "list", envir = envir, 
[09:32:28.414]                           inherits = FALSE)) {
[09:32:28.414]                           master <- get("master", mode = "list", 
[09:32:28.414]                             envir = envir, inherits = FALSE)
[09:32:28.414]                           if (inherits(master, c("SOCKnode", 
[09:32:28.414]                             "SOCK0node"))) {
[09:32:28.414]                             sendCondition <<- function(cond) {
[09:32:28.414]                               data <- list(type = "VALUE", value = cond, 
[09:32:28.414]                                 success = TRUE)
[09:32:28.414]                               parallel_sendData(master, data)
[09:32:28.414]                             }
[09:32:28.414]                             return(sendCondition)
[09:32:28.414]                           }
[09:32:28.414]                         }
[09:32:28.414]                         frame <- frame + 1L
[09:32:28.414]                         envir <- sys.frame(frame)
[09:32:28.414]                       }
[09:32:28.414]                     }
[09:32:28.414]                     sendCondition <<- function(cond) NULL
[09:32:28.414]                   }
[09:32:28.414]                 })
[09:32:28.414]                 withCallingHandlers({
[09:32:28.414]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:28.414]                 }, immediateCondition = function(cond) {
[09:32:28.414]                   sendCondition <- ...future.makeSendCondition()
[09:32:28.414]                   sendCondition(cond)
[09:32:28.414]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.414]                   {
[09:32:28.414]                     inherits <- base::inherits
[09:32:28.414]                     invokeRestart <- base::invokeRestart
[09:32:28.414]                     is.null <- base::is.null
[09:32:28.414]                     muffled <- FALSE
[09:32:28.414]                     if (inherits(cond, "message")) {
[09:32:28.414]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:28.414]                       if (muffled) 
[09:32:28.414]                         invokeRestart("muffleMessage")
[09:32:28.414]                     }
[09:32:28.414]                     else if (inherits(cond, "warning")) {
[09:32:28.414]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:28.414]                       if (muffled) 
[09:32:28.414]                         invokeRestart("muffleWarning")
[09:32:28.414]                     }
[09:32:28.414]                     else if (inherits(cond, "condition")) {
[09:32:28.414]                       if (!is.null(pattern)) {
[09:32:28.414]                         computeRestarts <- base::computeRestarts
[09:32:28.414]                         grepl <- base::grepl
[09:32:28.414]                         restarts <- computeRestarts(cond)
[09:32:28.414]                         for (restart in restarts) {
[09:32:28.414]                           name <- restart$name
[09:32:28.414]                           if (is.null(name)) 
[09:32:28.414]                             next
[09:32:28.414]                           if (!grepl(pattern, name)) 
[09:32:28.414]                             next
[09:32:28.414]                           invokeRestart(restart)
[09:32:28.414]                           muffled <- TRUE
[09:32:28.414]                           break
[09:32:28.414]                         }
[09:32:28.414]                       }
[09:32:28.414]                     }
[09:32:28.414]                     invisible(muffled)
[09:32:28.414]                   }
[09:32:28.414]                   muffleCondition(cond)
[09:32:28.414]                 })
[09:32:28.414]             }))
[09:32:28.414]             future::FutureResult(value = ...future.value$value, 
[09:32:28.414]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.414]                   ...future.rng), globalenv = if (FALSE) 
[09:32:28.414]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:28.414]                     ...future.globalenv.names))
[09:32:28.414]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:28.414]         }, condition = base::local({
[09:32:28.414]             c <- base::c
[09:32:28.414]             inherits <- base::inherits
[09:32:28.414]             invokeRestart <- base::invokeRestart
[09:32:28.414]             length <- base::length
[09:32:28.414]             list <- base::list
[09:32:28.414]             seq.int <- base::seq.int
[09:32:28.414]             signalCondition <- base::signalCondition
[09:32:28.414]             sys.calls <- base::sys.calls
[09:32:28.414]             `[[` <- base::`[[`
[09:32:28.414]             `+` <- base::`+`
[09:32:28.414]             `<<-` <- base::`<<-`
[09:32:28.414]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:28.414]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:28.414]                   3L)]
[09:32:28.414]             }
[09:32:28.414]             function(cond) {
[09:32:28.414]                 is_error <- inherits(cond, "error")
[09:32:28.414]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:28.414]                   NULL)
[09:32:28.414]                 if (is_error) {
[09:32:28.414]                   sessionInformation <- function() {
[09:32:28.414]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:28.414]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:28.414]                       search = base::search(), system = base::Sys.info())
[09:32:28.414]                   }
[09:32:28.414]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.414]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:28.414]                     cond$call), session = sessionInformation(), 
[09:32:28.414]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:28.414]                   signalCondition(cond)
[09:32:28.414]                 }
[09:32:28.414]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:28.414]                 "immediateCondition"))) {
[09:32:28.414]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:28.414]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.414]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:28.414]                   if (TRUE && !signal) {
[09:32:28.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.414]                     {
[09:32:28.414]                       inherits <- base::inherits
[09:32:28.414]                       invokeRestart <- base::invokeRestart
[09:32:28.414]                       is.null <- base::is.null
[09:32:28.414]                       muffled <- FALSE
[09:32:28.414]                       if (inherits(cond, "message")) {
[09:32:28.414]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.414]                         if (muffled) 
[09:32:28.414]                           invokeRestart("muffleMessage")
[09:32:28.414]                       }
[09:32:28.414]                       else if (inherits(cond, "warning")) {
[09:32:28.414]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.414]                         if (muffled) 
[09:32:28.414]                           invokeRestart("muffleWarning")
[09:32:28.414]                       }
[09:32:28.414]                       else if (inherits(cond, "condition")) {
[09:32:28.414]                         if (!is.null(pattern)) {
[09:32:28.414]                           computeRestarts <- base::computeRestarts
[09:32:28.414]                           grepl <- base::grepl
[09:32:28.414]                           restarts <- computeRestarts(cond)
[09:32:28.414]                           for (restart in restarts) {
[09:32:28.414]                             name <- restart$name
[09:32:28.414]                             if (is.null(name)) 
[09:32:28.414]                               next
[09:32:28.414]                             if (!grepl(pattern, name)) 
[09:32:28.414]                               next
[09:32:28.414]                             invokeRestart(restart)
[09:32:28.414]                             muffled <- TRUE
[09:32:28.414]                             break
[09:32:28.414]                           }
[09:32:28.414]                         }
[09:32:28.414]                       }
[09:32:28.414]                       invisible(muffled)
[09:32:28.414]                     }
[09:32:28.414]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.414]                   }
[09:32:28.414]                 }
[09:32:28.414]                 else {
[09:32:28.414]                   if (TRUE) {
[09:32:28.414]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.414]                     {
[09:32:28.414]                       inherits <- base::inherits
[09:32:28.414]                       invokeRestart <- base::invokeRestart
[09:32:28.414]                       is.null <- base::is.null
[09:32:28.414]                       muffled <- FALSE
[09:32:28.414]                       if (inherits(cond, "message")) {
[09:32:28.414]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.414]                         if (muffled) 
[09:32:28.414]                           invokeRestart("muffleMessage")
[09:32:28.414]                       }
[09:32:28.414]                       else if (inherits(cond, "warning")) {
[09:32:28.414]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.414]                         if (muffled) 
[09:32:28.414]                           invokeRestart("muffleWarning")
[09:32:28.414]                       }
[09:32:28.414]                       else if (inherits(cond, "condition")) {
[09:32:28.414]                         if (!is.null(pattern)) {
[09:32:28.414]                           computeRestarts <- base::computeRestarts
[09:32:28.414]                           grepl <- base::grepl
[09:32:28.414]                           restarts <- computeRestarts(cond)
[09:32:28.414]                           for (restart in restarts) {
[09:32:28.414]                             name <- restart$name
[09:32:28.414]                             if (is.null(name)) 
[09:32:28.414]                               next
[09:32:28.414]                             if (!grepl(pattern, name)) 
[09:32:28.414]                               next
[09:32:28.414]                             invokeRestart(restart)
[09:32:28.414]                             muffled <- TRUE
[09:32:28.414]                             break
[09:32:28.414]                           }
[09:32:28.414]                         }
[09:32:28.414]                       }
[09:32:28.414]                       invisible(muffled)
[09:32:28.414]                     }
[09:32:28.414]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.414]                   }
[09:32:28.414]                 }
[09:32:28.414]             }
[09:32:28.414]         }))
[09:32:28.414]     }, error = function(ex) {
[09:32:28.414]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:28.414]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.414]                 ...future.rng), started = ...future.startTime, 
[09:32:28.414]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:28.414]             version = "1.8"), class = "FutureResult")
[09:32:28.414]     }, finally = {
[09:32:28.414]         if (!identical(...future.workdir, getwd())) 
[09:32:28.414]             setwd(...future.workdir)
[09:32:28.414]         {
[09:32:28.414]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:28.414]                 ...future.oldOptions$nwarnings <- NULL
[09:32:28.414]             }
[09:32:28.414]             base::options(...future.oldOptions)
[09:32:28.414]             if (.Platform$OS.type == "windows") {
[09:32:28.414]                 old_names <- names(...future.oldEnvVars)
[09:32:28.414]                 envs <- base::Sys.getenv()
[09:32:28.414]                 names <- names(envs)
[09:32:28.414]                 common <- intersect(names, old_names)
[09:32:28.414]                 added <- setdiff(names, old_names)
[09:32:28.414]                 removed <- setdiff(old_names, names)
[09:32:28.414]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:28.414]                   envs[common]]
[09:32:28.414]                 NAMES <- toupper(changed)
[09:32:28.414]                 args <- list()
[09:32:28.414]                 for (kk in seq_along(NAMES)) {
[09:32:28.414]                   name <- changed[[kk]]
[09:32:28.414]                   NAME <- NAMES[[kk]]
[09:32:28.414]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.414]                     next
[09:32:28.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.414]                 }
[09:32:28.414]                 NAMES <- toupper(added)
[09:32:28.414]                 for (kk in seq_along(NAMES)) {
[09:32:28.414]                   name <- added[[kk]]
[09:32:28.414]                   NAME <- NAMES[[kk]]
[09:32:28.414]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.414]                     next
[09:32:28.414]                   args[[name]] <- ""
[09:32:28.414]                 }
[09:32:28.414]                 NAMES <- toupper(removed)
[09:32:28.414]                 for (kk in seq_along(NAMES)) {
[09:32:28.414]                   name <- removed[[kk]]
[09:32:28.414]                   NAME <- NAMES[[kk]]
[09:32:28.414]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.414]                     next
[09:32:28.414]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.414]                 }
[09:32:28.414]                 if (length(args) > 0) 
[09:32:28.414]                   base::do.call(base::Sys.setenv, args = args)
[09:32:28.414]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:28.414]             }
[09:32:28.414]             else {
[09:32:28.414]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:28.414]             }
[09:32:28.414]             {
[09:32:28.414]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:28.414]                   0L) {
[09:32:28.414]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:28.414]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:28.414]                   base::options(opts)
[09:32:28.414]                 }
[09:32:28.414]                 {
[09:32:28.414]                   {
[09:32:28.414]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:28.414]                     NULL
[09:32:28.414]                   }
[09:32:28.414]                   options(future.plan = NULL)
[09:32:28.414]                   if (is.na(NA_character_)) 
[09:32:28.414]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.414]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:28.414]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:28.414]                     .init = FALSE)
[09:32:28.414]                 }
[09:32:28.414]             }
[09:32:28.414]         }
[09:32:28.414]     })
[09:32:28.414]     if (TRUE) {
[09:32:28.414]         base::sink(type = "output", split = FALSE)
[09:32:28.414]         if (TRUE) {
[09:32:28.414]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:28.414]         }
[09:32:28.414]         else {
[09:32:28.414]             ...future.result["stdout"] <- base::list(NULL)
[09:32:28.414]         }
[09:32:28.414]         base::close(...future.stdout)
[09:32:28.414]         ...future.stdout <- NULL
[09:32:28.414]     }
[09:32:28.414]     ...future.result$conditions <- ...future.conditions
[09:32:28.414]     ...future.result$finished <- base::Sys.time()
[09:32:28.414]     ...future.result
[09:32:28.414] }
[09:32:28.417] MultisessionFuture started
[09:32:28.417] - Launch lazy future ... done
[09:32:28.417] run() for ‘MultisessionFuture’ ... done
[09:32:28.418] receiveMessageFromWorker() for ClusterFuture ...
[09:32:28.419] - Validating connection of MultisessionFuture
[09:32:28.419] - received message: FutureResult
[09:32:28.419] - Received FutureResult
[09:32:28.419] - Erased future from FutureRegistry
[09:32:28.419] result() for ClusterFuture ...
[09:32:28.419] - result already collected: FutureResult
[09:32:28.419] result() for ClusterFuture ... done
[09:32:28.420] signalConditions() ...
[09:32:28.420]  - include = ‘immediateCondition’
[09:32:28.420]  - exclude = 
[09:32:28.420]  - resignal = FALSE
[09:32:28.420]  - Number of conditions: 1
[09:32:28.420] signalConditions() ... done
[09:32:28.420] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:28.420] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[09:32:28.420] getGlobalsAndPackages() ...
[09:32:28.420] Searching for globals...
[09:32:28.421] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:28.422] Searching for globals ... DONE
[09:32:28.422] Resolving globals: FALSE
[09:32:28.422] 
[09:32:28.422] 
[09:32:28.422] getGlobalsAndPackages() ... DONE
[09:32:28.422] run() for ‘Future’ ...
[09:32:28.422] - state: ‘created’
[09:32:28.423] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:28.436] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:28.436] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:28.436]   - Field: ‘node’
[09:32:28.436]   - Field: ‘label’
[09:32:28.436]   - Field: ‘local’
[09:32:28.436]   - Field: ‘owner’
[09:32:28.436]   - Field: ‘envir’
[09:32:28.436]   - Field: ‘workers’
[09:32:28.437]   - Field: ‘packages’
[09:32:28.437]   - Field: ‘gc’
[09:32:28.437]   - Field: ‘conditions’
[09:32:28.437]   - Field: ‘persistent’
[09:32:28.437]   - Field: ‘expr’
[09:32:28.437]   - Field: ‘uuid’
[09:32:28.437]   - Field: ‘seed’
[09:32:28.437]   - Field: ‘version’
[09:32:28.437]   - Field: ‘result’
[09:32:28.437]   - Field: ‘asynchronous’
[09:32:28.437]   - Field: ‘calls’
[09:32:28.438]   - Field: ‘globals’
[09:32:28.438]   - Field: ‘stdout’
[09:32:28.438]   - Field: ‘earlySignal’
[09:32:28.438]   - Field: ‘lazy’
[09:32:28.438]   - Field: ‘state’
[09:32:28.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:28.438] - Launch lazy future ...
[09:32:28.438] Packages needed by the future expression (n = 0): <none>
[09:32:28.438] Packages needed by future strategies (n = 0): <none>
[09:32:28.439] {
[09:32:28.439]     {
[09:32:28.439]         {
[09:32:28.439]             ...future.startTime <- base::Sys.time()
[09:32:28.439]             {
[09:32:28.439]                 {
[09:32:28.439]                   {
[09:32:28.439]                     {
[09:32:28.439]                       base::local({
[09:32:28.439]                         has_future <- base::requireNamespace("future", 
[09:32:28.439]                           quietly = TRUE)
[09:32:28.439]                         if (has_future) {
[09:32:28.439]                           ns <- base::getNamespace("future")
[09:32:28.439]                           version <- ns[[".package"]][["version"]]
[09:32:28.439]                           if (is.null(version)) 
[09:32:28.439]                             version <- utils::packageVersion("future")
[09:32:28.439]                         }
[09:32:28.439]                         else {
[09:32:28.439]                           version <- NULL
[09:32:28.439]                         }
[09:32:28.439]                         if (!has_future || version < "1.8.0") {
[09:32:28.439]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:28.439]                             "", base::R.version$version.string), 
[09:32:28.439]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:28.439]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:28.439]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:28.439]                               "release", "version")], collapse = " "), 
[09:32:28.439]                             hostname = base::Sys.info()[["nodename"]])
[09:32:28.439]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:28.439]                             info)
[09:32:28.439]                           info <- base::paste(info, collapse = "; ")
[09:32:28.439]                           if (!has_future) {
[09:32:28.439]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:28.439]                               info)
[09:32:28.439]                           }
[09:32:28.439]                           else {
[09:32:28.439]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:28.439]                               info, version)
[09:32:28.439]                           }
[09:32:28.439]                           base::stop(msg)
[09:32:28.439]                         }
[09:32:28.439]                       })
[09:32:28.439]                     }
[09:32:28.439]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:28.439]                     base::options(mc.cores = 1L)
[09:32:28.439]                   }
[09:32:28.439]                   ...future.strategy.old <- future::plan("list")
[09:32:28.439]                   options(future.plan = NULL)
[09:32:28.439]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.439]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:28.439]                 }
[09:32:28.439]                 ...future.workdir <- getwd()
[09:32:28.439]             }
[09:32:28.439]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:28.439]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:28.439]         }
[09:32:28.439]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:28.439]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:28.439]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:28.439]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:28.439]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:28.439]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:28.439]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:28.439]             base::names(...future.oldOptions))
[09:32:28.439]     }
[09:32:28.439]     if (FALSE) {
[09:32:28.439]     }
[09:32:28.439]     else {
[09:32:28.439]         if (TRUE) {
[09:32:28.439]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:28.439]                 open = "w")
[09:32:28.439]         }
[09:32:28.439]         else {
[09:32:28.439]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:28.439]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:28.439]         }
[09:32:28.439]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:28.439]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:28.439]             base::sink(type = "output", split = FALSE)
[09:32:28.439]             base::close(...future.stdout)
[09:32:28.439]         }, add = TRUE)
[09:32:28.439]     }
[09:32:28.439]     ...future.frame <- base::sys.nframe()
[09:32:28.439]     ...future.conditions <- base::list()
[09:32:28.439]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:28.439]     if (FALSE) {
[09:32:28.439]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:28.439]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:28.439]     }
[09:32:28.439]     ...future.result <- base::tryCatch({
[09:32:28.439]         base::withCallingHandlers({
[09:32:28.439]             ...future.value <- base::withVisible(base::local({
[09:32:28.439]                 ...future.makeSendCondition <- base::local({
[09:32:28.439]                   sendCondition <- NULL
[09:32:28.439]                   function(frame = 1L) {
[09:32:28.439]                     if (is.function(sendCondition)) 
[09:32:28.439]                       return(sendCondition)
[09:32:28.439]                     ns <- getNamespace("parallel")
[09:32:28.439]                     if (exists("sendData", mode = "function", 
[09:32:28.439]                       envir = ns)) {
[09:32:28.439]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:28.439]                         envir = ns)
[09:32:28.439]                       envir <- sys.frame(frame)
[09:32:28.439]                       master <- NULL
[09:32:28.439]                       while (!identical(envir, .GlobalEnv) && 
[09:32:28.439]                         !identical(envir, emptyenv())) {
[09:32:28.439]                         if (exists("master", mode = "list", envir = envir, 
[09:32:28.439]                           inherits = FALSE)) {
[09:32:28.439]                           master <- get("master", mode = "list", 
[09:32:28.439]                             envir = envir, inherits = FALSE)
[09:32:28.439]                           if (inherits(master, c("SOCKnode", 
[09:32:28.439]                             "SOCK0node"))) {
[09:32:28.439]                             sendCondition <<- function(cond) {
[09:32:28.439]                               data <- list(type = "VALUE", value = cond, 
[09:32:28.439]                                 success = TRUE)
[09:32:28.439]                               parallel_sendData(master, data)
[09:32:28.439]                             }
[09:32:28.439]                             return(sendCondition)
[09:32:28.439]                           }
[09:32:28.439]                         }
[09:32:28.439]                         frame <- frame + 1L
[09:32:28.439]                         envir <- sys.frame(frame)
[09:32:28.439]                       }
[09:32:28.439]                     }
[09:32:28.439]                     sendCondition <<- function(cond) NULL
[09:32:28.439]                   }
[09:32:28.439]                 })
[09:32:28.439]                 withCallingHandlers({
[09:32:28.439]                   {
[09:32:28.439]                     Sys.sleep(0.5)
[09:32:28.439]                     list(a = 1, b = 42L)
[09:32:28.439]                   }
[09:32:28.439]                 }, immediateCondition = function(cond) {
[09:32:28.439]                   sendCondition <- ...future.makeSendCondition()
[09:32:28.439]                   sendCondition(cond)
[09:32:28.439]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.439]                   {
[09:32:28.439]                     inherits <- base::inherits
[09:32:28.439]                     invokeRestart <- base::invokeRestart
[09:32:28.439]                     is.null <- base::is.null
[09:32:28.439]                     muffled <- FALSE
[09:32:28.439]                     if (inherits(cond, "message")) {
[09:32:28.439]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:28.439]                       if (muffled) 
[09:32:28.439]                         invokeRestart("muffleMessage")
[09:32:28.439]                     }
[09:32:28.439]                     else if (inherits(cond, "warning")) {
[09:32:28.439]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:28.439]                       if (muffled) 
[09:32:28.439]                         invokeRestart("muffleWarning")
[09:32:28.439]                     }
[09:32:28.439]                     else if (inherits(cond, "condition")) {
[09:32:28.439]                       if (!is.null(pattern)) {
[09:32:28.439]                         computeRestarts <- base::computeRestarts
[09:32:28.439]                         grepl <- base::grepl
[09:32:28.439]                         restarts <- computeRestarts(cond)
[09:32:28.439]                         for (restart in restarts) {
[09:32:28.439]                           name <- restart$name
[09:32:28.439]                           if (is.null(name)) 
[09:32:28.439]                             next
[09:32:28.439]                           if (!grepl(pattern, name)) 
[09:32:28.439]                             next
[09:32:28.439]                           invokeRestart(restart)
[09:32:28.439]                           muffled <- TRUE
[09:32:28.439]                           break
[09:32:28.439]                         }
[09:32:28.439]                       }
[09:32:28.439]                     }
[09:32:28.439]                     invisible(muffled)
[09:32:28.439]                   }
[09:32:28.439]                   muffleCondition(cond)
[09:32:28.439]                 })
[09:32:28.439]             }))
[09:32:28.439]             future::FutureResult(value = ...future.value$value, 
[09:32:28.439]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.439]                   ...future.rng), globalenv = if (FALSE) 
[09:32:28.439]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:28.439]                     ...future.globalenv.names))
[09:32:28.439]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:28.439]         }, condition = base::local({
[09:32:28.439]             c <- base::c
[09:32:28.439]             inherits <- base::inherits
[09:32:28.439]             invokeRestart <- base::invokeRestart
[09:32:28.439]             length <- base::length
[09:32:28.439]             list <- base::list
[09:32:28.439]             seq.int <- base::seq.int
[09:32:28.439]             signalCondition <- base::signalCondition
[09:32:28.439]             sys.calls <- base::sys.calls
[09:32:28.439]             `[[` <- base::`[[`
[09:32:28.439]             `+` <- base::`+`
[09:32:28.439]             `<<-` <- base::`<<-`
[09:32:28.439]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:28.439]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:28.439]                   3L)]
[09:32:28.439]             }
[09:32:28.439]             function(cond) {
[09:32:28.439]                 is_error <- inherits(cond, "error")
[09:32:28.439]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:28.439]                   NULL)
[09:32:28.439]                 if (is_error) {
[09:32:28.439]                   sessionInformation <- function() {
[09:32:28.439]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:28.439]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:28.439]                       search = base::search(), system = base::Sys.info())
[09:32:28.439]                   }
[09:32:28.439]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.439]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:28.439]                     cond$call), session = sessionInformation(), 
[09:32:28.439]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:28.439]                   signalCondition(cond)
[09:32:28.439]                 }
[09:32:28.439]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:28.439]                 "immediateCondition"))) {
[09:32:28.439]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:28.439]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.439]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:28.439]                   if (TRUE && !signal) {
[09:32:28.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.439]                     {
[09:32:28.439]                       inherits <- base::inherits
[09:32:28.439]                       invokeRestart <- base::invokeRestart
[09:32:28.439]                       is.null <- base::is.null
[09:32:28.439]                       muffled <- FALSE
[09:32:28.439]                       if (inherits(cond, "message")) {
[09:32:28.439]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.439]                         if (muffled) 
[09:32:28.439]                           invokeRestart("muffleMessage")
[09:32:28.439]                       }
[09:32:28.439]                       else if (inherits(cond, "warning")) {
[09:32:28.439]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.439]                         if (muffled) 
[09:32:28.439]                           invokeRestart("muffleWarning")
[09:32:28.439]                       }
[09:32:28.439]                       else if (inherits(cond, "condition")) {
[09:32:28.439]                         if (!is.null(pattern)) {
[09:32:28.439]                           computeRestarts <- base::computeRestarts
[09:32:28.439]                           grepl <- base::grepl
[09:32:28.439]                           restarts <- computeRestarts(cond)
[09:32:28.439]                           for (restart in restarts) {
[09:32:28.439]                             name <- restart$name
[09:32:28.439]                             if (is.null(name)) 
[09:32:28.439]                               next
[09:32:28.439]                             if (!grepl(pattern, name)) 
[09:32:28.439]                               next
[09:32:28.439]                             invokeRestart(restart)
[09:32:28.439]                             muffled <- TRUE
[09:32:28.439]                             break
[09:32:28.439]                           }
[09:32:28.439]                         }
[09:32:28.439]                       }
[09:32:28.439]                       invisible(muffled)
[09:32:28.439]                     }
[09:32:28.439]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.439]                   }
[09:32:28.439]                 }
[09:32:28.439]                 else {
[09:32:28.439]                   if (TRUE) {
[09:32:28.439]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.439]                     {
[09:32:28.439]                       inherits <- base::inherits
[09:32:28.439]                       invokeRestart <- base::invokeRestart
[09:32:28.439]                       is.null <- base::is.null
[09:32:28.439]                       muffled <- FALSE
[09:32:28.439]                       if (inherits(cond, "message")) {
[09:32:28.439]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.439]                         if (muffled) 
[09:32:28.439]                           invokeRestart("muffleMessage")
[09:32:28.439]                       }
[09:32:28.439]                       else if (inherits(cond, "warning")) {
[09:32:28.439]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.439]                         if (muffled) 
[09:32:28.439]                           invokeRestart("muffleWarning")
[09:32:28.439]                       }
[09:32:28.439]                       else if (inherits(cond, "condition")) {
[09:32:28.439]                         if (!is.null(pattern)) {
[09:32:28.439]                           computeRestarts <- base::computeRestarts
[09:32:28.439]                           grepl <- base::grepl
[09:32:28.439]                           restarts <- computeRestarts(cond)
[09:32:28.439]                           for (restart in restarts) {
[09:32:28.439]                             name <- restart$name
[09:32:28.439]                             if (is.null(name)) 
[09:32:28.439]                               next
[09:32:28.439]                             if (!grepl(pattern, name)) 
[09:32:28.439]                               next
[09:32:28.439]                             invokeRestart(restart)
[09:32:28.439]                             muffled <- TRUE
[09:32:28.439]                             break
[09:32:28.439]                           }
[09:32:28.439]                         }
[09:32:28.439]                       }
[09:32:28.439]                       invisible(muffled)
[09:32:28.439]                     }
[09:32:28.439]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.439]                   }
[09:32:28.439]                 }
[09:32:28.439]             }
[09:32:28.439]         }))
[09:32:28.439]     }, error = function(ex) {
[09:32:28.439]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:28.439]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.439]                 ...future.rng), started = ...future.startTime, 
[09:32:28.439]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:28.439]             version = "1.8"), class = "FutureResult")
[09:32:28.439]     }, finally = {
[09:32:28.439]         if (!identical(...future.workdir, getwd())) 
[09:32:28.439]             setwd(...future.workdir)
[09:32:28.439]         {
[09:32:28.439]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:28.439]                 ...future.oldOptions$nwarnings <- NULL
[09:32:28.439]             }
[09:32:28.439]             base::options(...future.oldOptions)
[09:32:28.439]             if (.Platform$OS.type == "windows") {
[09:32:28.439]                 old_names <- names(...future.oldEnvVars)
[09:32:28.439]                 envs <- base::Sys.getenv()
[09:32:28.439]                 names <- names(envs)
[09:32:28.439]                 common <- intersect(names, old_names)
[09:32:28.439]                 added <- setdiff(names, old_names)
[09:32:28.439]                 removed <- setdiff(old_names, names)
[09:32:28.439]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:28.439]                   envs[common]]
[09:32:28.439]                 NAMES <- toupper(changed)
[09:32:28.439]                 args <- list()
[09:32:28.439]                 for (kk in seq_along(NAMES)) {
[09:32:28.439]                   name <- changed[[kk]]
[09:32:28.439]                   NAME <- NAMES[[kk]]
[09:32:28.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.439]                     next
[09:32:28.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.439]                 }
[09:32:28.439]                 NAMES <- toupper(added)
[09:32:28.439]                 for (kk in seq_along(NAMES)) {
[09:32:28.439]                   name <- added[[kk]]
[09:32:28.439]                   NAME <- NAMES[[kk]]
[09:32:28.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.439]                     next
[09:32:28.439]                   args[[name]] <- ""
[09:32:28.439]                 }
[09:32:28.439]                 NAMES <- toupper(removed)
[09:32:28.439]                 for (kk in seq_along(NAMES)) {
[09:32:28.439]                   name <- removed[[kk]]
[09:32:28.439]                   NAME <- NAMES[[kk]]
[09:32:28.439]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.439]                     next
[09:32:28.439]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.439]                 }
[09:32:28.439]                 if (length(args) > 0) 
[09:32:28.439]                   base::do.call(base::Sys.setenv, args = args)
[09:32:28.439]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:28.439]             }
[09:32:28.439]             else {
[09:32:28.439]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:28.439]             }
[09:32:28.439]             {
[09:32:28.439]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:28.439]                   0L) {
[09:32:28.439]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:28.439]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:28.439]                   base::options(opts)
[09:32:28.439]                 }
[09:32:28.439]                 {
[09:32:28.439]                   {
[09:32:28.439]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:28.439]                     NULL
[09:32:28.439]                   }
[09:32:28.439]                   options(future.plan = NULL)
[09:32:28.439]                   if (is.na(NA_character_)) 
[09:32:28.439]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.439]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:28.439]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:28.439]                     .init = FALSE)
[09:32:28.439]                 }
[09:32:28.439]             }
[09:32:28.439]         }
[09:32:28.439]     })
[09:32:28.439]     if (TRUE) {
[09:32:28.439]         base::sink(type = "output", split = FALSE)
[09:32:28.439]         if (TRUE) {
[09:32:28.439]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:28.439]         }
[09:32:28.439]         else {
[09:32:28.439]             ...future.result["stdout"] <- base::list(NULL)
[09:32:28.439]         }
[09:32:28.439]         base::close(...future.stdout)
[09:32:28.439]         ...future.stdout <- NULL
[09:32:28.439]     }
[09:32:28.439]     ...future.result$conditions <- ...future.conditions
[09:32:28.439]     ...future.result$finished <- base::Sys.time()
[09:32:28.439]     ...future.result
[09:32:28.439] }
[09:32:28.442] MultisessionFuture started
[09:32:28.442] - Launch lazy future ... done
[09:32:28.442] run() for ‘MultisessionFuture’ ... done
[09:32:28.944] receiveMessageFromWorker() for ClusterFuture ...
[09:32:28.944] - Validating connection of MultisessionFuture
[09:32:28.944] - received message: FutureResult
[09:32:28.944] - Received FutureResult
[09:32:28.944] - Erased future from FutureRegistry
[09:32:28.944] result() for ClusterFuture ...
[09:32:28.945] - result already collected: FutureResult
[09:32:28.945] result() for ClusterFuture ... done
[09:32:28.945] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:28.947] A MultisessionFuture was resolved (result was not collected)
[09:32:28.947] getGlobalsAndPackages() ...
[09:32:28.947] Searching for globals...
[09:32:28.948] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:28.948] Searching for globals ... DONE
[09:32:28.948] Resolving globals: FALSE
[09:32:28.949] 
[09:32:28.949] 
[09:32:28.949] getGlobalsAndPackages() ... DONE
[09:32:28.949] run() for ‘Future’ ...
[09:32:28.949] - state: ‘created’
[09:32:28.949] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:28.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:28.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:28.964]   - Field: ‘node’
[09:32:28.964]   - Field: ‘label’
[09:32:28.964]   - Field: ‘local’
[09:32:28.964]   - Field: ‘owner’
[09:32:28.964]   - Field: ‘envir’
[09:32:28.964]   - Field: ‘workers’
[09:32:28.964]   - Field: ‘packages’
[09:32:28.965]   - Field: ‘gc’
[09:32:28.965]   - Field: ‘conditions’
[09:32:28.965]   - Field: ‘persistent’
[09:32:28.965]   - Field: ‘expr’
[09:32:28.965]   - Field: ‘uuid’
[09:32:28.965]   - Field: ‘seed’
[09:32:28.965]   - Field: ‘version’
[09:32:28.965]   - Field: ‘result’
[09:32:28.965]   - Field: ‘asynchronous’
[09:32:28.965]   - Field: ‘calls’
[09:32:28.965]   - Field: ‘globals’
[09:32:28.965]   - Field: ‘stdout’
[09:32:28.966]   - Field: ‘earlySignal’
[09:32:28.966]   - Field: ‘lazy’
[09:32:28.966]   - Field: ‘state’
[09:32:28.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:28.966] - Launch lazy future ...
[09:32:28.966] Packages needed by the future expression (n = 0): <none>
[09:32:28.966] Packages needed by future strategies (n = 0): <none>
[09:32:28.967] {
[09:32:28.967]     {
[09:32:28.967]         {
[09:32:28.967]             ...future.startTime <- base::Sys.time()
[09:32:28.967]             {
[09:32:28.967]                 {
[09:32:28.967]                   {
[09:32:28.967]                     {
[09:32:28.967]                       base::local({
[09:32:28.967]                         has_future <- base::requireNamespace("future", 
[09:32:28.967]                           quietly = TRUE)
[09:32:28.967]                         if (has_future) {
[09:32:28.967]                           ns <- base::getNamespace("future")
[09:32:28.967]                           version <- ns[[".package"]][["version"]]
[09:32:28.967]                           if (is.null(version)) 
[09:32:28.967]                             version <- utils::packageVersion("future")
[09:32:28.967]                         }
[09:32:28.967]                         else {
[09:32:28.967]                           version <- NULL
[09:32:28.967]                         }
[09:32:28.967]                         if (!has_future || version < "1.8.0") {
[09:32:28.967]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:28.967]                             "", base::R.version$version.string), 
[09:32:28.967]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:28.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:28.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:28.967]                               "release", "version")], collapse = " "), 
[09:32:28.967]                             hostname = base::Sys.info()[["nodename"]])
[09:32:28.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:28.967]                             info)
[09:32:28.967]                           info <- base::paste(info, collapse = "; ")
[09:32:28.967]                           if (!has_future) {
[09:32:28.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:28.967]                               info)
[09:32:28.967]                           }
[09:32:28.967]                           else {
[09:32:28.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:28.967]                               info, version)
[09:32:28.967]                           }
[09:32:28.967]                           base::stop(msg)
[09:32:28.967]                         }
[09:32:28.967]                       })
[09:32:28.967]                     }
[09:32:28.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:28.967]                     base::options(mc.cores = 1L)
[09:32:28.967]                   }
[09:32:28.967]                   ...future.strategy.old <- future::plan("list")
[09:32:28.967]                   options(future.plan = NULL)
[09:32:28.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:28.967]                 }
[09:32:28.967]                 ...future.workdir <- getwd()
[09:32:28.967]             }
[09:32:28.967]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:28.967]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:28.967]         }
[09:32:28.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:28.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:28.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:28.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:28.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:28.967]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:28.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:28.967]             base::names(...future.oldOptions))
[09:32:28.967]     }
[09:32:28.967]     if (FALSE) {
[09:32:28.967]     }
[09:32:28.967]     else {
[09:32:28.967]         if (TRUE) {
[09:32:28.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:28.967]                 open = "w")
[09:32:28.967]         }
[09:32:28.967]         else {
[09:32:28.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:28.967]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:28.967]         }
[09:32:28.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:28.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:28.967]             base::sink(type = "output", split = FALSE)
[09:32:28.967]             base::close(...future.stdout)
[09:32:28.967]         }, add = TRUE)
[09:32:28.967]     }
[09:32:28.967]     ...future.frame <- base::sys.nframe()
[09:32:28.967]     ...future.conditions <- base::list()
[09:32:28.967]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:28.967]     if (FALSE) {
[09:32:28.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:28.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:28.967]     }
[09:32:28.967]     ...future.result <- base::tryCatch({
[09:32:28.967]         base::withCallingHandlers({
[09:32:28.967]             ...future.value <- base::withVisible(base::local({
[09:32:28.967]                 ...future.makeSendCondition <- base::local({
[09:32:28.967]                   sendCondition <- NULL
[09:32:28.967]                   function(frame = 1L) {
[09:32:28.967]                     if (is.function(sendCondition)) 
[09:32:28.967]                       return(sendCondition)
[09:32:28.967]                     ns <- getNamespace("parallel")
[09:32:28.967]                     if (exists("sendData", mode = "function", 
[09:32:28.967]                       envir = ns)) {
[09:32:28.967]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:28.967]                         envir = ns)
[09:32:28.967]                       envir <- sys.frame(frame)
[09:32:28.967]                       master <- NULL
[09:32:28.967]                       while (!identical(envir, .GlobalEnv) && 
[09:32:28.967]                         !identical(envir, emptyenv())) {
[09:32:28.967]                         if (exists("master", mode = "list", envir = envir, 
[09:32:28.967]                           inherits = FALSE)) {
[09:32:28.967]                           master <- get("master", mode = "list", 
[09:32:28.967]                             envir = envir, inherits = FALSE)
[09:32:28.967]                           if (inherits(master, c("SOCKnode", 
[09:32:28.967]                             "SOCK0node"))) {
[09:32:28.967]                             sendCondition <<- function(cond) {
[09:32:28.967]                               data <- list(type = "VALUE", value = cond, 
[09:32:28.967]                                 success = TRUE)
[09:32:28.967]                               parallel_sendData(master, data)
[09:32:28.967]                             }
[09:32:28.967]                             return(sendCondition)
[09:32:28.967]                           }
[09:32:28.967]                         }
[09:32:28.967]                         frame <- frame + 1L
[09:32:28.967]                         envir <- sys.frame(frame)
[09:32:28.967]                       }
[09:32:28.967]                     }
[09:32:28.967]                     sendCondition <<- function(cond) NULL
[09:32:28.967]                   }
[09:32:28.967]                 })
[09:32:28.967]                 withCallingHandlers({
[09:32:28.967]                   {
[09:32:28.967]                     Sys.sleep(0.5)
[09:32:28.967]                     list(a = 1, b = 42L)
[09:32:28.967]                   }
[09:32:28.967]                 }, immediateCondition = function(cond) {
[09:32:28.967]                   sendCondition <- ...future.makeSendCondition()
[09:32:28.967]                   sendCondition(cond)
[09:32:28.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.967]                   {
[09:32:28.967]                     inherits <- base::inherits
[09:32:28.967]                     invokeRestart <- base::invokeRestart
[09:32:28.967]                     is.null <- base::is.null
[09:32:28.967]                     muffled <- FALSE
[09:32:28.967]                     if (inherits(cond, "message")) {
[09:32:28.967]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:28.967]                       if (muffled) 
[09:32:28.967]                         invokeRestart("muffleMessage")
[09:32:28.967]                     }
[09:32:28.967]                     else if (inherits(cond, "warning")) {
[09:32:28.967]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:28.967]                       if (muffled) 
[09:32:28.967]                         invokeRestart("muffleWarning")
[09:32:28.967]                     }
[09:32:28.967]                     else if (inherits(cond, "condition")) {
[09:32:28.967]                       if (!is.null(pattern)) {
[09:32:28.967]                         computeRestarts <- base::computeRestarts
[09:32:28.967]                         grepl <- base::grepl
[09:32:28.967]                         restarts <- computeRestarts(cond)
[09:32:28.967]                         for (restart in restarts) {
[09:32:28.967]                           name <- restart$name
[09:32:28.967]                           if (is.null(name)) 
[09:32:28.967]                             next
[09:32:28.967]                           if (!grepl(pattern, name)) 
[09:32:28.967]                             next
[09:32:28.967]                           invokeRestart(restart)
[09:32:28.967]                           muffled <- TRUE
[09:32:28.967]                           break
[09:32:28.967]                         }
[09:32:28.967]                       }
[09:32:28.967]                     }
[09:32:28.967]                     invisible(muffled)
[09:32:28.967]                   }
[09:32:28.967]                   muffleCondition(cond)
[09:32:28.967]                 })
[09:32:28.967]             }))
[09:32:28.967]             future::FutureResult(value = ...future.value$value, 
[09:32:28.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.967]                   ...future.rng), globalenv = if (FALSE) 
[09:32:28.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:28.967]                     ...future.globalenv.names))
[09:32:28.967]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:28.967]         }, condition = base::local({
[09:32:28.967]             c <- base::c
[09:32:28.967]             inherits <- base::inherits
[09:32:28.967]             invokeRestart <- base::invokeRestart
[09:32:28.967]             length <- base::length
[09:32:28.967]             list <- base::list
[09:32:28.967]             seq.int <- base::seq.int
[09:32:28.967]             signalCondition <- base::signalCondition
[09:32:28.967]             sys.calls <- base::sys.calls
[09:32:28.967]             `[[` <- base::`[[`
[09:32:28.967]             `+` <- base::`+`
[09:32:28.967]             `<<-` <- base::`<<-`
[09:32:28.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:28.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:28.967]                   3L)]
[09:32:28.967]             }
[09:32:28.967]             function(cond) {
[09:32:28.967]                 is_error <- inherits(cond, "error")
[09:32:28.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:28.967]                   NULL)
[09:32:28.967]                 if (is_error) {
[09:32:28.967]                   sessionInformation <- function() {
[09:32:28.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:28.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:28.967]                       search = base::search(), system = base::Sys.info())
[09:32:28.967]                   }
[09:32:28.967]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:28.967]                     cond$call), session = sessionInformation(), 
[09:32:28.967]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:28.967]                   signalCondition(cond)
[09:32:28.967]                 }
[09:32:28.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:28.967]                 "immediateCondition"))) {
[09:32:28.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:28.967]                   ...future.conditions[[length(...future.conditions) + 
[09:32:28.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:28.967]                   if (TRUE && !signal) {
[09:32:28.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.967]                     {
[09:32:28.967]                       inherits <- base::inherits
[09:32:28.967]                       invokeRestart <- base::invokeRestart
[09:32:28.967]                       is.null <- base::is.null
[09:32:28.967]                       muffled <- FALSE
[09:32:28.967]                       if (inherits(cond, "message")) {
[09:32:28.967]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.967]                         if (muffled) 
[09:32:28.967]                           invokeRestart("muffleMessage")
[09:32:28.967]                       }
[09:32:28.967]                       else if (inherits(cond, "warning")) {
[09:32:28.967]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.967]                         if (muffled) 
[09:32:28.967]                           invokeRestart("muffleWarning")
[09:32:28.967]                       }
[09:32:28.967]                       else if (inherits(cond, "condition")) {
[09:32:28.967]                         if (!is.null(pattern)) {
[09:32:28.967]                           computeRestarts <- base::computeRestarts
[09:32:28.967]                           grepl <- base::grepl
[09:32:28.967]                           restarts <- computeRestarts(cond)
[09:32:28.967]                           for (restart in restarts) {
[09:32:28.967]                             name <- restart$name
[09:32:28.967]                             if (is.null(name)) 
[09:32:28.967]                               next
[09:32:28.967]                             if (!grepl(pattern, name)) 
[09:32:28.967]                               next
[09:32:28.967]                             invokeRestart(restart)
[09:32:28.967]                             muffled <- TRUE
[09:32:28.967]                             break
[09:32:28.967]                           }
[09:32:28.967]                         }
[09:32:28.967]                       }
[09:32:28.967]                       invisible(muffled)
[09:32:28.967]                     }
[09:32:28.967]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.967]                   }
[09:32:28.967]                 }
[09:32:28.967]                 else {
[09:32:28.967]                   if (TRUE) {
[09:32:28.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:28.967]                     {
[09:32:28.967]                       inherits <- base::inherits
[09:32:28.967]                       invokeRestart <- base::invokeRestart
[09:32:28.967]                       is.null <- base::is.null
[09:32:28.967]                       muffled <- FALSE
[09:32:28.967]                       if (inherits(cond, "message")) {
[09:32:28.967]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:28.967]                         if (muffled) 
[09:32:28.967]                           invokeRestart("muffleMessage")
[09:32:28.967]                       }
[09:32:28.967]                       else if (inherits(cond, "warning")) {
[09:32:28.967]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:28.967]                         if (muffled) 
[09:32:28.967]                           invokeRestart("muffleWarning")
[09:32:28.967]                       }
[09:32:28.967]                       else if (inherits(cond, "condition")) {
[09:32:28.967]                         if (!is.null(pattern)) {
[09:32:28.967]                           computeRestarts <- base::computeRestarts
[09:32:28.967]                           grepl <- base::grepl
[09:32:28.967]                           restarts <- computeRestarts(cond)
[09:32:28.967]                           for (restart in restarts) {
[09:32:28.967]                             name <- restart$name
[09:32:28.967]                             if (is.null(name)) 
[09:32:28.967]                               next
[09:32:28.967]                             if (!grepl(pattern, name)) 
[09:32:28.967]                               next
[09:32:28.967]                             invokeRestart(restart)
[09:32:28.967]                             muffled <- TRUE
[09:32:28.967]                             break
[09:32:28.967]                           }
[09:32:28.967]                         }
[09:32:28.967]                       }
[09:32:28.967]                       invisible(muffled)
[09:32:28.967]                     }
[09:32:28.967]                     muffleCondition(cond, pattern = "^muffle")
[09:32:28.967]                   }
[09:32:28.967]                 }
[09:32:28.967]             }
[09:32:28.967]         }))
[09:32:28.967]     }, error = function(ex) {
[09:32:28.967]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:28.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:28.967]                 ...future.rng), started = ...future.startTime, 
[09:32:28.967]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:28.967]             version = "1.8"), class = "FutureResult")
[09:32:28.967]     }, finally = {
[09:32:28.967]         if (!identical(...future.workdir, getwd())) 
[09:32:28.967]             setwd(...future.workdir)
[09:32:28.967]         {
[09:32:28.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:28.967]                 ...future.oldOptions$nwarnings <- NULL
[09:32:28.967]             }
[09:32:28.967]             base::options(...future.oldOptions)
[09:32:28.967]             if (.Platform$OS.type == "windows") {
[09:32:28.967]                 old_names <- names(...future.oldEnvVars)
[09:32:28.967]                 envs <- base::Sys.getenv()
[09:32:28.967]                 names <- names(envs)
[09:32:28.967]                 common <- intersect(names, old_names)
[09:32:28.967]                 added <- setdiff(names, old_names)
[09:32:28.967]                 removed <- setdiff(old_names, names)
[09:32:28.967]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:28.967]                   envs[common]]
[09:32:28.967]                 NAMES <- toupper(changed)
[09:32:28.967]                 args <- list()
[09:32:28.967]                 for (kk in seq_along(NAMES)) {
[09:32:28.967]                   name <- changed[[kk]]
[09:32:28.967]                   NAME <- NAMES[[kk]]
[09:32:28.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.967]                     next
[09:32:28.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.967]                 }
[09:32:28.967]                 NAMES <- toupper(added)
[09:32:28.967]                 for (kk in seq_along(NAMES)) {
[09:32:28.967]                   name <- added[[kk]]
[09:32:28.967]                   NAME <- NAMES[[kk]]
[09:32:28.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.967]                     next
[09:32:28.967]                   args[[name]] <- ""
[09:32:28.967]                 }
[09:32:28.967]                 NAMES <- toupper(removed)
[09:32:28.967]                 for (kk in seq_along(NAMES)) {
[09:32:28.967]                   name <- removed[[kk]]
[09:32:28.967]                   NAME <- NAMES[[kk]]
[09:32:28.967]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:28.967]                     next
[09:32:28.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:28.967]                 }
[09:32:28.967]                 if (length(args) > 0) 
[09:32:28.967]                   base::do.call(base::Sys.setenv, args = args)
[09:32:28.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:28.967]             }
[09:32:28.967]             else {
[09:32:28.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:28.967]             }
[09:32:28.967]             {
[09:32:28.967]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:28.967]                   0L) {
[09:32:28.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:28.967]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:28.967]                   base::options(opts)
[09:32:28.967]                 }
[09:32:28.967]                 {
[09:32:28.967]                   {
[09:32:28.967]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:28.967]                     NULL
[09:32:28.967]                   }
[09:32:28.967]                   options(future.plan = NULL)
[09:32:28.967]                   if (is.na(NA_character_)) 
[09:32:28.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:28.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:28.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:28.967]                     .init = FALSE)
[09:32:28.967]                 }
[09:32:28.967]             }
[09:32:28.967]         }
[09:32:28.967]     })
[09:32:28.967]     if (TRUE) {
[09:32:28.967]         base::sink(type = "output", split = FALSE)
[09:32:28.967]         if (TRUE) {
[09:32:28.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:28.967]         }
[09:32:28.967]         else {
[09:32:28.967]             ...future.result["stdout"] <- base::list(NULL)
[09:32:28.967]         }
[09:32:28.967]         base::close(...future.stdout)
[09:32:28.967]         ...future.stdout <- NULL
[09:32:28.967]     }
[09:32:28.967]     ...future.result$conditions <- ...future.conditions
[09:32:28.967]     ...future.result$finished <- base::Sys.time()
[09:32:28.967]     ...future.result
[09:32:28.967] }
[09:32:28.969] MultisessionFuture started
[09:32:28.970] - Launch lazy future ... done
[09:32:28.970] run() for ‘MultisessionFuture’ ... done
[09:32:29.472] receiveMessageFromWorker() for ClusterFuture ...
[09:32:29.472] - Validating connection of MultisessionFuture
[09:32:29.472] - received message: FutureResult
[09:32:29.472] - Received FutureResult
[09:32:29.473] - Erased future from FutureRegistry
[09:32:29.473] result() for ClusterFuture ...
[09:32:29.473] - result already collected: FutureResult
[09:32:29.473] result() for ClusterFuture ... done
[09:32:29.473] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:29.473] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[09:32:29.473] getGlobalsAndPackages() ...
[09:32:29.473] Searching for globals...
[09:32:29.474] - globals found: [2] ‘list’, ‘stop’
[09:32:29.474] Searching for globals ... DONE
[09:32:29.474] Resolving globals: FALSE
[09:32:29.475] 
[09:32:29.475] 
[09:32:29.475] getGlobalsAndPackages() ... DONE
[09:32:29.475] run() for ‘Future’ ...
[09:32:29.475] - state: ‘created’
[09:32:29.475] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:29.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:29.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:29.490]   - Field: ‘node’
[09:32:29.490]   - Field: ‘label’
[09:32:29.490]   - Field: ‘local’
[09:32:29.491]   - Field: ‘owner’
[09:32:29.491]   - Field: ‘envir’
[09:32:29.491]   - Field: ‘workers’
[09:32:29.491]   - Field: ‘packages’
[09:32:29.491]   - Field: ‘gc’
[09:32:29.491]   - Field: ‘conditions’
[09:32:29.491]   - Field: ‘persistent’
[09:32:29.491]   - Field: ‘expr’
[09:32:29.491]   - Field: ‘uuid’
[09:32:29.491]   - Field: ‘seed’
[09:32:29.491]   - Field: ‘version’
[09:32:29.492]   - Field: ‘result’
[09:32:29.492]   - Field: ‘asynchronous’
[09:32:29.492]   - Field: ‘calls’
[09:32:29.492]   - Field: ‘globals’
[09:32:29.492]   - Field: ‘stdout’
[09:32:29.492]   - Field: ‘earlySignal’
[09:32:29.492]   - Field: ‘lazy’
[09:32:29.492]   - Field: ‘state’
[09:32:29.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:29.492] - Launch lazy future ...
[09:32:29.493] Packages needed by the future expression (n = 0): <none>
[09:32:29.493] Packages needed by future strategies (n = 0): <none>
[09:32:29.493] {
[09:32:29.493]     {
[09:32:29.493]         {
[09:32:29.493]             ...future.startTime <- base::Sys.time()
[09:32:29.493]             {
[09:32:29.493]                 {
[09:32:29.493]                   {
[09:32:29.493]                     {
[09:32:29.493]                       base::local({
[09:32:29.493]                         has_future <- base::requireNamespace("future", 
[09:32:29.493]                           quietly = TRUE)
[09:32:29.493]                         if (has_future) {
[09:32:29.493]                           ns <- base::getNamespace("future")
[09:32:29.493]                           version <- ns[[".package"]][["version"]]
[09:32:29.493]                           if (is.null(version)) 
[09:32:29.493]                             version <- utils::packageVersion("future")
[09:32:29.493]                         }
[09:32:29.493]                         else {
[09:32:29.493]                           version <- NULL
[09:32:29.493]                         }
[09:32:29.493]                         if (!has_future || version < "1.8.0") {
[09:32:29.493]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:29.493]                             "", base::R.version$version.string), 
[09:32:29.493]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:29.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:29.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:29.493]                               "release", "version")], collapse = " "), 
[09:32:29.493]                             hostname = base::Sys.info()[["nodename"]])
[09:32:29.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:29.493]                             info)
[09:32:29.493]                           info <- base::paste(info, collapse = "; ")
[09:32:29.493]                           if (!has_future) {
[09:32:29.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:29.493]                               info)
[09:32:29.493]                           }
[09:32:29.493]                           else {
[09:32:29.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:29.493]                               info, version)
[09:32:29.493]                           }
[09:32:29.493]                           base::stop(msg)
[09:32:29.493]                         }
[09:32:29.493]                       })
[09:32:29.493]                     }
[09:32:29.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:29.493]                     base::options(mc.cores = 1L)
[09:32:29.493]                   }
[09:32:29.493]                   ...future.strategy.old <- future::plan("list")
[09:32:29.493]                   options(future.plan = NULL)
[09:32:29.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:29.493]                 }
[09:32:29.493]                 ...future.workdir <- getwd()
[09:32:29.493]             }
[09:32:29.493]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:29.493]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:29.493]         }
[09:32:29.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:29.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:29.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:29.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:29.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:29.493]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:29.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:29.493]             base::names(...future.oldOptions))
[09:32:29.493]     }
[09:32:29.493]     if (FALSE) {
[09:32:29.493]     }
[09:32:29.493]     else {
[09:32:29.493]         if (TRUE) {
[09:32:29.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:29.493]                 open = "w")
[09:32:29.493]         }
[09:32:29.493]         else {
[09:32:29.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:29.493]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:29.493]         }
[09:32:29.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:29.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:29.493]             base::sink(type = "output", split = FALSE)
[09:32:29.493]             base::close(...future.stdout)
[09:32:29.493]         }, add = TRUE)
[09:32:29.493]     }
[09:32:29.493]     ...future.frame <- base::sys.nframe()
[09:32:29.493]     ...future.conditions <- base::list()
[09:32:29.493]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:29.493]     if (FALSE) {
[09:32:29.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:29.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:29.493]     }
[09:32:29.493]     ...future.result <- base::tryCatch({
[09:32:29.493]         base::withCallingHandlers({
[09:32:29.493]             ...future.value <- base::withVisible(base::local({
[09:32:29.493]                 ...future.makeSendCondition <- base::local({
[09:32:29.493]                   sendCondition <- NULL
[09:32:29.493]                   function(frame = 1L) {
[09:32:29.493]                     if (is.function(sendCondition)) 
[09:32:29.493]                       return(sendCondition)
[09:32:29.493]                     ns <- getNamespace("parallel")
[09:32:29.493]                     if (exists("sendData", mode = "function", 
[09:32:29.493]                       envir = ns)) {
[09:32:29.493]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:29.493]                         envir = ns)
[09:32:29.493]                       envir <- sys.frame(frame)
[09:32:29.493]                       master <- NULL
[09:32:29.493]                       while (!identical(envir, .GlobalEnv) && 
[09:32:29.493]                         !identical(envir, emptyenv())) {
[09:32:29.493]                         if (exists("master", mode = "list", envir = envir, 
[09:32:29.493]                           inherits = FALSE)) {
[09:32:29.493]                           master <- get("master", mode = "list", 
[09:32:29.493]                             envir = envir, inherits = FALSE)
[09:32:29.493]                           if (inherits(master, c("SOCKnode", 
[09:32:29.493]                             "SOCK0node"))) {
[09:32:29.493]                             sendCondition <<- function(cond) {
[09:32:29.493]                               data <- list(type = "VALUE", value = cond, 
[09:32:29.493]                                 success = TRUE)
[09:32:29.493]                               parallel_sendData(master, data)
[09:32:29.493]                             }
[09:32:29.493]                             return(sendCondition)
[09:32:29.493]                           }
[09:32:29.493]                         }
[09:32:29.493]                         frame <- frame + 1L
[09:32:29.493]                         envir <- sys.frame(frame)
[09:32:29.493]                       }
[09:32:29.493]                     }
[09:32:29.493]                     sendCondition <<- function(cond) NULL
[09:32:29.493]                   }
[09:32:29.493]                 })
[09:32:29.493]                 withCallingHandlers({
[09:32:29.493]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:29.493]                 }, immediateCondition = function(cond) {
[09:32:29.493]                   sendCondition <- ...future.makeSendCondition()
[09:32:29.493]                   sendCondition(cond)
[09:32:29.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.493]                   {
[09:32:29.493]                     inherits <- base::inherits
[09:32:29.493]                     invokeRestart <- base::invokeRestart
[09:32:29.493]                     is.null <- base::is.null
[09:32:29.493]                     muffled <- FALSE
[09:32:29.493]                     if (inherits(cond, "message")) {
[09:32:29.493]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:29.493]                       if (muffled) 
[09:32:29.493]                         invokeRestart("muffleMessage")
[09:32:29.493]                     }
[09:32:29.493]                     else if (inherits(cond, "warning")) {
[09:32:29.493]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:29.493]                       if (muffled) 
[09:32:29.493]                         invokeRestart("muffleWarning")
[09:32:29.493]                     }
[09:32:29.493]                     else if (inherits(cond, "condition")) {
[09:32:29.493]                       if (!is.null(pattern)) {
[09:32:29.493]                         computeRestarts <- base::computeRestarts
[09:32:29.493]                         grepl <- base::grepl
[09:32:29.493]                         restarts <- computeRestarts(cond)
[09:32:29.493]                         for (restart in restarts) {
[09:32:29.493]                           name <- restart$name
[09:32:29.493]                           if (is.null(name)) 
[09:32:29.493]                             next
[09:32:29.493]                           if (!grepl(pattern, name)) 
[09:32:29.493]                             next
[09:32:29.493]                           invokeRestart(restart)
[09:32:29.493]                           muffled <- TRUE
[09:32:29.493]                           break
[09:32:29.493]                         }
[09:32:29.493]                       }
[09:32:29.493]                     }
[09:32:29.493]                     invisible(muffled)
[09:32:29.493]                   }
[09:32:29.493]                   muffleCondition(cond)
[09:32:29.493]                 })
[09:32:29.493]             }))
[09:32:29.493]             future::FutureResult(value = ...future.value$value, 
[09:32:29.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.493]                   ...future.rng), globalenv = if (FALSE) 
[09:32:29.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:29.493]                     ...future.globalenv.names))
[09:32:29.493]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:29.493]         }, condition = base::local({
[09:32:29.493]             c <- base::c
[09:32:29.493]             inherits <- base::inherits
[09:32:29.493]             invokeRestart <- base::invokeRestart
[09:32:29.493]             length <- base::length
[09:32:29.493]             list <- base::list
[09:32:29.493]             seq.int <- base::seq.int
[09:32:29.493]             signalCondition <- base::signalCondition
[09:32:29.493]             sys.calls <- base::sys.calls
[09:32:29.493]             `[[` <- base::`[[`
[09:32:29.493]             `+` <- base::`+`
[09:32:29.493]             `<<-` <- base::`<<-`
[09:32:29.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:29.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:29.493]                   3L)]
[09:32:29.493]             }
[09:32:29.493]             function(cond) {
[09:32:29.493]                 is_error <- inherits(cond, "error")
[09:32:29.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:29.493]                   NULL)
[09:32:29.493]                 if (is_error) {
[09:32:29.493]                   sessionInformation <- function() {
[09:32:29.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:29.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:29.493]                       search = base::search(), system = base::Sys.info())
[09:32:29.493]                   }
[09:32:29.493]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:29.493]                     cond$call), session = sessionInformation(), 
[09:32:29.493]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:29.493]                   signalCondition(cond)
[09:32:29.493]                 }
[09:32:29.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:29.493]                 "immediateCondition"))) {
[09:32:29.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:29.493]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:29.493]                   if (TRUE && !signal) {
[09:32:29.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.493]                     {
[09:32:29.493]                       inherits <- base::inherits
[09:32:29.493]                       invokeRestart <- base::invokeRestart
[09:32:29.493]                       is.null <- base::is.null
[09:32:29.493]                       muffled <- FALSE
[09:32:29.493]                       if (inherits(cond, "message")) {
[09:32:29.493]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.493]                         if (muffled) 
[09:32:29.493]                           invokeRestart("muffleMessage")
[09:32:29.493]                       }
[09:32:29.493]                       else if (inherits(cond, "warning")) {
[09:32:29.493]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.493]                         if (muffled) 
[09:32:29.493]                           invokeRestart("muffleWarning")
[09:32:29.493]                       }
[09:32:29.493]                       else if (inherits(cond, "condition")) {
[09:32:29.493]                         if (!is.null(pattern)) {
[09:32:29.493]                           computeRestarts <- base::computeRestarts
[09:32:29.493]                           grepl <- base::grepl
[09:32:29.493]                           restarts <- computeRestarts(cond)
[09:32:29.493]                           for (restart in restarts) {
[09:32:29.493]                             name <- restart$name
[09:32:29.493]                             if (is.null(name)) 
[09:32:29.493]                               next
[09:32:29.493]                             if (!grepl(pattern, name)) 
[09:32:29.493]                               next
[09:32:29.493]                             invokeRestart(restart)
[09:32:29.493]                             muffled <- TRUE
[09:32:29.493]                             break
[09:32:29.493]                           }
[09:32:29.493]                         }
[09:32:29.493]                       }
[09:32:29.493]                       invisible(muffled)
[09:32:29.493]                     }
[09:32:29.493]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.493]                   }
[09:32:29.493]                 }
[09:32:29.493]                 else {
[09:32:29.493]                   if (TRUE) {
[09:32:29.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.493]                     {
[09:32:29.493]                       inherits <- base::inherits
[09:32:29.493]                       invokeRestart <- base::invokeRestart
[09:32:29.493]                       is.null <- base::is.null
[09:32:29.493]                       muffled <- FALSE
[09:32:29.493]                       if (inherits(cond, "message")) {
[09:32:29.493]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.493]                         if (muffled) 
[09:32:29.493]                           invokeRestart("muffleMessage")
[09:32:29.493]                       }
[09:32:29.493]                       else if (inherits(cond, "warning")) {
[09:32:29.493]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.493]                         if (muffled) 
[09:32:29.493]                           invokeRestart("muffleWarning")
[09:32:29.493]                       }
[09:32:29.493]                       else if (inherits(cond, "condition")) {
[09:32:29.493]                         if (!is.null(pattern)) {
[09:32:29.493]                           computeRestarts <- base::computeRestarts
[09:32:29.493]                           grepl <- base::grepl
[09:32:29.493]                           restarts <- computeRestarts(cond)
[09:32:29.493]                           for (restart in restarts) {
[09:32:29.493]                             name <- restart$name
[09:32:29.493]                             if (is.null(name)) 
[09:32:29.493]                               next
[09:32:29.493]                             if (!grepl(pattern, name)) 
[09:32:29.493]                               next
[09:32:29.493]                             invokeRestart(restart)
[09:32:29.493]                             muffled <- TRUE
[09:32:29.493]                             break
[09:32:29.493]                           }
[09:32:29.493]                         }
[09:32:29.493]                       }
[09:32:29.493]                       invisible(muffled)
[09:32:29.493]                     }
[09:32:29.493]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.493]                   }
[09:32:29.493]                 }
[09:32:29.493]             }
[09:32:29.493]         }))
[09:32:29.493]     }, error = function(ex) {
[09:32:29.493]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:29.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.493]                 ...future.rng), started = ...future.startTime, 
[09:32:29.493]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:29.493]             version = "1.8"), class = "FutureResult")
[09:32:29.493]     }, finally = {
[09:32:29.493]         if (!identical(...future.workdir, getwd())) 
[09:32:29.493]             setwd(...future.workdir)
[09:32:29.493]         {
[09:32:29.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:29.493]                 ...future.oldOptions$nwarnings <- NULL
[09:32:29.493]             }
[09:32:29.493]             base::options(...future.oldOptions)
[09:32:29.493]             if (.Platform$OS.type == "windows") {
[09:32:29.493]                 old_names <- names(...future.oldEnvVars)
[09:32:29.493]                 envs <- base::Sys.getenv()
[09:32:29.493]                 names <- names(envs)
[09:32:29.493]                 common <- intersect(names, old_names)
[09:32:29.493]                 added <- setdiff(names, old_names)
[09:32:29.493]                 removed <- setdiff(old_names, names)
[09:32:29.493]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:29.493]                   envs[common]]
[09:32:29.493]                 NAMES <- toupper(changed)
[09:32:29.493]                 args <- list()
[09:32:29.493]                 for (kk in seq_along(NAMES)) {
[09:32:29.493]                   name <- changed[[kk]]
[09:32:29.493]                   NAME <- NAMES[[kk]]
[09:32:29.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.493]                     next
[09:32:29.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.493]                 }
[09:32:29.493]                 NAMES <- toupper(added)
[09:32:29.493]                 for (kk in seq_along(NAMES)) {
[09:32:29.493]                   name <- added[[kk]]
[09:32:29.493]                   NAME <- NAMES[[kk]]
[09:32:29.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.493]                     next
[09:32:29.493]                   args[[name]] <- ""
[09:32:29.493]                 }
[09:32:29.493]                 NAMES <- toupper(removed)
[09:32:29.493]                 for (kk in seq_along(NAMES)) {
[09:32:29.493]                   name <- removed[[kk]]
[09:32:29.493]                   NAME <- NAMES[[kk]]
[09:32:29.493]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.493]                     next
[09:32:29.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.493]                 }
[09:32:29.493]                 if (length(args) > 0) 
[09:32:29.493]                   base::do.call(base::Sys.setenv, args = args)
[09:32:29.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:29.493]             }
[09:32:29.493]             else {
[09:32:29.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:29.493]             }
[09:32:29.493]             {
[09:32:29.493]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:29.493]                   0L) {
[09:32:29.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:29.493]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:29.493]                   base::options(opts)
[09:32:29.493]                 }
[09:32:29.493]                 {
[09:32:29.493]                   {
[09:32:29.493]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:29.493]                     NULL
[09:32:29.493]                   }
[09:32:29.493]                   options(future.plan = NULL)
[09:32:29.493]                   if (is.na(NA_character_)) 
[09:32:29.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:29.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:29.493]                     .init = FALSE)
[09:32:29.493]                 }
[09:32:29.493]             }
[09:32:29.493]         }
[09:32:29.493]     })
[09:32:29.493]     if (TRUE) {
[09:32:29.493]         base::sink(type = "output", split = FALSE)
[09:32:29.493]         if (TRUE) {
[09:32:29.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:29.493]         }
[09:32:29.493]         else {
[09:32:29.493]             ...future.result["stdout"] <- base::list(NULL)
[09:32:29.493]         }
[09:32:29.493]         base::close(...future.stdout)
[09:32:29.493]         ...future.stdout <- NULL
[09:32:29.493]     }
[09:32:29.493]     ...future.result$conditions <- ...future.conditions
[09:32:29.493]     ...future.result$finished <- base::Sys.time()
[09:32:29.493]     ...future.result
[09:32:29.493] }
[09:32:29.496] MultisessionFuture started
[09:32:29.496] - Launch lazy future ... done
[09:32:29.496] run() for ‘MultisessionFuture’ ... done
[09:32:29.498] receiveMessageFromWorker() for ClusterFuture ...
[09:32:29.498] - Validating connection of MultisessionFuture
[09:32:29.498] - received message: FutureResult
[09:32:29.498] - Received FutureResult
[09:32:29.498] - Erased future from FutureRegistry
[09:32:29.499] result() for ClusterFuture ...
[09:32:29.499] - result already collected: FutureResult
[09:32:29.499] result() for ClusterFuture ... done
[09:32:29.499] signalConditions() ...
[09:32:29.499]  - include = ‘immediateCondition’
[09:32:29.499]  - exclude = 
[09:32:29.499]  - resignal = FALSE
[09:32:29.499]  - Number of conditions: 1
[09:32:29.499] signalConditions() ... done
[09:32:29.499] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:29.499] A MultisessionFuture was resolved (result was not collected)
[09:32:29.499] getGlobalsAndPackages() ...
[09:32:29.500] Searching for globals...
[09:32:29.500] - globals found: [2] ‘list’, ‘stop’
[09:32:29.500] Searching for globals ... DONE
[09:32:29.500] Resolving globals: FALSE
[09:32:29.501] 
[09:32:29.501] 
[09:32:29.501] getGlobalsAndPackages() ... DONE
[09:32:29.501] run() for ‘Future’ ...
[09:32:29.501] - state: ‘created’
[09:32:29.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:29.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:29.515] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:29.515]   - Field: ‘node’
[09:32:29.515]   - Field: ‘label’
[09:32:29.515]   - Field: ‘local’
[09:32:29.515]   - Field: ‘owner’
[09:32:29.515]   - Field: ‘envir’
[09:32:29.515]   - Field: ‘workers’
[09:32:29.516]   - Field: ‘packages’
[09:32:29.516]   - Field: ‘gc’
[09:32:29.516]   - Field: ‘conditions’
[09:32:29.516]   - Field: ‘persistent’
[09:32:29.516]   - Field: ‘expr’
[09:32:29.516]   - Field: ‘uuid’
[09:32:29.516]   - Field: ‘seed’
[09:32:29.516]   - Field: ‘version’
[09:32:29.516]   - Field: ‘result’
[09:32:29.516]   - Field: ‘asynchronous’
[09:32:29.516]   - Field: ‘calls’
[09:32:29.517]   - Field: ‘globals’
[09:32:29.517]   - Field: ‘stdout’
[09:32:29.517]   - Field: ‘earlySignal’
[09:32:29.517]   - Field: ‘lazy’
[09:32:29.517]   - Field: ‘state’
[09:32:29.517] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:29.517] - Launch lazy future ...
[09:32:29.517] Packages needed by the future expression (n = 0): <none>
[09:32:29.517] Packages needed by future strategies (n = 0): <none>
[09:32:29.518] {
[09:32:29.518]     {
[09:32:29.518]         {
[09:32:29.518]             ...future.startTime <- base::Sys.time()
[09:32:29.518]             {
[09:32:29.518]                 {
[09:32:29.518]                   {
[09:32:29.518]                     {
[09:32:29.518]                       base::local({
[09:32:29.518]                         has_future <- base::requireNamespace("future", 
[09:32:29.518]                           quietly = TRUE)
[09:32:29.518]                         if (has_future) {
[09:32:29.518]                           ns <- base::getNamespace("future")
[09:32:29.518]                           version <- ns[[".package"]][["version"]]
[09:32:29.518]                           if (is.null(version)) 
[09:32:29.518]                             version <- utils::packageVersion("future")
[09:32:29.518]                         }
[09:32:29.518]                         else {
[09:32:29.518]                           version <- NULL
[09:32:29.518]                         }
[09:32:29.518]                         if (!has_future || version < "1.8.0") {
[09:32:29.518]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:29.518]                             "", base::R.version$version.string), 
[09:32:29.518]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:29.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:29.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:29.518]                               "release", "version")], collapse = " "), 
[09:32:29.518]                             hostname = base::Sys.info()[["nodename"]])
[09:32:29.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:29.518]                             info)
[09:32:29.518]                           info <- base::paste(info, collapse = "; ")
[09:32:29.518]                           if (!has_future) {
[09:32:29.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:29.518]                               info)
[09:32:29.518]                           }
[09:32:29.518]                           else {
[09:32:29.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:29.518]                               info, version)
[09:32:29.518]                           }
[09:32:29.518]                           base::stop(msg)
[09:32:29.518]                         }
[09:32:29.518]                       })
[09:32:29.518]                     }
[09:32:29.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:29.518]                     base::options(mc.cores = 1L)
[09:32:29.518]                   }
[09:32:29.518]                   ...future.strategy.old <- future::plan("list")
[09:32:29.518]                   options(future.plan = NULL)
[09:32:29.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:29.518]                 }
[09:32:29.518]                 ...future.workdir <- getwd()
[09:32:29.518]             }
[09:32:29.518]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:29.518]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:29.518]         }
[09:32:29.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:29.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:29.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:29.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:29.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:29.518]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:29.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:29.518]             base::names(...future.oldOptions))
[09:32:29.518]     }
[09:32:29.518]     if (FALSE) {
[09:32:29.518]     }
[09:32:29.518]     else {
[09:32:29.518]         if (TRUE) {
[09:32:29.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:29.518]                 open = "w")
[09:32:29.518]         }
[09:32:29.518]         else {
[09:32:29.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:29.518]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:29.518]         }
[09:32:29.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:29.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:29.518]             base::sink(type = "output", split = FALSE)
[09:32:29.518]             base::close(...future.stdout)
[09:32:29.518]         }, add = TRUE)
[09:32:29.518]     }
[09:32:29.518]     ...future.frame <- base::sys.nframe()
[09:32:29.518]     ...future.conditions <- base::list()
[09:32:29.518]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:29.518]     if (FALSE) {
[09:32:29.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:29.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:29.518]     }
[09:32:29.518]     ...future.result <- base::tryCatch({
[09:32:29.518]         base::withCallingHandlers({
[09:32:29.518]             ...future.value <- base::withVisible(base::local({
[09:32:29.518]                 ...future.makeSendCondition <- base::local({
[09:32:29.518]                   sendCondition <- NULL
[09:32:29.518]                   function(frame = 1L) {
[09:32:29.518]                     if (is.function(sendCondition)) 
[09:32:29.518]                       return(sendCondition)
[09:32:29.518]                     ns <- getNamespace("parallel")
[09:32:29.518]                     if (exists("sendData", mode = "function", 
[09:32:29.518]                       envir = ns)) {
[09:32:29.518]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:29.518]                         envir = ns)
[09:32:29.518]                       envir <- sys.frame(frame)
[09:32:29.518]                       master <- NULL
[09:32:29.518]                       while (!identical(envir, .GlobalEnv) && 
[09:32:29.518]                         !identical(envir, emptyenv())) {
[09:32:29.518]                         if (exists("master", mode = "list", envir = envir, 
[09:32:29.518]                           inherits = FALSE)) {
[09:32:29.518]                           master <- get("master", mode = "list", 
[09:32:29.518]                             envir = envir, inherits = FALSE)
[09:32:29.518]                           if (inherits(master, c("SOCKnode", 
[09:32:29.518]                             "SOCK0node"))) {
[09:32:29.518]                             sendCondition <<- function(cond) {
[09:32:29.518]                               data <- list(type = "VALUE", value = cond, 
[09:32:29.518]                                 success = TRUE)
[09:32:29.518]                               parallel_sendData(master, data)
[09:32:29.518]                             }
[09:32:29.518]                             return(sendCondition)
[09:32:29.518]                           }
[09:32:29.518]                         }
[09:32:29.518]                         frame <- frame + 1L
[09:32:29.518]                         envir <- sys.frame(frame)
[09:32:29.518]                       }
[09:32:29.518]                     }
[09:32:29.518]                     sendCondition <<- function(cond) NULL
[09:32:29.518]                   }
[09:32:29.518]                 })
[09:32:29.518]                 withCallingHandlers({
[09:32:29.518]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:29.518]                 }, immediateCondition = function(cond) {
[09:32:29.518]                   sendCondition <- ...future.makeSendCondition()
[09:32:29.518]                   sendCondition(cond)
[09:32:29.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.518]                   {
[09:32:29.518]                     inherits <- base::inherits
[09:32:29.518]                     invokeRestart <- base::invokeRestart
[09:32:29.518]                     is.null <- base::is.null
[09:32:29.518]                     muffled <- FALSE
[09:32:29.518]                     if (inherits(cond, "message")) {
[09:32:29.518]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:29.518]                       if (muffled) 
[09:32:29.518]                         invokeRestart("muffleMessage")
[09:32:29.518]                     }
[09:32:29.518]                     else if (inherits(cond, "warning")) {
[09:32:29.518]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:29.518]                       if (muffled) 
[09:32:29.518]                         invokeRestart("muffleWarning")
[09:32:29.518]                     }
[09:32:29.518]                     else if (inherits(cond, "condition")) {
[09:32:29.518]                       if (!is.null(pattern)) {
[09:32:29.518]                         computeRestarts <- base::computeRestarts
[09:32:29.518]                         grepl <- base::grepl
[09:32:29.518]                         restarts <- computeRestarts(cond)
[09:32:29.518]                         for (restart in restarts) {
[09:32:29.518]                           name <- restart$name
[09:32:29.518]                           if (is.null(name)) 
[09:32:29.518]                             next
[09:32:29.518]                           if (!grepl(pattern, name)) 
[09:32:29.518]                             next
[09:32:29.518]                           invokeRestart(restart)
[09:32:29.518]                           muffled <- TRUE
[09:32:29.518]                           break
[09:32:29.518]                         }
[09:32:29.518]                       }
[09:32:29.518]                     }
[09:32:29.518]                     invisible(muffled)
[09:32:29.518]                   }
[09:32:29.518]                   muffleCondition(cond)
[09:32:29.518]                 })
[09:32:29.518]             }))
[09:32:29.518]             future::FutureResult(value = ...future.value$value, 
[09:32:29.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.518]                   ...future.rng), globalenv = if (FALSE) 
[09:32:29.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:29.518]                     ...future.globalenv.names))
[09:32:29.518]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:29.518]         }, condition = base::local({
[09:32:29.518]             c <- base::c
[09:32:29.518]             inherits <- base::inherits
[09:32:29.518]             invokeRestart <- base::invokeRestart
[09:32:29.518]             length <- base::length
[09:32:29.518]             list <- base::list
[09:32:29.518]             seq.int <- base::seq.int
[09:32:29.518]             signalCondition <- base::signalCondition
[09:32:29.518]             sys.calls <- base::sys.calls
[09:32:29.518]             `[[` <- base::`[[`
[09:32:29.518]             `+` <- base::`+`
[09:32:29.518]             `<<-` <- base::`<<-`
[09:32:29.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:29.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:29.518]                   3L)]
[09:32:29.518]             }
[09:32:29.518]             function(cond) {
[09:32:29.518]                 is_error <- inherits(cond, "error")
[09:32:29.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:29.518]                   NULL)
[09:32:29.518]                 if (is_error) {
[09:32:29.518]                   sessionInformation <- function() {
[09:32:29.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:29.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:29.518]                       search = base::search(), system = base::Sys.info())
[09:32:29.518]                   }
[09:32:29.518]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:29.518]                     cond$call), session = sessionInformation(), 
[09:32:29.518]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:29.518]                   signalCondition(cond)
[09:32:29.518]                 }
[09:32:29.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:29.518]                 "immediateCondition"))) {
[09:32:29.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:29.518]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:29.518]                   if (TRUE && !signal) {
[09:32:29.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.518]                     {
[09:32:29.518]                       inherits <- base::inherits
[09:32:29.518]                       invokeRestart <- base::invokeRestart
[09:32:29.518]                       is.null <- base::is.null
[09:32:29.518]                       muffled <- FALSE
[09:32:29.518]                       if (inherits(cond, "message")) {
[09:32:29.518]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.518]                         if (muffled) 
[09:32:29.518]                           invokeRestart("muffleMessage")
[09:32:29.518]                       }
[09:32:29.518]                       else if (inherits(cond, "warning")) {
[09:32:29.518]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.518]                         if (muffled) 
[09:32:29.518]                           invokeRestart("muffleWarning")
[09:32:29.518]                       }
[09:32:29.518]                       else if (inherits(cond, "condition")) {
[09:32:29.518]                         if (!is.null(pattern)) {
[09:32:29.518]                           computeRestarts <- base::computeRestarts
[09:32:29.518]                           grepl <- base::grepl
[09:32:29.518]                           restarts <- computeRestarts(cond)
[09:32:29.518]                           for (restart in restarts) {
[09:32:29.518]                             name <- restart$name
[09:32:29.518]                             if (is.null(name)) 
[09:32:29.518]                               next
[09:32:29.518]                             if (!grepl(pattern, name)) 
[09:32:29.518]                               next
[09:32:29.518]                             invokeRestart(restart)
[09:32:29.518]                             muffled <- TRUE
[09:32:29.518]                             break
[09:32:29.518]                           }
[09:32:29.518]                         }
[09:32:29.518]                       }
[09:32:29.518]                       invisible(muffled)
[09:32:29.518]                     }
[09:32:29.518]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.518]                   }
[09:32:29.518]                 }
[09:32:29.518]                 else {
[09:32:29.518]                   if (TRUE) {
[09:32:29.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.518]                     {
[09:32:29.518]                       inherits <- base::inherits
[09:32:29.518]                       invokeRestart <- base::invokeRestart
[09:32:29.518]                       is.null <- base::is.null
[09:32:29.518]                       muffled <- FALSE
[09:32:29.518]                       if (inherits(cond, "message")) {
[09:32:29.518]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.518]                         if (muffled) 
[09:32:29.518]                           invokeRestart("muffleMessage")
[09:32:29.518]                       }
[09:32:29.518]                       else if (inherits(cond, "warning")) {
[09:32:29.518]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.518]                         if (muffled) 
[09:32:29.518]                           invokeRestart("muffleWarning")
[09:32:29.518]                       }
[09:32:29.518]                       else if (inherits(cond, "condition")) {
[09:32:29.518]                         if (!is.null(pattern)) {
[09:32:29.518]                           computeRestarts <- base::computeRestarts
[09:32:29.518]                           grepl <- base::grepl
[09:32:29.518]                           restarts <- computeRestarts(cond)
[09:32:29.518]                           for (restart in restarts) {
[09:32:29.518]                             name <- restart$name
[09:32:29.518]                             if (is.null(name)) 
[09:32:29.518]                               next
[09:32:29.518]                             if (!grepl(pattern, name)) 
[09:32:29.518]                               next
[09:32:29.518]                             invokeRestart(restart)
[09:32:29.518]                             muffled <- TRUE
[09:32:29.518]                             break
[09:32:29.518]                           }
[09:32:29.518]                         }
[09:32:29.518]                       }
[09:32:29.518]                       invisible(muffled)
[09:32:29.518]                     }
[09:32:29.518]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.518]                   }
[09:32:29.518]                 }
[09:32:29.518]             }
[09:32:29.518]         }))
[09:32:29.518]     }, error = function(ex) {
[09:32:29.518]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:29.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.518]                 ...future.rng), started = ...future.startTime, 
[09:32:29.518]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:29.518]             version = "1.8"), class = "FutureResult")
[09:32:29.518]     }, finally = {
[09:32:29.518]         if (!identical(...future.workdir, getwd())) 
[09:32:29.518]             setwd(...future.workdir)
[09:32:29.518]         {
[09:32:29.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:29.518]                 ...future.oldOptions$nwarnings <- NULL
[09:32:29.518]             }
[09:32:29.518]             base::options(...future.oldOptions)
[09:32:29.518]             if (.Platform$OS.type == "windows") {
[09:32:29.518]                 old_names <- names(...future.oldEnvVars)
[09:32:29.518]                 envs <- base::Sys.getenv()
[09:32:29.518]                 names <- names(envs)
[09:32:29.518]                 common <- intersect(names, old_names)
[09:32:29.518]                 added <- setdiff(names, old_names)
[09:32:29.518]                 removed <- setdiff(old_names, names)
[09:32:29.518]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:29.518]                   envs[common]]
[09:32:29.518]                 NAMES <- toupper(changed)
[09:32:29.518]                 args <- list()
[09:32:29.518]                 for (kk in seq_along(NAMES)) {
[09:32:29.518]                   name <- changed[[kk]]
[09:32:29.518]                   NAME <- NAMES[[kk]]
[09:32:29.518]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.518]                     next
[09:32:29.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.518]                 }
[09:32:29.518]                 NAMES <- toupper(added)
[09:32:29.518]                 for (kk in seq_along(NAMES)) {
[09:32:29.518]                   name <- added[[kk]]
[09:32:29.518]                   NAME <- NAMES[[kk]]
[09:32:29.518]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.518]                     next
[09:32:29.518]                   args[[name]] <- ""
[09:32:29.518]                 }
[09:32:29.518]                 NAMES <- toupper(removed)
[09:32:29.518]                 for (kk in seq_along(NAMES)) {
[09:32:29.518]                   name <- removed[[kk]]
[09:32:29.518]                   NAME <- NAMES[[kk]]
[09:32:29.518]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.518]                     next
[09:32:29.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.518]                 }
[09:32:29.518]                 if (length(args) > 0) 
[09:32:29.518]                   base::do.call(base::Sys.setenv, args = args)
[09:32:29.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:29.518]             }
[09:32:29.518]             else {
[09:32:29.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:29.518]             }
[09:32:29.518]             {
[09:32:29.518]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:29.518]                   0L) {
[09:32:29.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:29.518]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:29.518]                   base::options(opts)
[09:32:29.518]                 }
[09:32:29.518]                 {
[09:32:29.518]                   {
[09:32:29.518]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:29.518]                     NULL
[09:32:29.518]                   }
[09:32:29.518]                   options(future.plan = NULL)
[09:32:29.518]                   if (is.na(NA_character_)) 
[09:32:29.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:29.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:29.518]                     .init = FALSE)
[09:32:29.518]                 }
[09:32:29.518]             }
[09:32:29.518]         }
[09:32:29.518]     })
[09:32:29.518]     if (TRUE) {
[09:32:29.518]         base::sink(type = "output", split = FALSE)
[09:32:29.518]         if (TRUE) {
[09:32:29.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:29.518]         }
[09:32:29.518]         else {
[09:32:29.518]             ...future.result["stdout"] <- base::list(NULL)
[09:32:29.518]         }
[09:32:29.518]         base::close(...future.stdout)
[09:32:29.518]         ...future.stdout <- NULL
[09:32:29.518]     }
[09:32:29.518]     ...future.result$conditions <- ...future.conditions
[09:32:29.518]     ...future.result$finished <- base::Sys.time()
[09:32:29.518]     ...future.result
[09:32:29.518] }
[09:32:29.521] MultisessionFuture started
[09:32:29.521] - Launch lazy future ... done
[09:32:29.521] run() for ‘MultisessionFuture’ ... done
[09:32:29.522] receiveMessageFromWorker() for ClusterFuture ...
[09:32:29.522] - Validating connection of MultisessionFuture
[09:32:29.523] - received message: FutureResult
[09:32:29.523] - Received FutureResult
[09:32:29.523] - Erased future from FutureRegistry
[09:32:29.523] result() for ClusterFuture ...
[09:32:29.523] - result already collected: FutureResult
[09:32:29.523] result() for ClusterFuture ... done
[09:32:29.523] signalConditions() ...
[09:32:29.523]  - include = ‘immediateCondition’
[09:32:29.523]  - exclude = 
[09:32:29.523]  - resignal = FALSE
[09:32:29.524]  - Number of conditions: 1
[09:32:29.524] signalConditions() ... done
[09:32:29.524] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:29.524] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[09:32:29.524] getGlobalsAndPackages() ...
[09:32:29.524] Searching for globals...
[09:32:29.525] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:29.525] Searching for globals ... DONE
[09:32:29.525] Resolving globals: FALSE
[09:32:29.526] 
[09:32:29.526] 
[09:32:29.526] getGlobalsAndPackages() ... DONE
[09:32:29.526] run() for ‘Future’ ...
[09:32:29.526] - state: ‘created’
[09:32:29.526] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:29.540] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:29.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:29.540]   - Field: ‘node’
[09:32:29.540]   - Field: ‘label’
[09:32:29.540]   - Field: ‘local’
[09:32:29.540]   - Field: ‘owner’
[09:32:29.540]   - Field: ‘envir’
[09:32:29.540]   - Field: ‘workers’
[09:32:29.540]   - Field: ‘packages’
[09:32:29.541]   - Field: ‘gc’
[09:32:29.541]   - Field: ‘conditions’
[09:32:29.541]   - Field: ‘persistent’
[09:32:29.541]   - Field: ‘expr’
[09:32:29.541]   - Field: ‘uuid’
[09:32:29.541]   - Field: ‘seed’
[09:32:29.541]   - Field: ‘version’
[09:32:29.541]   - Field: ‘result’
[09:32:29.541]   - Field: ‘asynchronous’
[09:32:29.541]   - Field: ‘calls’
[09:32:29.541]   - Field: ‘globals’
[09:32:29.541]   - Field: ‘stdout’
[09:32:29.542]   - Field: ‘earlySignal’
[09:32:29.542]   - Field: ‘lazy’
[09:32:29.542]   - Field: ‘state’
[09:32:29.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:29.542] - Launch lazy future ...
[09:32:29.542] Packages needed by the future expression (n = 0): <none>
[09:32:29.542] Packages needed by future strategies (n = 0): <none>
[09:32:29.543] {
[09:32:29.543]     {
[09:32:29.543]         {
[09:32:29.543]             ...future.startTime <- base::Sys.time()
[09:32:29.543]             {
[09:32:29.543]                 {
[09:32:29.543]                   {
[09:32:29.543]                     {
[09:32:29.543]                       base::local({
[09:32:29.543]                         has_future <- base::requireNamespace("future", 
[09:32:29.543]                           quietly = TRUE)
[09:32:29.543]                         if (has_future) {
[09:32:29.543]                           ns <- base::getNamespace("future")
[09:32:29.543]                           version <- ns[[".package"]][["version"]]
[09:32:29.543]                           if (is.null(version)) 
[09:32:29.543]                             version <- utils::packageVersion("future")
[09:32:29.543]                         }
[09:32:29.543]                         else {
[09:32:29.543]                           version <- NULL
[09:32:29.543]                         }
[09:32:29.543]                         if (!has_future || version < "1.8.0") {
[09:32:29.543]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:29.543]                             "", base::R.version$version.string), 
[09:32:29.543]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:29.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:29.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:29.543]                               "release", "version")], collapse = " "), 
[09:32:29.543]                             hostname = base::Sys.info()[["nodename"]])
[09:32:29.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:29.543]                             info)
[09:32:29.543]                           info <- base::paste(info, collapse = "; ")
[09:32:29.543]                           if (!has_future) {
[09:32:29.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:29.543]                               info)
[09:32:29.543]                           }
[09:32:29.543]                           else {
[09:32:29.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:29.543]                               info, version)
[09:32:29.543]                           }
[09:32:29.543]                           base::stop(msg)
[09:32:29.543]                         }
[09:32:29.543]                       })
[09:32:29.543]                     }
[09:32:29.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:29.543]                     base::options(mc.cores = 1L)
[09:32:29.543]                   }
[09:32:29.543]                   ...future.strategy.old <- future::plan("list")
[09:32:29.543]                   options(future.plan = NULL)
[09:32:29.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:29.543]                 }
[09:32:29.543]                 ...future.workdir <- getwd()
[09:32:29.543]             }
[09:32:29.543]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:29.543]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:29.543]         }
[09:32:29.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:29.543]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:29.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:29.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:29.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:29.543]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:29.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:29.543]             base::names(...future.oldOptions))
[09:32:29.543]     }
[09:32:29.543]     if (FALSE) {
[09:32:29.543]     }
[09:32:29.543]     else {
[09:32:29.543]         if (TRUE) {
[09:32:29.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:29.543]                 open = "w")
[09:32:29.543]         }
[09:32:29.543]         else {
[09:32:29.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:29.543]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:29.543]         }
[09:32:29.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:29.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:29.543]             base::sink(type = "output", split = FALSE)
[09:32:29.543]             base::close(...future.stdout)
[09:32:29.543]         }, add = TRUE)
[09:32:29.543]     }
[09:32:29.543]     ...future.frame <- base::sys.nframe()
[09:32:29.543]     ...future.conditions <- base::list()
[09:32:29.543]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:29.543]     if (FALSE) {
[09:32:29.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:29.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:29.543]     }
[09:32:29.543]     ...future.result <- base::tryCatch({
[09:32:29.543]         base::withCallingHandlers({
[09:32:29.543]             ...future.value <- base::withVisible(base::local({
[09:32:29.543]                 ...future.makeSendCondition <- base::local({
[09:32:29.543]                   sendCondition <- NULL
[09:32:29.543]                   function(frame = 1L) {
[09:32:29.543]                     if (is.function(sendCondition)) 
[09:32:29.543]                       return(sendCondition)
[09:32:29.543]                     ns <- getNamespace("parallel")
[09:32:29.543]                     if (exists("sendData", mode = "function", 
[09:32:29.543]                       envir = ns)) {
[09:32:29.543]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:29.543]                         envir = ns)
[09:32:29.543]                       envir <- sys.frame(frame)
[09:32:29.543]                       master <- NULL
[09:32:29.543]                       while (!identical(envir, .GlobalEnv) && 
[09:32:29.543]                         !identical(envir, emptyenv())) {
[09:32:29.543]                         if (exists("master", mode = "list", envir = envir, 
[09:32:29.543]                           inherits = FALSE)) {
[09:32:29.543]                           master <- get("master", mode = "list", 
[09:32:29.543]                             envir = envir, inherits = FALSE)
[09:32:29.543]                           if (inherits(master, c("SOCKnode", 
[09:32:29.543]                             "SOCK0node"))) {
[09:32:29.543]                             sendCondition <<- function(cond) {
[09:32:29.543]                               data <- list(type = "VALUE", value = cond, 
[09:32:29.543]                                 success = TRUE)
[09:32:29.543]                               parallel_sendData(master, data)
[09:32:29.543]                             }
[09:32:29.543]                             return(sendCondition)
[09:32:29.543]                           }
[09:32:29.543]                         }
[09:32:29.543]                         frame <- frame + 1L
[09:32:29.543]                         envir <- sys.frame(frame)
[09:32:29.543]                       }
[09:32:29.543]                     }
[09:32:29.543]                     sendCondition <<- function(cond) NULL
[09:32:29.543]                   }
[09:32:29.543]                 })
[09:32:29.543]                 withCallingHandlers({
[09:32:29.543]                   {
[09:32:29.543]                     Sys.sleep(0.5)
[09:32:29.543]                     list(a = 1, b = 42L)
[09:32:29.543]                   }
[09:32:29.543]                 }, immediateCondition = function(cond) {
[09:32:29.543]                   sendCondition <- ...future.makeSendCondition()
[09:32:29.543]                   sendCondition(cond)
[09:32:29.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.543]                   {
[09:32:29.543]                     inherits <- base::inherits
[09:32:29.543]                     invokeRestart <- base::invokeRestart
[09:32:29.543]                     is.null <- base::is.null
[09:32:29.543]                     muffled <- FALSE
[09:32:29.543]                     if (inherits(cond, "message")) {
[09:32:29.543]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:29.543]                       if (muffled) 
[09:32:29.543]                         invokeRestart("muffleMessage")
[09:32:29.543]                     }
[09:32:29.543]                     else if (inherits(cond, "warning")) {
[09:32:29.543]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:29.543]                       if (muffled) 
[09:32:29.543]                         invokeRestart("muffleWarning")
[09:32:29.543]                     }
[09:32:29.543]                     else if (inherits(cond, "condition")) {
[09:32:29.543]                       if (!is.null(pattern)) {
[09:32:29.543]                         computeRestarts <- base::computeRestarts
[09:32:29.543]                         grepl <- base::grepl
[09:32:29.543]                         restarts <- computeRestarts(cond)
[09:32:29.543]                         for (restart in restarts) {
[09:32:29.543]                           name <- restart$name
[09:32:29.543]                           if (is.null(name)) 
[09:32:29.543]                             next
[09:32:29.543]                           if (!grepl(pattern, name)) 
[09:32:29.543]                             next
[09:32:29.543]                           invokeRestart(restart)
[09:32:29.543]                           muffled <- TRUE
[09:32:29.543]                           break
[09:32:29.543]                         }
[09:32:29.543]                       }
[09:32:29.543]                     }
[09:32:29.543]                     invisible(muffled)
[09:32:29.543]                   }
[09:32:29.543]                   muffleCondition(cond)
[09:32:29.543]                 })
[09:32:29.543]             }))
[09:32:29.543]             future::FutureResult(value = ...future.value$value, 
[09:32:29.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.543]                   ...future.rng), globalenv = if (FALSE) 
[09:32:29.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:29.543]                     ...future.globalenv.names))
[09:32:29.543]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:29.543]         }, condition = base::local({
[09:32:29.543]             c <- base::c
[09:32:29.543]             inherits <- base::inherits
[09:32:29.543]             invokeRestart <- base::invokeRestart
[09:32:29.543]             length <- base::length
[09:32:29.543]             list <- base::list
[09:32:29.543]             seq.int <- base::seq.int
[09:32:29.543]             signalCondition <- base::signalCondition
[09:32:29.543]             sys.calls <- base::sys.calls
[09:32:29.543]             `[[` <- base::`[[`
[09:32:29.543]             `+` <- base::`+`
[09:32:29.543]             `<<-` <- base::`<<-`
[09:32:29.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:29.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:29.543]                   3L)]
[09:32:29.543]             }
[09:32:29.543]             function(cond) {
[09:32:29.543]                 is_error <- inherits(cond, "error")
[09:32:29.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:29.543]                   NULL)
[09:32:29.543]                 if (is_error) {
[09:32:29.543]                   sessionInformation <- function() {
[09:32:29.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:29.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:29.543]                       search = base::search(), system = base::Sys.info())
[09:32:29.543]                   }
[09:32:29.543]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:29.543]                     cond$call), session = sessionInformation(), 
[09:32:29.543]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:29.543]                   signalCondition(cond)
[09:32:29.543]                 }
[09:32:29.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:29.543]                 "immediateCondition"))) {
[09:32:29.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:29.543]                   ...future.conditions[[length(...future.conditions) + 
[09:32:29.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:29.543]                   if (TRUE && !signal) {
[09:32:29.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.543]                     {
[09:32:29.543]                       inherits <- base::inherits
[09:32:29.543]                       invokeRestart <- base::invokeRestart
[09:32:29.543]                       is.null <- base::is.null
[09:32:29.543]                       muffled <- FALSE
[09:32:29.543]                       if (inherits(cond, "message")) {
[09:32:29.543]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.543]                         if (muffled) 
[09:32:29.543]                           invokeRestart("muffleMessage")
[09:32:29.543]                       }
[09:32:29.543]                       else if (inherits(cond, "warning")) {
[09:32:29.543]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.543]                         if (muffled) 
[09:32:29.543]                           invokeRestart("muffleWarning")
[09:32:29.543]                       }
[09:32:29.543]                       else if (inherits(cond, "condition")) {
[09:32:29.543]                         if (!is.null(pattern)) {
[09:32:29.543]                           computeRestarts <- base::computeRestarts
[09:32:29.543]                           grepl <- base::grepl
[09:32:29.543]                           restarts <- computeRestarts(cond)
[09:32:29.543]                           for (restart in restarts) {
[09:32:29.543]                             name <- restart$name
[09:32:29.543]                             if (is.null(name)) 
[09:32:29.543]                               next
[09:32:29.543]                             if (!grepl(pattern, name)) 
[09:32:29.543]                               next
[09:32:29.543]                             invokeRestart(restart)
[09:32:29.543]                             muffled <- TRUE
[09:32:29.543]                             break
[09:32:29.543]                           }
[09:32:29.543]                         }
[09:32:29.543]                       }
[09:32:29.543]                       invisible(muffled)
[09:32:29.543]                     }
[09:32:29.543]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.543]                   }
[09:32:29.543]                 }
[09:32:29.543]                 else {
[09:32:29.543]                   if (TRUE) {
[09:32:29.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:29.543]                     {
[09:32:29.543]                       inherits <- base::inherits
[09:32:29.543]                       invokeRestart <- base::invokeRestart
[09:32:29.543]                       is.null <- base::is.null
[09:32:29.543]                       muffled <- FALSE
[09:32:29.543]                       if (inherits(cond, "message")) {
[09:32:29.543]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:29.543]                         if (muffled) 
[09:32:29.543]                           invokeRestart("muffleMessage")
[09:32:29.543]                       }
[09:32:29.543]                       else if (inherits(cond, "warning")) {
[09:32:29.543]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:29.543]                         if (muffled) 
[09:32:29.543]                           invokeRestart("muffleWarning")
[09:32:29.543]                       }
[09:32:29.543]                       else if (inherits(cond, "condition")) {
[09:32:29.543]                         if (!is.null(pattern)) {
[09:32:29.543]                           computeRestarts <- base::computeRestarts
[09:32:29.543]                           grepl <- base::grepl
[09:32:29.543]                           restarts <- computeRestarts(cond)
[09:32:29.543]                           for (restart in restarts) {
[09:32:29.543]                             name <- restart$name
[09:32:29.543]                             if (is.null(name)) 
[09:32:29.543]                               next
[09:32:29.543]                             if (!grepl(pattern, name)) 
[09:32:29.543]                               next
[09:32:29.543]                             invokeRestart(restart)
[09:32:29.543]                             muffled <- TRUE
[09:32:29.543]                             break
[09:32:29.543]                           }
[09:32:29.543]                         }
[09:32:29.543]                       }
[09:32:29.543]                       invisible(muffled)
[09:32:29.543]                     }
[09:32:29.543]                     muffleCondition(cond, pattern = "^muffle")
[09:32:29.543]                   }
[09:32:29.543]                 }
[09:32:29.543]             }
[09:32:29.543]         }))
[09:32:29.543]     }, error = function(ex) {
[09:32:29.543]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:29.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:29.543]                 ...future.rng), started = ...future.startTime, 
[09:32:29.543]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:29.543]             version = "1.8"), class = "FutureResult")
[09:32:29.543]     }, finally = {
[09:32:29.543]         if (!identical(...future.workdir, getwd())) 
[09:32:29.543]             setwd(...future.workdir)
[09:32:29.543]         {
[09:32:29.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:29.543]                 ...future.oldOptions$nwarnings <- NULL
[09:32:29.543]             }
[09:32:29.543]             base::options(...future.oldOptions)
[09:32:29.543]             if (.Platform$OS.type == "windows") {
[09:32:29.543]                 old_names <- names(...future.oldEnvVars)
[09:32:29.543]                 envs <- base::Sys.getenv()
[09:32:29.543]                 names <- names(envs)
[09:32:29.543]                 common <- intersect(names, old_names)
[09:32:29.543]                 added <- setdiff(names, old_names)
[09:32:29.543]                 removed <- setdiff(old_names, names)
[09:32:29.543]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:29.543]                   envs[common]]
[09:32:29.543]                 NAMES <- toupper(changed)
[09:32:29.543]                 args <- list()
[09:32:29.543]                 for (kk in seq_along(NAMES)) {
[09:32:29.543]                   name <- changed[[kk]]
[09:32:29.543]                   NAME <- NAMES[[kk]]
[09:32:29.543]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.543]                     next
[09:32:29.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.543]                 }
[09:32:29.543]                 NAMES <- toupper(added)
[09:32:29.543]                 for (kk in seq_along(NAMES)) {
[09:32:29.543]                   name <- added[[kk]]
[09:32:29.543]                   NAME <- NAMES[[kk]]
[09:32:29.543]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.543]                     next
[09:32:29.543]                   args[[name]] <- ""
[09:32:29.543]                 }
[09:32:29.543]                 NAMES <- toupper(removed)
[09:32:29.543]                 for (kk in seq_along(NAMES)) {
[09:32:29.543]                   name <- removed[[kk]]
[09:32:29.543]                   NAME <- NAMES[[kk]]
[09:32:29.543]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:29.543]                     next
[09:32:29.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:29.543]                 }
[09:32:29.543]                 if (length(args) > 0) 
[09:32:29.543]                   base::do.call(base::Sys.setenv, args = args)
[09:32:29.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:29.543]             }
[09:32:29.543]             else {
[09:32:29.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:29.543]             }
[09:32:29.543]             {
[09:32:29.543]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:29.543]                   0L) {
[09:32:29.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:29.543]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:29.543]                   base::options(opts)
[09:32:29.543]                 }
[09:32:29.543]                 {
[09:32:29.543]                   {
[09:32:29.543]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:29.543]                     NULL
[09:32:29.543]                   }
[09:32:29.543]                   options(future.plan = NULL)
[09:32:29.543]                   if (is.na(NA_character_)) 
[09:32:29.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:29.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:29.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:29.543]                     .init = FALSE)
[09:32:29.543]                 }
[09:32:29.543]             }
[09:32:29.543]         }
[09:32:29.543]     })
[09:32:29.543]     if (TRUE) {
[09:32:29.543]         base::sink(type = "output", split = FALSE)
[09:32:29.543]         if (TRUE) {
[09:32:29.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:29.543]         }
[09:32:29.543]         else {
[09:32:29.543]             ...future.result["stdout"] <- base::list(NULL)
[09:32:29.543]         }
[09:32:29.543]         base::close(...future.stdout)
[09:32:29.543]         ...future.stdout <- NULL
[09:32:29.543]     }
[09:32:29.543]     ...future.result$conditions <- ...future.conditions
[09:32:29.543]     ...future.result$finished <- base::Sys.time()
[09:32:29.543]     ...future.result
[09:32:29.543] }
[09:32:29.545] MultisessionFuture started
[09:32:29.546] - Launch lazy future ... done
[09:32:29.546] run() for ‘MultisessionFuture’ ... done
[09:32:30.048] receiveMessageFromWorker() for ClusterFuture ...
[09:32:30.048] - Validating connection of MultisessionFuture
[09:32:30.048] - received message: FutureResult
[09:32:30.048] - Received FutureResult
[09:32:30.048] - Erased future from FutureRegistry
[09:32:30.048] result() for ClusterFuture ...
[09:32:30.048] - result already collected: FutureResult
[09:32:30.049] result() for ClusterFuture ... done
[09:32:30.049] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:30.049] A MultisessionFuture was resolved
[09:32:30.049] getGlobalsAndPackages() ...
[09:32:30.049] Searching for globals...
[09:32:30.050] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:30.050] Searching for globals ... DONE
[09:32:30.050] Resolving globals: FALSE
[09:32:30.050] 
[09:32:30.051] 
[09:32:30.051] getGlobalsAndPackages() ... DONE
[09:32:30.051] run() for ‘Future’ ...
[09:32:30.051] - state: ‘created’
[09:32:30.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:30.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:30.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:30.065]   - Field: ‘node’
[09:32:30.065]   - Field: ‘label’
[09:32:30.065]   - Field: ‘local’
[09:32:30.065]   - Field: ‘owner’
[09:32:30.065]   - Field: ‘envir’
[09:32:30.065]   - Field: ‘workers’
[09:32:30.065]   - Field: ‘packages’
[09:32:30.066]   - Field: ‘gc’
[09:32:30.066]   - Field: ‘conditions’
[09:32:30.066]   - Field: ‘persistent’
[09:32:30.066]   - Field: ‘expr’
[09:32:30.066]   - Field: ‘uuid’
[09:32:30.066]   - Field: ‘seed’
[09:32:30.066]   - Field: ‘version’
[09:32:30.066]   - Field: ‘result’
[09:32:30.066]   - Field: ‘asynchronous’
[09:32:30.066]   - Field: ‘calls’
[09:32:30.066]   - Field: ‘globals’
[09:32:30.067]   - Field: ‘stdout’
[09:32:30.067]   - Field: ‘earlySignal’
[09:32:30.067]   - Field: ‘lazy’
[09:32:30.067]   - Field: ‘state’
[09:32:30.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:30.067] - Launch lazy future ...
[09:32:30.067] Packages needed by the future expression (n = 0): <none>
[09:32:30.067] Packages needed by future strategies (n = 0): <none>
[09:32:30.068] {
[09:32:30.068]     {
[09:32:30.068]         {
[09:32:30.068]             ...future.startTime <- base::Sys.time()
[09:32:30.068]             {
[09:32:30.068]                 {
[09:32:30.068]                   {
[09:32:30.068]                     {
[09:32:30.068]                       base::local({
[09:32:30.068]                         has_future <- base::requireNamespace("future", 
[09:32:30.068]                           quietly = TRUE)
[09:32:30.068]                         if (has_future) {
[09:32:30.068]                           ns <- base::getNamespace("future")
[09:32:30.068]                           version <- ns[[".package"]][["version"]]
[09:32:30.068]                           if (is.null(version)) 
[09:32:30.068]                             version <- utils::packageVersion("future")
[09:32:30.068]                         }
[09:32:30.068]                         else {
[09:32:30.068]                           version <- NULL
[09:32:30.068]                         }
[09:32:30.068]                         if (!has_future || version < "1.8.0") {
[09:32:30.068]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:30.068]                             "", base::R.version$version.string), 
[09:32:30.068]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:30.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:30.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:30.068]                               "release", "version")], collapse = " "), 
[09:32:30.068]                             hostname = base::Sys.info()[["nodename"]])
[09:32:30.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:30.068]                             info)
[09:32:30.068]                           info <- base::paste(info, collapse = "; ")
[09:32:30.068]                           if (!has_future) {
[09:32:30.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:30.068]                               info)
[09:32:30.068]                           }
[09:32:30.068]                           else {
[09:32:30.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:30.068]                               info, version)
[09:32:30.068]                           }
[09:32:30.068]                           base::stop(msg)
[09:32:30.068]                         }
[09:32:30.068]                       })
[09:32:30.068]                     }
[09:32:30.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:30.068]                     base::options(mc.cores = 1L)
[09:32:30.068]                   }
[09:32:30.068]                   ...future.strategy.old <- future::plan("list")
[09:32:30.068]                   options(future.plan = NULL)
[09:32:30.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:30.068]                 }
[09:32:30.068]                 ...future.workdir <- getwd()
[09:32:30.068]             }
[09:32:30.068]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:30.068]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:30.068]         }
[09:32:30.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:30.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:30.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:30.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:30.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:30.068]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:30.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:30.068]             base::names(...future.oldOptions))
[09:32:30.068]     }
[09:32:30.068]     if (FALSE) {
[09:32:30.068]     }
[09:32:30.068]     else {
[09:32:30.068]         if (TRUE) {
[09:32:30.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:30.068]                 open = "w")
[09:32:30.068]         }
[09:32:30.068]         else {
[09:32:30.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:30.068]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:30.068]         }
[09:32:30.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:30.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:30.068]             base::sink(type = "output", split = FALSE)
[09:32:30.068]             base::close(...future.stdout)
[09:32:30.068]         }, add = TRUE)
[09:32:30.068]     }
[09:32:30.068]     ...future.frame <- base::sys.nframe()
[09:32:30.068]     ...future.conditions <- base::list()
[09:32:30.068]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:30.068]     if (FALSE) {
[09:32:30.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:30.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:30.068]     }
[09:32:30.068]     ...future.result <- base::tryCatch({
[09:32:30.068]         base::withCallingHandlers({
[09:32:30.068]             ...future.value <- base::withVisible(base::local({
[09:32:30.068]                 ...future.makeSendCondition <- base::local({
[09:32:30.068]                   sendCondition <- NULL
[09:32:30.068]                   function(frame = 1L) {
[09:32:30.068]                     if (is.function(sendCondition)) 
[09:32:30.068]                       return(sendCondition)
[09:32:30.068]                     ns <- getNamespace("parallel")
[09:32:30.068]                     if (exists("sendData", mode = "function", 
[09:32:30.068]                       envir = ns)) {
[09:32:30.068]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:30.068]                         envir = ns)
[09:32:30.068]                       envir <- sys.frame(frame)
[09:32:30.068]                       master <- NULL
[09:32:30.068]                       while (!identical(envir, .GlobalEnv) && 
[09:32:30.068]                         !identical(envir, emptyenv())) {
[09:32:30.068]                         if (exists("master", mode = "list", envir = envir, 
[09:32:30.068]                           inherits = FALSE)) {
[09:32:30.068]                           master <- get("master", mode = "list", 
[09:32:30.068]                             envir = envir, inherits = FALSE)
[09:32:30.068]                           if (inherits(master, c("SOCKnode", 
[09:32:30.068]                             "SOCK0node"))) {
[09:32:30.068]                             sendCondition <<- function(cond) {
[09:32:30.068]                               data <- list(type = "VALUE", value = cond, 
[09:32:30.068]                                 success = TRUE)
[09:32:30.068]                               parallel_sendData(master, data)
[09:32:30.068]                             }
[09:32:30.068]                             return(sendCondition)
[09:32:30.068]                           }
[09:32:30.068]                         }
[09:32:30.068]                         frame <- frame + 1L
[09:32:30.068]                         envir <- sys.frame(frame)
[09:32:30.068]                       }
[09:32:30.068]                     }
[09:32:30.068]                     sendCondition <<- function(cond) NULL
[09:32:30.068]                   }
[09:32:30.068]                 })
[09:32:30.068]                 withCallingHandlers({
[09:32:30.068]                   {
[09:32:30.068]                     Sys.sleep(0.5)
[09:32:30.068]                     list(a = 1, b = 42L)
[09:32:30.068]                   }
[09:32:30.068]                 }, immediateCondition = function(cond) {
[09:32:30.068]                   sendCondition <- ...future.makeSendCondition()
[09:32:30.068]                   sendCondition(cond)
[09:32:30.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.068]                   {
[09:32:30.068]                     inherits <- base::inherits
[09:32:30.068]                     invokeRestart <- base::invokeRestart
[09:32:30.068]                     is.null <- base::is.null
[09:32:30.068]                     muffled <- FALSE
[09:32:30.068]                     if (inherits(cond, "message")) {
[09:32:30.068]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:30.068]                       if (muffled) 
[09:32:30.068]                         invokeRestart("muffleMessage")
[09:32:30.068]                     }
[09:32:30.068]                     else if (inherits(cond, "warning")) {
[09:32:30.068]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:30.068]                       if (muffled) 
[09:32:30.068]                         invokeRestart("muffleWarning")
[09:32:30.068]                     }
[09:32:30.068]                     else if (inherits(cond, "condition")) {
[09:32:30.068]                       if (!is.null(pattern)) {
[09:32:30.068]                         computeRestarts <- base::computeRestarts
[09:32:30.068]                         grepl <- base::grepl
[09:32:30.068]                         restarts <- computeRestarts(cond)
[09:32:30.068]                         for (restart in restarts) {
[09:32:30.068]                           name <- restart$name
[09:32:30.068]                           if (is.null(name)) 
[09:32:30.068]                             next
[09:32:30.068]                           if (!grepl(pattern, name)) 
[09:32:30.068]                             next
[09:32:30.068]                           invokeRestart(restart)
[09:32:30.068]                           muffled <- TRUE
[09:32:30.068]                           break
[09:32:30.068]                         }
[09:32:30.068]                       }
[09:32:30.068]                     }
[09:32:30.068]                     invisible(muffled)
[09:32:30.068]                   }
[09:32:30.068]                   muffleCondition(cond)
[09:32:30.068]                 })
[09:32:30.068]             }))
[09:32:30.068]             future::FutureResult(value = ...future.value$value, 
[09:32:30.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.068]                   ...future.rng), globalenv = if (FALSE) 
[09:32:30.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:30.068]                     ...future.globalenv.names))
[09:32:30.068]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:30.068]         }, condition = base::local({
[09:32:30.068]             c <- base::c
[09:32:30.068]             inherits <- base::inherits
[09:32:30.068]             invokeRestart <- base::invokeRestart
[09:32:30.068]             length <- base::length
[09:32:30.068]             list <- base::list
[09:32:30.068]             seq.int <- base::seq.int
[09:32:30.068]             signalCondition <- base::signalCondition
[09:32:30.068]             sys.calls <- base::sys.calls
[09:32:30.068]             `[[` <- base::`[[`
[09:32:30.068]             `+` <- base::`+`
[09:32:30.068]             `<<-` <- base::`<<-`
[09:32:30.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:30.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:30.068]                   3L)]
[09:32:30.068]             }
[09:32:30.068]             function(cond) {
[09:32:30.068]                 is_error <- inherits(cond, "error")
[09:32:30.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:30.068]                   NULL)
[09:32:30.068]                 if (is_error) {
[09:32:30.068]                   sessionInformation <- function() {
[09:32:30.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:30.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:30.068]                       search = base::search(), system = base::Sys.info())
[09:32:30.068]                   }
[09:32:30.068]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:30.068]                     cond$call), session = sessionInformation(), 
[09:32:30.068]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:30.068]                   signalCondition(cond)
[09:32:30.068]                 }
[09:32:30.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:30.068]                 "immediateCondition"))) {
[09:32:30.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:30.068]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:30.068]                   if (TRUE && !signal) {
[09:32:30.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.068]                     {
[09:32:30.068]                       inherits <- base::inherits
[09:32:30.068]                       invokeRestart <- base::invokeRestart
[09:32:30.068]                       is.null <- base::is.null
[09:32:30.068]                       muffled <- FALSE
[09:32:30.068]                       if (inherits(cond, "message")) {
[09:32:30.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.068]                         if (muffled) 
[09:32:30.068]                           invokeRestart("muffleMessage")
[09:32:30.068]                       }
[09:32:30.068]                       else if (inherits(cond, "warning")) {
[09:32:30.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.068]                         if (muffled) 
[09:32:30.068]                           invokeRestart("muffleWarning")
[09:32:30.068]                       }
[09:32:30.068]                       else if (inherits(cond, "condition")) {
[09:32:30.068]                         if (!is.null(pattern)) {
[09:32:30.068]                           computeRestarts <- base::computeRestarts
[09:32:30.068]                           grepl <- base::grepl
[09:32:30.068]                           restarts <- computeRestarts(cond)
[09:32:30.068]                           for (restart in restarts) {
[09:32:30.068]                             name <- restart$name
[09:32:30.068]                             if (is.null(name)) 
[09:32:30.068]                               next
[09:32:30.068]                             if (!grepl(pattern, name)) 
[09:32:30.068]                               next
[09:32:30.068]                             invokeRestart(restart)
[09:32:30.068]                             muffled <- TRUE
[09:32:30.068]                             break
[09:32:30.068]                           }
[09:32:30.068]                         }
[09:32:30.068]                       }
[09:32:30.068]                       invisible(muffled)
[09:32:30.068]                     }
[09:32:30.068]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.068]                   }
[09:32:30.068]                 }
[09:32:30.068]                 else {
[09:32:30.068]                   if (TRUE) {
[09:32:30.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.068]                     {
[09:32:30.068]                       inherits <- base::inherits
[09:32:30.068]                       invokeRestart <- base::invokeRestart
[09:32:30.068]                       is.null <- base::is.null
[09:32:30.068]                       muffled <- FALSE
[09:32:30.068]                       if (inherits(cond, "message")) {
[09:32:30.068]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.068]                         if (muffled) 
[09:32:30.068]                           invokeRestart("muffleMessage")
[09:32:30.068]                       }
[09:32:30.068]                       else if (inherits(cond, "warning")) {
[09:32:30.068]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.068]                         if (muffled) 
[09:32:30.068]                           invokeRestart("muffleWarning")
[09:32:30.068]                       }
[09:32:30.068]                       else if (inherits(cond, "condition")) {
[09:32:30.068]                         if (!is.null(pattern)) {
[09:32:30.068]                           computeRestarts <- base::computeRestarts
[09:32:30.068]                           grepl <- base::grepl
[09:32:30.068]                           restarts <- computeRestarts(cond)
[09:32:30.068]                           for (restart in restarts) {
[09:32:30.068]                             name <- restart$name
[09:32:30.068]                             if (is.null(name)) 
[09:32:30.068]                               next
[09:32:30.068]                             if (!grepl(pattern, name)) 
[09:32:30.068]                               next
[09:32:30.068]                             invokeRestart(restart)
[09:32:30.068]                             muffled <- TRUE
[09:32:30.068]                             break
[09:32:30.068]                           }
[09:32:30.068]                         }
[09:32:30.068]                       }
[09:32:30.068]                       invisible(muffled)
[09:32:30.068]                     }
[09:32:30.068]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.068]                   }
[09:32:30.068]                 }
[09:32:30.068]             }
[09:32:30.068]         }))
[09:32:30.068]     }, error = function(ex) {
[09:32:30.068]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:30.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.068]                 ...future.rng), started = ...future.startTime, 
[09:32:30.068]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:30.068]             version = "1.8"), class = "FutureResult")
[09:32:30.068]     }, finally = {
[09:32:30.068]         if (!identical(...future.workdir, getwd())) 
[09:32:30.068]             setwd(...future.workdir)
[09:32:30.068]         {
[09:32:30.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:30.068]                 ...future.oldOptions$nwarnings <- NULL
[09:32:30.068]             }
[09:32:30.068]             base::options(...future.oldOptions)
[09:32:30.068]             if (.Platform$OS.type == "windows") {
[09:32:30.068]                 old_names <- names(...future.oldEnvVars)
[09:32:30.068]                 envs <- base::Sys.getenv()
[09:32:30.068]                 names <- names(envs)
[09:32:30.068]                 common <- intersect(names, old_names)
[09:32:30.068]                 added <- setdiff(names, old_names)
[09:32:30.068]                 removed <- setdiff(old_names, names)
[09:32:30.068]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:30.068]                   envs[common]]
[09:32:30.068]                 NAMES <- toupper(changed)
[09:32:30.068]                 args <- list()
[09:32:30.068]                 for (kk in seq_along(NAMES)) {
[09:32:30.068]                   name <- changed[[kk]]
[09:32:30.068]                   NAME <- NAMES[[kk]]
[09:32:30.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.068]                     next
[09:32:30.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.068]                 }
[09:32:30.068]                 NAMES <- toupper(added)
[09:32:30.068]                 for (kk in seq_along(NAMES)) {
[09:32:30.068]                   name <- added[[kk]]
[09:32:30.068]                   NAME <- NAMES[[kk]]
[09:32:30.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.068]                     next
[09:32:30.068]                   args[[name]] <- ""
[09:32:30.068]                 }
[09:32:30.068]                 NAMES <- toupper(removed)
[09:32:30.068]                 for (kk in seq_along(NAMES)) {
[09:32:30.068]                   name <- removed[[kk]]
[09:32:30.068]                   NAME <- NAMES[[kk]]
[09:32:30.068]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.068]                     next
[09:32:30.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.068]                 }
[09:32:30.068]                 if (length(args) > 0) 
[09:32:30.068]                   base::do.call(base::Sys.setenv, args = args)
[09:32:30.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:30.068]             }
[09:32:30.068]             else {
[09:32:30.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:30.068]             }
[09:32:30.068]             {
[09:32:30.068]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:30.068]                   0L) {
[09:32:30.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:30.068]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:30.068]                   base::options(opts)
[09:32:30.068]                 }
[09:32:30.068]                 {
[09:32:30.068]                   {
[09:32:30.068]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:30.068]                     NULL
[09:32:30.068]                   }
[09:32:30.068]                   options(future.plan = NULL)
[09:32:30.068]                   if (is.na(NA_character_)) 
[09:32:30.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:30.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:30.068]                     .init = FALSE)
[09:32:30.068]                 }
[09:32:30.068]             }
[09:32:30.068]         }
[09:32:30.068]     })
[09:32:30.068]     if (TRUE) {
[09:32:30.068]         base::sink(type = "output", split = FALSE)
[09:32:30.068]         if (TRUE) {
[09:32:30.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:30.068]         }
[09:32:30.068]         else {
[09:32:30.068]             ...future.result["stdout"] <- base::list(NULL)
[09:32:30.068]         }
[09:32:30.068]         base::close(...future.stdout)
[09:32:30.068]         ...future.stdout <- NULL
[09:32:30.068]     }
[09:32:30.068]     ...future.result$conditions <- ...future.conditions
[09:32:30.068]     ...future.result$finished <- base::Sys.time()
[09:32:30.068]     ...future.result
[09:32:30.068] }
[09:32:30.071] MultisessionFuture started
[09:32:30.071] - Launch lazy future ... done
[09:32:30.071] run() for ‘MultisessionFuture’ ... done
[09:32:30.573] receiveMessageFromWorker() for ClusterFuture ...
[09:32:30.574] - Validating connection of MultisessionFuture
[09:32:30.574] - received message: FutureResult
[09:32:30.574] - Received FutureResult
[09:32:30.574] - Erased future from FutureRegistry
[09:32:30.574] result() for ClusterFuture ...
[09:32:30.574] - result already collected: FutureResult
[09:32:30.574] result() for ClusterFuture ... done
[09:32:30.574] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:30.574] A MultisessionFuture was resolved
- w/ exception ...
[09:32:30.575] getGlobalsAndPackages() ...
[09:32:30.575] Searching for globals...
[09:32:30.575] - globals found: [2] ‘list’, ‘stop’
[09:32:30.575] Searching for globals ... DONE
[09:32:30.576] Resolving globals: FALSE
[09:32:30.576] 
[09:32:30.576] 
[09:32:30.576] getGlobalsAndPackages() ... DONE
[09:32:30.576] run() for ‘Future’ ...
[09:32:30.576] - state: ‘created’
[09:32:30.577] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:30.590] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:30.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:30.591]   - Field: ‘node’
[09:32:30.591]   - Field: ‘label’
[09:32:30.591]   - Field: ‘local’
[09:32:30.591]   - Field: ‘owner’
[09:32:30.591]   - Field: ‘envir’
[09:32:30.591]   - Field: ‘workers’
[09:32:30.591]   - Field: ‘packages’
[09:32:30.591]   - Field: ‘gc’
[09:32:30.591]   - Field: ‘conditions’
[09:32:30.591]   - Field: ‘persistent’
[09:32:30.592]   - Field: ‘expr’
[09:32:30.592]   - Field: ‘uuid’
[09:32:30.592]   - Field: ‘seed’
[09:32:30.592]   - Field: ‘version’
[09:32:30.592]   - Field: ‘result’
[09:32:30.592]   - Field: ‘asynchronous’
[09:32:30.592]   - Field: ‘calls’
[09:32:30.592]   - Field: ‘globals’
[09:32:30.592]   - Field: ‘stdout’
[09:32:30.592]   - Field: ‘earlySignal’
[09:32:30.593]   - Field: ‘lazy’
[09:32:30.593]   - Field: ‘state’
[09:32:30.593] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:30.593] - Launch lazy future ...
[09:32:30.593] Packages needed by the future expression (n = 0): <none>
[09:32:30.593] Packages needed by future strategies (n = 0): <none>
[09:32:30.594] {
[09:32:30.594]     {
[09:32:30.594]         {
[09:32:30.594]             ...future.startTime <- base::Sys.time()
[09:32:30.594]             {
[09:32:30.594]                 {
[09:32:30.594]                   {
[09:32:30.594]                     {
[09:32:30.594]                       base::local({
[09:32:30.594]                         has_future <- base::requireNamespace("future", 
[09:32:30.594]                           quietly = TRUE)
[09:32:30.594]                         if (has_future) {
[09:32:30.594]                           ns <- base::getNamespace("future")
[09:32:30.594]                           version <- ns[[".package"]][["version"]]
[09:32:30.594]                           if (is.null(version)) 
[09:32:30.594]                             version <- utils::packageVersion("future")
[09:32:30.594]                         }
[09:32:30.594]                         else {
[09:32:30.594]                           version <- NULL
[09:32:30.594]                         }
[09:32:30.594]                         if (!has_future || version < "1.8.0") {
[09:32:30.594]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:30.594]                             "", base::R.version$version.string), 
[09:32:30.594]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:30.594]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:30.594]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:30.594]                               "release", "version")], collapse = " "), 
[09:32:30.594]                             hostname = base::Sys.info()[["nodename"]])
[09:32:30.594]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:30.594]                             info)
[09:32:30.594]                           info <- base::paste(info, collapse = "; ")
[09:32:30.594]                           if (!has_future) {
[09:32:30.594]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:30.594]                               info)
[09:32:30.594]                           }
[09:32:30.594]                           else {
[09:32:30.594]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:30.594]                               info, version)
[09:32:30.594]                           }
[09:32:30.594]                           base::stop(msg)
[09:32:30.594]                         }
[09:32:30.594]                       })
[09:32:30.594]                     }
[09:32:30.594]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:30.594]                     base::options(mc.cores = 1L)
[09:32:30.594]                   }
[09:32:30.594]                   ...future.strategy.old <- future::plan("list")
[09:32:30.594]                   options(future.plan = NULL)
[09:32:30.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:30.594]                 }
[09:32:30.594]                 ...future.workdir <- getwd()
[09:32:30.594]             }
[09:32:30.594]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:30.594]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:30.594]         }
[09:32:30.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:30.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:30.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:30.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:30.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:30.594]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:30.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:30.594]             base::names(...future.oldOptions))
[09:32:30.594]     }
[09:32:30.594]     if (FALSE) {
[09:32:30.594]     }
[09:32:30.594]     else {
[09:32:30.594]         if (TRUE) {
[09:32:30.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:30.594]                 open = "w")
[09:32:30.594]         }
[09:32:30.594]         else {
[09:32:30.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:30.594]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:30.594]         }
[09:32:30.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:30.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:30.594]             base::sink(type = "output", split = FALSE)
[09:32:30.594]             base::close(...future.stdout)
[09:32:30.594]         }, add = TRUE)
[09:32:30.594]     }
[09:32:30.594]     ...future.frame <- base::sys.nframe()
[09:32:30.594]     ...future.conditions <- base::list()
[09:32:30.594]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:30.594]     if (FALSE) {
[09:32:30.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:30.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:30.594]     }
[09:32:30.594]     ...future.result <- base::tryCatch({
[09:32:30.594]         base::withCallingHandlers({
[09:32:30.594]             ...future.value <- base::withVisible(base::local({
[09:32:30.594]                 ...future.makeSendCondition <- base::local({
[09:32:30.594]                   sendCondition <- NULL
[09:32:30.594]                   function(frame = 1L) {
[09:32:30.594]                     if (is.function(sendCondition)) 
[09:32:30.594]                       return(sendCondition)
[09:32:30.594]                     ns <- getNamespace("parallel")
[09:32:30.594]                     if (exists("sendData", mode = "function", 
[09:32:30.594]                       envir = ns)) {
[09:32:30.594]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:30.594]                         envir = ns)
[09:32:30.594]                       envir <- sys.frame(frame)
[09:32:30.594]                       master <- NULL
[09:32:30.594]                       while (!identical(envir, .GlobalEnv) && 
[09:32:30.594]                         !identical(envir, emptyenv())) {
[09:32:30.594]                         if (exists("master", mode = "list", envir = envir, 
[09:32:30.594]                           inherits = FALSE)) {
[09:32:30.594]                           master <- get("master", mode = "list", 
[09:32:30.594]                             envir = envir, inherits = FALSE)
[09:32:30.594]                           if (inherits(master, c("SOCKnode", 
[09:32:30.594]                             "SOCK0node"))) {
[09:32:30.594]                             sendCondition <<- function(cond) {
[09:32:30.594]                               data <- list(type = "VALUE", value = cond, 
[09:32:30.594]                                 success = TRUE)
[09:32:30.594]                               parallel_sendData(master, data)
[09:32:30.594]                             }
[09:32:30.594]                             return(sendCondition)
[09:32:30.594]                           }
[09:32:30.594]                         }
[09:32:30.594]                         frame <- frame + 1L
[09:32:30.594]                         envir <- sys.frame(frame)
[09:32:30.594]                       }
[09:32:30.594]                     }
[09:32:30.594]                     sendCondition <<- function(cond) NULL
[09:32:30.594]                   }
[09:32:30.594]                 })
[09:32:30.594]                 withCallingHandlers({
[09:32:30.594]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:30.594]                 }, immediateCondition = function(cond) {
[09:32:30.594]                   sendCondition <- ...future.makeSendCondition()
[09:32:30.594]                   sendCondition(cond)
[09:32:30.594]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.594]                   {
[09:32:30.594]                     inherits <- base::inherits
[09:32:30.594]                     invokeRestart <- base::invokeRestart
[09:32:30.594]                     is.null <- base::is.null
[09:32:30.594]                     muffled <- FALSE
[09:32:30.594]                     if (inherits(cond, "message")) {
[09:32:30.594]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:30.594]                       if (muffled) 
[09:32:30.594]                         invokeRestart("muffleMessage")
[09:32:30.594]                     }
[09:32:30.594]                     else if (inherits(cond, "warning")) {
[09:32:30.594]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:30.594]                       if (muffled) 
[09:32:30.594]                         invokeRestart("muffleWarning")
[09:32:30.594]                     }
[09:32:30.594]                     else if (inherits(cond, "condition")) {
[09:32:30.594]                       if (!is.null(pattern)) {
[09:32:30.594]                         computeRestarts <- base::computeRestarts
[09:32:30.594]                         grepl <- base::grepl
[09:32:30.594]                         restarts <- computeRestarts(cond)
[09:32:30.594]                         for (restart in restarts) {
[09:32:30.594]                           name <- restart$name
[09:32:30.594]                           if (is.null(name)) 
[09:32:30.594]                             next
[09:32:30.594]                           if (!grepl(pattern, name)) 
[09:32:30.594]                             next
[09:32:30.594]                           invokeRestart(restart)
[09:32:30.594]                           muffled <- TRUE
[09:32:30.594]                           break
[09:32:30.594]                         }
[09:32:30.594]                       }
[09:32:30.594]                     }
[09:32:30.594]                     invisible(muffled)
[09:32:30.594]                   }
[09:32:30.594]                   muffleCondition(cond)
[09:32:30.594]                 })
[09:32:30.594]             }))
[09:32:30.594]             future::FutureResult(value = ...future.value$value, 
[09:32:30.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.594]                   ...future.rng), globalenv = if (FALSE) 
[09:32:30.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:30.594]                     ...future.globalenv.names))
[09:32:30.594]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:30.594]         }, condition = base::local({
[09:32:30.594]             c <- base::c
[09:32:30.594]             inherits <- base::inherits
[09:32:30.594]             invokeRestart <- base::invokeRestart
[09:32:30.594]             length <- base::length
[09:32:30.594]             list <- base::list
[09:32:30.594]             seq.int <- base::seq.int
[09:32:30.594]             signalCondition <- base::signalCondition
[09:32:30.594]             sys.calls <- base::sys.calls
[09:32:30.594]             `[[` <- base::`[[`
[09:32:30.594]             `+` <- base::`+`
[09:32:30.594]             `<<-` <- base::`<<-`
[09:32:30.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:30.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:30.594]                   3L)]
[09:32:30.594]             }
[09:32:30.594]             function(cond) {
[09:32:30.594]                 is_error <- inherits(cond, "error")
[09:32:30.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:30.594]                   NULL)
[09:32:30.594]                 if (is_error) {
[09:32:30.594]                   sessionInformation <- function() {
[09:32:30.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:30.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:30.594]                       search = base::search(), system = base::Sys.info())
[09:32:30.594]                   }
[09:32:30.594]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:30.594]                     cond$call), session = sessionInformation(), 
[09:32:30.594]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:30.594]                   signalCondition(cond)
[09:32:30.594]                 }
[09:32:30.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:30.594]                 "immediateCondition"))) {
[09:32:30.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:30.594]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:30.594]                   if (TRUE && !signal) {
[09:32:30.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.594]                     {
[09:32:30.594]                       inherits <- base::inherits
[09:32:30.594]                       invokeRestart <- base::invokeRestart
[09:32:30.594]                       is.null <- base::is.null
[09:32:30.594]                       muffled <- FALSE
[09:32:30.594]                       if (inherits(cond, "message")) {
[09:32:30.594]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.594]                         if (muffled) 
[09:32:30.594]                           invokeRestart("muffleMessage")
[09:32:30.594]                       }
[09:32:30.594]                       else if (inherits(cond, "warning")) {
[09:32:30.594]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.594]                         if (muffled) 
[09:32:30.594]                           invokeRestart("muffleWarning")
[09:32:30.594]                       }
[09:32:30.594]                       else if (inherits(cond, "condition")) {
[09:32:30.594]                         if (!is.null(pattern)) {
[09:32:30.594]                           computeRestarts <- base::computeRestarts
[09:32:30.594]                           grepl <- base::grepl
[09:32:30.594]                           restarts <- computeRestarts(cond)
[09:32:30.594]                           for (restart in restarts) {
[09:32:30.594]                             name <- restart$name
[09:32:30.594]                             if (is.null(name)) 
[09:32:30.594]                               next
[09:32:30.594]                             if (!grepl(pattern, name)) 
[09:32:30.594]                               next
[09:32:30.594]                             invokeRestart(restart)
[09:32:30.594]                             muffled <- TRUE
[09:32:30.594]                             break
[09:32:30.594]                           }
[09:32:30.594]                         }
[09:32:30.594]                       }
[09:32:30.594]                       invisible(muffled)
[09:32:30.594]                     }
[09:32:30.594]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.594]                   }
[09:32:30.594]                 }
[09:32:30.594]                 else {
[09:32:30.594]                   if (TRUE) {
[09:32:30.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.594]                     {
[09:32:30.594]                       inherits <- base::inherits
[09:32:30.594]                       invokeRestart <- base::invokeRestart
[09:32:30.594]                       is.null <- base::is.null
[09:32:30.594]                       muffled <- FALSE
[09:32:30.594]                       if (inherits(cond, "message")) {
[09:32:30.594]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.594]                         if (muffled) 
[09:32:30.594]                           invokeRestart("muffleMessage")
[09:32:30.594]                       }
[09:32:30.594]                       else if (inherits(cond, "warning")) {
[09:32:30.594]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.594]                         if (muffled) 
[09:32:30.594]                           invokeRestart("muffleWarning")
[09:32:30.594]                       }
[09:32:30.594]                       else if (inherits(cond, "condition")) {
[09:32:30.594]                         if (!is.null(pattern)) {
[09:32:30.594]                           computeRestarts <- base::computeRestarts
[09:32:30.594]                           grepl <- base::grepl
[09:32:30.594]                           restarts <- computeRestarts(cond)
[09:32:30.594]                           for (restart in restarts) {
[09:32:30.594]                             name <- restart$name
[09:32:30.594]                             if (is.null(name)) 
[09:32:30.594]                               next
[09:32:30.594]                             if (!grepl(pattern, name)) 
[09:32:30.594]                               next
[09:32:30.594]                             invokeRestart(restart)
[09:32:30.594]                             muffled <- TRUE
[09:32:30.594]                             break
[09:32:30.594]                           }
[09:32:30.594]                         }
[09:32:30.594]                       }
[09:32:30.594]                       invisible(muffled)
[09:32:30.594]                     }
[09:32:30.594]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.594]                   }
[09:32:30.594]                 }
[09:32:30.594]             }
[09:32:30.594]         }))
[09:32:30.594]     }, error = function(ex) {
[09:32:30.594]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:30.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.594]                 ...future.rng), started = ...future.startTime, 
[09:32:30.594]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:30.594]             version = "1.8"), class = "FutureResult")
[09:32:30.594]     }, finally = {
[09:32:30.594]         if (!identical(...future.workdir, getwd())) 
[09:32:30.594]             setwd(...future.workdir)
[09:32:30.594]         {
[09:32:30.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:30.594]                 ...future.oldOptions$nwarnings <- NULL
[09:32:30.594]             }
[09:32:30.594]             base::options(...future.oldOptions)
[09:32:30.594]             if (.Platform$OS.type == "windows") {
[09:32:30.594]                 old_names <- names(...future.oldEnvVars)
[09:32:30.594]                 envs <- base::Sys.getenv()
[09:32:30.594]                 names <- names(envs)
[09:32:30.594]                 common <- intersect(names, old_names)
[09:32:30.594]                 added <- setdiff(names, old_names)
[09:32:30.594]                 removed <- setdiff(old_names, names)
[09:32:30.594]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:30.594]                   envs[common]]
[09:32:30.594]                 NAMES <- toupper(changed)
[09:32:30.594]                 args <- list()
[09:32:30.594]                 for (kk in seq_along(NAMES)) {
[09:32:30.594]                   name <- changed[[kk]]
[09:32:30.594]                   NAME <- NAMES[[kk]]
[09:32:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.594]                     next
[09:32:30.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.594]                 }
[09:32:30.594]                 NAMES <- toupper(added)
[09:32:30.594]                 for (kk in seq_along(NAMES)) {
[09:32:30.594]                   name <- added[[kk]]
[09:32:30.594]                   NAME <- NAMES[[kk]]
[09:32:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.594]                     next
[09:32:30.594]                   args[[name]] <- ""
[09:32:30.594]                 }
[09:32:30.594]                 NAMES <- toupper(removed)
[09:32:30.594]                 for (kk in seq_along(NAMES)) {
[09:32:30.594]                   name <- removed[[kk]]
[09:32:30.594]                   NAME <- NAMES[[kk]]
[09:32:30.594]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.594]                     next
[09:32:30.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.594]                 }
[09:32:30.594]                 if (length(args) > 0) 
[09:32:30.594]                   base::do.call(base::Sys.setenv, args = args)
[09:32:30.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:30.594]             }
[09:32:30.594]             else {
[09:32:30.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:30.594]             }
[09:32:30.594]             {
[09:32:30.594]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:30.594]                   0L) {
[09:32:30.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:30.594]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:30.594]                   base::options(opts)
[09:32:30.594]                 }
[09:32:30.594]                 {
[09:32:30.594]                   {
[09:32:30.594]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:30.594]                     NULL
[09:32:30.594]                   }
[09:32:30.594]                   options(future.plan = NULL)
[09:32:30.594]                   if (is.na(NA_character_)) 
[09:32:30.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:30.594]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:30.594]                     .init = FALSE)
[09:32:30.594]                 }
[09:32:30.594]             }
[09:32:30.594]         }
[09:32:30.594]     })
[09:32:30.594]     if (TRUE) {
[09:32:30.594]         base::sink(type = "output", split = FALSE)
[09:32:30.594]         if (TRUE) {
[09:32:30.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:30.594]         }
[09:32:30.594]         else {
[09:32:30.594]             ...future.result["stdout"] <- base::list(NULL)
[09:32:30.594]         }
[09:32:30.594]         base::close(...future.stdout)
[09:32:30.594]         ...future.stdout <- NULL
[09:32:30.594]     }
[09:32:30.594]     ...future.result$conditions <- ...future.conditions
[09:32:30.594]     ...future.result$finished <- base::Sys.time()
[09:32:30.594]     ...future.result
[09:32:30.594] }
[09:32:30.596] MultisessionFuture started
[09:32:30.597] - Launch lazy future ... done
[09:32:30.597] run() for ‘MultisessionFuture’ ... done
[09:32:30.598] receiveMessageFromWorker() for ClusterFuture ...
[09:32:30.598] - Validating connection of MultisessionFuture
[09:32:30.599] - received message: FutureResult
[09:32:30.599] - Received FutureResult
[09:32:30.599] - Erased future from FutureRegistry
[09:32:30.599] result() for ClusterFuture ...
[09:32:30.599] - result already collected: FutureResult
[09:32:30.599] result() for ClusterFuture ... done
[09:32:30.599] signalConditions() ...
[09:32:30.599]  - include = ‘immediateCondition’
[09:32:30.599]  - exclude = 
[09:32:30.599]  - resignal = FALSE
[09:32:30.600]  - Number of conditions: 1
[09:32:30.600] signalConditions() ... done
[09:32:30.600] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:30.600] A MultisessionFuture was resolved
[09:32:30.600] getGlobalsAndPackages() ...
[09:32:30.600] Searching for globals...
[09:32:30.601] - globals found: [2] ‘list’, ‘stop’
[09:32:30.601] Searching for globals ... DONE
[09:32:30.601] Resolving globals: FALSE
[09:32:30.601] 
[09:32:30.601] 
[09:32:30.601] getGlobalsAndPackages() ... DONE
[09:32:30.602] run() for ‘Future’ ...
[09:32:30.602] - state: ‘created’
[09:32:30.602] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:30.615] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:30.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:30.615]   - Field: ‘node’
[09:32:30.615]   - Field: ‘label’
[09:32:30.615]   - Field: ‘local’
[09:32:30.616]   - Field: ‘owner’
[09:32:30.616]   - Field: ‘envir’
[09:32:30.616]   - Field: ‘workers’
[09:32:30.616]   - Field: ‘packages’
[09:32:30.616]   - Field: ‘gc’
[09:32:30.616]   - Field: ‘conditions’
[09:32:30.616]   - Field: ‘persistent’
[09:32:30.616]   - Field: ‘expr’
[09:32:30.616]   - Field: ‘uuid’
[09:32:30.616]   - Field: ‘seed’
[09:32:30.616]   - Field: ‘version’
[09:32:30.617]   - Field: ‘result’
[09:32:30.617]   - Field: ‘asynchronous’
[09:32:30.617]   - Field: ‘calls’
[09:32:30.617]   - Field: ‘globals’
[09:32:30.617]   - Field: ‘stdout’
[09:32:30.617]   - Field: ‘earlySignal’
[09:32:30.617]   - Field: ‘lazy’
[09:32:30.617]   - Field: ‘state’
[09:32:30.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:30.617] - Launch lazy future ...
[09:32:30.618] Packages needed by the future expression (n = 0): <none>
[09:32:30.618] Packages needed by future strategies (n = 0): <none>
[09:32:30.618] {
[09:32:30.618]     {
[09:32:30.618]         {
[09:32:30.618]             ...future.startTime <- base::Sys.time()
[09:32:30.618]             {
[09:32:30.618]                 {
[09:32:30.618]                   {
[09:32:30.618]                     {
[09:32:30.618]                       base::local({
[09:32:30.618]                         has_future <- base::requireNamespace("future", 
[09:32:30.618]                           quietly = TRUE)
[09:32:30.618]                         if (has_future) {
[09:32:30.618]                           ns <- base::getNamespace("future")
[09:32:30.618]                           version <- ns[[".package"]][["version"]]
[09:32:30.618]                           if (is.null(version)) 
[09:32:30.618]                             version <- utils::packageVersion("future")
[09:32:30.618]                         }
[09:32:30.618]                         else {
[09:32:30.618]                           version <- NULL
[09:32:30.618]                         }
[09:32:30.618]                         if (!has_future || version < "1.8.0") {
[09:32:30.618]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:30.618]                             "", base::R.version$version.string), 
[09:32:30.618]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:30.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:30.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:30.618]                               "release", "version")], collapse = " "), 
[09:32:30.618]                             hostname = base::Sys.info()[["nodename"]])
[09:32:30.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:30.618]                             info)
[09:32:30.618]                           info <- base::paste(info, collapse = "; ")
[09:32:30.618]                           if (!has_future) {
[09:32:30.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:30.618]                               info)
[09:32:30.618]                           }
[09:32:30.618]                           else {
[09:32:30.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:30.618]                               info, version)
[09:32:30.618]                           }
[09:32:30.618]                           base::stop(msg)
[09:32:30.618]                         }
[09:32:30.618]                       })
[09:32:30.618]                     }
[09:32:30.618]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:30.618]                     base::options(mc.cores = 1L)
[09:32:30.618]                   }
[09:32:30.618]                   ...future.strategy.old <- future::plan("list")
[09:32:30.618]                   options(future.plan = NULL)
[09:32:30.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:30.618]                 }
[09:32:30.618]                 ...future.workdir <- getwd()
[09:32:30.618]             }
[09:32:30.618]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:30.618]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:30.618]         }
[09:32:30.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:30.618]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:30.618]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:30.618]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:30.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:30.618]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:30.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:30.618]             base::names(...future.oldOptions))
[09:32:30.618]     }
[09:32:30.618]     if (FALSE) {
[09:32:30.618]     }
[09:32:30.618]     else {
[09:32:30.618]         if (TRUE) {
[09:32:30.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:30.618]                 open = "w")
[09:32:30.618]         }
[09:32:30.618]         else {
[09:32:30.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:30.618]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:30.618]         }
[09:32:30.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:30.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:30.618]             base::sink(type = "output", split = FALSE)
[09:32:30.618]             base::close(...future.stdout)
[09:32:30.618]         }, add = TRUE)
[09:32:30.618]     }
[09:32:30.618]     ...future.frame <- base::sys.nframe()
[09:32:30.618]     ...future.conditions <- base::list()
[09:32:30.618]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:30.618]     if (FALSE) {
[09:32:30.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:30.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:30.618]     }
[09:32:30.618]     ...future.result <- base::tryCatch({
[09:32:30.618]         base::withCallingHandlers({
[09:32:30.618]             ...future.value <- base::withVisible(base::local({
[09:32:30.618]                 ...future.makeSendCondition <- base::local({
[09:32:30.618]                   sendCondition <- NULL
[09:32:30.618]                   function(frame = 1L) {
[09:32:30.618]                     if (is.function(sendCondition)) 
[09:32:30.618]                       return(sendCondition)
[09:32:30.618]                     ns <- getNamespace("parallel")
[09:32:30.618]                     if (exists("sendData", mode = "function", 
[09:32:30.618]                       envir = ns)) {
[09:32:30.618]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:30.618]                         envir = ns)
[09:32:30.618]                       envir <- sys.frame(frame)
[09:32:30.618]                       master <- NULL
[09:32:30.618]                       while (!identical(envir, .GlobalEnv) && 
[09:32:30.618]                         !identical(envir, emptyenv())) {
[09:32:30.618]                         if (exists("master", mode = "list", envir = envir, 
[09:32:30.618]                           inherits = FALSE)) {
[09:32:30.618]                           master <- get("master", mode = "list", 
[09:32:30.618]                             envir = envir, inherits = FALSE)
[09:32:30.618]                           if (inherits(master, c("SOCKnode", 
[09:32:30.618]                             "SOCK0node"))) {
[09:32:30.618]                             sendCondition <<- function(cond) {
[09:32:30.618]                               data <- list(type = "VALUE", value = cond, 
[09:32:30.618]                                 success = TRUE)
[09:32:30.618]                               parallel_sendData(master, data)
[09:32:30.618]                             }
[09:32:30.618]                             return(sendCondition)
[09:32:30.618]                           }
[09:32:30.618]                         }
[09:32:30.618]                         frame <- frame + 1L
[09:32:30.618]                         envir <- sys.frame(frame)
[09:32:30.618]                       }
[09:32:30.618]                     }
[09:32:30.618]                     sendCondition <<- function(cond) NULL
[09:32:30.618]                   }
[09:32:30.618]                 })
[09:32:30.618]                 withCallingHandlers({
[09:32:30.618]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:30.618]                 }, immediateCondition = function(cond) {
[09:32:30.618]                   sendCondition <- ...future.makeSendCondition()
[09:32:30.618]                   sendCondition(cond)
[09:32:30.618]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.618]                   {
[09:32:30.618]                     inherits <- base::inherits
[09:32:30.618]                     invokeRestart <- base::invokeRestart
[09:32:30.618]                     is.null <- base::is.null
[09:32:30.618]                     muffled <- FALSE
[09:32:30.618]                     if (inherits(cond, "message")) {
[09:32:30.618]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:30.618]                       if (muffled) 
[09:32:30.618]                         invokeRestart("muffleMessage")
[09:32:30.618]                     }
[09:32:30.618]                     else if (inherits(cond, "warning")) {
[09:32:30.618]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:30.618]                       if (muffled) 
[09:32:30.618]                         invokeRestart("muffleWarning")
[09:32:30.618]                     }
[09:32:30.618]                     else if (inherits(cond, "condition")) {
[09:32:30.618]                       if (!is.null(pattern)) {
[09:32:30.618]                         computeRestarts <- base::computeRestarts
[09:32:30.618]                         grepl <- base::grepl
[09:32:30.618]                         restarts <- computeRestarts(cond)
[09:32:30.618]                         for (restart in restarts) {
[09:32:30.618]                           name <- restart$name
[09:32:30.618]                           if (is.null(name)) 
[09:32:30.618]                             next
[09:32:30.618]                           if (!grepl(pattern, name)) 
[09:32:30.618]                             next
[09:32:30.618]                           invokeRestart(restart)
[09:32:30.618]                           muffled <- TRUE
[09:32:30.618]                           break
[09:32:30.618]                         }
[09:32:30.618]                       }
[09:32:30.618]                     }
[09:32:30.618]                     invisible(muffled)
[09:32:30.618]                   }
[09:32:30.618]                   muffleCondition(cond)
[09:32:30.618]                 })
[09:32:30.618]             }))
[09:32:30.618]             future::FutureResult(value = ...future.value$value, 
[09:32:30.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.618]                   ...future.rng), globalenv = if (FALSE) 
[09:32:30.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:30.618]                     ...future.globalenv.names))
[09:32:30.618]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:30.618]         }, condition = base::local({
[09:32:30.618]             c <- base::c
[09:32:30.618]             inherits <- base::inherits
[09:32:30.618]             invokeRestart <- base::invokeRestart
[09:32:30.618]             length <- base::length
[09:32:30.618]             list <- base::list
[09:32:30.618]             seq.int <- base::seq.int
[09:32:30.618]             signalCondition <- base::signalCondition
[09:32:30.618]             sys.calls <- base::sys.calls
[09:32:30.618]             `[[` <- base::`[[`
[09:32:30.618]             `+` <- base::`+`
[09:32:30.618]             `<<-` <- base::`<<-`
[09:32:30.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:30.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:30.618]                   3L)]
[09:32:30.618]             }
[09:32:30.618]             function(cond) {
[09:32:30.618]                 is_error <- inherits(cond, "error")
[09:32:30.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:30.618]                   NULL)
[09:32:30.618]                 if (is_error) {
[09:32:30.618]                   sessionInformation <- function() {
[09:32:30.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:30.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:30.618]                       search = base::search(), system = base::Sys.info())
[09:32:30.618]                   }
[09:32:30.618]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:30.618]                     cond$call), session = sessionInformation(), 
[09:32:30.618]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:30.618]                   signalCondition(cond)
[09:32:30.618]                 }
[09:32:30.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:30.618]                 "immediateCondition"))) {
[09:32:30.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:30.618]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:30.618]                   if (TRUE && !signal) {
[09:32:30.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.618]                     {
[09:32:30.618]                       inherits <- base::inherits
[09:32:30.618]                       invokeRestart <- base::invokeRestart
[09:32:30.618]                       is.null <- base::is.null
[09:32:30.618]                       muffled <- FALSE
[09:32:30.618]                       if (inherits(cond, "message")) {
[09:32:30.618]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.618]                         if (muffled) 
[09:32:30.618]                           invokeRestart("muffleMessage")
[09:32:30.618]                       }
[09:32:30.618]                       else if (inherits(cond, "warning")) {
[09:32:30.618]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.618]                         if (muffled) 
[09:32:30.618]                           invokeRestart("muffleWarning")
[09:32:30.618]                       }
[09:32:30.618]                       else if (inherits(cond, "condition")) {
[09:32:30.618]                         if (!is.null(pattern)) {
[09:32:30.618]                           computeRestarts <- base::computeRestarts
[09:32:30.618]                           grepl <- base::grepl
[09:32:30.618]                           restarts <- computeRestarts(cond)
[09:32:30.618]                           for (restart in restarts) {
[09:32:30.618]                             name <- restart$name
[09:32:30.618]                             if (is.null(name)) 
[09:32:30.618]                               next
[09:32:30.618]                             if (!grepl(pattern, name)) 
[09:32:30.618]                               next
[09:32:30.618]                             invokeRestart(restart)
[09:32:30.618]                             muffled <- TRUE
[09:32:30.618]                             break
[09:32:30.618]                           }
[09:32:30.618]                         }
[09:32:30.618]                       }
[09:32:30.618]                       invisible(muffled)
[09:32:30.618]                     }
[09:32:30.618]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.618]                   }
[09:32:30.618]                 }
[09:32:30.618]                 else {
[09:32:30.618]                   if (TRUE) {
[09:32:30.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.618]                     {
[09:32:30.618]                       inherits <- base::inherits
[09:32:30.618]                       invokeRestart <- base::invokeRestart
[09:32:30.618]                       is.null <- base::is.null
[09:32:30.618]                       muffled <- FALSE
[09:32:30.618]                       if (inherits(cond, "message")) {
[09:32:30.618]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.618]                         if (muffled) 
[09:32:30.618]                           invokeRestart("muffleMessage")
[09:32:30.618]                       }
[09:32:30.618]                       else if (inherits(cond, "warning")) {
[09:32:30.618]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.618]                         if (muffled) 
[09:32:30.618]                           invokeRestart("muffleWarning")
[09:32:30.618]                       }
[09:32:30.618]                       else if (inherits(cond, "condition")) {
[09:32:30.618]                         if (!is.null(pattern)) {
[09:32:30.618]                           computeRestarts <- base::computeRestarts
[09:32:30.618]                           grepl <- base::grepl
[09:32:30.618]                           restarts <- computeRestarts(cond)
[09:32:30.618]                           for (restart in restarts) {
[09:32:30.618]                             name <- restart$name
[09:32:30.618]                             if (is.null(name)) 
[09:32:30.618]                               next
[09:32:30.618]                             if (!grepl(pattern, name)) 
[09:32:30.618]                               next
[09:32:30.618]                             invokeRestart(restart)
[09:32:30.618]                             muffled <- TRUE
[09:32:30.618]                             break
[09:32:30.618]                           }
[09:32:30.618]                         }
[09:32:30.618]                       }
[09:32:30.618]                       invisible(muffled)
[09:32:30.618]                     }
[09:32:30.618]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.618]                   }
[09:32:30.618]                 }
[09:32:30.618]             }
[09:32:30.618]         }))
[09:32:30.618]     }, error = function(ex) {
[09:32:30.618]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:30.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.618]                 ...future.rng), started = ...future.startTime, 
[09:32:30.618]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:30.618]             version = "1.8"), class = "FutureResult")
[09:32:30.618]     }, finally = {
[09:32:30.618]         if (!identical(...future.workdir, getwd())) 
[09:32:30.618]             setwd(...future.workdir)
[09:32:30.618]         {
[09:32:30.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:30.618]                 ...future.oldOptions$nwarnings <- NULL
[09:32:30.618]             }
[09:32:30.618]             base::options(...future.oldOptions)
[09:32:30.618]             if (.Platform$OS.type == "windows") {
[09:32:30.618]                 old_names <- names(...future.oldEnvVars)
[09:32:30.618]                 envs <- base::Sys.getenv()
[09:32:30.618]                 names <- names(envs)
[09:32:30.618]                 common <- intersect(names, old_names)
[09:32:30.618]                 added <- setdiff(names, old_names)
[09:32:30.618]                 removed <- setdiff(old_names, names)
[09:32:30.618]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:30.618]                   envs[common]]
[09:32:30.618]                 NAMES <- toupper(changed)
[09:32:30.618]                 args <- list()
[09:32:30.618]                 for (kk in seq_along(NAMES)) {
[09:32:30.618]                   name <- changed[[kk]]
[09:32:30.618]                   NAME <- NAMES[[kk]]
[09:32:30.618]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.618]                     next
[09:32:30.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.618]                 }
[09:32:30.618]                 NAMES <- toupper(added)
[09:32:30.618]                 for (kk in seq_along(NAMES)) {
[09:32:30.618]                   name <- added[[kk]]
[09:32:30.618]                   NAME <- NAMES[[kk]]
[09:32:30.618]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.618]                     next
[09:32:30.618]                   args[[name]] <- ""
[09:32:30.618]                 }
[09:32:30.618]                 NAMES <- toupper(removed)
[09:32:30.618]                 for (kk in seq_along(NAMES)) {
[09:32:30.618]                   name <- removed[[kk]]
[09:32:30.618]                   NAME <- NAMES[[kk]]
[09:32:30.618]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.618]                     next
[09:32:30.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.618]                 }
[09:32:30.618]                 if (length(args) > 0) 
[09:32:30.618]                   base::do.call(base::Sys.setenv, args = args)
[09:32:30.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:30.618]             }
[09:32:30.618]             else {
[09:32:30.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:30.618]             }
[09:32:30.618]             {
[09:32:30.618]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:30.618]                   0L) {
[09:32:30.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:30.618]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:30.618]                   base::options(opts)
[09:32:30.618]                 }
[09:32:30.618]                 {
[09:32:30.618]                   {
[09:32:30.618]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:30.618]                     NULL
[09:32:30.618]                   }
[09:32:30.618]                   options(future.plan = NULL)
[09:32:30.618]                   if (is.na(NA_character_)) 
[09:32:30.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:30.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:30.618]                     .init = FALSE)
[09:32:30.618]                 }
[09:32:30.618]             }
[09:32:30.618]         }
[09:32:30.618]     })
[09:32:30.618]     if (TRUE) {
[09:32:30.618]         base::sink(type = "output", split = FALSE)
[09:32:30.618]         if (TRUE) {
[09:32:30.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:30.618]         }
[09:32:30.618]         else {
[09:32:30.618]             ...future.result["stdout"] <- base::list(NULL)
[09:32:30.618]         }
[09:32:30.618]         base::close(...future.stdout)
[09:32:30.618]         ...future.stdout <- NULL
[09:32:30.618]     }
[09:32:30.618]     ...future.result$conditions <- ...future.conditions
[09:32:30.618]     ...future.result$finished <- base::Sys.time()
[09:32:30.618]     ...future.result
[09:32:30.618] }
[09:32:30.621] MultisessionFuture started
[09:32:30.621] - Launch lazy future ... done
[09:32:30.621] run() for ‘MultisessionFuture’ ... done
[09:32:30.622] receiveMessageFromWorker() for ClusterFuture ...
[09:32:30.623] - Validating connection of MultisessionFuture
[09:32:30.623] - received message: FutureResult
[09:32:30.623] - Received FutureResult
[09:32:30.623] - Erased future from FutureRegistry
[09:32:30.623] result() for ClusterFuture ...
[09:32:30.623] - result already collected: FutureResult
[09:32:30.623] result() for ClusterFuture ... done
[09:32:30.623] signalConditions() ...
[09:32:30.624]  - include = ‘immediateCondition’
[09:32:30.624]  - exclude = 
[09:32:30.624]  - resignal = FALSE
[09:32:30.624]  - Number of conditions: 1
[09:32:30.624] signalConditions() ... done
[09:32:30.624] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:30.624] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[09:32:30.624] getGlobalsAndPackages() ...
[09:32:30.624] Searching for globals...
[09:32:30.626] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:30.626] Searching for globals ... DONE
[09:32:30.626] Resolving globals: FALSE
[09:32:30.626] 
[09:32:30.626] 
[09:32:30.626] getGlobalsAndPackages() ... DONE
[09:32:30.626] run() for ‘Future’ ...
[09:32:30.627] - state: ‘created’
[09:32:30.627] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:30.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:30.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:30.641]   - Field: ‘node’
[09:32:30.641]   - Field: ‘label’
[09:32:30.641]   - Field: ‘local’
[09:32:30.641]   - Field: ‘owner’
[09:32:30.641]   - Field: ‘envir’
[09:32:30.641]   - Field: ‘workers’
[09:32:30.641]   - Field: ‘packages’
[09:32:30.641]   - Field: ‘gc’
[09:32:30.642]   - Field: ‘conditions’
[09:32:30.642]   - Field: ‘persistent’
[09:32:30.642]   - Field: ‘expr’
[09:32:30.642]   - Field: ‘uuid’
[09:32:30.642]   - Field: ‘seed’
[09:32:30.642]   - Field: ‘version’
[09:32:30.642]   - Field: ‘result’
[09:32:30.642]   - Field: ‘asynchronous’
[09:32:30.642]   - Field: ‘calls’
[09:32:30.642]   - Field: ‘globals’
[09:32:30.642]   - Field: ‘stdout’
[09:32:30.642]   - Field: ‘earlySignal’
[09:32:30.643]   - Field: ‘lazy’
[09:32:30.643]   - Field: ‘state’
[09:32:30.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:30.643] - Launch lazy future ...
[09:32:30.643] Packages needed by the future expression (n = 0): <none>
[09:32:30.643] Packages needed by future strategies (n = 0): <none>
[09:32:30.644] {
[09:32:30.644]     {
[09:32:30.644]         {
[09:32:30.644]             ...future.startTime <- base::Sys.time()
[09:32:30.644]             {
[09:32:30.644]                 {
[09:32:30.644]                   {
[09:32:30.644]                     {
[09:32:30.644]                       base::local({
[09:32:30.644]                         has_future <- base::requireNamespace("future", 
[09:32:30.644]                           quietly = TRUE)
[09:32:30.644]                         if (has_future) {
[09:32:30.644]                           ns <- base::getNamespace("future")
[09:32:30.644]                           version <- ns[[".package"]][["version"]]
[09:32:30.644]                           if (is.null(version)) 
[09:32:30.644]                             version <- utils::packageVersion("future")
[09:32:30.644]                         }
[09:32:30.644]                         else {
[09:32:30.644]                           version <- NULL
[09:32:30.644]                         }
[09:32:30.644]                         if (!has_future || version < "1.8.0") {
[09:32:30.644]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:30.644]                             "", base::R.version$version.string), 
[09:32:30.644]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:30.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:30.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:30.644]                               "release", "version")], collapse = " "), 
[09:32:30.644]                             hostname = base::Sys.info()[["nodename"]])
[09:32:30.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:30.644]                             info)
[09:32:30.644]                           info <- base::paste(info, collapse = "; ")
[09:32:30.644]                           if (!has_future) {
[09:32:30.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:30.644]                               info)
[09:32:30.644]                           }
[09:32:30.644]                           else {
[09:32:30.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:30.644]                               info, version)
[09:32:30.644]                           }
[09:32:30.644]                           base::stop(msg)
[09:32:30.644]                         }
[09:32:30.644]                       })
[09:32:30.644]                     }
[09:32:30.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:30.644]                     base::options(mc.cores = 1L)
[09:32:30.644]                   }
[09:32:30.644]                   ...future.strategy.old <- future::plan("list")
[09:32:30.644]                   options(future.plan = NULL)
[09:32:30.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:30.644]                 }
[09:32:30.644]                 ...future.workdir <- getwd()
[09:32:30.644]             }
[09:32:30.644]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:30.644]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:30.644]         }
[09:32:30.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:30.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:30.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:30.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:30.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:30.644]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:30.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:30.644]             base::names(...future.oldOptions))
[09:32:30.644]     }
[09:32:30.644]     if (FALSE) {
[09:32:30.644]     }
[09:32:30.644]     else {
[09:32:30.644]         if (TRUE) {
[09:32:30.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:30.644]                 open = "w")
[09:32:30.644]         }
[09:32:30.644]         else {
[09:32:30.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:30.644]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:30.644]         }
[09:32:30.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:30.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:30.644]             base::sink(type = "output", split = FALSE)
[09:32:30.644]             base::close(...future.stdout)
[09:32:30.644]         }, add = TRUE)
[09:32:30.644]     }
[09:32:30.644]     ...future.frame <- base::sys.nframe()
[09:32:30.644]     ...future.conditions <- base::list()
[09:32:30.644]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:30.644]     if (FALSE) {
[09:32:30.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:30.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:30.644]     }
[09:32:30.644]     ...future.result <- base::tryCatch({
[09:32:30.644]         base::withCallingHandlers({
[09:32:30.644]             ...future.value <- base::withVisible(base::local({
[09:32:30.644]                 ...future.makeSendCondition <- base::local({
[09:32:30.644]                   sendCondition <- NULL
[09:32:30.644]                   function(frame = 1L) {
[09:32:30.644]                     if (is.function(sendCondition)) 
[09:32:30.644]                       return(sendCondition)
[09:32:30.644]                     ns <- getNamespace("parallel")
[09:32:30.644]                     if (exists("sendData", mode = "function", 
[09:32:30.644]                       envir = ns)) {
[09:32:30.644]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:30.644]                         envir = ns)
[09:32:30.644]                       envir <- sys.frame(frame)
[09:32:30.644]                       master <- NULL
[09:32:30.644]                       while (!identical(envir, .GlobalEnv) && 
[09:32:30.644]                         !identical(envir, emptyenv())) {
[09:32:30.644]                         if (exists("master", mode = "list", envir = envir, 
[09:32:30.644]                           inherits = FALSE)) {
[09:32:30.644]                           master <- get("master", mode = "list", 
[09:32:30.644]                             envir = envir, inherits = FALSE)
[09:32:30.644]                           if (inherits(master, c("SOCKnode", 
[09:32:30.644]                             "SOCK0node"))) {
[09:32:30.644]                             sendCondition <<- function(cond) {
[09:32:30.644]                               data <- list(type = "VALUE", value = cond, 
[09:32:30.644]                                 success = TRUE)
[09:32:30.644]                               parallel_sendData(master, data)
[09:32:30.644]                             }
[09:32:30.644]                             return(sendCondition)
[09:32:30.644]                           }
[09:32:30.644]                         }
[09:32:30.644]                         frame <- frame + 1L
[09:32:30.644]                         envir <- sys.frame(frame)
[09:32:30.644]                       }
[09:32:30.644]                     }
[09:32:30.644]                     sendCondition <<- function(cond) NULL
[09:32:30.644]                   }
[09:32:30.644]                 })
[09:32:30.644]                 withCallingHandlers({
[09:32:30.644]                   {
[09:32:30.644]                     Sys.sleep(0.5)
[09:32:30.644]                     list(a = 1, b = 42L)
[09:32:30.644]                   }
[09:32:30.644]                 }, immediateCondition = function(cond) {
[09:32:30.644]                   sendCondition <- ...future.makeSendCondition()
[09:32:30.644]                   sendCondition(cond)
[09:32:30.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.644]                   {
[09:32:30.644]                     inherits <- base::inherits
[09:32:30.644]                     invokeRestart <- base::invokeRestart
[09:32:30.644]                     is.null <- base::is.null
[09:32:30.644]                     muffled <- FALSE
[09:32:30.644]                     if (inherits(cond, "message")) {
[09:32:30.644]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:30.644]                       if (muffled) 
[09:32:30.644]                         invokeRestart("muffleMessage")
[09:32:30.644]                     }
[09:32:30.644]                     else if (inherits(cond, "warning")) {
[09:32:30.644]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:30.644]                       if (muffled) 
[09:32:30.644]                         invokeRestart("muffleWarning")
[09:32:30.644]                     }
[09:32:30.644]                     else if (inherits(cond, "condition")) {
[09:32:30.644]                       if (!is.null(pattern)) {
[09:32:30.644]                         computeRestarts <- base::computeRestarts
[09:32:30.644]                         grepl <- base::grepl
[09:32:30.644]                         restarts <- computeRestarts(cond)
[09:32:30.644]                         for (restart in restarts) {
[09:32:30.644]                           name <- restart$name
[09:32:30.644]                           if (is.null(name)) 
[09:32:30.644]                             next
[09:32:30.644]                           if (!grepl(pattern, name)) 
[09:32:30.644]                             next
[09:32:30.644]                           invokeRestart(restart)
[09:32:30.644]                           muffled <- TRUE
[09:32:30.644]                           break
[09:32:30.644]                         }
[09:32:30.644]                       }
[09:32:30.644]                     }
[09:32:30.644]                     invisible(muffled)
[09:32:30.644]                   }
[09:32:30.644]                   muffleCondition(cond)
[09:32:30.644]                 })
[09:32:30.644]             }))
[09:32:30.644]             future::FutureResult(value = ...future.value$value, 
[09:32:30.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.644]                   ...future.rng), globalenv = if (FALSE) 
[09:32:30.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:30.644]                     ...future.globalenv.names))
[09:32:30.644]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:30.644]         }, condition = base::local({
[09:32:30.644]             c <- base::c
[09:32:30.644]             inherits <- base::inherits
[09:32:30.644]             invokeRestart <- base::invokeRestart
[09:32:30.644]             length <- base::length
[09:32:30.644]             list <- base::list
[09:32:30.644]             seq.int <- base::seq.int
[09:32:30.644]             signalCondition <- base::signalCondition
[09:32:30.644]             sys.calls <- base::sys.calls
[09:32:30.644]             `[[` <- base::`[[`
[09:32:30.644]             `+` <- base::`+`
[09:32:30.644]             `<<-` <- base::`<<-`
[09:32:30.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:30.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:30.644]                   3L)]
[09:32:30.644]             }
[09:32:30.644]             function(cond) {
[09:32:30.644]                 is_error <- inherits(cond, "error")
[09:32:30.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:30.644]                   NULL)
[09:32:30.644]                 if (is_error) {
[09:32:30.644]                   sessionInformation <- function() {
[09:32:30.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:30.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:30.644]                       search = base::search(), system = base::Sys.info())
[09:32:30.644]                   }
[09:32:30.644]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:30.644]                     cond$call), session = sessionInformation(), 
[09:32:30.644]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:30.644]                   signalCondition(cond)
[09:32:30.644]                 }
[09:32:30.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:30.644]                 "immediateCondition"))) {
[09:32:30.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:30.644]                   ...future.conditions[[length(...future.conditions) + 
[09:32:30.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:30.644]                   if (TRUE && !signal) {
[09:32:30.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.644]                     {
[09:32:30.644]                       inherits <- base::inherits
[09:32:30.644]                       invokeRestart <- base::invokeRestart
[09:32:30.644]                       is.null <- base::is.null
[09:32:30.644]                       muffled <- FALSE
[09:32:30.644]                       if (inherits(cond, "message")) {
[09:32:30.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.644]                         if (muffled) 
[09:32:30.644]                           invokeRestart("muffleMessage")
[09:32:30.644]                       }
[09:32:30.644]                       else if (inherits(cond, "warning")) {
[09:32:30.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.644]                         if (muffled) 
[09:32:30.644]                           invokeRestart("muffleWarning")
[09:32:30.644]                       }
[09:32:30.644]                       else if (inherits(cond, "condition")) {
[09:32:30.644]                         if (!is.null(pattern)) {
[09:32:30.644]                           computeRestarts <- base::computeRestarts
[09:32:30.644]                           grepl <- base::grepl
[09:32:30.644]                           restarts <- computeRestarts(cond)
[09:32:30.644]                           for (restart in restarts) {
[09:32:30.644]                             name <- restart$name
[09:32:30.644]                             if (is.null(name)) 
[09:32:30.644]                               next
[09:32:30.644]                             if (!grepl(pattern, name)) 
[09:32:30.644]                               next
[09:32:30.644]                             invokeRestart(restart)
[09:32:30.644]                             muffled <- TRUE
[09:32:30.644]                             break
[09:32:30.644]                           }
[09:32:30.644]                         }
[09:32:30.644]                       }
[09:32:30.644]                       invisible(muffled)
[09:32:30.644]                     }
[09:32:30.644]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.644]                   }
[09:32:30.644]                 }
[09:32:30.644]                 else {
[09:32:30.644]                   if (TRUE) {
[09:32:30.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:30.644]                     {
[09:32:30.644]                       inherits <- base::inherits
[09:32:30.644]                       invokeRestart <- base::invokeRestart
[09:32:30.644]                       is.null <- base::is.null
[09:32:30.644]                       muffled <- FALSE
[09:32:30.644]                       if (inherits(cond, "message")) {
[09:32:30.644]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:30.644]                         if (muffled) 
[09:32:30.644]                           invokeRestart("muffleMessage")
[09:32:30.644]                       }
[09:32:30.644]                       else if (inherits(cond, "warning")) {
[09:32:30.644]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:30.644]                         if (muffled) 
[09:32:30.644]                           invokeRestart("muffleWarning")
[09:32:30.644]                       }
[09:32:30.644]                       else if (inherits(cond, "condition")) {
[09:32:30.644]                         if (!is.null(pattern)) {
[09:32:30.644]                           computeRestarts <- base::computeRestarts
[09:32:30.644]                           grepl <- base::grepl
[09:32:30.644]                           restarts <- computeRestarts(cond)
[09:32:30.644]                           for (restart in restarts) {
[09:32:30.644]                             name <- restart$name
[09:32:30.644]                             if (is.null(name)) 
[09:32:30.644]                               next
[09:32:30.644]                             if (!grepl(pattern, name)) 
[09:32:30.644]                               next
[09:32:30.644]                             invokeRestart(restart)
[09:32:30.644]                             muffled <- TRUE
[09:32:30.644]                             break
[09:32:30.644]                           }
[09:32:30.644]                         }
[09:32:30.644]                       }
[09:32:30.644]                       invisible(muffled)
[09:32:30.644]                     }
[09:32:30.644]                     muffleCondition(cond, pattern = "^muffle")
[09:32:30.644]                   }
[09:32:30.644]                 }
[09:32:30.644]             }
[09:32:30.644]         }))
[09:32:30.644]     }, error = function(ex) {
[09:32:30.644]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:30.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:30.644]                 ...future.rng), started = ...future.startTime, 
[09:32:30.644]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:30.644]             version = "1.8"), class = "FutureResult")
[09:32:30.644]     }, finally = {
[09:32:30.644]         if (!identical(...future.workdir, getwd())) 
[09:32:30.644]             setwd(...future.workdir)
[09:32:30.644]         {
[09:32:30.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:30.644]                 ...future.oldOptions$nwarnings <- NULL
[09:32:30.644]             }
[09:32:30.644]             base::options(...future.oldOptions)
[09:32:30.644]             if (.Platform$OS.type == "windows") {
[09:32:30.644]                 old_names <- names(...future.oldEnvVars)
[09:32:30.644]                 envs <- base::Sys.getenv()
[09:32:30.644]                 names <- names(envs)
[09:32:30.644]                 common <- intersect(names, old_names)
[09:32:30.644]                 added <- setdiff(names, old_names)
[09:32:30.644]                 removed <- setdiff(old_names, names)
[09:32:30.644]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:30.644]                   envs[common]]
[09:32:30.644]                 NAMES <- toupper(changed)
[09:32:30.644]                 args <- list()
[09:32:30.644]                 for (kk in seq_along(NAMES)) {
[09:32:30.644]                   name <- changed[[kk]]
[09:32:30.644]                   NAME <- NAMES[[kk]]
[09:32:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.644]                     next
[09:32:30.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.644]                 }
[09:32:30.644]                 NAMES <- toupper(added)
[09:32:30.644]                 for (kk in seq_along(NAMES)) {
[09:32:30.644]                   name <- added[[kk]]
[09:32:30.644]                   NAME <- NAMES[[kk]]
[09:32:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.644]                     next
[09:32:30.644]                   args[[name]] <- ""
[09:32:30.644]                 }
[09:32:30.644]                 NAMES <- toupper(removed)
[09:32:30.644]                 for (kk in seq_along(NAMES)) {
[09:32:30.644]                   name <- removed[[kk]]
[09:32:30.644]                   NAME <- NAMES[[kk]]
[09:32:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:30.644]                     next
[09:32:30.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:30.644]                 }
[09:32:30.644]                 if (length(args) > 0) 
[09:32:30.644]                   base::do.call(base::Sys.setenv, args = args)
[09:32:30.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:30.644]             }
[09:32:30.644]             else {
[09:32:30.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:30.644]             }
[09:32:30.644]             {
[09:32:30.644]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:30.644]                   0L) {
[09:32:30.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:30.644]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:30.644]                   base::options(opts)
[09:32:30.644]                 }
[09:32:30.644]                 {
[09:32:30.644]                   {
[09:32:30.644]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:30.644]                     NULL
[09:32:30.644]                   }
[09:32:30.644]                   options(future.plan = NULL)
[09:32:30.644]                   if (is.na(NA_character_)) 
[09:32:30.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:30.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:30.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:30.644]                     .init = FALSE)
[09:32:30.644]                 }
[09:32:30.644]             }
[09:32:30.644]         }
[09:32:30.644]     })
[09:32:30.644]     if (TRUE) {
[09:32:30.644]         base::sink(type = "output", split = FALSE)
[09:32:30.644]         if (TRUE) {
[09:32:30.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:30.644]         }
[09:32:30.644]         else {
[09:32:30.644]             ...future.result["stdout"] <- base::list(NULL)
[09:32:30.644]         }
[09:32:30.644]         base::close(...future.stdout)
[09:32:30.644]         ...future.stdout <- NULL
[09:32:30.644]     }
[09:32:30.644]     ...future.result$conditions <- ...future.conditions
[09:32:30.644]     ...future.result$finished <- base::Sys.time()
[09:32:30.644]     ...future.result
[09:32:30.644] }
[09:32:30.646] MultisessionFuture started
[09:32:30.646] - Launch lazy future ... done
[09:32:30.647] run() for ‘MultisessionFuture’ ... done
[09:32:31.149] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.149] - Validating connection of MultisessionFuture
[09:32:31.149] - received message: FutureResult
[09:32:31.149] - Received FutureResult
[09:32:31.150] - Erased future from FutureRegistry
[09:32:31.150] result() for ClusterFuture ...
[09:32:31.150] - result already collected: FutureResult
[09:32:31.150] result() for ClusterFuture ... done
[09:32:31.150] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.150] resolve() on list ...
[09:32:31.150]  recursive: 98
[09:32:31.150]  length: 2
[09:32:31.150]  elements: ‘a’, ‘b’
[09:32:31.151]  length: 1 (resolved future 1)
[09:32:31.151]  length: 0 (resolved future 2)
[09:32:31.151] resolve() on list ... DONE
[09:32:31.151] A MultisessionFuture was resolved (and resolved itself)
[09:32:31.151] getGlobalsAndPackages() ...
[09:32:31.151] Searching for globals...
[09:32:31.152] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:31.152] Searching for globals ... DONE
[09:32:31.152] Resolving globals: FALSE
[09:32:31.153] 
[09:32:31.153] 
[09:32:31.153] getGlobalsAndPackages() ... DONE
[09:32:31.153] run() for ‘Future’ ...
[09:32:31.153] - state: ‘created’
[09:32:31.153] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.168]   - Field: ‘node’
[09:32:31.168]   - Field: ‘label’
[09:32:31.168]   - Field: ‘local’
[09:32:31.168]   - Field: ‘owner’
[09:32:31.168]   - Field: ‘envir’
[09:32:31.168]   - Field: ‘workers’
[09:32:31.168]   - Field: ‘packages’
[09:32:31.168]   - Field: ‘gc’
[09:32:31.168]   - Field: ‘conditions’
[09:32:31.168]   - Field: ‘persistent’
[09:32:31.169]   - Field: ‘expr’
[09:32:31.169]   - Field: ‘uuid’
[09:32:31.169]   - Field: ‘seed’
[09:32:31.169]   - Field: ‘version’
[09:32:31.169]   - Field: ‘result’
[09:32:31.169]   - Field: ‘asynchronous’
[09:32:31.169]   - Field: ‘calls’
[09:32:31.169]   - Field: ‘globals’
[09:32:31.169]   - Field: ‘stdout’
[09:32:31.169]   - Field: ‘earlySignal’
[09:32:31.169]   - Field: ‘lazy’
[09:32:31.170]   - Field: ‘state’
[09:32:31.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.170] - Launch lazy future ...
[09:32:31.170] Packages needed by the future expression (n = 0): <none>
[09:32:31.170] Packages needed by future strategies (n = 0): <none>
[09:32:31.171] {
[09:32:31.171]     {
[09:32:31.171]         {
[09:32:31.171]             ...future.startTime <- base::Sys.time()
[09:32:31.171]             {
[09:32:31.171]                 {
[09:32:31.171]                   {
[09:32:31.171]                     {
[09:32:31.171]                       base::local({
[09:32:31.171]                         has_future <- base::requireNamespace("future", 
[09:32:31.171]                           quietly = TRUE)
[09:32:31.171]                         if (has_future) {
[09:32:31.171]                           ns <- base::getNamespace("future")
[09:32:31.171]                           version <- ns[[".package"]][["version"]]
[09:32:31.171]                           if (is.null(version)) 
[09:32:31.171]                             version <- utils::packageVersion("future")
[09:32:31.171]                         }
[09:32:31.171]                         else {
[09:32:31.171]                           version <- NULL
[09:32:31.171]                         }
[09:32:31.171]                         if (!has_future || version < "1.8.0") {
[09:32:31.171]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.171]                             "", base::R.version$version.string), 
[09:32:31.171]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.171]                               "release", "version")], collapse = " "), 
[09:32:31.171]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.171]                             info)
[09:32:31.171]                           info <- base::paste(info, collapse = "; ")
[09:32:31.171]                           if (!has_future) {
[09:32:31.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.171]                               info)
[09:32:31.171]                           }
[09:32:31.171]                           else {
[09:32:31.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.171]                               info, version)
[09:32:31.171]                           }
[09:32:31.171]                           base::stop(msg)
[09:32:31.171]                         }
[09:32:31.171]                       })
[09:32:31.171]                     }
[09:32:31.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.171]                     base::options(mc.cores = 1L)
[09:32:31.171]                   }
[09:32:31.171]                   ...future.strategy.old <- future::plan("list")
[09:32:31.171]                   options(future.plan = NULL)
[09:32:31.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.171]                 }
[09:32:31.171]                 ...future.workdir <- getwd()
[09:32:31.171]             }
[09:32:31.171]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.171]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.171]         }
[09:32:31.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.171]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.171]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.171]             base::names(...future.oldOptions))
[09:32:31.171]     }
[09:32:31.171]     if (FALSE) {
[09:32:31.171]     }
[09:32:31.171]     else {
[09:32:31.171]         if (TRUE) {
[09:32:31.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.171]                 open = "w")
[09:32:31.171]         }
[09:32:31.171]         else {
[09:32:31.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.171]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.171]         }
[09:32:31.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.171]             base::sink(type = "output", split = FALSE)
[09:32:31.171]             base::close(...future.stdout)
[09:32:31.171]         }, add = TRUE)
[09:32:31.171]     }
[09:32:31.171]     ...future.frame <- base::sys.nframe()
[09:32:31.171]     ...future.conditions <- base::list()
[09:32:31.171]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.171]     if (FALSE) {
[09:32:31.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.171]     }
[09:32:31.171]     ...future.result <- base::tryCatch({
[09:32:31.171]         base::withCallingHandlers({
[09:32:31.171]             ...future.value <- base::withVisible(base::local({
[09:32:31.171]                 ...future.makeSendCondition <- base::local({
[09:32:31.171]                   sendCondition <- NULL
[09:32:31.171]                   function(frame = 1L) {
[09:32:31.171]                     if (is.function(sendCondition)) 
[09:32:31.171]                       return(sendCondition)
[09:32:31.171]                     ns <- getNamespace("parallel")
[09:32:31.171]                     if (exists("sendData", mode = "function", 
[09:32:31.171]                       envir = ns)) {
[09:32:31.171]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.171]                         envir = ns)
[09:32:31.171]                       envir <- sys.frame(frame)
[09:32:31.171]                       master <- NULL
[09:32:31.171]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.171]                         !identical(envir, emptyenv())) {
[09:32:31.171]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.171]                           inherits = FALSE)) {
[09:32:31.171]                           master <- get("master", mode = "list", 
[09:32:31.171]                             envir = envir, inherits = FALSE)
[09:32:31.171]                           if (inherits(master, c("SOCKnode", 
[09:32:31.171]                             "SOCK0node"))) {
[09:32:31.171]                             sendCondition <<- function(cond) {
[09:32:31.171]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.171]                                 success = TRUE)
[09:32:31.171]                               parallel_sendData(master, data)
[09:32:31.171]                             }
[09:32:31.171]                             return(sendCondition)
[09:32:31.171]                           }
[09:32:31.171]                         }
[09:32:31.171]                         frame <- frame + 1L
[09:32:31.171]                         envir <- sys.frame(frame)
[09:32:31.171]                       }
[09:32:31.171]                     }
[09:32:31.171]                     sendCondition <<- function(cond) NULL
[09:32:31.171]                   }
[09:32:31.171]                 })
[09:32:31.171]                 withCallingHandlers({
[09:32:31.171]                   {
[09:32:31.171]                     Sys.sleep(0.5)
[09:32:31.171]                     list(a = 1, b = 42L)
[09:32:31.171]                   }
[09:32:31.171]                 }, immediateCondition = function(cond) {
[09:32:31.171]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.171]                   sendCondition(cond)
[09:32:31.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.171]                   {
[09:32:31.171]                     inherits <- base::inherits
[09:32:31.171]                     invokeRestart <- base::invokeRestart
[09:32:31.171]                     is.null <- base::is.null
[09:32:31.171]                     muffled <- FALSE
[09:32:31.171]                     if (inherits(cond, "message")) {
[09:32:31.171]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.171]                       if (muffled) 
[09:32:31.171]                         invokeRestart("muffleMessage")
[09:32:31.171]                     }
[09:32:31.171]                     else if (inherits(cond, "warning")) {
[09:32:31.171]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.171]                       if (muffled) 
[09:32:31.171]                         invokeRestart("muffleWarning")
[09:32:31.171]                     }
[09:32:31.171]                     else if (inherits(cond, "condition")) {
[09:32:31.171]                       if (!is.null(pattern)) {
[09:32:31.171]                         computeRestarts <- base::computeRestarts
[09:32:31.171]                         grepl <- base::grepl
[09:32:31.171]                         restarts <- computeRestarts(cond)
[09:32:31.171]                         for (restart in restarts) {
[09:32:31.171]                           name <- restart$name
[09:32:31.171]                           if (is.null(name)) 
[09:32:31.171]                             next
[09:32:31.171]                           if (!grepl(pattern, name)) 
[09:32:31.171]                             next
[09:32:31.171]                           invokeRestart(restart)
[09:32:31.171]                           muffled <- TRUE
[09:32:31.171]                           break
[09:32:31.171]                         }
[09:32:31.171]                       }
[09:32:31.171]                     }
[09:32:31.171]                     invisible(muffled)
[09:32:31.171]                   }
[09:32:31.171]                   muffleCondition(cond)
[09:32:31.171]                 })
[09:32:31.171]             }))
[09:32:31.171]             future::FutureResult(value = ...future.value$value, 
[09:32:31.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.171]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.171]                     ...future.globalenv.names))
[09:32:31.171]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.171]         }, condition = base::local({
[09:32:31.171]             c <- base::c
[09:32:31.171]             inherits <- base::inherits
[09:32:31.171]             invokeRestart <- base::invokeRestart
[09:32:31.171]             length <- base::length
[09:32:31.171]             list <- base::list
[09:32:31.171]             seq.int <- base::seq.int
[09:32:31.171]             signalCondition <- base::signalCondition
[09:32:31.171]             sys.calls <- base::sys.calls
[09:32:31.171]             `[[` <- base::`[[`
[09:32:31.171]             `+` <- base::`+`
[09:32:31.171]             `<<-` <- base::`<<-`
[09:32:31.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.171]                   3L)]
[09:32:31.171]             }
[09:32:31.171]             function(cond) {
[09:32:31.171]                 is_error <- inherits(cond, "error")
[09:32:31.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.171]                   NULL)
[09:32:31.171]                 if (is_error) {
[09:32:31.171]                   sessionInformation <- function() {
[09:32:31.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.171]                       search = base::search(), system = base::Sys.info())
[09:32:31.171]                   }
[09:32:31.171]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.171]                     cond$call), session = sessionInformation(), 
[09:32:31.171]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.171]                   signalCondition(cond)
[09:32:31.171]                 }
[09:32:31.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.171]                 "immediateCondition"))) {
[09:32:31.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.171]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.171]                   if (TRUE && !signal) {
[09:32:31.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.171]                     {
[09:32:31.171]                       inherits <- base::inherits
[09:32:31.171]                       invokeRestart <- base::invokeRestart
[09:32:31.171]                       is.null <- base::is.null
[09:32:31.171]                       muffled <- FALSE
[09:32:31.171]                       if (inherits(cond, "message")) {
[09:32:31.171]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.171]                         if (muffled) 
[09:32:31.171]                           invokeRestart("muffleMessage")
[09:32:31.171]                       }
[09:32:31.171]                       else if (inherits(cond, "warning")) {
[09:32:31.171]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.171]                         if (muffled) 
[09:32:31.171]                           invokeRestart("muffleWarning")
[09:32:31.171]                       }
[09:32:31.171]                       else if (inherits(cond, "condition")) {
[09:32:31.171]                         if (!is.null(pattern)) {
[09:32:31.171]                           computeRestarts <- base::computeRestarts
[09:32:31.171]                           grepl <- base::grepl
[09:32:31.171]                           restarts <- computeRestarts(cond)
[09:32:31.171]                           for (restart in restarts) {
[09:32:31.171]                             name <- restart$name
[09:32:31.171]                             if (is.null(name)) 
[09:32:31.171]                               next
[09:32:31.171]                             if (!grepl(pattern, name)) 
[09:32:31.171]                               next
[09:32:31.171]                             invokeRestart(restart)
[09:32:31.171]                             muffled <- TRUE
[09:32:31.171]                             break
[09:32:31.171]                           }
[09:32:31.171]                         }
[09:32:31.171]                       }
[09:32:31.171]                       invisible(muffled)
[09:32:31.171]                     }
[09:32:31.171]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.171]                   }
[09:32:31.171]                 }
[09:32:31.171]                 else {
[09:32:31.171]                   if (TRUE) {
[09:32:31.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.171]                     {
[09:32:31.171]                       inherits <- base::inherits
[09:32:31.171]                       invokeRestart <- base::invokeRestart
[09:32:31.171]                       is.null <- base::is.null
[09:32:31.171]                       muffled <- FALSE
[09:32:31.171]                       if (inherits(cond, "message")) {
[09:32:31.171]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.171]                         if (muffled) 
[09:32:31.171]                           invokeRestart("muffleMessage")
[09:32:31.171]                       }
[09:32:31.171]                       else if (inherits(cond, "warning")) {
[09:32:31.171]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.171]                         if (muffled) 
[09:32:31.171]                           invokeRestart("muffleWarning")
[09:32:31.171]                       }
[09:32:31.171]                       else if (inherits(cond, "condition")) {
[09:32:31.171]                         if (!is.null(pattern)) {
[09:32:31.171]                           computeRestarts <- base::computeRestarts
[09:32:31.171]                           grepl <- base::grepl
[09:32:31.171]                           restarts <- computeRestarts(cond)
[09:32:31.171]                           for (restart in restarts) {
[09:32:31.171]                             name <- restart$name
[09:32:31.171]                             if (is.null(name)) 
[09:32:31.171]                               next
[09:32:31.171]                             if (!grepl(pattern, name)) 
[09:32:31.171]                               next
[09:32:31.171]                             invokeRestart(restart)
[09:32:31.171]                             muffled <- TRUE
[09:32:31.171]                             break
[09:32:31.171]                           }
[09:32:31.171]                         }
[09:32:31.171]                       }
[09:32:31.171]                       invisible(muffled)
[09:32:31.171]                     }
[09:32:31.171]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.171]                   }
[09:32:31.171]                 }
[09:32:31.171]             }
[09:32:31.171]         }))
[09:32:31.171]     }, error = function(ex) {
[09:32:31.171]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.171]                 ...future.rng), started = ...future.startTime, 
[09:32:31.171]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.171]             version = "1.8"), class = "FutureResult")
[09:32:31.171]     }, finally = {
[09:32:31.171]         if (!identical(...future.workdir, getwd())) 
[09:32:31.171]             setwd(...future.workdir)
[09:32:31.171]         {
[09:32:31.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.171]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.171]             }
[09:32:31.171]             base::options(...future.oldOptions)
[09:32:31.171]             if (.Platform$OS.type == "windows") {
[09:32:31.171]                 old_names <- names(...future.oldEnvVars)
[09:32:31.171]                 envs <- base::Sys.getenv()
[09:32:31.171]                 names <- names(envs)
[09:32:31.171]                 common <- intersect(names, old_names)
[09:32:31.171]                 added <- setdiff(names, old_names)
[09:32:31.171]                 removed <- setdiff(old_names, names)
[09:32:31.171]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.171]                   envs[common]]
[09:32:31.171]                 NAMES <- toupper(changed)
[09:32:31.171]                 args <- list()
[09:32:31.171]                 for (kk in seq_along(NAMES)) {
[09:32:31.171]                   name <- changed[[kk]]
[09:32:31.171]                   NAME <- NAMES[[kk]]
[09:32:31.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.171]                     next
[09:32:31.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.171]                 }
[09:32:31.171]                 NAMES <- toupper(added)
[09:32:31.171]                 for (kk in seq_along(NAMES)) {
[09:32:31.171]                   name <- added[[kk]]
[09:32:31.171]                   NAME <- NAMES[[kk]]
[09:32:31.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.171]                     next
[09:32:31.171]                   args[[name]] <- ""
[09:32:31.171]                 }
[09:32:31.171]                 NAMES <- toupper(removed)
[09:32:31.171]                 for (kk in seq_along(NAMES)) {
[09:32:31.171]                   name <- removed[[kk]]
[09:32:31.171]                   NAME <- NAMES[[kk]]
[09:32:31.171]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.171]                     next
[09:32:31.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.171]                 }
[09:32:31.171]                 if (length(args) > 0) 
[09:32:31.171]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.171]             }
[09:32:31.171]             else {
[09:32:31.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.171]             }
[09:32:31.171]             {
[09:32:31.171]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.171]                   0L) {
[09:32:31.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.171]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.171]                   base::options(opts)
[09:32:31.171]                 }
[09:32:31.171]                 {
[09:32:31.171]                   {
[09:32:31.171]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.171]                     NULL
[09:32:31.171]                   }
[09:32:31.171]                   options(future.plan = NULL)
[09:32:31.171]                   if (is.na(NA_character_)) 
[09:32:31.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.171]                     .init = FALSE)
[09:32:31.171]                 }
[09:32:31.171]             }
[09:32:31.171]         }
[09:32:31.171]     })
[09:32:31.171]     if (TRUE) {
[09:32:31.171]         base::sink(type = "output", split = FALSE)
[09:32:31.171]         if (TRUE) {
[09:32:31.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.171]         }
[09:32:31.171]         else {
[09:32:31.171]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.171]         }
[09:32:31.171]         base::close(...future.stdout)
[09:32:31.171]         ...future.stdout <- NULL
[09:32:31.171]     }
[09:32:31.171]     ...future.result$conditions <- ...future.conditions
[09:32:31.171]     ...future.result$finished <- base::Sys.time()
[09:32:31.171]     ...future.result
[09:32:31.171] }
[09:32:31.173] MultisessionFuture started
[09:32:31.174] - Launch lazy future ... done
[09:32:31.174] run() for ‘MultisessionFuture’ ... done
[09:32:31.676] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.676] - Validating connection of MultisessionFuture
[09:32:31.676] - received message: FutureResult
[09:32:31.677] - Received FutureResult
[09:32:31.677] - Erased future from FutureRegistry
[09:32:31.677] result() for ClusterFuture ...
[09:32:31.677] - result already collected: FutureResult
[09:32:31.677] result() for ClusterFuture ... done
[09:32:31.677] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.677] resolve() on list ...
[09:32:31.677]  recursive: 98
[09:32:31.677]  length: 2
[09:32:31.677]  elements: ‘a’, ‘b’
[09:32:31.678]  length: 1 (resolved future 1)
[09:32:31.678]  length: 0 (resolved future 2)
[09:32:31.678] resolve() on list ... DONE
[09:32:31.678] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[09:32:31.678] getGlobalsAndPackages() ...
[09:32:31.678] Searching for globals...
[09:32:31.679] - globals found: [2] ‘list’, ‘stop’
[09:32:31.679] Searching for globals ... DONE
[09:32:31.679] Resolving globals: FALSE
[09:32:31.679] 
[09:32:31.679] 
[09:32:31.680] getGlobalsAndPackages() ... DONE
[09:32:31.680] run() for ‘Future’ ...
[09:32:31.680] - state: ‘created’
[09:32:31.680] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.694] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.694] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.694]   - Field: ‘node’
[09:32:31.694]   - Field: ‘label’
[09:32:31.694]   - Field: ‘local’
[09:32:31.694]   - Field: ‘owner’
[09:32:31.694]   - Field: ‘envir’
[09:32:31.694]   - Field: ‘workers’
[09:32:31.695]   - Field: ‘packages’
[09:32:31.695]   - Field: ‘gc’
[09:32:31.695]   - Field: ‘conditions’
[09:32:31.695]   - Field: ‘persistent’
[09:32:31.695]   - Field: ‘expr’
[09:32:31.695]   - Field: ‘uuid’
[09:32:31.695]   - Field: ‘seed’
[09:32:31.695]   - Field: ‘version’
[09:32:31.695]   - Field: ‘result’
[09:32:31.695]   - Field: ‘asynchronous’
[09:32:31.695]   - Field: ‘calls’
[09:32:31.695]   - Field: ‘globals’
[09:32:31.696]   - Field: ‘stdout’
[09:32:31.696]   - Field: ‘earlySignal’
[09:32:31.696]   - Field: ‘lazy’
[09:32:31.696]   - Field: ‘state’
[09:32:31.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.696] - Launch lazy future ...
[09:32:31.696] Packages needed by the future expression (n = 0): <none>
[09:32:31.696] Packages needed by future strategies (n = 0): <none>
[09:32:31.697] {
[09:32:31.697]     {
[09:32:31.697]         {
[09:32:31.697]             ...future.startTime <- base::Sys.time()
[09:32:31.697]             {
[09:32:31.697]                 {
[09:32:31.697]                   {
[09:32:31.697]                     {
[09:32:31.697]                       base::local({
[09:32:31.697]                         has_future <- base::requireNamespace("future", 
[09:32:31.697]                           quietly = TRUE)
[09:32:31.697]                         if (has_future) {
[09:32:31.697]                           ns <- base::getNamespace("future")
[09:32:31.697]                           version <- ns[[".package"]][["version"]]
[09:32:31.697]                           if (is.null(version)) 
[09:32:31.697]                             version <- utils::packageVersion("future")
[09:32:31.697]                         }
[09:32:31.697]                         else {
[09:32:31.697]                           version <- NULL
[09:32:31.697]                         }
[09:32:31.697]                         if (!has_future || version < "1.8.0") {
[09:32:31.697]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.697]                             "", base::R.version$version.string), 
[09:32:31.697]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.697]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.697]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.697]                               "release", "version")], collapse = " "), 
[09:32:31.697]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.697]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.697]                             info)
[09:32:31.697]                           info <- base::paste(info, collapse = "; ")
[09:32:31.697]                           if (!has_future) {
[09:32:31.697]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.697]                               info)
[09:32:31.697]                           }
[09:32:31.697]                           else {
[09:32:31.697]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.697]                               info, version)
[09:32:31.697]                           }
[09:32:31.697]                           base::stop(msg)
[09:32:31.697]                         }
[09:32:31.697]                       })
[09:32:31.697]                     }
[09:32:31.697]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.697]                     base::options(mc.cores = 1L)
[09:32:31.697]                   }
[09:32:31.697]                   ...future.strategy.old <- future::plan("list")
[09:32:31.697]                   options(future.plan = NULL)
[09:32:31.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.697]                 }
[09:32:31.697]                 ...future.workdir <- getwd()
[09:32:31.697]             }
[09:32:31.697]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.697]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.697]         }
[09:32:31.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.697]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.697]             base::names(...future.oldOptions))
[09:32:31.697]     }
[09:32:31.697]     if (FALSE) {
[09:32:31.697]     }
[09:32:31.697]     else {
[09:32:31.697]         if (TRUE) {
[09:32:31.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.697]                 open = "w")
[09:32:31.697]         }
[09:32:31.697]         else {
[09:32:31.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.697]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.697]         }
[09:32:31.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.697]             base::sink(type = "output", split = FALSE)
[09:32:31.697]             base::close(...future.stdout)
[09:32:31.697]         }, add = TRUE)
[09:32:31.697]     }
[09:32:31.697]     ...future.frame <- base::sys.nframe()
[09:32:31.697]     ...future.conditions <- base::list()
[09:32:31.697]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.697]     if (FALSE) {
[09:32:31.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.697]     }
[09:32:31.697]     ...future.result <- base::tryCatch({
[09:32:31.697]         base::withCallingHandlers({
[09:32:31.697]             ...future.value <- base::withVisible(base::local({
[09:32:31.697]                 ...future.makeSendCondition <- base::local({
[09:32:31.697]                   sendCondition <- NULL
[09:32:31.697]                   function(frame = 1L) {
[09:32:31.697]                     if (is.function(sendCondition)) 
[09:32:31.697]                       return(sendCondition)
[09:32:31.697]                     ns <- getNamespace("parallel")
[09:32:31.697]                     if (exists("sendData", mode = "function", 
[09:32:31.697]                       envir = ns)) {
[09:32:31.697]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.697]                         envir = ns)
[09:32:31.697]                       envir <- sys.frame(frame)
[09:32:31.697]                       master <- NULL
[09:32:31.697]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.697]                         !identical(envir, emptyenv())) {
[09:32:31.697]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.697]                           inherits = FALSE)) {
[09:32:31.697]                           master <- get("master", mode = "list", 
[09:32:31.697]                             envir = envir, inherits = FALSE)
[09:32:31.697]                           if (inherits(master, c("SOCKnode", 
[09:32:31.697]                             "SOCK0node"))) {
[09:32:31.697]                             sendCondition <<- function(cond) {
[09:32:31.697]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.697]                                 success = TRUE)
[09:32:31.697]                               parallel_sendData(master, data)
[09:32:31.697]                             }
[09:32:31.697]                             return(sendCondition)
[09:32:31.697]                           }
[09:32:31.697]                         }
[09:32:31.697]                         frame <- frame + 1L
[09:32:31.697]                         envir <- sys.frame(frame)
[09:32:31.697]                       }
[09:32:31.697]                     }
[09:32:31.697]                     sendCondition <<- function(cond) NULL
[09:32:31.697]                   }
[09:32:31.697]                 })
[09:32:31.697]                 withCallingHandlers({
[09:32:31.697]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:31.697]                 }, immediateCondition = function(cond) {
[09:32:31.697]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.697]                   sendCondition(cond)
[09:32:31.697]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.697]                   {
[09:32:31.697]                     inherits <- base::inherits
[09:32:31.697]                     invokeRestart <- base::invokeRestart
[09:32:31.697]                     is.null <- base::is.null
[09:32:31.697]                     muffled <- FALSE
[09:32:31.697]                     if (inherits(cond, "message")) {
[09:32:31.697]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.697]                       if (muffled) 
[09:32:31.697]                         invokeRestart("muffleMessage")
[09:32:31.697]                     }
[09:32:31.697]                     else if (inherits(cond, "warning")) {
[09:32:31.697]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.697]                       if (muffled) 
[09:32:31.697]                         invokeRestart("muffleWarning")
[09:32:31.697]                     }
[09:32:31.697]                     else if (inherits(cond, "condition")) {
[09:32:31.697]                       if (!is.null(pattern)) {
[09:32:31.697]                         computeRestarts <- base::computeRestarts
[09:32:31.697]                         grepl <- base::grepl
[09:32:31.697]                         restarts <- computeRestarts(cond)
[09:32:31.697]                         for (restart in restarts) {
[09:32:31.697]                           name <- restart$name
[09:32:31.697]                           if (is.null(name)) 
[09:32:31.697]                             next
[09:32:31.697]                           if (!grepl(pattern, name)) 
[09:32:31.697]                             next
[09:32:31.697]                           invokeRestart(restart)
[09:32:31.697]                           muffled <- TRUE
[09:32:31.697]                           break
[09:32:31.697]                         }
[09:32:31.697]                       }
[09:32:31.697]                     }
[09:32:31.697]                     invisible(muffled)
[09:32:31.697]                   }
[09:32:31.697]                   muffleCondition(cond)
[09:32:31.697]                 })
[09:32:31.697]             }))
[09:32:31.697]             future::FutureResult(value = ...future.value$value, 
[09:32:31.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.697]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.697]                     ...future.globalenv.names))
[09:32:31.697]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.697]         }, condition = base::local({
[09:32:31.697]             c <- base::c
[09:32:31.697]             inherits <- base::inherits
[09:32:31.697]             invokeRestart <- base::invokeRestart
[09:32:31.697]             length <- base::length
[09:32:31.697]             list <- base::list
[09:32:31.697]             seq.int <- base::seq.int
[09:32:31.697]             signalCondition <- base::signalCondition
[09:32:31.697]             sys.calls <- base::sys.calls
[09:32:31.697]             `[[` <- base::`[[`
[09:32:31.697]             `+` <- base::`+`
[09:32:31.697]             `<<-` <- base::`<<-`
[09:32:31.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.697]                   3L)]
[09:32:31.697]             }
[09:32:31.697]             function(cond) {
[09:32:31.697]                 is_error <- inherits(cond, "error")
[09:32:31.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.697]                   NULL)
[09:32:31.697]                 if (is_error) {
[09:32:31.697]                   sessionInformation <- function() {
[09:32:31.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.697]                       search = base::search(), system = base::Sys.info())
[09:32:31.697]                   }
[09:32:31.697]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.697]                     cond$call), session = sessionInformation(), 
[09:32:31.697]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.697]                   signalCondition(cond)
[09:32:31.697]                 }
[09:32:31.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.697]                 "immediateCondition"))) {
[09:32:31.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.697]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.697]                   if (TRUE && !signal) {
[09:32:31.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.697]                     {
[09:32:31.697]                       inherits <- base::inherits
[09:32:31.697]                       invokeRestart <- base::invokeRestart
[09:32:31.697]                       is.null <- base::is.null
[09:32:31.697]                       muffled <- FALSE
[09:32:31.697]                       if (inherits(cond, "message")) {
[09:32:31.697]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.697]                         if (muffled) 
[09:32:31.697]                           invokeRestart("muffleMessage")
[09:32:31.697]                       }
[09:32:31.697]                       else if (inherits(cond, "warning")) {
[09:32:31.697]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.697]                         if (muffled) 
[09:32:31.697]                           invokeRestart("muffleWarning")
[09:32:31.697]                       }
[09:32:31.697]                       else if (inherits(cond, "condition")) {
[09:32:31.697]                         if (!is.null(pattern)) {
[09:32:31.697]                           computeRestarts <- base::computeRestarts
[09:32:31.697]                           grepl <- base::grepl
[09:32:31.697]                           restarts <- computeRestarts(cond)
[09:32:31.697]                           for (restart in restarts) {
[09:32:31.697]                             name <- restart$name
[09:32:31.697]                             if (is.null(name)) 
[09:32:31.697]                               next
[09:32:31.697]                             if (!grepl(pattern, name)) 
[09:32:31.697]                               next
[09:32:31.697]                             invokeRestart(restart)
[09:32:31.697]                             muffled <- TRUE
[09:32:31.697]                             break
[09:32:31.697]                           }
[09:32:31.697]                         }
[09:32:31.697]                       }
[09:32:31.697]                       invisible(muffled)
[09:32:31.697]                     }
[09:32:31.697]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.697]                   }
[09:32:31.697]                 }
[09:32:31.697]                 else {
[09:32:31.697]                   if (TRUE) {
[09:32:31.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.697]                     {
[09:32:31.697]                       inherits <- base::inherits
[09:32:31.697]                       invokeRestart <- base::invokeRestart
[09:32:31.697]                       is.null <- base::is.null
[09:32:31.697]                       muffled <- FALSE
[09:32:31.697]                       if (inherits(cond, "message")) {
[09:32:31.697]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.697]                         if (muffled) 
[09:32:31.697]                           invokeRestart("muffleMessage")
[09:32:31.697]                       }
[09:32:31.697]                       else if (inherits(cond, "warning")) {
[09:32:31.697]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.697]                         if (muffled) 
[09:32:31.697]                           invokeRestart("muffleWarning")
[09:32:31.697]                       }
[09:32:31.697]                       else if (inherits(cond, "condition")) {
[09:32:31.697]                         if (!is.null(pattern)) {
[09:32:31.697]                           computeRestarts <- base::computeRestarts
[09:32:31.697]                           grepl <- base::grepl
[09:32:31.697]                           restarts <- computeRestarts(cond)
[09:32:31.697]                           for (restart in restarts) {
[09:32:31.697]                             name <- restart$name
[09:32:31.697]                             if (is.null(name)) 
[09:32:31.697]                               next
[09:32:31.697]                             if (!grepl(pattern, name)) 
[09:32:31.697]                               next
[09:32:31.697]                             invokeRestart(restart)
[09:32:31.697]                             muffled <- TRUE
[09:32:31.697]                             break
[09:32:31.697]                           }
[09:32:31.697]                         }
[09:32:31.697]                       }
[09:32:31.697]                       invisible(muffled)
[09:32:31.697]                     }
[09:32:31.697]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.697]                   }
[09:32:31.697]                 }
[09:32:31.697]             }
[09:32:31.697]         }))
[09:32:31.697]     }, error = function(ex) {
[09:32:31.697]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.697]                 ...future.rng), started = ...future.startTime, 
[09:32:31.697]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.697]             version = "1.8"), class = "FutureResult")
[09:32:31.697]     }, finally = {
[09:32:31.697]         if (!identical(...future.workdir, getwd())) 
[09:32:31.697]             setwd(...future.workdir)
[09:32:31.697]         {
[09:32:31.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.697]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.697]             }
[09:32:31.697]             base::options(...future.oldOptions)
[09:32:31.697]             if (.Platform$OS.type == "windows") {
[09:32:31.697]                 old_names <- names(...future.oldEnvVars)
[09:32:31.697]                 envs <- base::Sys.getenv()
[09:32:31.697]                 names <- names(envs)
[09:32:31.697]                 common <- intersect(names, old_names)
[09:32:31.697]                 added <- setdiff(names, old_names)
[09:32:31.697]                 removed <- setdiff(old_names, names)
[09:32:31.697]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.697]                   envs[common]]
[09:32:31.697]                 NAMES <- toupper(changed)
[09:32:31.697]                 args <- list()
[09:32:31.697]                 for (kk in seq_along(NAMES)) {
[09:32:31.697]                   name <- changed[[kk]]
[09:32:31.697]                   NAME <- NAMES[[kk]]
[09:32:31.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.697]                     next
[09:32:31.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.697]                 }
[09:32:31.697]                 NAMES <- toupper(added)
[09:32:31.697]                 for (kk in seq_along(NAMES)) {
[09:32:31.697]                   name <- added[[kk]]
[09:32:31.697]                   NAME <- NAMES[[kk]]
[09:32:31.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.697]                     next
[09:32:31.697]                   args[[name]] <- ""
[09:32:31.697]                 }
[09:32:31.697]                 NAMES <- toupper(removed)
[09:32:31.697]                 for (kk in seq_along(NAMES)) {
[09:32:31.697]                   name <- removed[[kk]]
[09:32:31.697]                   NAME <- NAMES[[kk]]
[09:32:31.697]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.697]                     next
[09:32:31.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.697]                 }
[09:32:31.697]                 if (length(args) > 0) 
[09:32:31.697]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.697]             }
[09:32:31.697]             else {
[09:32:31.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.697]             }
[09:32:31.697]             {
[09:32:31.697]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.697]                   0L) {
[09:32:31.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.697]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.697]                   base::options(opts)
[09:32:31.697]                 }
[09:32:31.697]                 {
[09:32:31.697]                   {
[09:32:31.697]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.697]                     NULL
[09:32:31.697]                   }
[09:32:31.697]                   options(future.plan = NULL)
[09:32:31.697]                   if (is.na(NA_character_)) 
[09:32:31.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.697]                     .init = FALSE)
[09:32:31.697]                 }
[09:32:31.697]             }
[09:32:31.697]         }
[09:32:31.697]     })
[09:32:31.697]     if (TRUE) {
[09:32:31.697]         base::sink(type = "output", split = FALSE)
[09:32:31.697]         if (TRUE) {
[09:32:31.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.697]         }
[09:32:31.697]         else {
[09:32:31.697]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.697]         }
[09:32:31.697]         base::close(...future.stdout)
[09:32:31.697]         ...future.stdout <- NULL
[09:32:31.697]     }
[09:32:31.697]     ...future.result$conditions <- ...future.conditions
[09:32:31.697]     ...future.result$finished <- base::Sys.time()
[09:32:31.697]     ...future.result
[09:32:31.697] }
[09:32:31.700] MultisessionFuture started
[09:32:31.702] - Launch lazy future ... done
[09:32:31.702] run() for ‘MultisessionFuture’ ... done
[09:32:31.703] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.703] - Validating connection of MultisessionFuture
[09:32:31.703] - received message: FutureResult
[09:32:31.703] - Received FutureResult
[09:32:31.703] - Erased future from FutureRegistry
[09:32:31.703] result() for ClusterFuture ...
[09:32:31.704] - result already collected: FutureResult
[09:32:31.704] result() for ClusterFuture ... done
[09:32:31.704] signalConditions() ...
[09:32:31.704]  - include = ‘immediateCondition’
[09:32:31.704]  - exclude = 
[09:32:31.704]  - resignal = FALSE
[09:32:31.704]  - Number of conditions: 1
[09:32:31.704] signalConditions() ... done
[09:32:31.704] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.704] A MultisessionFuture was resolved (and resolved itself)
[09:32:31.704] getGlobalsAndPackages() ...
[09:32:31.705] Searching for globals...
[09:32:31.705] - globals found: [2] ‘list’, ‘stop’
[09:32:31.705] Searching for globals ... DONE
[09:32:31.705] Resolving globals: FALSE
[09:32:31.706] 
[09:32:31.706] 
[09:32:31.706] getGlobalsAndPackages() ... DONE
[09:32:31.706] run() for ‘Future’ ...
[09:32:31.706] - state: ‘created’
[09:32:31.706] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.719] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.720] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.720]   - Field: ‘node’
[09:32:31.720]   - Field: ‘label’
[09:32:31.720]   - Field: ‘local’
[09:32:31.720]   - Field: ‘owner’
[09:32:31.720]   - Field: ‘envir’
[09:32:31.720]   - Field: ‘workers’
[09:32:31.720]   - Field: ‘packages’
[09:32:31.720]   - Field: ‘gc’
[09:32:31.721]   - Field: ‘conditions’
[09:32:31.721]   - Field: ‘persistent’
[09:32:31.721]   - Field: ‘expr’
[09:32:31.721]   - Field: ‘uuid’
[09:32:31.721]   - Field: ‘seed’
[09:32:31.721]   - Field: ‘version’
[09:32:31.721]   - Field: ‘result’
[09:32:31.721]   - Field: ‘asynchronous’
[09:32:31.721]   - Field: ‘calls’
[09:32:31.721]   - Field: ‘globals’
[09:32:31.721]   - Field: ‘stdout’
[09:32:31.721]   - Field: ‘earlySignal’
[09:32:31.722]   - Field: ‘lazy’
[09:32:31.722]   - Field: ‘state’
[09:32:31.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.722] - Launch lazy future ...
[09:32:31.722] Packages needed by the future expression (n = 0): <none>
[09:32:31.722] Packages needed by future strategies (n = 0): <none>
[09:32:31.723] {
[09:32:31.723]     {
[09:32:31.723]         {
[09:32:31.723]             ...future.startTime <- base::Sys.time()
[09:32:31.723]             {
[09:32:31.723]                 {
[09:32:31.723]                   {
[09:32:31.723]                     {
[09:32:31.723]                       base::local({
[09:32:31.723]                         has_future <- base::requireNamespace("future", 
[09:32:31.723]                           quietly = TRUE)
[09:32:31.723]                         if (has_future) {
[09:32:31.723]                           ns <- base::getNamespace("future")
[09:32:31.723]                           version <- ns[[".package"]][["version"]]
[09:32:31.723]                           if (is.null(version)) 
[09:32:31.723]                             version <- utils::packageVersion("future")
[09:32:31.723]                         }
[09:32:31.723]                         else {
[09:32:31.723]                           version <- NULL
[09:32:31.723]                         }
[09:32:31.723]                         if (!has_future || version < "1.8.0") {
[09:32:31.723]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.723]                             "", base::R.version$version.string), 
[09:32:31.723]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.723]                               "release", "version")], collapse = " "), 
[09:32:31.723]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.723]                             info)
[09:32:31.723]                           info <- base::paste(info, collapse = "; ")
[09:32:31.723]                           if (!has_future) {
[09:32:31.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.723]                               info)
[09:32:31.723]                           }
[09:32:31.723]                           else {
[09:32:31.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.723]                               info, version)
[09:32:31.723]                           }
[09:32:31.723]                           base::stop(msg)
[09:32:31.723]                         }
[09:32:31.723]                       })
[09:32:31.723]                     }
[09:32:31.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.723]                     base::options(mc.cores = 1L)
[09:32:31.723]                   }
[09:32:31.723]                   ...future.strategy.old <- future::plan("list")
[09:32:31.723]                   options(future.plan = NULL)
[09:32:31.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.723]                 }
[09:32:31.723]                 ...future.workdir <- getwd()
[09:32:31.723]             }
[09:32:31.723]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.723]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.723]         }
[09:32:31.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.723]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.723]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.723]             base::names(...future.oldOptions))
[09:32:31.723]     }
[09:32:31.723]     if (FALSE) {
[09:32:31.723]     }
[09:32:31.723]     else {
[09:32:31.723]         if (TRUE) {
[09:32:31.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.723]                 open = "w")
[09:32:31.723]         }
[09:32:31.723]         else {
[09:32:31.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.723]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.723]         }
[09:32:31.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.723]             base::sink(type = "output", split = FALSE)
[09:32:31.723]             base::close(...future.stdout)
[09:32:31.723]         }, add = TRUE)
[09:32:31.723]     }
[09:32:31.723]     ...future.frame <- base::sys.nframe()
[09:32:31.723]     ...future.conditions <- base::list()
[09:32:31.723]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.723]     if (FALSE) {
[09:32:31.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.723]     }
[09:32:31.723]     ...future.result <- base::tryCatch({
[09:32:31.723]         base::withCallingHandlers({
[09:32:31.723]             ...future.value <- base::withVisible(base::local({
[09:32:31.723]                 ...future.makeSendCondition <- base::local({
[09:32:31.723]                   sendCondition <- NULL
[09:32:31.723]                   function(frame = 1L) {
[09:32:31.723]                     if (is.function(sendCondition)) 
[09:32:31.723]                       return(sendCondition)
[09:32:31.723]                     ns <- getNamespace("parallel")
[09:32:31.723]                     if (exists("sendData", mode = "function", 
[09:32:31.723]                       envir = ns)) {
[09:32:31.723]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.723]                         envir = ns)
[09:32:31.723]                       envir <- sys.frame(frame)
[09:32:31.723]                       master <- NULL
[09:32:31.723]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.723]                         !identical(envir, emptyenv())) {
[09:32:31.723]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.723]                           inherits = FALSE)) {
[09:32:31.723]                           master <- get("master", mode = "list", 
[09:32:31.723]                             envir = envir, inherits = FALSE)
[09:32:31.723]                           if (inherits(master, c("SOCKnode", 
[09:32:31.723]                             "SOCK0node"))) {
[09:32:31.723]                             sendCondition <<- function(cond) {
[09:32:31.723]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.723]                                 success = TRUE)
[09:32:31.723]                               parallel_sendData(master, data)
[09:32:31.723]                             }
[09:32:31.723]                             return(sendCondition)
[09:32:31.723]                           }
[09:32:31.723]                         }
[09:32:31.723]                         frame <- frame + 1L
[09:32:31.723]                         envir <- sys.frame(frame)
[09:32:31.723]                       }
[09:32:31.723]                     }
[09:32:31.723]                     sendCondition <<- function(cond) NULL
[09:32:31.723]                   }
[09:32:31.723]                 })
[09:32:31.723]                 withCallingHandlers({
[09:32:31.723]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:31.723]                 }, immediateCondition = function(cond) {
[09:32:31.723]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.723]                   sendCondition(cond)
[09:32:31.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.723]                   {
[09:32:31.723]                     inherits <- base::inherits
[09:32:31.723]                     invokeRestart <- base::invokeRestart
[09:32:31.723]                     is.null <- base::is.null
[09:32:31.723]                     muffled <- FALSE
[09:32:31.723]                     if (inherits(cond, "message")) {
[09:32:31.723]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.723]                       if (muffled) 
[09:32:31.723]                         invokeRestart("muffleMessage")
[09:32:31.723]                     }
[09:32:31.723]                     else if (inherits(cond, "warning")) {
[09:32:31.723]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.723]                       if (muffled) 
[09:32:31.723]                         invokeRestart("muffleWarning")
[09:32:31.723]                     }
[09:32:31.723]                     else if (inherits(cond, "condition")) {
[09:32:31.723]                       if (!is.null(pattern)) {
[09:32:31.723]                         computeRestarts <- base::computeRestarts
[09:32:31.723]                         grepl <- base::grepl
[09:32:31.723]                         restarts <- computeRestarts(cond)
[09:32:31.723]                         for (restart in restarts) {
[09:32:31.723]                           name <- restart$name
[09:32:31.723]                           if (is.null(name)) 
[09:32:31.723]                             next
[09:32:31.723]                           if (!grepl(pattern, name)) 
[09:32:31.723]                             next
[09:32:31.723]                           invokeRestart(restart)
[09:32:31.723]                           muffled <- TRUE
[09:32:31.723]                           break
[09:32:31.723]                         }
[09:32:31.723]                       }
[09:32:31.723]                     }
[09:32:31.723]                     invisible(muffled)
[09:32:31.723]                   }
[09:32:31.723]                   muffleCondition(cond)
[09:32:31.723]                 })
[09:32:31.723]             }))
[09:32:31.723]             future::FutureResult(value = ...future.value$value, 
[09:32:31.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.723]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.723]                     ...future.globalenv.names))
[09:32:31.723]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.723]         }, condition = base::local({
[09:32:31.723]             c <- base::c
[09:32:31.723]             inherits <- base::inherits
[09:32:31.723]             invokeRestart <- base::invokeRestart
[09:32:31.723]             length <- base::length
[09:32:31.723]             list <- base::list
[09:32:31.723]             seq.int <- base::seq.int
[09:32:31.723]             signalCondition <- base::signalCondition
[09:32:31.723]             sys.calls <- base::sys.calls
[09:32:31.723]             `[[` <- base::`[[`
[09:32:31.723]             `+` <- base::`+`
[09:32:31.723]             `<<-` <- base::`<<-`
[09:32:31.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.723]                   3L)]
[09:32:31.723]             }
[09:32:31.723]             function(cond) {
[09:32:31.723]                 is_error <- inherits(cond, "error")
[09:32:31.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.723]                   NULL)
[09:32:31.723]                 if (is_error) {
[09:32:31.723]                   sessionInformation <- function() {
[09:32:31.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.723]                       search = base::search(), system = base::Sys.info())
[09:32:31.723]                   }
[09:32:31.723]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.723]                     cond$call), session = sessionInformation(), 
[09:32:31.723]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.723]                   signalCondition(cond)
[09:32:31.723]                 }
[09:32:31.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.723]                 "immediateCondition"))) {
[09:32:31.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.723]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.723]                   if (TRUE && !signal) {
[09:32:31.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.723]                     {
[09:32:31.723]                       inherits <- base::inherits
[09:32:31.723]                       invokeRestart <- base::invokeRestart
[09:32:31.723]                       is.null <- base::is.null
[09:32:31.723]                       muffled <- FALSE
[09:32:31.723]                       if (inherits(cond, "message")) {
[09:32:31.723]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.723]                         if (muffled) 
[09:32:31.723]                           invokeRestart("muffleMessage")
[09:32:31.723]                       }
[09:32:31.723]                       else if (inherits(cond, "warning")) {
[09:32:31.723]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.723]                         if (muffled) 
[09:32:31.723]                           invokeRestart("muffleWarning")
[09:32:31.723]                       }
[09:32:31.723]                       else if (inherits(cond, "condition")) {
[09:32:31.723]                         if (!is.null(pattern)) {
[09:32:31.723]                           computeRestarts <- base::computeRestarts
[09:32:31.723]                           grepl <- base::grepl
[09:32:31.723]                           restarts <- computeRestarts(cond)
[09:32:31.723]                           for (restart in restarts) {
[09:32:31.723]                             name <- restart$name
[09:32:31.723]                             if (is.null(name)) 
[09:32:31.723]                               next
[09:32:31.723]                             if (!grepl(pattern, name)) 
[09:32:31.723]                               next
[09:32:31.723]                             invokeRestart(restart)
[09:32:31.723]                             muffled <- TRUE
[09:32:31.723]                             break
[09:32:31.723]                           }
[09:32:31.723]                         }
[09:32:31.723]                       }
[09:32:31.723]                       invisible(muffled)
[09:32:31.723]                     }
[09:32:31.723]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.723]                   }
[09:32:31.723]                 }
[09:32:31.723]                 else {
[09:32:31.723]                   if (TRUE) {
[09:32:31.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.723]                     {
[09:32:31.723]                       inherits <- base::inherits
[09:32:31.723]                       invokeRestart <- base::invokeRestart
[09:32:31.723]                       is.null <- base::is.null
[09:32:31.723]                       muffled <- FALSE
[09:32:31.723]                       if (inherits(cond, "message")) {
[09:32:31.723]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.723]                         if (muffled) 
[09:32:31.723]                           invokeRestart("muffleMessage")
[09:32:31.723]                       }
[09:32:31.723]                       else if (inherits(cond, "warning")) {
[09:32:31.723]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.723]                         if (muffled) 
[09:32:31.723]                           invokeRestart("muffleWarning")
[09:32:31.723]                       }
[09:32:31.723]                       else if (inherits(cond, "condition")) {
[09:32:31.723]                         if (!is.null(pattern)) {
[09:32:31.723]                           computeRestarts <- base::computeRestarts
[09:32:31.723]                           grepl <- base::grepl
[09:32:31.723]                           restarts <- computeRestarts(cond)
[09:32:31.723]                           for (restart in restarts) {
[09:32:31.723]                             name <- restart$name
[09:32:31.723]                             if (is.null(name)) 
[09:32:31.723]                               next
[09:32:31.723]                             if (!grepl(pattern, name)) 
[09:32:31.723]                               next
[09:32:31.723]                             invokeRestart(restart)
[09:32:31.723]                             muffled <- TRUE
[09:32:31.723]                             break
[09:32:31.723]                           }
[09:32:31.723]                         }
[09:32:31.723]                       }
[09:32:31.723]                       invisible(muffled)
[09:32:31.723]                     }
[09:32:31.723]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.723]                   }
[09:32:31.723]                 }
[09:32:31.723]             }
[09:32:31.723]         }))
[09:32:31.723]     }, error = function(ex) {
[09:32:31.723]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.723]                 ...future.rng), started = ...future.startTime, 
[09:32:31.723]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.723]             version = "1.8"), class = "FutureResult")
[09:32:31.723]     }, finally = {
[09:32:31.723]         if (!identical(...future.workdir, getwd())) 
[09:32:31.723]             setwd(...future.workdir)
[09:32:31.723]         {
[09:32:31.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.723]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.723]             }
[09:32:31.723]             base::options(...future.oldOptions)
[09:32:31.723]             if (.Platform$OS.type == "windows") {
[09:32:31.723]                 old_names <- names(...future.oldEnvVars)
[09:32:31.723]                 envs <- base::Sys.getenv()
[09:32:31.723]                 names <- names(envs)
[09:32:31.723]                 common <- intersect(names, old_names)
[09:32:31.723]                 added <- setdiff(names, old_names)
[09:32:31.723]                 removed <- setdiff(old_names, names)
[09:32:31.723]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.723]                   envs[common]]
[09:32:31.723]                 NAMES <- toupper(changed)
[09:32:31.723]                 args <- list()
[09:32:31.723]                 for (kk in seq_along(NAMES)) {
[09:32:31.723]                   name <- changed[[kk]]
[09:32:31.723]                   NAME <- NAMES[[kk]]
[09:32:31.723]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.723]                     next
[09:32:31.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.723]                 }
[09:32:31.723]                 NAMES <- toupper(added)
[09:32:31.723]                 for (kk in seq_along(NAMES)) {
[09:32:31.723]                   name <- added[[kk]]
[09:32:31.723]                   NAME <- NAMES[[kk]]
[09:32:31.723]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.723]                     next
[09:32:31.723]                   args[[name]] <- ""
[09:32:31.723]                 }
[09:32:31.723]                 NAMES <- toupper(removed)
[09:32:31.723]                 for (kk in seq_along(NAMES)) {
[09:32:31.723]                   name <- removed[[kk]]
[09:32:31.723]                   NAME <- NAMES[[kk]]
[09:32:31.723]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.723]                     next
[09:32:31.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.723]                 }
[09:32:31.723]                 if (length(args) > 0) 
[09:32:31.723]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.723]             }
[09:32:31.723]             else {
[09:32:31.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.723]             }
[09:32:31.723]             {
[09:32:31.723]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.723]                   0L) {
[09:32:31.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.723]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.723]                   base::options(opts)
[09:32:31.723]                 }
[09:32:31.723]                 {
[09:32:31.723]                   {
[09:32:31.723]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.723]                     NULL
[09:32:31.723]                   }
[09:32:31.723]                   options(future.plan = NULL)
[09:32:31.723]                   if (is.na(NA_character_)) 
[09:32:31.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.723]                     .init = FALSE)
[09:32:31.723]                 }
[09:32:31.723]             }
[09:32:31.723]         }
[09:32:31.723]     })
[09:32:31.723]     if (TRUE) {
[09:32:31.723]         base::sink(type = "output", split = FALSE)
[09:32:31.723]         if (TRUE) {
[09:32:31.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.723]         }
[09:32:31.723]         else {
[09:32:31.723]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.723]         }
[09:32:31.723]         base::close(...future.stdout)
[09:32:31.723]         ...future.stdout <- NULL
[09:32:31.723]     }
[09:32:31.723]     ...future.result$conditions <- ...future.conditions
[09:32:31.723]     ...future.result$finished <- base::Sys.time()
[09:32:31.723]     ...future.result
[09:32:31.723] }
[09:32:31.725] MultisessionFuture started
[09:32:31.725] - Launch lazy future ... done
[09:32:31.725] run() for ‘MultisessionFuture’ ... done
[09:32:31.727] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.727] - Validating connection of MultisessionFuture
[09:32:31.727] - received message: FutureResult
[09:32:31.727] - Received FutureResult
[09:32:31.727] - Erased future from FutureRegistry
[09:32:31.728] result() for ClusterFuture ...
[09:32:31.728] - result already collected: FutureResult
[09:32:31.728] result() for ClusterFuture ... done
[09:32:31.728] signalConditions() ...
[09:32:31.728]  - include = ‘immediateCondition’
[09:32:31.728]  - exclude = 
[09:32:31.728]  - resignal = FALSE
[09:32:31.728]  - Number of conditions: 1
[09:32:31.728] signalConditions() ... done
[09:32:31.728] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.729] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[09:32:31.729] getGlobalsAndPackages() ...
[09:32:31.729] Searching for globals...
[09:32:31.730] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:31.730] Searching for globals ... DONE
[09:32:31.730] Resolving globals: FALSE
[09:32:31.730] 
[09:32:31.730] 
[09:32:31.731] getGlobalsAndPackages() ... DONE
[09:32:31.731] run() for ‘Future’ ...
[09:32:31.731] - state: ‘created’
[09:32:31.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.744] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.745]   - Field: ‘node’
[09:32:31.745]   - Field: ‘label’
[09:32:31.745]   - Field: ‘local’
[09:32:31.745]   - Field: ‘owner’
[09:32:31.745]   - Field: ‘envir’
[09:32:31.745]   - Field: ‘workers’
[09:32:31.745]   - Field: ‘packages’
[09:32:31.745]   - Field: ‘gc’
[09:32:31.745]   - Field: ‘conditions’
[09:32:31.745]   - Field: ‘persistent’
[09:32:31.745]   - Field: ‘expr’
[09:32:31.746]   - Field: ‘uuid’
[09:32:31.746]   - Field: ‘seed’
[09:32:31.746]   - Field: ‘version’
[09:32:31.746]   - Field: ‘result’
[09:32:31.746]   - Field: ‘asynchronous’
[09:32:31.746]   - Field: ‘calls’
[09:32:31.746]   - Field: ‘globals’
[09:32:31.746]   - Field: ‘stdout’
[09:32:31.746]   - Field: ‘earlySignal’
[09:32:31.746]   - Field: ‘lazy’
[09:32:31.746]   - Field: ‘state’
[09:32:31.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.747] - Launch lazy future ...
[09:32:31.747] Packages needed by the future expression (n = 0): <none>
[09:32:31.747] Packages needed by future strategies (n = 0): <none>
[09:32:31.747] {
[09:32:31.747]     {
[09:32:31.747]         {
[09:32:31.747]             ...future.startTime <- base::Sys.time()
[09:32:31.747]             {
[09:32:31.747]                 {
[09:32:31.747]                   {
[09:32:31.747]                     {
[09:32:31.747]                       base::local({
[09:32:31.747]                         has_future <- base::requireNamespace("future", 
[09:32:31.747]                           quietly = TRUE)
[09:32:31.747]                         if (has_future) {
[09:32:31.747]                           ns <- base::getNamespace("future")
[09:32:31.747]                           version <- ns[[".package"]][["version"]]
[09:32:31.747]                           if (is.null(version)) 
[09:32:31.747]                             version <- utils::packageVersion("future")
[09:32:31.747]                         }
[09:32:31.747]                         else {
[09:32:31.747]                           version <- NULL
[09:32:31.747]                         }
[09:32:31.747]                         if (!has_future || version < "1.8.0") {
[09:32:31.747]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.747]                             "", base::R.version$version.string), 
[09:32:31.747]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.747]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.747]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.747]                               "release", "version")], collapse = " "), 
[09:32:31.747]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.747]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.747]                             info)
[09:32:31.747]                           info <- base::paste(info, collapse = "; ")
[09:32:31.747]                           if (!has_future) {
[09:32:31.747]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.747]                               info)
[09:32:31.747]                           }
[09:32:31.747]                           else {
[09:32:31.747]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.747]                               info, version)
[09:32:31.747]                           }
[09:32:31.747]                           base::stop(msg)
[09:32:31.747]                         }
[09:32:31.747]                       })
[09:32:31.747]                     }
[09:32:31.747]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.747]                     base::options(mc.cores = 1L)
[09:32:31.747]                   }
[09:32:31.747]                   ...future.strategy.old <- future::plan("list")
[09:32:31.747]                   options(future.plan = NULL)
[09:32:31.747]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.747]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.747]                 }
[09:32:31.747]                 ...future.workdir <- getwd()
[09:32:31.747]             }
[09:32:31.747]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.747]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.747]         }
[09:32:31.747]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.747]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.747]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.747]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.747]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.747]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.747]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.747]             base::names(...future.oldOptions))
[09:32:31.747]     }
[09:32:31.747]     if (FALSE) {
[09:32:31.747]     }
[09:32:31.747]     else {
[09:32:31.747]         if (TRUE) {
[09:32:31.747]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.747]                 open = "w")
[09:32:31.747]         }
[09:32:31.747]         else {
[09:32:31.747]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.747]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.747]         }
[09:32:31.747]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.747]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.747]             base::sink(type = "output", split = FALSE)
[09:32:31.747]             base::close(...future.stdout)
[09:32:31.747]         }, add = TRUE)
[09:32:31.747]     }
[09:32:31.747]     ...future.frame <- base::sys.nframe()
[09:32:31.747]     ...future.conditions <- base::list()
[09:32:31.747]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.747]     if (FALSE) {
[09:32:31.747]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.747]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.747]     }
[09:32:31.747]     ...future.result <- base::tryCatch({
[09:32:31.747]         base::withCallingHandlers({
[09:32:31.747]             ...future.value <- base::withVisible(base::local({
[09:32:31.747]                 ...future.makeSendCondition <- base::local({
[09:32:31.747]                   sendCondition <- NULL
[09:32:31.747]                   function(frame = 1L) {
[09:32:31.747]                     if (is.function(sendCondition)) 
[09:32:31.747]                       return(sendCondition)
[09:32:31.747]                     ns <- getNamespace("parallel")
[09:32:31.747]                     if (exists("sendData", mode = "function", 
[09:32:31.747]                       envir = ns)) {
[09:32:31.747]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.747]                         envir = ns)
[09:32:31.747]                       envir <- sys.frame(frame)
[09:32:31.747]                       master <- NULL
[09:32:31.747]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.747]                         !identical(envir, emptyenv())) {
[09:32:31.747]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.747]                           inherits = FALSE)) {
[09:32:31.747]                           master <- get("master", mode = "list", 
[09:32:31.747]                             envir = envir, inherits = FALSE)
[09:32:31.747]                           if (inherits(master, c("SOCKnode", 
[09:32:31.747]                             "SOCK0node"))) {
[09:32:31.747]                             sendCondition <<- function(cond) {
[09:32:31.747]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.747]                                 success = TRUE)
[09:32:31.747]                               parallel_sendData(master, data)
[09:32:31.747]                             }
[09:32:31.747]                             return(sendCondition)
[09:32:31.747]                           }
[09:32:31.747]                         }
[09:32:31.747]                         frame <- frame + 1L
[09:32:31.747]                         envir <- sys.frame(frame)
[09:32:31.747]                       }
[09:32:31.747]                     }
[09:32:31.747]                     sendCondition <<- function(cond) NULL
[09:32:31.747]                   }
[09:32:31.747]                 })
[09:32:31.747]                 withCallingHandlers({
[09:32:31.747]                   {
[09:32:31.747]                     Sys.sleep(0.5)
[09:32:31.747]                     list(a = 1, b = 42L)
[09:32:31.747]                   }
[09:32:31.747]                 }, immediateCondition = function(cond) {
[09:32:31.747]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.747]                   sendCondition(cond)
[09:32:31.747]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.747]                   {
[09:32:31.747]                     inherits <- base::inherits
[09:32:31.747]                     invokeRestart <- base::invokeRestart
[09:32:31.747]                     is.null <- base::is.null
[09:32:31.747]                     muffled <- FALSE
[09:32:31.747]                     if (inherits(cond, "message")) {
[09:32:31.747]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.747]                       if (muffled) 
[09:32:31.747]                         invokeRestart("muffleMessage")
[09:32:31.747]                     }
[09:32:31.747]                     else if (inherits(cond, "warning")) {
[09:32:31.747]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.747]                       if (muffled) 
[09:32:31.747]                         invokeRestart("muffleWarning")
[09:32:31.747]                     }
[09:32:31.747]                     else if (inherits(cond, "condition")) {
[09:32:31.747]                       if (!is.null(pattern)) {
[09:32:31.747]                         computeRestarts <- base::computeRestarts
[09:32:31.747]                         grepl <- base::grepl
[09:32:31.747]                         restarts <- computeRestarts(cond)
[09:32:31.747]                         for (restart in restarts) {
[09:32:31.747]                           name <- restart$name
[09:32:31.747]                           if (is.null(name)) 
[09:32:31.747]                             next
[09:32:31.747]                           if (!grepl(pattern, name)) 
[09:32:31.747]                             next
[09:32:31.747]                           invokeRestart(restart)
[09:32:31.747]                           muffled <- TRUE
[09:32:31.747]                           break
[09:32:31.747]                         }
[09:32:31.747]                       }
[09:32:31.747]                     }
[09:32:31.747]                     invisible(muffled)
[09:32:31.747]                   }
[09:32:31.747]                   muffleCondition(cond)
[09:32:31.747]                 })
[09:32:31.747]             }))
[09:32:31.747]             future::FutureResult(value = ...future.value$value, 
[09:32:31.747]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.747]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.747]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.747]                     ...future.globalenv.names))
[09:32:31.747]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.747]         }, condition = base::local({
[09:32:31.747]             c <- base::c
[09:32:31.747]             inherits <- base::inherits
[09:32:31.747]             invokeRestart <- base::invokeRestart
[09:32:31.747]             length <- base::length
[09:32:31.747]             list <- base::list
[09:32:31.747]             seq.int <- base::seq.int
[09:32:31.747]             signalCondition <- base::signalCondition
[09:32:31.747]             sys.calls <- base::sys.calls
[09:32:31.747]             `[[` <- base::`[[`
[09:32:31.747]             `+` <- base::`+`
[09:32:31.747]             `<<-` <- base::`<<-`
[09:32:31.747]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.747]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.747]                   3L)]
[09:32:31.747]             }
[09:32:31.747]             function(cond) {
[09:32:31.747]                 is_error <- inherits(cond, "error")
[09:32:31.747]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.747]                   NULL)
[09:32:31.747]                 if (is_error) {
[09:32:31.747]                   sessionInformation <- function() {
[09:32:31.747]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.747]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.747]                       search = base::search(), system = base::Sys.info())
[09:32:31.747]                   }
[09:32:31.747]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.747]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.747]                     cond$call), session = sessionInformation(), 
[09:32:31.747]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.747]                   signalCondition(cond)
[09:32:31.747]                 }
[09:32:31.747]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.747]                 "immediateCondition"))) {
[09:32:31.747]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.747]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.747]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.747]                   if (TRUE && !signal) {
[09:32:31.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.747]                     {
[09:32:31.747]                       inherits <- base::inherits
[09:32:31.747]                       invokeRestart <- base::invokeRestart
[09:32:31.747]                       is.null <- base::is.null
[09:32:31.747]                       muffled <- FALSE
[09:32:31.747]                       if (inherits(cond, "message")) {
[09:32:31.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.747]                         if (muffled) 
[09:32:31.747]                           invokeRestart("muffleMessage")
[09:32:31.747]                       }
[09:32:31.747]                       else if (inherits(cond, "warning")) {
[09:32:31.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.747]                         if (muffled) 
[09:32:31.747]                           invokeRestart("muffleWarning")
[09:32:31.747]                       }
[09:32:31.747]                       else if (inherits(cond, "condition")) {
[09:32:31.747]                         if (!is.null(pattern)) {
[09:32:31.747]                           computeRestarts <- base::computeRestarts
[09:32:31.747]                           grepl <- base::grepl
[09:32:31.747]                           restarts <- computeRestarts(cond)
[09:32:31.747]                           for (restart in restarts) {
[09:32:31.747]                             name <- restart$name
[09:32:31.747]                             if (is.null(name)) 
[09:32:31.747]                               next
[09:32:31.747]                             if (!grepl(pattern, name)) 
[09:32:31.747]                               next
[09:32:31.747]                             invokeRestart(restart)
[09:32:31.747]                             muffled <- TRUE
[09:32:31.747]                             break
[09:32:31.747]                           }
[09:32:31.747]                         }
[09:32:31.747]                       }
[09:32:31.747]                       invisible(muffled)
[09:32:31.747]                     }
[09:32:31.747]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.747]                   }
[09:32:31.747]                 }
[09:32:31.747]                 else {
[09:32:31.747]                   if (TRUE) {
[09:32:31.747]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.747]                     {
[09:32:31.747]                       inherits <- base::inherits
[09:32:31.747]                       invokeRestart <- base::invokeRestart
[09:32:31.747]                       is.null <- base::is.null
[09:32:31.747]                       muffled <- FALSE
[09:32:31.747]                       if (inherits(cond, "message")) {
[09:32:31.747]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.747]                         if (muffled) 
[09:32:31.747]                           invokeRestart("muffleMessage")
[09:32:31.747]                       }
[09:32:31.747]                       else if (inherits(cond, "warning")) {
[09:32:31.747]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.747]                         if (muffled) 
[09:32:31.747]                           invokeRestart("muffleWarning")
[09:32:31.747]                       }
[09:32:31.747]                       else if (inherits(cond, "condition")) {
[09:32:31.747]                         if (!is.null(pattern)) {
[09:32:31.747]                           computeRestarts <- base::computeRestarts
[09:32:31.747]                           grepl <- base::grepl
[09:32:31.747]                           restarts <- computeRestarts(cond)
[09:32:31.747]                           for (restart in restarts) {
[09:32:31.747]                             name <- restart$name
[09:32:31.747]                             if (is.null(name)) 
[09:32:31.747]                               next
[09:32:31.747]                             if (!grepl(pattern, name)) 
[09:32:31.747]                               next
[09:32:31.747]                             invokeRestart(restart)
[09:32:31.747]                             muffled <- TRUE
[09:32:31.747]                             break
[09:32:31.747]                           }
[09:32:31.747]                         }
[09:32:31.747]                       }
[09:32:31.747]                       invisible(muffled)
[09:32:31.747]                     }
[09:32:31.747]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.747]                   }
[09:32:31.747]                 }
[09:32:31.747]             }
[09:32:31.747]         }))
[09:32:31.747]     }, error = function(ex) {
[09:32:31.747]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.747]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.747]                 ...future.rng), started = ...future.startTime, 
[09:32:31.747]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.747]             version = "1.8"), class = "FutureResult")
[09:32:31.747]     }, finally = {
[09:32:31.747]         if (!identical(...future.workdir, getwd())) 
[09:32:31.747]             setwd(...future.workdir)
[09:32:31.747]         {
[09:32:31.747]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.747]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.747]             }
[09:32:31.747]             base::options(...future.oldOptions)
[09:32:31.747]             if (.Platform$OS.type == "windows") {
[09:32:31.747]                 old_names <- names(...future.oldEnvVars)
[09:32:31.747]                 envs <- base::Sys.getenv()
[09:32:31.747]                 names <- names(envs)
[09:32:31.747]                 common <- intersect(names, old_names)
[09:32:31.747]                 added <- setdiff(names, old_names)
[09:32:31.747]                 removed <- setdiff(old_names, names)
[09:32:31.747]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.747]                   envs[common]]
[09:32:31.747]                 NAMES <- toupper(changed)
[09:32:31.747]                 args <- list()
[09:32:31.747]                 for (kk in seq_along(NAMES)) {
[09:32:31.747]                   name <- changed[[kk]]
[09:32:31.747]                   NAME <- NAMES[[kk]]
[09:32:31.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.747]                     next
[09:32:31.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.747]                 }
[09:32:31.747]                 NAMES <- toupper(added)
[09:32:31.747]                 for (kk in seq_along(NAMES)) {
[09:32:31.747]                   name <- added[[kk]]
[09:32:31.747]                   NAME <- NAMES[[kk]]
[09:32:31.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.747]                     next
[09:32:31.747]                   args[[name]] <- ""
[09:32:31.747]                 }
[09:32:31.747]                 NAMES <- toupper(removed)
[09:32:31.747]                 for (kk in seq_along(NAMES)) {
[09:32:31.747]                   name <- removed[[kk]]
[09:32:31.747]                   NAME <- NAMES[[kk]]
[09:32:31.747]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.747]                     next
[09:32:31.747]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.747]                 }
[09:32:31.747]                 if (length(args) > 0) 
[09:32:31.747]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.747]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.747]             }
[09:32:31.747]             else {
[09:32:31.747]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.747]             }
[09:32:31.747]             {
[09:32:31.747]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.747]                   0L) {
[09:32:31.747]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.747]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.747]                   base::options(opts)
[09:32:31.747]                 }
[09:32:31.747]                 {
[09:32:31.747]                   {
[09:32:31.747]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.747]                     NULL
[09:32:31.747]                   }
[09:32:31.747]                   options(future.plan = NULL)
[09:32:31.747]                   if (is.na(NA_character_)) 
[09:32:31.747]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.747]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.747]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.747]                     .init = FALSE)
[09:32:31.747]                 }
[09:32:31.747]             }
[09:32:31.747]         }
[09:32:31.747]     })
[09:32:31.747]     if (TRUE) {
[09:32:31.747]         base::sink(type = "output", split = FALSE)
[09:32:31.747]         if (TRUE) {
[09:32:31.747]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.747]         }
[09:32:31.747]         else {
[09:32:31.747]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.747]         }
[09:32:31.747]         base::close(...future.stdout)
[09:32:31.747]         ...future.stdout <- NULL
[09:32:31.747]     }
[09:32:31.747]     ...future.result$conditions <- ...future.conditions
[09:32:31.747]     ...future.result$finished <- base::Sys.time()
[09:32:31.747]     ...future.result
[09:32:31.747] }
[09:32:31.750] MultisessionFuture started
[09:32:31.750] - Launch lazy future ... done
[09:32:31.750] run() for ‘MultisessionFuture’ ... done
[09:32:31.750] getGlobalsAndPackages() ...
[09:32:31.751] Searching for globals...
[09:32:31.752] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:31.752] Searching for globals ... DONE
[09:32:31.752] Resolving globals: FALSE
[09:32:31.752] 
[09:32:31.752] 
[09:32:31.752] getGlobalsAndPackages() ... DONE
- w/ exception ...
[09:32:31.753] getGlobalsAndPackages() ...
[09:32:31.753] Searching for globals...
[09:32:31.753] - globals found: [2] ‘list’, ‘stop’
[09:32:31.753] Searching for globals ... DONE
[09:32:31.753] Resolving globals: FALSE
[09:32:31.754] 
[09:32:31.754] 
[09:32:31.754] getGlobalsAndPackages() ... DONE
[09:32:31.754] run() for ‘Future’ ...
[09:32:31.754] - state: ‘created’
[09:32:31.754] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.768] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.768]   - Field: ‘node’
[09:32:31.769]   - Field: ‘label’
[09:32:31.769]   - Field: ‘local’
[09:32:31.769]   - Field: ‘owner’
[09:32:31.769]   - Field: ‘envir’
[09:32:31.769]   - Field: ‘workers’
[09:32:31.769]   - Field: ‘packages’
[09:32:31.769]   - Field: ‘gc’
[09:32:31.769]   - Field: ‘conditions’
[09:32:31.769]   - Field: ‘persistent’
[09:32:31.769]   - Field: ‘expr’
[09:32:31.769]   - Field: ‘uuid’
[09:32:31.770]   - Field: ‘seed’
[09:32:31.770]   - Field: ‘version’
[09:32:31.770]   - Field: ‘result’
[09:32:31.770]   - Field: ‘asynchronous’
[09:32:31.770]   - Field: ‘calls’
[09:32:31.770]   - Field: ‘globals’
[09:32:31.770]   - Field: ‘stdout’
[09:32:31.770]   - Field: ‘earlySignal’
[09:32:31.770]   - Field: ‘lazy’
[09:32:31.770]   - Field: ‘state’
[09:32:31.770] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.771] - Launch lazy future ...
[09:32:31.771] Packages needed by the future expression (n = 0): <none>
[09:32:31.771] Packages needed by future strategies (n = 0): <none>
[09:32:31.771] {
[09:32:31.771]     {
[09:32:31.771]         {
[09:32:31.771]             ...future.startTime <- base::Sys.time()
[09:32:31.771]             {
[09:32:31.771]                 {
[09:32:31.771]                   {
[09:32:31.771]                     {
[09:32:31.771]                       base::local({
[09:32:31.771]                         has_future <- base::requireNamespace("future", 
[09:32:31.771]                           quietly = TRUE)
[09:32:31.771]                         if (has_future) {
[09:32:31.771]                           ns <- base::getNamespace("future")
[09:32:31.771]                           version <- ns[[".package"]][["version"]]
[09:32:31.771]                           if (is.null(version)) 
[09:32:31.771]                             version <- utils::packageVersion("future")
[09:32:31.771]                         }
[09:32:31.771]                         else {
[09:32:31.771]                           version <- NULL
[09:32:31.771]                         }
[09:32:31.771]                         if (!has_future || version < "1.8.0") {
[09:32:31.771]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.771]                             "", base::R.version$version.string), 
[09:32:31.771]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.771]                               "release", "version")], collapse = " "), 
[09:32:31.771]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.771]                             info)
[09:32:31.771]                           info <- base::paste(info, collapse = "; ")
[09:32:31.771]                           if (!has_future) {
[09:32:31.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.771]                               info)
[09:32:31.771]                           }
[09:32:31.771]                           else {
[09:32:31.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.771]                               info, version)
[09:32:31.771]                           }
[09:32:31.771]                           base::stop(msg)
[09:32:31.771]                         }
[09:32:31.771]                       })
[09:32:31.771]                     }
[09:32:31.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.771]                     base::options(mc.cores = 1L)
[09:32:31.771]                   }
[09:32:31.771]                   ...future.strategy.old <- future::plan("list")
[09:32:31.771]                   options(future.plan = NULL)
[09:32:31.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.771]                 }
[09:32:31.771]                 ...future.workdir <- getwd()
[09:32:31.771]             }
[09:32:31.771]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.771]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.771]         }
[09:32:31.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.771]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.771]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.771]             base::names(...future.oldOptions))
[09:32:31.771]     }
[09:32:31.771]     if (FALSE) {
[09:32:31.771]     }
[09:32:31.771]     else {
[09:32:31.771]         if (TRUE) {
[09:32:31.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.771]                 open = "w")
[09:32:31.771]         }
[09:32:31.771]         else {
[09:32:31.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.771]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.771]         }
[09:32:31.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.771]             base::sink(type = "output", split = FALSE)
[09:32:31.771]             base::close(...future.stdout)
[09:32:31.771]         }, add = TRUE)
[09:32:31.771]     }
[09:32:31.771]     ...future.frame <- base::sys.nframe()
[09:32:31.771]     ...future.conditions <- base::list()
[09:32:31.771]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.771]     if (FALSE) {
[09:32:31.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.771]     }
[09:32:31.771]     ...future.result <- base::tryCatch({
[09:32:31.771]         base::withCallingHandlers({
[09:32:31.771]             ...future.value <- base::withVisible(base::local({
[09:32:31.771]                 ...future.makeSendCondition <- base::local({
[09:32:31.771]                   sendCondition <- NULL
[09:32:31.771]                   function(frame = 1L) {
[09:32:31.771]                     if (is.function(sendCondition)) 
[09:32:31.771]                       return(sendCondition)
[09:32:31.771]                     ns <- getNamespace("parallel")
[09:32:31.771]                     if (exists("sendData", mode = "function", 
[09:32:31.771]                       envir = ns)) {
[09:32:31.771]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.771]                         envir = ns)
[09:32:31.771]                       envir <- sys.frame(frame)
[09:32:31.771]                       master <- NULL
[09:32:31.771]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.771]                         !identical(envir, emptyenv())) {
[09:32:31.771]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.771]                           inherits = FALSE)) {
[09:32:31.771]                           master <- get("master", mode = "list", 
[09:32:31.771]                             envir = envir, inherits = FALSE)
[09:32:31.771]                           if (inherits(master, c("SOCKnode", 
[09:32:31.771]                             "SOCK0node"))) {
[09:32:31.771]                             sendCondition <<- function(cond) {
[09:32:31.771]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.771]                                 success = TRUE)
[09:32:31.771]                               parallel_sendData(master, data)
[09:32:31.771]                             }
[09:32:31.771]                             return(sendCondition)
[09:32:31.771]                           }
[09:32:31.771]                         }
[09:32:31.771]                         frame <- frame + 1L
[09:32:31.771]                         envir <- sys.frame(frame)
[09:32:31.771]                       }
[09:32:31.771]                     }
[09:32:31.771]                     sendCondition <<- function(cond) NULL
[09:32:31.771]                   }
[09:32:31.771]                 })
[09:32:31.771]                 withCallingHandlers({
[09:32:31.771]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:31.771]                 }, immediateCondition = function(cond) {
[09:32:31.771]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.771]                   sendCondition(cond)
[09:32:31.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.771]                   {
[09:32:31.771]                     inherits <- base::inherits
[09:32:31.771]                     invokeRestart <- base::invokeRestart
[09:32:31.771]                     is.null <- base::is.null
[09:32:31.771]                     muffled <- FALSE
[09:32:31.771]                     if (inherits(cond, "message")) {
[09:32:31.771]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.771]                       if (muffled) 
[09:32:31.771]                         invokeRestart("muffleMessage")
[09:32:31.771]                     }
[09:32:31.771]                     else if (inherits(cond, "warning")) {
[09:32:31.771]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.771]                       if (muffled) 
[09:32:31.771]                         invokeRestart("muffleWarning")
[09:32:31.771]                     }
[09:32:31.771]                     else if (inherits(cond, "condition")) {
[09:32:31.771]                       if (!is.null(pattern)) {
[09:32:31.771]                         computeRestarts <- base::computeRestarts
[09:32:31.771]                         grepl <- base::grepl
[09:32:31.771]                         restarts <- computeRestarts(cond)
[09:32:31.771]                         for (restart in restarts) {
[09:32:31.771]                           name <- restart$name
[09:32:31.771]                           if (is.null(name)) 
[09:32:31.771]                             next
[09:32:31.771]                           if (!grepl(pattern, name)) 
[09:32:31.771]                             next
[09:32:31.771]                           invokeRestart(restart)
[09:32:31.771]                           muffled <- TRUE
[09:32:31.771]                           break
[09:32:31.771]                         }
[09:32:31.771]                       }
[09:32:31.771]                     }
[09:32:31.771]                     invisible(muffled)
[09:32:31.771]                   }
[09:32:31.771]                   muffleCondition(cond)
[09:32:31.771]                 })
[09:32:31.771]             }))
[09:32:31.771]             future::FutureResult(value = ...future.value$value, 
[09:32:31.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.771]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.771]                     ...future.globalenv.names))
[09:32:31.771]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.771]         }, condition = base::local({
[09:32:31.771]             c <- base::c
[09:32:31.771]             inherits <- base::inherits
[09:32:31.771]             invokeRestart <- base::invokeRestart
[09:32:31.771]             length <- base::length
[09:32:31.771]             list <- base::list
[09:32:31.771]             seq.int <- base::seq.int
[09:32:31.771]             signalCondition <- base::signalCondition
[09:32:31.771]             sys.calls <- base::sys.calls
[09:32:31.771]             `[[` <- base::`[[`
[09:32:31.771]             `+` <- base::`+`
[09:32:31.771]             `<<-` <- base::`<<-`
[09:32:31.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.771]                   3L)]
[09:32:31.771]             }
[09:32:31.771]             function(cond) {
[09:32:31.771]                 is_error <- inherits(cond, "error")
[09:32:31.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.771]                   NULL)
[09:32:31.771]                 if (is_error) {
[09:32:31.771]                   sessionInformation <- function() {
[09:32:31.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.771]                       search = base::search(), system = base::Sys.info())
[09:32:31.771]                   }
[09:32:31.771]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.771]                     cond$call), session = sessionInformation(), 
[09:32:31.771]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.771]                   signalCondition(cond)
[09:32:31.771]                 }
[09:32:31.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.771]                 "immediateCondition"))) {
[09:32:31.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.771]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.771]                   if (TRUE && !signal) {
[09:32:31.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.771]                     {
[09:32:31.771]                       inherits <- base::inherits
[09:32:31.771]                       invokeRestart <- base::invokeRestart
[09:32:31.771]                       is.null <- base::is.null
[09:32:31.771]                       muffled <- FALSE
[09:32:31.771]                       if (inherits(cond, "message")) {
[09:32:31.771]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.771]                         if (muffled) 
[09:32:31.771]                           invokeRestart("muffleMessage")
[09:32:31.771]                       }
[09:32:31.771]                       else if (inherits(cond, "warning")) {
[09:32:31.771]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.771]                         if (muffled) 
[09:32:31.771]                           invokeRestart("muffleWarning")
[09:32:31.771]                       }
[09:32:31.771]                       else if (inherits(cond, "condition")) {
[09:32:31.771]                         if (!is.null(pattern)) {
[09:32:31.771]                           computeRestarts <- base::computeRestarts
[09:32:31.771]                           grepl <- base::grepl
[09:32:31.771]                           restarts <- computeRestarts(cond)
[09:32:31.771]                           for (restart in restarts) {
[09:32:31.771]                             name <- restart$name
[09:32:31.771]                             if (is.null(name)) 
[09:32:31.771]                               next
[09:32:31.771]                             if (!grepl(pattern, name)) 
[09:32:31.771]                               next
[09:32:31.771]                             invokeRestart(restart)
[09:32:31.771]                             muffled <- TRUE
[09:32:31.771]                             break
[09:32:31.771]                           }
[09:32:31.771]                         }
[09:32:31.771]                       }
[09:32:31.771]                       invisible(muffled)
[09:32:31.771]                     }
[09:32:31.771]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.771]                   }
[09:32:31.771]                 }
[09:32:31.771]                 else {
[09:32:31.771]                   if (TRUE) {
[09:32:31.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.771]                     {
[09:32:31.771]                       inherits <- base::inherits
[09:32:31.771]                       invokeRestart <- base::invokeRestart
[09:32:31.771]                       is.null <- base::is.null
[09:32:31.771]                       muffled <- FALSE
[09:32:31.771]                       if (inherits(cond, "message")) {
[09:32:31.771]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.771]                         if (muffled) 
[09:32:31.771]                           invokeRestart("muffleMessage")
[09:32:31.771]                       }
[09:32:31.771]                       else if (inherits(cond, "warning")) {
[09:32:31.771]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.771]                         if (muffled) 
[09:32:31.771]                           invokeRestart("muffleWarning")
[09:32:31.771]                       }
[09:32:31.771]                       else if (inherits(cond, "condition")) {
[09:32:31.771]                         if (!is.null(pattern)) {
[09:32:31.771]                           computeRestarts <- base::computeRestarts
[09:32:31.771]                           grepl <- base::grepl
[09:32:31.771]                           restarts <- computeRestarts(cond)
[09:32:31.771]                           for (restart in restarts) {
[09:32:31.771]                             name <- restart$name
[09:32:31.771]                             if (is.null(name)) 
[09:32:31.771]                               next
[09:32:31.771]                             if (!grepl(pattern, name)) 
[09:32:31.771]                               next
[09:32:31.771]                             invokeRestart(restart)
[09:32:31.771]                             muffled <- TRUE
[09:32:31.771]                             break
[09:32:31.771]                           }
[09:32:31.771]                         }
[09:32:31.771]                       }
[09:32:31.771]                       invisible(muffled)
[09:32:31.771]                     }
[09:32:31.771]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.771]                   }
[09:32:31.771]                 }
[09:32:31.771]             }
[09:32:31.771]         }))
[09:32:31.771]     }, error = function(ex) {
[09:32:31.771]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.771]                 ...future.rng), started = ...future.startTime, 
[09:32:31.771]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.771]             version = "1.8"), class = "FutureResult")
[09:32:31.771]     }, finally = {
[09:32:31.771]         if (!identical(...future.workdir, getwd())) 
[09:32:31.771]             setwd(...future.workdir)
[09:32:31.771]         {
[09:32:31.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.771]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.771]             }
[09:32:31.771]             base::options(...future.oldOptions)
[09:32:31.771]             if (.Platform$OS.type == "windows") {
[09:32:31.771]                 old_names <- names(...future.oldEnvVars)
[09:32:31.771]                 envs <- base::Sys.getenv()
[09:32:31.771]                 names <- names(envs)
[09:32:31.771]                 common <- intersect(names, old_names)
[09:32:31.771]                 added <- setdiff(names, old_names)
[09:32:31.771]                 removed <- setdiff(old_names, names)
[09:32:31.771]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.771]                   envs[common]]
[09:32:31.771]                 NAMES <- toupper(changed)
[09:32:31.771]                 args <- list()
[09:32:31.771]                 for (kk in seq_along(NAMES)) {
[09:32:31.771]                   name <- changed[[kk]]
[09:32:31.771]                   NAME <- NAMES[[kk]]
[09:32:31.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.771]                     next
[09:32:31.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.771]                 }
[09:32:31.771]                 NAMES <- toupper(added)
[09:32:31.771]                 for (kk in seq_along(NAMES)) {
[09:32:31.771]                   name <- added[[kk]]
[09:32:31.771]                   NAME <- NAMES[[kk]]
[09:32:31.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.771]                     next
[09:32:31.771]                   args[[name]] <- ""
[09:32:31.771]                 }
[09:32:31.771]                 NAMES <- toupper(removed)
[09:32:31.771]                 for (kk in seq_along(NAMES)) {
[09:32:31.771]                   name <- removed[[kk]]
[09:32:31.771]                   NAME <- NAMES[[kk]]
[09:32:31.771]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.771]                     next
[09:32:31.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.771]                 }
[09:32:31.771]                 if (length(args) > 0) 
[09:32:31.771]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.771]             }
[09:32:31.771]             else {
[09:32:31.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.771]             }
[09:32:31.771]             {
[09:32:31.771]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.771]                   0L) {
[09:32:31.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.771]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.771]                   base::options(opts)
[09:32:31.771]                 }
[09:32:31.771]                 {
[09:32:31.771]                   {
[09:32:31.771]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.771]                     NULL
[09:32:31.771]                   }
[09:32:31.771]                   options(future.plan = NULL)
[09:32:31.771]                   if (is.na(NA_character_)) 
[09:32:31.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.771]                     .init = FALSE)
[09:32:31.771]                 }
[09:32:31.771]             }
[09:32:31.771]         }
[09:32:31.771]     })
[09:32:31.771]     if (TRUE) {
[09:32:31.771]         base::sink(type = "output", split = FALSE)
[09:32:31.771]         if (TRUE) {
[09:32:31.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.771]         }
[09:32:31.771]         else {
[09:32:31.771]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.771]         }
[09:32:31.771]         base::close(...future.stdout)
[09:32:31.771]         ...future.stdout <- NULL
[09:32:31.771]     }
[09:32:31.771]     ...future.result$conditions <- ...future.conditions
[09:32:31.771]     ...future.result$finished <- base::Sys.time()
[09:32:31.771]     ...future.result
[09:32:31.771] }
[09:32:31.773] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:31.784] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.784] - Validating connection of MultisessionFuture
[09:32:31.784] - received message: FutureResult
[09:32:31.785] - Received FutureResult
[09:32:31.785] - Erased future from FutureRegistry
[09:32:31.785] result() for ClusterFuture ...
[09:32:31.785] - result already collected: FutureResult
[09:32:31.785] result() for ClusterFuture ... done
[09:32:31.785] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.785] result() for ClusterFuture ...
[09:32:31.785] - result already collected: FutureResult
[09:32:31.785] result() for ClusterFuture ... done
[09:32:31.785] result() for ClusterFuture ...
[09:32:31.785] - result already collected: FutureResult
[09:32:31.785] result() for ClusterFuture ... done
[09:32:31.786] MultisessionFuture started
[09:32:31.787] - Launch lazy future ... done
[09:32:31.787] run() for ‘MultisessionFuture’ ... done
[09:32:31.787] getGlobalsAndPackages() ...
[09:32:31.787] Searching for globals...
[09:32:31.787] - globals found: [2] ‘list’, ‘stop’
[09:32:31.788] Searching for globals ... DONE
[09:32:31.788] Resolving globals: FALSE
[09:32:31.788] 
[09:32:31.788] 
[09:32:31.788] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[09:32:31.789] getGlobalsAndPackages() ...
[09:32:31.789] Searching for globals...
[09:32:31.790] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:31.790] Searching for globals ... DONE
[09:32:31.790] Resolving globals: FALSE
[09:32:31.790] 
[09:32:31.790] 
[09:32:31.790] getGlobalsAndPackages() ... DONE
[09:32:31.791] run() for ‘Future’ ...
[09:32:31.791] - state: ‘created’
[09:32:31.791] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:31.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:31.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:31.804]   - Field: ‘node’
[09:32:31.804]   - Field: ‘label’
[09:32:31.805]   - Field: ‘local’
[09:32:31.805]   - Field: ‘owner’
[09:32:31.805]   - Field: ‘envir’
[09:32:31.805]   - Field: ‘workers’
[09:32:31.805]   - Field: ‘packages’
[09:32:31.805]   - Field: ‘gc’
[09:32:31.805]   - Field: ‘conditions’
[09:32:31.805]   - Field: ‘persistent’
[09:32:31.805]   - Field: ‘expr’
[09:32:31.805]   - Field: ‘uuid’
[09:32:31.805]   - Field: ‘seed’
[09:32:31.806]   - Field: ‘version’
[09:32:31.806]   - Field: ‘result’
[09:32:31.806]   - Field: ‘asynchronous’
[09:32:31.806]   - Field: ‘calls’
[09:32:31.806]   - Field: ‘globals’
[09:32:31.806]   - Field: ‘stdout’
[09:32:31.806]   - Field: ‘earlySignal’
[09:32:31.806]   - Field: ‘lazy’
[09:32:31.806]   - Field: ‘state’
[09:32:31.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:31.807] - Launch lazy future ...
[09:32:31.807] Packages needed by the future expression (n = 0): <none>
[09:32:31.807] Packages needed by future strategies (n = 0): <none>
[09:32:31.807] {
[09:32:31.807]     {
[09:32:31.807]         {
[09:32:31.807]             ...future.startTime <- base::Sys.time()
[09:32:31.807]             {
[09:32:31.807]                 {
[09:32:31.807]                   {
[09:32:31.807]                     {
[09:32:31.807]                       base::local({
[09:32:31.807]                         has_future <- base::requireNamespace("future", 
[09:32:31.807]                           quietly = TRUE)
[09:32:31.807]                         if (has_future) {
[09:32:31.807]                           ns <- base::getNamespace("future")
[09:32:31.807]                           version <- ns[[".package"]][["version"]]
[09:32:31.807]                           if (is.null(version)) 
[09:32:31.807]                             version <- utils::packageVersion("future")
[09:32:31.807]                         }
[09:32:31.807]                         else {
[09:32:31.807]                           version <- NULL
[09:32:31.807]                         }
[09:32:31.807]                         if (!has_future || version < "1.8.0") {
[09:32:31.807]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:31.807]                             "", base::R.version$version.string), 
[09:32:31.807]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:31.807]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:31.807]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:31.807]                               "release", "version")], collapse = " "), 
[09:32:31.807]                             hostname = base::Sys.info()[["nodename"]])
[09:32:31.807]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:31.807]                             info)
[09:32:31.807]                           info <- base::paste(info, collapse = "; ")
[09:32:31.807]                           if (!has_future) {
[09:32:31.807]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:31.807]                               info)
[09:32:31.807]                           }
[09:32:31.807]                           else {
[09:32:31.807]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:31.807]                               info, version)
[09:32:31.807]                           }
[09:32:31.807]                           base::stop(msg)
[09:32:31.807]                         }
[09:32:31.807]                       })
[09:32:31.807]                     }
[09:32:31.807]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:31.807]                     base::options(mc.cores = 1L)
[09:32:31.807]                   }
[09:32:31.807]                   ...future.strategy.old <- future::plan("list")
[09:32:31.807]                   options(future.plan = NULL)
[09:32:31.807]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.807]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:31.807]                 }
[09:32:31.807]                 ...future.workdir <- getwd()
[09:32:31.807]             }
[09:32:31.807]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:31.807]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:31.807]         }
[09:32:31.807]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:31.807]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:31.807]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:31.807]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:31.807]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:31.807]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:31.807]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:31.807]             base::names(...future.oldOptions))
[09:32:31.807]     }
[09:32:31.807]     if (FALSE) {
[09:32:31.807]     }
[09:32:31.807]     else {
[09:32:31.807]         if (TRUE) {
[09:32:31.807]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:31.807]                 open = "w")
[09:32:31.807]         }
[09:32:31.807]         else {
[09:32:31.807]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:31.807]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:31.807]         }
[09:32:31.807]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:31.807]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:31.807]             base::sink(type = "output", split = FALSE)
[09:32:31.807]             base::close(...future.stdout)
[09:32:31.807]         }, add = TRUE)
[09:32:31.807]     }
[09:32:31.807]     ...future.frame <- base::sys.nframe()
[09:32:31.807]     ...future.conditions <- base::list()
[09:32:31.807]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:31.807]     if (FALSE) {
[09:32:31.807]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:31.807]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:31.807]     }
[09:32:31.807]     ...future.result <- base::tryCatch({
[09:32:31.807]         base::withCallingHandlers({
[09:32:31.807]             ...future.value <- base::withVisible(base::local({
[09:32:31.807]                 ...future.makeSendCondition <- base::local({
[09:32:31.807]                   sendCondition <- NULL
[09:32:31.807]                   function(frame = 1L) {
[09:32:31.807]                     if (is.function(sendCondition)) 
[09:32:31.807]                       return(sendCondition)
[09:32:31.807]                     ns <- getNamespace("parallel")
[09:32:31.807]                     if (exists("sendData", mode = "function", 
[09:32:31.807]                       envir = ns)) {
[09:32:31.807]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:31.807]                         envir = ns)
[09:32:31.807]                       envir <- sys.frame(frame)
[09:32:31.807]                       master <- NULL
[09:32:31.807]                       while (!identical(envir, .GlobalEnv) && 
[09:32:31.807]                         !identical(envir, emptyenv())) {
[09:32:31.807]                         if (exists("master", mode = "list", envir = envir, 
[09:32:31.807]                           inherits = FALSE)) {
[09:32:31.807]                           master <- get("master", mode = "list", 
[09:32:31.807]                             envir = envir, inherits = FALSE)
[09:32:31.807]                           if (inherits(master, c("SOCKnode", 
[09:32:31.807]                             "SOCK0node"))) {
[09:32:31.807]                             sendCondition <<- function(cond) {
[09:32:31.807]                               data <- list(type = "VALUE", value = cond, 
[09:32:31.807]                                 success = TRUE)
[09:32:31.807]                               parallel_sendData(master, data)
[09:32:31.807]                             }
[09:32:31.807]                             return(sendCondition)
[09:32:31.807]                           }
[09:32:31.807]                         }
[09:32:31.807]                         frame <- frame + 1L
[09:32:31.807]                         envir <- sys.frame(frame)
[09:32:31.807]                       }
[09:32:31.807]                     }
[09:32:31.807]                     sendCondition <<- function(cond) NULL
[09:32:31.807]                   }
[09:32:31.807]                 })
[09:32:31.807]                 withCallingHandlers({
[09:32:31.807]                   {
[09:32:31.807]                     Sys.sleep(0.5)
[09:32:31.807]                     list(a = 1, b = 42L)
[09:32:31.807]                   }
[09:32:31.807]                 }, immediateCondition = function(cond) {
[09:32:31.807]                   sendCondition <- ...future.makeSendCondition()
[09:32:31.807]                   sendCondition(cond)
[09:32:31.807]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.807]                   {
[09:32:31.807]                     inherits <- base::inherits
[09:32:31.807]                     invokeRestart <- base::invokeRestart
[09:32:31.807]                     is.null <- base::is.null
[09:32:31.807]                     muffled <- FALSE
[09:32:31.807]                     if (inherits(cond, "message")) {
[09:32:31.807]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:31.807]                       if (muffled) 
[09:32:31.807]                         invokeRestart("muffleMessage")
[09:32:31.807]                     }
[09:32:31.807]                     else if (inherits(cond, "warning")) {
[09:32:31.807]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:31.807]                       if (muffled) 
[09:32:31.807]                         invokeRestart("muffleWarning")
[09:32:31.807]                     }
[09:32:31.807]                     else if (inherits(cond, "condition")) {
[09:32:31.807]                       if (!is.null(pattern)) {
[09:32:31.807]                         computeRestarts <- base::computeRestarts
[09:32:31.807]                         grepl <- base::grepl
[09:32:31.807]                         restarts <- computeRestarts(cond)
[09:32:31.807]                         for (restart in restarts) {
[09:32:31.807]                           name <- restart$name
[09:32:31.807]                           if (is.null(name)) 
[09:32:31.807]                             next
[09:32:31.807]                           if (!grepl(pattern, name)) 
[09:32:31.807]                             next
[09:32:31.807]                           invokeRestart(restart)
[09:32:31.807]                           muffled <- TRUE
[09:32:31.807]                           break
[09:32:31.807]                         }
[09:32:31.807]                       }
[09:32:31.807]                     }
[09:32:31.807]                     invisible(muffled)
[09:32:31.807]                   }
[09:32:31.807]                   muffleCondition(cond)
[09:32:31.807]                 })
[09:32:31.807]             }))
[09:32:31.807]             future::FutureResult(value = ...future.value$value, 
[09:32:31.807]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.807]                   ...future.rng), globalenv = if (FALSE) 
[09:32:31.807]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:31.807]                     ...future.globalenv.names))
[09:32:31.807]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:31.807]         }, condition = base::local({
[09:32:31.807]             c <- base::c
[09:32:31.807]             inherits <- base::inherits
[09:32:31.807]             invokeRestart <- base::invokeRestart
[09:32:31.807]             length <- base::length
[09:32:31.807]             list <- base::list
[09:32:31.807]             seq.int <- base::seq.int
[09:32:31.807]             signalCondition <- base::signalCondition
[09:32:31.807]             sys.calls <- base::sys.calls
[09:32:31.807]             `[[` <- base::`[[`
[09:32:31.807]             `+` <- base::`+`
[09:32:31.807]             `<<-` <- base::`<<-`
[09:32:31.807]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:31.807]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:31.807]                   3L)]
[09:32:31.807]             }
[09:32:31.807]             function(cond) {
[09:32:31.807]                 is_error <- inherits(cond, "error")
[09:32:31.807]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:31.807]                   NULL)
[09:32:31.807]                 if (is_error) {
[09:32:31.807]                   sessionInformation <- function() {
[09:32:31.807]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:31.807]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:31.807]                       search = base::search(), system = base::Sys.info())
[09:32:31.807]                   }
[09:32:31.807]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.807]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:31.807]                     cond$call), session = sessionInformation(), 
[09:32:31.807]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:31.807]                   signalCondition(cond)
[09:32:31.807]                 }
[09:32:31.807]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:31.807]                 "immediateCondition"))) {
[09:32:31.807]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:31.807]                   ...future.conditions[[length(...future.conditions) + 
[09:32:31.807]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:31.807]                   if (TRUE && !signal) {
[09:32:31.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.807]                     {
[09:32:31.807]                       inherits <- base::inherits
[09:32:31.807]                       invokeRestart <- base::invokeRestart
[09:32:31.807]                       is.null <- base::is.null
[09:32:31.807]                       muffled <- FALSE
[09:32:31.807]                       if (inherits(cond, "message")) {
[09:32:31.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.807]                         if (muffled) 
[09:32:31.807]                           invokeRestart("muffleMessage")
[09:32:31.807]                       }
[09:32:31.807]                       else if (inherits(cond, "warning")) {
[09:32:31.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.807]                         if (muffled) 
[09:32:31.807]                           invokeRestart("muffleWarning")
[09:32:31.807]                       }
[09:32:31.807]                       else if (inherits(cond, "condition")) {
[09:32:31.807]                         if (!is.null(pattern)) {
[09:32:31.807]                           computeRestarts <- base::computeRestarts
[09:32:31.807]                           grepl <- base::grepl
[09:32:31.807]                           restarts <- computeRestarts(cond)
[09:32:31.807]                           for (restart in restarts) {
[09:32:31.807]                             name <- restart$name
[09:32:31.807]                             if (is.null(name)) 
[09:32:31.807]                               next
[09:32:31.807]                             if (!grepl(pattern, name)) 
[09:32:31.807]                               next
[09:32:31.807]                             invokeRestart(restart)
[09:32:31.807]                             muffled <- TRUE
[09:32:31.807]                             break
[09:32:31.807]                           }
[09:32:31.807]                         }
[09:32:31.807]                       }
[09:32:31.807]                       invisible(muffled)
[09:32:31.807]                     }
[09:32:31.807]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.807]                   }
[09:32:31.807]                 }
[09:32:31.807]                 else {
[09:32:31.807]                   if (TRUE) {
[09:32:31.807]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:31.807]                     {
[09:32:31.807]                       inherits <- base::inherits
[09:32:31.807]                       invokeRestart <- base::invokeRestart
[09:32:31.807]                       is.null <- base::is.null
[09:32:31.807]                       muffled <- FALSE
[09:32:31.807]                       if (inherits(cond, "message")) {
[09:32:31.807]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:31.807]                         if (muffled) 
[09:32:31.807]                           invokeRestart("muffleMessage")
[09:32:31.807]                       }
[09:32:31.807]                       else if (inherits(cond, "warning")) {
[09:32:31.807]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:31.807]                         if (muffled) 
[09:32:31.807]                           invokeRestart("muffleWarning")
[09:32:31.807]                       }
[09:32:31.807]                       else if (inherits(cond, "condition")) {
[09:32:31.807]                         if (!is.null(pattern)) {
[09:32:31.807]                           computeRestarts <- base::computeRestarts
[09:32:31.807]                           grepl <- base::grepl
[09:32:31.807]                           restarts <- computeRestarts(cond)
[09:32:31.807]                           for (restart in restarts) {
[09:32:31.807]                             name <- restart$name
[09:32:31.807]                             if (is.null(name)) 
[09:32:31.807]                               next
[09:32:31.807]                             if (!grepl(pattern, name)) 
[09:32:31.807]                               next
[09:32:31.807]                             invokeRestart(restart)
[09:32:31.807]                             muffled <- TRUE
[09:32:31.807]                             break
[09:32:31.807]                           }
[09:32:31.807]                         }
[09:32:31.807]                       }
[09:32:31.807]                       invisible(muffled)
[09:32:31.807]                     }
[09:32:31.807]                     muffleCondition(cond, pattern = "^muffle")
[09:32:31.807]                   }
[09:32:31.807]                 }
[09:32:31.807]             }
[09:32:31.807]         }))
[09:32:31.807]     }, error = function(ex) {
[09:32:31.807]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:31.807]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:31.807]                 ...future.rng), started = ...future.startTime, 
[09:32:31.807]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:31.807]             version = "1.8"), class = "FutureResult")
[09:32:31.807]     }, finally = {
[09:32:31.807]         if (!identical(...future.workdir, getwd())) 
[09:32:31.807]             setwd(...future.workdir)
[09:32:31.807]         {
[09:32:31.807]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:31.807]                 ...future.oldOptions$nwarnings <- NULL
[09:32:31.807]             }
[09:32:31.807]             base::options(...future.oldOptions)
[09:32:31.807]             if (.Platform$OS.type == "windows") {
[09:32:31.807]                 old_names <- names(...future.oldEnvVars)
[09:32:31.807]                 envs <- base::Sys.getenv()
[09:32:31.807]                 names <- names(envs)
[09:32:31.807]                 common <- intersect(names, old_names)
[09:32:31.807]                 added <- setdiff(names, old_names)
[09:32:31.807]                 removed <- setdiff(old_names, names)
[09:32:31.807]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:31.807]                   envs[common]]
[09:32:31.807]                 NAMES <- toupper(changed)
[09:32:31.807]                 args <- list()
[09:32:31.807]                 for (kk in seq_along(NAMES)) {
[09:32:31.807]                   name <- changed[[kk]]
[09:32:31.807]                   NAME <- NAMES[[kk]]
[09:32:31.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.807]                     next
[09:32:31.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.807]                 }
[09:32:31.807]                 NAMES <- toupper(added)
[09:32:31.807]                 for (kk in seq_along(NAMES)) {
[09:32:31.807]                   name <- added[[kk]]
[09:32:31.807]                   NAME <- NAMES[[kk]]
[09:32:31.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.807]                     next
[09:32:31.807]                   args[[name]] <- ""
[09:32:31.807]                 }
[09:32:31.807]                 NAMES <- toupper(removed)
[09:32:31.807]                 for (kk in seq_along(NAMES)) {
[09:32:31.807]                   name <- removed[[kk]]
[09:32:31.807]                   NAME <- NAMES[[kk]]
[09:32:31.807]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:31.807]                     next
[09:32:31.807]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:31.807]                 }
[09:32:31.807]                 if (length(args) > 0) 
[09:32:31.807]                   base::do.call(base::Sys.setenv, args = args)
[09:32:31.807]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:31.807]             }
[09:32:31.807]             else {
[09:32:31.807]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:31.807]             }
[09:32:31.807]             {
[09:32:31.807]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:31.807]                   0L) {
[09:32:31.807]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:31.807]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:31.807]                   base::options(opts)
[09:32:31.807]                 }
[09:32:31.807]                 {
[09:32:31.807]                   {
[09:32:31.807]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:31.807]                     NULL
[09:32:31.807]                   }
[09:32:31.807]                   options(future.plan = NULL)
[09:32:31.807]                   if (is.na(NA_character_)) 
[09:32:31.807]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:31.807]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:31.807]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:31.807]                     .init = FALSE)
[09:32:31.807]                 }
[09:32:31.807]             }
[09:32:31.807]         }
[09:32:31.807]     })
[09:32:31.807]     if (TRUE) {
[09:32:31.807]         base::sink(type = "output", split = FALSE)
[09:32:31.807]         if (TRUE) {
[09:32:31.807]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:31.807]         }
[09:32:31.807]         else {
[09:32:31.807]             ...future.result["stdout"] <- base::list(NULL)
[09:32:31.807]         }
[09:32:31.807]         base::close(...future.stdout)
[09:32:31.807]         ...future.stdout <- NULL
[09:32:31.807]     }
[09:32:31.807]     ...future.result$conditions <- ...future.conditions
[09:32:31.807]     ...future.result$finished <- base::Sys.time()
[09:32:31.807]     ...future.result
[09:32:31.807] }
[09:32:31.809] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:31.831] receiveMessageFromWorker() for ClusterFuture ...
[09:32:31.831] - Validating connection of MultisessionFuture
[09:32:31.831] - received message: FutureResult
[09:32:31.831] - Received FutureResult
[09:32:31.832] - Erased future from FutureRegistry
[09:32:31.832] result() for ClusterFuture ...
[09:32:31.832] - result already collected: FutureResult
[09:32:31.832] result() for ClusterFuture ... done
[09:32:31.832] signalConditions() ...
[09:32:31.832]  - include = ‘immediateCondition’
[09:32:31.832]  - exclude = 
[09:32:31.832]  - resignal = FALSE
[09:32:31.832]  - Number of conditions: 1
[09:32:31.832] signalConditions() ... done
[09:32:31.832] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:31.833] result() for ClusterFuture ...
[09:32:31.833] - result already collected: FutureResult
[09:32:31.833] result() for ClusterFuture ... done
[09:32:31.833] result() for ClusterFuture ...
[09:32:31.833] - result already collected: FutureResult
[09:32:31.833] result() for ClusterFuture ... done
[09:32:31.833] signalConditions() ...
[09:32:31.833]  - include = ‘immediateCondition’
[09:32:31.833]  - exclude = 
[09:32:31.833]  - resignal = FALSE
[09:32:31.833]  - Number of conditions: 1
[09:32:31.833] signalConditions() ... done
[09:32:31.834] MultisessionFuture started
[09:32:31.834] - Launch lazy future ... done
[09:32:31.835] run() for ‘MultisessionFuture’ ... done
[09:32:32.337] receiveMessageFromWorker() for ClusterFuture ...
[09:32:32.337] - Validating connection of MultisessionFuture
[09:32:32.337] - received message: FutureResult
[09:32:32.337] - Received FutureResult
[09:32:32.337] - Erased future from FutureRegistry
[09:32:32.337] result() for ClusterFuture ...
[09:32:32.338] - result already collected: FutureResult
[09:32:32.338] result() for ClusterFuture ... done
[09:32:32.338] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:32.338] A MultisessionFuture was resolved
[09:32:32.338] getGlobalsAndPackages() ...
[09:32:32.338] Searching for globals...
[09:32:32.339] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:32.339] Searching for globals ... DONE
[09:32:32.339] Resolving globals: FALSE
[09:32:32.340] 
[09:32:32.340] 
[09:32:32.340] getGlobalsAndPackages() ... DONE
[09:32:32.340] run() for ‘Future’ ...
[09:32:32.340] - state: ‘created’
[09:32:32.340] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:32.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:32.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:32.355]   - Field: ‘node’
[09:32:32.355]   - Field: ‘label’
[09:32:32.355]   - Field: ‘local’
[09:32:32.355]   - Field: ‘owner’
[09:32:32.355]   - Field: ‘envir’
[09:32:32.355]   - Field: ‘workers’
[09:32:32.355]   - Field: ‘packages’
[09:32:32.355]   - Field: ‘gc’
[09:32:32.355]   - Field: ‘conditions’
[09:32:32.355]   - Field: ‘persistent’
[09:32:32.356]   - Field: ‘expr’
[09:32:32.356]   - Field: ‘uuid’
[09:32:32.356]   - Field: ‘seed’
[09:32:32.356]   - Field: ‘version’
[09:32:32.356]   - Field: ‘result’
[09:32:32.356]   - Field: ‘asynchronous’
[09:32:32.356]   - Field: ‘calls’
[09:32:32.356]   - Field: ‘globals’
[09:32:32.356]   - Field: ‘stdout’
[09:32:32.356]   - Field: ‘earlySignal’
[09:32:32.357]   - Field: ‘lazy’
[09:32:32.357]   - Field: ‘state’
[09:32:32.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:32.357] - Launch lazy future ...
[09:32:32.357] Packages needed by the future expression (n = 0): <none>
[09:32:32.357] Packages needed by future strategies (n = 0): <none>
[09:32:32.358] {
[09:32:32.358]     {
[09:32:32.358]         {
[09:32:32.358]             ...future.startTime <- base::Sys.time()
[09:32:32.358]             {
[09:32:32.358]                 {
[09:32:32.358]                   {
[09:32:32.358]                     {
[09:32:32.358]                       base::local({
[09:32:32.358]                         has_future <- base::requireNamespace("future", 
[09:32:32.358]                           quietly = TRUE)
[09:32:32.358]                         if (has_future) {
[09:32:32.358]                           ns <- base::getNamespace("future")
[09:32:32.358]                           version <- ns[[".package"]][["version"]]
[09:32:32.358]                           if (is.null(version)) 
[09:32:32.358]                             version <- utils::packageVersion("future")
[09:32:32.358]                         }
[09:32:32.358]                         else {
[09:32:32.358]                           version <- NULL
[09:32:32.358]                         }
[09:32:32.358]                         if (!has_future || version < "1.8.0") {
[09:32:32.358]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:32.358]                             "", base::R.version$version.string), 
[09:32:32.358]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:32.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:32.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:32.358]                               "release", "version")], collapse = " "), 
[09:32:32.358]                             hostname = base::Sys.info()[["nodename"]])
[09:32:32.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:32.358]                             info)
[09:32:32.358]                           info <- base::paste(info, collapse = "; ")
[09:32:32.358]                           if (!has_future) {
[09:32:32.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:32.358]                               info)
[09:32:32.358]                           }
[09:32:32.358]                           else {
[09:32:32.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:32.358]                               info, version)
[09:32:32.358]                           }
[09:32:32.358]                           base::stop(msg)
[09:32:32.358]                         }
[09:32:32.358]                       })
[09:32:32.358]                     }
[09:32:32.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:32.358]                     base::options(mc.cores = 1L)
[09:32:32.358]                   }
[09:32:32.358]                   ...future.strategy.old <- future::plan("list")
[09:32:32.358]                   options(future.plan = NULL)
[09:32:32.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:32.358]                 }
[09:32:32.358]                 ...future.workdir <- getwd()
[09:32:32.358]             }
[09:32:32.358]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:32.358]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:32.358]         }
[09:32:32.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:32.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:32.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:32.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:32.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:32.358]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:32.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:32.358]             base::names(...future.oldOptions))
[09:32:32.358]     }
[09:32:32.358]     if (FALSE) {
[09:32:32.358]     }
[09:32:32.358]     else {
[09:32:32.358]         if (TRUE) {
[09:32:32.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:32.358]                 open = "w")
[09:32:32.358]         }
[09:32:32.358]         else {
[09:32:32.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:32.358]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:32.358]         }
[09:32:32.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:32.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:32.358]             base::sink(type = "output", split = FALSE)
[09:32:32.358]             base::close(...future.stdout)
[09:32:32.358]         }, add = TRUE)
[09:32:32.358]     }
[09:32:32.358]     ...future.frame <- base::sys.nframe()
[09:32:32.358]     ...future.conditions <- base::list()
[09:32:32.358]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:32.358]     if (FALSE) {
[09:32:32.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:32.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:32.358]     }
[09:32:32.358]     ...future.result <- base::tryCatch({
[09:32:32.358]         base::withCallingHandlers({
[09:32:32.358]             ...future.value <- base::withVisible(base::local({
[09:32:32.358]                 ...future.makeSendCondition <- base::local({
[09:32:32.358]                   sendCondition <- NULL
[09:32:32.358]                   function(frame = 1L) {
[09:32:32.358]                     if (is.function(sendCondition)) 
[09:32:32.358]                       return(sendCondition)
[09:32:32.358]                     ns <- getNamespace("parallel")
[09:32:32.358]                     if (exists("sendData", mode = "function", 
[09:32:32.358]                       envir = ns)) {
[09:32:32.358]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:32.358]                         envir = ns)
[09:32:32.358]                       envir <- sys.frame(frame)
[09:32:32.358]                       master <- NULL
[09:32:32.358]                       while (!identical(envir, .GlobalEnv) && 
[09:32:32.358]                         !identical(envir, emptyenv())) {
[09:32:32.358]                         if (exists("master", mode = "list", envir = envir, 
[09:32:32.358]                           inherits = FALSE)) {
[09:32:32.358]                           master <- get("master", mode = "list", 
[09:32:32.358]                             envir = envir, inherits = FALSE)
[09:32:32.358]                           if (inherits(master, c("SOCKnode", 
[09:32:32.358]                             "SOCK0node"))) {
[09:32:32.358]                             sendCondition <<- function(cond) {
[09:32:32.358]                               data <- list(type = "VALUE", value = cond, 
[09:32:32.358]                                 success = TRUE)
[09:32:32.358]                               parallel_sendData(master, data)
[09:32:32.358]                             }
[09:32:32.358]                             return(sendCondition)
[09:32:32.358]                           }
[09:32:32.358]                         }
[09:32:32.358]                         frame <- frame + 1L
[09:32:32.358]                         envir <- sys.frame(frame)
[09:32:32.358]                       }
[09:32:32.358]                     }
[09:32:32.358]                     sendCondition <<- function(cond) NULL
[09:32:32.358]                   }
[09:32:32.358]                 })
[09:32:32.358]                 withCallingHandlers({
[09:32:32.358]                   {
[09:32:32.358]                     Sys.sleep(0.5)
[09:32:32.358]                     list(a = 1, b = 42L)
[09:32:32.358]                   }
[09:32:32.358]                 }, immediateCondition = function(cond) {
[09:32:32.358]                   sendCondition <- ...future.makeSendCondition()
[09:32:32.358]                   sendCondition(cond)
[09:32:32.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.358]                   {
[09:32:32.358]                     inherits <- base::inherits
[09:32:32.358]                     invokeRestart <- base::invokeRestart
[09:32:32.358]                     is.null <- base::is.null
[09:32:32.358]                     muffled <- FALSE
[09:32:32.358]                     if (inherits(cond, "message")) {
[09:32:32.358]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:32.358]                       if (muffled) 
[09:32:32.358]                         invokeRestart("muffleMessage")
[09:32:32.358]                     }
[09:32:32.358]                     else if (inherits(cond, "warning")) {
[09:32:32.358]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:32.358]                       if (muffled) 
[09:32:32.358]                         invokeRestart("muffleWarning")
[09:32:32.358]                     }
[09:32:32.358]                     else if (inherits(cond, "condition")) {
[09:32:32.358]                       if (!is.null(pattern)) {
[09:32:32.358]                         computeRestarts <- base::computeRestarts
[09:32:32.358]                         grepl <- base::grepl
[09:32:32.358]                         restarts <- computeRestarts(cond)
[09:32:32.358]                         for (restart in restarts) {
[09:32:32.358]                           name <- restart$name
[09:32:32.358]                           if (is.null(name)) 
[09:32:32.358]                             next
[09:32:32.358]                           if (!grepl(pattern, name)) 
[09:32:32.358]                             next
[09:32:32.358]                           invokeRestart(restart)
[09:32:32.358]                           muffled <- TRUE
[09:32:32.358]                           break
[09:32:32.358]                         }
[09:32:32.358]                       }
[09:32:32.358]                     }
[09:32:32.358]                     invisible(muffled)
[09:32:32.358]                   }
[09:32:32.358]                   muffleCondition(cond)
[09:32:32.358]                 })
[09:32:32.358]             }))
[09:32:32.358]             future::FutureResult(value = ...future.value$value, 
[09:32:32.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.358]                   ...future.rng), globalenv = if (FALSE) 
[09:32:32.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:32.358]                     ...future.globalenv.names))
[09:32:32.358]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:32.358]         }, condition = base::local({
[09:32:32.358]             c <- base::c
[09:32:32.358]             inherits <- base::inherits
[09:32:32.358]             invokeRestart <- base::invokeRestart
[09:32:32.358]             length <- base::length
[09:32:32.358]             list <- base::list
[09:32:32.358]             seq.int <- base::seq.int
[09:32:32.358]             signalCondition <- base::signalCondition
[09:32:32.358]             sys.calls <- base::sys.calls
[09:32:32.358]             `[[` <- base::`[[`
[09:32:32.358]             `+` <- base::`+`
[09:32:32.358]             `<<-` <- base::`<<-`
[09:32:32.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:32.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:32.358]                   3L)]
[09:32:32.358]             }
[09:32:32.358]             function(cond) {
[09:32:32.358]                 is_error <- inherits(cond, "error")
[09:32:32.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:32.358]                   NULL)
[09:32:32.358]                 if (is_error) {
[09:32:32.358]                   sessionInformation <- function() {
[09:32:32.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:32.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:32.358]                       search = base::search(), system = base::Sys.info())
[09:32:32.358]                   }
[09:32:32.358]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:32.358]                     cond$call), session = sessionInformation(), 
[09:32:32.358]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:32.358]                   signalCondition(cond)
[09:32:32.358]                 }
[09:32:32.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:32.358]                 "immediateCondition"))) {
[09:32:32.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:32.358]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:32.358]                   if (TRUE && !signal) {
[09:32:32.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.358]                     {
[09:32:32.358]                       inherits <- base::inherits
[09:32:32.358]                       invokeRestart <- base::invokeRestart
[09:32:32.358]                       is.null <- base::is.null
[09:32:32.358]                       muffled <- FALSE
[09:32:32.358]                       if (inherits(cond, "message")) {
[09:32:32.358]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.358]                         if (muffled) 
[09:32:32.358]                           invokeRestart("muffleMessage")
[09:32:32.358]                       }
[09:32:32.358]                       else if (inherits(cond, "warning")) {
[09:32:32.358]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.358]                         if (muffled) 
[09:32:32.358]                           invokeRestart("muffleWarning")
[09:32:32.358]                       }
[09:32:32.358]                       else if (inherits(cond, "condition")) {
[09:32:32.358]                         if (!is.null(pattern)) {
[09:32:32.358]                           computeRestarts <- base::computeRestarts
[09:32:32.358]                           grepl <- base::grepl
[09:32:32.358]                           restarts <- computeRestarts(cond)
[09:32:32.358]                           for (restart in restarts) {
[09:32:32.358]                             name <- restart$name
[09:32:32.358]                             if (is.null(name)) 
[09:32:32.358]                               next
[09:32:32.358]                             if (!grepl(pattern, name)) 
[09:32:32.358]                               next
[09:32:32.358]                             invokeRestart(restart)
[09:32:32.358]                             muffled <- TRUE
[09:32:32.358]                             break
[09:32:32.358]                           }
[09:32:32.358]                         }
[09:32:32.358]                       }
[09:32:32.358]                       invisible(muffled)
[09:32:32.358]                     }
[09:32:32.358]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.358]                   }
[09:32:32.358]                 }
[09:32:32.358]                 else {
[09:32:32.358]                   if (TRUE) {
[09:32:32.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.358]                     {
[09:32:32.358]                       inherits <- base::inherits
[09:32:32.358]                       invokeRestart <- base::invokeRestart
[09:32:32.358]                       is.null <- base::is.null
[09:32:32.358]                       muffled <- FALSE
[09:32:32.358]                       if (inherits(cond, "message")) {
[09:32:32.358]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.358]                         if (muffled) 
[09:32:32.358]                           invokeRestart("muffleMessage")
[09:32:32.358]                       }
[09:32:32.358]                       else if (inherits(cond, "warning")) {
[09:32:32.358]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.358]                         if (muffled) 
[09:32:32.358]                           invokeRestart("muffleWarning")
[09:32:32.358]                       }
[09:32:32.358]                       else if (inherits(cond, "condition")) {
[09:32:32.358]                         if (!is.null(pattern)) {
[09:32:32.358]                           computeRestarts <- base::computeRestarts
[09:32:32.358]                           grepl <- base::grepl
[09:32:32.358]                           restarts <- computeRestarts(cond)
[09:32:32.358]                           for (restart in restarts) {
[09:32:32.358]                             name <- restart$name
[09:32:32.358]                             if (is.null(name)) 
[09:32:32.358]                               next
[09:32:32.358]                             if (!grepl(pattern, name)) 
[09:32:32.358]                               next
[09:32:32.358]                             invokeRestart(restart)
[09:32:32.358]                             muffled <- TRUE
[09:32:32.358]                             break
[09:32:32.358]                           }
[09:32:32.358]                         }
[09:32:32.358]                       }
[09:32:32.358]                       invisible(muffled)
[09:32:32.358]                     }
[09:32:32.358]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.358]                   }
[09:32:32.358]                 }
[09:32:32.358]             }
[09:32:32.358]         }))
[09:32:32.358]     }, error = function(ex) {
[09:32:32.358]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:32.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.358]                 ...future.rng), started = ...future.startTime, 
[09:32:32.358]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:32.358]             version = "1.8"), class = "FutureResult")
[09:32:32.358]     }, finally = {
[09:32:32.358]         if (!identical(...future.workdir, getwd())) 
[09:32:32.358]             setwd(...future.workdir)
[09:32:32.358]         {
[09:32:32.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:32.358]                 ...future.oldOptions$nwarnings <- NULL
[09:32:32.358]             }
[09:32:32.358]             base::options(...future.oldOptions)
[09:32:32.358]             if (.Platform$OS.type == "windows") {
[09:32:32.358]                 old_names <- names(...future.oldEnvVars)
[09:32:32.358]                 envs <- base::Sys.getenv()
[09:32:32.358]                 names <- names(envs)
[09:32:32.358]                 common <- intersect(names, old_names)
[09:32:32.358]                 added <- setdiff(names, old_names)
[09:32:32.358]                 removed <- setdiff(old_names, names)
[09:32:32.358]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:32.358]                   envs[common]]
[09:32:32.358]                 NAMES <- toupper(changed)
[09:32:32.358]                 args <- list()
[09:32:32.358]                 for (kk in seq_along(NAMES)) {
[09:32:32.358]                   name <- changed[[kk]]
[09:32:32.358]                   NAME <- NAMES[[kk]]
[09:32:32.358]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.358]                     next
[09:32:32.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.358]                 }
[09:32:32.358]                 NAMES <- toupper(added)
[09:32:32.358]                 for (kk in seq_along(NAMES)) {
[09:32:32.358]                   name <- added[[kk]]
[09:32:32.358]                   NAME <- NAMES[[kk]]
[09:32:32.358]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.358]                     next
[09:32:32.358]                   args[[name]] <- ""
[09:32:32.358]                 }
[09:32:32.358]                 NAMES <- toupper(removed)
[09:32:32.358]                 for (kk in seq_along(NAMES)) {
[09:32:32.358]                   name <- removed[[kk]]
[09:32:32.358]                   NAME <- NAMES[[kk]]
[09:32:32.358]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.358]                     next
[09:32:32.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.358]                 }
[09:32:32.358]                 if (length(args) > 0) 
[09:32:32.358]                   base::do.call(base::Sys.setenv, args = args)
[09:32:32.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:32.358]             }
[09:32:32.358]             else {
[09:32:32.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:32.358]             }
[09:32:32.358]             {
[09:32:32.358]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:32.358]                   0L) {
[09:32:32.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:32.358]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:32.358]                   base::options(opts)
[09:32:32.358]                 }
[09:32:32.358]                 {
[09:32:32.358]                   {
[09:32:32.358]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:32.358]                     NULL
[09:32:32.358]                   }
[09:32:32.358]                   options(future.plan = NULL)
[09:32:32.358]                   if (is.na(NA_character_)) 
[09:32:32.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:32.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:32.358]                     .init = FALSE)
[09:32:32.358]                 }
[09:32:32.358]             }
[09:32:32.358]         }
[09:32:32.358]     })
[09:32:32.358]     if (TRUE) {
[09:32:32.358]         base::sink(type = "output", split = FALSE)
[09:32:32.358]         if (TRUE) {
[09:32:32.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:32.358]         }
[09:32:32.358]         else {
[09:32:32.358]             ...future.result["stdout"] <- base::list(NULL)
[09:32:32.358]         }
[09:32:32.358]         base::close(...future.stdout)
[09:32:32.358]         ...future.stdout <- NULL
[09:32:32.358]     }
[09:32:32.358]     ...future.result$conditions <- ...future.conditions
[09:32:32.358]     ...future.result$finished <- base::Sys.time()
[09:32:32.358]     ...future.result
[09:32:32.358] }
[09:32:32.361] MultisessionFuture started
[09:32:32.361] - Launch lazy future ... done
[09:32:32.361] run() for ‘MultisessionFuture’ ... done
[09:32:32.863] receiveMessageFromWorker() for ClusterFuture ...
[09:32:32.863] - Validating connection of MultisessionFuture
[09:32:32.863] - received message: FutureResult
[09:32:32.863] - Received FutureResult
[09:32:32.864] - Erased future from FutureRegistry
[09:32:32.864] result() for ClusterFuture ...
[09:32:32.864] - result already collected: FutureResult
[09:32:32.864] result() for ClusterFuture ... done
[09:32:32.864] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:32.864] A MultisessionFuture was resolved
- w/ exception ...
[09:32:32.864] getGlobalsAndPackages() ...
[09:32:32.864] Searching for globals...
[09:32:32.865] - globals found: [2] ‘list’, ‘stop’
[09:32:32.865] Searching for globals ... DONE
[09:32:32.865] Resolving globals: FALSE
[09:32:32.865] 
[09:32:32.866] 
[09:32:32.866] getGlobalsAndPackages() ... DONE
[09:32:32.866] run() for ‘Future’ ...
[09:32:32.866] - state: ‘created’
[09:32:32.866] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:32.881] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:32.881] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:32.881]   - Field: ‘node’
[09:32:32.881]   - Field: ‘label’
[09:32:32.881]   - Field: ‘local’
[09:32:32.881]   - Field: ‘owner’
[09:32:32.881]   - Field: ‘envir’
[09:32:32.881]   - Field: ‘workers’
[09:32:32.882]   - Field: ‘packages’
[09:32:32.882]   - Field: ‘gc’
[09:32:32.882]   - Field: ‘conditions’
[09:32:32.882]   - Field: ‘persistent’
[09:32:32.882]   - Field: ‘expr’
[09:32:32.882]   - Field: ‘uuid’
[09:32:32.882]   - Field: ‘seed’
[09:32:32.882]   - Field: ‘version’
[09:32:32.882]   - Field: ‘result’
[09:32:32.882]   - Field: ‘asynchronous’
[09:32:32.882]   - Field: ‘calls’
[09:32:32.882]   - Field: ‘globals’
[09:32:32.883]   - Field: ‘stdout’
[09:32:32.883]   - Field: ‘earlySignal’
[09:32:32.883]   - Field: ‘lazy’
[09:32:32.883]   - Field: ‘state’
[09:32:32.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:32.883] - Launch lazy future ...
[09:32:32.883] Packages needed by the future expression (n = 0): <none>
[09:32:32.883] Packages needed by future strategies (n = 0): <none>
[09:32:32.884] {
[09:32:32.884]     {
[09:32:32.884]         {
[09:32:32.884]             ...future.startTime <- base::Sys.time()
[09:32:32.884]             {
[09:32:32.884]                 {
[09:32:32.884]                   {
[09:32:32.884]                     {
[09:32:32.884]                       base::local({
[09:32:32.884]                         has_future <- base::requireNamespace("future", 
[09:32:32.884]                           quietly = TRUE)
[09:32:32.884]                         if (has_future) {
[09:32:32.884]                           ns <- base::getNamespace("future")
[09:32:32.884]                           version <- ns[[".package"]][["version"]]
[09:32:32.884]                           if (is.null(version)) 
[09:32:32.884]                             version <- utils::packageVersion("future")
[09:32:32.884]                         }
[09:32:32.884]                         else {
[09:32:32.884]                           version <- NULL
[09:32:32.884]                         }
[09:32:32.884]                         if (!has_future || version < "1.8.0") {
[09:32:32.884]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:32.884]                             "", base::R.version$version.string), 
[09:32:32.884]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:32.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:32.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:32.884]                               "release", "version")], collapse = " "), 
[09:32:32.884]                             hostname = base::Sys.info()[["nodename"]])
[09:32:32.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:32.884]                             info)
[09:32:32.884]                           info <- base::paste(info, collapse = "; ")
[09:32:32.884]                           if (!has_future) {
[09:32:32.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:32.884]                               info)
[09:32:32.884]                           }
[09:32:32.884]                           else {
[09:32:32.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:32.884]                               info, version)
[09:32:32.884]                           }
[09:32:32.884]                           base::stop(msg)
[09:32:32.884]                         }
[09:32:32.884]                       })
[09:32:32.884]                     }
[09:32:32.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:32.884]                     base::options(mc.cores = 1L)
[09:32:32.884]                   }
[09:32:32.884]                   ...future.strategy.old <- future::plan("list")
[09:32:32.884]                   options(future.plan = NULL)
[09:32:32.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:32.884]                 }
[09:32:32.884]                 ...future.workdir <- getwd()
[09:32:32.884]             }
[09:32:32.884]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:32.884]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:32.884]         }
[09:32:32.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:32.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:32.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:32.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:32.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:32.884]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:32.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:32.884]             base::names(...future.oldOptions))
[09:32:32.884]     }
[09:32:32.884]     if (FALSE) {
[09:32:32.884]     }
[09:32:32.884]     else {
[09:32:32.884]         if (TRUE) {
[09:32:32.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:32.884]                 open = "w")
[09:32:32.884]         }
[09:32:32.884]         else {
[09:32:32.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:32.884]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:32.884]         }
[09:32:32.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:32.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:32.884]             base::sink(type = "output", split = FALSE)
[09:32:32.884]             base::close(...future.stdout)
[09:32:32.884]         }, add = TRUE)
[09:32:32.884]     }
[09:32:32.884]     ...future.frame <- base::sys.nframe()
[09:32:32.884]     ...future.conditions <- base::list()
[09:32:32.884]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:32.884]     if (FALSE) {
[09:32:32.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:32.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:32.884]     }
[09:32:32.884]     ...future.result <- base::tryCatch({
[09:32:32.884]         base::withCallingHandlers({
[09:32:32.884]             ...future.value <- base::withVisible(base::local({
[09:32:32.884]                 ...future.makeSendCondition <- base::local({
[09:32:32.884]                   sendCondition <- NULL
[09:32:32.884]                   function(frame = 1L) {
[09:32:32.884]                     if (is.function(sendCondition)) 
[09:32:32.884]                       return(sendCondition)
[09:32:32.884]                     ns <- getNamespace("parallel")
[09:32:32.884]                     if (exists("sendData", mode = "function", 
[09:32:32.884]                       envir = ns)) {
[09:32:32.884]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:32.884]                         envir = ns)
[09:32:32.884]                       envir <- sys.frame(frame)
[09:32:32.884]                       master <- NULL
[09:32:32.884]                       while (!identical(envir, .GlobalEnv) && 
[09:32:32.884]                         !identical(envir, emptyenv())) {
[09:32:32.884]                         if (exists("master", mode = "list", envir = envir, 
[09:32:32.884]                           inherits = FALSE)) {
[09:32:32.884]                           master <- get("master", mode = "list", 
[09:32:32.884]                             envir = envir, inherits = FALSE)
[09:32:32.884]                           if (inherits(master, c("SOCKnode", 
[09:32:32.884]                             "SOCK0node"))) {
[09:32:32.884]                             sendCondition <<- function(cond) {
[09:32:32.884]                               data <- list(type = "VALUE", value = cond, 
[09:32:32.884]                                 success = TRUE)
[09:32:32.884]                               parallel_sendData(master, data)
[09:32:32.884]                             }
[09:32:32.884]                             return(sendCondition)
[09:32:32.884]                           }
[09:32:32.884]                         }
[09:32:32.884]                         frame <- frame + 1L
[09:32:32.884]                         envir <- sys.frame(frame)
[09:32:32.884]                       }
[09:32:32.884]                     }
[09:32:32.884]                     sendCondition <<- function(cond) NULL
[09:32:32.884]                   }
[09:32:32.884]                 })
[09:32:32.884]                 withCallingHandlers({
[09:32:32.884]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:32.884]                 }, immediateCondition = function(cond) {
[09:32:32.884]                   sendCondition <- ...future.makeSendCondition()
[09:32:32.884]                   sendCondition(cond)
[09:32:32.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.884]                   {
[09:32:32.884]                     inherits <- base::inherits
[09:32:32.884]                     invokeRestart <- base::invokeRestart
[09:32:32.884]                     is.null <- base::is.null
[09:32:32.884]                     muffled <- FALSE
[09:32:32.884]                     if (inherits(cond, "message")) {
[09:32:32.884]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:32.884]                       if (muffled) 
[09:32:32.884]                         invokeRestart("muffleMessage")
[09:32:32.884]                     }
[09:32:32.884]                     else if (inherits(cond, "warning")) {
[09:32:32.884]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:32.884]                       if (muffled) 
[09:32:32.884]                         invokeRestart("muffleWarning")
[09:32:32.884]                     }
[09:32:32.884]                     else if (inherits(cond, "condition")) {
[09:32:32.884]                       if (!is.null(pattern)) {
[09:32:32.884]                         computeRestarts <- base::computeRestarts
[09:32:32.884]                         grepl <- base::grepl
[09:32:32.884]                         restarts <- computeRestarts(cond)
[09:32:32.884]                         for (restart in restarts) {
[09:32:32.884]                           name <- restart$name
[09:32:32.884]                           if (is.null(name)) 
[09:32:32.884]                             next
[09:32:32.884]                           if (!grepl(pattern, name)) 
[09:32:32.884]                             next
[09:32:32.884]                           invokeRestart(restart)
[09:32:32.884]                           muffled <- TRUE
[09:32:32.884]                           break
[09:32:32.884]                         }
[09:32:32.884]                       }
[09:32:32.884]                     }
[09:32:32.884]                     invisible(muffled)
[09:32:32.884]                   }
[09:32:32.884]                   muffleCondition(cond)
[09:32:32.884]                 })
[09:32:32.884]             }))
[09:32:32.884]             future::FutureResult(value = ...future.value$value, 
[09:32:32.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.884]                   ...future.rng), globalenv = if (FALSE) 
[09:32:32.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:32.884]                     ...future.globalenv.names))
[09:32:32.884]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:32.884]         }, condition = base::local({
[09:32:32.884]             c <- base::c
[09:32:32.884]             inherits <- base::inherits
[09:32:32.884]             invokeRestart <- base::invokeRestart
[09:32:32.884]             length <- base::length
[09:32:32.884]             list <- base::list
[09:32:32.884]             seq.int <- base::seq.int
[09:32:32.884]             signalCondition <- base::signalCondition
[09:32:32.884]             sys.calls <- base::sys.calls
[09:32:32.884]             `[[` <- base::`[[`
[09:32:32.884]             `+` <- base::`+`
[09:32:32.884]             `<<-` <- base::`<<-`
[09:32:32.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:32.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:32.884]                   3L)]
[09:32:32.884]             }
[09:32:32.884]             function(cond) {
[09:32:32.884]                 is_error <- inherits(cond, "error")
[09:32:32.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:32.884]                   NULL)
[09:32:32.884]                 if (is_error) {
[09:32:32.884]                   sessionInformation <- function() {
[09:32:32.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:32.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:32.884]                       search = base::search(), system = base::Sys.info())
[09:32:32.884]                   }
[09:32:32.884]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:32.884]                     cond$call), session = sessionInformation(), 
[09:32:32.884]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:32.884]                   signalCondition(cond)
[09:32:32.884]                 }
[09:32:32.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:32.884]                 "immediateCondition"))) {
[09:32:32.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:32.884]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:32.884]                   if (TRUE && !signal) {
[09:32:32.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.884]                     {
[09:32:32.884]                       inherits <- base::inherits
[09:32:32.884]                       invokeRestart <- base::invokeRestart
[09:32:32.884]                       is.null <- base::is.null
[09:32:32.884]                       muffled <- FALSE
[09:32:32.884]                       if (inherits(cond, "message")) {
[09:32:32.884]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.884]                         if (muffled) 
[09:32:32.884]                           invokeRestart("muffleMessage")
[09:32:32.884]                       }
[09:32:32.884]                       else if (inherits(cond, "warning")) {
[09:32:32.884]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.884]                         if (muffled) 
[09:32:32.884]                           invokeRestart("muffleWarning")
[09:32:32.884]                       }
[09:32:32.884]                       else if (inherits(cond, "condition")) {
[09:32:32.884]                         if (!is.null(pattern)) {
[09:32:32.884]                           computeRestarts <- base::computeRestarts
[09:32:32.884]                           grepl <- base::grepl
[09:32:32.884]                           restarts <- computeRestarts(cond)
[09:32:32.884]                           for (restart in restarts) {
[09:32:32.884]                             name <- restart$name
[09:32:32.884]                             if (is.null(name)) 
[09:32:32.884]                               next
[09:32:32.884]                             if (!grepl(pattern, name)) 
[09:32:32.884]                               next
[09:32:32.884]                             invokeRestart(restart)
[09:32:32.884]                             muffled <- TRUE
[09:32:32.884]                             break
[09:32:32.884]                           }
[09:32:32.884]                         }
[09:32:32.884]                       }
[09:32:32.884]                       invisible(muffled)
[09:32:32.884]                     }
[09:32:32.884]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.884]                   }
[09:32:32.884]                 }
[09:32:32.884]                 else {
[09:32:32.884]                   if (TRUE) {
[09:32:32.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.884]                     {
[09:32:32.884]                       inherits <- base::inherits
[09:32:32.884]                       invokeRestart <- base::invokeRestart
[09:32:32.884]                       is.null <- base::is.null
[09:32:32.884]                       muffled <- FALSE
[09:32:32.884]                       if (inherits(cond, "message")) {
[09:32:32.884]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.884]                         if (muffled) 
[09:32:32.884]                           invokeRestart("muffleMessage")
[09:32:32.884]                       }
[09:32:32.884]                       else if (inherits(cond, "warning")) {
[09:32:32.884]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.884]                         if (muffled) 
[09:32:32.884]                           invokeRestart("muffleWarning")
[09:32:32.884]                       }
[09:32:32.884]                       else if (inherits(cond, "condition")) {
[09:32:32.884]                         if (!is.null(pattern)) {
[09:32:32.884]                           computeRestarts <- base::computeRestarts
[09:32:32.884]                           grepl <- base::grepl
[09:32:32.884]                           restarts <- computeRestarts(cond)
[09:32:32.884]                           for (restart in restarts) {
[09:32:32.884]                             name <- restart$name
[09:32:32.884]                             if (is.null(name)) 
[09:32:32.884]                               next
[09:32:32.884]                             if (!grepl(pattern, name)) 
[09:32:32.884]                               next
[09:32:32.884]                             invokeRestart(restart)
[09:32:32.884]                             muffled <- TRUE
[09:32:32.884]                             break
[09:32:32.884]                           }
[09:32:32.884]                         }
[09:32:32.884]                       }
[09:32:32.884]                       invisible(muffled)
[09:32:32.884]                     }
[09:32:32.884]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.884]                   }
[09:32:32.884]                 }
[09:32:32.884]             }
[09:32:32.884]         }))
[09:32:32.884]     }, error = function(ex) {
[09:32:32.884]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:32.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.884]                 ...future.rng), started = ...future.startTime, 
[09:32:32.884]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:32.884]             version = "1.8"), class = "FutureResult")
[09:32:32.884]     }, finally = {
[09:32:32.884]         if (!identical(...future.workdir, getwd())) 
[09:32:32.884]             setwd(...future.workdir)
[09:32:32.884]         {
[09:32:32.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:32.884]                 ...future.oldOptions$nwarnings <- NULL
[09:32:32.884]             }
[09:32:32.884]             base::options(...future.oldOptions)
[09:32:32.884]             if (.Platform$OS.type == "windows") {
[09:32:32.884]                 old_names <- names(...future.oldEnvVars)
[09:32:32.884]                 envs <- base::Sys.getenv()
[09:32:32.884]                 names <- names(envs)
[09:32:32.884]                 common <- intersect(names, old_names)
[09:32:32.884]                 added <- setdiff(names, old_names)
[09:32:32.884]                 removed <- setdiff(old_names, names)
[09:32:32.884]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:32.884]                   envs[common]]
[09:32:32.884]                 NAMES <- toupper(changed)
[09:32:32.884]                 args <- list()
[09:32:32.884]                 for (kk in seq_along(NAMES)) {
[09:32:32.884]                   name <- changed[[kk]]
[09:32:32.884]                   NAME <- NAMES[[kk]]
[09:32:32.884]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.884]                     next
[09:32:32.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.884]                 }
[09:32:32.884]                 NAMES <- toupper(added)
[09:32:32.884]                 for (kk in seq_along(NAMES)) {
[09:32:32.884]                   name <- added[[kk]]
[09:32:32.884]                   NAME <- NAMES[[kk]]
[09:32:32.884]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.884]                     next
[09:32:32.884]                   args[[name]] <- ""
[09:32:32.884]                 }
[09:32:32.884]                 NAMES <- toupper(removed)
[09:32:32.884]                 for (kk in seq_along(NAMES)) {
[09:32:32.884]                   name <- removed[[kk]]
[09:32:32.884]                   NAME <- NAMES[[kk]]
[09:32:32.884]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.884]                     next
[09:32:32.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.884]                 }
[09:32:32.884]                 if (length(args) > 0) 
[09:32:32.884]                   base::do.call(base::Sys.setenv, args = args)
[09:32:32.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:32.884]             }
[09:32:32.884]             else {
[09:32:32.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:32.884]             }
[09:32:32.884]             {
[09:32:32.884]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:32.884]                   0L) {
[09:32:32.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:32.884]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:32.884]                   base::options(opts)
[09:32:32.884]                 }
[09:32:32.884]                 {
[09:32:32.884]                   {
[09:32:32.884]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:32.884]                     NULL
[09:32:32.884]                   }
[09:32:32.884]                   options(future.plan = NULL)
[09:32:32.884]                   if (is.na(NA_character_)) 
[09:32:32.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:32.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:32.884]                     .init = FALSE)
[09:32:32.884]                 }
[09:32:32.884]             }
[09:32:32.884]         }
[09:32:32.884]     })
[09:32:32.884]     if (TRUE) {
[09:32:32.884]         base::sink(type = "output", split = FALSE)
[09:32:32.884]         if (TRUE) {
[09:32:32.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:32.884]         }
[09:32:32.884]         else {
[09:32:32.884]             ...future.result["stdout"] <- base::list(NULL)
[09:32:32.884]         }
[09:32:32.884]         base::close(...future.stdout)
[09:32:32.884]         ...future.stdout <- NULL
[09:32:32.884]     }
[09:32:32.884]     ...future.result$conditions <- ...future.conditions
[09:32:32.884]     ...future.result$finished <- base::Sys.time()
[09:32:32.884]     ...future.result
[09:32:32.884] }
[09:32:32.887] MultisessionFuture started
[09:32:32.887] - Launch lazy future ... done
[09:32:32.887] run() for ‘MultisessionFuture’ ... done
[09:32:32.888] receiveMessageFromWorker() for ClusterFuture ...
[09:32:32.889] - Validating connection of MultisessionFuture
[09:32:32.889] - received message: FutureResult
[09:32:32.889] - Received FutureResult
[09:32:32.889] - Erased future from FutureRegistry
[09:32:32.889] result() for ClusterFuture ...
[09:32:32.889] - result already collected: FutureResult
[09:32:32.889] result() for ClusterFuture ... done
[09:32:32.889] signalConditions() ...
[09:32:32.890]  - include = ‘immediateCondition’
[09:32:32.890]  - exclude = 
[09:32:32.890]  - resignal = FALSE
[09:32:32.890]  - Number of conditions: 1
[09:32:32.890] signalConditions() ... done
[09:32:32.890] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:32.890] A MultisessionFuture was resolved
[09:32:32.890] getGlobalsAndPackages() ...
[09:32:32.890] Searching for globals...
[09:32:32.891] - globals found: [2] ‘list’, ‘stop’
[09:32:32.891] Searching for globals ... DONE
[09:32:32.891] Resolving globals: FALSE
[09:32:32.891] 
[09:32:32.891] 
[09:32:32.891] getGlobalsAndPackages() ... DONE
[09:32:32.892] run() for ‘Future’ ...
[09:32:32.892] - state: ‘created’
[09:32:32.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:32.907] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:32.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:32.907]   - Field: ‘node’
[09:32:32.907]   - Field: ‘label’
[09:32:32.907]   - Field: ‘local’
[09:32:32.907]   - Field: ‘owner’
[09:32:32.908]   - Field: ‘envir’
[09:32:32.908]   - Field: ‘workers’
[09:32:32.908]   - Field: ‘packages’
[09:32:32.908]   - Field: ‘gc’
[09:32:32.908]   - Field: ‘conditions’
[09:32:32.908]   - Field: ‘persistent’
[09:32:32.908]   - Field: ‘expr’
[09:32:32.908]   - Field: ‘uuid’
[09:32:32.908]   - Field: ‘seed’
[09:32:32.908]   - Field: ‘version’
[09:32:32.908]   - Field: ‘result’
[09:32:32.909]   - Field: ‘asynchronous’
[09:32:32.909]   - Field: ‘calls’
[09:32:32.909]   - Field: ‘globals’
[09:32:32.909]   - Field: ‘stdout’
[09:32:32.909]   - Field: ‘earlySignal’
[09:32:32.909]   - Field: ‘lazy’
[09:32:32.909]   - Field: ‘state’
[09:32:32.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:32.909] - Launch lazy future ...
[09:32:32.910] Packages needed by the future expression (n = 0): <none>
[09:32:32.910] Packages needed by future strategies (n = 0): <none>
[09:32:32.910] {
[09:32:32.910]     {
[09:32:32.910]         {
[09:32:32.910]             ...future.startTime <- base::Sys.time()
[09:32:32.910]             {
[09:32:32.910]                 {
[09:32:32.910]                   {
[09:32:32.910]                     {
[09:32:32.910]                       base::local({
[09:32:32.910]                         has_future <- base::requireNamespace("future", 
[09:32:32.910]                           quietly = TRUE)
[09:32:32.910]                         if (has_future) {
[09:32:32.910]                           ns <- base::getNamespace("future")
[09:32:32.910]                           version <- ns[[".package"]][["version"]]
[09:32:32.910]                           if (is.null(version)) 
[09:32:32.910]                             version <- utils::packageVersion("future")
[09:32:32.910]                         }
[09:32:32.910]                         else {
[09:32:32.910]                           version <- NULL
[09:32:32.910]                         }
[09:32:32.910]                         if (!has_future || version < "1.8.0") {
[09:32:32.910]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:32.910]                             "", base::R.version$version.string), 
[09:32:32.910]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:32.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:32.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:32.910]                               "release", "version")], collapse = " "), 
[09:32:32.910]                             hostname = base::Sys.info()[["nodename"]])
[09:32:32.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:32.910]                             info)
[09:32:32.910]                           info <- base::paste(info, collapse = "; ")
[09:32:32.910]                           if (!has_future) {
[09:32:32.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:32.910]                               info)
[09:32:32.910]                           }
[09:32:32.910]                           else {
[09:32:32.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:32.910]                               info, version)
[09:32:32.910]                           }
[09:32:32.910]                           base::stop(msg)
[09:32:32.910]                         }
[09:32:32.910]                       })
[09:32:32.910]                     }
[09:32:32.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:32.910]                     base::options(mc.cores = 1L)
[09:32:32.910]                   }
[09:32:32.910]                   ...future.strategy.old <- future::plan("list")
[09:32:32.910]                   options(future.plan = NULL)
[09:32:32.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:32.910]                 }
[09:32:32.910]                 ...future.workdir <- getwd()
[09:32:32.910]             }
[09:32:32.910]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:32.910]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:32.910]         }
[09:32:32.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:32.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:32.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:32.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:32.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:32.910]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:32.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:32.910]             base::names(...future.oldOptions))
[09:32:32.910]     }
[09:32:32.910]     if (FALSE) {
[09:32:32.910]     }
[09:32:32.910]     else {
[09:32:32.910]         if (TRUE) {
[09:32:32.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:32.910]                 open = "w")
[09:32:32.910]         }
[09:32:32.910]         else {
[09:32:32.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:32.910]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:32.910]         }
[09:32:32.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:32.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:32.910]             base::sink(type = "output", split = FALSE)
[09:32:32.910]             base::close(...future.stdout)
[09:32:32.910]         }, add = TRUE)
[09:32:32.910]     }
[09:32:32.910]     ...future.frame <- base::sys.nframe()
[09:32:32.910]     ...future.conditions <- base::list()
[09:32:32.910]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:32.910]     if (FALSE) {
[09:32:32.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:32.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:32.910]     }
[09:32:32.910]     ...future.result <- base::tryCatch({
[09:32:32.910]         base::withCallingHandlers({
[09:32:32.910]             ...future.value <- base::withVisible(base::local({
[09:32:32.910]                 ...future.makeSendCondition <- base::local({
[09:32:32.910]                   sendCondition <- NULL
[09:32:32.910]                   function(frame = 1L) {
[09:32:32.910]                     if (is.function(sendCondition)) 
[09:32:32.910]                       return(sendCondition)
[09:32:32.910]                     ns <- getNamespace("parallel")
[09:32:32.910]                     if (exists("sendData", mode = "function", 
[09:32:32.910]                       envir = ns)) {
[09:32:32.910]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:32.910]                         envir = ns)
[09:32:32.910]                       envir <- sys.frame(frame)
[09:32:32.910]                       master <- NULL
[09:32:32.910]                       while (!identical(envir, .GlobalEnv) && 
[09:32:32.910]                         !identical(envir, emptyenv())) {
[09:32:32.910]                         if (exists("master", mode = "list", envir = envir, 
[09:32:32.910]                           inherits = FALSE)) {
[09:32:32.910]                           master <- get("master", mode = "list", 
[09:32:32.910]                             envir = envir, inherits = FALSE)
[09:32:32.910]                           if (inherits(master, c("SOCKnode", 
[09:32:32.910]                             "SOCK0node"))) {
[09:32:32.910]                             sendCondition <<- function(cond) {
[09:32:32.910]                               data <- list(type = "VALUE", value = cond, 
[09:32:32.910]                                 success = TRUE)
[09:32:32.910]                               parallel_sendData(master, data)
[09:32:32.910]                             }
[09:32:32.910]                             return(sendCondition)
[09:32:32.910]                           }
[09:32:32.910]                         }
[09:32:32.910]                         frame <- frame + 1L
[09:32:32.910]                         envir <- sys.frame(frame)
[09:32:32.910]                       }
[09:32:32.910]                     }
[09:32:32.910]                     sendCondition <<- function(cond) NULL
[09:32:32.910]                   }
[09:32:32.910]                 })
[09:32:32.910]                 withCallingHandlers({
[09:32:32.910]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:32.910]                 }, immediateCondition = function(cond) {
[09:32:32.910]                   sendCondition <- ...future.makeSendCondition()
[09:32:32.910]                   sendCondition(cond)
[09:32:32.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.910]                   {
[09:32:32.910]                     inherits <- base::inherits
[09:32:32.910]                     invokeRestart <- base::invokeRestart
[09:32:32.910]                     is.null <- base::is.null
[09:32:32.910]                     muffled <- FALSE
[09:32:32.910]                     if (inherits(cond, "message")) {
[09:32:32.910]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:32.910]                       if (muffled) 
[09:32:32.910]                         invokeRestart("muffleMessage")
[09:32:32.910]                     }
[09:32:32.910]                     else if (inherits(cond, "warning")) {
[09:32:32.910]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:32.910]                       if (muffled) 
[09:32:32.910]                         invokeRestart("muffleWarning")
[09:32:32.910]                     }
[09:32:32.910]                     else if (inherits(cond, "condition")) {
[09:32:32.910]                       if (!is.null(pattern)) {
[09:32:32.910]                         computeRestarts <- base::computeRestarts
[09:32:32.910]                         grepl <- base::grepl
[09:32:32.910]                         restarts <- computeRestarts(cond)
[09:32:32.910]                         for (restart in restarts) {
[09:32:32.910]                           name <- restart$name
[09:32:32.910]                           if (is.null(name)) 
[09:32:32.910]                             next
[09:32:32.910]                           if (!grepl(pattern, name)) 
[09:32:32.910]                             next
[09:32:32.910]                           invokeRestart(restart)
[09:32:32.910]                           muffled <- TRUE
[09:32:32.910]                           break
[09:32:32.910]                         }
[09:32:32.910]                       }
[09:32:32.910]                     }
[09:32:32.910]                     invisible(muffled)
[09:32:32.910]                   }
[09:32:32.910]                   muffleCondition(cond)
[09:32:32.910]                 })
[09:32:32.910]             }))
[09:32:32.910]             future::FutureResult(value = ...future.value$value, 
[09:32:32.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.910]                   ...future.rng), globalenv = if (FALSE) 
[09:32:32.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:32.910]                     ...future.globalenv.names))
[09:32:32.910]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:32.910]         }, condition = base::local({
[09:32:32.910]             c <- base::c
[09:32:32.910]             inherits <- base::inherits
[09:32:32.910]             invokeRestart <- base::invokeRestart
[09:32:32.910]             length <- base::length
[09:32:32.910]             list <- base::list
[09:32:32.910]             seq.int <- base::seq.int
[09:32:32.910]             signalCondition <- base::signalCondition
[09:32:32.910]             sys.calls <- base::sys.calls
[09:32:32.910]             `[[` <- base::`[[`
[09:32:32.910]             `+` <- base::`+`
[09:32:32.910]             `<<-` <- base::`<<-`
[09:32:32.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:32.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:32.910]                   3L)]
[09:32:32.910]             }
[09:32:32.910]             function(cond) {
[09:32:32.910]                 is_error <- inherits(cond, "error")
[09:32:32.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:32.910]                   NULL)
[09:32:32.910]                 if (is_error) {
[09:32:32.910]                   sessionInformation <- function() {
[09:32:32.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:32.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:32.910]                       search = base::search(), system = base::Sys.info())
[09:32:32.910]                   }
[09:32:32.910]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:32.910]                     cond$call), session = sessionInformation(), 
[09:32:32.910]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:32.910]                   signalCondition(cond)
[09:32:32.910]                 }
[09:32:32.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:32.910]                 "immediateCondition"))) {
[09:32:32.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:32.910]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:32.910]                   if (TRUE && !signal) {
[09:32:32.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.910]                     {
[09:32:32.910]                       inherits <- base::inherits
[09:32:32.910]                       invokeRestart <- base::invokeRestart
[09:32:32.910]                       is.null <- base::is.null
[09:32:32.910]                       muffled <- FALSE
[09:32:32.910]                       if (inherits(cond, "message")) {
[09:32:32.910]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.910]                         if (muffled) 
[09:32:32.910]                           invokeRestart("muffleMessage")
[09:32:32.910]                       }
[09:32:32.910]                       else if (inherits(cond, "warning")) {
[09:32:32.910]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.910]                         if (muffled) 
[09:32:32.910]                           invokeRestart("muffleWarning")
[09:32:32.910]                       }
[09:32:32.910]                       else if (inherits(cond, "condition")) {
[09:32:32.910]                         if (!is.null(pattern)) {
[09:32:32.910]                           computeRestarts <- base::computeRestarts
[09:32:32.910]                           grepl <- base::grepl
[09:32:32.910]                           restarts <- computeRestarts(cond)
[09:32:32.910]                           for (restart in restarts) {
[09:32:32.910]                             name <- restart$name
[09:32:32.910]                             if (is.null(name)) 
[09:32:32.910]                               next
[09:32:32.910]                             if (!grepl(pattern, name)) 
[09:32:32.910]                               next
[09:32:32.910]                             invokeRestart(restart)
[09:32:32.910]                             muffled <- TRUE
[09:32:32.910]                             break
[09:32:32.910]                           }
[09:32:32.910]                         }
[09:32:32.910]                       }
[09:32:32.910]                       invisible(muffled)
[09:32:32.910]                     }
[09:32:32.910]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.910]                   }
[09:32:32.910]                 }
[09:32:32.910]                 else {
[09:32:32.910]                   if (TRUE) {
[09:32:32.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.910]                     {
[09:32:32.910]                       inherits <- base::inherits
[09:32:32.910]                       invokeRestart <- base::invokeRestart
[09:32:32.910]                       is.null <- base::is.null
[09:32:32.910]                       muffled <- FALSE
[09:32:32.910]                       if (inherits(cond, "message")) {
[09:32:32.910]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.910]                         if (muffled) 
[09:32:32.910]                           invokeRestart("muffleMessage")
[09:32:32.910]                       }
[09:32:32.910]                       else if (inherits(cond, "warning")) {
[09:32:32.910]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.910]                         if (muffled) 
[09:32:32.910]                           invokeRestart("muffleWarning")
[09:32:32.910]                       }
[09:32:32.910]                       else if (inherits(cond, "condition")) {
[09:32:32.910]                         if (!is.null(pattern)) {
[09:32:32.910]                           computeRestarts <- base::computeRestarts
[09:32:32.910]                           grepl <- base::grepl
[09:32:32.910]                           restarts <- computeRestarts(cond)
[09:32:32.910]                           for (restart in restarts) {
[09:32:32.910]                             name <- restart$name
[09:32:32.910]                             if (is.null(name)) 
[09:32:32.910]                               next
[09:32:32.910]                             if (!grepl(pattern, name)) 
[09:32:32.910]                               next
[09:32:32.910]                             invokeRestart(restart)
[09:32:32.910]                             muffled <- TRUE
[09:32:32.910]                             break
[09:32:32.910]                           }
[09:32:32.910]                         }
[09:32:32.910]                       }
[09:32:32.910]                       invisible(muffled)
[09:32:32.910]                     }
[09:32:32.910]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.910]                   }
[09:32:32.910]                 }
[09:32:32.910]             }
[09:32:32.910]         }))
[09:32:32.910]     }, error = function(ex) {
[09:32:32.910]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:32.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.910]                 ...future.rng), started = ...future.startTime, 
[09:32:32.910]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:32.910]             version = "1.8"), class = "FutureResult")
[09:32:32.910]     }, finally = {
[09:32:32.910]         if (!identical(...future.workdir, getwd())) 
[09:32:32.910]             setwd(...future.workdir)
[09:32:32.910]         {
[09:32:32.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:32.910]                 ...future.oldOptions$nwarnings <- NULL
[09:32:32.910]             }
[09:32:32.910]             base::options(...future.oldOptions)
[09:32:32.910]             if (.Platform$OS.type == "windows") {
[09:32:32.910]                 old_names <- names(...future.oldEnvVars)
[09:32:32.910]                 envs <- base::Sys.getenv()
[09:32:32.910]                 names <- names(envs)
[09:32:32.910]                 common <- intersect(names, old_names)
[09:32:32.910]                 added <- setdiff(names, old_names)
[09:32:32.910]                 removed <- setdiff(old_names, names)
[09:32:32.910]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:32.910]                   envs[common]]
[09:32:32.910]                 NAMES <- toupper(changed)
[09:32:32.910]                 args <- list()
[09:32:32.910]                 for (kk in seq_along(NAMES)) {
[09:32:32.910]                   name <- changed[[kk]]
[09:32:32.910]                   NAME <- NAMES[[kk]]
[09:32:32.910]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.910]                     next
[09:32:32.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.910]                 }
[09:32:32.910]                 NAMES <- toupper(added)
[09:32:32.910]                 for (kk in seq_along(NAMES)) {
[09:32:32.910]                   name <- added[[kk]]
[09:32:32.910]                   NAME <- NAMES[[kk]]
[09:32:32.910]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.910]                     next
[09:32:32.910]                   args[[name]] <- ""
[09:32:32.910]                 }
[09:32:32.910]                 NAMES <- toupper(removed)
[09:32:32.910]                 for (kk in seq_along(NAMES)) {
[09:32:32.910]                   name <- removed[[kk]]
[09:32:32.910]                   NAME <- NAMES[[kk]]
[09:32:32.910]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.910]                     next
[09:32:32.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.910]                 }
[09:32:32.910]                 if (length(args) > 0) 
[09:32:32.910]                   base::do.call(base::Sys.setenv, args = args)
[09:32:32.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:32.910]             }
[09:32:32.910]             else {
[09:32:32.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:32.910]             }
[09:32:32.910]             {
[09:32:32.910]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:32.910]                   0L) {
[09:32:32.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:32.910]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:32.910]                   base::options(opts)
[09:32:32.910]                 }
[09:32:32.910]                 {
[09:32:32.910]                   {
[09:32:32.910]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:32.910]                     NULL
[09:32:32.910]                   }
[09:32:32.910]                   options(future.plan = NULL)
[09:32:32.910]                   if (is.na(NA_character_)) 
[09:32:32.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:32.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:32.910]                     .init = FALSE)
[09:32:32.910]                 }
[09:32:32.910]             }
[09:32:32.910]         }
[09:32:32.910]     })
[09:32:32.910]     if (TRUE) {
[09:32:32.910]         base::sink(type = "output", split = FALSE)
[09:32:32.910]         if (TRUE) {
[09:32:32.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:32.910]         }
[09:32:32.910]         else {
[09:32:32.910]             ...future.result["stdout"] <- base::list(NULL)
[09:32:32.910]         }
[09:32:32.910]         base::close(...future.stdout)
[09:32:32.910]         ...future.stdout <- NULL
[09:32:32.910]     }
[09:32:32.910]     ...future.result$conditions <- ...future.conditions
[09:32:32.910]     ...future.result$finished <- base::Sys.time()
[09:32:32.910]     ...future.result
[09:32:32.910] }
[09:32:32.913] MultisessionFuture started
[09:32:32.913] - Launch lazy future ... done
[09:32:32.913] run() for ‘MultisessionFuture’ ... done
[09:32:32.914] receiveMessageFromWorker() for ClusterFuture ...
[09:32:32.914] - Validating connection of MultisessionFuture
[09:32:32.915] - received message: FutureResult
[09:32:32.915] - Received FutureResult
[09:32:32.915] - Erased future from FutureRegistry
[09:32:32.915] result() for ClusterFuture ...
[09:32:32.915] - result already collected: FutureResult
[09:32:32.915] result() for ClusterFuture ... done
[09:32:32.915] signalConditions() ...
[09:32:32.915]  - include = ‘immediateCondition’
[09:32:32.916]  - exclude = 
[09:32:32.916]  - resignal = FALSE
[09:32:32.916]  - Number of conditions: 1
[09:32:32.916] signalConditions() ... done
[09:32:32.916] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:32.916] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[09:32:32.916] getGlobalsAndPackages() ...
[09:32:32.916] Searching for globals...
[09:32:32.917] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:32.917] Searching for globals ... DONE
[09:32:32.918] Resolving globals: FALSE
[09:32:32.918] 
[09:32:32.918] 
[09:32:32.918] getGlobalsAndPackages() ... DONE
[09:32:32.918] run() for ‘Future’ ...
[09:32:32.918] - state: ‘created’
[09:32:32.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:32.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:32.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:32.932]   - Field: ‘node’
[09:32:32.932]   - Field: ‘label’
[09:32:32.932]   - Field: ‘local’
[09:32:32.932]   - Field: ‘owner’
[09:32:32.932]   - Field: ‘envir’
[09:32:32.932]   - Field: ‘workers’
[09:32:32.932]   - Field: ‘packages’
[09:32:32.933]   - Field: ‘gc’
[09:32:32.933]   - Field: ‘conditions’
[09:32:32.933]   - Field: ‘persistent’
[09:32:32.933]   - Field: ‘expr’
[09:32:32.933]   - Field: ‘uuid’
[09:32:32.933]   - Field: ‘seed’
[09:32:32.933]   - Field: ‘version’
[09:32:32.933]   - Field: ‘result’
[09:32:32.933]   - Field: ‘asynchronous’
[09:32:32.933]   - Field: ‘calls’
[09:32:32.933]   - Field: ‘globals’
[09:32:32.934]   - Field: ‘stdout’
[09:32:32.934]   - Field: ‘earlySignal’
[09:32:32.934]   - Field: ‘lazy’
[09:32:32.934]   - Field: ‘state’
[09:32:32.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:32.934] - Launch lazy future ...
[09:32:32.934] Packages needed by the future expression (n = 0): <none>
[09:32:32.934] Packages needed by future strategies (n = 0): <none>
[09:32:32.935] {
[09:32:32.935]     {
[09:32:32.935]         {
[09:32:32.935]             ...future.startTime <- base::Sys.time()
[09:32:32.935]             {
[09:32:32.935]                 {
[09:32:32.935]                   {
[09:32:32.935]                     {
[09:32:32.935]                       base::local({
[09:32:32.935]                         has_future <- base::requireNamespace("future", 
[09:32:32.935]                           quietly = TRUE)
[09:32:32.935]                         if (has_future) {
[09:32:32.935]                           ns <- base::getNamespace("future")
[09:32:32.935]                           version <- ns[[".package"]][["version"]]
[09:32:32.935]                           if (is.null(version)) 
[09:32:32.935]                             version <- utils::packageVersion("future")
[09:32:32.935]                         }
[09:32:32.935]                         else {
[09:32:32.935]                           version <- NULL
[09:32:32.935]                         }
[09:32:32.935]                         if (!has_future || version < "1.8.0") {
[09:32:32.935]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:32.935]                             "", base::R.version$version.string), 
[09:32:32.935]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:32.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:32.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:32.935]                               "release", "version")], collapse = " "), 
[09:32:32.935]                             hostname = base::Sys.info()[["nodename"]])
[09:32:32.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:32.935]                             info)
[09:32:32.935]                           info <- base::paste(info, collapse = "; ")
[09:32:32.935]                           if (!has_future) {
[09:32:32.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:32.935]                               info)
[09:32:32.935]                           }
[09:32:32.935]                           else {
[09:32:32.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:32.935]                               info, version)
[09:32:32.935]                           }
[09:32:32.935]                           base::stop(msg)
[09:32:32.935]                         }
[09:32:32.935]                       })
[09:32:32.935]                     }
[09:32:32.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:32.935]                     base::options(mc.cores = 1L)
[09:32:32.935]                   }
[09:32:32.935]                   ...future.strategy.old <- future::plan("list")
[09:32:32.935]                   options(future.plan = NULL)
[09:32:32.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:32.935]                 }
[09:32:32.935]                 ...future.workdir <- getwd()
[09:32:32.935]             }
[09:32:32.935]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:32.935]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:32.935]         }
[09:32:32.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:32.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:32.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:32.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:32.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:32.935]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:32.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:32.935]             base::names(...future.oldOptions))
[09:32:32.935]     }
[09:32:32.935]     if (FALSE) {
[09:32:32.935]     }
[09:32:32.935]     else {
[09:32:32.935]         if (TRUE) {
[09:32:32.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:32.935]                 open = "w")
[09:32:32.935]         }
[09:32:32.935]         else {
[09:32:32.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:32.935]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:32.935]         }
[09:32:32.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:32.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:32.935]             base::sink(type = "output", split = FALSE)
[09:32:32.935]             base::close(...future.stdout)
[09:32:32.935]         }, add = TRUE)
[09:32:32.935]     }
[09:32:32.935]     ...future.frame <- base::sys.nframe()
[09:32:32.935]     ...future.conditions <- base::list()
[09:32:32.935]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:32.935]     if (FALSE) {
[09:32:32.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:32.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:32.935]     }
[09:32:32.935]     ...future.result <- base::tryCatch({
[09:32:32.935]         base::withCallingHandlers({
[09:32:32.935]             ...future.value <- base::withVisible(base::local({
[09:32:32.935]                 ...future.makeSendCondition <- base::local({
[09:32:32.935]                   sendCondition <- NULL
[09:32:32.935]                   function(frame = 1L) {
[09:32:32.935]                     if (is.function(sendCondition)) 
[09:32:32.935]                       return(sendCondition)
[09:32:32.935]                     ns <- getNamespace("parallel")
[09:32:32.935]                     if (exists("sendData", mode = "function", 
[09:32:32.935]                       envir = ns)) {
[09:32:32.935]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:32.935]                         envir = ns)
[09:32:32.935]                       envir <- sys.frame(frame)
[09:32:32.935]                       master <- NULL
[09:32:32.935]                       while (!identical(envir, .GlobalEnv) && 
[09:32:32.935]                         !identical(envir, emptyenv())) {
[09:32:32.935]                         if (exists("master", mode = "list", envir = envir, 
[09:32:32.935]                           inherits = FALSE)) {
[09:32:32.935]                           master <- get("master", mode = "list", 
[09:32:32.935]                             envir = envir, inherits = FALSE)
[09:32:32.935]                           if (inherits(master, c("SOCKnode", 
[09:32:32.935]                             "SOCK0node"))) {
[09:32:32.935]                             sendCondition <<- function(cond) {
[09:32:32.935]                               data <- list(type = "VALUE", value = cond, 
[09:32:32.935]                                 success = TRUE)
[09:32:32.935]                               parallel_sendData(master, data)
[09:32:32.935]                             }
[09:32:32.935]                             return(sendCondition)
[09:32:32.935]                           }
[09:32:32.935]                         }
[09:32:32.935]                         frame <- frame + 1L
[09:32:32.935]                         envir <- sys.frame(frame)
[09:32:32.935]                       }
[09:32:32.935]                     }
[09:32:32.935]                     sendCondition <<- function(cond) NULL
[09:32:32.935]                   }
[09:32:32.935]                 })
[09:32:32.935]                 withCallingHandlers({
[09:32:32.935]                   {
[09:32:32.935]                     Sys.sleep(0.5)
[09:32:32.935]                     list(a = 1, b = 42L)
[09:32:32.935]                   }
[09:32:32.935]                 }, immediateCondition = function(cond) {
[09:32:32.935]                   sendCondition <- ...future.makeSendCondition()
[09:32:32.935]                   sendCondition(cond)
[09:32:32.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.935]                   {
[09:32:32.935]                     inherits <- base::inherits
[09:32:32.935]                     invokeRestart <- base::invokeRestart
[09:32:32.935]                     is.null <- base::is.null
[09:32:32.935]                     muffled <- FALSE
[09:32:32.935]                     if (inherits(cond, "message")) {
[09:32:32.935]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:32.935]                       if (muffled) 
[09:32:32.935]                         invokeRestart("muffleMessage")
[09:32:32.935]                     }
[09:32:32.935]                     else if (inherits(cond, "warning")) {
[09:32:32.935]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:32.935]                       if (muffled) 
[09:32:32.935]                         invokeRestart("muffleWarning")
[09:32:32.935]                     }
[09:32:32.935]                     else if (inherits(cond, "condition")) {
[09:32:32.935]                       if (!is.null(pattern)) {
[09:32:32.935]                         computeRestarts <- base::computeRestarts
[09:32:32.935]                         grepl <- base::grepl
[09:32:32.935]                         restarts <- computeRestarts(cond)
[09:32:32.935]                         for (restart in restarts) {
[09:32:32.935]                           name <- restart$name
[09:32:32.935]                           if (is.null(name)) 
[09:32:32.935]                             next
[09:32:32.935]                           if (!grepl(pattern, name)) 
[09:32:32.935]                             next
[09:32:32.935]                           invokeRestart(restart)
[09:32:32.935]                           muffled <- TRUE
[09:32:32.935]                           break
[09:32:32.935]                         }
[09:32:32.935]                       }
[09:32:32.935]                     }
[09:32:32.935]                     invisible(muffled)
[09:32:32.935]                   }
[09:32:32.935]                   muffleCondition(cond)
[09:32:32.935]                 })
[09:32:32.935]             }))
[09:32:32.935]             future::FutureResult(value = ...future.value$value, 
[09:32:32.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.935]                   ...future.rng), globalenv = if (FALSE) 
[09:32:32.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:32.935]                     ...future.globalenv.names))
[09:32:32.935]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:32.935]         }, condition = base::local({
[09:32:32.935]             c <- base::c
[09:32:32.935]             inherits <- base::inherits
[09:32:32.935]             invokeRestart <- base::invokeRestart
[09:32:32.935]             length <- base::length
[09:32:32.935]             list <- base::list
[09:32:32.935]             seq.int <- base::seq.int
[09:32:32.935]             signalCondition <- base::signalCondition
[09:32:32.935]             sys.calls <- base::sys.calls
[09:32:32.935]             `[[` <- base::`[[`
[09:32:32.935]             `+` <- base::`+`
[09:32:32.935]             `<<-` <- base::`<<-`
[09:32:32.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:32.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:32.935]                   3L)]
[09:32:32.935]             }
[09:32:32.935]             function(cond) {
[09:32:32.935]                 is_error <- inherits(cond, "error")
[09:32:32.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:32.935]                   NULL)
[09:32:32.935]                 if (is_error) {
[09:32:32.935]                   sessionInformation <- function() {
[09:32:32.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:32.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:32.935]                       search = base::search(), system = base::Sys.info())
[09:32:32.935]                   }
[09:32:32.935]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:32.935]                     cond$call), session = sessionInformation(), 
[09:32:32.935]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:32.935]                   signalCondition(cond)
[09:32:32.935]                 }
[09:32:32.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:32.935]                 "immediateCondition"))) {
[09:32:32.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:32.935]                   ...future.conditions[[length(...future.conditions) + 
[09:32:32.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:32.935]                   if (TRUE && !signal) {
[09:32:32.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.935]                     {
[09:32:32.935]                       inherits <- base::inherits
[09:32:32.935]                       invokeRestart <- base::invokeRestart
[09:32:32.935]                       is.null <- base::is.null
[09:32:32.935]                       muffled <- FALSE
[09:32:32.935]                       if (inherits(cond, "message")) {
[09:32:32.935]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.935]                         if (muffled) 
[09:32:32.935]                           invokeRestart("muffleMessage")
[09:32:32.935]                       }
[09:32:32.935]                       else if (inherits(cond, "warning")) {
[09:32:32.935]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.935]                         if (muffled) 
[09:32:32.935]                           invokeRestart("muffleWarning")
[09:32:32.935]                       }
[09:32:32.935]                       else if (inherits(cond, "condition")) {
[09:32:32.935]                         if (!is.null(pattern)) {
[09:32:32.935]                           computeRestarts <- base::computeRestarts
[09:32:32.935]                           grepl <- base::grepl
[09:32:32.935]                           restarts <- computeRestarts(cond)
[09:32:32.935]                           for (restart in restarts) {
[09:32:32.935]                             name <- restart$name
[09:32:32.935]                             if (is.null(name)) 
[09:32:32.935]                               next
[09:32:32.935]                             if (!grepl(pattern, name)) 
[09:32:32.935]                               next
[09:32:32.935]                             invokeRestart(restart)
[09:32:32.935]                             muffled <- TRUE
[09:32:32.935]                             break
[09:32:32.935]                           }
[09:32:32.935]                         }
[09:32:32.935]                       }
[09:32:32.935]                       invisible(muffled)
[09:32:32.935]                     }
[09:32:32.935]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.935]                   }
[09:32:32.935]                 }
[09:32:32.935]                 else {
[09:32:32.935]                   if (TRUE) {
[09:32:32.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:32.935]                     {
[09:32:32.935]                       inherits <- base::inherits
[09:32:32.935]                       invokeRestart <- base::invokeRestart
[09:32:32.935]                       is.null <- base::is.null
[09:32:32.935]                       muffled <- FALSE
[09:32:32.935]                       if (inherits(cond, "message")) {
[09:32:32.935]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:32.935]                         if (muffled) 
[09:32:32.935]                           invokeRestart("muffleMessage")
[09:32:32.935]                       }
[09:32:32.935]                       else if (inherits(cond, "warning")) {
[09:32:32.935]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:32.935]                         if (muffled) 
[09:32:32.935]                           invokeRestart("muffleWarning")
[09:32:32.935]                       }
[09:32:32.935]                       else if (inherits(cond, "condition")) {
[09:32:32.935]                         if (!is.null(pattern)) {
[09:32:32.935]                           computeRestarts <- base::computeRestarts
[09:32:32.935]                           grepl <- base::grepl
[09:32:32.935]                           restarts <- computeRestarts(cond)
[09:32:32.935]                           for (restart in restarts) {
[09:32:32.935]                             name <- restart$name
[09:32:32.935]                             if (is.null(name)) 
[09:32:32.935]                               next
[09:32:32.935]                             if (!grepl(pattern, name)) 
[09:32:32.935]                               next
[09:32:32.935]                             invokeRestart(restart)
[09:32:32.935]                             muffled <- TRUE
[09:32:32.935]                             break
[09:32:32.935]                           }
[09:32:32.935]                         }
[09:32:32.935]                       }
[09:32:32.935]                       invisible(muffled)
[09:32:32.935]                     }
[09:32:32.935]                     muffleCondition(cond, pattern = "^muffle")
[09:32:32.935]                   }
[09:32:32.935]                 }
[09:32:32.935]             }
[09:32:32.935]         }))
[09:32:32.935]     }, error = function(ex) {
[09:32:32.935]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:32.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:32.935]                 ...future.rng), started = ...future.startTime, 
[09:32:32.935]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:32.935]             version = "1.8"), class = "FutureResult")
[09:32:32.935]     }, finally = {
[09:32:32.935]         if (!identical(...future.workdir, getwd())) 
[09:32:32.935]             setwd(...future.workdir)
[09:32:32.935]         {
[09:32:32.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:32.935]                 ...future.oldOptions$nwarnings <- NULL
[09:32:32.935]             }
[09:32:32.935]             base::options(...future.oldOptions)
[09:32:32.935]             if (.Platform$OS.type == "windows") {
[09:32:32.935]                 old_names <- names(...future.oldEnvVars)
[09:32:32.935]                 envs <- base::Sys.getenv()
[09:32:32.935]                 names <- names(envs)
[09:32:32.935]                 common <- intersect(names, old_names)
[09:32:32.935]                 added <- setdiff(names, old_names)
[09:32:32.935]                 removed <- setdiff(old_names, names)
[09:32:32.935]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:32.935]                   envs[common]]
[09:32:32.935]                 NAMES <- toupper(changed)
[09:32:32.935]                 args <- list()
[09:32:32.935]                 for (kk in seq_along(NAMES)) {
[09:32:32.935]                   name <- changed[[kk]]
[09:32:32.935]                   NAME <- NAMES[[kk]]
[09:32:32.935]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.935]                     next
[09:32:32.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.935]                 }
[09:32:32.935]                 NAMES <- toupper(added)
[09:32:32.935]                 for (kk in seq_along(NAMES)) {
[09:32:32.935]                   name <- added[[kk]]
[09:32:32.935]                   NAME <- NAMES[[kk]]
[09:32:32.935]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.935]                     next
[09:32:32.935]                   args[[name]] <- ""
[09:32:32.935]                 }
[09:32:32.935]                 NAMES <- toupper(removed)
[09:32:32.935]                 for (kk in seq_along(NAMES)) {
[09:32:32.935]                   name <- removed[[kk]]
[09:32:32.935]                   NAME <- NAMES[[kk]]
[09:32:32.935]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:32.935]                     next
[09:32:32.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:32.935]                 }
[09:32:32.935]                 if (length(args) > 0) 
[09:32:32.935]                   base::do.call(base::Sys.setenv, args = args)
[09:32:32.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:32.935]             }
[09:32:32.935]             else {
[09:32:32.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:32.935]             }
[09:32:32.935]             {
[09:32:32.935]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:32.935]                   0L) {
[09:32:32.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:32.935]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:32.935]                   base::options(opts)
[09:32:32.935]                 }
[09:32:32.935]                 {
[09:32:32.935]                   {
[09:32:32.935]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:32.935]                     NULL
[09:32:32.935]                   }
[09:32:32.935]                   options(future.plan = NULL)
[09:32:32.935]                   if (is.na(NA_character_)) 
[09:32:32.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:32.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:32.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:32.935]                     .init = FALSE)
[09:32:32.935]                 }
[09:32:32.935]             }
[09:32:32.935]         }
[09:32:32.935]     })
[09:32:32.935]     if (TRUE) {
[09:32:32.935]         base::sink(type = "output", split = FALSE)
[09:32:32.935]         if (TRUE) {
[09:32:32.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:32.935]         }
[09:32:32.935]         else {
[09:32:32.935]             ...future.result["stdout"] <- base::list(NULL)
[09:32:32.935]         }
[09:32:32.935]         base::close(...future.stdout)
[09:32:32.935]         ...future.stdout <- NULL
[09:32:32.935]     }
[09:32:32.935]     ...future.result$conditions <- ...future.conditions
[09:32:32.935]     ...future.result$finished <- base::Sys.time()
[09:32:32.935]     ...future.result
[09:32:32.935] }
[09:32:32.938] MultisessionFuture started
[09:32:32.938] - Launch lazy future ... done
[09:32:32.938] run() for ‘MultisessionFuture’ ... done
[09:32:33.440] receiveMessageFromWorker() for ClusterFuture ...
[09:32:33.440] - Validating connection of MultisessionFuture
[09:32:33.441] - received message: FutureResult
[09:32:33.441] - Received FutureResult
[09:32:33.441] - Erased future from FutureRegistry
[09:32:33.441] result() for ClusterFuture ...
[09:32:33.441] - result already collected: FutureResult
[09:32:33.441] result() for ClusterFuture ... done
[09:32:33.441] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:33.441] resolve() on list ...
[09:32:33.441]  recursive: 0
[09:32:33.441]  length: 2
[09:32:33.441]  elements: ‘a’, ‘b’
[09:32:33.442]  length: 1 (resolved future 1)
[09:32:33.442]  length: 0 (resolved future 2)
[09:32:33.442] resolve() on list ... DONE
[09:32:33.442] A MultisessionFuture was resolved (and resolved itself)
[09:32:33.442] getGlobalsAndPackages() ...
[09:32:33.442] Searching for globals...
[09:32:33.443] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:33.443] Searching for globals ... DONE
[09:32:33.443] Resolving globals: FALSE
[09:32:33.444] 
[09:32:33.444] 
[09:32:33.444] getGlobalsAndPackages() ... DONE
[09:32:33.444] run() for ‘Future’ ...
[09:32:33.444] - state: ‘created’
[09:32:33.444] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:33.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:33.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:33.458]   - Field: ‘node’
[09:32:33.458]   - Field: ‘label’
[09:32:33.458]   - Field: ‘local’
[09:32:33.458]   - Field: ‘owner’
[09:32:33.459]   - Field: ‘envir’
[09:32:33.459]   - Field: ‘workers’
[09:32:33.459]   - Field: ‘packages’
[09:32:33.459]   - Field: ‘gc’
[09:32:33.459]   - Field: ‘conditions’
[09:32:33.459]   - Field: ‘persistent’
[09:32:33.459]   - Field: ‘expr’
[09:32:33.459]   - Field: ‘uuid’
[09:32:33.459]   - Field: ‘seed’
[09:32:33.459]   - Field: ‘version’
[09:32:33.459]   - Field: ‘result’
[09:32:33.460]   - Field: ‘asynchronous’
[09:32:33.460]   - Field: ‘calls’
[09:32:33.460]   - Field: ‘globals’
[09:32:33.460]   - Field: ‘stdout’
[09:32:33.460]   - Field: ‘earlySignal’
[09:32:33.460]   - Field: ‘lazy’
[09:32:33.460]   - Field: ‘state’
[09:32:33.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:33.460] - Launch lazy future ...
[09:32:33.461] Packages needed by the future expression (n = 0): <none>
[09:32:33.461] Packages needed by future strategies (n = 0): <none>
[09:32:33.461] {
[09:32:33.461]     {
[09:32:33.461]         {
[09:32:33.461]             ...future.startTime <- base::Sys.time()
[09:32:33.461]             {
[09:32:33.461]                 {
[09:32:33.461]                   {
[09:32:33.461]                     {
[09:32:33.461]                       base::local({
[09:32:33.461]                         has_future <- base::requireNamespace("future", 
[09:32:33.461]                           quietly = TRUE)
[09:32:33.461]                         if (has_future) {
[09:32:33.461]                           ns <- base::getNamespace("future")
[09:32:33.461]                           version <- ns[[".package"]][["version"]]
[09:32:33.461]                           if (is.null(version)) 
[09:32:33.461]                             version <- utils::packageVersion("future")
[09:32:33.461]                         }
[09:32:33.461]                         else {
[09:32:33.461]                           version <- NULL
[09:32:33.461]                         }
[09:32:33.461]                         if (!has_future || version < "1.8.0") {
[09:32:33.461]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:33.461]                             "", base::R.version$version.string), 
[09:32:33.461]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:33.461]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:33.461]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:33.461]                               "release", "version")], collapse = " "), 
[09:32:33.461]                             hostname = base::Sys.info()[["nodename"]])
[09:32:33.461]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:33.461]                             info)
[09:32:33.461]                           info <- base::paste(info, collapse = "; ")
[09:32:33.461]                           if (!has_future) {
[09:32:33.461]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:33.461]                               info)
[09:32:33.461]                           }
[09:32:33.461]                           else {
[09:32:33.461]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:33.461]                               info, version)
[09:32:33.461]                           }
[09:32:33.461]                           base::stop(msg)
[09:32:33.461]                         }
[09:32:33.461]                       })
[09:32:33.461]                     }
[09:32:33.461]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:33.461]                     base::options(mc.cores = 1L)
[09:32:33.461]                   }
[09:32:33.461]                   ...future.strategy.old <- future::plan("list")
[09:32:33.461]                   options(future.plan = NULL)
[09:32:33.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:33.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:33.461]                 }
[09:32:33.461]                 ...future.workdir <- getwd()
[09:32:33.461]             }
[09:32:33.461]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:33.461]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:33.461]         }
[09:32:33.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:33.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:33.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:33.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:33.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:33.461]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:33.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:33.461]             base::names(...future.oldOptions))
[09:32:33.461]     }
[09:32:33.461]     if (FALSE) {
[09:32:33.461]     }
[09:32:33.461]     else {
[09:32:33.461]         if (TRUE) {
[09:32:33.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:33.461]                 open = "w")
[09:32:33.461]         }
[09:32:33.461]         else {
[09:32:33.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:33.461]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:33.461]         }
[09:32:33.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:33.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:33.461]             base::sink(type = "output", split = FALSE)
[09:32:33.461]             base::close(...future.stdout)
[09:32:33.461]         }, add = TRUE)
[09:32:33.461]     }
[09:32:33.461]     ...future.frame <- base::sys.nframe()
[09:32:33.461]     ...future.conditions <- base::list()
[09:32:33.461]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:33.461]     if (FALSE) {
[09:32:33.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:33.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:33.461]     }
[09:32:33.461]     ...future.result <- base::tryCatch({
[09:32:33.461]         base::withCallingHandlers({
[09:32:33.461]             ...future.value <- base::withVisible(base::local({
[09:32:33.461]                 ...future.makeSendCondition <- base::local({
[09:32:33.461]                   sendCondition <- NULL
[09:32:33.461]                   function(frame = 1L) {
[09:32:33.461]                     if (is.function(sendCondition)) 
[09:32:33.461]                       return(sendCondition)
[09:32:33.461]                     ns <- getNamespace("parallel")
[09:32:33.461]                     if (exists("sendData", mode = "function", 
[09:32:33.461]                       envir = ns)) {
[09:32:33.461]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:33.461]                         envir = ns)
[09:32:33.461]                       envir <- sys.frame(frame)
[09:32:33.461]                       master <- NULL
[09:32:33.461]                       while (!identical(envir, .GlobalEnv) && 
[09:32:33.461]                         !identical(envir, emptyenv())) {
[09:32:33.461]                         if (exists("master", mode = "list", envir = envir, 
[09:32:33.461]                           inherits = FALSE)) {
[09:32:33.461]                           master <- get("master", mode = "list", 
[09:32:33.461]                             envir = envir, inherits = FALSE)
[09:32:33.461]                           if (inherits(master, c("SOCKnode", 
[09:32:33.461]                             "SOCK0node"))) {
[09:32:33.461]                             sendCondition <<- function(cond) {
[09:32:33.461]                               data <- list(type = "VALUE", value = cond, 
[09:32:33.461]                                 success = TRUE)
[09:32:33.461]                               parallel_sendData(master, data)
[09:32:33.461]                             }
[09:32:33.461]                             return(sendCondition)
[09:32:33.461]                           }
[09:32:33.461]                         }
[09:32:33.461]                         frame <- frame + 1L
[09:32:33.461]                         envir <- sys.frame(frame)
[09:32:33.461]                       }
[09:32:33.461]                     }
[09:32:33.461]                     sendCondition <<- function(cond) NULL
[09:32:33.461]                   }
[09:32:33.461]                 })
[09:32:33.461]                 withCallingHandlers({
[09:32:33.461]                   {
[09:32:33.461]                     Sys.sleep(0.5)
[09:32:33.461]                     list(a = 1, b = 42L)
[09:32:33.461]                   }
[09:32:33.461]                 }, immediateCondition = function(cond) {
[09:32:33.461]                   sendCondition <- ...future.makeSendCondition()
[09:32:33.461]                   sendCondition(cond)
[09:32:33.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.461]                   {
[09:32:33.461]                     inherits <- base::inherits
[09:32:33.461]                     invokeRestart <- base::invokeRestart
[09:32:33.461]                     is.null <- base::is.null
[09:32:33.461]                     muffled <- FALSE
[09:32:33.461]                     if (inherits(cond, "message")) {
[09:32:33.461]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:33.461]                       if (muffled) 
[09:32:33.461]                         invokeRestart("muffleMessage")
[09:32:33.461]                     }
[09:32:33.461]                     else if (inherits(cond, "warning")) {
[09:32:33.461]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:33.461]                       if (muffled) 
[09:32:33.461]                         invokeRestart("muffleWarning")
[09:32:33.461]                     }
[09:32:33.461]                     else if (inherits(cond, "condition")) {
[09:32:33.461]                       if (!is.null(pattern)) {
[09:32:33.461]                         computeRestarts <- base::computeRestarts
[09:32:33.461]                         grepl <- base::grepl
[09:32:33.461]                         restarts <- computeRestarts(cond)
[09:32:33.461]                         for (restart in restarts) {
[09:32:33.461]                           name <- restart$name
[09:32:33.461]                           if (is.null(name)) 
[09:32:33.461]                             next
[09:32:33.461]                           if (!grepl(pattern, name)) 
[09:32:33.461]                             next
[09:32:33.461]                           invokeRestart(restart)
[09:32:33.461]                           muffled <- TRUE
[09:32:33.461]                           break
[09:32:33.461]                         }
[09:32:33.461]                       }
[09:32:33.461]                     }
[09:32:33.461]                     invisible(muffled)
[09:32:33.461]                   }
[09:32:33.461]                   muffleCondition(cond)
[09:32:33.461]                 })
[09:32:33.461]             }))
[09:32:33.461]             future::FutureResult(value = ...future.value$value, 
[09:32:33.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:33.461]                   ...future.rng), globalenv = if (FALSE) 
[09:32:33.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:33.461]                     ...future.globalenv.names))
[09:32:33.461]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:33.461]         }, condition = base::local({
[09:32:33.461]             c <- base::c
[09:32:33.461]             inherits <- base::inherits
[09:32:33.461]             invokeRestart <- base::invokeRestart
[09:32:33.461]             length <- base::length
[09:32:33.461]             list <- base::list
[09:32:33.461]             seq.int <- base::seq.int
[09:32:33.461]             signalCondition <- base::signalCondition
[09:32:33.461]             sys.calls <- base::sys.calls
[09:32:33.461]             `[[` <- base::`[[`
[09:32:33.461]             `+` <- base::`+`
[09:32:33.461]             `<<-` <- base::`<<-`
[09:32:33.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:33.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:33.461]                   3L)]
[09:32:33.461]             }
[09:32:33.461]             function(cond) {
[09:32:33.461]                 is_error <- inherits(cond, "error")
[09:32:33.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:33.461]                   NULL)
[09:32:33.461]                 if (is_error) {
[09:32:33.461]                   sessionInformation <- function() {
[09:32:33.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:33.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:33.461]                       search = base::search(), system = base::Sys.info())
[09:32:33.461]                   }
[09:32:33.461]                   ...future.conditions[[length(...future.conditions) + 
[09:32:33.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:33.461]                     cond$call), session = sessionInformation(), 
[09:32:33.461]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:33.461]                   signalCondition(cond)
[09:32:33.461]                 }
[09:32:33.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:33.461]                 "immediateCondition"))) {
[09:32:33.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:33.461]                   ...future.conditions[[length(...future.conditions) + 
[09:32:33.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:33.461]                   if (TRUE && !signal) {
[09:32:33.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.461]                     {
[09:32:33.461]                       inherits <- base::inherits
[09:32:33.461]                       invokeRestart <- base::invokeRestart
[09:32:33.461]                       is.null <- base::is.null
[09:32:33.461]                       muffled <- FALSE
[09:32:33.461]                       if (inherits(cond, "message")) {
[09:32:33.461]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:33.461]                         if (muffled) 
[09:32:33.461]                           invokeRestart("muffleMessage")
[09:32:33.461]                       }
[09:32:33.461]                       else if (inherits(cond, "warning")) {
[09:32:33.461]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:33.461]                         if (muffled) 
[09:32:33.461]                           invokeRestart("muffleWarning")
[09:32:33.461]                       }
[09:32:33.461]                       else if (inherits(cond, "condition")) {
[09:32:33.461]                         if (!is.null(pattern)) {
[09:32:33.461]                           computeRestarts <- base::computeRestarts
[09:32:33.461]                           grepl <- base::grepl
[09:32:33.461]                           restarts <- computeRestarts(cond)
[09:32:33.461]                           for (restart in restarts) {
[09:32:33.461]                             name <- restart$name
[09:32:33.461]                             if (is.null(name)) 
[09:32:33.461]                               next
[09:32:33.461]                             if (!grepl(pattern, name)) 
[09:32:33.461]                               next
[09:32:33.461]                             invokeRestart(restart)
[09:32:33.461]                             muffled <- TRUE
[09:32:33.461]                             break
[09:32:33.461]                           }
[09:32:33.461]                         }
[09:32:33.461]                       }
[09:32:33.461]                       invisible(muffled)
[09:32:33.461]                     }
[09:32:33.461]                     muffleCondition(cond, pattern = "^muffle")
[09:32:33.461]                   }
[09:32:33.461]                 }
[09:32:33.461]                 else {
[09:32:33.461]                   if (TRUE) {
[09:32:33.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.461]                     {
[09:32:33.461]                       inherits <- base::inherits
[09:32:33.461]                       invokeRestart <- base::invokeRestart
[09:32:33.461]                       is.null <- base::is.null
[09:32:33.461]                       muffled <- FALSE
[09:32:33.461]                       if (inherits(cond, "message")) {
[09:32:33.461]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:33.461]                         if (muffled) 
[09:32:33.461]                           invokeRestart("muffleMessage")
[09:32:33.461]                       }
[09:32:33.461]                       else if (inherits(cond, "warning")) {
[09:32:33.461]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:33.461]                         if (muffled) 
[09:32:33.461]                           invokeRestart("muffleWarning")
[09:32:33.461]                       }
[09:32:33.461]                       else if (inherits(cond, "condition")) {
[09:32:33.461]                         if (!is.null(pattern)) {
[09:32:33.461]                           computeRestarts <- base::computeRestarts
[09:32:33.461]                           grepl <- base::grepl
[09:32:33.461]                           restarts <- computeRestarts(cond)
[09:32:33.461]                           for (restart in restarts) {
[09:32:33.461]                             name <- restart$name
[09:32:33.461]                             if (is.null(name)) 
[09:32:33.461]                               next
[09:32:33.461]                             if (!grepl(pattern, name)) 
[09:32:33.461]                               next
[09:32:33.461]                             invokeRestart(restart)
[09:32:33.461]                             muffled <- TRUE
[09:32:33.461]                             break
[09:32:33.461]                           }
[09:32:33.461]                         }
[09:32:33.461]                       }
[09:32:33.461]                       invisible(muffled)
[09:32:33.461]                     }
[09:32:33.461]                     muffleCondition(cond, pattern = "^muffle")
[09:32:33.461]                   }
[09:32:33.461]                 }
[09:32:33.461]             }
[09:32:33.461]         }))
[09:32:33.461]     }, error = function(ex) {
[09:32:33.461]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:33.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:33.461]                 ...future.rng), started = ...future.startTime, 
[09:32:33.461]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:33.461]             version = "1.8"), class = "FutureResult")
[09:32:33.461]     }, finally = {
[09:32:33.461]         if (!identical(...future.workdir, getwd())) 
[09:32:33.461]             setwd(...future.workdir)
[09:32:33.461]         {
[09:32:33.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:33.461]                 ...future.oldOptions$nwarnings <- NULL
[09:32:33.461]             }
[09:32:33.461]             base::options(...future.oldOptions)
[09:32:33.461]             if (.Platform$OS.type == "windows") {
[09:32:33.461]                 old_names <- names(...future.oldEnvVars)
[09:32:33.461]                 envs <- base::Sys.getenv()
[09:32:33.461]                 names <- names(envs)
[09:32:33.461]                 common <- intersect(names, old_names)
[09:32:33.461]                 added <- setdiff(names, old_names)
[09:32:33.461]                 removed <- setdiff(old_names, names)
[09:32:33.461]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:33.461]                   envs[common]]
[09:32:33.461]                 NAMES <- toupper(changed)
[09:32:33.461]                 args <- list()
[09:32:33.461]                 for (kk in seq_along(NAMES)) {
[09:32:33.461]                   name <- changed[[kk]]
[09:32:33.461]                   NAME <- NAMES[[kk]]
[09:32:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.461]                     next
[09:32:33.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:33.461]                 }
[09:32:33.461]                 NAMES <- toupper(added)
[09:32:33.461]                 for (kk in seq_along(NAMES)) {
[09:32:33.461]                   name <- added[[kk]]
[09:32:33.461]                   NAME <- NAMES[[kk]]
[09:32:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.461]                     next
[09:32:33.461]                   args[[name]] <- ""
[09:32:33.461]                 }
[09:32:33.461]                 NAMES <- toupper(removed)
[09:32:33.461]                 for (kk in seq_along(NAMES)) {
[09:32:33.461]                   name <- removed[[kk]]
[09:32:33.461]                   NAME <- NAMES[[kk]]
[09:32:33.461]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.461]                     next
[09:32:33.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:33.461]                 }
[09:32:33.461]                 if (length(args) > 0) 
[09:32:33.461]                   base::do.call(base::Sys.setenv, args = args)
[09:32:33.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:33.461]             }
[09:32:33.461]             else {
[09:32:33.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:33.461]             }
[09:32:33.461]             {
[09:32:33.461]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:33.461]                   0L) {
[09:32:33.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:33.461]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:33.461]                   base::options(opts)
[09:32:33.461]                 }
[09:32:33.461]                 {
[09:32:33.461]                   {
[09:32:33.461]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:33.461]                     NULL
[09:32:33.461]                   }
[09:32:33.461]                   options(future.plan = NULL)
[09:32:33.461]                   if (is.na(NA_character_)) 
[09:32:33.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:33.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:33.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:33.461]                     .init = FALSE)
[09:32:33.461]                 }
[09:32:33.461]             }
[09:32:33.461]         }
[09:32:33.461]     })
[09:32:33.461]     if (TRUE) {
[09:32:33.461]         base::sink(type = "output", split = FALSE)
[09:32:33.461]         if (TRUE) {
[09:32:33.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:33.461]         }
[09:32:33.461]         else {
[09:32:33.461]             ...future.result["stdout"] <- base::list(NULL)
[09:32:33.461]         }
[09:32:33.461]         base::close(...future.stdout)
[09:32:33.461]         ...future.stdout <- NULL
[09:32:33.461]     }
[09:32:33.461]     ...future.result$conditions <- ...future.conditions
[09:32:33.461]     ...future.result$finished <- base::Sys.time()
[09:32:33.461]     ...future.result
[09:32:33.461] }
[09:32:33.464] MultisessionFuture started
[09:32:33.464] - Launch lazy future ... done
[09:32:33.464] run() for ‘MultisessionFuture’ ... done
[09:32:33.966] receiveMessageFromWorker() for ClusterFuture ...
[09:32:33.966] - Validating connection of MultisessionFuture
[09:32:33.967] - received message: FutureResult
[09:32:33.967] - Received FutureResult
[09:32:33.967] - Erased future from FutureRegistry
[09:32:33.967] result() for ClusterFuture ...
[09:32:33.967] - result already collected: FutureResult
[09:32:33.967] result() for ClusterFuture ... done
[09:32:33.967] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:33.967] resolve() on list ...
[09:32:33.968]  recursive: 0
[09:32:33.968]  length: 2
[09:32:33.968]  elements: ‘a’, ‘b’
[09:32:33.968]  length: 1 (resolved future 1)
[09:32:33.968]  length: 0 (resolved future 2)
[09:32:33.968] resolve() on list ... DONE
[09:32:33.968] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[09:32:33.968] getGlobalsAndPackages() ...
[09:32:33.968] Searching for globals...
[09:32:33.969] - globals found: [2] ‘list’, ‘stop’
[09:32:33.969] Searching for globals ... DONE
[09:32:33.969] Resolving globals: FALSE
[09:32:33.970] 
[09:32:33.970] 
[09:32:33.970] getGlobalsAndPackages() ... DONE
[09:32:33.970] run() for ‘Future’ ...
[09:32:33.970] - state: ‘created’
[09:32:33.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:33.989] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:33.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:33.989]   - Field: ‘node’
[09:32:33.989]   - Field: ‘label’
[09:32:33.989]   - Field: ‘local’
[09:32:33.989]   - Field: ‘owner’
[09:32:33.989]   - Field: ‘envir’
[09:32:33.989]   - Field: ‘workers’
[09:32:33.989]   - Field: ‘packages’
[09:32:33.990]   - Field: ‘gc’
[09:32:33.990]   - Field: ‘conditions’
[09:32:33.990]   - Field: ‘persistent’
[09:32:33.990]   - Field: ‘expr’
[09:32:33.990]   - Field: ‘uuid’
[09:32:33.990]   - Field: ‘seed’
[09:32:33.990]   - Field: ‘version’
[09:32:33.990]   - Field: ‘result’
[09:32:33.990]   - Field: ‘asynchronous’
[09:32:33.990]   - Field: ‘calls’
[09:32:33.990]   - Field: ‘globals’
[09:32:33.991]   - Field: ‘stdout’
[09:32:33.991]   - Field: ‘earlySignal’
[09:32:33.991]   - Field: ‘lazy’
[09:32:33.991]   - Field: ‘state’
[09:32:33.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:33.991] - Launch lazy future ...
[09:32:33.991] Packages needed by the future expression (n = 0): <none>
[09:32:33.991] Packages needed by future strategies (n = 0): <none>
[09:32:33.992] {
[09:32:33.992]     {
[09:32:33.992]         {
[09:32:33.992]             ...future.startTime <- base::Sys.time()
[09:32:33.992]             {
[09:32:33.992]                 {
[09:32:33.992]                   {
[09:32:33.992]                     {
[09:32:33.992]                       base::local({
[09:32:33.992]                         has_future <- base::requireNamespace("future", 
[09:32:33.992]                           quietly = TRUE)
[09:32:33.992]                         if (has_future) {
[09:32:33.992]                           ns <- base::getNamespace("future")
[09:32:33.992]                           version <- ns[[".package"]][["version"]]
[09:32:33.992]                           if (is.null(version)) 
[09:32:33.992]                             version <- utils::packageVersion("future")
[09:32:33.992]                         }
[09:32:33.992]                         else {
[09:32:33.992]                           version <- NULL
[09:32:33.992]                         }
[09:32:33.992]                         if (!has_future || version < "1.8.0") {
[09:32:33.992]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:33.992]                             "", base::R.version$version.string), 
[09:32:33.992]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:33.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:33.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:33.992]                               "release", "version")], collapse = " "), 
[09:32:33.992]                             hostname = base::Sys.info()[["nodename"]])
[09:32:33.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:33.992]                             info)
[09:32:33.992]                           info <- base::paste(info, collapse = "; ")
[09:32:33.992]                           if (!has_future) {
[09:32:33.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:33.992]                               info)
[09:32:33.992]                           }
[09:32:33.992]                           else {
[09:32:33.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:33.992]                               info, version)
[09:32:33.992]                           }
[09:32:33.992]                           base::stop(msg)
[09:32:33.992]                         }
[09:32:33.992]                       })
[09:32:33.992]                     }
[09:32:33.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:33.992]                     base::options(mc.cores = 1L)
[09:32:33.992]                   }
[09:32:33.992]                   ...future.strategy.old <- future::plan("list")
[09:32:33.992]                   options(future.plan = NULL)
[09:32:33.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:33.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:33.992]                 }
[09:32:33.992]                 ...future.workdir <- getwd()
[09:32:33.992]             }
[09:32:33.992]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:33.992]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:33.992]         }
[09:32:33.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:33.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:33.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:33.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:33.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:33.992]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:33.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:33.992]             base::names(...future.oldOptions))
[09:32:33.992]     }
[09:32:33.992]     if (FALSE) {
[09:32:33.992]     }
[09:32:33.992]     else {
[09:32:33.992]         if (TRUE) {
[09:32:33.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:33.992]                 open = "w")
[09:32:33.992]         }
[09:32:33.992]         else {
[09:32:33.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:33.992]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:33.992]         }
[09:32:33.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:33.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:33.992]             base::sink(type = "output", split = FALSE)
[09:32:33.992]             base::close(...future.stdout)
[09:32:33.992]         }, add = TRUE)
[09:32:33.992]     }
[09:32:33.992]     ...future.frame <- base::sys.nframe()
[09:32:33.992]     ...future.conditions <- base::list()
[09:32:33.992]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:33.992]     if (FALSE) {
[09:32:33.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:33.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:33.992]     }
[09:32:33.992]     ...future.result <- base::tryCatch({
[09:32:33.992]         base::withCallingHandlers({
[09:32:33.992]             ...future.value <- base::withVisible(base::local({
[09:32:33.992]                 ...future.makeSendCondition <- base::local({
[09:32:33.992]                   sendCondition <- NULL
[09:32:33.992]                   function(frame = 1L) {
[09:32:33.992]                     if (is.function(sendCondition)) 
[09:32:33.992]                       return(sendCondition)
[09:32:33.992]                     ns <- getNamespace("parallel")
[09:32:33.992]                     if (exists("sendData", mode = "function", 
[09:32:33.992]                       envir = ns)) {
[09:32:33.992]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:33.992]                         envir = ns)
[09:32:33.992]                       envir <- sys.frame(frame)
[09:32:33.992]                       master <- NULL
[09:32:33.992]                       while (!identical(envir, .GlobalEnv) && 
[09:32:33.992]                         !identical(envir, emptyenv())) {
[09:32:33.992]                         if (exists("master", mode = "list", envir = envir, 
[09:32:33.992]                           inherits = FALSE)) {
[09:32:33.992]                           master <- get("master", mode = "list", 
[09:32:33.992]                             envir = envir, inherits = FALSE)
[09:32:33.992]                           if (inherits(master, c("SOCKnode", 
[09:32:33.992]                             "SOCK0node"))) {
[09:32:33.992]                             sendCondition <<- function(cond) {
[09:32:33.992]                               data <- list(type = "VALUE", value = cond, 
[09:32:33.992]                                 success = TRUE)
[09:32:33.992]                               parallel_sendData(master, data)
[09:32:33.992]                             }
[09:32:33.992]                             return(sendCondition)
[09:32:33.992]                           }
[09:32:33.992]                         }
[09:32:33.992]                         frame <- frame + 1L
[09:32:33.992]                         envir <- sys.frame(frame)
[09:32:33.992]                       }
[09:32:33.992]                     }
[09:32:33.992]                     sendCondition <<- function(cond) NULL
[09:32:33.992]                   }
[09:32:33.992]                 })
[09:32:33.992]                 withCallingHandlers({
[09:32:33.992]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:33.992]                 }, immediateCondition = function(cond) {
[09:32:33.992]                   sendCondition <- ...future.makeSendCondition()
[09:32:33.992]                   sendCondition(cond)
[09:32:33.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.992]                   {
[09:32:33.992]                     inherits <- base::inherits
[09:32:33.992]                     invokeRestart <- base::invokeRestart
[09:32:33.992]                     is.null <- base::is.null
[09:32:33.992]                     muffled <- FALSE
[09:32:33.992]                     if (inherits(cond, "message")) {
[09:32:33.992]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:33.992]                       if (muffled) 
[09:32:33.992]                         invokeRestart("muffleMessage")
[09:32:33.992]                     }
[09:32:33.992]                     else if (inherits(cond, "warning")) {
[09:32:33.992]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:33.992]                       if (muffled) 
[09:32:33.992]                         invokeRestart("muffleWarning")
[09:32:33.992]                     }
[09:32:33.992]                     else if (inherits(cond, "condition")) {
[09:32:33.992]                       if (!is.null(pattern)) {
[09:32:33.992]                         computeRestarts <- base::computeRestarts
[09:32:33.992]                         grepl <- base::grepl
[09:32:33.992]                         restarts <- computeRestarts(cond)
[09:32:33.992]                         for (restart in restarts) {
[09:32:33.992]                           name <- restart$name
[09:32:33.992]                           if (is.null(name)) 
[09:32:33.992]                             next
[09:32:33.992]                           if (!grepl(pattern, name)) 
[09:32:33.992]                             next
[09:32:33.992]                           invokeRestart(restart)
[09:32:33.992]                           muffled <- TRUE
[09:32:33.992]                           break
[09:32:33.992]                         }
[09:32:33.992]                       }
[09:32:33.992]                     }
[09:32:33.992]                     invisible(muffled)
[09:32:33.992]                   }
[09:32:33.992]                   muffleCondition(cond)
[09:32:33.992]                 })
[09:32:33.992]             }))
[09:32:33.992]             future::FutureResult(value = ...future.value$value, 
[09:32:33.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:33.992]                   ...future.rng), globalenv = if (FALSE) 
[09:32:33.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:33.992]                     ...future.globalenv.names))
[09:32:33.992]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:33.992]         }, condition = base::local({
[09:32:33.992]             c <- base::c
[09:32:33.992]             inherits <- base::inherits
[09:32:33.992]             invokeRestart <- base::invokeRestart
[09:32:33.992]             length <- base::length
[09:32:33.992]             list <- base::list
[09:32:33.992]             seq.int <- base::seq.int
[09:32:33.992]             signalCondition <- base::signalCondition
[09:32:33.992]             sys.calls <- base::sys.calls
[09:32:33.992]             `[[` <- base::`[[`
[09:32:33.992]             `+` <- base::`+`
[09:32:33.992]             `<<-` <- base::`<<-`
[09:32:33.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:33.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:33.992]                   3L)]
[09:32:33.992]             }
[09:32:33.992]             function(cond) {
[09:32:33.992]                 is_error <- inherits(cond, "error")
[09:32:33.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:33.992]                   NULL)
[09:32:33.992]                 if (is_error) {
[09:32:33.992]                   sessionInformation <- function() {
[09:32:33.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:33.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:33.992]                       search = base::search(), system = base::Sys.info())
[09:32:33.992]                   }
[09:32:33.992]                   ...future.conditions[[length(...future.conditions) + 
[09:32:33.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:33.992]                     cond$call), session = sessionInformation(), 
[09:32:33.992]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:33.992]                   signalCondition(cond)
[09:32:33.992]                 }
[09:32:33.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:33.992]                 "immediateCondition"))) {
[09:32:33.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:33.992]                   ...future.conditions[[length(...future.conditions) + 
[09:32:33.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:33.992]                   if (TRUE && !signal) {
[09:32:33.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.992]                     {
[09:32:33.992]                       inherits <- base::inherits
[09:32:33.992]                       invokeRestart <- base::invokeRestart
[09:32:33.992]                       is.null <- base::is.null
[09:32:33.992]                       muffled <- FALSE
[09:32:33.992]                       if (inherits(cond, "message")) {
[09:32:33.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:33.992]                         if (muffled) 
[09:32:33.992]                           invokeRestart("muffleMessage")
[09:32:33.992]                       }
[09:32:33.992]                       else if (inherits(cond, "warning")) {
[09:32:33.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:33.992]                         if (muffled) 
[09:32:33.992]                           invokeRestart("muffleWarning")
[09:32:33.992]                       }
[09:32:33.992]                       else if (inherits(cond, "condition")) {
[09:32:33.992]                         if (!is.null(pattern)) {
[09:32:33.992]                           computeRestarts <- base::computeRestarts
[09:32:33.992]                           grepl <- base::grepl
[09:32:33.992]                           restarts <- computeRestarts(cond)
[09:32:33.992]                           for (restart in restarts) {
[09:32:33.992]                             name <- restart$name
[09:32:33.992]                             if (is.null(name)) 
[09:32:33.992]                               next
[09:32:33.992]                             if (!grepl(pattern, name)) 
[09:32:33.992]                               next
[09:32:33.992]                             invokeRestart(restart)
[09:32:33.992]                             muffled <- TRUE
[09:32:33.992]                             break
[09:32:33.992]                           }
[09:32:33.992]                         }
[09:32:33.992]                       }
[09:32:33.992]                       invisible(muffled)
[09:32:33.992]                     }
[09:32:33.992]                     muffleCondition(cond, pattern = "^muffle")
[09:32:33.992]                   }
[09:32:33.992]                 }
[09:32:33.992]                 else {
[09:32:33.992]                   if (TRUE) {
[09:32:33.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:33.992]                     {
[09:32:33.992]                       inherits <- base::inherits
[09:32:33.992]                       invokeRestart <- base::invokeRestart
[09:32:33.992]                       is.null <- base::is.null
[09:32:33.992]                       muffled <- FALSE
[09:32:33.992]                       if (inherits(cond, "message")) {
[09:32:33.992]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:33.992]                         if (muffled) 
[09:32:33.992]                           invokeRestart("muffleMessage")
[09:32:33.992]                       }
[09:32:33.992]                       else if (inherits(cond, "warning")) {
[09:32:33.992]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:33.992]                         if (muffled) 
[09:32:33.992]                           invokeRestart("muffleWarning")
[09:32:33.992]                       }
[09:32:33.992]                       else if (inherits(cond, "condition")) {
[09:32:33.992]                         if (!is.null(pattern)) {
[09:32:33.992]                           computeRestarts <- base::computeRestarts
[09:32:33.992]                           grepl <- base::grepl
[09:32:33.992]                           restarts <- computeRestarts(cond)
[09:32:33.992]                           for (restart in restarts) {
[09:32:33.992]                             name <- restart$name
[09:32:33.992]                             if (is.null(name)) 
[09:32:33.992]                               next
[09:32:33.992]                             if (!grepl(pattern, name)) 
[09:32:33.992]                               next
[09:32:33.992]                             invokeRestart(restart)
[09:32:33.992]                             muffled <- TRUE
[09:32:33.992]                             break
[09:32:33.992]                           }
[09:32:33.992]                         }
[09:32:33.992]                       }
[09:32:33.992]                       invisible(muffled)
[09:32:33.992]                     }
[09:32:33.992]                     muffleCondition(cond, pattern = "^muffle")
[09:32:33.992]                   }
[09:32:33.992]                 }
[09:32:33.992]             }
[09:32:33.992]         }))
[09:32:33.992]     }, error = function(ex) {
[09:32:33.992]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:33.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:33.992]                 ...future.rng), started = ...future.startTime, 
[09:32:33.992]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:33.992]             version = "1.8"), class = "FutureResult")
[09:32:33.992]     }, finally = {
[09:32:33.992]         if (!identical(...future.workdir, getwd())) 
[09:32:33.992]             setwd(...future.workdir)
[09:32:33.992]         {
[09:32:33.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:33.992]                 ...future.oldOptions$nwarnings <- NULL
[09:32:33.992]             }
[09:32:33.992]             base::options(...future.oldOptions)
[09:32:33.992]             if (.Platform$OS.type == "windows") {
[09:32:33.992]                 old_names <- names(...future.oldEnvVars)
[09:32:33.992]                 envs <- base::Sys.getenv()
[09:32:33.992]                 names <- names(envs)
[09:32:33.992]                 common <- intersect(names, old_names)
[09:32:33.992]                 added <- setdiff(names, old_names)
[09:32:33.992]                 removed <- setdiff(old_names, names)
[09:32:33.992]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:33.992]                   envs[common]]
[09:32:33.992]                 NAMES <- toupper(changed)
[09:32:33.992]                 args <- list()
[09:32:33.992]                 for (kk in seq_along(NAMES)) {
[09:32:33.992]                   name <- changed[[kk]]
[09:32:33.992]                   NAME <- NAMES[[kk]]
[09:32:33.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.992]                     next
[09:32:33.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:33.992]                 }
[09:32:33.992]                 NAMES <- toupper(added)
[09:32:33.992]                 for (kk in seq_along(NAMES)) {
[09:32:33.992]                   name <- added[[kk]]
[09:32:33.992]                   NAME <- NAMES[[kk]]
[09:32:33.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.992]                     next
[09:32:33.992]                   args[[name]] <- ""
[09:32:33.992]                 }
[09:32:33.992]                 NAMES <- toupper(removed)
[09:32:33.992]                 for (kk in seq_along(NAMES)) {
[09:32:33.992]                   name <- removed[[kk]]
[09:32:33.992]                   NAME <- NAMES[[kk]]
[09:32:33.992]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:33.992]                     next
[09:32:33.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:33.992]                 }
[09:32:33.992]                 if (length(args) > 0) 
[09:32:33.992]                   base::do.call(base::Sys.setenv, args = args)
[09:32:33.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:33.992]             }
[09:32:33.992]             else {
[09:32:33.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:33.992]             }
[09:32:33.992]             {
[09:32:33.992]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:33.992]                   0L) {
[09:32:33.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:33.992]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:33.992]                   base::options(opts)
[09:32:33.992]                 }
[09:32:33.992]                 {
[09:32:33.992]                   {
[09:32:33.992]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:33.992]                     NULL
[09:32:33.992]                   }
[09:32:33.992]                   options(future.plan = NULL)
[09:32:33.992]                   if (is.na(NA_character_)) 
[09:32:33.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:33.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:33.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:33.992]                     .init = FALSE)
[09:32:33.992]                 }
[09:32:33.992]             }
[09:32:33.992]         }
[09:32:33.992]     })
[09:32:33.992]     if (TRUE) {
[09:32:33.992]         base::sink(type = "output", split = FALSE)
[09:32:33.992]         if (TRUE) {
[09:32:33.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:33.992]         }
[09:32:33.992]         else {
[09:32:33.992]             ...future.result["stdout"] <- base::list(NULL)
[09:32:33.992]         }
[09:32:33.992]         base::close(...future.stdout)
[09:32:33.992]         ...future.stdout <- NULL
[09:32:33.992]     }
[09:32:33.992]     ...future.result$conditions <- ...future.conditions
[09:32:33.992]     ...future.result$finished <- base::Sys.time()
[09:32:33.992]     ...future.result
[09:32:33.992] }
[09:32:33.995] MultisessionFuture started
[09:32:33.995] - Launch lazy future ... done
[09:32:33.995] run() for ‘MultisessionFuture’ ... done
[09:32:33.996] receiveMessageFromWorker() for ClusterFuture ...
[09:32:33.997] - Validating connection of MultisessionFuture
[09:32:33.997] - received message: FutureResult
[09:32:33.997] - Received FutureResult
[09:32:33.997] - Erased future from FutureRegistry
[09:32:33.997] result() for ClusterFuture ...
[09:32:33.997] - result already collected: FutureResult
[09:32:33.997] result() for ClusterFuture ... done
[09:32:33.998] signalConditions() ...
[09:32:33.998]  - include = ‘immediateCondition’
[09:32:33.998]  - exclude = 
[09:32:33.998]  - resignal = FALSE
[09:32:33.998]  - Number of conditions: 1
[09:32:33.998] signalConditions() ... done
[09:32:33.998] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:33.998] A MultisessionFuture was resolved (and resolved itself)
[09:32:33.998] getGlobalsAndPackages() ...
[09:32:33.998] Searching for globals...
[09:32:33.999] - globals found: [2] ‘list’, ‘stop’
[09:32:33.999] Searching for globals ... DONE
[09:32:33.999] Resolving globals: FALSE
[09:32:33.999] 
[09:32:34.000] 
[09:32:34.000] getGlobalsAndPackages() ... DONE
[09:32:34.000] run() for ‘Future’ ...
[09:32:34.000] - state: ‘created’
[09:32:34.000] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:34.014] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:34.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:34.014]   - Field: ‘node’
[09:32:34.015]   - Field: ‘label’
[09:32:34.015]   - Field: ‘local’
[09:32:34.015]   - Field: ‘owner’
[09:32:34.015]   - Field: ‘envir’
[09:32:34.015]   - Field: ‘workers’
[09:32:34.015]   - Field: ‘packages’
[09:32:34.015]   - Field: ‘gc’
[09:32:34.015]   - Field: ‘conditions’
[09:32:34.015]   - Field: ‘persistent’
[09:32:34.015]   - Field: ‘expr’
[09:32:34.015]   - Field: ‘uuid’
[09:32:34.016]   - Field: ‘seed’
[09:32:34.016]   - Field: ‘version’
[09:32:34.016]   - Field: ‘result’
[09:32:34.016]   - Field: ‘asynchronous’
[09:32:34.016]   - Field: ‘calls’
[09:32:34.016]   - Field: ‘globals’
[09:32:34.016]   - Field: ‘stdout’
[09:32:34.016]   - Field: ‘earlySignal’
[09:32:34.016]   - Field: ‘lazy’
[09:32:34.016]   - Field: ‘state’
[09:32:34.017] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:34.017] - Launch lazy future ...
[09:32:34.017] Packages needed by the future expression (n = 0): <none>
[09:32:34.017] Packages needed by future strategies (n = 0): <none>
[09:32:34.017] {
[09:32:34.017]     {
[09:32:34.017]         {
[09:32:34.017]             ...future.startTime <- base::Sys.time()
[09:32:34.017]             {
[09:32:34.017]                 {
[09:32:34.017]                   {
[09:32:34.017]                     {
[09:32:34.017]                       base::local({
[09:32:34.017]                         has_future <- base::requireNamespace("future", 
[09:32:34.017]                           quietly = TRUE)
[09:32:34.017]                         if (has_future) {
[09:32:34.017]                           ns <- base::getNamespace("future")
[09:32:34.017]                           version <- ns[[".package"]][["version"]]
[09:32:34.017]                           if (is.null(version)) 
[09:32:34.017]                             version <- utils::packageVersion("future")
[09:32:34.017]                         }
[09:32:34.017]                         else {
[09:32:34.017]                           version <- NULL
[09:32:34.017]                         }
[09:32:34.017]                         if (!has_future || version < "1.8.0") {
[09:32:34.017]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:34.017]                             "", base::R.version$version.string), 
[09:32:34.017]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:34.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:34.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:34.017]                               "release", "version")], collapse = " "), 
[09:32:34.017]                             hostname = base::Sys.info()[["nodename"]])
[09:32:34.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:34.017]                             info)
[09:32:34.017]                           info <- base::paste(info, collapse = "; ")
[09:32:34.017]                           if (!has_future) {
[09:32:34.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:34.017]                               info)
[09:32:34.017]                           }
[09:32:34.017]                           else {
[09:32:34.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:34.017]                               info, version)
[09:32:34.017]                           }
[09:32:34.017]                           base::stop(msg)
[09:32:34.017]                         }
[09:32:34.017]                       })
[09:32:34.017]                     }
[09:32:34.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:34.017]                     base::options(mc.cores = 1L)
[09:32:34.017]                   }
[09:32:34.017]                   ...future.strategy.old <- future::plan("list")
[09:32:34.017]                   options(future.plan = NULL)
[09:32:34.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:34.017]                 }
[09:32:34.017]                 ...future.workdir <- getwd()
[09:32:34.017]             }
[09:32:34.017]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:34.017]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:34.017]         }
[09:32:34.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:34.017]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:34.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:34.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:34.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:34.017]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:34.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:34.017]             base::names(...future.oldOptions))
[09:32:34.017]     }
[09:32:34.017]     if (FALSE) {
[09:32:34.017]     }
[09:32:34.017]     else {
[09:32:34.017]         if (TRUE) {
[09:32:34.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:34.017]                 open = "w")
[09:32:34.017]         }
[09:32:34.017]         else {
[09:32:34.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:34.017]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:34.017]         }
[09:32:34.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:34.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:34.017]             base::sink(type = "output", split = FALSE)
[09:32:34.017]             base::close(...future.stdout)
[09:32:34.017]         }, add = TRUE)
[09:32:34.017]     }
[09:32:34.017]     ...future.frame <- base::sys.nframe()
[09:32:34.017]     ...future.conditions <- base::list()
[09:32:34.017]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:34.017]     if (FALSE) {
[09:32:34.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:34.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:34.017]     }
[09:32:34.017]     ...future.result <- base::tryCatch({
[09:32:34.017]         base::withCallingHandlers({
[09:32:34.017]             ...future.value <- base::withVisible(base::local({
[09:32:34.017]                 ...future.makeSendCondition <- base::local({
[09:32:34.017]                   sendCondition <- NULL
[09:32:34.017]                   function(frame = 1L) {
[09:32:34.017]                     if (is.function(sendCondition)) 
[09:32:34.017]                       return(sendCondition)
[09:32:34.017]                     ns <- getNamespace("parallel")
[09:32:34.017]                     if (exists("sendData", mode = "function", 
[09:32:34.017]                       envir = ns)) {
[09:32:34.017]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:34.017]                         envir = ns)
[09:32:34.017]                       envir <- sys.frame(frame)
[09:32:34.017]                       master <- NULL
[09:32:34.017]                       while (!identical(envir, .GlobalEnv) && 
[09:32:34.017]                         !identical(envir, emptyenv())) {
[09:32:34.017]                         if (exists("master", mode = "list", envir = envir, 
[09:32:34.017]                           inherits = FALSE)) {
[09:32:34.017]                           master <- get("master", mode = "list", 
[09:32:34.017]                             envir = envir, inherits = FALSE)
[09:32:34.017]                           if (inherits(master, c("SOCKnode", 
[09:32:34.017]                             "SOCK0node"))) {
[09:32:34.017]                             sendCondition <<- function(cond) {
[09:32:34.017]                               data <- list(type = "VALUE", value = cond, 
[09:32:34.017]                                 success = TRUE)
[09:32:34.017]                               parallel_sendData(master, data)
[09:32:34.017]                             }
[09:32:34.017]                             return(sendCondition)
[09:32:34.017]                           }
[09:32:34.017]                         }
[09:32:34.017]                         frame <- frame + 1L
[09:32:34.017]                         envir <- sys.frame(frame)
[09:32:34.017]                       }
[09:32:34.017]                     }
[09:32:34.017]                     sendCondition <<- function(cond) NULL
[09:32:34.017]                   }
[09:32:34.017]                 })
[09:32:34.017]                 withCallingHandlers({
[09:32:34.017]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:34.017]                 }, immediateCondition = function(cond) {
[09:32:34.017]                   sendCondition <- ...future.makeSendCondition()
[09:32:34.017]                   sendCondition(cond)
[09:32:34.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.017]                   {
[09:32:34.017]                     inherits <- base::inherits
[09:32:34.017]                     invokeRestart <- base::invokeRestart
[09:32:34.017]                     is.null <- base::is.null
[09:32:34.017]                     muffled <- FALSE
[09:32:34.017]                     if (inherits(cond, "message")) {
[09:32:34.017]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:34.017]                       if (muffled) 
[09:32:34.017]                         invokeRestart("muffleMessage")
[09:32:34.017]                     }
[09:32:34.017]                     else if (inherits(cond, "warning")) {
[09:32:34.017]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:34.017]                       if (muffled) 
[09:32:34.017]                         invokeRestart("muffleWarning")
[09:32:34.017]                     }
[09:32:34.017]                     else if (inherits(cond, "condition")) {
[09:32:34.017]                       if (!is.null(pattern)) {
[09:32:34.017]                         computeRestarts <- base::computeRestarts
[09:32:34.017]                         grepl <- base::grepl
[09:32:34.017]                         restarts <- computeRestarts(cond)
[09:32:34.017]                         for (restart in restarts) {
[09:32:34.017]                           name <- restart$name
[09:32:34.017]                           if (is.null(name)) 
[09:32:34.017]                             next
[09:32:34.017]                           if (!grepl(pattern, name)) 
[09:32:34.017]                             next
[09:32:34.017]                           invokeRestart(restart)
[09:32:34.017]                           muffled <- TRUE
[09:32:34.017]                           break
[09:32:34.017]                         }
[09:32:34.017]                       }
[09:32:34.017]                     }
[09:32:34.017]                     invisible(muffled)
[09:32:34.017]                   }
[09:32:34.017]                   muffleCondition(cond)
[09:32:34.017]                 })
[09:32:34.017]             }))
[09:32:34.017]             future::FutureResult(value = ...future.value$value, 
[09:32:34.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.017]                   ...future.rng), globalenv = if (FALSE) 
[09:32:34.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:34.017]                     ...future.globalenv.names))
[09:32:34.017]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:34.017]         }, condition = base::local({
[09:32:34.017]             c <- base::c
[09:32:34.017]             inherits <- base::inherits
[09:32:34.017]             invokeRestart <- base::invokeRestart
[09:32:34.017]             length <- base::length
[09:32:34.017]             list <- base::list
[09:32:34.017]             seq.int <- base::seq.int
[09:32:34.017]             signalCondition <- base::signalCondition
[09:32:34.017]             sys.calls <- base::sys.calls
[09:32:34.017]             `[[` <- base::`[[`
[09:32:34.017]             `+` <- base::`+`
[09:32:34.017]             `<<-` <- base::`<<-`
[09:32:34.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:34.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:34.017]                   3L)]
[09:32:34.017]             }
[09:32:34.017]             function(cond) {
[09:32:34.017]                 is_error <- inherits(cond, "error")
[09:32:34.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:34.017]                   NULL)
[09:32:34.017]                 if (is_error) {
[09:32:34.017]                   sessionInformation <- function() {
[09:32:34.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:34.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:34.017]                       search = base::search(), system = base::Sys.info())
[09:32:34.017]                   }
[09:32:34.017]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:34.017]                     cond$call), session = sessionInformation(), 
[09:32:34.017]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:34.017]                   signalCondition(cond)
[09:32:34.017]                 }
[09:32:34.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:34.017]                 "immediateCondition"))) {
[09:32:34.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:34.017]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:34.017]                   if (TRUE && !signal) {
[09:32:34.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.017]                     {
[09:32:34.017]                       inherits <- base::inherits
[09:32:34.017]                       invokeRestart <- base::invokeRestart
[09:32:34.017]                       is.null <- base::is.null
[09:32:34.017]                       muffled <- FALSE
[09:32:34.017]                       if (inherits(cond, "message")) {
[09:32:34.017]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.017]                         if (muffled) 
[09:32:34.017]                           invokeRestart("muffleMessage")
[09:32:34.017]                       }
[09:32:34.017]                       else if (inherits(cond, "warning")) {
[09:32:34.017]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.017]                         if (muffled) 
[09:32:34.017]                           invokeRestart("muffleWarning")
[09:32:34.017]                       }
[09:32:34.017]                       else if (inherits(cond, "condition")) {
[09:32:34.017]                         if (!is.null(pattern)) {
[09:32:34.017]                           computeRestarts <- base::computeRestarts
[09:32:34.017]                           grepl <- base::grepl
[09:32:34.017]                           restarts <- computeRestarts(cond)
[09:32:34.017]                           for (restart in restarts) {
[09:32:34.017]                             name <- restart$name
[09:32:34.017]                             if (is.null(name)) 
[09:32:34.017]                               next
[09:32:34.017]                             if (!grepl(pattern, name)) 
[09:32:34.017]                               next
[09:32:34.017]                             invokeRestart(restart)
[09:32:34.017]                             muffled <- TRUE
[09:32:34.017]                             break
[09:32:34.017]                           }
[09:32:34.017]                         }
[09:32:34.017]                       }
[09:32:34.017]                       invisible(muffled)
[09:32:34.017]                     }
[09:32:34.017]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.017]                   }
[09:32:34.017]                 }
[09:32:34.017]                 else {
[09:32:34.017]                   if (TRUE) {
[09:32:34.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.017]                     {
[09:32:34.017]                       inherits <- base::inherits
[09:32:34.017]                       invokeRestart <- base::invokeRestart
[09:32:34.017]                       is.null <- base::is.null
[09:32:34.017]                       muffled <- FALSE
[09:32:34.017]                       if (inherits(cond, "message")) {
[09:32:34.017]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.017]                         if (muffled) 
[09:32:34.017]                           invokeRestart("muffleMessage")
[09:32:34.017]                       }
[09:32:34.017]                       else if (inherits(cond, "warning")) {
[09:32:34.017]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.017]                         if (muffled) 
[09:32:34.017]                           invokeRestart("muffleWarning")
[09:32:34.017]                       }
[09:32:34.017]                       else if (inherits(cond, "condition")) {
[09:32:34.017]                         if (!is.null(pattern)) {
[09:32:34.017]                           computeRestarts <- base::computeRestarts
[09:32:34.017]                           grepl <- base::grepl
[09:32:34.017]                           restarts <- computeRestarts(cond)
[09:32:34.017]                           for (restart in restarts) {
[09:32:34.017]                             name <- restart$name
[09:32:34.017]                             if (is.null(name)) 
[09:32:34.017]                               next
[09:32:34.017]                             if (!grepl(pattern, name)) 
[09:32:34.017]                               next
[09:32:34.017]                             invokeRestart(restart)
[09:32:34.017]                             muffled <- TRUE
[09:32:34.017]                             break
[09:32:34.017]                           }
[09:32:34.017]                         }
[09:32:34.017]                       }
[09:32:34.017]                       invisible(muffled)
[09:32:34.017]                     }
[09:32:34.017]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.017]                   }
[09:32:34.017]                 }
[09:32:34.017]             }
[09:32:34.017]         }))
[09:32:34.017]     }, error = function(ex) {
[09:32:34.017]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:34.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.017]                 ...future.rng), started = ...future.startTime, 
[09:32:34.017]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:34.017]             version = "1.8"), class = "FutureResult")
[09:32:34.017]     }, finally = {
[09:32:34.017]         if (!identical(...future.workdir, getwd())) 
[09:32:34.017]             setwd(...future.workdir)
[09:32:34.017]         {
[09:32:34.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:34.017]                 ...future.oldOptions$nwarnings <- NULL
[09:32:34.017]             }
[09:32:34.017]             base::options(...future.oldOptions)
[09:32:34.017]             if (.Platform$OS.type == "windows") {
[09:32:34.017]                 old_names <- names(...future.oldEnvVars)
[09:32:34.017]                 envs <- base::Sys.getenv()
[09:32:34.017]                 names <- names(envs)
[09:32:34.017]                 common <- intersect(names, old_names)
[09:32:34.017]                 added <- setdiff(names, old_names)
[09:32:34.017]                 removed <- setdiff(old_names, names)
[09:32:34.017]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:34.017]                   envs[common]]
[09:32:34.017]                 NAMES <- toupper(changed)
[09:32:34.017]                 args <- list()
[09:32:34.017]                 for (kk in seq_along(NAMES)) {
[09:32:34.017]                   name <- changed[[kk]]
[09:32:34.017]                   NAME <- NAMES[[kk]]
[09:32:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.017]                     next
[09:32:34.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.017]                 }
[09:32:34.017]                 NAMES <- toupper(added)
[09:32:34.017]                 for (kk in seq_along(NAMES)) {
[09:32:34.017]                   name <- added[[kk]]
[09:32:34.017]                   NAME <- NAMES[[kk]]
[09:32:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.017]                     next
[09:32:34.017]                   args[[name]] <- ""
[09:32:34.017]                 }
[09:32:34.017]                 NAMES <- toupper(removed)
[09:32:34.017]                 for (kk in seq_along(NAMES)) {
[09:32:34.017]                   name <- removed[[kk]]
[09:32:34.017]                   NAME <- NAMES[[kk]]
[09:32:34.017]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.017]                     next
[09:32:34.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.017]                 }
[09:32:34.017]                 if (length(args) > 0) 
[09:32:34.017]                   base::do.call(base::Sys.setenv, args = args)
[09:32:34.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:34.017]             }
[09:32:34.017]             else {
[09:32:34.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:34.017]             }
[09:32:34.017]             {
[09:32:34.017]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:34.017]                   0L) {
[09:32:34.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:34.017]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:34.017]                   base::options(opts)
[09:32:34.017]                 }
[09:32:34.017]                 {
[09:32:34.017]                   {
[09:32:34.017]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:34.017]                     NULL
[09:32:34.017]                   }
[09:32:34.017]                   options(future.plan = NULL)
[09:32:34.017]                   if (is.na(NA_character_)) 
[09:32:34.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:34.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:34.017]                     .init = FALSE)
[09:32:34.017]                 }
[09:32:34.017]             }
[09:32:34.017]         }
[09:32:34.017]     })
[09:32:34.017]     if (TRUE) {
[09:32:34.017]         base::sink(type = "output", split = FALSE)
[09:32:34.017]         if (TRUE) {
[09:32:34.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:34.017]         }
[09:32:34.017]         else {
[09:32:34.017]             ...future.result["stdout"] <- base::list(NULL)
[09:32:34.017]         }
[09:32:34.017]         base::close(...future.stdout)
[09:32:34.017]         ...future.stdout <- NULL
[09:32:34.017]     }
[09:32:34.017]     ...future.result$conditions <- ...future.conditions
[09:32:34.017]     ...future.result$finished <- base::Sys.time()
[09:32:34.017]     ...future.result
[09:32:34.017] }
[09:32:34.020] MultisessionFuture started
[09:32:34.021] - Launch lazy future ... done
[09:32:34.021] run() for ‘MultisessionFuture’ ... done
[09:32:34.022] receiveMessageFromWorker() for ClusterFuture ...
[09:32:34.022] - Validating connection of MultisessionFuture
[09:32:34.023] - received message: FutureResult
[09:32:34.023] - Received FutureResult
[09:32:34.023] - Erased future from FutureRegistry
[09:32:34.023] result() for ClusterFuture ...
[09:32:34.023] - result already collected: FutureResult
[09:32:34.023] result() for ClusterFuture ... done
[09:32:34.023] signalConditions() ...
[09:32:34.023]  - include = ‘immediateCondition’
[09:32:34.023]  - exclude = 
[09:32:34.024]  - resignal = FALSE
[09:32:34.024]  - Number of conditions: 1
[09:32:34.024] signalConditions() ... done
[09:32:34.024] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:34.024] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[09:32:34.024] getGlobalsAndPackages() ...
[09:32:34.024] Searching for globals...
[09:32:34.025] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:34.026] Searching for globals ... DONE
[09:32:34.026] Resolving globals: FALSE
[09:32:34.026] 
[09:32:34.026] 
[09:32:34.026] getGlobalsAndPackages() ... DONE
[09:32:34.026] run() for ‘Future’ ...
[09:32:34.026] - state: ‘created’
[09:32:34.027] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:34.041] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:34.041] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:34.041]   - Field: ‘node’
[09:32:34.041]   - Field: ‘label’
[09:32:34.041]   - Field: ‘local’
[09:32:34.041]   - Field: ‘owner’
[09:32:34.041]   - Field: ‘envir’
[09:32:34.041]   - Field: ‘workers’
[09:32:34.041]   - Field: ‘packages’
[09:32:34.041]   - Field: ‘gc’
[09:32:34.042]   - Field: ‘conditions’
[09:32:34.042]   - Field: ‘persistent’
[09:32:34.042]   - Field: ‘expr’
[09:32:34.042]   - Field: ‘uuid’
[09:32:34.042]   - Field: ‘seed’
[09:32:34.042]   - Field: ‘version’
[09:32:34.042]   - Field: ‘result’
[09:32:34.042]   - Field: ‘asynchronous’
[09:32:34.042]   - Field: ‘calls’
[09:32:34.042]   - Field: ‘globals’
[09:32:34.042]   - Field: ‘stdout’
[09:32:34.043]   - Field: ‘earlySignal’
[09:32:34.043]   - Field: ‘lazy’
[09:32:34.043]   - Field: ‘state’
[09:32:34.043] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:34.043] - Launch lazy future ...
[09:32:34.043] Packages needed by the future expression (n = 0): <none>
[09:32:34.043] Packages needed by future strategies (n = 0): <none>
[09:32:34.044] {
[09:32:34.044]     {
[09:32:34.044]         {
[09:32:34.044]             ...future.startTime <- base::Sys.time()
[09:32:34.044]             {
[09:32:34.044]                 {
[09:32:34.044]                   {
[09:32:34.044]                     {
[09:32:34.044]                       base::local({
[09:32:34.044]                         has_future <- base::requireNamespace("future", 
[09:32:34.044]                           quietly = TRUE)
[09:32:34.044]                         if (has_future) {
[09:32:34.044]                           ns <- base::getNamespace("future")
[09:32:34.044]                           version <- ns[[".package"]][["version"]]
[09:32:34.044]                           if (is.null(version)) 
[09:32:34.044]                             version <- utils::packageVersion("future")
[09:32:34.044]                         }
[09:32:34.044]                         else {
[09:32:34.044]                           version <- NULL
[09:32:34.044]                         }
[09:32:34.044]                         if (!has_future || version < "1.8.0") {
[09:32:34.044]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:34.044]                             "", base::R.version$version.string), 
[09:32:34.044]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:34.044]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:34.044]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:34.044]                               "release", "version")], collapse = " "), 
[09:32:34.044]                             hostname = base::Sys.info()[["nodename"]])
[09:32:34.044]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:34.044]                             info)
[09:32:34.044]                           info <- base::paste(info, collapse = "; ")
[09:32:34.044]                           if (!has_future) {
[09:32:34.044]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:34.044]                               info)
[09:32:34.044]                           }
[09:32:34.044]                           else {
[09:32:34.044]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:34.044]                               info, version)
[09:32:34.044]                           }
[09:32:34.044]                           base::stop(msg)
[09:32:34.044]                         }
[09:32:34.044]                       })
[09:32:34.044]                     }
[09:32:34.044]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:34.044]                     base::options(mc.cores = 1L)
[09:32:34.044]                   }
[09:32:34.044]                   ...future.strategy.old <- future::plan("list")
[09:32:34.044]                   options(future.plan = NULL)
[09:32:34.044]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.044]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:34.044]                 }
[09:32:34.044]                 ...future.workdir <- getwd()
[09:32:34.044]             }
[09:32:34.044]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:34.044]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:34.044]         }
[09:32:34.044]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:34.044]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:34.044]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:34.044]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:34.044]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:34.044]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:34.044]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:34.044]             base::names(...future.oldOptions))
[09:32:34.044]     }
[09:32:34.044]     if (FALSE) {
[09:32:34.044]     }
[09:32:34.044]     else {
[09:32:34.044]         if (TRUE) {
[09:32:34.044]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:34.044]                 open = "w")
[09:32:34.044]         }
[09:32:34.044]         else {
[09:32:34.044]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:34.044]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:34.044]         }
[09:32:34.044]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:34.044]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:34.044]             base::sink(type = "output", split = FALSE)
[09:32:34.044]             base::close(...future.stdout)
[09:32:34.044]         }, add = TRUE)
[09:32:34.044]     }
[09:32:34.044]     ...future.frame <- base::sys.nframe()
[09:32:34.044]     ...future.conditions <- base::list()
[09:32:34.044]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:34.044]     if (FALSE) {
[09:32:34.044]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:34.044]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:34.044]     }
[09:32:34.044]     ...future.result <- base::tryCatch({
[09:32:34.044]         base::withCallingHandlers({
[09:32:34.044]             ...future.value <- base::withVisible(base::local({
[09:32:34.044]                 ...future.makeSendCondition <- base::local({
[09:32:34.044]                   sendCondition <- NULL
[09:32:34.044]                   function(frame = 1L) {
[09:32:34.044]                     if (is.function(sendCondition)) 
[09:32:34.044]                       return(sendCondition)
[09:32:34.044]                     ns <- getNamespace("parallel")
[09:32:34.044]                     if (exists("sendData", mode = "function", 
[09:32:34.044]                       envir = ns)) {
[09:32:34.044]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:34.044]                         envir = ns)
[09:32:34.044]                       envir <- sys.frame(frame)
[09:32:34.044]                       master <- NULL
[09:32:34.044]                       while (!identical(envir, .GlobalEnv) && 
[09:32:34.044]                         !identical(envir, emptyenv())) {
[09:32:34.044]                         if (exists("master", mode = "list", envir = envir, 
[09:32:34.044]                           inherits = FALSE)) {
[09:32:34.044]                           master <- get("master", mode = "list", 
[09:32:34.044]                             envir = envir, inherits = FALSE)
[09:32:34.044]                           if (inherits(master, c("SOCKnode", 
[09:32:34.044]                             "SOCK0node"))) {
[09:32:34.044]                             sendCondition <<- function(cond) {
[09:32:34.044]                               data <- list(type = "VALUE", value = cond, 
[09:32:34.044]                                 success = TRUE)
[09:32:34.044]                               parallel_sendData(master, data)
[09:32:34.044]                             }
[09:32:34.044]                             return(sendCondition)
[09:32:34.044]                           }
[09:32:34.044]                         }
[09:32:34.044]                         frame <- frame + 1L
[09:32:34.044]                         envir <- sys.frame(frame)
[09:32:34.044]                       }
[09:32:34.044]                     }
[09:32:34.044]                     sendCondition <<- function(cond) NULL
[09:32:34.044]                   }
[09:32:34.044]                 })
[09:32:34.044]                 withCallingHandlers({
[09:32:34.044]                   {
[09:32:34.044]                     Sys.sleep(0.5)
[09:32:34.044]                     list(a = 1, b = 42L)
[09:32:34.044]                   }
[09:32:34.044]                 }, immediateCondition = function(cond) {
[09:32:34.044]                   sendCondition <- ...future.makeSendCondition()
[09:32:34.044]                   sendCondition(cond)
[09:32:34.044]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.044]                   {
[09:32:34.044]                     inherits <- base::inherits
[09:32:34.044]                     invokeRestart <- base::invokeRestart
[09:32:34.044]                     is.null <- base::is.null
[09:32:34.044]                     muffled <- FALSE
[09:32:34.044]                     if (inherits(cond, "message")) {
[09:32:34.044]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:34.044]                       if (muffled) 
[09:32:34.044]                         invokeRestart("muffleMessage")
[09:32:34.044]                     }
[09:32:34.044]                     else if (inherits(cond, "warning")) {
[09:32:34.044]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:34.044]                       if (muffled) 
[09:32:34.044]                         invokeRestart("muffleWarning")
[09:32:34.044]                     }
[09:32:34.044]                     else if (inherits(cond, "condition")) {
[09:32:34.044]                       if (!is.null(pattern)) {
[09:32:34.044]                         computeRestarts <- base::computeRestarts
[09:32:34.044]                         grepl <- base::grepl
[09:32:34.044]                         restarts <- computeRestarts(cond)
[09:32:34.044]                         for (restart in restarts) {
[09:32:34.044]                           name <- restart$name
[09:32:34.044]                           if (is.null(name)) 
[09:32:34.044]                             next
[09:32:34.044]                           if (!grepl(pattern, name)) 
[09:32:34.044]                             next
[09:32:34.044]                           invokeRestart(restart)
[09:32:34.044]                           muffled <- TRUE
[09:32:34.044]                           break
[09:32:34.044]                         }
[09:32:34.044]                       }
[09:32:34.044]                     }
[09:32:34.044]                     invisible(muffled)
[09:32:34.044]                   }
[09:32:34.044]                   muffleCondition(cond)
[09:32:34.044]                 })
[09:32:34.044]             }))
[09:32:34.044]             future::FutureResult(value = ...future.value$value, 
[09:32:34.044]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.044]                   ...future.rng), globalenv = if (FALSE) 
[09:32:34.044]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:34.044]                     ...future.globalenv.names))
[09:32:34.044]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:34.044]         }, condition = base::local({
[09:32:34.044]             c <- base::c
[09:32:34.044]             inherits <- base::inherits
[09:32:34.044]             invokeRestart <- base::invokeRestart
[09:32:34.044]             length <- base::length
[09:32:34.044]             list <- base::list
[09:32:34.044]             seq.int <- base::seq.int
[09:32:34.044]             signalCondition <- base::signalCondition
[09:32:34.044]             sys.calls <- base::sys.calls
[09:32:34.044]             `[[` <- base::`[[`
[09:32:34.044]             `+` <- base::`+`
[09:32:34.044]             `<<-` <- base::`<<-`
[09:32:34.044]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:34.044]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:34.044]                   3L)]
[09:32:34.044]             }
[09:32:34.044]             function(cond) {
[09:32:34.044]                 is_error <- inherits(cond, "error")
[09:32:34.044]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:34.044]                   NULL)
[09:32:34.044]                 if (is_error) {
[09:32:34.044]                   sessionInformation <- function() {
[09:32:34.044]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:34.044]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:34.044]                       search = base::search(), system = base::Sys.info())
[09:32:34.044]                   }
[09:32:34.044]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.044]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:34.044]                     cond$call), session = sessionInformation(), 
[09:32:34.044]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:34.044]                   signalCondition(cond)
[09:32:34.044]                 }
[09:32:34.044]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:34.044]                 "immediateCondition"))) {
[09:32:34.044]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:34.044]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.044]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:34.044]                   if (TRUE && !signal) {
[09:32:34.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.044]                     {
[09:32:34.044]                       inherits <- base::inherits
[09:32:34.044]                       invokeRestart <- base::invokeRestart
[09:32:34.044]                       is.null <- base::is.null
[09:32:34.044]                       muffled <- FALSE
[09:32:34.044]                       if (inherits(cond, "message")) {
[09:32:34.044]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.044]                         if (muffled) 
[09:32:34.044]                           invokeRestart("muffleMessage")
[09:32:34.044]                       }
[09:32:34.044]                       else if (inherits(cond, "warning")) {
[09:32:34.044]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.044]                         if (muffled) 
[09:32:34.044]                           invokeRestart("muffleWarning")
[09:32:34.044]                       }
[09:32:34.044]                       else if (inherits(cond, "condition")) {
[09:32:34.044]                         if (!is.null(pattern)) {
[09:32:34.044]                           computeRestarts <- base::computeRestarts
[09:32:34.044]                           grepl <- base::grepl
[09:32:34.044]                           restarts <- computeRestarts(cond)
[09:32:34.044]                           for (restart in restarts) {
[09:32:34.044]                             name <- restart$name
[09:32:34.044]                             if (is.null(name)) 
[09:32:34.044]                               next
[09:32:34.044]                             if (!grepl(pattern, name)) 
[09:32:34.044]                               next
[09:32:34.044]                             invokeRestart(restart)
[09:32:34.044]                             muffled <- TRUE
[09:32:34.044]                             break
[09:32:34.044]                           }
[09:32:34.044]                         }
[09:32:34.044]                       }
[09:32:34.044]                       invisible(muffled)
[09:32:34.044]                     }
[09:32:34.044]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.044]                   }
[09:32:34.044]                 }
[09:32:34.044]                 else {
[09:32:34.044]                   if (TRUE) {
[09:32:34.044]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.044]                     {
[09:32:34.044]                       inherits <- base::inherits
[09:32:34.044]                       invokeRestart <- base::invokeRestart
[09:32:34.044]                       is.null <- base::is.null
[09:32:34.044]                       muffled <- FALSE
[09:32:34.044]                       if (inherits(cond, "message")) {
[09:32:34.044]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.044]                         if (muffled) 
[09:32:34.044]                           invokeRestart("muffleMessage")
[09:32:34.044]                       }
[09:32:34.044]                       else if (inherits(cond, "warning")) {
[09:32:34.044]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.044]                         if (muffled) 
[09:32:34.044]                           invokeRestart("muffleWarning")
[09:32:34.044]                       }
[09:32:34.044]                       else if (inherits(cond, "condition")) {
[09:32:34.044]                         if (!is.null(pattern)) {
[09:32:34.044]                           computeRestarts <- base::computeRestarts
[09:32:34.044]                           grepl <- base::grepl
[09:32:34.044]                           restarts <- computeRestarts(cond)
[09:32:34.044]                           for (restart in restarts) {
[09:32:34.044]                             name <- restart$name
[09:32:34.044]                             if (is.null(name)) 
[09:32:34.044]                               next
[09:32:34.044]                             if (!grepl(pattern, name)) 
[09:32:34.044]                               next
[09:32:34.044]                             invokeRestart(restart)
[09:32:34.044]                             muffled <- TRUE
[09:32:34.044]                             break
[09:32:34.044]                           }
[09:32:34.044]                         }
[09:32:34.044]                       }
[09:32:34.044]                       invisible(muffled)
[09:32:34.044]                     }
[09:32:34.044]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.044]                   }
[09:32:34.044]                 }
[09:32:34.044]             }
[09:32:34.044]         }))
[09:32:34.044]     }, error = function(ex) {
[09:32:34.044]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:34.044]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.044]                 ...future.rng), started = ...future.startTime, 
[09:32:34.044]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:34.044]             version = "1.8"), class = "FutureResult")
[09:32:34.044]     }, finally = {
[09:32:34.044]         if (!identical(...future.workdir, getwd())) 
[09:32:34.044]             setwd(...future.workdir)
[09:32:34.044]         {
[09:32:34.044]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:34.044]                 ...future.oldOptions$nwarnings <- NULL
[09:32:34.044]             }
[09:32:34.044]             base::options(...future.oldOptions)
[09:32:34.044]             if (.Platform$OS.type == "windows") {
[09:32:34.044]                 old_names <- names(...future.oldEnvVars)
[09:32:34.044]                 envs <- base::Sys.getenv()
[09:32:34.044]                 names <- names(envs)
[09:32:34.044]                 common <- intersect(names, old_names)
[09:32:34.044]                 added <- setdiff(names, old_names)
[09:32:34.044]                 removed <- setdiff(old_names, names)
[09:32:34.044]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:34.044]                   envs[common]]
[09:32:34.044]                 NAMES <- toupper(changed)
[09:32:34.044]                 args <- list()
[09:32:34.044]                 for (kk in seq_along(NAMES)) {
[09:32:34.044]                   name <- changed[[kk]]
[09:32:34.044]                   NAME <- NAMES[[kk]]
[09:32:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.044]                     next
[09:32:34.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.044]                 }
[09:32:34.044]                 NAMES <- toupper(added)
[09:32:34.044]                 for (kk in seq_along(NAMES)) {
[09:32:34.044]                   name <- added[[kk]]
[09:32:34.044]                   NAME <- NAMES[[kk]]
[09:32:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.044]                     next
[09:32:34.044]                   args[[name]] <- ""
[09:32:34.044]                 }
[09:32:34.044]                 NAMES <- toupper(removed)
[09:32:34.044]                 for (kk in seq_along(NAMES)) {
[09:32:34.044]                   name <- removed[[kk]]
[09:32:34.044]                   NAME <- NAMES[[kk]]
[09:32:34.044]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.044]                     next
[09:32:34.044]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.044]                 }
[09:32:34.044]                 if (length(args) > 0) 
[09:32:34.044]                   base::do.call(base::Sys.setenv, args = args)
[09:32:34.044]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:34.044]             }
[09:32:34.044]             else {
[09:32:34.044]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:34.044]             }
[09:32:34.044]             {
[09:32:34.044]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:34.044]                   0L) {
[09:32:34.044]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:34.044]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:34.044]                   base::options(opts)
[09:32:34.044]                 }
[09:32:34.044]                 {
[09:32:34.044]                   {
[09:32:34.044]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:34.044]                     NULL
[09:32:34.044]                   }
[09:32:34.044]                   options(future.plan = NULL)
[09:32:34.044]                   if (is.na(NA_character_)) 
[09:32:34.044]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.044]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:34.044]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:34.044]                     .init = FALSE)
[09:32:34.044]                 }
[09:32:34.044]             }
[09:32:34.044]         }
[09:32:34.044]     })
[09:32:34.044]     if (TRUE) {
[09:32:34.044]         base::sink(type = "output", split = FALSE)
[09:32:34.044]         if (TRUE) {
[09:32:34.044]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:34.044]         }
[09:32:34.044]         else {
[09:32:34.044]             ...future.result["stdout"] <- base::list(NULL)
[09:32:34.044]         }
[09:32:34.044]         base::close(...future.stdout)
[09:32:34.044]         ...future.stdout <- NULL
[09:32:34.044]     }
[09:32:34.044]     ...future.result$conditions <- ...future.conditions
[09:32:34.044]     ...future.result$finished <- base::Sys.time()
[09:32:34.044]     ...future.result
[09:32:34.044] }
[09:32:34.046] MultisessionFuture started
[09:32:34.047] - Launch lazy future ... done
[09:32:34.047] run() for ‘MultisessionFuture’ ... done
[09:32:34.549] receiveMessageFromWorker() for ClusterFuture ...
[09:32:34.549] - Validating connection of MultisessionFuture
[09:32:34.549] - received message: FutureResult
[09:32:34.549] - Received FutureResult
[09:32:34.549] - Erased future from FutureRegistry
[09:32:34.549] result() for ClusterFuture ...
[09:32:34.549] - result already collected: FutureResult
[09:32:34.550] result() for ClusterFuture ... done
[09:32:34.550] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:34.550] resolve() on list ...
[09:32:34.550]  recursive: 1
[09:32:34.550]  length: 2
[09:32:34.550]  elements: ‘a’, ‘b’
[09:32:34.550]  length: 1 (resolved future 1)
[09:32:34.550]  length: 0 (resolved future 2)
[09:32:34.550] resolve() on list ... DONE
[09:32:34.550] A MultisessionFuture was resolved (and resolved itself)
[09:32:34.551] getGlobalsAndPackages() ...
[09:32:34.551] Searching for globals...
[09:32:34.552] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:34.552] Searching for globals ... DONE
[09:32:34.552] Resolving globals: FALSE
[09:32:34.552] 
[09:32:34.552] 
[09:32:34.552] getGlobalsAndPackages() ... DONE
[09:32:34.553] run() for ‘Future’ ...
[09:32:34.553] - state: ‘created’
[09:32:34.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:34.567] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:34.567] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:34.567]   - Field: ‘node’
[09:32:34.567]   - Field: ‘label’
[09:32:34.567]   - Field: ‘local’
[09:32:34.567]   - Field: ‘owner’
[09:32:34.567]   - Field: ‘envir’
[09:32:34.567]   - Field: ‘workers’
[09:32:34.567]   - Field: ‘packages’
[09:32:34.568]   - Field: ‘gc’
[09:32:34.568]   - Field: ‘conditions’
[09:32:34.568]   - Field: ‘persistent’
[09:32:34.568]   - Field: ‘expr’
[09:32:34.568]   - Field: ‘uuid’
[09:32:34.568]   - Field: ‘seed’
[09:32:34.568]   - Field: ‘version’
[09:32:34.568]   - Field: ‘result’
[09:32:34.568]   - Field: ‘asynchronous’
[09:32:34.568]   - Field: ‘calls’
[09:32:34.568]   - Field: ‘globals’
[09:32:34.569]   - Field: ‘stdout’
[09:32:34.569]   - Field: ‘earlySignal’
[09:32:34.569]   - Field: ‘lazy’
[09:32:34.569]   - Field: ‘state’
[09:32:34.569] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:34.569] - Launch lazy future ...
[09:32:34.569] Packages needed by the future expression (n = 0): <none>
[09:32:34.569] Packages needed by future strategies (n = 0): <none>
[09:32:34.570] {
[09:32:34.570]     {
[09:32:34.570]         {
[09:32:34.570]             ...future.startTime <- base::Sys.time()
[09:32:34.570]             {
[09:32:34.570]                 {
[09:32:34.570]                   {
[09:32:34.570]                     {
[09:32:34.570]                       base::local({
[09:32:34.570]                         has_future <- base::requireNamespace("future", 
[09:32:34.570]                           quietly = TRUE)
[09:32:34.570]                         if (has_future) {
[09:32:34.570]                           ns <- base::getNamespace("future")
[09:32:34.570]                           version <- ns[[".package"]][["version"]]
[09:32:34.570]                           if (is.null(version)) 
[09:32:34.570]                             version <- utils::packageVersion("future")
[09:32:34.570]                         }
[09:32:34.570]                         else {
[09:32:34.570]                           version <- NULL
[09:32:34.570]                         }
[09:32:34.570]                         if (!has_future || version < "1.8.0") {
[09:32:34.570]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:34.570]                             "", base::R.version$version.string), 
[09:32:34.570]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:34.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:34.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:34.570]                               "release", "version")], collapse = " "), 
[09:32:34.570]                             hostname = base::Sys.info()[["nodename"]])
[09:32:34.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:34.570]                             info)
[09:32:34.570]                           info <- base::paste(info, collapse = "; ")
[09:32:34.570]                           if (!has_future) {
[09:32:34.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:34.570]                               info)
[09:32:34.570]                           }
[09:32:34.570]                           else {
[09:32:34.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:34.570]                               info, version)
[09:32:34.570]                           }
[09:32:34.570]                           base::stop(msg)
[09:32:34.570]                         }
[09:32:34.570]                       })
[09:32:34.570]                     }
[09:32:34.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:34.570]                     base::options(mc.cores = 1L)
[09:32:34.570]                   }
[09:32:34.570]                   ...future.strategy.old <- future::plan("list")
[09:32:34.570]                   options(future.plan = NULL)
[09:32:34.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:34.570]                 }
[09:32:34.570]                 ...future.workdir <- getwd()
[09:32:34.570]             }
[09:32:34.570]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:34.570]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:34.570]         }
[09:32:34.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:34.570]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:34.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:34.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:34.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:34.570]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:34.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:34.570]             base::names(...future.oldOptions))
[09:32:34.570]     }
[09:32:34.570]     if (FALSE) {
[09:32:34.570]     }
[09:32:34.570]     else {
[09:32:34.570]         if (TRUE) {
[09:32:34.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:34.570]                 open = "w")
[09:32:34.570]         }
[09:32:34.570]         else {
[09:32:34.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:34.570]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:34.570]         }
[09:32:34.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:34.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:34.570]             base::sink(type = "output", split = FALSE)
[09:32:34.570]             base::close(...future.stdout)
[09:32:34.570]         }, add = TRUE)
[09:32:34.570]     }
[09:32:34.570]     ...future.frame <- base::sys.nframe()
[09:32:34.570]     ...future.conditions <- base::list()
[09:32:34.570]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:34.570]     if (FALSE) {
[09:32:34.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:34.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:34.570]     }
[09:32:34.570]     ...future.result <- base::tryCatch({
[09:32:34.570]         base::withCallingHandlers({
[09:32:34.570]             ...future.value <- base::withVisible(base::local({
[09:32:34.570]                 ...future.makeSendCondition <- base::local({
[09:32:34.570]                   sendCondition <- NULL
[09:32:34.570]                   function(frame = 1L) {
[09:32:34.570]                     if (is.function(sendCondition)) 
[09:32:34.570]                       return(sendCondition)
[09:32:34.570]                     ns <- getNamespace("parallel")
[09:32:34.570]                     if (exists("sendData", mode = "function", 
[09:32:34.570]                       envir = ns)) {
[09:32:34.570]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:34.570]                         envir = ns)
[09:32:34.570]                       envir <- sys.frame(frame)
[09:32:34.570]                       master <- NULL
[09:32:34.570]                       while (!identical(envir, .GlobalEnv) && 
[09:32:34.570]                         !identical(envir, emptyenv())) {
[09:32:34.570]                         if (exists("master", mode = "list", envir = envir, 
[09:32:34.570]                           inherits = FALSE)) {
[09:32:34.570]                           master <- get("master", mode = "list", 
[09:32:34.570]                             envir = envir, inherits = FALSE)
[09:32:34.570]                           if (inherits(master, c("SOCKnode", 
[09:32:34.570]                             "SOCK0node"))) {
[09:32:34.570]                             sendCondition <<- function(cond) {
[09:32:34.570]                               data <- list(type = "VALUE", value = cond, 
[09:32:34.570]                                 success = TRUE)
[09:32:34.570]                               parallel_sendData(master, data)
[09:32:34.570]                             }
[09:32:34.570]                             return(sendCondition)
[09:32:34.570]                           }
[09:32:34.570]                         }
[09:32:34.570]                         frame <- frame + 1L
[09:32:34.570]                         envir <- sys.frame(frame)
[09:32:34.570]                       }
[09:32:34.570]                     }
[09:32:34.570]                     sendCondition <<- function(cond) NULL
[09:32:34.570]                   }
[09:32:34.570]                 })
[09:32:34.570]                 withCallingHandlers({
[09:32:34.570]                   {
[09:32:34.570]                     Sys.sleep(0.5)
[09:32:34.570]                     list(a = 1, b = 42L)
[09:32:34.570]                   }
[09:32:34.570]                 }, immediateCondition = function(cond) {
[09:32:34.570]                   sendCondition <- ...future.makeSendCondition()
[09:32:34.570]                   sendCondition(cond)
[09:32:34.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.570]                   {
[09:32:34.570]                     inherits <- base::inherits
[09:32:34.570]                     invokeRestart <- base::invokeRestart
[09:32:34.570]                     is.null <- base::is.null
[09:32:34.570]                     muffled <- FALSE
[09:32:34.570]                     if (inherits(cond, "message")) {
[09:32:34.570]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:34.570]                       if (muffled) 
[09:32:34.570]                         invokeRestart("muffleMessage")
[09:32:34.570]                     }
[09:32:34.570]                     else if (inherits(cond, "warning")) {
[09:32:34.570]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:34.570]                       if (muffled) 
[09:32:34.570]                         invokeRestart("muffleWarning")
[09:32:34.570]                     }
[09:32:34.570]                     else if (inherits(cond, "condition")) {
[09:32:34.570]                       if (!is.null(pattern)) {
[09:32:34.570]                         computeRestarts <- base::computeRestarts
[09:32:34.570]                         grepl <- base::grepl
[09:32:34.570]                         restarts <- computeRestarts(cond)
[09:32:34.570]                         for (restart in restarts) {
[09:32:34.570]                           name <- restart$name
[09:32:34.570]                           if (is.null(name)) 
[09:32:34.570]                             next
[09:32:34.570]                           if (!grepl(pattern, name)) 
[09:32:34.570]                             next
[09:32:34.570]                           invokeRestart(restart)
[09:32:34.570]                           muffled <- TRUE
[09:32:34.570]                           break
[09:32:34.570]                         }
[09:32:34.570]                       }
[09:32:34.570]                     }
[09:32:34.570]                     invisible(muffled)
[09:32:34.570]                   }
[09:32:34.570]                   muffleCondition(cond)
[09:32:34.570]                 })
[09:32:34.570]             }))
[09:32:34.570]             future::FutureResult(value = ...future.value$value, 
[09:32:34.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.570]                   ...future.rng), globalenv = if (FALSE) 
[09:32:34.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:34.570]                     ...future.globalenv.names))
[09:32:34.570]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:34.570]         }, condition = base::local({
[09:32:34.570]             c <- base::c
[09:32:34.570]             inherits <- base::inherits
[09:32:34.570]             invokeRestart <- base::invokeRestart
[09:32:34.570]             length <- base::length
[09:32:34.570]             list <- base::list
[09:32:34.570]             seq.int <- base::seq.int
[09:32:34.570]             signalCondition <- base::signalCondition
[09:32:34.570]             sys.calls <- base::sys.calls
[09:32:34.570]             `[[` <- base::`[[`
[09:32:34.570]             `+` <- base::`+`
[09:32:34.570]             `<<-` <- base::`<<-`
[09:32:34.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:34.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:34.570]                   3L)]
[09:32:34.570]             }
[09:32:34.570]             function(cond) {
[09:32:34.570]                 is_error <- inherits(cond, "error")
[09:32:34.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:34.570]                   NULL)
[09:32:34.570]                 if (is_error) {
[09:32:34.570]                   sessionInformation <- function() {
[09:32:34.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:34.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:34.570]                       search = base::search(), system = base::Sys.info())
[09:32:34.570]                   }
[09:32:34.570]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:34.570]                     cond$call), session = sessionInformation(), 
[09:32:34.570]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:34.570]                   signalCondition(cond)
[09:32:34.570]                 }
[09:32:34.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:34.570]                 "immediateCondition"))) {
[09:32:34.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:34.570]                   ...future.conditions[[length(...future.conditions) + 
[09:32:34.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:34.570]                   if (TRUE && !signal) {
[09:32:34.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.570]                     {
[09:32:34.570]                       inherits <- base::inherits
[09:32:34.570]                       invokeRestart <- base::invokeRestart
[09:32:34.570]                       is.null <- base::is.null
[09:32:34.570]                       muffled <- FALSE
[09:32:34.570]                       if (inherits(cond, "message")) {
[09:32:34.570]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.570]                         if (muffled) 
[09:32:34.570]                           invokeRestart("muffleMessage")
[09:32:34.570]                       }
[09:32:34.570]                       else if (inherits(cond, "warning")) {
[09:32:34.570]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.570]                         if (muffled) 
[09:32:34.570]                           invokeRestart("muffleWarning")
[09:32:34.570]                       }
[09:32:34.570]                       else if (inherits(cond, "condition")) {
[09:32:34.570]                         if (!is.null(pattern)) {
[09:32:34.570]                           computeRestarts <- base::computeRestarts
[09:32:34.570]                           grepl <- base::grepl
[09:32:34.570]                           restarts <- computeRestarts(cond)
[09:32:34.570]                           for (restart in restarts) {
[09:32:34.570]                             name <- restart$name
[09:32:34.570]                             if (is.null(name)) 
[09:32:34.570]                               next
[09:32:34.570]                             if (!grepl(pattern, name)) 
[09:32:34.570]                               next
[09:32:34.570]                             invokeRestart(restart)
[09:32:34.570]                             muffled <- TRUE
[09:32:34.570]                             break
[09:32:34.570]                           }
[09:32:34.570]                         }
[09:32:34.570]                       }
[09:32:34.570]                       invisible(muffled)
[09:32:34.570]                     }
[09:32:34.570]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.570]                   }
[09:32:34.570]                 }
[09:32:34.570]                 else {
[09:32:34.570]                   if (TRUE) {
[09:32:34.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:34.570]                     {
[09:32:34.570]                       inherits <- base::inherits
[09:32:34.570]                       invokeRestart <- base::invokeRestart
[09:32:34.570]                       is.null <- base::is.null
[09:32:34.570]                       muffled <- FALSE
[09:32:34.570]                       if (inherits(cond, "message")) {
[09:32:34.570]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:34.570]                         if (muffled) 
[09:32:34.570]                           invokeRestart("muffleMessage")
[09:32:34.570]                       }
[09:32:34.570]                       else if (inherits(cond, "warning")) {
[09:32:34.570]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:34.570]                         if (muffled) 
[09:32:34.570]                           invokeRestart("muffleWarning")
[09:32:34.570]                       }
[09:32:34.570]                       else if (inherits(cond, "condition")) {
[09:32:34.570]                         if (!is.null(pattern)) {
[09:32:34.570]                           computeRestarts <- base::computeRestarts
[09:32:34.570]                           grepl <- base::grepl
[09:32:34.570]                           restarts <- computeRestarts(cond)
[09:32:34.570]                           for (restart in restarts) {
[09:32:34.570]                             name <- restart$name
[09:32:34.570]                             if (is.null(name)) 
[09:32:34.570]                               next
[09:32:34.570]                             if (!grepl(pattern, name)) 
[09:32:34.570]                               next
[09:32:34.570]                             invokeRestart(restart)
[09:32:34.570]                             muffled <- TRUE
[09:32:34.570]                             break
[09:32:34.570]                           }
[09:32:34.570]                         }
[09:32:34.570]                       }
[09:32:34.570]                       invisible(muffled)
[09:32:34.570]                     }
[09:32:34.570]                     muffleCondition(cond, pattern = "^muffle")
[09:32:34.570]                   }
[09:32:34.570]                 }
[09:32:34.570]             }
[09:32:34.570]         }))
[09:32:34.570]     }, error = function(ex) {
[09:32:34.570]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:34.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:34.570]                 ...future.rng), started = ...future.startTime, 
[09:32:34.570]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:34.570]             version = "1.8"), class = "FutureResult")
[09:32:34.570]     }, finally = {
[09:32:34.570]         if (!identical(...future.workdir, getwd())) 
[09:32:34.570]             setwd(...future.workdir)
[09:32:34.570]         {
[09:32:34.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:34.570]                 ...future.oldOptions$nwarnings <- NULL
[09:32:34.570]             }
[09:32:34.570]             base::options(...future.oldOptions)
[09:32:34.570]             if (.Platform$OS.type == "windows") {
[09:32:34.570]                 old_names <- names(...future.oldEnvVars)
[09:32:34.570]                 envs <- base::Sys.getenv()
[09:32:34.570]                 names <- names(envs)
[09:32:34.570]                 common <- intersect(names, old_names)
[09:32:34.570]                 added <- setdiff(names, old_names)
[09:32:34.570]                 removed <- setdiff(old_names, names)
[09:32:34.570]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:34.570]                   envs[common]]
[09:32:34.570]                 NAMES <- toupper(changed)
[09:32:34.570]                 args <- list()
[09:32:34.570]                 for (kk in seq_along(NAMES)) {
[09:32:34.570]                   name <- changed[[kk]]
[09:32:34.570]                   NAME <- NAMES[[kk]]
[09:32:34.570]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.570]                     next
[09:32:34.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.570]                 }
[09:32:34.570]                 NAMES <- toupper(added)
[09:32:34.570]                 for (kk in seq_along(NAMES)) {
[09:32:34.570]                   name <- added[[kk]]
[09:32:34.570]                   NAME <- NAMES[[kk]]
[09:32:34.570]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.570]                     next
[09:32:34.570]                   args[[name]] <- ""
[09:32:34.570]                 }
[09:32:34.570]                 NAMES <- toupper(removed)
[09:32:34.570]                 for (kk in seq_along(NAMES)) {
[09:32:34.570]                   name <- removed[[kk]]
[09:32:34.570]                   NAME <- NAMES[[kk]]
[09:32:34.570]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:34.570]                     next
[09:32:34.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:34.570]                 }
[09:32:34.570]                 if (length(args) > 0) 
[09:32:34.570]                   base::do.call(base::Sys.setenv, args = args)
[09:32:34.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:34.570]             }
[09:32:34.570]             else {
[09:32:34.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:34.570]             }
[09:32:34.570]             {
[09:32:34.570]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:34.570]                   0L) {
[09:32:34.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:34.570]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:34.570]                   base::options(opts)
[09:32:34.570]                 }
[09:32:34.570]                 {
[09:32:34.570]                   {
[09:32:34.570]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:34.570]                     NULL
[09:32:34.570]                   }
[09:32:34.570]                   options(future.plan = NULL)
[09:32:34.570]                   if (is.na(NA_character_)) 
[09:32:34.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:34.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:34.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:34.570]                     .init = FALSE)
[09:32:34.570]                 }
[09:32:34.570]             }
[09:32:34.570]         }
[09:32:34.570]     })
[09:32:34.570]     if (TRUE) {
[09:32:34.570]         base::sink(type = "output", split = FALSE)
[09:32:34.570]         if (TRUE) {
[09:32:34.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:34.570]         }
[09:32:34.570]         else {
[09:32:34.570]             ...future.result["stdout"] <- base::list(NULL)
[09:32:34.570]         }
[09:32:34.570]         base::close(...future.stdout)
[09:32:34.570]         ...future.stdout <- NULL
[09:32:34.570]     }
[09:32:34.570]     ...future.result$conditions <- ...future.conditions
[09:32:34.570]     ...future.result$finished <- base::Sys.time()
[09:32:34.570]     ...future.result
[09:32:34.570] }
[09:32:34.573] MultisessionFuture started
[09:32:34.573] - Launch lazy future ... done
[09:32:34.573] run() for ‘MultisessionFuture’ ... done
[09:32:35.075] receiveMessageFromWorker() for ClusterFuture ...
[09:32:35.076] - Validating connection of MultisessionFuture
[09:32:35.076] - received message: FutureResult
[09:32:35.076] - Received FutureResult
[09:32:35.076] - Erased future from FutureRegistry
[09:32:35.076] result() for ClusterFuture ...
[09:32:35.076] - result already collected: FutureResult
[09:32:35.076] result() for ClusterFuture ... done
[09:32:35.076] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:35.076] resolve() on list ...
[09:32:35.077]  recursive: 1
[09:32:35.077]  length: 2
[09:32:35.077]  elements: ‘a’, ‘b’
[09:32:35.077]  length: 1 (resolved future 1)
[09:32:35.077]  length: 0 (resolved future 2)
[09:32:35.077] resolve() on list ... DONE
[09:32:35.077] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[09:32:35.077] getGlobalsAndPackages() ...
[09:32:35.077] Searching for globals...
[09:32:35.078] - globals found: [2] ‘list’, ‘stop’
[09:32:35.078] Searching for globals ... DONE
[09:32:35.078] Resolving globals: FALSE
[09:32:35.079] 
[09:32:35.079] 
[09:32:35.079] getGlobalsAndPackages() ... DONE
[09:32:35.079] run() for ‘Future’ ...
[09:32:35.079] - state: ‘created’
[09:32:35.079] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:35.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:35.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:35.095]   - Field: ‘node’
[09:32:35.095]   - Field: ‘label’
[09:32:35.095]   - Field: ‘local’
[09:32:35.095]   - Field: ‘owner’
[09:32:35.095]   - Field: ‘envir’
[09:32:35.095]   - Field: ‘workers’
[09:32:35.095]   - Field: ‘packages’
[09:32:35.096]   - Field: ‘gc’
[09:32:35.096]   - Field: ‘conditions’
[09:32:35.096]   - Field: ‘persistent’
[09:32:35.096]   - Field: ‘expr’
[09:32:35.096]   - Field: ‘uuid’
[09:32:35.096]   - Field: ‘seed’
[09:32:35.096]   - Field: ‘version’
[09:32:35.097]   - Field: ‘result’
[09:32:35.097]   - Field: ‘asynchronous’
[09:32:35.097]   - Field: ‘calls’
[09:32:35.097]   - Field: ‘globals’
[09:32:35.097]   - Field: ‘stdout’
[09:32:35.097]   - Field: ‘earlySignal’
[09:32:35.097]   - Field: ‘lazy’
[09:32:35.097]   - Field: ‘state’
[09:32:35.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:35.098] - Launch lazy future ...
[09:32:35.098] Packages needed by the future expression (n = 0): <none>
[09:32:35.098] Packages needed by future strategies (n = 0): <none>
[09:32:35.099] {
[09:32:35.099]     {
[09:32:35.099]         {
[09:32:35.099]             ...future.startTime <- base::Sys.time()
[09:32:35.099]             {
[09:32:35.099]                 {
[09:32:35.099]                   {
[09:32:35.099]                     {
[09:32:35.099]                       base::local({
[09:32:35.099]                         has_future <- base::requireNamespace("future", 
[09:32:35.099]                           quietly = TRUE)
[09:32:35.099]                         if (has_future) {
[09:32:35.099]                           ns <- base::getNamespace("future")
[09:32:35.099]                           version <- ns[[".package"]][["version"]]
[09:32:35.099]                           if (is.null(version)) 
[09:32:35.099]                             version <- utils::packageVersion("future")
[09:32:35.099]                         }
[09:32:35.099]                         else {
[09:32:35.099]                           version <- NULL
[09:32:35.099]                         }
[09:32:35.099]                         if (!has_future || version < "1.8.0") {
[09:32:35.099]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:35.099]                             "", base::R.version$version.string), 
[09:32:35.099]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:35.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:35.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:35.099]                               "release", "version")], collapse = " "), 
[09:32:35.099]                             hostname = base::Sys.info()[["nodename"]])
[09:32:35.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:35.099]                             info)
[09:32:35.099]                           info <- base::paste(info, collapse = "; ")
[09:32:35.099]                           if (!has_future) {
[09:32:35.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:35.099]                               info)
[09:32:35.099]                           }
[09:32:35.099]                           else {
[09:32:35.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:35.099]                               info, version)
[09:32:35.099]                           }
[09:32:35.099]                           base::stop(msg)
[09:32:35.099]                         }
[09:32:35.099]                       })
[09:32:35.099]                     }
[09:32:35.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:35.099]                     base::options(mc.cores = 1L)
[09:32:35.099]                   }
[09:32:35.099]                   ...future.strategy.old <- future::plan("list")
[09:32:35.099]                   options(future.plan = NULL)
[09:32:35.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:35.099]                 }
[09:32:35.099]                 ...future.workdir <- getwd()
[09:32:35.099]             }
[09:32:35.099]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:35.099]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:35.099]         }
[09:32:35.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:35.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:35.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:35.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:35.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:35.099]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:35.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:35.099]             base::names(...future.oldOptions))
[09:32:35.099]     }
[09:32:35.099]     if (FALSE) {
[09:32:35.099]     }
[09:32:35.099]     else {
[09:32:35.099]         if (TRUE) {
[09:32:35.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:35.099]                 open = "w")
[09:32:35.099]         }
[09:32:35.099]         else {
[09:32:35.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:35.099]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:35.099]         }
[09:32:35.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:35.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:35.099]             base::sink(type = "output", split = FALSE)
[09:32:35.099]             base::close(...future.stdout)
[09:32:35.099]         }, add = TRUE)
[09:32:35.099]     }
[09:32:35.099]     ...future.frame <- base::sys.nframe()
[09:32:35.099]     ...future.conditions <- base::list()
[09:32:35.099]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:35.099]     if (FALSE) {
[09:32:35.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:35.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:35.099]     }
[09:32:35.099]     ...future.result <- base::tryCatch({
[09:32:35.099]         base::withCallingHandlers({
[09:32:35.099]             ...future.value <- base::withVisible(base::local({
[09:32:35.099]                 ...future.makeSendCondition <- base::local({
[09:32:35.099]                   sendCondition <- NULL
[09:32:35.099]                   function(frame = 1L) {
[09:32:35.099]                     if (is.function(sendCondition)) 
[09:32:35.099]                       return(sendCondition)
[09:32:35.099]                     ns <- getNamespace("parallel")
[09:32:35.099]                     if (exists("sendData", mode = "function", 
[09:32:35.099]                       envir = ns)) {
[09:32:35.099]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:35.099]                         envir = ns)
[09:32:35.099]                       envir <- sys.frame(frame)
[09:32:35.099]                       master <- NULL
[09:32:35.099]                       while (!identical(envir, .GlobalEnv) && 
[09:32:35.099]                         !identical(envir, emptyenv())) {
[09:32:35.099]                         if (exists("master", mode = "list", envir = envir, 
[09:32:35.099]                           inherits = FALSE)) {
[09:32:35.099]                           master <- get("master", mode = "list", 
[09:32:35.099]                             envir = envir, inherits = FALSE)
[09:32:35.099]                           if (inherits(master, c("SOCKnode", 
[09:32:35.099]                             "SOCK0node"))) {
[09:32:35.099]                             sendCondition <<- function(cond) {
[09:32:35.099]                               data <- list(type = "VALUE", value = cond, 
[09:32:35.099]                                 success = TRUE)
[09:32:35.099]                               parallel_sendData(master, data)
[09:32:35.099]                             }
[09:32:35.099]                             return(sendCondition)
[09:32:35.099]                           }
[09:32:35.099]                         }
[09:32:35.099]                         frame <- frame + 1L
[09:32:35.099]                         envir <- sys.frame(frame)
[09:32:35.099]                       }
[09:32:35.099]                     }
[09:32:35.099]                     sendCondition <<- function(cond) NULL
[09:32:35.099]                   }
[09:32:35.099]                 })
[09:32:35.099]                 withCallingHandlers({
[09:32:35.099]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:35.099]                 }, immediateCondition = function(cond) {
[09:32:35.099]                   sendCondition <- ...future.makeSendCondition()
[09:32:35.099]                   sendCondition(cond)
[09:32:35.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.099]                   {
[09:32:35.099]                     inherits <- base::inherits
[09:32:35.099]                     invokeRestart <- base::invokeRestart
[09:32:35.099]                     is.null <- base::is.null
[09:32:35.099]                     muffled <- FALSE
[09:32:35.099]                     if (inherits(cond, "message")) {
[09:32:35.099]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:35.099]                       if (muffled) 
[09:32:35.099]                         invokeRestart("muffleMessage")
[09:32:35.099]                     }
[09:32:35.099]                     else if (inherits(cond, "warning")) {
[09:32:35.099]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:35.099]                       if (muffled) 
[09:32:35.099]                         invokeRestart("muffleWarning")
[09:32:35.099]                     }
[09:32:35.099]                     else if (inherits(cond, "condition")) {
[09:32:35.099]                       if (!is.null(pattern)) {
[09:32:35.099]                         computeRestarts <- base::computeRestarts
[09:32:35.099]                         grepl <- base::grepl
[09:32:35.099]                         restarts <- computeRestarts(cond)
[09:32:35.099]                         for (restart in restarts) {
[09:32:35.099]                           name <- restart$name
[09:32:35.099]                           if (is.null(name)) 
[09:32:35.099]                             next
[09:32:35.099]                           if (!grepl(pattern, name)) 
[09:32:35.099]                             next
[09:32:35.099]                           invokeRestart(restart)
[09:32:35.099]                           muffled <- TRUE
[09:32:35.099]                           break
[09:32:35.099]                         }
[09:32:35.099]                       }
[09:32:35.099]                     }
[09:32:35.099]                     invisible(muffled)
[09:32:35.099]                   }
[09:32:35.099]                   muffleCondition(cond)
[09:32:35.099]                 })
[09:32:35.099]             }))
[09:32:35.099]             future::FutureResult(value = ...future.value$value, 
[09:32:35.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.099]                   ...future.rng), globalenv = if (FALSE) 
[09:32:35.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:35.099]                     ...future.globalenv.names))
[09:32:35.099]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:35.099]         }, condition = base::local({
[09:32:35.099]             c <- base::c
[09:32:35.099]             inherits <- base::inherits
[09:32:35.099]             invokeRestart <- base::invokeRestart
[09:32:35.099]             length <- base::length
[09:32:35.099]             list <- base::list
[09:32:35.099]             seq.int <- base::seq.int
[09:32:35.099]             signalCondition <- base::signalCondition
[09:32:35.099]             sys.calls <- base::sys.calls
[09:32:35.099]             `[[` <- base::`[[`
[09:32:35.099]             `+` <- base::`+`
[09:32:35.099]             `<<-` <- base::`<<-`
[09:32:35.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:35.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:35.099]                   3L)]
[09:32:35.099]             }
[09:32:35.099]             function(cond) {
[09:32:35.099]                 is_error <- inherits(cond, "error")
[09:32:35.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:35.099]                   NULL)
[09:32:35.099]                 if (is_error) {
[09:32:35.099]                   sessionInformation <- function() {
[09:32:35.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:35.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:35.099]                       search = base::search(), system = base::Sys.info())
[09:32:35.099]                   }
[09:32:35.099]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:35.099]                     cond$call), session = sessionInformation(), 
[09:32:35.099]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:35.099]                   signalCondition(cond)
[09:32:35.099]                 }
[09:32:35.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:35.099]                 "immediateCondition"))) {
[09:32:35.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:35.099]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:35.099]                   if (TRUE && !signal) {
[09:32:35.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.099]                     {
[09:32:35.099]                       inherits <- base::inherits
[09:32:35.099]                       invokeRestart <- base::invokeRestart
[09:32:35.099]                       is.null <- base::is.null
[09:32:35.099]                       muffled <- FALSE
[09:32:35.099]                       if (inherits(cond, "message")) {
[09:32:35.099]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.099]                         if (muffled) 
[09:32:35.099]                           invokeRestart("muffleMessage")
[09:32:35.099]                       }
[09:32:35.099]                       else if (inherits(cond, "warning")) {
[09:32:35.099]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.099]                         if (muffled) 
[09:32:35.099]                           invokeRestart("muffleWarning")
[09:32:35.099]                       }
[09:32:35.099]                       else if (inherits(cond, "condition")) {
[09:32:35.099]                         if (!is.null(pattern)) {
[09:32:35.099]                           computeRestarts <- base::computeRestarts
[09:32:35.099]                           grepl <- base::grepl
[09:32:35.099]                           restarts <- computeRestarts(cond)
[09:32:35.099]                           for (restart in restarts) {
[09:32:35.099]                             name <- restart$name
[09:32:35.099]                             if (is.null(name)) 
[09:32:35.099]                               next
[09:32:35.099]                             if (!grepl(pattern, name)) 
[09:32:35.099]                               next
[09:32:35.099]                             invokeRestart(restart)
[09:32:35.099]                             muffled <- TRUE
[09:32:35.099]                             break
[09:32:35.099]                           }
[09:32:35.099]                         }
[09:32:35.099]                       }
[09:32:35.099]                       invisible(muffled)
[09:32:35.099]                     }
[09:32:35.099]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.099]                   }
[09:32:35.099]                 }
[09:32:35.099]                 else {
[09:32:35.099]                   if (TRUE) {
[09:32:35.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.099]                     {
[09:32:35.099]                       inherits <- base::inherits
[09:32:35.099]                       invokeRestart <- base::invokeRestart
[09:32:35.099]                       is.null <- base::is.null
[09:32:35.099]                       muffled <- FALSE
[09:32:35.099]                       if (inherits(cond, "message")) {
[09:32:35.099]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.099]                         if (muffled) 
[09:32:35.099]                           invokeRestart("muffleMessage")
[09:32:35.099]                       }
[09:32:35.099]                       else if (inherits(cond, "warning")) {
[09:32:35.099]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.099]                         if (muffled) 
[09:32:35.099]                           invokeRestart("muffleWarning")
[09:32:35.099]                       }
[09:32:35.099]                       else if (inherits(cond, "condition")) {
[09:32:35.099]                         if (!is.null(pattern)) {
[09:32:35.099]                           computeRestarts <- base::computeRestarts
[09:32:35.099]                           grepl <- base::grepl
[09:32:35.099]                           restarts <- computeRestarts(cond)
[09:32:35.099]                           for (restart in restarts) {
[09:32:35.099]                             name <- restart$name
[09:32:35.099]                             if (is.null(name)) 
[09:32:35.099]                               next
[09:32:35.099]                             if (!grepl(pattern, name)) 
[09:32:35.099]                               next
[09:32:35.099]                             invokeRestart(restart)
[09:32:35.099]                             muffled <- TRUE
[09:32:35.099]                             break
[09:32:35.099]                           }
[09:32:35.099]                         }
[09:32:35.099]                       }
[09:32:35.099]                       invisible(muffled)
[09:32:35.099]                     }
[09:32:35.099]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.099]                   }
[09:32:35.099]                 }
[09:32:35.099]             }
[09:32:35.099]         }))
[09:32:35.099]     }, error = function(ex) {
[09:32:35.099]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:35.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.099]                 ...future.rng), started = ...future.startTime, 
[09:32:35.099]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:35.099]             version = "1.8"), class = "FutureResult")
[09:32:35.099]     }, finally = {
[09:32:35.099]         if (!identical(...future.workdir, getwd())) 
[09:32:35.099]             setwd(...future.workdir)
[09:32:35.099]         {
[09:32:35.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:35.099]                 ...future.oldOptions$nwarnings <- NULL
[09:32:35.099]             }
[09:32:35.099]             base::options(...future.oldOptions)
[09:32:35.099]             if (.Platform$OS.type == "windows") {
[09:32:35.099]                 old_names <- names(...future.oldEnvVars)
[09:32:35.099]                 envs <- base::Sys.getenv()
[09:32:35.099]                 names <- names(envs)
[09:32:35.099]                 common <- intersect(names, old_names)
[09:32:35.099]                 added <- setdiff(names, old_names)
[09:32:35.099]                 removed <- setdiff(old_names, names)
[09:32:35.099]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:35.099]                   envs[common]]
[09:32:35.099]                 NAMES <- toupper(changed)
[09:32:35.099]                 args <- list()
[09:32:35.099]                 for (kk in seq_along(NAMES)) {
[09:32:35.099]                   name <- changed[[kk]]
[09:32:35.099]                   NAME <- NAMES[[kk]]
[09:32:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.099]                     next
[09:32:35.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.099]                 }
[09:32:35.099]                 NAMES <- toupper(added)
[09:32:35.099]                 for (kk in seq_along(NAMES)) {
[09:32:35.099]                   name <- added[[kk]]
[09:32:35.099]                   NAME <- NAMES[[kk]]
[09:32:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.099]                     next
[09:32:35.099]                   args[[name]] <- ""
[09:32:35.099]                 }
[09:32:35.099]                 NAMES <- toupper(removed)
[09:32:35.099]                 for (kk in seq_along(NAMES)) {
[09:32:35.099]                   name <- removed[[kk]]
[09:32:35.099]                   NAME <- NAMES[[kk]]
[09:32:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.099]                     next
[09:32:35.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.099]                 }
[09:32:35.099]                 if (length(args) > 0) 
[09:32:35.099]                   base::do.call(base::Sys.setenv, args = args)
[09:32:35.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:35.099]             }
[09:32:35.099]             else {
[09:32:35.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:35.099]             }
[09:32:35.099]             {
[09:32:35.099]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:35.099]                   0L) {
[09:32:35.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:35.099]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:35.099]                   base::options(opts)
[09:32:35.099]                 }
[09:32:35.099]                 {
[09:32:35.099]                   {
[09:32:35.099]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:35.099]                     NULL
[09:32:35.099]                   }
[09:32:35.099]                   options(future.plan = NULL)
[09:32:35.099]                   if (is.na(NA_character_)) 
[09:32:35.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:35.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:35.099]                     .init = FALSE)
[09:32:35.099]                 }
[09:32:35.099]             }
[09:32:35.099]         }
[09:32:35.099]     })
[09:32:35.099]     if (TRUE) {
[09:32:35.099]         base::sink(type = "output", split = FALSE)
[09:32:35.099]         if (TRUE) {
[09:32:35.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:35.099]         }
[09:32:35.099]         else {
[09:32:35.099]             ...future.result["stdout"] <- base::list(NULL)
[09:32:35.099]         }
[09:32:35.099]         base::close(...future.stdout)
[09:32:35.099]         ...future.stdout <- NULL
[09:32:35.099]     }
[09:32:35.099]     ...future.result$conditions <- ...future.conditions
[09:32:35.099]     ...future.result$finished <- base::Sys.time()
[09:32:35.099]     ...future.result
[09:32:35.099] }
[09:32:35.102] MultisessionFuture started
[09:32:35.103] - Launch lazy future ... done
[09:32:35.103] run() for ‘MultisessionFuture’ ... done
[09:32:35.105] receiveMessageFromWorker() for ClusterFuture ...
[09:32:35.105] - Validating connection of MultisessionFuture
[09:32:35.106] - received message: FutureResult
[09:32:35.106] - Received FutureResult
[09:32:35.106] - Erased future from FutureRegistry
[09:32:35.106] result() for ClusterFuture ...
[09:32:35.106] - result already collected: FutureResult
[09:32:35.106] result() for ClusterFuture ... done
[09:32:35.107] signalConditions() ...
[09:32:35.107]  - include = ‘immediateCondition’
[09:32:35.107]  - exclude = 
[09:32:35.107]  - resignal = FALSE
[09:32:35.107]  - Number of conditions: 1
[09:32:35.107] signalConditions() ... done
[09:32:35.107] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:35.107] A MultisessionFuture was resolved (and resolved itself)
[09:32:35.108] getGlobalsAndPackages() ...
[09:32:35.108] Searching for globals...
[09:32:35.109] - globals found: [2] ‘list’, ‘stop’
[09:32:35.109] Searching for globals ... DONE
[09:32:35.109] Resolving globals: FALSE
[09:32:35.109] 
[09:32:35.109] 
[09:32:35.109] getGlobalsAndPackages() ... DONE
[09:32:35.110] run() for ‘Future’ ...
[09:32:35.110] - state: ‘created’
[09:32:35.110] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:35.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:35.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:35.126]   - Field: ‘node’
[09:32:35.126]   - Field: ‘label’
[09:32:35.126]   - Field: ‘local’
[09:32:35.126]   - Field: ‘owner’
[09:32:35.126]   - Field: ‘envir’
[09:32:35.126]   - Field: ‘workers’
[09:32:35.126]   - Field: ‘packages’
[09:32:35.127]   - Field: ‘gc’
[09:32:35.127]   - Field: ‘conditions’
[09:32:35.127]   - Field: ‘persistent’
[09:32:35.127]   - Field: ‘expr’
[09:32:35.127]   - Field: ‘uuid’
[09:32:35.127]   - Field: ‘seed’
[09:32:35.127]   - Field: ‘version’
[09:32:35.127]   - Field: ‘result’
[09:32:35.128]   - Field: ‘asynchronous’
[09:32:35.128]   - Field: ‘calls’
[09:32:35.128]   - Field: ‘globals’
[09:32:35.128]   - Field: ‘stdout’
[09:32:35.131]   - Field: ‘earlySignal’
[09:32:35.131]   - Field: ‘lazy’
[09:32:35.131]   - Field: ‘state’
[09:32:35.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:35.131] - Launch lazy future ...
[09:32:35.132] Packages needed by the future expression (n = 0): <none>
[09:32:35.132] Packages needed by future strategies (n = 0): <none>
[09:32:35.133] {
[09:32:35.133]     {
[09:32:35.133]         {
[09:32:35.133]             ...future.startTime <- base::Sys.time()
[09:32:35.133]             {
[09:32:35.133]                 {
[09:32:35.133]                   {
[09:32:35.133]                     {
[09:32:35.133]                       base::local({
[09:32:35.133]                         has_future <- base::requireNamespace("future", 
[09:32:35.133]                           quietly = TRUE)
[09:32:35.133]                         if (has_future) {
[09:32:35.133]                           ns <- base::getNamespace("future")
[09:32:35.133]                           version <- ns[[".package"]][["version"]]
[09:32:35.133]                           if (is.null(version)) 
[09:32:35.133]                             version <- utils::packageVersion("future")
[09:32:35.133]                         }
[09:32:35.133]                         else {
[09:32:35.133]                           version <- NULL
[09:32:35.133]                         }
[09:32:35.133]                         if (!has_future || version < "1.8.0") {
[09:32:35.133]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:35.133]                             "", base::R.version$version.string), 
[09:32:35.133]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:35.133]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:35.133]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:35.133]                               "release", "version")], collapse = " "), 
[09:32:35.133]                             hostname = base::Sys.info()[["nodename"]])
[09:32:35.133]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:35.133]                             info)
[09:32:35.133]                           info <- base::paste(info, collapse = "; ")
[09:32:35.133]                           if (!has_future) {
[09:32:35.133]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:35.133]                               info)
[09:32:35.133]                           }
[09:32:35.133]                           else {
[09:32:35.133]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:35.133]                               info, version)
[09:32:35.133]                           }
[09:32:35.133]                           base::stop(msg)
[09:32:35.133]                         }
[09:32:35.133]                       })
[09:32:35.133]                     }
[09:32:35.133]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:35.133]                     base::options(mc.cores = 1L)
[09:32:35.133]                   }
[09:32:35.133]                   ...future.strategy.old <- future::plan("list")
[09:32:35.133]                   options(future.plan = NULL)
[09:32:35.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.133]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:35.133]                 }
[09:32:35.133]                 ...future.workdir <- getwd()
[09:32:35.133]             }
[09:32:35.133]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:35.133]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:35.133]         }
[09:32:35.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:35.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:35.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:35.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:35.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:35.133]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:35.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:35.133]             base::names(...future.oldOptions))
[09:32:35.133]     }
[09:32:35.133]     if (FALSE) {
[09:32:35.133]     }
[09:32:35.133]     else {
[09:32:35.133]         if (TRUE) {
[09:32:35.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:35.133]                 open = "w")
[09:32:35.133]         }
[09:32:35.133]         else {
[09:32:35.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:35.133]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:35.133]         }
[09:32:35.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:35.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:35.133]             base::sink(type = "output", split = FALSE)
[09:32:35.133]             base::close(...future.stdout)
[09:32:35.133]         }, add = TRUE)
[09:32:35.133]     }
[09:32:35.133]     ...future.frame <- base::sys.nframe()
[09:32:35.133]     ...future.conditions <- base::list()
[09:32:35.133]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:35.133]     if (FALSE) {
[09:32:35.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:35.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:35.133]     }
[09:32:35.133]     ...future.result <- base::tryCatch({
[09:32:35.133]         base::withCallingHandlers({
[09:32:35.133]             ...future.value <- base::withVisible(base::local({
[09:32:35.133]                 ...future.makeSendCondition <- base::local({
[09:32:35.133]                   sendCondition <- NULL
[09:32:35.133]                   function(frame = 1L) {
[09:32:35.133]                     if (is.function(sendCondition)) 
[09:32:35.133]                       return(sendCondition)
[09:32:35.133]                     ns <- getNamespace("parallel")
[09:32:35.133]                     if (exists("sendData", mode = "function", 
[09:32:35.133]                       envir = ns)) {
[09:32:35.133]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:35.133]                         envir = ns)
[09:32:35.133]                       envir <- sys.frame(frame)
[09:32:35.133]                       master <- NULL
[09:32:35.133]                       while (!identical(envir, .GlobalEnv) && 
[09:32:35.133]                         !identical(envir, emptyenv())) {
[09:32:35.133]                         if (exists("master", mode = "list", envir = envir, 
[09:32:35.133]                           inherits = FALSE)) {
[09:32:35.133]                           master <- get("master", mode = "list", 
[09:32:35.133]                             envir = envir, inherits = FALSE)
[09:32:35.133]                           if (inherits(master, c("SOCKnode", 
[09:32:35.133]                             "SOCK0node"))) {
[09:32:35.133]                             sendCondition <<- function(cond) {
[09:32:35.133]                               data <- list(type = "VALUE", value = cond, 
[09:32:35.133]                                 success = TRUE)
[09:32:35.133]                               parallel_sendData(master, data)
[09:32:35.133]                             }
[09:32:35.133]                             return(sendCondition)
[09:32:35.133]                           }
[09:32:35.133]                         }
[09:32:35.133]                         frame <- frame + 1L
[09:32:35.133]                         envir <- sys.frame(frame)
[09:32:35.133]                       }
[09:32:35.133]                     }
[09:32:35.133]                     sendCondition <<- function(cond) NULL
[09:32:35.133]                   }
[09:32:35.133]                 })
[09:32:35.133]                 withCallingHandlers({
[09:32:35.133]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:35.133]                 }, immediateCondition = function(cond) {
[09:32:35.133]                   sendCondition <- ...future.makeSendCondition()
[09:32:35.133]                   sendCondition(cond)
[09:32:35.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.133]                   {
[09:32:35.133]                     inherits <- base::inherits
[09:32:35.133]                     invokeRestart <- base::invokeRestart
[09:32:35.133]                     is.null <- base::is.null
[09:32:35.133]                     muffled <- FALSE
[09:32:35.133]                     if (inherits(cond, "message")) {
[09:32:35.133]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:35.133]                       if (muffled) 
[09:32:35.133]                         invokeRestart("muffleMessage")
[09:32:35.133]                     }
[09:32:35.133]                     else if (inherits(cond, "warning")) {
[09:32:35.133]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:35.133]                       if (muffled) 
[09:32:35.133]                         invokeRestart("muffleWarning")
[09:32:35.133]                     }
[09:32:35.133]                     else if (inherits(cond, "condition")) {
[09:32:35.133]                       if (!is.null(pattern)) {
[09:32:35.133]                         computeRestarts <- base::computeRestarts
[09:32:35.133]                         grepl <- base::grepl
[09:32:35.133]                         restarts <- computeRestarts(cond)
[09:32:35.133]                         for (restart in restarts) {
[09:32:35.133]                           name <- restart$name
[09:32:35.133]                           if (is.null(name)) 
[09:32:35.133]                             next
[09:32:35.133]                           if (!grepl(pattern, name)) 
[09:32:35.133]                             next
[09:32:35.133]                           invokeRestart(restart)
[09:32:35.133]                           muffled <- TRUE
[09:32:35.133]                           break
[09:32:35.133]                         }
[09:32:35.133]                       }
[09:32:35.133]                     }
[09:32:35.133]                     invisible(muffled)
[09:32:35.133]                   }
[09:32:35.133]                   muffleCondition(cond)
[09:32:35.133]                 })
[09:32:35.133]             }))
[09:32:35.133]             future::FutureResult(value = ...future.value$value, 
[09:32:35.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.133]                   ...future.rng), globalenv = if (FALSE) 
[09:32:35.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:35.133]                     ...future.globalenv.names))
[09:32:35.133]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:35.133]         }, condition = base::local({
[09:32:35.133]             c <- base::c
[09:32:35.133]             inherits <- base::inherits
[09:32:35.133]             invokeRestart <- base::invokeRestart
[09:32:35.133]             length <- base::length
[09:32:35.133]             list <- base::list
[09:32:35.133]             seq.int <- base::seq.int
[09:32:35.133]             signalCondition <- base::signalCondition
[09:32:35.133]             sys.calls <- base::sys.calls
[09:32:35.133]             `[[` <- base::`[[`
[09:32:35.133]             `+` <- base::`+`
[09:32:35.133]             `<<-` <- base::`<<-`
[09:32:35.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:35.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:35.133]                   3L)]
[09:32:35.133]             }
[09:32:35.133]             function(cond) {
[09:32:35.133]                 is_error <- inherits(cond, "error")
[09:32:35.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:35.133]                   NULL)
[09:32:35.133]                 if (is_error) {
[09:32:35.133]                   sessionInformation <- function() {
[09:32:35.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:35.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:35.133]                       search = base::search(), system = base::Sys.info())
[09:32:35.133]                   }
[09:32:35.133]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:35.133]                     cond$call), session = sessionInformation(), 
[09:32:35.133]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:35.133]                   signalCondition(cond)
[09:32:35.133]                 }
[09:32:35.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:35.133]                 "immediateCondition"))) {
[09:32:35.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:35.133]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:35.133]                   if (TRUE && !signal) {
[09:32:35.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.133]                     {
[09:32:35.133]                       inherits <- base::inherits
[09:32:35.133]                       invokeRestart <- base::invokeRestart
[09:32:35.133]                       is.null <- base::is.null
[09:32:35.133]                       muffled <- FALSE
[09:32:35.133]                       if (inherits(cond, "message")) {
[09:32:35.133]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.133]                         if (muffled) 
[09:32:35.133]                           invokeRestart("muffleMessage")
[09:32:35.133]                       }
[09:32:35.133]                       else if (inherits(cond, "warning")) {
[09:32:35.133]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.133]                         if (muffled) 
[09:32:35.133]                           invokeRestart("muffleWarning")
[09:32:35.133]                       }
[09:32:35.133]                       else if (inherits(cond, "condition")) {
[09:32:35.133]                         if (!is.null(pattern)) {
[09:32:35.133]                           computeRestarts <- base::computeRestarts
[09:32:35.133]                           grepl <- base::grepl
[09:32:35.133]                           restarts <- computeRestarts(cond)
[09:32:35.133]                           for (restart in restarts) {
[09:32:35.133]                             name <- restart$name
[09:32:35.133]                             if (is.null(name)) 
[09:32:35.133]                               next
[09:32:35.133]                             if (!grepl(pattern, name)) 
[09:32:35.133]                               next
[09:32:35.133]                             invokeRestart(restart)
[09:32:35.133]                             muffled <- TRUE
[09:32:35.133]                             break
[09:32:35.133]                           }
[09:32:35.133]                         }
[09:32:35.133]                       }
[09:32:35.133]                       invisible(muffled)
[09:32:35.133]                     }
[09:32:35.133]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.133]                   }
[09:32:35.133]                 }
[09:32:35.133]                 else {
[09:32:35.133]                   if (TRUE) {
[09:32:35.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.133]                     {
[09:32:35.133]                       inherits <- base::inherits
[09:32:35.133]                       invokeRestart <- base::invokeRestart
[09:32:35.133]                       is.null <- base::is.null
[09:32:35.133]                       muffled <- FALSE
[09:32:35.133]                       if (inherits(cond, "message")) {
[09:32:35.133]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.133]                         if (muffled) 
[09:32:35.133]                           invokeRestart("muffleMessage")
[09:32:35.133]                       }
[09:32:35.133]                       else if (inherits(cond, "warning")) {
[09:32:35.133]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.133]                         if (muffled) 
[09:32:35.133]                           invokeRestart("muffleWarning")
[09:32:35.133]                       }
[09:32:35.133]                       else if (inherits(cond, "condition")) {
[09:32:35.133]                         if (!is.null(pattern)) {
[09:32:35.133]                           computeRestarts <- base::computeRestarts
[09:32:35.133]                           grepl <- base::grepl
[09:32:35.133]                           restarts <- computeRestarts(cond)
[09:32:35.133]                           for (restart in restarts) {
[09:32:35.133]                             name <- restart$name
[09:32:35.133]                             if (is.null(name)) 
[09:32:35.133]                               next
[09:32:35.133]                             if (!grepl(pattern, name)) 
[09:32:35.133]                               next
[09:32:35.133]                             invokeRestart(restart)
[09:32:35.133]                             muffled <- TRUE
[09:32:35.133]                             break
[09:32:35.133]                           }
[09:32:35.133]                         }
[09:32:35.133]                       }
[09:32:35.133]                       invisible(muffled)
[09:32:35.133]                     }
[09:32:35.133]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.133]                   }
[09:32:35.133]                 }
[09:32:35.133]             }
[09:32:35.133]         }))
[09:32:35.133]     }, error = function(ex) {
[09:32:35.133]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:35.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.133]                 ...future.rng), started = ...future.startTime, 
[09:32:35.133]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:35.133]             version = "1.8"), class = "FutureResult")
[09:32:35.133]     }, finally = {
[09:32:35.133]         if (!identical(...future.workdir, getwd())) 
[09:32:35.133]             setwd(...future.workdir)
[09:32:35.133]         {
[09:32:35.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:35.133]                 ...future.oldOptions$nwarnings <- NULL
[09:32:35.133]             }
[09:32:35.133]             base::options(...future.oldOptions)
[09:32:35.133]             if (.Platform$OS.type == "windows") {
[09:32:35.133]                 old_names <- names(...future.oldEnvVars)
[09:32:35.133]                 envs <- base::Sys.getenv()
[09:32:35.133]                 names <- names(envs)
[09:32:35.133]                 common <- intersect(names, old_names)
[09:32:35.133]                 added <- setdiff(names, old_names)
[09:32:35.133]                 removed <- setdiff(old_names, names)
[09:32:35.133]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:35.133]                   envs[common]]
[09:32:35.133]                 NAMES <- toupper(changed)
[09:32:35.133]                 args <- list()
[09:32:35.133]                 for (kk in seq_along(NAMES)) {
[09:32:35.133]                   name <- changed[[kk]]
[09:32:35.133]                   NAME <- NAMES[[kk]]
[09:32:35.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.133]                     next
[09:32:35.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.133]                 }
[09:32:35.133]                 NAMES <- toupper(added)
[09:32:35.133]                 for (kk in seq_along(NAMES)) {
[09:32:35.133]                   name <- added[[kk]]
[09:32:35.133]                   NAME <- NAMES[[kk]]
[09:32:35.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.133]                     next
[09:32:35.133]                   args[[name]] <- ""
[09:32:35.133]                 }
[09:32:35.133]                 NAMES <- toupper(removed)
[09:32:35.133]                 for (kk in seq_along(NAMES)) {
[09:32:35.133]                   name <- removed[[kk]]
[09:32:35.133]                   NAME <- NAMES[[kk]]
[09:32:35.133]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.133]                     next
[09:32:35.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.133]                 }
[09:32:35.133]                 if (length(args) > 0) 
[09:32:35.133]                   base::do.call(base::Sys.setenv, args = args)
[09:32:35.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:35.133]             }
[09:32:35.133]             else {
[09:32:35.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:35.133]             }
[09:32:35.133]             {
[09:32:35.133]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:35.133]                   0L) {
[09:32:35.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:35.133]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:35.133]                   base::options(opts)
[09:32:35.133]                 }
[09:32:35.133]                 {
[09:32:35.133]                   {
[09:32:35.133]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:35.133]                     NULL
[09:32:35.133]                   }
[09:32:35.133]                   options(future.plan = NULL)
[09:32:35.133]                   if (is.na(NA_character_)) 
[09:32:35.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:35.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:35.133]                     .init = FALSE)
[09:32:35.133]                 }
[09:32:35.133]             }
[09:32:35.133]         }
[09:32:35.133]     })
[09:32:35.133]     if (TRUE) {
[09:32:35.133]         base::sink(type = "output", split = FALSE)
[09:32:35.133]         if (TRUE) {
[09:32:35.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:35.133]         }
[09:32:35.133]         else {
[09:32:35.133]             ...future.result["stdout"] <- base::list(NULL)
[09:32:35.133]         }
[09:32:35.133]         base::close(...future.stdout)
[09:32:35.133]         ...future.stdout <- NULL
[09:32:35.133]     }
[09:32:35.133]     ...future.result$conditions <- ...future.conditions
[09:32:35.133]     ...future.result$finished <- base::Sys.time()
[09:32:35.133]     ...future.result
[09:32:35.133] }
[09:32:35.136] MultisessionFuture started
[09:32:35.137] - Launch lazy future ... done
[09:32:35.137] run() for ‘MultisessionFuture’ ... done
[09:32:35.139] receiveMessageFromWorker() for ClusterFuture ...
[09:32:35.139] - Validating connection of MultisessionFuture
[09:32:35.140] - received message: FutureResult
[09:32:35.140] - Received FutureResult
[09:32:35.140] - Erased future from FutureRegistry
[09:32:35.140] result() for ClusterFuture ...
[09:32:35.140] - result already collected: FutureResult
[09:32:35.140] result() for ClusterFuture ... done
[09:32:35.141] signalConditions() ...
[09:32:35.141]  - include = ‘immediateCondition’
[09:32:35.141]  - exclude = 
[09:32:35.141]  - resignal = FALSE
[09:32:35.141]  - Number of conditions: 1
[09:32:35.141] signalConditions() ... done
[09:32:35.141] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:35.141] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[09:32:35.142] getGlobalsAndPackages() ...
[09:32:35.142] Searching for globals...
[09:32:35.143] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:35.143] Searching for globals ... DONE
[09:32:35.144] Resolving globals: FALSE
[09:32:35.144] 
[09:32:35.144] 
[09:32:35.144] getGlobalsAndPackages() ... DONE
[09:32:35.144] run() for ‘Future’ ...
[09:32:35.144] - state: ‘created’
[09:32:35.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:35.159] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:35.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:35.159]   - Field: ‘node’
[09:32:35.159]   - Field: ‘label’
[09:32:35.159]   - Field: ‘local’
[09:32:35.159]   - Field: ‘owner’
[09:32:35.159]   - Field: ‘envir’
[09:32:35.159]   - Field: ‘workers’
[09:32:35.159]   - Field: ‘packages’
[09:32:35.159]   - Field: ‘gc’
[09:32:35.159]   - Field: ‘conditions’
[09:32:35.160]   - Field: ‘persistent’
[09:32:35.160]   - Field: ‘expr’
[09:32:35.160]   - Field: ‘uuid’
[09:32:35.160]   - Field: ‘seed’
[09:32:35.160]   - Field: ‘version’
[09:32:35.160]   - Field: ‘result’
[09:32:35.160]   - Field: ‘asynchronous’
[09:32:35.160]   - Field: ‘calls’
[09:32:35.160]   - Field: ‘globals’
[09:32:35.160]   - Field: ‘stdout’
[09:32:35.160]   - Field: ‘earlySignal’
[09:32:35.161]   - Field: ‘lazy’
[09:32:35.161]   - Field: ‘state’
[09:32:35.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:35.161] - Launch lazy future ...
[09:32:35.161] Packages needed by the future expression (n = 0): <none>
[09:32:35.161] Packages needed by future strategies (n = 0): <none>
[09:32:35.162] {
[09:32:35.162]     {
[09:32:35.162]         {
[09:32:35.162]             ...future.startTime <- base::Sys.time()
[09:32:35.162]             {
[09:32:35.162]                 {
[09:32:35.162]                   {
[09:32:35.162]                     {
[09:32:35.162]                       base::local({
[09:32:35.162]                         has_future <- base::requireNamespace("future", 
[09:32:35.162]                           quietly = TRUE)
[09:32:35.162]                         if (has_future) {
[09:32:35.162]                           ns <- base::getNamespace("future")
[09:32:35.162]                           version <- ns[[".package"]][["version"]]
[09:32:35.162]                           if (is.null(version)) 
[09:32:35.162]                             version <- utils::packageVersion("future")
[09:32:35.162]                         }
[09:32:35.162]                         else {
[09:32:35.162]                           version <- NULL
[09:32:35.162]                         }
[09:32:35.162]                         if (!has_future || version < "1.8.0") {
[09:32:35.162]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:35.162]                             "", base::R.version$version.string), 
[09:32:35.162]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:35.162]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:35.162]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:35.162]                               "release", "version")], collapse = " "), 
[09:32:35.162]                             hostname = base::Sys.info()[["nodename"]])
[09:32:35.162]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:35.162]                             info)
[09:32:35.162]                           info <- base::paste(info, collapse = "; ")
[09:32:35.162]                           if (!has_future) {
[09:32:35.162]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:35.162]                               info)
[09:32:35.162]                           }
[09:32:35.162]                           else {
[09:32:35.162]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:35.162]                               info, version)
[09:32:35.162]                           }
[09:32:35.162]                           base::stop(msg)
[09:32:35.162]                         }
[09:32:35.162]                       })
[09:32:35.162]                     }
[09:32:35.162]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:35.162]                     base::options(mc.cores = 1L)
[09:32:35.162]                   }
[09:32:35.162]                   ...future.strategy.old <- future::plan("list")
[09:32:35.162]                   options(future.plan = NULL)
[09:32:35.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:35.162]                 }
[09:32:35.162]                 ...future.workdir <- getwd()
[09:32:35.162]             }
[09:32:35.162]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:35.162]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:35.162]         }
[09:32:35.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:35.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:35.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:35.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:35.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:35.162]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:35.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:35.162]             base::names(...future.oldOptions))
[09:32:35.162]     }
[09:32:35.162]     if (FALSE) {
[09:32:35.162]     }
[09:32:35.162]     else {
[09:32:35.162]         if (TRUE) {
[09:32:35.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:35.162]                 open = "w")
[09:32:35.162]         }
[09:32:35.162]         else {
[09:32:35.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:35.162]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:35.162]         }
[09:32:35.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:35.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:35.162]             base::sink(type = "output", split = FALSE)
[09:32:35.162]             base::close(...future.stdout)
[09:32:35.162]         }, add = TRUE)
[09:32:35.162]     }
[09:32:35.162]     ...future.frame <- base::sys.nframe()
[09:32:35.162]     ...future.conditions <- base::list()
[09:32:35.162]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:35.162]     if (FALSE) {
[09:32:35.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:35.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:35.162]     }
[09:32:35.162]     ...future.result <- base::tryCatch({
[09:32:35.162]         base::withCallingHandlers({
[09:32:35.162]             ...future.value <- base::withVisible(base::local({
[09:32:35.162]                 ...future.makeSendCondition <- base::local({
[09:32:35.162]                   sendCondition <- NULL
[09:32:35.162]                   function(frame = 1L) {
[09:32:35.162]                     if (is.function(sendCondition)) 
[09:32:35.162]                       return(sendCondition)
[09:32:35.162]                     ns <- getNamespace("parallel")
[09:32:35.162]                     if (exists("sendData", mode = "function", 
[09:32:35.162]                       envir = ns)) {
[09:32:35.162]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:35.162]                         envir = ns)
[09:32:35.162]                       envir <- sys.frame(frame)
[09:32:35.162]                       master <- NULL
[09:32:35.162]                       while (!identical(envir, .GlobalEnv) && 
[09:32:35.162]                         !identical(envir, emptyenv())) {
[09:32:35.162]                         if (exists("master", mode = "list", envir = envir, 
[09:32:35.162]                           inherits = FALSE)) {
[09:32:35.162]                           master <- get("master", mode = "list", 
[09:32:35.162]                             envir = envir, inherits = FALSE)
[09:32:35.162]                           if (inherits(master, c("SOCKnode", 
[09:32:35.162]                             "SOCK0node"))) {
[09:32:35.162]                             sendCondition <<- function(cond) {
[09:32:35.162]                               data <- list(type = "VALUE", value = cond, 
[09:32:35.162]                                 success = TRUE)
[09:32:35.162]                               parallel_sendData(master, data)
[09:32:35.162]                             }
[09:32:35.162]                             return(sendCondition)
[09:32:35.162]                           }
[09:32:35.162]                         }
[09:32:35.162]                         frame <- frame + 1L
[09:32:35.162]                         envir <- sys.frame(frame)
[09:32:35.162]                       }
[09:32:35.162]                     }
[09:32:35.162]                     sendCondition <<- function(cond) NULL
[09:32:35.162]                   }
[09:32:35.162]                 })
[09:32:35.162]                 withCallingHandlers({
[09:32:35.162]                   {
[09:32:35.162]                     Sys.sleep(0.5)
[09:32:35.162]                     list(a = 1, b = 42L)
[09:32:35.162]                   }
[09:32:35.162]                 }, immediateCondition = function(cond) {
[09:32:35.162]                   sendCondition <- ...future.makeSendCondition()
[09:32:35.162]                   sendCondition(cond)
[09:32:35.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.162]                   {
[09:32:35.162]                     inherits <- base::inherits
[09:32:35.162]                     invokeRestart <- base::invokeRestart
[09:32:35.162]                     is.null <- base::is.null
[09:32:35.162]                     muffled <- FALSE
[09:32:35.162]                     if (inherits(cond, "message")) {
[09:32:35.162]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:35.162]                       if (muffled) 
[09:32:35.162]                         invokeRestart("muffleMessage")
[09:32:35.162]                     }
[09:32:35.162]                     else if (inherits(cond, "warning")) {
[09:32:35.162]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:35.162]                       if (muffled) 
[09:32:35.162]                         invokeRestart("muffleWarning")
[09:32:35.162]                     }
[09:32:35.162]                     else if (inherits(cond, "condition")) {
[09:32:35.162]                       if (!is.null(pattern)) {
[09:32:35.162]                         computeRestarts <- base::computeRestarts
[09:32:35.162]                         grepl <- base::grepl
[09:32:35.162]                         restarts <- computeRestarts(cond)
[09:32:35.162]                         for (restart in restarts) {
[09:32:35.162]                           name <- restart$name
[09:32:35.162]                           if (is.null(name)) 
[09:32:35.162]                             next
[09:32:35.162]                           if (!grepl(pattern, name)) 
[09:32:35.162]                             next
[09:32:35.162]                           invokeRestart(restart)
[09:32:35.162]                           muffled <- TRUE
[09:32:35.162]                           break
[09:32:35.162]                         }
[09:32:35.162]                       }
[09:32:35.162]                     }
[09:32:35.162]                     invisible(muffled)
[09:32:35.162]                   }
[09:32:35.162]                   muffleCondition(cond)
[09:32:35.162]                 })
[09:32:35.162]             }))
[09:32:35.162]             future::FutureResult(value = ...future.value$value, 
[09:32:35.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.162]                   ...future.rng), globalenv = if (FALSE) 
[09:32:35.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:35.162]                     ...future.globalenv.names))
[09:32:35.162]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:35.162]         }, condition = base::local({
[09:32:35.162]             c <- base::c
[09:32:35.162]             inherits <- base::inherits
[09:32:35.162]             invokeRestart <- base::invokeRestart
[09:32:35.162]             length <- base::length
[09:32:35.162]             list <- base::list
[09:32:35.162]             seq.int <- base::seq.int
[09:32:35.162]             signalCondition <- base::signalCondition
[09:32:35.162]             sys.calls <- base::sys.calls
[09:32:35.162]             `[[` <- base::`[[`
[09:32:35.162]             `+` <- base::`+`
[09:32:35.162]             `<<-` <- base::`<<-`
[09:32:35.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:35.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:35.162]                   3L)]
[09:32:35.162]             }
[09:32:35.162]             function(cond) {
[09:32:35.162]                 is_error <- inherits(cond, "error")
[09:32:35.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:35.162]                   NULL)
[09:32:35.162]                 if (is_error) {
[09:32:35.162]                   sessionInformation <- function() {
[09:32:35.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:35.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:35.162]                       search = base::search(), system = base::Sys.info())
[09:32:35.162]                   }
[09:32:35.162]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:35.162]                     cond$call), session = sessionInformation(), 
[09:32:35.162]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:35.162]                   signalCondition(cond)
[09:32:35.162]                 }
[09:32:35.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:35.162]                 "immediateCondition"))) {
[09:32:35.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:35.162]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:35.162]                   if (TRUE && !signal) {
[09:32:35.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.162]                     {
[09:32:35.162]                       inherits <- base::inherits
[09:32:35.162]                       invokeRestart <- base::invokeRestart
[09:32:35.162]                       is.null <- base::is.null
[09:32:35.162]                       muffled <- FALSE
[09:32:35.162]                       if (inherits(cond, "message")) {
[09:32:35.162]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.162]                         if (muffled) 
[09:32:35.162]                           invokeRestart("muffleMessage")
[09:32:35.162]                       }
[09:32:35.162]                       else if (inherits(cond, "warning")) {
[09:32:35.162]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.162]                         if (muffled) 
[09:32:35.162]                           invokeRestart("muffleWarning")
[09:32:35.162]                       }
[09:32:35.162]                       else if (inherits(cond, "condition")) {
[09:32:35.162]                         if (!is.null(pattern)) {
[09:32:35.162]                           computeRestarts <- base::computeRestarts
[09:32:35.162]                           grepl <- base::grepl
[09:32:35.162]                           restarts <- computeRestarts(cond)
[09:32:35.162]                           for (restart in restarts) {
[09:32:35.162]                             name <- restart$name
[09:32:35.162]                             if (is.null(name)) 
[09:32:35.162]                               next
[09:32:35.162]                             if (!grepl(pattern, name)) 
[09:32:35.162]                               next
[09:32:35.162]                             invokeRestart(restart)
[09:32:35.162]                             muffled <- TRUE
[09:32:35.162]                             break
[09:32:35.162]                           }
[09:32:35.162]                         }
[09:32:35.162]                       }
[09:32:35.162]                       invisible(muffled)
[09:32:35.162]                     }
[09:32:35.162]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.162]                   }
[09:32:35.162]                 }
[09:32:35.162]                 else {
[09:32:35.162]                   if (TRUE) {
[09:32:35.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.162]                     {
[09:32:35.162]                       inherits <- base::inherits
[09:32:35.162]                       invokeRestart <- base::invokeRestart
[09:32:35.162]                       is.null <- base::is.null
[09:32:35.162]                       muffled <- FALSE
[09:32:35.162]                       if (inherits(cond, "message")) {
[09:32:35.162]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.162]                         if (muffled) 
[09:32:35.162]                           invokeRestart("muffleMessage")
[09:32:35.162]                       }
[09:32:35.162]                       else if (inherits(cond, "warning")) {
[09:32:35.162]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.162]                         if (muffled) 
[09:32:35.162]                           invokeRestart("muffleWarning")
[09:32:35.162]                       }
[09:32:35.162]                       else if (inherits(cond, "condition")) {
[09:32:35.162]                         if (!is.null(pattern)) {
[09:32:35.162]                           computeRestarts <- base::computeRestarts
[09:32:35.162]                           grepl <- base::grepl
[09:32:35.162]                           restarts <- computeRestarts(cond)
[09:32:35.162]                           for (restart in restarts) {
[09:32:35.162]                             name <- restart$name
[09:32:35.162]                             if (is.null(name)) 
[09:32:35.162]                               next
[09:32:35.162]                             if (!grepl(pattern, name)) 
[09:32:35.162]                               next
[09:32:35.162]                             invokeRestart(restart)
[09:32:35.162]                             muffled <- TRUE
[09:32:35.162]                             break
[09:32:35.162]                           }
[09:32:35.162]                         }
[09:32:35.162]                       }
[09:32:35.162]                       invisible(muffled)
[09:32:35.162]                     }
[09:32:35.162]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.162]                   }
[09:32:35.162]                 }
[09:32:35.162]             }
[09:32:35.162]         }))
[09:32:35.162]     }, error = function(ex) {
[09:32:35.162]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:35.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.162]                 ...future.rng), started = ...future.startTime, 
[09:32:35.162]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:35.162]             version = "1.8"), class = "FutureResult")
[09:32:35.162]     }, finally = {
[09:32:35.162]         if (!identical(...future.workdir, getwd())) 
[09:32:35.162]             setwd(...future.workdir)
[09:32:35.162]         {
[09:32:35.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:35.162]                 ...future.oldOptions$nwarnings <- NULL
[09:32:35.162]             }
[09:32:35.162]             base::options(...future.oldOptions)
[09:32:35.162]             if (.Platform$OS.type == "windows") {
[09:32:35.162]                 old_names <- names(...future.oldEnvVars)
[09:32:35.162]                 envs <- base::Sys.getenv()
[09:32:35.162]                 names <- names(envs)
[09:32:35.162]                 common <- intersect(names, old_names)
[09:32:35.162]                 added <- setdiff(names, old_names)
[09:32:35.162]                 removed <- setdiff(old_names, names)
[09:32:35.162]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:35.162]                   envs[common]]
[09:32:35.162]                 NAMES <- toupper(changed)
[09:32:35.162]                 args <- list()
[09:32:35.162]                 for (kk in seq_along(NAMES)) {
[09:32:35.162]                   name <- changed[[kk]]
[09:32:35.162]                   NAME <- NAMES[[kk]]
[09:32:35.162]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.162]                     next
[09:32:35.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.162]                 }
[09:32:35.162]                 NAMES <- toupper(added)
[09:32:35.162]                 for (kk in seq_along(NAMES)) {
[09:32:35.162]                   name <- added[[kk]]
[09:32:35.162]                   NAME <- NAMES[[kk]]
[09:32:35.162]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.162]                     next
[09:32:35.162]                   args[[name]] <- ""
[09:32:35.162]                 }
[09:32:35.162]                 NAMES <- toupper(removed)
[09:32:35.162]                 for (kk in seq_along(NAMES)) {
[09:32:35.162]                   name <- removed[[kk]]
[09:32:35.162]                   NAME <- NAMES[[kk]]
[09:32:35.162]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.162]                     next
[09:32:35.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.162]                 }
[09:32:35.162]                 if (length(args) > 0) 
[09:32:35.162]                   base::do.call(base::Sys.setenv, args = args)
[09:32:35.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:35.162]             }
[09:32:35.162]             else {
[09:32:35.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:35.162]             }
[09:32:35.162]             {
[09:32:35.162]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:35.162]                   0L) {
[09:32:35.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:35.162]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:35.162]                   base::options(opts)
[09:32:35.162]                 }
[09:32:35.162]                 {
[09:32:35.162]                   {
[09:32:35.162]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:35.162]                     NULL
[09:32:35.162]                   }
[09:32:35.162]                   options(future.plan = NULL)
[09:32:35.162]                   if (is.na(NA_character_)) 
[09:32:35.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:35.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:35.162]                     .init = FALSE)
[09:32:35.162]                 }
[09:32:35.162]             }
[09:32:35.162]         }
[09:32:35.162]     })
[09:32:35.162]     if (TRUE) {
[09:32:35.162]         base::sink(type = "output", split = FALSE)
[09:32:35.162]         if (TRUE) {
[09:32:35.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:35.162]         }
[09:32:35.162]         else {
[09:32:35.162]             ...future.result["stdout"] <- base::list(NULL)
[09:32:35.162]         }
[09:32:35.162]         base::close(...future.stdout)
[09:32:35.162]         ...future.stdout <- NULL
[09:32:35.162]     }
[09:32:35.162]     ...future.result$conditions <- ...future.conditions
[09:32:35.162]     ...future.result$finished <- base::Sys.time()
[09:32:35.162]     ...future.result
[09:32:35.162] }
[09:32:35.165] MultisessionFuture started
[09:32:35.165] - Launch lazy future ... done
[09:32:35.165] run() for ‘MultisessionFuture’ ... done
[09:32:35.667] receiveMessageFromWorker() for ClusterFuture ...
[09:32:35.668] - Validating connection of MultisessionFuture
[09:32:35.668] - received message: FutureResult
[09:32:35.668] - Received FutureResult
[09:32:35.668] - Erased future from FutureRegistry
[09:32:35.668] result() for ClusterFuture ...
[09:32:35.669] - result already collected: FutureResult
[09:32:35.669] result() for ClusterFuture ... done
[09:32:35.669] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:35.669] resolve() on list ...
[09:32:35.669]  recursive: Inf
[09:32:35.669]  length: 2
[09:32:35.669]  elements: ‘a’, ‘b’
[09:32:35.669]  length: 1 (resolved future 1)
[09:32:35.669]  length: 0 (resolved future 2)
[09:32:35.669] resolve() on list ... DONE
[09:32:35.669] A MultisessionFuture was resolved (and resolved itself)
[09:32:35.670] getGlobalsAndPackages() ...
[09:32:35.670] Searching for globals...
[09:32:35.671] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[09:32:35.671] Searching for globals ... DONE
[09:32:35.671] Resolving globals: FALSE
[09:32:35.671] 
[09:32:35.671] 
[09:32:35.672] getGlobalsAndPackages() ... DONE
[09:32:35.672] run() for ‘Future’ ...
[09:32:35.672] - state: ‘created’
[09:32:35.672] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:35.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:35.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:35.688]   - Field: ‘node’
[09:32:35.688]   - Field: ‘label’
[09:32:35.688]   - Field: ‘local’
[09:32:35.688]   - Field: ‘owner’
[09:32:35.688]   - Field: ‘envir’
[09:32:35.688]   - Field: ‘workers’
[09:32:35.688]   - Field: ‘packages’
[09:32:35.688]   - Field: ‘gc’
[09:32:35.688]   - Field: ‘conditions’
[09:32:35.688]   - Field: ‘persistent’
[09:32:35.689]   - Field: ‘expr’
[09:32:35.689]   - Field: ‘uuid’
[09:32:35.689]   - Field: ‘seed’
[09:32:35.689]   - Field: ‘version’
[09:32:35.689]   - Field: ‘result’
[09:32:35.689]   - Field: ‘asynchronous’
[09:32:35.689]   - Field: ‘calls’
[09:32:35.689]   - Field: ‘globals’
[09:32:35.689]   - Field: ‘stdout’
[09:32:35.689]   - Field: ‘earlySignal’
[09:32:35.689]   - Field: ‘lazy’
[09:32:35.689]   - Field: ‘state’
[09:32:35.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:35.690] - Launch lazy future ...
[09:32:35.690] Packages needed by the future expression (n = 0): <none>
[09:32:35.690] Packages needed by future strategies (n = 0): <none>
[09:32:35.690] {
[09:32:35.690]     {
[09:32:35.690]         {
[09:32:35.690]             ...future.startTime <- base::Sys.time()
[09:32:35.690]             {
[09:32:35.690]                 {
[09:32:35.690]                   {
[09:32:35.690]                     {
[09:32:35.690]                       base::local({
[09:32:35.690]                         has_future <- base::requireNamespace("future", 
[09:32:35.690]                           quietly = TRUE)
[09:32:35.690]                         if (has_future) {
[09:32:35.690]                           ns <- base::getNamespace("future")
[09:32:35.690]                           version <- ns[[".package"]][["version"]]
[09:32:35.690]                           if (is.null(version)) 
[09:32:35.690]                             version <- utils::packageVersion("future")
[09:32:35.690]                         }
[09:32:35.690]                         else {
[09:32:35.690]                           version <- NULL
[09:32:35.690]                         }
[09:32:35.690]                         if (!has_future || version < "1.8.0") {
[09:32:35.690]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:35.690]                             "", base::R.version$version.string), 
[09:32:35.690]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:35.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:35.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:35.690]                               "release", "version")], collapse = " "), 
[09:32:35.690]                             hostname = base::Sys.info()[["nodename"]])
[09:32:35.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:35.690]                             info)
[09:32:35.690]                           info <- base::paste(info, collapse = "; ")
[09:32:35.690]                           if (!has_future) {
[09:32:35.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:35.690]                               info)
[09:32:35.690]                           }
[09:32:35.690]                           else {
[09:32:35.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:35.690]                               info, version)
[09:32:35.690]                           }
[09:32:35.690]                           base::stop(msg)
[09:32:35.690]                         }
[09:32:35.690]                       })
[09:32:35.690]                     }
[09:32:35.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:35.690]                     base::options(mc.cores = 1L)
[09:32:35.690]                   }
[09:32:35.690]                   ...future.strategy.old <- future::plan("list")
[09:32:35.690]                   options(future.plan = NULL)
[09:32:35.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:35.690]                 }
[09:32:35.690]                 ...future.workdir <- getwd()
[09:32:35.690]             }
[09:32:35.690]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:35.690]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:35.690]         }
[09:32:35.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:35.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:35.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:35.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:35.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:35.690]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:35.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:35.690]             base::names(...future.oldOptions))
[09:32:35.690]     }
[09:32:35.690]     if (FALSE) {
[09:32:35.690]     }
[09:32:35.690]     else {
[09:32:35.690]         if (TRUE) {
[09:32:35.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:35.690]                 open = "w")
[09:32:35.690]         }
[09:32:35.690]         else {
[09:32:35.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:35.690]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:35.690]         }
[09:32:35.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:35.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:35.690]             base::sink(type = "output", split = FALSE)
[09:32:35.690]             base::close(...future.stdout)
[09:32:35.690]         }, add = TRUE)
[09:32:35.690]     }
[09:32:35.690]     ...future.frame <- base::sys.nframe()
[09:32:35.690]     ...future.conditions <- base::list()
[09:32:35.690]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:35.690]     if (FALSE) {
[09:32:35.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:35.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:35.690]     }
[09:32:35.690]     ...future.result <- base::tryCatch({
[09:32:35.690]         base::withCallingHandlers({
[09:32:35.690]             ...future.value <- base::withVisible(base::local({
[09:32:35.690]                 ...future.makeSendCondition <- base::local({
[09:32:35.690]                   sendCondition <- NULL
[09:32:35.690]                   function(frame = 1L) {
[09:32:35.690]                     if (is.function(sendCondition)) 
[09:32:35.690]                       return(sendCondition)
[09:32:35.690]                     ns <- getNamespace("parallel")
[09:32:35.690]                     if (exists("sendData", mode = "function", 
[09:32:35.690]                       envir = ns)) {
[09:32:35.690]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:35.690]                         envir = ns)
[09:32:35.690]                       envir <- sys.frame(frame)
[09:32:35.690]                       master <- NULL
[09:32:35.690]                       while (!identical(envir, .GlobalEnv) && 
[09:32:35.690]                         !identical(envir, emptyenv())) {
[09:32:35.690]                         if (exists("master", mode = "list", envir = envir, 
[09:32:35.690]                           inherits = FALSE)) {
[09:32:35.690]                           master <- get("master", mode = "list", 
[09:32:35.690]                             envir = envir, inherits = FALSE)
[09:32:35.690]                           if (inherits(master, c("SOCKnode", 
[09:32:35.690]                             "SOCK0node"))) {
[09:32:35.690]                             sendCondition <<- function(cond) {
[09:32:35.690]                               data <- list(type = "VALUE", value = cond, 
[09:32:35.690]                                 success = TRUE)
[09:32:35.690]                               parallel_sendData(master, data)
[09:32:35.690]                             }
[09:32:35.690]                             return(sendCondition)
[09:32:35.690]                           }
[09:32:35.690]                         }
[09:32:35.690]                         frame <- frame + 1L
[09:32:35.690]                         envir <- sys.frame(frame)
[09:32:35.690]                       }
[09:32:35.690]                     }
[09:32:35.690]                     sendCondition <<- function(cond) NULL
[09:32:35.690]                   }
[09:32:35.690]                 })
[09:32:35.690]                 withCallingHandlers({
[09:32:35.690]                   {
[09:32:35.690]                     Sys.sleep(0.5)
[09:32:35.690]                     list(a = 1, b = 42L)
[09:32:35.690]                   }
[09:32:35.690]                 }, immediateCondition = function(cond) {
[09:32:35.690]                   sendCondition <- ...future.makeSendCondition()
[09:32:35.690]                   sendCondition(cond)
[09:32:35.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.690]                   {
[09:32:35.690]                     inherits <- base::inherits
[09:32:35.690]                     invokeRestart <- base::invokeRestart
[09:32:35.690]                     is.null <- base::is.null
[09:32:35.690]                     muffled <- FALSE
[09:32:35.690]                     if (inherits(cond, "message")) {
[09:32:35.690]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:35.690]                       if (muffled) 
[09:32:35.690]                         invokeRestart("muffleMessage")
[09:32:35.690]                     }
[09:32:35.690]                     else if (inherits(cond, "warning")) {
[09:32:35.690]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:35.690]                       if (muffled) 
[09:32:35.690]                         invokeRestart("muffleWarning")
[09:32:35.690]                     }
[09:32:35.690]                     else if (inherits(cond, "condition")) {
[09:32:35.690]                       if (!is.null(pattern)) {
[09:32:35.690]                         computeRestarts <- base::computeRestarts
[09:32:35.690]                         grepl <- base::grepl
[09:32:35.690]                         restarts <- computeRestarts(cond)
[09:32:35.690]                         for (restart in restarts) {
[09:32:35.690]                           name <- restart$name
[09:32:35.690]                           if (is.null(name)) 
[09:32:35.690]                             next
[09:32:35.690]                           if (!grepl(pattern, name)) 
[09:32:35.690]                             next
[09:32:35.690]                           invokeRestart(restart)
[09:32:35.690]                           muffled <- TRUE
[09:32:35.690]                           break
[09:32:35.690]                         }
[09:32:35.690]                       }
[09:32:35.690]                     }
[09:32:35.690]                     invisible(muffled)
[09:32:35.690]                   }
[09:32:35.690]                   muffleCondition(cond)
[09:32:35.690]                 })
[09:32:35.690]             }))
[09:32:35.690]             future::FutureResult(value = ...future.value$value, 
[09:32:35.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.690]                   ...future.rng), globalenv = if (FALSE) 
[09:32:35.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:35.690]                     ...future.globalenv.names))
[09:32:35.690]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:35.690]         }, condition = base::local({
[09:32:35.690]             c <- base::c
[09:32:35.690]             inherits <- base::inherits
[09:32:35.690]             invokeRestart <- base::invokeRestart
[09:32:35.690]             length <- base::length
[09:32:35.690]             list <- base::list
[09:32:35.690]             seq.int <- base::seq.int
[09:32:35.690]             signalCondition <- base::signalCondition
[09:32:35.690]             sys.calls <- base::sys.calls
[09:32:35.690]             `[[` <- base::`[[`
[09:32:35.690]             `+` <- base::`+`
[09:32:35.690]             `<<-` <- base::`<<-`
[09:32:35.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:35.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:35.690]                   3L)]
[09:32:35.690]             }
[09:32:35.690]             function(cond) {
[09:32:35.690]                 is_error <- inherits(cond, "error")
[09:32:35.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:35.690]                   NULL)
[09:32:35.690]                 if (is_error) {
[09:32:35.690]                   sessionInformation <- function() {
[09:32:35.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:35.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:35.690]                       search = base::search(), system = base::Sys.info())
[09:32:35.690]                   }
[09:32:35.690]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:35.690]                     cond$call), session = sessionInformation(), 
[09:32:35.690]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:35.690]                   signalCondition(cond)
[09:32:35.690]                 }
[09:32:35.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:35.690]                 "immediateCondition"))) {
[09:32:35.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:35.690]                   ...future.conditions[[length(...future.conditions) + 
[09:32:35.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:35.690]                   if (TRUE && !signal) {
[09:32:35.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.690]                     {
[09:32:35.690]                       inherits <- base::inherits
[09:32:35.690]                       invokeRestart <- base::invokeRestart
[09:32:35.690]                       is.null <- base::is.null
[09:32:35.690]                       muffled <- FALSE
[09:32:35.690]                       if (inherits(cond, "message")) {
[09:32:35.690]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.690]                         if (muffled) 
[09:32:35.690]                           invokeRestart("muffleMessage")
[09:32:35.690]                       }
[09:32:35.690]                       else if (inherits(cond, "warning")) {
[09:32:35.690]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.690]                         if (muffled) 
[09:32:35.690]                           invokeRestart("muffleWarning")
[09:32:35.690]                       }
[09:32:35.690]                       else if (inherits(cond, "condition")) {
[09:32:35.690]                         if (!is.null(pattern)) {
[09:32:35.690]                           computeRestarts <- base::computeRestarts
[09:32:35.690]                           grepl <- base::grepl
[09:32:35.690]                           restarts <- computeRestarts(cond)
[09:32:35.690]                           for (restart in restarts) {
[09:32:35.690]                             name <- restart$name
[09:32:35.690]                             if (is.null(name)) 
[09:32:35.690]                               next
[09:32:35.690]                             if (!grepl(pattern, name)) 
[09:32:35.690]                               next
[09:32:35.690]                             invokeRestart(restart)
[09:32:35.690]                             muffled <- TRUE
[09:32:35.690]                             break
[09:32:35.690]                           }
[09:32:35.690]                         }
[09:32:35.690]                       }
[09:32:35.690]                       invisible(muffled)
[09:32:35.690]                     }
[09:32:35.690]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.690]                   }
[09:32:35.690]                 }
[09:32:35.690]                 else {
[09:32:35.690]                   if (TRUE) {
[09:32:35.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:35.690]                     {
[09:32:35.690]                       inherits <- base::inherits
[09:32:35.690]                       invokeRestart <- base::invokeRestart
[09:32:35.690]                       is.null <- base::is.null
[09:32:35.690]                       muffled <- FALSE
[09:32:35.690]                       if (inherits(cond, "message")) {
[09:32:35.690]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:35.690]                         if (muffled) 
[09:32:35.690]                           invokeRestart("muffleMessage")
[09:32:35.690]                       }
[09:32:35.690]                       else if (inherits(cond, "warning")) {
[09:32:35.690]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:35.690]                         if (muffled) 
[09:32:35.690]                           invokeRestart("muffleWarning")
[09:32:35.690]                       }
[09:32:35.690]                       else if (inherits(cond, "condition")) {
[09:32:35.690]                         if (!is.null(pattern)) {
[09:32:35.690]                           computeRestarts <- base::computeRestarts
[09:32:35.690]                           grepl <- base::grepl
[09:32:35.690]                           restarts <- computeRestarts(cond)
[09:32:35.690]                           for (restart in restarts) {
[09:32:35.690]                             name <- restart$name
[09:32:35.690]                             if (is.null(name)) 
[09:32:35.690]                               next
[09:32:35.690]                             if (!grepl(pattern, name)) 
[09:32:35.690]                               next
[09:32:35.690]                             invokeRestart(restart)
[09:32:35.690]                             muffled <- TRUE
[09:32:35.690]                             break
[09:32:35.690]                           }
[09:32:35.690]                         }
[09:32:35.690]                       }
[09:32:35.690]                       invisible(muffled)
[09:32:35.690]                     }
[09:32:35.690]                     muffleCondition(cond, pattern = "^muffle")
[09:32:35.690]                   }
[09:32:35.690]                 }
[09:32:35.690]             }
[09:32:35.690]         }))
[09:32:35.690]     }, error = function(ex) {
[09:32:35.690]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:35.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:35.690]                 ...future.rng), started = ...future.startTime, 
[09:32:35.690]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:35.690]             version = "1.8"), class = "FutureResult")
[09:32:35.690]     }, finally = {
[09:32:35.690]         if (!identical(...future.workdir, getwd())) 
[09:32:35.690]             setwd(...future.workdir)
[09:32:35.690]         {
[09:32:35.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:35.690]                 ...future.oldOptions$nwarnings <- NULL
[09:32:35.690]             }
[09:32:35.690]             base::options(...future.oldOptions)
[09:32:35.690]             if (.Platform$OS.type == "windows") {
[09:32:35.690]                 old_names <- names(...future.oldEnvVars)
[09:32:35.690]                 envs <- base::Sys.getenv()
[09:32:35.690]                 names <- names(envs)
[09:32:35.690]                 common <- intersect(names, old_names)
[09:32:35.690]                 added <- setdiff(names, old_names)
[09:32:35.690]                 removed <- setdiff(old_names, names)
[09:32:35.690]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:35.690]                   envs[common]]
[09:32:35.690]                 NAMES <- toupper(changed)
[09:32:35.690]                 args <- list()
[09:32:35.690]                 for (kk in seq_along(NAMES)) {
[09:32:35.690]                   name <- changed[[kk]]
[09:32:35.690]                   NAME <- NAMES[[kk]]
[09:32:35.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.690]                     next
[09:32:35.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.690]                 }
[09:32:35.690]                 NAMES <- toupper(added)
[09:32:35.690]                 for (kk in seq_along(NAMES)) {
[09:32:35.690]                   name <- added[[kk]]
[09:32:35.690]                   NAME <- NAMES[[kk]]
[09:32:35.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.690]                     next
[09:32:35.690]                   args[[name]] <- ""
[09:32:35.690]                 }
[09:32:35.690]                 NAMES <- toupper(removed)
[09:32:35.690]                 for (kk in seq_along(NAMES)) {
[09:32:35.690]                   name <- removed[[kk]]
[09:32:35.690]                   NAME <- NAMES[[kk]]
[09:32:35.690]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:35.690]                     next
[09:32:35.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:35.690]                 }
[09:32:35.690]                 if (length(args) > 0) 
[09:32:35.690]                   base::do.call(base::Sys.setenv, args = args)
[09:32:35.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:35.690]             }
[09:32:35.690]             else {
[09:32:35.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:35.690]             }
[09:32:35.690]             {
[09:32:35.690]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:35.690]                   0L) {
[09:32:35.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:35.690]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:35.690]                   base::options(opts)
[09:32:35.690]                 }
[09:32:35.690]                 {
[09:32:35.690]                   {
[09:32:35.690]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:35.690]                     NULL
[09:32:35.690]                   }
[09:32:35.690]                   options(future.plan = NULL)
[09:32:35.690]                   if (is.na(NA_character_)) 
[09:32:35.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:35.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:35.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:35.690]                     .init = FALSE)
[09:32:35.690]                 }
[09:32:35.690]             }
[09:32:35.690]         }
[09:32:35.690]     })
[09:32:35.690]     if (TRUE) {
[09:32:35.690]         base::sink(type = "output", split = FALSE)
[09:32:35.690]         if (TRUE) {
[09:32:35.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:35.690]         }
[09:32:35.690]         else {
[09:32:35.690]             ...future.result["stdout"] <- base::list(NULL)
[09:32:35.690]         }
[09:32:35.690]         base::close(...future.stdout)
[09:32:35.690]         ...future.stdout <- NULL
[09:32:35.690]     }
[09:32:35.690]     ...future.result$conditions <- ...future.conditions
[09:32:35.690]     ...future.result$finished <- base::Sys.time()
[09:32:35.690]     ...future.result
[09:32:35.690] }
[09:32:35.693] MultisessionFuture started
[09:32:35.694] - Launch lazy future ... done
[09:32:35.694] run() for ‘MultisessionFuture’ ... done
[09:32:36.196] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.196] - Validating connection of MultisessionFuture
[09:32:36.197] - received message: FutureResult
[09:32:36.197] - Received FutureResult
[09:32:36.197] - Erased future from FutureRegistry
[09:32:36.197] result() for ClusterFuture ...
[09:32:36.197] - result already collected: FutureResult
[09:32:36.197] result() for ClusterFuture ... done
[09:32:36.197] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.197] resolve() on list ...
[09:32:36.197]  recursive: Inf
[09:32:36.197]  length: 2
[09:32:36.198]  elements: ‘a’, ‘b’
[09:32:36.198]  length: 1 (resolved future 1)
[09:32:36.198]  length: 0 (resolved future 2)
[09:32:36.198] resolve() on list ... DONE
[09:32:36.198] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[09:32:36.198] getGlobalsAndPackages() ...
[09:32:36.198] Searching for globals...
[09:32:36.199] - globals found: [2] ‘list’, ‘stop’
[09:32:36.199] Searching for globals ... DONE
[09:32:36.199] Resolving globals: FALSE
[09:32:36.199] 
[09:32:36.199] 
[09:32:36.200] getGlobalsAndPackages() ... DONE
[09:32:36.200] run() for ‘Future’ ...
[09:32:36.200] - state: ‘created’
[09:32:36.200] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.214] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.214]   - Field: ‘node’
[09:32:36.214]   - Field: ‘label’
[09:32:36.215]   - Field: ‘local’
[09:32:36.215]   - Field: ‘owner’
[09:32:36.215]   - Field: ‘envir’
[09:32:36.215]   - Field: ‘workers’
[09:32:36.215]   - Field: ‘packages’
[09:32:36.215]   - Field: ‘gc’
[09:32:36.215]   - Field: ‘conditions’
[09:32:36.215]   - Field: ‘persistent’
[09:32:36.215]   - Field: ‘expr’
[09:32:36.215]   - Field: ‘uuid’
[09:32:36.215]   - Field: ‘seed’
[09:32:36.216]   - Field: ‘version’
[09:32:36.216]   - Field: ‘result’
[09:32:36.216]   - Field: ‘asynchronous’
[09:32:36.216]   - Field: ‘calls’
[09:32:36.216]   - Field: ‘globals’
[09:32:36.216]   - Field: ‘stdout’
[09:32:36.216]   - Field: ‘earlySignal’
[09:32:36.216]   - Field: ‘lazy’
[09:32:36.216]   - Field: ‘state’
[09:32:36.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.217] - Launch lazy future ...
[09:32:36.217] Packages needed by the future expression (n = 0): <none>
[09:32:36.217] Packages needed by future strategies (n = 0): <none>
[09:32:36.217] {
[09:32:36.217]     {
[09:32:36.217]         {
[09:32:36.217]             ...future.startTime <- base::Sys.time()
[09:32:36.217]             {
[09:32:36.217]                 {
[09:32:36.217]                   {
[09:32:36.217]                     {
[09:32:36.217]                       base::local({
[09:32:36.217]                         has_future <- base::requireNamespace("future", 
[09:32:36.217]                           quietly = TRUE)
[09:32:36.217]                         if (has_future) {
[09:32:36.217]                           ns <- base::getNamespace("future")
[09:32:36.217]                           version <- ns[[".package"]][["version"]]
[09:32:36.217]                           if (is.null(version)) 
[09:32:36.217]                             version <- utils::packageVersion("future")
[09:32:36.217]                         }
[09:32:36.217]                         else {
[09:32:36.217]                           version <- NULL
[09:32:36.217]                         }
[09:32:36.217]                         if (!has_future || version < "1.8.0") {
[09:32:36.217]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.217]                             "", base::R.version$version.string), 
[09:32:36.217]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.217]                               "release", "version")], collapse = " "), 
[09:32:36.217]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.217]                             info)
[09:32:36.217]                           info <- base::paste(info, collapse = "; ")
[09:32:36.217]                           if (!has_future) {
[09:32:36.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.217]                               info)
[09:32:36.217]                           }
[09:32:36.217]                           else {
[09:32:36.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.217]                               info, version)
[09:32:36.217]                           }
[09:32:36.217]                           base::stop(msg)
[09:32:36.217]                         }
[09:32:36.217]                       })
[09:32:36.217]                     }
[09:32:36.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.217]                     base::options(mc.cores = 1L)
[09:32:36.217]                   }
[09:32:36.217]                   ...future.strategy.old <- future::plan("list")
[09:32:36.217]                   options(future.plan = NULL)
[09:32:36.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.217]                 }
[09:32:36.217]                 ...future.workdir <- getwd()
[09:32:36.217]             }
[09:32:36.217]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.217]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.217]         }
[09:32:36.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.217]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.217]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.217]             base::names(...future.oldOptions))
[09:32:36.217]     }
[09:32:36.217]     if (FALSE) {
[09:32:36.217]     }
[09:32:36.217]     else {
[09:32:36.217]         if (TRUE) {
[09:32:36.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.217]                 open = "w")
[09:32:36.217]         }
[09:32:36.217]         else {
[09:32:36.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.217]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.217]         }
[09:32:36.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.217]             base::sink(type = "output", split = FALSE)
[09:32:36.217]             base::close(...future.stdout)
[09:32:36.217]         }, add = TRUE)
[09:32:36.217]     }
[09:32:36.217]     ...future.frame <- base::sys.nframe()
[09:32:36.217]     ...future.conditions <- base::list()
[09:32:36.217]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.217]     if (FALSE) {
[09:32:36.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.217]     }
[09:32:36.217]     ...future.result <- base::tryCatch({
[09:32:36.217]         base::withCallingHandlers({
[09:32:36.217]             ...future.value <- base::withVisible(base::local({
[09:32:36.217]                 ...future.makeSendCondition <- base::local({
[09:32:36.217]                   sendCondition <- NULL
[09:32:36.217]                   function(frame = 1L) {
[09:32:36.217]                     if (is.function(sendCondition)) 
[09:32:36.217]                       return(sendCondition)
[09:32:36.217]                     ns <- getNamespace("parallel")
[09:32:36.217]                     if (exists("sendData", mode = "function", 
[09:32:36.217]                       envir = ns)) {
[09:32:36.217]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.217]                         envir = ns)
[09:32:36.217]                       envir <- sys.frame(frame)
[09:32:36.217]                       master <- NULL
[09:32:36.217]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.217]                         !identical(envir, emptyenv())) {
[09:32:36.217]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.217]                           inherits = FALSE)) {
[09:32:36.217]                           master <- get("master", mode = "list", 
[09:32:36.217]                             envir = envir, inherits = FALSE)
[09:32:36.217]                           if (inherits(master, c("SOCKnode", 
[09:32:36.217]                             "SOCK0node"))) {
[09:32:36.217]                             sendCondition <<- function(cond) {
[09:32:36.217]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.217]                                 success = TRUE)
[09:32:36.217]                               parallel_sendData(master, data)
[09:32:36.217]                             }
[09:32:36.217]                             return(sendCondition)
[09:32:36.217]                           }
[09:32:36.217]                         }
[09:32:36.217]                         frame <- frame + 1L
[09:32:36.217]                         envir <- sys.frame(frame)
[09:32:36.217]                       }
[09:32:36.217]                     }
[09:32:36.217]                     sendCondition <<- function(cond) NULL
[09:32:36.217]                   }
[09:32:36.217]                 })
[09:32:36.217]                 withCallingHandlers({
[09:32:36.217]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:36.217]                 }, immediateCondition = function(cond) {
[09:32:36.217]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.217]                   sendCondition(cond)
[09:32:36.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.217]                   {
[09:32:36.217]                     inherits <- base::inherits
[09:32:36.217]                     invokeRestart <- base::invokeRestart
[09:32:36.217]                     is.null <- base::is.null
[09:32:36.217]                     muffled <- FALSE
[09:32:36.217]                     if (inherits(cond, "message")) {
[09:32:36.217]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.217]                       if (muffled) 
[09:32:36.217]                         invokeRestart("muffleMessage")
[09:32:36.217]                     }
[09:32:36.217]                     else if (inherits(cond, "warning")) {
[09:32:36.217]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.217]                       if (muffled) 
[09:32:36.217]                         invokeRestart("muffleWarning")
[09:32:36.217]                     }
[09:32:36.217]                     else if (inherits(cond, "condition")) {
[09:32:36.217]                       if (!is.null(pattern)) {
[09:32:36.217]                         computeRestarts <- base::computeRestarts
[09:32:36.217]                         grepl <- base::grepl
[09:32:36.217]                         restarts <- computeRestarts(cond)
[09:32:36.217]                         for (restart in restarts) {
[09:32:36.217]                           name <- restart$name
[09:32:36.217]                           if (is.null(name)) 
[09:32:36.217]                             next
[09:32:36.217]                           if (!grepl(pattern, name)) 
[09:32:36.217]                             next
[09:32:36.217]                           invokeRestart(restart)
[09:32:36.217]                           muffled <- TRUE
[09:32:36.217]                           break
[09:32:36.217]                         }
[09:32:36.217]                       }
[09:32:36.217]                     }
[09:32:36.217]                     invisible(muffled)
[09:32:36.217]                   }
[09:32:36.217]                   muffleCondition(cond)
[09:32:36.217]                 })
[09:32:36.217]             }))
[09:32:36.217]             future::FutureResult(value = ...future.value$value, 
[09:32:36.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.217]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.217]                     ...future.globalenv.names))
[09:32:36.217]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.217]         }, condition = base::local({
[09:32:36.217]             c <- base::c
[09:32:36.217]             inherits <- base::inherits
[09:32:36.217]             invokeRestart <- base::invokeRestart
[09:32:36.217]             length <- base::length
[09:32:36.217]             list <- base::list
[09:32:36.217]             seq.int <- base::seq.int
[09:32:36.217]             signalCondition <- base::signalCondition
[09:32:36.217]             sys.calls <- base::sys.calls
[09:32:36.217]             `[[` <- base::`[[`
[09:32:36.217]             `+` <- base::`+`
[09:32:36.217]             `<<-` <- base::`<<-`
[09:32:36.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.217]                   3L)]
[09:32:36.217]             }
[09:32:36.217]             function(cond) {
[09:32:36.217]                 is_error <- inherits(cond, "error")
[09:32:36.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.217]                   NULL)
[09:32:36.217]                 if (is_error) {
[09:32:36.217]                   sessionInformation <- function() {
[09:32:36.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.217]                       search = base::search(), system = base::Sys.info())
[09:32:36.217]                   }
[09:32:36.217]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.217]                     cond$call), session = sessionInformation(), 
[09:32:36.217]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.217]                   signalCondition(cond)
[09:32:36.217]                 }
[09:32:36.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.217]                 "immediateCondition"))) {
[09:32:36.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.217]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.217]                   if (TRUE && !signal) {
[09:32:36.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.217]                     {
[09:32:36.217]                       inherits <- base::inherits
[09:32:36.217]                       invokeRestart <- base::invokeRestart
[09:32:36.217]                       is.null <- base::is.null
[09:32:36.217]                       muffled <- FALSE
[09:32:36.217]                       if (inherits(cond, "message")) {
[09:32:36.217]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.217]                         if (muffled) 
[09:32:36.217]                           invokeRestart("muffleMessage")
[09:32:36.217]                       }
[09:32:36.217]                       else if (inherits(cond, "warning")) {
[09:32:36.217]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.217]                         if (muffled) 
[09:32:36.217]                           invokeRestart("muffleWarning")
[09:32:36.217]                       }
[09:32:36.217]                       else if (inherits(cond, "condition")) {
[09:32:36.217]                         if (!is.null(pattern)) {
[09:32:36.217]                           computeRestarts <- base::computeRestarts
[09:32:36.217]                           grepl <- base::grepl
[09:32:36.217]                           restarts <- computeRestarts(cond)
[09:32:36.217]                           for (restart in restarts) {
[09:32:36.217]                             name <- restart$name
[09:32:36.217]                             if (is.null(name)) 
[09:32:36.217]                               next
[09:32:36.217]                             if (!grepl(pattern, name)) 
[09:32:36.217]                               next
[09:32:36.217]                             invokeRestart(restart)
[09:32:36.217]                             muffled <- TRUE
[09:32:36.217]                             break
[09:32:36.217]                           }
[09:32:36.217]                         }
[09:32:36.217]                       }
[09:32:36.217]                       invisible(muffled)
[09:32:36.217]                     }
[09:32:36.217]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.217]                   }
[09:32:36.217]                 }
[09:32:36.217]                 else {
[09:32:36.217]                   if (TRUE) {
[09:32:36.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.217]                     {
[09:32:36.217]                       inherits <- base::inherits
[09:32:36.217]                       invokeRestart <- base::invokeRestart
[09:32:36.217]                       is.null <- base::is.null
[09:32:36.217]                       muffled <- FALSE
[09:32:36.217]                       if (inherits(cond, "message")) {
[09:32:36.217]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.217]                         if (muffled) 
[09:32:36.217]                           invokeRestart("muffleMessage")
[09:32:36.217]                       }
[09:32:36.217]                       else if (inherits(cond, "warning")) {
[09:32:36.217]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.217]                         if (muffled) 
[09:32:36.217]                           invokeRestart("muffleWarning")
[09:32:36.217]                       }
[09:32:36.217]                       else if (inherits(cond, "condition")) {
[09:32:36.217]                         if (!is.null(pattern)) {
[09:32:36.217]                           computeRestarts <- base::computeRestarts
[09:32:36.217]                           grepl <- base::grepl
[09:32:36.217]                           restarts <- computeRestarts(cond)
[09:32:36.217]                           for (restart in restarts) {
[09:32:36.217]                             name <- restart$name
[09:32:36.217]                             if (is.null(name)) 
[09:32:36.217]                               next
[09:32:36.217]                             if (!grepl(pattern, name)) 
[09:32:36.217]                               next
[09:32:36.217]                             invokeRestart(restart)
[09:32:36.217]                             muffled <- TRUE
[09:32:36.217]                             break
[09:32:36.217]                           }
[09:32:36.217]                         }
[09:32:36.217]                       }
[09:32:36.217]                       invisible(muffled)
[09:32:36.217]                     }
[09:32:36.217]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.217]                   }
[09:32:36.217]                 }
[09:32:36.217]             }
[09:32:36.217]         }))
[09:32:36.217]     }, error = function(ex) {
[09:32:36.217]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.217]                 ...future.rng), started = ...future.startTime, 
[09:32:36.217]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.217]             version = "1.8"), class = "FutureResult")
[09:32:36.217]     }, finally = {
[09:32:36.217]         if (!identical(...future.workdir, getwd())) 
[09:32:36.217]             setwd(...future.workdir)
[09:32:36.217]         {
[09:32:36.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.217]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.217]             }
[09:32:36.217]             base::options(...future.oldOptions)
[09:32:36.217]             if (.Platform$OS.type == "windows") {
[09:32:36.217]                 old_names <- names(...future.oldEnvVars)
[09:32:36.217]                 envs <- base::Sys.getenv()
[09:32:36.217]                 names <- names(envs)
[09:32:36.217]                 common <- intersect(names, old_names)
[09:32:36.217]                 added <- setdiff(names, old_names)
[09:32:36.217]                 removed <- setdiff(old_names, names)
[09:32:36.217]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.217]                   envs[common]]
[09:32:36.217]                 NAMES <- toupper(changed)
[09:32:36.217]                 args <- list()
[09:32:36.217]                 for (kk in seq_along(NAMES)) {
[09:32:36.217]                   name <- changed[[kk]]
[09:32:36.217]                   NAME <- NAMES[[kk]]
[09:32:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.217]                     next
[09:32:36.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.217]                 }
[09:32:36.217]                 NAMES <- toupper(added)
[09:32:36.217]                 for (kk in seq_along(NAMES)) {
[09:32:36.217]                   name <- added[[kk]]
[09:32:36.217]                   NAME <- NAMES[[kk]]
[09:32:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.217]                     next
[09:32:36.217]                   args[[name]] <- ""
[09:32:36.217]                 }
[09:32:36.217]                 NAMES <- toupper(removed)
[09:32:36.217]                 for (kk in seq_along(NAMES)) {
[09:32:36.217]                   name <- removed[[kk]]
[09:32:36.217]                   NAME <- NAMES[[kk]]
[09:32:36.217]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.217]                     next
[09:32:36.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.217]                 }
[09:32:36.217]                 if (length(args) > 0) 
[09:32:36.217]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.217]             }
[09:32:36.217]             else {
[09:32:36.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.217]             }
[09:32:36.217]             {
[09:32:36.217]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.217]                   0L) {
[09:32:36.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.217]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.217]                   base::options(opts)
[09:32:36.217]                 }
[09:32:36.217]                 {
[09:32:36.217]                   {
[09:32:36.217]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.217]                     NULL
[09:32:36.217]                   }
[09:32:36.217]                   options(future.plan = NULL)
[09:32:36.217]                   if (is.na(NA_character_)) 
[09:32:36.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.217]                     .init = FALSE)
[09:32:36.217]                 }
[09:32:36.217]             }
[09:32:36.217]         }
[09:32:36.217]     })
[09:32:36.217]     if (TRUE) {
[09:32:36.217]         base::sink(type = "output", split = FALSE)
[09:32:36.217]         if (TRUE) {
[09:32:36.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.217]         }
[09:32:36.217]         else {
[09:32:36.217]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.217]         }
[09:32:36.217]         base::close(...future.stdout)
[09:32:36.217]         ...future.stdout <- NULL
[09:32:36.217]     }
[09:32:36.217]     ...future.result$conditions <- ...future.conditions
[09:32:36.217]     ...future.result$finished <- base::Sys.time()
[09:32:36.217]     ...future.result
[09:32:36.217] }
[09:32:36.220] MultisessionFuture started
[09:32:36.220] - Launch lazy future ... done
[09:32:36.221] run() for ‘MultisessionFuture’ ... done
[09:32:36.222] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.222] - Validating connection of MultisessionFuture
[09:32:36.223] - received message: FutureResult
[09:32:36.223] - Received FutureResult
[09:32:36.223] - Erased future from FutureRegistry
[09:32:36.223] result() for ClusterFuture ...
[09:32:36.223] - result already collected: FutureResult
[09:32:36.223] result() for ClusterFuture ... done
[09:32:36.224] signalConditions() ...
[09:32:36.224]  - include = ‘immediateCondition’
[09:32:36.224]  - exclude = 
[09:32:36.224]  - resignal = FALSE
[09:32:36.224]  - Number of conditions: 1
[09:32:36.224] signalConditions() ... done
[09:32:36.224] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.224] A MultisessionFuture was resolved (and resolved itself)
[09:32:36.224] getGlobalsAndPackages() ...
[09:32:36.224] Searching for globals...
[09:32:36.225] - globals found: [2] ‘list’, ‘stop’
[09:32:36.225] Searching for globals ... DONE
[09:32:36.225] Resolving globals: FALSE
[09:32:36.226] 
[09:32:36.226] 
[09:32:36.226] getGlobalsAndPackages() ... DONE
[09:32:36.226] run() for ‘Future’ ...
[09:32:36.226] - state: ‘created’
[09:32:36.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.240]   - Field: ‘node’
[09:32:36.240]   - Field: ‘label’
[09:32:36.240]   - Field: ‘local’
[09:32:36.240]   - Field: ‘owner’
[09:32:36.240]   - Field: ‘envir’
[09:32:36.240]   - Field: ‘workers’
[09:32:36.240]   - Field: ‘packages’
[09:32:36.240]   - Field: ‘gc’
[09:32:36.241]   - Field: ‘conditions’
[09:32:36.241]   - Field: ‘persistent’
[09:32:36.241]   - Field: ‘expr’
[09:32:36.241]   - Field: ‘uuid’
[09:32:36.241]   - Field: ‘seed’
[09:32:36.241]   - Field: ‘version’
[09:32:36.241]   - Field: ‘result’
[09:32:36.241]   - Field: ‘asynchronous’
[09:32:36.241]   - Field: ‘calls’
[09:32:36.241]   - Field: ‘globals’
[09:32:36.241]   - Field: ‘stdout’
[09:32:36.242]   - Field: ‘earlySignal’
[09:32:36.242]   - Field: ‘lazy’
[09:32:36.242]   - Field: ‘state’
[09:32:36.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.242] - Launch lazy future ...
[09:32:36.242] Packages needed by the future expression (n = 0): <none>
[09:32:36.242] Packages needed by future strategies (n = 0): <none>
[09:32:36.243] {
[09:32:36.243]     {
[09:32:36.243]         {
[09:32:36.243]             ...future.startTime <- base::Sys.time()
[09:32:36.243]             {
[09:32:36.243]                 {
[09:32:36.243]                   {
[09:32:36.243]                     {
[09:32:36.243]                       base::local({
[09:32:36.243]                         has_future <- base::requireNamespace("future", 
[09:32:36.243]                           quietly = TRUE)
[09:32:36.243]                         if (has_future) {
[09:32:36.243]                           ns <- base::getNamespace("future")
[09:32:36.243]                           version <- ns[[".package"]][["version"]]
[09:32:36.243]                           if (is.null(version)) 
[09:32:36.243]                             version <- utils::packageVersion("future")
[09:32:36.243]                         }
[09:32:36.243]                         else {
[09:32:36.243]                           version <- NULL
[09:32:36.243]                         }
[09:32:36.243]                         if (!has_future || version < "1.8.0") {
[09:32:36.243]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.243]                             "", base::R.version$version.string), 
[09:32:36.243]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.243]                               "release", "version")], collapse = " "), 
[09:32:36.243]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.243]                             info)
[09:32:36.243]                           info <- base::paste(info, collapse = "; ")
[09:32:36.243]                           if (!has_future) {
[09:32:36.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.243]                               info)
[09:32:36.243]                           }
[09:32:36.243]                           else {
[09:32:36.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.243]                               info, version)
[09:32:36.243]                           }
[09:32:36.243]                           base::stop(msg)
[09:32:36.243]                         }
[09:32:36.243]                       })
[09:32:36.243]                     }
[09:32:36.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.243]                     base::options(mc.cores = 1L)
[09:32:36.243]                   }
[09:32:36.243]                   ...future.strategy.old <- future::plan("list")
[09:32:36.243]                   options(future.plan = NULL)
[09:32:36.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.243]                 }
[09:32:36.243]                 ...future.workdir <- getwd()
[09:32:36.243]             }
[09:32:36.243]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.243]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.243]         }
[09:32:36.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.243]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.243]             base::names(...future.oldOptions))
[09:32:36.243]     }
[09:32:36.243]     if (FALSE) {
[09:32:36.243]     }
[09:32:36.243]     else {
[09:32:36.243]         if (TRUE) {
[09:32:36.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.243]                 open = "w")
[09:32:36.243]         }
[09:32:36.243]         else {
[09:32:36.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.243]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.243]         }
[09:32:36.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.243]             base::sink(type = "output", split = FALSE)
[09:32:36.243]             base::close(...future.stdout)
[09:32:36.243]         }, add = TRUE)
[09:32:36.243]     }
[09:32:36.243]     ...future.frame <- base::sys.nframe()
[09:32:36.243]     ...future.conditions <- base::list()
[09:32:36.243]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.243]     if (FALSE) {
[09:32:36.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.243]     }
[09:32:36.243]     ...future.result <- base::tryCatch({
[09:32:36.243]         base::withCallingHandlers({
[09:32:36.243]             ...future.value <- base::withVisible(base::local({
[09:32:36.243]                 ...future.makeSendCondition <- base::local({
[09:32:36.243]                   sendCondition <- NULL
[09:32:36.243]                   function(frame = 1L) {
[09:32:36.243]                     if (is.function(sendCondition)) 
[09:32:36.243]                       return(sendCondition)
[09:32:36.243]                     ns <- getNamespace("parallel")
[09:32:36.243]                     if (exists("sendData", mode = "function", 
[09:32:36.243]                       envir = ns)) {
[09:32:36.243]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.243]                         envir = ns)
[09:32:36.243]                       envir <- sys.frame(frame)
[09:32:36.243]                       master <- NULL
[09:32:36.243]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.243]                         !identical(envir, emptyenv())) {
[09:32:36.243]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.243]                           inherits = FALSE)) {
[09:32:36.243]                           master <- get("master", mode = "list", 
[09:32:36.243]                             envir = envir, inherits = FALSE)
[09:32:36.243]                           if (inherits(master, c("SOCKnode", 
[09:32:36.243]                             "SOCK0node"))) {
[09:32:36.243]                             sendCondition <<- function(cond) {
[09:32:36.243]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.243]                                 success = TRUE)
[09:32:36.243]                               parallel_sendData(master, data)
[09:32:36.243]                             }
[09:32:36.243]                             return(sendCondition)
[09:32:36.243]                           }
[09:32:36.243]                         }
[09:32:36.243]                         frame <- frame + 1L
[09:32:36.243]                         envir <- sys.frame(frame)
[09:32:36.243]                       }
[09:32:36.243]                     }
[09:32:36.243]                     sendCondition <<- function(cond) NULL
[09:32:36.243]                   }
[09:32:36.243]                 })
[09:32:36.243]                 withCallingHandlers({
[09:32:36.243]                   list(a = 1, b = 42L, c = stop("Nah!"))
[09:32:36.243]                 }, immediateCondition = function(cond) {
[09:32:36.243]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.243]                   sendCondition(cond)
[09:32:36.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.243]                   {
[09:32:36.243]                     inherits <- base::inherits
[09:32:36.243]                     invokeRestart <- base::invokeRestart
[09:32:36.243]                     is.null <- base::is.null
[09:32:36.243]                     muffled <- FALSE
[09:32:36.243]                     if (inherits(cond, "message")) {
[09:32:36.243]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.243]                       if (muffled) 
[09:32:36.243]                         invokeRestart("muffleMessage")
[09:32:36.243]                     }
[09:32:36.243]                     else if (inherits(cond, "warning")) {
[09:32:36.243]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.243]                       if (muffled) 
[09:32:36.243]                         invokeRestart("muffleWarning")
[09:32:36.243]                     }
[09:32:36.243]                     else if (inherits(cond, "condition")) {
[09:32:36.243]                       if (!is.null(pattern)) {
[09:32:36.243]                         computeRestarts <- base::computeRestarts
[09:32:36.243]                         grepl <- base::grepl
[09:32:36.243]                         restarts <- computeRestarts(cond)
[09:32:36.243]                         for (restart in restarts) {
[09:32:36.243]                           name <- restart$name
[09:32:36.243]                           if (is.null(name)) 
[09:32:36.243]                             next
[09:32:36.243]                           if (!grepl(pattern, name)) 
[09:32:36.243]                             next
[09:32:36.243]                           invokeRestart(restart)
[09:32:36.243]                           muffled <- TRUE
[09:32:36.243]                           break
[09:32:36.243]                         }
[09:32:36.243]                       }
[09:32:36.243]                     }
[09:32:36.243]                     invisible(muffled)
[09:32:36.243]                   }
[09:32:36.243]                   muffleCondition(cond)
[09:32:36.243]                 })
[09:32:36.243]             }))
[09:32:36.243]             future::FutureResult(value = ...future.value$value, 
[09:32:36.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.243]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.243]                     ...future.globalenv.names))
[09:32:36.243]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.243]         }, condition = base::local({
[09:32:36.243]             c <- base::c
[09:32:36.243]             inherits <- base::inherits
[09:32:36.243]             invokeRestart <- base::invokeRestart
[09:32:36.243]             length <- base::length
[09:32:36.243]             list <- base::list
[09:32:36.243]             seq.int <- base::seq.int
[09:32:36.243]             signalCondition <- base::signalCondition
[09:32:36.243]             sys.calls <- base::sys.calls
[09:32:36.243]             `[[` <- base::`[[`
[09:32:36.243]             `+` <- base::`+`
[09:32:36.243]             `<<-` <- base::`<<-`
[09:32:36.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.243]                   3L)]
[09:32:36.243]             }
[09:32:36.243]             function(cond) {
[09:32:36.243]                 is_error <- inherits(cond, "error")
[09:32:36.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.243]                   NULL)
[09:32:36.243]                 if (is_error) {
[09:32:36.243]                   sessionInformation <- function() {
[09:32:36.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.243]                       search = base::search(), system = base::Sys.info())
[09:32:36.243]                   }
[09:32:36.243]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.243]                     cond$call), session = sessionInformation(), 
[09:32:36.243]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.243]                   signalCondition(cond)
[09:32:36.243]                 }
[09:32:36.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.243]                 "immediateCondition"))) {
[09:32:36.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.243]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.243]                   if (TRUE && !signal) {
[09:32:36.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.243]                     {
[09:32:36.243]                       inherits <- base::inherits
[09:32:36.243]                       invokeRestart <- base::invokeRestart
[09:32:36.243]                       is.null <- base::is.null
[09:32:36.243]                       muffled <- FALSE
[09:32:36.243]                       if (inherits(cond, "message")) {
[09:32:36.243]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.243]                         if (muffled) 
[09:32:36.243]                           invokeRestart("muffleMessage")
[09:32:36.243]                       }
[09:32:36.243]                       else if (inherits(cond, "warning")) {
[09:32:36.243]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.243]                         if (muffled) 
[09:32:36.243]                           invokeRestart("muffleWarning")
[09:32:36.243]                       }
[09:32:36.243]                       else if (inherits(cond, "condition")) {
[09:32:36.243]                         if (!is.null(pattern)) {
[09:32:36.243]                           computeRestarts <- base::computeRestarts
[09:32:36.243]                           grepl <- base::grepl
[09:32:36.243]                           restarts <- computeRestarts(cond)
[09:32:36.243]                           for (restart in restarts) {
[09:32:36.243]                             name <- restart$name
[09:32:36.243]                             if (is.null(name)) 
[09:32:36.243]                               next
[09:32:36.243]                             if (!grepl(pattern, name)) 
[09:32:36.243]                               next
[09:32:36.243]                             invokeRestart(restart)
[09:32:36.243]                             muffled <- TRUE
[09:32:36.243]                             break
[09:32:36.243]                           }
[09:32:36.243]                         }
[09:32:36.243]                       }
[09:32:36.243]                       invisible(muffled)
[09:32:36.243]                     }
[09:32:36.243]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.243]                   }
[09:32:36.243]                 }
[09:32:36.243]                 else {
[09:32:36.243]                   if (TRUE) {
[09:32:36.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.243]                     {
[09:32:36.243]                       inherits <- base::inherits
[09:32:36.243]                       invokeRestart <- base::invokeRestart
[09:32:36.243]                       is.null <- base::is.null
[09:32:36.243]                       muffled <- FALSE
[09:32:36.243]                       if (inherits(cond, "message")) {
[09:32:36.243]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.243]                         if (muffled) 
[09:32:36.243]                           invokeRestart("muffleMessage")
[09:32:36.243]                       }
[09:32:36.243]                       else if (inherits(cond, "warning")) {
[09:32:36.243]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.243]                         if (muffled) 
[09:32:36.243]                           invokeRestart("muffleWarning")
[09:32:36.243]                       }
[09:32:36.243]                       else if (inherits(cond, "condition")) {
[09:32:36.243]                         if (!is.null(pattern)) {
[09:32:36.243]                           computeRestarts <- base::computeRestarts
[09:32:36.243]                           grepl <- base::grepl
[09:32:36.243]                           restarts <- computeRestarts(cond)
[09:32:36.243]                           for (restart in restarts) {
[09:32:36.243]                             name <- restart$name
[09:32:36.243]                             if (is.null(name)) 
[09:32:36.243]                               next
[09:32:36.243]                             if (!grepl(pattern, name)) 
[09:32:36.243]                               next
[09:32:36.243]                             invokeRestart(restart)
[09:32:36.243]                             muffled <- TRUE
[09:32:36.243]                             break
[09:32:36.243]                           }
[09:32:36.243]                         }
[09:32:36.243]                       }
[09:32:36.243]                       invisible(muffled)
[09:32:36.243]                     }
[09:32:36.243]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.243]                   }
[09:32:36.243]                 }
[09:32:36.243]             }
[09:32:36.243]         }))
[09:32:36.243]     }, error = function(ex) {
[09:32:36.243]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.243]                 ...future.rng), started = ...future.startTime, 
[09:32:36.243]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.243]             version = "1.8"), class = "FutureResult")
[09:32:36.243]     }, finally = {
[09:32:36.243]         if (!identical(...future.workdir, getwd())) 
[09:32:36.243]             setwd(...future.workdir)
[09:32:36.243]         {
[09:32:36.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.243]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.243]             }
[09:32:36.243]             base::options(...future.oldOptions)
[09:32:36.243]             if (.Platform$OS.type == "windows") {
[09:32:36.243]                 old_names <- names(...future.oldEnvVars)
[09:32:36.243]                 envs <- base::Sys.getenv()
[09:32:36.243]                 names <- names(envs)
[09:32:36.243]                 common <- intersect(names, old_names)
[09:32:36.243]                 added <- setdiff(names, old_names)
[09:32:36.243]                 removed <- setdiff(old_names, names)
[09:32:36.243]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.243]                   envs[common]]
[09:32:36.243]                 NAMES <- toupper(changed)
[09:32:36.243]                 args <- list()
[09:32:36.243]                 for (kk in seq_along(NAMES)) {
[09:32:36.243]                   name <- changed[[kk]]
[09:32:36.243]                   NAME <- NAMES[[kk]]
[09:32:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.243]                     next
[09:32:36.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.243]                 }
[09:32:36.243]                 NAMES <- toupper(added)
[09:32:36.243]                 for (kk in seq_along(NAMES)) {
[09:32:36.243]                   name <- added[[kk]]
[09:32:36.243]                   NAME <- NAMES[[kk]]
[09:32:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.243]                     next
[09:32:36.243]                   args[[name]] <- ""
[09:32:36.243]                 }
[09:32:36.243]                 NAMES <- toupper(removed)
[09:32:36.243]                 for (kk in seq_along(NAMES)) {
[09:32:36.243]                   name <- removed[[kk]]
[09:32:36.243]                   NAME <- NAMES[[kk]]
[09:32:36.243]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.243]                     next
[09:32:36.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.243]                 }
[09:32:36.243]                 if (length(args) > 0) 
[09:32:36.243]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.243]             }
[09:32:36.243]             else {
[09:32:36.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.243]             }
[09:32:36.243]             {
[09:32:36.243]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.243]                   0L) {
[09:32:36.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.243]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.243]                   base::options(opts)
[09:32:36.243]                 }
[09:32:36.243]                 {
[09:32:36.243]                   {
[09:32:36.243]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.243]                     NULL
[09:32:36.243]                   }
[09:32:36.243]                   options(future.plan = NULL)
[09:32:36.243]                   if (is.na(NA_character_)) 
[09:32:36.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.243]                     .init = FALSE)
[09:32:36.243]                 }
[09:32:36.243]             }
[09:32:36.243]         }
[09:32:36.243]     })
[09:32:36.243]     if (TRUE) {
[09:32:36.243]         base::sink(type = "output", split = FALSE)
[09:32:36.243]         if (TRUE) {
[09:32:36.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.243]         }
[09:32:36.243]         else {
[09:32:36.243]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.243]         }
[09:32:36.243]         base::close(...future.stdout)
[09:32:36.243]         ...future.stdout <- NULL
[09:32:36.243]     }
[09:32:36.243]     ...future.result$conditions <- ...future.conditions
[09:32:36.243]     ...future.result$finished <- base::Sys.time()
[09:32:36.243]     ...future.result
[09:32:36.243] }
[09:32:36.245] MultisessionFuture started
[09:32:36.245] - Launch lazy future ... done
[09:32:36.246] run() for ‘MultisessionFuture’ ... done
[09:32:36.247] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.247] - Validating connection of MultisessionFuture
[09:32:36.247] - received message: FutureResult
[09:32:36.247] - Received FutureResult
[09:32:36.248] - Erased future from FutureRegistry
[09:32:36.248] result() for ClusterFuture ...
[09:32:36.248] - result already collected: FutureResult
[09:32:36.248] result() for ClusterFuture ... done
[09:32:36.248] signalConditions() ...
[09:32:36.248]  - include = ‘immediateCondition’
[09:32:36.248]  - exclude = 
[09:32:36.248]  - resignal = FALSE
[09:32:36.248]  - Number of conditions: 1
[09:32:36.248] signalConditions() ... done
[09:32:36.249] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.249] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[09:32:36.249] resolve() on list ...
[09:32:36.249]  recursive: 0
[09:32:36.249]  length: 2
[09:32:36.249]  elements: ‘a’, ‘b’
[09:32:36.249]  length: 1 (resolved future 1)
[09:32:36.249]  length: 0 (resolved future 2)
[09:32:36.249] resolve() on list ... DONE
[09:32:36.250] getGlobalsAndPackages() ...
[09:32:36.250] Searching for globals...
[09:32:36.250] 
[09:32:36.250] Searching for globals ... DONE
[09:32:36.250] - globals: [0] <none>
[09:32:36.250] getGlobalsAndPackages() ... DONE
[09:32:36.250] run() for ‘Future’ ...
[09:32:36.251] - state: ‘created’
[09:32:36.251] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.264] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.264] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.264]   - Field: ‘node’
[09:32:36.264]   - Field: ‘label’
[09:32:36.265]   - Field: ‘local’
[09:32:36.265]   - Field: ‘owner’
[09:32:36.265]   - Field: ‘envir’
[09:32:36.265]   - Field: ‘workers’
[09:32:36.265]   - Field: ‘packages’
[09:32:36.265]   - Field: ‘gc’
[09:32:36.265]   - Field: ‘conditions’
[09:32:36.265]   - Field: ‘persistent’
[09:32:36.265]   - Field: ‘expr’
[09:32:36.265]   - Field: ‘uuid’
[09:32:36.265]   - Field: ‘seed’
[09:32:36.266]   - Field: ‘version’
[09:32:36.266]   - Field: ‘result’
[09:32:36.266]   - Field: ‘asynchronous’
[09:32:36.266]   - Field: ‘calls’
[09:32:36.266]   - Field: ‘globals’
[09:32:36.266]   - Field: ‘stdout’
[09:32:36.266]   - Field: ‘earlySignal’
[09:32:36.266]   - Field: ‘lazy’
[09:32:36.266]   - Field: ‘state’
[09:32:36.266] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.266] - Launch lazy future ...
[09:32:36.267] Packages needed by the future expression (n = 0): <none>
[09:32:36.267] Packages needed by future strategies (n = 0): <none>
[09:32:36.267] {
[09:32:36.267]     {
[09:32:36.267]         {
[09:32:36.267]             ...future.startTime <- base::Sys.time()
[09:32:36.267]             {
[09:32:36.267]                 {
[09:32:36.267]                   {
[09:32:36.267]                     {
[09:32:36.267]                       base::local({
[09:32:36.267]                         has_future <- base::requireNamespace("future", 
[09:32:36.267]                           quietly = TRUE)
[09:32:36.267]                         if (has_future) {
[09:32:36.267]                           ns <- base::getNamespace("future")
[09:32:36.267]                           version <- ns[[".package"]][["version"]]
[09:32:36.267]                           if (is.null(version)) 
[09:32:36.267]                             version <- utils::packageVersion("future")
[09:32:36.267]                         }
[09:32:36.267]                         else {
[09:32:36.267]                           version <- NULL
[09:32:36.267]                         }
[09:32:36.267]                         if (!has_future || version < "1.8.0") {
[09:32:36.267]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.267]                             "", base::R.version$version.string), 
[09:32:36.267]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.267]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.267]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.267]                               "release", "version")], collapse = " "), 
[09:32:36.267]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.267]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.267]                             info)
[09:32:36.267]                           info <- base::paste(info, collapse = "; ")
[09:32:36.267]                           if (!has_future) {
[09:32:36.267]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.267]                               info)
[09:32:36.267]                           }
[09:32:36.267]                           else {
[09:32:36.267]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.267]                               info, version)
[09:32:36.267]                           }
[09:32:36.267]                           base::stop(msg)
[09:32:36.267]                         }
[09:32:36.267]                       })
[09:32:36.267]                     }
[09:32:36.267]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.267]                     base::options(mc.cores = 1L)
[09:32:36.267]                   }
[09:32:36.267]                   ...future.strategy.old <- future::plan("list")
[09:32:36.267]                   options(future.plan = NULL)
[09:32:36.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.267]                 }
[09:32:36.267]                 ...future.workdir <- getwd()
[09:32:36.267]             }
[09:32:36.267]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.267]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.267]         }
[09:32:36.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.267]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.267]             base::names(...future.oldOptions))
[09:32:36.267]     }
[09:32:36.267]     if (FALSE) {
[09:32:36.267]     }
[09:32:36.267]     else {
[09:32:36.267]         if (TRUE) {
[09:32:36.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.267]                 open = "w")
[09:32:36.267]         }
[09:32:36.267]         else {
[09:32:36.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.267]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.267]         }
[09:32:36.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.267]             base::sink(type = "output", split = FALSE)
[09:32:36.267]             base::close(...future.stdout)
[09:32:36.267]         }, add = TRUE)
[09:32:36.267]     }
[09:32:36.267]     ...future.frame <- base::sys.nframe()
[09:32:36.267]     ...future.conditions <- base::list()
[09:32:36.267]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.267]     if (FALSE) {
[09:32:36.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.267]     }
[09:32:36.267]     ...future.result <- base::tryCatch({
[09:32:36.267]         base::withCallingHandlers({
[09:32:36.267]             ...future.value <- base::withVisible(base::local({
[09:32:36.267]                 ...future.makeSendCondition <- base::local({
[09:32:36.267]                   sendCondition <- NULL
[09:32:36.267]                   function(frame = 1L) {
[09:32:36.267]                     if (is.function(sendCondition)) 
[09:32:36.267]                       return(sendCondition)
[09:32:36.267]                     ns <- getNamespace("parallel")
[09:32:36.267]                     if (exists("sendData", mode = "function", 
[09:32:36.267]                       envir = ns)) {
[09:32:36.267]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.267]                         envir = ns)
[09:32:36.267]                       envir <- sys.frame(frame)
[09:32:36.267]                       master <- NULL
[09:32:36.267]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.267]                         !identical(envir, emptyenv())) {
[09:32:36.267]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.267]                           inherits = FALSE)) {
[09:32:36.267]                           master <- get("master", mode = "list", 
[09:32:36.267]                             envir = envir, inherits = FALSE)
[09:32:36.267]                           if (inherits(master, c("SOCKnode", 
[09:32:36.267]                             "SOCK0node"))) {
[09:32:36.267]                             sendCondition <<- function(cond) {
[09:32:36.267]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.267]                                 success = TRUE)
[09:32:36.267]                               parallel_sendData(master, data)
[09:32:36.267]                             }
[09:32:36.267]                             return(sendCondition)
[09:32:36.267]                           }
[09:32:36.267]                         }
[09:32:36.267]                         frame <- frame + 1L
[09:32:36.267]                         envir <- sys.frame(frame)
[09:32:36.267]                       }
[09:32:36.267]                     }
[09:32:36.267]                     sendCondition <<- function(cond) NULL
[09:32:36.267]                   }
[09:32:36.267]                 })
[09:32:36.267]                 withCallingHandlers({
[09:32:36.267]                   1
[09:32:36.267]                 }, immediateCondition = function(cond) {
[09:32:36.267]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.267]                   sendCondition(cond)
[09:32:36.267]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.267]                   {
[09:32:36.267]                     inherits <- base::inherits
[09:32:36.267]                     invokeRestart <- base::invokeRestart
[09:32:36.267]                     is.null <- base::is.null
[09:32:36.267]                     muffled <- FALSE
[09:32:36.267]                     if (inherits(cond, "message")) {
[09:32:36.267]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.267]                       if (muffled) 
[09:32:36.267]                         invokeRestart("muffleMessage")
[09:32:36.267]                     }
[09:32:36.267]                     else if (inherits(cond, "warning")) {
[09:32:36.267]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.267]                       if (muffled) 
[09:32:36.267]                         invokeRestart("muffleWarning")
[09:32:36.267]                     }
[09:32:36.267]                     else if (inherits(cond, "condition")) {
[09:32:36.267]                       if (!is.null(pattern)) {
[09:32:36.267]                         computeRestarts <- base::computeRestarts
[09:32:36.267]                         grepl <- base::grepl
[09:32:36.267]                         restarts <- computeRestarts(cond)
[09:32:36.267]                         for (restart in restarts) {
[09:32:36.267]                           name <- restart$name
[09:32:36.267]                           if (is.null(name)) 
[09:32:36.267]                             next
[09:32:36.267]                           if (!grepl(pattern, name)) 
[09:32:36.267]                             next
[09:32:36.267]                           invokeRestart(restart)
[09:32:36.267]                           muffled <- TRUE
[09:32:36.267]                           break
[09:32:36.267]                         }
[09:32:36.267]                       }
[09:32:36.267]                     }
[09:32:36.267]                     invisible(muffled)
[09:32:36.267]                   }
[09:32:36.267]                   muffleCondition(cond)
[09:32:36.267]                 })
[09:32:36.267]             }))
[09:32:36.267]             future::FutureResult(value = ...future.value$value, 
[09:32:36.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.267]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.267]                     ...future.globalenv.names))
[09:32:36.267]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.267]         }, condition = base::local({
[09:32:36.267]             c <- base::c
[09:32:36.267]             inherits <- base::inherits
[09:32:36.267]             invokeRestart <- base::invokeRestart
[09:32:36.267]             length <- base::length
[09:32:36.267]             list <- base::list
[09:32:36.267]             seq.int <- base::seq.int
[09:32:36.267]             signalCondition <- base::signalCondition
[09:32:36.267]             sys.calls <- base::sys.calls
[09:32:36.267]             `[[` <- base::`[[`
[09:32:36.267]             `+` <- base::`+`
[09:32:36.267]             `<<-` <- base::`<<-`
[09:32:36.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.267]                   3L)]
[09:32:36.267]             }
[09:32:36.267]             function(cond) {
[09:32:36.267]                 is_error <- inherits(cond, "error")
[09:32:36.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.267]                   NULL)
[09:32:36.267]                 if (is_error) {
[09:32:36.267]                   sessionInformation <- function() {
[09:32:36.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.267]                       search = base::search(), system = base::Sys.info())
[09:32:36.267]                   }
[09:32:36.267]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.267]                     cond$call), session = sessionInformation(), 
[09:32:36.267]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.267]                   signalCondition(cond)
[09:32:36.267]                 }
[09:32:36.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.267]                 "immediateCondition"))) {
[09:32:36.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.267]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.267]                   if (TRUE && !signal) {
[09:32:36.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.267]                     {
[09:32:36.267]                       inherits <- base::inherits
[09:32:36.267]                       invokeRestart <- base::invokeRestart
[09:32:36.267]                       is.null <- base::is.null
[09:32:36.267]                       muffled <- FALSE
[09:32:36.267]                       if (inherits(cond, "message")) {
[09:32:36.267]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.267]                         if (muffled) 
[09:32:36.267]                           invokeRestart("muffleMessage")
[09:32:36.267]                       }
[09:32:36.267]                       else if (inherits(cond, "warning")) {
[09:32:36.267]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.267]                         if (muffled) 
[09:32:36.267]                           invokeRestart("muffleWarning")
[09:32:36.267]                       }
[09:32:36.267]                       else if (inherits(cond, "condition")) {
[09:32:36.267]                         if (!is.null(pattern)) {
[09:32:36.267]                           computeRestarts <- base::computeRestarts
[09:32:36.267]                           grepl <- base::grepl
[09:32:36.267]                           restarts <- computeRestarts(cond)
[09:32:36.267]                           for (restart in restarts) {
[09:32:36.267]                             name <- restart$name
[09:32:36.267]                             if (is.null(name)) 
[09:32:36.267]                               next
[09:32:36.267]                             if (!grepl(pattern, name)) 
[09:32:36.267]                               next
[09:32:36.267]                             invokeRestart(restart)
[09:32:36.267]                             muffled <- TRUE
[09:32:36.267]                             break
[09:32:36.267]                           }
[09:32:36.267]                         }
[09:32:36.267]                       }
[09:32:36.267]                       invisible(muffled)
[09:32:36.267]                     }
[09:32:36.267]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.267]                   }
[09:32:36.267]                 }
[09:32:36.267]                 else {
[09:32:36.267]                   if (TRUE) {
[09:32:36.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.267]                     {
[09:32:36.267]                       inherits <- base::inherits
[09:32:36.267]                       invokeRestart <- base::invokeRestart
[09:32:36.267]                       is.null <- base::is.null
[09:32:36.267]                       muffled <- FALSE
[09:32:36.267]                       if (inherits(cond, "message")) {
[09:32:36.267]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.267]                         if (muffled) 
[09:32:36.267]                           invokeRestart("muffleMessage")
[09:32:36.267]                       }
[09:32:36.267]                       else if (inherits(cond, "warning")) {
[09:32:36.267]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.267]                         if (muffled) 
[09:32:36.267]                           invokeRestart("muffleWarning")
[09:32:36.267]                       }
[09:32:36.267]                       else if (inherits(cond, "condition")) {
[09:32:36.267]                         if (!is.null(pattern)) {
[09:32:36.267]                           computeRestarts <- base::computeRestarts
[09:32:36.267]                           grepl <- base::grepl
[09:32:36.267]                           restarts <- computeRestarts(cond)
[09:32:36.267]                           for (restart in restarts) {
[09:32:36.267]                             name <- restart$name
[09:32:36.267]                             if (is.null(name)) 
[09:32:36.267]                               next
[09:32:36.267]                             if (!grepl(pattern, name)) 
[09:32:36.267]                               next
[09:32:36.267]                             invokeRestart(restart)
[09:32:36.267]                             muffled <- TRUE
[09:32:36.267]                             break
[09:32:36.267]                           }
[09:32:36.267]                         }
[09:32:36.267]                       }
[09:32:36.267]                       invisible(muffled)
[09:32:36.267]                     }
[09:32:36.267]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.267]                   }
[09:32:36.267]                 }
[09:32:36.267]             }
[09:32:36.267]         }))
[09:32:36.267]     }, error = function(ex) {
[09:32:36.267]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.267]                 ...future.rng), started = ...future.startTime, 
[09:32:36.267]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.267]             version = "1.8"), class = "FutureResult")
[09:32:36.267]     }, finally = {
[09:32:36.267]         if (!identical(...future.workdir, getwd())) 
[09:32:36.267]             setwd(...future.workdir)
[09:32:36.267]         {
[09:32:36.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.267]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.267]             }
[09:32:36.267]             base::options(...future.oldOptions)
[09:32:36.267]             if (.Platform$OS.type == "windows") {
[09:32:36.267]                 old_names <- names(...future.oldEnvVars)
[09:32:36.267]                 envs <- base::Sys.getenv()
[09:32:36.267]                 names <- names(envs)
[09:32:36.267]                 common <- intersect(names, old_names)
[09:32:36.267]                 added <- setdiff(names, old_names)
[09:32:36.267]                 removed <- setdiff(old_names, names)
[09:32:36.267]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.267]                   envs[common]]
[09:32:36.267]                 NAMES <- toupper(changed)
[09:32:36.267]                 args <- list()
[09:32:36.267]                 for (kk in seq_along(NAMES)) {
[09:32:36.267]                   name <- changed[[kk]]
[09:32:36.267]                   NAME <- NAMES[[kk]]
[09:32:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.267]                     next
[09:32:36.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.267]                 }
[09:32:36.267]                 NAMES <- toupper(added)
[09:32:36.267]                 for (kk in seq_along(NAMES)) {
[09:32:36.267]                   name <- added[[kk]]
[09:32:36.267]                   NAME <- NAMES[[kk]]
[09:32:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.267]                     next
[09:32:36.267]                   args[[name]] <- ""
[09:32:36.267]                 }
[09:32:36.267]                 NAMES <- toupper(removed)
[09:32:36.267]                 for (kk in seq_along(NAMES)) {
[09:32:36.267]                   name <- removed[[kk]]
[09:32:36.267]                   NAME <- NAMES[[kk]]
[09:32:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.267]                     next
[09:32:36.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.267]                 }
[09:32:36.267]                 if (length(args) > 0) 
[09:32:36.267]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.267]             }
[09:32:36.267]             else {
[09:32:36.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.267]             }
[09:32:36.267]             {
[09:32:36.267]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.267]                   0L) {
[09:32:36.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.267]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.267]                   base::options(opts)
[09:32:36.267]                 }
[09:32:36.267]                 {
[09:32:36.267]                   {
[09:32:36.267]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.267]                     NULL
[09:32:36.267]                   }
[09:32:36.267]                   options(future.plan = NULL)
[09:32:36.267]                   if (is.na(NA_character_)) 
[09:32:36.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.267]                     .init = FALSE)
[09:32:36.267]                 }
[09:32:36.267]             }
[09:32:36.267]         }
[09:32:36.267]     })
[09:32:36.267]     if (TRUE) {
[09:32:36.267]         base::sink(type = "output", split = FALSE)
[09:32:36.267]         if (TRUE) {
[09:32:36.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.267]         }
[09:32:36.267]         else {
[09:32:36.267]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.267]         }
[09:32:36.267]         base::close(...future.stdout)
[09:32:36.267]         ...future.stdout <- NULL
[09:32:36.267]     }
[09:32:36.267]     ...future.result$conditions <- ...future.conditions
[09:32:36.267]     ...future.result$finished <- base::Sys.time()
[09:32:36.267]     ...future.result
[09:32:36.267] }
[09:32:36.273] MultisessionFuture started
[09:32:36.273] - Launch lazy future ... done
[09:32:36.273] run() for ‘MultisessionFuture’ ... done
[09:32:36.273] getGlobalsAndPackages() ...
[09:32:36.273] Searching for globals...
[09:32:36.274] 
[09:32:36.274] Searching for globals ... DONE
[09:32:36.274] - globals: [0] <none>
[09:32:36.274] getGlobalsAndPackages() ... DONE
[09:32:36.274] run() for ‘Future’ ...
[09:32:36.274] - state: ‘created’
[09:32:36.274] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.288] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.288] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.288]   - Field: ‘node’
[09:32:36.288]   - Field: ‘label’
[09:32:36.288]   - Field: ‘local’
[09:32:36.288]   - Field: ‘owner’
[09:32:36.289]   - Field: ‘envir’
[09:32:36.289]   - Field: ‘workers’
[09:32:36.289]   - Field: ‘packages’
[09:32:36.289]   - Field: ‘gc’
[09:32:36.289]   - Field: ‘conditions’
[09:32:36.289]   - Field: ‘persistent’
[09:32:36.289]   - Field: ‘expr’
[09:32:36.289]   - Field: ‘uuid’
[09:32:36.289]   - Field: ‘seed’
[09:32:36.289]   - Field: ‘version’
[09:32:36.289]   - Field: ‘result’
[09:32:36.290]   - Field: ‘asynchronous’
[09:32:36.290]   - Field: ‘calls’
[09:32:36.290]   - Field: ‘globals’
[09:32:36.290]   - Field: ‘stdout’
[09:32:36.290]   - Field: ‘earlySignal’
[09:32:36.290]   - Field: ‘lazy’
[09:32:36.290]   - Field: ‘state’
[09:32:36.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.290] - Launch lazy future ...
[09:32:36.290] Packages needed by the future expression (n = 0): <none>
[09:32:36.291] Packages needed by future strategies (n = 0): <none>
[09:32:36.291] {
[09:32:36.291]     {
[09:32:36.291]         {
[09:32:36.291]             ...future.startTime <- base::Sys.time()
[09:32:36.291]             {
[09:32:36.291]                 {
[09:32:36.291]                   {
[09:32:36.291]                     {
[09:32:36.291]                       base::local({
[09:32:36.291]                         has_future <- base::requireNamespace("future", 
[09:32:36.291]                           quietly = TRUE)
[09:32:36.291]                         if (has_future) {
[09:32:36.291]                           ns <- base::getNamespace("future")
[09:32:36.291]                           version <- ns[[".package"]][["version"]]
[09:32:36.291]                           if (is.null(version)) 
[09:32:36.291]                             version <- utils::packageVersion("future")
[09:32:36.291]                         }
[09:32:36.291]                         else {
[09:32:36.291]                           version <- NULL
[09:32:36.291]                         }
[09:32:36.291]                         if (!has_future || version < "1.8.0") {
[09:32:36.291]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.291]                             "", base::R.version$version.string), 
[09:32:36.291]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.291]                               "release", "version")], collapse = " "), 
[09:32:36.291]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.291]                             info)
[09:32:36.291]                           info <- base::paste(info, collapse = "; ")
[09:32:36.291]                           if (!has_future) {
[09:32:36.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.291]                               info)
[09:32:36.291]                           }
[09:32:36.291]                           else {
[09:32:36.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.291]                               info, version)
[09:32:36.291]                           }
[09:32:36.291]                           base::stop(msg)
[09:32:36.291]                         }
[09:32:36.291]                       })
[09:32:36.291]                     }
[09:32:36.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.291]                     base::options(mc.cores = 1L)
[09:32:36.291]                   }
[09:32:36.291]                   ...future.strategy.old <- future::plan("list")
[09:32:36.291]                   options(future.plan = NULL)
[09:32:36.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.291]                 }
[09:32:36.291]                 ...future.workdir <- getwd()
[09:32:36.291]             }
[09:32:36.291]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.291]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.291]         }
[09:32:36.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.291]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.291]             base::names(...future.oldOptions))
[09:32:36.291]     }
[09:32:36.291]     if (FALSE) {
[09:32:36.291]     }
[09:32:36.291]     else {
[09:32:36.291]         if (TRUE) {
[09:32:36.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.291]                 open = "w")
[09:32:36.291]         }
[09:32:36.291]         else {
[09:32:36.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.291]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.291]         }
[09:32:36.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.291]             base::sink(type = "output", split = FALSE)
[09:32:36.291]             base::close(...future.stdout)
[09:32:36.291]         }, add = TRUE)
[09:32:36.291]     }
[09:32:36.291]     ...future.frame <- base::sys.nframe()
[09:32:36.291]     ...future.conditions <- base::list()
[09:32:36.291]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.291]     if (FALSE) {
[09:32:36.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.291]     }
[09:32:36.291]     ...future.result <- base::tryCatch({
[09:32:36.291]         base::withCallingHandlers({
[09:32:36.291]             ...future.value <- base::withVisible(base::local({
[09:32:36.291]                 ...future.makeSendCondition <- base::local({
[09:32:36.291]                   sendCondition <- NULL
[09:32:36.291]                   function(frame = 1L) {
[09:32:36.291]                     if (is.function(sendCondition)) 
[09:32:36.291]                       return(sendCondition)
[09:32:36.291]                     ns <- getNamespace("parallel")
[09:32:36.291]                     if (exists("sendData", mode = "function", 
[09:32:36.291]                       envir = ns)) {
[09:32:36.291]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.291]                         envir = ns)
[09:32:36.291]                       envir <- sys.frame(frame)
[09:32:36.291]                       master <- NULL
[09:32:36.291]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.291]                         !identical(envir, emptyenv())) {
[09:32:36.291]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.291]                           inherits = FALSE)) {
[09:32:36.291]                           master <- get("master", mode = "list", 
[09:32:36.291]                             envir = envir, inherits = FALSE)
[09:32:36.291]                           if (inherits(master, c("SOCKnode", 
[09:32:36.291]                             "SOCK0node"))) {
[09:32:36.291]                             sendCondition <<- function(cond) {
[09:32:36.291]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.291]                                 success = TRUE)
[09:32:36.291]                               parallel_sendData(master, data)
[09:32:36.291]                             }
[09:32:36.291]                             return(sendCondition)
[09:32:36.291]                           }
[09:32:36.291]                         }
[09:32:36.291]                         frame <- frame + 1L
[09:32:36.291]                         envir <- sys.frame(frame)
[09:32:36.291]                       }
[09:32:36.291]                     }
[09:32:36.291]                     sendCondition <<- function(cond) NULL
[09:32:36.291]                   }
[09:32:36.291]                 })
[09:32:36.291]                 withCallingHandlers({
[09:32:36.291]                   2
[09:32:36.291]                 }, immediateCondition = function(cond) {
[09:32:36.291]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.291]                   sendCondition(cond)
[09:32:36.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.291]                   {
[09:32:36.291]                     inherits <- base::inherits
[09:32:36.291]                     invokeRestart <- base::invokeRestart
[09:32:36.291]                     is.null <- base::is.null
[09:32:36.291]                     muffled <- FALSE
[09:32:36.291]                     if (inherits(cond, "message")) {
[09:32:36.291]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.291]                       if (muffled) 
[09:32:36.291]                         invokeRestart("muffleMessage")
[09:32:36.291]                     }
[09:32:36.291]                     else if (inherits(cond, "warning")) {
[09:32:36.291]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.291]                       if (muffled) 
[09:32:36.291]                         invokeRestart("muffleWarning")
[09:32:36.291]                     }
[09:32:36.291]                     else if (inherits(cond, "condition")) {
[09:32:36.291]                       if (!is.null(pattern)) {
[09:32:36.291]                         computeRestarts <- base::computeRestarts
[09:32:36.291]                         grepl <- base::grepl
[09:32:36.291]                         restarts <- computeRestarts(cond)
[09:32:36.291]                         for (restart in restarts) {
[09:32:36.291]                           name <- restart$name
[09:32:36.291]                           if (is.null(name)) 
[09:32:36.291]                             next
[09:32:36.291]                           if (!grepl(pattern, name)) 
[09:32:36.291]                             next
[09:32:36.291]                           invokeRestart(restart)
[09:32:36.291]                           muffled <- TRUE
[09:32:36.291]                           break
[09:32:36.291]                         }
[09:32:36.291]                       }
[09:32:36.291]                     }
[09:32:36.291]                     invisible(muffled)
[09:32:36.291]                   }
[09:32:36.291]                   muffleCondition(cond)
[09:32:36.291]                 })
[09:32:36.291]             }))
[09:32:36.291]             future::FutureResult(value = ...future.value$value, 
[09:32:36.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.291]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.291]                     ...future.globalenv.names))
[09:32:36.291]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.291]         }, condition = base::local({
[09:32:36.291]             c <- base::c
[09:32:36.291]             inherits <- base::inherits
[09:32:36.291]             invokeRestart <- base::invokeRestart
[09:32:36.291]             length <- base::length
[09:32:36.291]             list <- base::list
[09:32:36.291]             seq.int <- base::seq.int
[09:32:36.291]             signalCondition <- base::signalCondition
[09:32:36.291]             sys.calls <- base::sys.calls
[09:32:36.291]             `[[` <- base::`[[`
[09:32:36.291]             `+` <- base::`+`
[09:32:36.291]             `<<-` <- base::`<<-`
[09:32:36.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.291]                   3L)]
[09:32:36.291]             }
[09:32:36.291]             function(cond) {
[09:32:36.291]                 is_error <- inherits(cond, "error")
[09:32:36.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.291]                   NULL)
[09:32:36.291]                 if (is_error) {
[09:32:36.291]                   sessionInformation <- function() {
[09:32:36.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.291]                       search = base::search(), system = base::Sys.info())
[09:32:36.291]                   }
[09:32:36.291]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.291]                     cond$call), session = sessionInformation(), 
[09:32:36.291]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.291]                   signalCondition(cond)
[09:32:36.291]                 }
[09:32:36.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.291]                 "immediateCondition"))) {
[09:32:36.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.291]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.291]                   if (TRUE && !signal) {
[09:32:36.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.291]                     {
[09:32:36.291]                       inherits <- base::inherits
[09:32:36.291]                       invokeRestart <- base::invokeRestart
[09:32:36.291]                       is.null <- base::is.null
[09:32:36.291]                       muffled <- FALSE
[09:32:36.291]                       if (inherits(cond, "message")) {
[09:32:36.291]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.291]                         if (muffled) 
[09:32:36.291]                           invokeRestart("muffleMessage")
[09:32:36.291]                       }
[09:32:36.291]                       else if (inherits(cond, "warning")) {
[09:32:36.291]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.291]                         if (muffled) 
[09:32:36.291]                           invokeRestart("muffleWarning")
[09:32:36.291]                       }
[09:32:36.291]                       else if (inherits(cond, "condition")) {
[09:32:36.291]                         if (!is.null(pattern)) {
[09:32:36.291]                           computeRestarts <- base::computeRestarts
[09:32:36.291]                           grepl <- base::grepl
[09:32:36.291]                           restarts <- computeRestarts(cond)
[09:32:36.291]                           for (restart in restarts) {
[09:32:36.291]                             name <- restart$name
[09:32:36.291]                             if (is.null(name)) 
[09:32:36.291]                               next
[09:32:36.291]                             if (!grepl(pattern, name)) 
[09:32:36.291]                               next
[09:32:36.291]                             invokeRestart(restart)
[09:32:36.291]                             muffled <- TRUE
[09:32:36.291]                             break
[09:32:36.291]                           }
[09:32:36.291]                         }
[09:32:36.291]                       }
[09:32:36.291]                       invisible(muffled)
[09:32:36.291]                     }
[09:32:36.291]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.291]                   }
[09:32:36.291]                 }
[09:32:36.291]                 else {
[09:32:36.291]                   if (TRUE) {
[09:32:36.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.291]                     {
[09:32:36.291]                       inherits <- base::inherits
[09:32:36.291]                       invokeRestart <- base::invokeRestart
[09:32:36.291]                       is.null <- base::is.null
[09:32:36.291]                       muffled <- FALSE
[09:32:36.291]                       if (inherits(cond, "message")) {
[09:32:36.291]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.291]                         if (muffled) 
[09:32:36.291]                           invokeRestart("muffleMessage")
[09:32:36.291]                       }
[09:32:36.291]                       else if (inherits(cond, "warning")) {
[09:32:36.291]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.291]                         if (muffled) 
[09:32:36.291]                           invokeRestart("muffleWarning")
[09:32:36.291]                       }
[09:32:36.291]                       else if (inherits(cond, "condition")) {
[09:32:36.291]                         if (!is.null(pattern)) {
[09:32:36.291]                           computeRestarts <- base::computeRestarts
[09:32:36.291]                           grepl <- base::grepl
[09:32:36.291]                           restarts <- computeRestarts(cond)
[09:32:36.291]                           for (restart in restarts) {
[09:32:36.291]                             name <- restart$name
[09:32:36.291]                             if (is.null(name)) 
[09:32:36.291]                               next
[09:32:36.291]                             if (!grepl(pattern, name)) 
[09:32:36.291]                               next
[09:32:36.291]                             invokeRestart(restart)
[09:32:36.291]                             muffled <- TRUE
[09:32:36.291]                             break
[09:32:36.291]                           }
[09:32:36.291]                         }
[09:32:36.291]                       }
[09:32:36.291]                       invisible(muffled)
[09:32:36.291]                     }
[09:32:36.291]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.291]                   }
[09:32:36.291]                 }
[09:32:36.291]             }
[09:32:36.291]         }))
[09:32:36.291]     }, error = function(ex) {
[09:32:36.291]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.291]                 ...future.rng), started = ...future.startTime, 
[09:32:36.291]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.291]             version = "1.8"), class = "FutureResult")
[09:32:36.291]     }, finally = {
[09:32:36.291]         if (!identical(...future.workdir, getwd())) 
[09:32:36.291]             setwd(...future.workdir)
[09:32:36.291]         {
[09:32:36.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.291]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.291]             }
[09:32:36.291]             base::options(...future.oldOptions)
[09:32:36.291]             if (.Platform$OS.type == "windows") {
[09:32:36.291]                 old_names <- names(...future.oldEnvVars)
[09:32:36.291]                 envs <- base::Sys.getenv()
[09:32:36.291]                 names <- names(envs)
[09:32:36.291]                 common <- intersect(names, old_names)
[09:32:36.291]                 added <- setdiff(names, old_names)
[09:32:36.291]                 removed <- setdiff(old_names, names)
[09:32:36.291]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.291]                   envs[common]]
[09:32:36.291]                 NAMES <- toupper(changed)
[09:32:36.291]                 args <- list()
[09:32:36.291]                 for (kk in seq_along(NAMES)) {
[09:32:36.291]                   name <- changed[[kk]]
[09:32:36.291]                   NAME <- NAMES[[kk]]
[09:32:36.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.291]                     next
[09:32:36.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.291]                 }
[09:32:36.291]                 NAMES <- toupper(added)
[09:32:36.291]                 for (kk in seq_along(NAMES)) {
[09:32:36.291]                   name <- added[[kk]]
[09:32:36.291]                   NAME <- NAMES[[kk]]
[09:32:36.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.291]                     next
[09:32:36.291]                   args[[name]] <- ""
[09:32:36.291]                 }
[09:32:36.291]                 NAMES <- toupper(removed)
[09:32:36.291]                 for (kk in seq_along(NAMES)) {
[09:32:36.291]                   name <- removed[[kk]]
[09:32:36.291]                   NAME <- NAMES[[kk]]
[09:32:36.291]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.291]                     next
[09:32:36.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.291]                 }
[09:32:36.291]                 if (length(args) > 0) 
[09:32:36.291]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.291]             }
[09:32:36.291]             else {
[09:32:36.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.291]             }
[09:32:36.291]             {
[09:32:36.291]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.291]                   0L) {
[09:32:36.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.291]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.291]                   base::options(opts)
[09:32:36.291]                 }
[09:32:36.291]                 {
[09:32:36.291]                   {
[09:32:36.291]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.291]                     NULL
[09:32:36.291]                   }
[09:32:36.291]                   options(future.plan = NULL)
[09:32:36.291]                   if (is.na(NA_character_)) 
[09:32:36.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.291]                     .init = FALSE)
[09:32:36.291]                 }
[09:32:36.291]             }
[09:32:36.291]         }
[09:32:36.291]     })
[09:32:36.291]     if (TRUE) {
[09:32:36.291]         base::sink(type = "output", split = FALSE)
[09:32:36.291]         if (TRUE) {
[09:32:36.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.291]         }
[09:32:36.291]         else {
[09:32:36.291]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.291]         }
[09:32:36.291]         base::close(...future.stdout)
[09:32:36.291]         ...future.stdout <- NULL
[09:32:36.291]     }
[09:32:36.291]     ...future.result$conditions <- ...future.conditions
[09:32:36.291]     ...future.result$finished <- base::Sys.time()
[09:32:36.291]     ...future.result
[09:32:36.291] }
[09:32:36.293] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:36.304] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.304] - Validating connection of MultisessionFuture
[09:32:36.304] - received message: FutureResult
[09:32:36.304] - Received FutureResult
[09:32:36.304] - Erased future from FutureRegistry
[09:32:36.304] result() for ClusterFuture ...
[09:32:36.304] - result already collected: FutureResult
[09:32:36.305] result() for ClusterFuture ... done
[09:32:36.305] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.305] result() for ClusterFuture ...
[09:32:36.305] - result already collected: FutureResult
[09:32:36.305] result() for ClusterFuture ... done
[09:32:36.305] result() for ClusterFuture ...
[09:32:36.305] - result already collected: FutureResult
[09:32:36.305] result() for ClusterFuture ... done
[09:32:36.306] MultisessionFuture started
[09:32:36.306] - Launch lazy future ... done
[09:32:36.306] run() for ‘MultisessionFuture’ ... done
[09:32:36.306] resolve() on list ...
[09:32:36.307]  recursive: 0
[09:32:36.307]  length: 3
[09:32:36.307]  elements: ‘a’, ‘b’, ‘’
[09:32:36.307] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.307] - Validating connection of MultisessionFuture
[09:32:36.307] - received message: FutureResult
[09:32:36.307] - Received FutureResult
[09:32:36.308] - Erased future from FutureRegistry
[09:32:36.308] result() for ClusterFuture ...
[09:32:36.308] - result already collected: FutureResult
[09:32:36.308] result() for ClusterFuture ... done
[09:32:36.308] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.308] Future #1
[09:32:36.308]  length: 2 (resolved future 1)
[09:32:36.309] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.309] - Validating connection of MultisessionFuture
[09:32:36.309] - received message: FutureResult
[09:32:36.309] - Received FutureResult
[09:32:36.309] - Erased future from FutureRegistry
[09:32:36.309] result() for ClusterFuture ...
[09:32:36.309] - result already collected: FutureResult
[09:32:36.309] result() for ClusterFuture ... done
[09:32:36.309] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.309] Future #2
[09:32:36.310]  length: 1 (resolved future 2)
[09:32:36.310]  length: 0 (resolved future 3)
[09:32:36.310] resolve() on list ... DONE
[09:32:36.310] getGlobalsAndPackages() ...
[09:32:36.310] Searching for globals...
[09:32:36.310] 
[09:32:36.310] Searching for globals ... DONE
[09:32:36.310] - globals: [0] <none>
[09:32:36.310] getGlobalsAndPackages() ... DONE
[09:32:36.311] getGlobalsAndPackages() ...
[09:32:36.311] Searching for globals...
[09:32:36.311] 
[09:32:36.311] Searching for globals ... DONE
[09:32:36.311] - globals: [0] <none>
[09:32:36.311] getGlobalsAndPackages() ... DONE
[09:32:36.311] run() for ‘Future’ ...
[09:32:36.312] - state: ‘created’
[09:32:36.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.325]   - Field: ‘node’
[09:32:36.325]   - Field: ‘label’
[09:32:36.326]   - Field: ‘local’
[09:32:36.326]   - Field: ‘owner’
[09:32:36.326]   - Field: ‘envir’
[09:32:36.326]   - Field: ‘workers’
[09:32:36.326]   - Field: ‘packages’
[09:32:36.326]   - Field: ‘gc’
[09:32:36.326]   - Field: ‘conditions’
[09:32:36.326]   - Field: ‘persistent’
[09:32:36.326]   - Field: ‘expr’
[09:32:36.326]   - Field: ‘uuid’
[09:32:36.326]   - Field: ‘seed’
[09:32:36.327]   - Field: ‘version’
[09:32:36.327]   - Field: ‘result’
[09:32:36.327]   - Field: ‘asynchronous’
[09:32:36.327]   - Field: ‘calls’
[09:32:36.327]   - Field: ‘globals’
[09:32:36.327]   - Field: ‘stdout’
[09:32:36.327]   - Field: ‘earlySignal’
[09:32:36.327]   - Field: ‘lazy’
[09:32:36.327]   - Field: ‘state’
[09:32:36.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.327] - Launch lazy future ...
[09:32:36.328] Packages needed by the future expression (n = 0): <none>
[09:32:36.328] Packages needed by future strategies (n = 0): <none>
[09:32:36.328] {
[09:32:36.328]     {
[09:32:36.328]         {
[09:32:36.328]             ...future.startTime <- base::Sys.time()
[09:32:36.328]             {
[09:32:36.328]                 {
[09:32:36.328]                   {
[09:32:36.328]                     {
[09:32:36.328]                       base::local({
[09:32:36.328]                         has_future <- base::requireNamespace("future", 
[09:32:36.328]                           quietly = TRUE)
[09:32:36.328]                         if (has_future) {
[09:32:36.328]                           ns <- base::getNamespace("future")
[09:32:36.328]                           version <- ns[[".package"]][["version"]]
[09:32:36.328]                           if (is.null(version)) 
[09:32:36.328]                             version <- utils::packageVersion("future")
[09:32:36.328]                         }
[09:32:36.328]                         else {
[09:32:36.328]                           version <- NULL
[09:32:36.328]                         }
[09:32:36.328]                         if (!has_future || version < "1.8.0") {
[09:32:36.328]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.328]                             "", base::R.version$version.string), 
[09:32:36.328]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.328]                               "release", "version")], collapse = " "), 
[09:32:36.328]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.328]                             info)
[09:32:36.328]                           info <- base::paste(info, collapse = "; ")
[09:32:36.328]                           if (!has_future) {
[09:32:36.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.328]                               info)
[09:32:36.328]                           }
[09:32:36.328]                           else {
[09:32:36.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.328]                               info, version)
[09:32:36.328]                           }
[09:32:36.328]                           base::stop(msg)
[09:32:36.328]                         }
[09:32:36.328]                       })
[09:32:36.328]                     }
[09:32:36.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.328]                     base::options(mc.cores = 1L)
[09:32:36.328]                   }
[09:32:36.328]                   ...future.strategy.old <- future::plan("list")
[09:32:36.328]                   options(future.plan = NULL)
[09:32:36.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.328]                 }
[09:32:36.328]                 ...future.workdir <- getwd()
[09:32:36.328]             }
[09:32:36.328]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.328]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.328]         }
[09:32:36.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.328]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.328]             base::names(...future.oldOptions))
[09:32:36.328]     }
[09:32:36.328]     if (FALSE) {
[09:32:36.328]     }
[09:32:36.328]     else {
[09:32:36.328]         if (TRUE) {
[09:32:36.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.328]                 open = "w")
[09:32:36.328]         }
[09:32:36.328]         else {
[09:32:36.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.328]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.328]         }
[09:32:36.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.328]             base::sink(type = "output", split = FALSE)
[09:32:36.328]             base::close(...future.stdout)
[09:32:36.328]         }, add = TRUE)
[09:32:36.328]     }
[09:32:36.328]     ...future.frame <- base::sys.nframe()
[09:32:36.328]     ...future.conditions <- base::list()
[09:32:36.328]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.328]     if (FALSE) {
[09:32:36.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.328]     }
[09:32:36.328]     ...future.result <- base::tryCatch({
[09:32:36.328]         base::withCallingHandlers({
[09:32:36.328]             ...future.value <- base::withVisible(base::local({
[09:32:36.328]                 ...future.makeSendCondition <- base::local({
[09:32:36.328]                   sendCondition <- NULL
[09:32:36.328]                   function(frame = 1L) {
[09:32:36.328]                     if (is.function(sendCondition)) 
[09:32:36.328]                       return(sendCondition)
[09:32:36.328]                     ns <- getNamespace("parallel")
[09:32:36.328]                     if (exists("sendData", mode = "function", 
[09:32:36.328]                       envir = ns)) {
[09:32:36.328]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.328]                         envir = ns)
[09:32:36.328]                       envir <- sys.frame(frame)
[09:32:36.328]                       master <- NULL
[09:32:36.328]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.328]                         !identical(envir, emptyenv())) {
[09:32:36.328]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.328]                           inherits = FALSE)) {
[09:32:36.328]                           master <- get("master", mode = "list", 
[09:32:36.328]                             envir = envir, inherits = FALSE)
[09:32:36.328]                           if (inherits(master, c("SOCKnode", 
[09:32:36.328]                             "SOCK0node"))) {
[09:32:36.328]                             sendCondition <<- function(cond) {
[09:32:36.328]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.328]                                 success = TRUE)
[09:32:36.328]                               parallel_sendData(master, data)
[09:32:36.328]                             }
[09:32:36.328]                             return(sendCondition)
[09:32:36.328]                           }
[09:32:36.328]                         }
[09:32:36.328]                         frame <- frame + 1L
[09:32:36.328]                         envir <- sys.frame(frame)
[09:32:36.328]                       }
[09:32:36.328]                     }
[09:32:36.328]                     sendCondition <<- function(cond) NULL
[09:32:36.328]                   }
[09:32:36.328]                 })
[09:32:36.328]                 withCallingHandlers({
[09:32:36.328]                   2
[09:32:36.328]                 }, immediateCondition = function(cond) {
[09:32:36.328]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.328]                   sendCondition(cond)
[09:32:36.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.328]                   {
[09:32:36.328]                     inherits <- base::inherits
[09:32:36.328]                     invokeRestart <- base::invokeRestart
[09:32:36.328]                     is.null <- base::is.null
[09:32:36.328]                     muffled <- FALSE
[09:32:36.328]                     if (inherits(cond, "message")) {
[09:32:36.328]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.328]                       if (muffled) 
[09:32:36.328]                         invokeRestart("muffleMessage")
[09:32:36.328]                     }
[09:32:36.328]                     else if (inherits(cond, "warning")) {
[09:32:36.328]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.328]                       if (muffled) 
[09:32:36.328]                         invokeRestart("muffleWarning")
[09:32:36.328]                     }
[09:32:36.328]                     else if (inherits(cond, "condition")) {
[09:32:36.328]                       if (!is.null(pattern)) {
[09:32:36.328]                         computeRestarts <- base::computeRestarts
[09:32:36.328]                         grepl <- base::grepl
[09:32:36.328]                         restarts <- computeRestarts(cond)
[09:32:36.328]                         for (restart in restarts) {
[09:32:36.328]                           name <- restart$name
[09:32:36.328]                           if (is.null(name)) 
[09:32:36.328]                             next
[09:32:36.328]                           if (!grepl(pattern, name)) 
[09:32:36.328]                             next
[09:32:36.328]                           invokeRestart(restart)
[09:32:36.328]                           muffled <- TRUE
[09:32:36.328]                           break
[09:32:36.328]                         }
[09:32:36.328]                       }
[09:32:36.328]                     }
[09:32:36.328]                     invisible(muffled)
[09:32:36.328]                   }
[09:32:36.328]                   muffleCondition(cond)
[09:32:36.328]                 })
[09:32:36.328]             }))
[09:32:36.328]             future::FutureResult(value = ...future.value$value, 
[09:32:36.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.328]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.328]                     ...future.globalenv.names))
[09:32:36.328]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.328]         }, condition = base::local({
[09:32:36.328]             c <- base::c
[09:32:36.328]             inherits <- base::inherits
[09:32:36.328]             invokeRestart <- base::invokeRestart
[09:32:36.328]             length <- base::length
[09:32:36.328]             list <- base::list
[09:32:36.328]             seq.int <- base::seq.int
[09:32:36.328]             signalCondition <- base::signalCondition
[09:32:36.328]             sys.calls <- base::sys.calls
[09:32:36.328]             `[[` <- base::`[[`
[09:32:36.328]             `+` <- base::`+`
[09:32:36.328]             `<<-` <- base::`<<-`
[09:32:36.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.328]                   3L)]
[09:32:36.328]             }
[09:32:36.328]             function(cond) {
[09:32:36.328]                 is_error <- inherits(cond, "error")
[09:32:36.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.328]                   NULL)
[09:32:36.328]                 if (is_error) {
[09:32:36.328]                   sessionInformation <- function() {
[09:32:36.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.328]                       search = base::search(), system = base::Sys.info())
[09:32:36.328]                   }
[09:32:36.328]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.328]                     cond$call), session = sessionInformation(), 
[09:32:36.328]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.328]                   signalCondition(cond)
[09:32:36.328]                 }
[09:32:36.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.328]                 "immediateCondition"))) {
[09:32:36.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.328]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.328]                   if (TRUE && !signal) {
[09:32:36.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.328]                     {
[09:32:36.328]                       inherits <- base::inherits
[09:32:36.328]                       invokeRestart <- base::invokeRestart
[09:32:36.328]                       is.null <- base::is.null
[09:32:36.328]                       muffled <- FALSE
[09:32:36.328]                       if (inherits(cond, "message")) {
[09:32:36.328]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.328]                         if (muffled) 
[09:32:36.328]                           invokeRestart("muffleMessage")
[09:32:36.328]                       }
[09:32:36.328]                       else if (inherits(cond, "warning")) {
[09:32:36.328]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.328]                         if (muffled) 
[09:32:36.328]                           invokeRestart("muffleWarning")
[09:32:36.328]                       }
[09:32:36.328]                       else if (inherits(cond, "condition")) {
[09:32:36.328]                         if (!is.null(pattern)) {
[09:32:36.328]                           computeRestarts <- base::computeRestarts
[09:32:36.328]                           grepl <- base::grepl
[09:32:36.328]                           restarts <- computeRestarts(cond)
[09:32:36.328]                           for (restart in restarts) {
[09:32:36.328]                             name <- restart$name
[09:32:36.328]                             if (is.null(name)) 
[09:32:36.328]                               next
[09:32:36.328]                             if (!grepl(pattern, name)) 
[09:32:36.328]                               next
[09:32:36.328]                             invokeRestart(restart)
[09:32:36.328]                             muffled <- TRUE
[09:32:36.328]                             break
[09:32:36.328]                           }
[09:32:36.328]                         }
[09:32:36.328]                       }
[09:32:36.328]                       invisible(muffled)
[09:32:36.328]                     }
[09:32:36.328]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.328]                   }
[09:32:36.328]                 }
[09:32:36.328]                 else {
[09:32:36.328]                   if (TRUE) {
[09:32:36.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.328]                     {
[09:32:36.328]                       inherits <- base::inherits
[09:32:36.328]                       invokeRestart <- base::invokeRestart
[09:32:36.328]                       is.null <- base::is.null
[09:32:36.328]                       muffled <- FALSE
[09:32:36.328]                       if (inherits(cond, "message")) {
[09:32:36.328]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.328]                         if (muffled) 
[09:32:36.328]                           invokeRestart("muffleMessage")
[09:32:36.328]                       }
[09:32:36.328]                       else if (inherits(cond, "warning")) {
[09:32:36.328]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.328]                         if (muffled) 
[09:32:36.328]                           invokeRestart("muffleWarning")
[09:32:36.328]                       }
[09:32:36.328]                       else if (inherits(cond, "condition")) {
[09:32:36.328]                         if (!is.null(pattern)) {
[09:32:36.328]                           computeRestarts <- base::computeRestarts
[09:32:36.328]                           grepl <- base::grepl
[09:32:36.328]                           restarts <- computeRestarts(cond)
[09:32:36.328]                           for (restart in restarts) {
[09:32:36.328]                             name <- restart$name
[09:32:36.328]                             if (is.null(name)) 
[09:32:36.328]                               next
[09:32:36.328]                             if (!grepl(pattern, name)) 
[09:32:36.328]                               next
[09:32:36.328]                             invokeRestart(restart)
[09:32:36.328]                             muffled <- TRUE
[09:32:36.328]                             break
[09:32:36.328]                           }
[09:32:36.328]                         }
[09:32:36.328]                       }
[09:32:36.328]                       invisible(muffled)
[09:32:36.328]                     }
[09:32:36.328]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.328]                   }
[09:32:36.328]                 }
[09:32:36.328]             }
[09:32:36.328]         }))
[09:32:36.328]     }, error = function(ex) {
[09:32:36.328]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.328]                 ...future.rng), started = ...future.startTime, 
[09:32:36.328]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.328]             version = "1.8"), class = "FutureResult")
[09:32:36.328]     }, finally = {
[09:32:36.328]         if (!identical(...future.workdir, getwd())) 
[09:32:36.328]             setwd(...future.workdir)
[09:32:36.328]         {
[09:32:36.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.328]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.328]             }
[09:32:36.328]             base::options(...future.oldOptions)
[09:32:36.328]             if (.Platform$OS.type == "windows") {
[09:32:36.328]                 old_names <- names(...future.oldEnvVars)
[09:32:36.328]                 envs <- base::Sys.getenv()
[09:32:36.328]                 names <- names(envs)
[09:32:36.328]                 common <- intersect(names, old_names)
[09:32:36.328]                 added <- setdiff(names, old_names)
[09:32:36.328]                 removed <- setdiff(old_names, names)
[09:32:36.328]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.328]                   envs[common]]
[09:32:36.328]                 NAMES <- toupper(changed)
[09:32:36.328]                 args <- list()
[09:32:36.328]                 for (kk in seq_along(NAMES)) {
[09:32:36.328]                   name <- changed[[kk]]
[09:32:36.328]                   NAME <- NAMES[[kk]]
[09:32:36.328]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.328]                     next
[09:32:36.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.328]                 }
[09:32:36.328]                 NAMES <- toupper(added)
[09:32:36.328]                 for (kk in seq_along(NAMES)) {
[09:32:36.328]                   name <- added[[kk]]
[09:32:36.328]                   NAME <- NAMES[[kk]]
[09:32:36.328]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.328]                     next
[09:32:36.328]                   args[[name]] <- ""
[09:32:36.328]                 }
[09:32:36.328]                 NAMES <- toupper(removed)
[09:32:36.328]                 for (kk in seq_along(NAMES)) {
[09:32:36.328]                   name <- removed[[kk]]
[09:32:36.328]                   NAME <- NAMES[[kk]]
[09:32:36.328]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.328]                     next
[09:32:36.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.328]                 }
[09:32:36.328]                 if (length(args) > 0) 
[09:32:36.328]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.328]             }
[09:32:36.328]             else {
[09:32:36.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.328]             }
[09:32:36.328]             {
[09:32:36.328]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.328]                   0L) {
[09:32:36.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.328]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.328]                   base::options(opts)
[09:32:36.328]                 }
[09:32:36.328]                 {
[09:32:36.328]                   {
[09:32:36.328]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.328]                     NULL
[09:32:36.328]                   }
[09:32:36.328]                   options(future.plan = NULL)
[09:32:36.328]                   if (is.na(NA_character_)) 
[09:32:36.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.328]                     .init = FALSE)
[09:32:36.328]                 }
[09:32:36.328]             }
[09:32:36.328]         }
[09:32:36.328]     })
[09:32:36.328]     if (TRUE) {
[09:32:36.328]         base::sink(type = "output", split = FALSE)
[09:32:36.328]         if (TRUE) {
[09:32:36.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.328]         }
[09:32:36.328]         else {
[09:32:36.328]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.328]         }
[09:32:36.328]         base::close(...future.stdout)
[09:32:36.328]         ...future.stdout <- NULL
[09:32:36.328]     }
[09:32:36.328]     ...future.result$conditions <- ...future.conditions
[09:32:36.328]     ...future.result$finished <- base::Sys.time()
[09:32:36.328]     ...future.result
[09:32:36.328] }
[09:32:36.331] MultisessionFuture started
[09:32:36.331] - Launch lazy future ... done
[09:32:36.331] run() for ‘MultisessionFuture’ ... done
[09:32:36.331] resolve() on list ...
[09:32:36.331]  recursive: 0
[09:32:36.331]  length: 3
[09:32:36.332]  elements: ‘a’, ‘b’, ‘’
[09:32:36.332] run() for ‘Future’ ...
[09:32:36.332] - state: ‘created’
[09:32:36.332] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.345] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.346]   - Field: ‘node’
[09:32:36.346]   - Field: ‘label’
[09:32:36.346]   - Field: ‘local’
[09:32:36.346]   - Field: ‘owner’
[09:32:36.346]   - Field: ‘envir’
[09:32:36.346]   - Field: ‘workers’
[09:32:36.346]   - Field: ‘packages’
[09:32:36.346]   - Field: ‘gc’
[09:32:36.346]   - Field: ‘conditions’
[09:32:36.347]   - Field: ‘persistent’
[09:32:36.347]   - Field: ‘expr’
[09:32:36.347]   - Field: ‘uuid’
[09:32:36.347]   - Field: ‘seed’
[09:32:36.347]   - Field: ‘version’
[09:32:36.347]   - Field: ‘result’
[09:32:36.347]   - Field: ‘asynchronous’
[09:32:36.347]   - Field: ‘calls’
[09:32:36.347]   - Field: ‘globals’
[09:32:36.347]   - Field: ‘stdout’
[09:32:36.347]   - Field: ‘earlySignal’
[09:32:36.347]   - Field: ‘lazy’
[09:32:36.348]   - Field: ‘state’
[09:32:36.348] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.348] - Launch lazy future ...
[09:32:36.348] Packages needed by the future expression (n = 0): <none>
[09:32:36.348] Packages needed by future strategies (n = 0): <none>
[09:32:36.349] {
[09:32:36.349]     {
[09:32:36.349]         {
[09:32:36.349]             ...future.startTime <- base::Sys.time()
[09:32:36.349]             {
[09:32:36.349]                 {
[09:32:36.349]                   {
[09:32:36.349]                     {
[09:32:36.349]                       base::local({
[09:32:36.349]                         has_future <- base::requireNamespace("future", 
[09:32:36.349]                           quietly = TRUE)
[09:32:36.349]                         if (has_future) {
[09:32:36.349]                           ns <- base::getNamespace("future")
[09:32:36.349]                           version <- ns[[".package"]][["version"]]
[09:32:36.349]                           if (is.null(version)) 
[09:32:36.349]                             version <- utils::packageVersion("future")
[09:32:36.349]                         }
[09:32:36.349]                         else {
[09:32:36.349]                           version <- NULL
[09:32:36.349]                         }
[09:32:36.349]                         if (!has_future || version < "1.8.0") {
[09:32:36.349]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.349]                             "", base::R.version$version.string), 
[09:32:36.349]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.349]                               "release", "version")], collapse = " "), 
[09:32:36.349]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.349]                             info)
[09:32:36.349]                           info <- base::paste(info, collapse = "; ")
[09:32:36.349]                           if (!has_future) {
[09:32:36.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.349]                               info)
[09:32:36.349]                           }
[09:32:36.349]                           else {
[09:32:36.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.349]                               info, version)
[09:32:36.349]                           }
[09:32:36.349]                           base::stop(msg)
[09:32:36.349]                         }
[09:32:36.349]                       })
[09:32:36.349]                     }
[09:32:36.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.349]                     base::options(mc.cores = 1L)
[09:32:36.349]                   }
[09:32:36.349]                   ...future.strategy.old <- future::plan("list")
[09:32:36.349]                   options(future.plan = NULL)
[09:32:36.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.349]                 }
[09:32:36.349]                 ...future.workdir <- getwd()
[09:32:36.349]             }
[09:32:36.349]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.349]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.349]         }
[09:32:36.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.349]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.349]             base::names(...future.oldOptions))
[09:32:36.349]     }
[09:32:36.349]     if (FALSE) {
[09:32:36.349]     }
[09:32:36.349]     else {
[09:32:36.349]         if (TRUE) {
[09:32:36.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.349]                 open = "w")
[09:32:36.349]         }
[09:32:36.349]         else {
[09:32:36.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.349]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.349]         }
[09:32:36.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.349]             base::sink(type = "output", split = FALSE)
[09:32:36.349]             base::close(...future.stdout)
[09:32:36.349]         }, add = TRUE)
[09:32:36.349]     }
[09:32:36.349]     ...future.frame <- base::sys.nframe()
[09:32:36.349]     ...future.conditions <- base::list()
[09:32:36.349]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.349]     if (FALSE) {
[09:32:36.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.349]     }
[09:32:36.349]     ...future.result <- base::tryCatch({
[09:32:36.349]         base::withCallingHandlers({
[09:32:36.349]             ...future.value <- base::withVisible(base::local({
[09:32:36.349]                 ...future.makeSendCondition <- base::local({
[09:32:36.349]                   sendCondition <- NULL
[09:32:36.349]                   function(frame = 1L) {
[09:32:36.349]                     if (is.function(sendCondition)) 
[09:32:36.349]                       return(sendCondition)
[09:32:36.349]                     ns <- getNamespace("parallel")
[09:32:36.349]                     if (exists("sendData", mode = "function", 
[09:32:36.349]                       envir = ns)) {
[09:32:36.349]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.349]                         envir = ns)
[09:32:36.349]                       envir <- sys.frame(frame)
[09:32:36.349]                       master <- NULL
[09:32:36.349]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.349]                         !identical(envir, emptyenv())) {
[09:32:36.349]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.349]                           inherits = FALSE)) {
[09:32:36.349]                           master <- get("master", mode = "list", 
[09:32:36.349]                             envir = envir, inherits = FALSE)
[09:32:36.349]                           if (inherits(master, c("SOCKnode", 
[09:32:36.349]                             "SOCK0node"))) {
[09:32:36.349]                             sendCondition <<- function(cond) {
[09:32:36.349]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.349]                                 success = TRUE)
[09:32:36.349]                               parallel_sendData(master, data)
[09:32:36.349]                             }
[09:32:36.349]                             return(sendCondition)
[09:32:36.349]                           }
[09:32:36.349]                         }
[09:32:36.349]                         frame <- frame + 1L
[09:32:36.349]                         envir <- sys.frame(frame)
[09:32:36.349]                       }
[09:32:36.349]                     }
[09:32:36.349]                     sendCondition <<- function(cond) NULL
[09:32:36.349]                   }
[09:32:36.349]                 })
[09:32:36.349]                 withCallingHandlers({
[09:32:36.349]                   1
[09:32:36.349]                 }, immediateCondition = function(cond) {
[09:32:36.349]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.349]                   sendCondition(cond)
[09:32:36.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.349]                   {
[09:32:36.349]                     inherits <- base::inherits
[09:32:36.349]                     invokeRestart <- base::invokeRestart
[09:32:36.349]                     is.null <- base::is.null
[09:32:36.349]                     muffled <- FALSE
[09:32:36.349]                     if (inherits(cond, "message")) {
[09:32:36.349]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.349]                       if (muffled) 
[09:32:36.349]                         invokeRestart("muffleMessage")
[09:32:36.349]                     }
[09:32:36.349]                     else if (inherits(cond, "warning")) {
[09:32:36.349]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.349]                       if (muffled) 
[09:32:36.349]                         invokeRestart("muffleWarning")
[09:32:36.349]                     }
[09:32:36.349]                     else if (inherits(cond, "condition")) {
[09:32:36.349]                       if (!is.null(pattern)) {
[09:32:36.349]                         computeRestarts <- base::computeRestarts
[09:32:36.349]                         grepl <- base::grepl
[09:32:36.349]                         restarts <- computeRestarts(cond)
[09:32:36.349]                         for (restart in restarts) {
[09:32:36.349]                           name <- restart$name
[09:32:36.349]                           if (is.null(name)) 
[09:32:36.349]                             next
[09:32:36.349]                           if (!grepl(pattern, name)) 
[09:32:36.349]                             next
[09:32:36.349]                           invokeRestart(restart)
[09:32:36.349]                           muffled <- TRUE
[09:32:36.349]                           break
[09:32:36.349]                         }
[09:32:36.349]                       }
[09:32:36.349]                     }
[09:32:36.349]                     invisible(muffled)
[09:32:36.349]                   }
[09:32:36.349]                   muffleCondition(cond)
[09:32:36.349]                 })
[09:32:36.349]             }))
[09:32:36.349]             future::FutureResult(value = ...future.value$value, 
[09:32:36.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.349]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.349]                     ...future.globalenv.names))
[09:32:36.349]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.349]         }, condition = base::local({
[09:32:36.349]             c <- base::c
[09:32:36.349]             inherits <- base::inherits
[09:32:36.349]             invokeRestart <- base::invokeRestart
[09:32:36.349]             length <- base::length
[09:32:36.349]             list <- base::list
[09:32:36.349]             seq.int <- base::seq.int
[09:32:36.349]             signalCondition <- base::signalCondition
[09:32:36.349]             sys.calls <- base::sys.calls
[09:32:36.349]             `[[` <- base::`[[`
[09:32:36.349]             `+` <- base::`+`
[09:32:36.349]             `<<-` <- base::`<<-`
[09:32:36.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.349]                   3L)]
[09:32:36.349]             }
[09:32:36.349]             function(cond) {
[09:32:36.349]                 is_error <- inherits(cond, "error")
[09:32:36.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.349]                   NULL)
[09:32:36.349]                 if (is_error) {
[09:32:36.349]                   sessionInformation <- function() {
[09:32:36.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.349]                       search = base::search(), system = base::Sys.info())
[09:32:36.349]                   }
[09:32:36.349]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.349]                     cond$call), session = sessionInformation(), 
[09:32:36.349]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.349]                   signalCondition(cond)
[09:32:36.349]                 }
[09:32:36.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.349]                 "immediateCondition"))) {
[09:32:36.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.349]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.349]                   if (TRUE && !signal) {
[09:32:36.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.349]                     {
[09:32:36.349]                       inherits <- base::inherits
[09:32:36.349]                       invokeRestart <- base::invokeRestart
[09:32:36.349]                       is.null <- base::is.null
[09:32:36.349]                       muffled <- FALSE
[09:32:36.349]                       if (inherits(cond, "message")) {
[09:32:36.349]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.349]                         if (muffled) 
[09:32:36.349]                           invokeRestart("muffleMessage")
[09:32:36.349]                       }
[09:32:36.349]                       else if (inherits(cond, "warning")) {
[09:32:36.349]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.349]                         if (muffled) 
[09:32:36.349]                           invokeRestart("muffleWarning")
[09:32:36.349]                       }
[09:32:36.349]                       else if (inherits(cond, "condition")) {
[09:32:36.349]                         if (!is.null(pattern)) {
[09:32:36.349]                           computeRestarts <- base::computeRestarts
[09:32:36.349]                           grepl <- base::grepl
[09:32:36.349]                           restarts <- computeRestarts(cond)
[09:32:36.349]                           for (restart in restarts) {
[09:32:36.349]                             name <- restart$name
[09:32:36.349]                             if (is.null(name)) 
[09:32:36.349]                               next
[09:32:36.349]                             if (!grepl(pattern, name)) 
[09:32:36.349]                               next
[09:32:36.349]                             invokeRestart(restart)
[09:32:36.349]                             muffled <- TRUE
[09:32:36.349]                             break
[09:32:36.349]                           }
[09:32:36.349]                         }
[09:32:36.349]                       }
[09:32:36.349]                       invisible(muffled)
[09:32:36.349]                     }
[09:32:36.349]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.349]                   }
[09:32:36.349]                 }
[09:32:36.349]                 else {
[09:32:36.349]                   if (TRUE) {
[09:32:36.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.349]                     {
[09:32:36.349]                       inherits <- base::inherits
[09:32:36.349]                       invokeRestart <- base::invokeRestart
[09:32:36.349]                       is.null <- base::is.null
[09:32:36.349]                       muffled <- FALSE
[09:32:36.349]                       if (inherits(cond, "message")) {
[09:32:36.349]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.349]                         if (muffled) 
[09:32:36.349]                           invokeRestart("muffleMessage")
[09:32:36.349]                       }
[09:32:36.349]                       else if (inherits(cond, "warning")) {
[09:32:36.349]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.349]                         if (muffled) 
[09:32:36.349]                           invokeRestart("muffleWarning")
[09:32:36.349]                       }
[09:32:36.349]                       else if (inherits(cond, "condition")) {
[09:32:36.349]                         if (!is.null(pattern)) {
[09:32:36.349]                           computeRestarts <- base::computeRestarts
[09:32:36.349]                           grepl <- base::grepl
[09:32:36.349]                           restarts <- computeRestarts(cond)
[09:32:36.349]                           for (restart in restarts) {
[09:32:36.349]                             name <- restart$name
[09:32:36.349]                             if (is.null(name)) 
[09:32:36.349]                               next
[09:32:36.349]                             if (!grepl(pattern, name)) 
[09:32:36.349]                               next
[09:32:36.349]                             invokeRestart(restart)
[09:32:36.349]                             muffled <- TRUE
[09:32:36.349]                             break
[09:32:36.349]                           }
[09:32:36.349]                         }
[09:32:36.349]                       }
[09:32:36.349]                       invisible(muffled)
[09:32:36.349]                     }
[09:32:36.349]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.349]                   }
[09:32:36.349]                 }
[09:32:36.349]             }
[09:32:36.349]         }))
[09:32:36.349]     }, error = function(ex) {
[09:32:36.349]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.349]                 ...future.rng), started = ...future.startTime, 
[09:32:36.349]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.349]             version = "1.8"), class = "FutureResult")
[09:32:36.349]     }, finally = {
[09:32:36.349]         if (!identical(...future.workdir, getwd())) 
[09:32:36.349]             setwd(...future.workdir)
[09:32:36.349]         {
[09:32:36.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.349]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.349]             }
[09:32:36.349]             base::options(...future.oldOptions)
[09:32:36.349]             if (.Platform$OS.type == "windows") {
[09:32:36.349]                 old_names <- names(...future.oldEnvVars)
[09:32:36.349]                 envs <- base::Sys.getenv()
[09:32:36.349]                 names <- names(envs)
[09:32:36.349]                 common <- intersect(names, old_names)
[09:32:36.349]                 added <- setdiff(names, old_names)
[09:32:36.349]                 removed <- setdiff(old_names, names)
[09:32:36.349]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.349]                   envs[common]]
[09:32:36.349]                 NAMES <- toupper(changed)
[09:32:36.349]                 args <- list()
[09:32:36.349]                 for (kk in seq_along(NAMES)) {
[09:32:36.349]                   name <- changed[[kk]]
[09:32:36.349]                   NAME <- NAMES[[kk]]
[09:32:36.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.349]                     next
[09:32:36.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.349]                 }
[09:32:36.349]                 NAMES <- toupper(added)
[09:32:36.349]                 for (kk in seq_along(NAMES)) {
[09:32:36.349]                   name <- added[[kk]]
[09:32:36.349]                   NAME <- NAMES[[kk]]
[09:32:36.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.349]                     next
[09:32:36.349]                   args[[name]] <- ""
[09:32:36.349]                 }
[09:32:36.349]                 NAMES <- toupper(removed)
[09:32:36.349]                 for (kk in seq_along(NAMES)) {
[09:32:36.349]                   name <- removed[[kk]]
[09:32:36.349]                   NAME <- NAMES[[kk]]
[09:32:36.349]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.349]                     next
[09:32:36.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.349]                 }
[09:32:36.349]                 if (length(args) > 0) 
[09:32:36.349]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.349]             }
[09:32:36.349]             else {
[09:32:36.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.349]             }
[09:32:36.349]             {
[09:32:36.349]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.349]                   0L) {
[09:32:36.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.349]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.349]                   base::options(opts)
[09:32:36.349]                 }
[09:32:36.349]                 {
[09:32:36.349]                   {
[09:32:36.349]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.349]                     NULL
[09:32:36.349]                   }
[09:32:36.349]                   options(future.plan = NULL)
[09:32:36.349]                   if (is.na(NA_character_)) 
[09:32:36.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.349]                     .init = FALSE)
[09:32:36.349]                 }
[09:32:36.349]             }
[09:32:36.349]         }
[09:32:36.349]     })
[09:32:36.349]     if (TRUE) {
[09:32:36.349]         base::sink(type = "output", split = FALSE)
[09:32:36.349]         if (TRUE) {
[09:32:36.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.349]         }
[09:32:36.349]         else {
[09:32:36.349]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.349]         }
[09:32:36.349]         base::close(...future.stdout)
[09:32:36.349]         ...future.stdout <- NULL
[09:32:36.349]     }
[09:32:36.349]     ...future.result$conditions <- ...future.conditions
[09:32:36.349]     ...future.result$finished <- base::Sys.time()
[09:32:36.349]     ...future.result
[09:32:36.349] }
[09:32:36.351] MultisessionFuture started
[09:32:36.351] - Launch lazy future ... done
[09:32:36.352] run() for ‘MultisessionFuture’ ... done
[09:32:36.353] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.353] - Validating connection of MultisessionFuture
[09:32:36.353] - received message: FutureResult
[09:32:36.353] - Received FutureResult
[09:32:36.353] - Erased future from FutureRegistry
[09:32:36.353] result() for ClusterFuture ...
[09:32:36.353] - result already collected: FutureResult
[09:32:36.353] result() for ClusterFuture ... done
[09:32:36.354] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.354] Future #1
[09:32:36.354]  length: 2 (resolved future 1)
[09:32:36.354] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.354] - Validating connection of MultisessionFuture
[09:32:36.354] - received message: FutureResult
[09:32:36.355] - Received FutureResult
[09:32:36.355] - Erased future from FutureRegistry
[09:32:36.355] result() for ClusterFuture ...
[09:32:36.355] - result already collected: FutureResult
[09:32:36.355] result() for ClusterFuture ... done
[09:32:36.355] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.355] Future #2
[09:32:36.355]  length: 1 (resolved future 2)
[09:32:36.355]  length: 0 (resolved future 3)
[09:32:36.355] resolve() on list ... DONE
[09:32:36.356] getGlobalsAndPackages() ...
[09:32:36.356] Searching for globals...
[09:32:36.356] 
[09:32:36.356] Searching for globals ... DONE
[09:32:36.356] - globals: [0] <none>
[09:32:36.356] getGlobalsAndPackages() ... DONE
[09:32:36.356] getGlobalsAndPackages() ...
[09:32:36.357] Searching for globals...
[09:32:36.357] 
[09:32:36.357] Searching for globals ... DONE
[09:32:36.357] - globals: [0] <none>
[09:32:36.357] getGlobalsAndPackages() ... DONE
[09:32:36.357] resolve() on list ...
[09:32:36.357]  recursive: 0
[09:32:36.357]  length: 3
[09:32:36.358]  elements: ‘a’, ‘b’, ‘’
[09:32:36.358] run() for ‘Future’ ...
[09:32:36.358] - state: ‘created’
[09:32:36.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.371]   - Field: ‘node’
[09:32:36.371]   - Field: ‘label’
[09:32:36.371]   - Field: ‘local’
[09:32:36.372]   - Field: ‘owner’
[09:32:36.372]   - Field: ‘envir’
[09:32:36.372]   - Field: ‘workers’
[09:32:36.372]   - Field: ‘packages’
[09:32:36.372]   - Field: ‘gc’
[09:32:36.372]   - Field: ‘conditions’
[09:32:36.372]   - Field: ‘persistent’
[09:32:36.372]   - Field: ‘expr’
[09:32:36.372]   - Field: ‘uuid’
[09:32:36.372]   - Field: ‘seed’
[09:32:36.372]   - Field: ‘version’
[09:32:36.373]   - Field: ‘result’
[09:32:36.373]   - Field: ‘asynchronous’
[09:32:36.373]   - Field: ‘calls’
[09:32:36.373]   - Field: ‘globals’
[09:32:36.373]   - Field: ‘stdout’
[09:32:36.373]   - Field: ‘earlySignal’
[09:32:36.373]   - Field: ‘lazy’
[09:32:36.373]   - Field: ‘state’
[09:32:36.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.373] - Launch lazy future ...
[09:32:36.374] Packages needed by the future expression (n = 0): <none>
[09:32:36.374] Packages needed by future strategies (n = 0): <none>
[09:32:36.374] {
[09:32:36.374]     {
[09:32:36.374]         {
[09:32:36.374]             ...future.startTime <- base::Sys.time()
[09:32:36.374]             {
[09:32:36.374]                 {
[09:32:36.374]                   {
[09:32:36.374]                     {
[09:32:36.374]                       base::local({
[09:32:36.374]                         has_future <- base::requireNamespace("future", 
[09:32:36.374]                           quietly = TRUE)
[09:32:36.374]                         if (has_future) {
[09:32:36.374]                           ns <- base::getNamespace("future")
[09:32:36.374]                           version <- ns[[".package"]][["version"]]
[09:32:36.374]                           if (is.null(version)) 
[09:32:36.374]                             version <- utils::packageVersion("future")
[09:32:36.374]                         }
[09:32:36.374]                         else {
[09:32:36.374]                           version <- NULL
[09:32:36.374]                         }
[09:32:36.374]                         if (!has_future || version < "1.8.0") {
[09:32:36.374]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.374]                             "", base::R.version$version.string), 
[09:32:36.374]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.374]                               "release", "version")], collapse = " "), 
[09:32:36.374]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.374]                             info)
[09:32:36.374]                           info <- base::paste(info, collapse = "; ")
[09:32:36.374]                           if (!has_future) {
[09:32:36.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.374]                               info)
[09:32:36.374]                           }
[09:32:36.374]                           else {
[09:32:36.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.374]                               info, version)
[09:32:36.374]                           }
[09:32:36.374]                           base::stop(msg)
[09:32:36.374]                         }
[09:32:36.374]                       })
[09:32:36.374]                     }
[09:32:36.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.374]                     base::options(mc.cores = 1L)
[09:32:36.374]                   }
[09:32:36.374]                   ...future.strategy.old <- future::plan("list")
[09:32:36.374]                   options(future.plan = NULL)
[09:32:36.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.374]                 }
[09:32:36.374]                 ...future.workdir <- getwd()
[09:32:36.374]             }
[09:32:36.374]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.374]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.374]         }
[09:32:36.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.374]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.374]             base::names(...future.oldOptions))
[09:32:36.374]     }
[09:32:36.374]     if (FALSE) {
[09:32:36.374]     }
[09:32:36.374]     else {
[09:32:36.374]         if (TRUE) {
[09:32:36.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.374]                 open = "w")
[09:32:36.374]         }
[09:32:36.374]         else {
[09:32:36.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.374]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.374]         }
[09:32:36.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.374]             base::sink(type = "output", split = FALSE)
[09:32:36.374]             base::close(...future.stdout)
[09:32:36.374]         }, add = TRUE)
[09:32:36.374]     }
[09:32:36.374]     ...future.frame <- base::sys.nframe()
[09:32:36.374]     ...future.conditions <- base::list()
[09:32:36.374]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.374]     if (FALSE) {
[09:32:36.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.374]     }
[09:32:36.374]     ...future.result <- base::tryCatch({
[09:32:36.374]         base::withCallingHandlers({
[09:32:36.374]             ...future.value <- base::withVisible(base::local({
[09:32:36.374]                 ...future.makeSendCondition <- base::local({
[09:32:36.374]                   sendCondition <- NULL
[09:32:36.374]                   function(frame = 1L) {
[09:32:36.374]                     if (is.function(sendCondition)) 
[09:32:36.374]                       return(sendCondition)
[09:32:36.374]                     ns <- getNamespace("parallel")
[09:32:36.374]                     if (exists("sendData", mode = "function", 
[09:32:36.374]                       envir = ns)) {
[09:32:36.374]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.374]                         envir = ns)
[09:32:36.374]                       envir <- sys.frame(frame)
[09:32:36.374]                       master <- NULL
[09:32:36.374]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.374]                         !identical(envir, emptyenv())) {
[09:32:36.374]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.374]                           inherits = FALSE)) {
[09:32:36.374]                           master <- get("master", mode = "list", 
[09:32:36.374]                             envir = envir, inherits = FALSE)
[09:32:36.374]                           if (inherits(master, c("SOCKnode", 
[09:32:36.374]                             "SOCK0node"))) {
[09:32:36.374]                             sendCondition <<- function(cond) {
[09:32:36.374]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.374]                                 success = TRUE)
[09:32:36.374]                               parallel_sendData(master, data)
[09:32:36.374]                             }
[09:32:36.374]                             return(sendCondition)
[09:32:36.374]                           }
[09:32:36.374]                         }
[09:32:36.374]                         frame <- frame + 1L
[09:32:36.374]                         envir <- sys.frame(frame)
[09:32:36.374]                       }
[09:32:36.374]                     }
[09:32:36.374]                     sendCondition <<- function(cond) NULL
[09:32:36.374]                   }
[09:32:36.374]                 })
[09:32:36.374]                 withCallingHandlers({
[09:32:36.374]                   1
[09:32:36.374]                 }, immediateCondition = function(cond) {
[09:32:36.374]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.374]                   sendCondition(cond)
[09:32:36.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.374]                   {
[09:32:36.374]                     inherits <- base::inherits
[09:32:36.374]                     invokeRestart <- base::invokeRestart
[09:32:36.374]                     is.null <- base::is.null
[09:32:36.374]                     muffled <- FALSE
[09:32:36.374]                     if (inherits(cond, "message")) {
[09:32:36.374]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.374]                       if (muffled) 
[09:32:36.374]                         invokeRestart("muffleMessage")
[09:32:36.374]                     }
[09:32:36.374]                     else if (inherits(cond, "warning")) {
[09:32:36.374]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.374]                       if (muffled) 
[09:32:36.374]                         invokeRestart("muffleWarning")
[09:32:36.374]                     }
[09:32:36.374]                     else if (inherits(cond, "condition")) {
[09:32:36.374]                       if (!is.null(pattern)) {
[09:32:36.374]                         computeRestarts <- base::computeRestarts
[09:32:36.374]                         grepl <- base::grepl
[09:32:36.374]                         restarts <- computeRestarts(cond)
[09:32:36.374]                         for (restart in restarts) {
[09:32:36.374]                           name <- restart$name
[09:32:36.374]                           if (is.null(name)) 
[09:32:36.374]                             next
[09:32:36.374]                           if (!grepl(pattern, name)) 
[09:32:36.374]                             next
[09:32:36.374]                           invokeRestart(restart)
[09:32:36.374]                           muffled <- TRUE
[09:32:36.374]                           break
[09:32:36.374]                         }
[09:32:36.374]                       }
[09:32:36.374]                     }
[09:32:36.374]                     invisible(muffled)
[09:32:36.374]                   }
[09:32:36.374]                   muffleCondition(cond)
[09:32:36.374]                 })
[09:32:36.374]             }))
[09:32:36.374]             future::FutureResult(value = ...future.value$value, 
[09:32:36.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.374]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.374]                     ...future.globalenv.names))
[09:32:36.374]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.374]         }, condition = base::local({
[09:32:36.374]             c <- base::c
[09:32:36.374]             inherits <- base::inherits
[09:32:36.374]             invokeRestart <- base::invokeRestart
[09:32:36.374]             length <- base::length
[09:32:36.374]             list <- base::list
[09:32:36.374]             seq.int <- base::seq.int
[09:32:36.374]             signalCondition <- base::signalCondition
[09:32:36.374]             sys.calls <- base::sys.calls
[09:32:36.374]             `[[` <- base::`[[`
[09:32:36.374]             `+` <- base::`+`
[09:32:36.374]             `<<-` <- base::`<<-`
[09:32:36.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.374]                   3L)]
[09:32:36.374]             }
[09:32:36.374]             function(cond) {
[09:32:36.374]                 is_error <- inherits(cond, "error")
[09:32:36.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.374]                   NULL)
[09:32:36.374]                 if (is_error) {
[09:32:36.374]                   sessionInformation <- function() {
[09:32:36.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.374]                       search = base::search(), system = base::Sys.info())
[09:32:36.374]                   }
[09:32:36.374]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.374]                     cond$call), session = sessionInformation(), 
[09:32:36.374]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.374]                   signalCondition(cond)
[09:32:36.374]                 }
[09:32:36.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.374]                 "immediateCondition"))) {
[09:32:36.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.374]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.374]                   if (TRUE && !signal) {
[09:32:36.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.374]                     {
[09:32:36.374]                       inherits <- base::inherits
[09:32:36.374]                       invokeRestart <- base::invokeRestart
[09:32:36.374]                       is.null <- base::is.null
[09:32:36.374]                       muffled <- FALSE
[09:32:36.374]                       if (inherits(cond, "message")) {
[09:32:36.374]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.374]                         if (muffled) 
[09:32:36.374]                           invokeRestart("muffleMessage")
[09:32:36.374]                       }
[09:32:36.374]                       else if (inherits(cond, "warning")) {
[09:32:36.374]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.374]                         if (muffled) 
[09:32:36.374]                           invokeRestart("muffleWarning")
[09:32:36.374]                       }
[09:32:36.374]                       else if (inherits(cond, "condition")) {
[09:32:36.374]                         if (!is.null(pattern)) {
[09:32:36.374]                           computeRestarts <- base::computeRestarts
[09:32:36.374]                           grepl <- base::grepl
[09:32:36.374]                           restarts <- computeRestarts(cond)
[09:32:36.374]                           for (restart in restarts) {
[09:32:36.374]                             name <- restart$name
[09:32:36.374]                             if (is.null(name)) 
[09:32:36.374]                               next
[09:32:36.374]                             if (!grepl(pattern, name)) 
[09:32:36.374]                               next
[09:32:36.374]                             invokeRestart(restart)
[09:32:36.374]                             muffled <- TRUE
[09:32:36.374]                             break
[09:32:36.374]                           }
[09:32:36.374]                         }
[09:32:36.374]                       }
[09:32:36.374]                       invisible(muffled)
[09:32:36.374]                     }
[09:32:36.374]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.374]                   }
[09:32:36.374]                 }
[09:32:36.374]                 else {
[09:32:36.374]                   if (TRUE) {
[09:32:36.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.374]                     {
[09:32:36.374]                       inherits <- base::inherits
[09:32:36.374]                       invokeRestart <- base::invokeRestart
[09:32:36.374]                       is.null <- base::is.null
[09:32:36.374]                       muffled <- FALSE
[09:32:36.374]                       if (inherits(cond, "message")) {
[09:32:36.374]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.374]                         if (muffled) 
[09:32:36.374]                           invokeRestart("muffleMessage")
[09:32:36.374]                       }
[09:32:36.374]                       else if (inherits(cond, "warning")) {
[09:32:36.374]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.374]                         if (muffled) 
[09:32:36.374]                           invokeRestart("muffleWarning")
[09:32:36.374]                       }
[09:32:36.374]                       else if (inherits(cond, "condition")) {
[09:32:36.374]                         if (!is.null(pattern)) {
[09:32:36.374]                           computeRestarts <- base::computeRestarts
[09:32:36.374]                           grepl <- base::grepl
[09:32:36.374]                           restarts <- computeRestarts(cond)
[09:32:36.374]                           for (restart in restarts) {
[09:32:36.374]                             name <- restart$name
[09:32:36.374]                             if (is.null(name)) 
[09:32:36.374]                               next
[09:32:36.374]                             if (!grepl(pattern, name)) 
[09:32:36.374]                               next
[09:32:36.374]                             invokeRestart(restart)
[09:32:36.374]                             muffled <- TRUE
[09:32:36.374]                             break
[09:32:36.374]                           }
[09:32:36.374]                         }
[09:32:36.374]                       }
[09:32:36.374]                       invisible(muffled)
[09:32:36.374]                     }
[09:32:36.374]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.374]                   }
[09:32:36.374]                 }
[09:32:36.374]             }
[09:32:36.374]         }))
[09:32:36.374]     }, error = function(ex) {
[09:32:36.374]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.374]                 ...future.rng), started = ...future.startTime, 
[09:32:36.374]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.374]             version = "1.8"), class = "FutureResult")
[09:32:36.374]     }, finally = {
[09:32:36.374]         if (!identical(...future.workdir, getwd())) 
[09:32:36.374]             setwd(...future.workdir)
[09:32:36.374]         {
[09:32:36.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.374]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.374]             }
[09:32:36.374]             base::options(...future.oldOptions)
[09:32:36.374]             if (.Platform$OS.type == "windows") {
[09:32:36.374]                 old_names <- names(...future.oldEnvVars)
[09:32:36.374]                 envs <- base::Sys.getenv()
[09:32:36.374]                 names <- names(envs)
[09:32:36.374]                 common <- intersect(names, old_names)
[09:32:36.374]                 added <- setdiff(names, old_names)
[09:32:36.374]                 removed <- setdiff(old_names, names)
[09:32:36.374]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.374]                   envs[common]]
[09:32:36.374]                 NAMES <- toupper(changed)
[09:32:36.374]                 args <- list()
[09:32:36.374]                 for (kk in seq_along(NAMES)) {
[09:32:36.374]                   name <- changed[[kk]]
[09:32:36.374]                   NAME <- NAMES[[kk]]
[09:32:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.374]                     next
[09:32:36.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.374]                 }
[09:32:36.374]                 NAMES <- toupper(added)
[09:32:36.374]                 for (kk in seq_along(NAMES)) {
[09:32:36.374]                   name <- added[[kk]]
[09:32:36.374]                   NAME <- NAMES[[kk]]
[09:32:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.374]                     next
[09:32:36.374]                   args[[name]] <- ""
[09:32:36.374]                 }
[09:32:36.374]                 NAMES <- toupper(removed)
[09:32:36.374]                 for (kk in seq_along(NAMES)) {
[09:32:36.374]                   name <- removed[[kk]]
[09:32:36.374]                   NAME <- NAMES[[kk]]
[09:32:36.374]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.374]                     next
[09:32:36.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.374]                 }
[09:32:36.374]                 if (length(args) > 0) 
[09:32:36.374]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.374]             }
[09:32:36.374]             else {
[09:32:36.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.374]             }
[09:32:36.374]             {
[09:32:36.374]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.374]                   0L) {
[09:32:36.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.374]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.374]                   base::options(opts)
[09:32:36.374]                 }
[09:32:36.374]                 {
[09:32:36.374]                   {
[09:32:36.374]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.374]                     NULL
[09:32:36.374]                   }
[09:32:36.374]                   options(future.plan = NULL)
[09:32:36.374]                   if (is.na(NA_character_)) 
[09:32:36.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.374]                     .init = FALSE)
[09:32:36.374]                 }
[09:32:36.374]             }
[09:32:36.374]         }
[09:32:36.374]     })
[09:32:36.374]     if (TRUE) {
[09:32:36.374]         base::sink(type = "output", split = FALSE)
[09:32:36.374]         if (TRUE) {
[09:32:36.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.374]         }
[09:32:36.374]         else {
[09:32:36.374]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.374]         }
[09:32:36.374]         base::close(...future.stdout)
[09:32:36.374]         ...future.stdout <- NULL
[09:32:36.374]     }
[09:32:36.374]     ...future.result$conditions <- ...future.conditions
[09:32:36.374]     ...future.result$finished <- base::Sys.time()
[09:32:36.374]     ...future.result
[09:32:36.374] }
[09:32:36.377] MultisessionFuture started
[09:32:36.377] - Launch lazy future ... done
[09:32:36.377] run() for ‘MultisessionFuture’ ... done
[09:32:36.378] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.378] - Validating connection of MultisessionFuture
[09:32:36.378] - received message: FutureResult
[09:32:36.379] - Received FutureResult
[09:32:36.379] - Erased future from FutureRegistry
[09:32:36.379] result() for ClusterFuture ...
[09:32:36.379] - result already collected: FutureResult
[09:32:36.379] result() for ClusterFuture ... done
[09:32:36.379] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.379] Future #1
[09:32:36.379]  length: 2 (resolved future 1)
[09:32:36.379] run() for ‘Future’ ...
[09:32:36.379] - state: ‘created’
[09:32:36.379] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.393] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.393]   - Field: ‘node’
[09:32:36.393]   - Field: ‘label’
[09:32:36.393]   - Field: ‘local’
[09:32:36.393]   - Field: ‘owner’
[09:32:36.393]   - Field: ‘envir’
[09:32:36.393]   - Field: ‘workers’
[09:32:36.393]   - Field: ‘packages’
[09:32:36.394]   - Field: ‘gc’
[09:32:36.394]   - Field: ‘conditions’
[09:32:36.394]   - Field: ‘persistent’
[09:32:36.394]   - Field: ‘expr’
[09:32:36.394]   - Field: ‘uuid’
[09:32:36.394]   - Field: ‘seed’
[09:32:36.394]   - Field: ‘version’
[09:32:36.394]   - Field: ‘result’
[09:32:36.394]   - Field: ‘asynchronous’
[09:32:36.394]   - Field: ‘calls’
[09:32:36.394]   - Field: ‘globals’
[09:32:36.395]   - Field: ‘stdout’
[09:32:36.395]   - Field: ‘earlySignal’
[09:32:36.395]   - Field: ‘lazy’
[09:32:36.395]   - Field: ‘state’
[09:32:36.395] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.395] - Launch lazy future ...
[09:32:36.395] Packages needed by the future expression (n = 0): <none>
[09:32:36.395] Packages needed by future strategies (n = 0): <none>
[09:32:36.396] {
[09:32:36.396]     {
[09:32:36.396]         {
[09:32:36.396]             ...future.startTime <- base::Sys.time()
[09:32:36.396]             {
[09:32:36.396]                 {
[09:32:36.396]                   {
[09:32:36.396]                     {
[09:32:36.396]                       base::local({
[09:32:36.396]                         has_future <- base::requireNamespace("future", 
[09:32:36.396]                           quietly = TRUE)
[09:32:36.396]                         if (has_future) {
[09:32:36.396]                           ns <- base::getNamespace("future")
[09:32:36.396]                           version <- ns[[".package"]][["version"]]
[09:32:36.396]                           if (is.null(version)) 
[09:32:36.396]                             version <- utils::packageVersion("future")
[09:32:36.396]                         }
[09:32:36.396]                         else {
[09:32:36.396]                           version <- NULL
[09:32:36.396]                         }
[09:32:36.396]                         if (!has_future || version < "1.8.0") {
[09:32:36.396]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.396]                             "", base::R.version$version.string), 
[09:32:36.396]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.396]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.396]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.396]                               "release", "version")], collapse = " "), 
[09:32:36.396]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.396]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.396]                             info)
[09:32:36.396]                           info <- base::paste(info, collapse = "; ")
[09:32:36.396]                           if (!has_future) {
[09:32:36.396]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.396]                               info)
[09:32:36.396]                           }
[09:32:36.396]                           else {
[09:32:36.396]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.396]                               info, version)
[09:32:36.396]                           }
[09:32:36.396]                           base::stop(msg)
[09:32:36.396]                         }
[09:32:36.396]                       })
[09:32:36.396]                     }
[09:32:36.396]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.396]                     base::options(mc.cores = 1L)
[09:32:36.396]                   }
[09:32:36.396]                   ...future.strategy.old <- future::plan("list")
[09:32:36.396]                   options(future.plan = NULL)
[09:32:36.396]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.396]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.396]                 }
[09:32:36.396]                 ...future.workdir <- getwd()
[09:32:36.396]             }
[09:32:36.396]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.396]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.396]         }
[09:32:36.396]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.396]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.396]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.396]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.396]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.396]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.396]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.396]             base::names(...future.oldOptions))
[09:32:36.396]     }
[09:32:36.396]     if (FALSE) {
[09:32:36.396]     }
[09:32:36.396]     else {
[09:32:36.396]         if (TRUE) {
[09:32:36.396]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.396]                 open = "w")
[09:32:36.396]         }
[09:32:36.396]         else {
[09:32:36.396]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.396]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.396]         }
[09:32:36.396]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.396]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.396]             base::sink(type = "output", split = FALSE)
[09:32:36.396]             base::close(...future.stdout)
[09:32:36.396]         }, add = TRUE)
[09:32:36.396]     }
[09:32:36.396]     ...future.frame <- base::sys.nframe()
[09:32:36.396]     ...future.conditions <- base::list()
[09:32:36.396]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.396]     if (FALSE) {
[09:32:36.396]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.396]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.396]     }
[09:32:36.396]     ...future.result <- base::tryCatch({
[09:32:36.396]         base::withCallingHandlers({
[09:32:36.396]             ...future.value <- base::withVisible(base::local({
[09:32:36.396]                 ...future.makeSendCondition <- base::local({
[09:32:36.396]                   sendCondition <- NULL
[09:32:36.396]                   function(frame = 1L) {
[09:32:36.396]                     if (is.function(sendCondition)) 
[09:32:36.396]                       return(sendCondition)
[09:32:36.396]                     ns <- getNamespace("parallel")
[09:32:36.396]                     if (exists("sendData", mode = "function", 
[09:32:36.396]                       envir = ns)) {
[09:32:36.396]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.396]                         envir = ns)
[09:32:36.396]                       envir <- sys.frame(frame)
[09:32:36.396]                       master <- NULL
[09:32:36.396]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.396]                         !identical(envir, emptyenv())) {
[09:32:36.396]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.396]                           inherits = FALSE)) {
[09:32:36.396]                           master <- get("master", mode = "list", 
[09:32:36.396]                             envir = envir, inherits = FALSE)
[09:32:36.396]                           if (inherits(master, c("SOCKnode", 
[09:32:36.396]                             "SOCK0node"))) {
[09:32:36.396]                             sendCondition <<- function(cond) {
[09:32:36.396]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.396]                                 success = TRUE)
[09:32:36.396]                               parallel_sendData(master, data)
[09:32:36.396]                             }
[09:32:36.396]                             return(sendCondition)
[09:32:36.396]                           }
[09:32:36.396]                         }
[09:32:36.396]                         frame <- frame + 1L
[09:32:36.396]                         envir <- sys.frame(frame)
[09:32:36.396]                       }
[09:32:36.396]                     }
[09:32:36.396]                     sendCondition <<- function(cond) NULL
[09:32:36.396]                   }
[09:32:36.396]                 })
[09:32:36.396]                 withCallingHandlers({
[09:32:36.396]                   2
[09:32:36.396]                 }, immediateCondition = function(cond) {
[09:32:36.396]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.396]                   sendCondition(cond)
[09:32:36.396]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.396]                   {
[09:32:36.396]                     inherits <- base::inherits
[09:32:36.396]                     invokeRestart <- base::invokeRestart
[09:32:36.396]                     is.null <- base::is.null
[09:32:36.396]                     muffled <- FALSE
[09:32:36.396]                     if (inherits(cond, "message")) {
[09:32:36.396]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.396]                       if (muffled) 
[09:32:36.396]                         invokeRestart("muffleMessage")
[09:32:36.396]                     }
[09:32:36.396]                     else if (inherits(cond, "warning")) {
[09:32:36.396]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.396]                       if (muffled) 
[09:32:36.396]                         invokeRestart("muffleWarning")
[09:32:36.396]                     }
[09:32:36.396]                     else if (inherits(cond, "condition")) {
[09:32:36.396]                       if (!is.null(pattern)) {
[09:32:36.396]                         computeRestarts <- base::computeRestarts
[09:32:36.396]                         grepl <- base::grepl
[09:32:36.396]                         restarts <- computeRestarts(cond)
[09:32:36.396]                         for (restart in restarts) {
[09:32:36.396]                           name <- restart$name
[09:32:36.396]                           if (is.null(name)) 
[09:32:36.396]                             next
[09:32:36.396]                           if (!grepl(pattern, name)) 
[09:32:36.396]                             next
[09:32:36.396]                           invokeRestart(restart)
[09:32:36.396]                           muffled <- TRUE
[09:32:36.396]                           break
[09:32:36.396]                         }
[09:32:36.396]                       }
[09:32:36.396]                     }
[09:32:36.396]                     invisible(muffled)
[09:32:36.396]                   }
[09:32:36.396]                   muffleCondition(cond)
[09:32:36.396]                 })
[09:32:36.396]             }))
[09:32:36.396]             future::FutureResult(value = ...future.value$value, 
[09:32:36.396]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.396]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.396]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.396]                     ...future.globalenv.names))
[09:32:36.396]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.396]         }, condition = base::local({
[09:32:36.396]             c <- base::c
[09:32:36.396]             inherits <- base::inherits
[09:32:36.396]             invokeRestart <- base::invokeRestart
[09:32:36.396]             length <- base::length
[09:32:36.396]             list <- base::list
[09:32:36.396]             seq.int <- base::seq.int
[09:32:36.396]             signalCondition <- base::signalCondition
[09:32:36.396]             sys.calls <- base::sys.calls
[09:32:36.396]             `[[` <- base::`[[`
[09:32:36.396]             `+` <- base::`+`
[09:32:36.396]             `<<-` <- base::`<<-`
[09:32:36.396]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.396]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.396]                   3L)]
[09:32:36.396]             }
[09:32:36.396]             function(cond) {
[09:32:36.396]                 is_error <- inherits(cond, "error")
[09:32:36.396]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.396]                   NULL)
[09:32:36.396]                 if (is_error) {
[09:32:36.396]                   sessionInformation <- function() {
[09:32:36.396]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.396]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.396]                       search = base::search(), system = base::Sys.info())
[09:32:36.396]                   }
[09:32:36.396]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.396]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.396]                     cond$call), session = sessionInformation(), 
[09:32:36.396]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.396]                   signalCondition(cond)
[09:32:36.396]                 }
[09:32:36.396]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.396]                 "immediateCondition"))) {
[09:32:36.396]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.396]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.396]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.396]                   if (TRUE && !signal) {
[09:32:36.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.396]                     {
[09:32:36.396]                       inherits <- base::inherits
[09:32:36.396]                       invokeRestart <- base::invokeRestart
[09:32:36.396]                       is.null <- base::is.null
[09:32:36.396]                       muffled <- FALSE
[09:32:36.396]                       if (inherits(cond, "message")) {
[09:32:36.396]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.396]                         if (muffled) 
[09:32:36.396]                           invokeRestart("muffleMessage")
[09:32:36.396]                       }
[09:32:36.396]                       else if (inherits(cond, "warning")) {
[09:32:36.396]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.396]                         if (muffled) 
[09:32:36.396]                           invokeRestart("muffleWarning")
[09:32:36.396]                       }
[09:32:36.396]                       else if (inherits(cond, "condition")) {
[09:32:36.396]                         if (!is.null(pattern)) {
[09:32:36.396]                           computeRestarts <- base::computeRestarts
[09:32:36.396]                           grepl <- base::grepl
[09:32:36.396]                           restarts <- computeRestarts(cond)
[09:32:36.396]                           for (restart in restarts) {
[09:32:36.396]                             name <- restart$name
[09:32:36.396]                             if (is.null(name)) 
[09:32:36.396]                               next
[09:32:36.396]                             if (!grepl(pattern, name)) 
[09:32:36.396]                               next
[09:32:36.396]                             invokeRestart(restart)
[09:32:36.396]                             muffled <- TRUE
[09:32:36.396]                             break
[09:32:36.396]                           }
[09:32:36.396]                         }
[09:32:36.396]                       }
[09:32:36.396]                       invisible(muffled)
[09:32:36.396]                     }
[09:32:36.396]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.396]                   }
[09:32:36.396]                 }
[09:32:36.396]                 else {
[09:32:36.396]                   if (TRUE) {
[09:32:36.396]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.396]                     {
[09:32:36.396]                       inherits <- base::inherits
[09:32:36.396]                       invokeRestart <- base::invokeRestart
[09:32:36.396]                       is.null <- base::is.null
[09:32:36.396]                       muffled <- FALSE
[09:32:36.396]                       if (inherits(cond, "message")) {
[09:32:36.396]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.396]                         if (muffled) 
[09:32:36.396]                           invokeRestart("muffleMessage")
[09:32:36.396]                       }
[09:32:36.396]                       else if (inherits(cond, "warning")) {
[09:32:36.396]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.396]                         if (muffled) 
[09:32:36.396]                           invokeRestart("muffleWarning")
[09:32:36.396]                       }
[09:32:36.396]                       else if (inherits(cond, "condition")) {
[09:32:36.396]                         if (!is.null(pattern)) {
[09:32:36.396]                           computeRestarts <- base::computeRestarts
[09:32:36.396]                           grepl <- base::grepl
[09:32:36.396]                           restarts <- computeRestarts(cond)
[09:32:36.396]                           for (restart in restarts) {
[09:32:36.396]                             name <- restart$name
[09:32:36.396]                             if (is.null(name)) 
[09:32:36.396]                               next
[09:32:36.396]                             if (!grepl(pattern, name)) 
[09:32:36.396]                               next
[09:32:36.396]                             invokeRestart(restart)
[09:32:36.396]                             muffled <- TRUE
[09:32:36.396]                             break
[09:32:36.396]                           }
[09:32:36.396]                         }
[09:32:36.396]                       }
[09:32:36.396]                       invisible(muffled)
[09:32:36.396]                     }
[09:32:36.396]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.396]                   }
[09:32:36.396]                 }
[09:32:36.396]             }
[09:32:36.396]         }))
[09:32:36.396]     }, error = function(ex) {
[09:32:36.396]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.396]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.396]                 ...future.rng), started = ...future.startTime, 
[09:32:36.396]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.396]             version = "1.8"), class = "FutureResult")
[09:32:36.396]     }, finally = {
[09:32:36.396]         if (!identical(...future.workdir, getwd())) 
[09:32:36.396]             setwd(...future.workdir)
[09:32:36.396]         {
[09:32:36.396]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.396]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.396]             }
[09:32:36.396]             base::options(...future.oldOptions)
[09:32:36.396]             if (.Platform$OS.type == "windows") {
[09:32:36.396]                 old_names <- names(...future.oldEnvVars)
[09:32:36.396]                 envs <- base::Sys.getenv()
[09:32:36.396]                 names <- names(envs)
[09:32:36.396]                 common <- intersect(names, old_names)
[09:32:36.396]                 added <- setdiff(names, old_names)
[09:32:36.396]                 removed <- setdiff(old_names, names)
[09:32:36.396]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.396]                   envs[common]]
[09:32:36.396]                 NAMES <- toupper(changed)
[09:32:36.396]                 args <- list()
[09:32:36.396]                 for (kk in seq_along(NAMES)) {
[09:32:36.396]                   name <- changed[[kk]]
[09:32:36.396]                   NAME <- NAMES[[kk]]
[09:32:36.396]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.396]                     next
[09:32:36.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.396]                 }
[09:32:36.396]                 NAMES <- toupper(added)
[09:32:36.396]                 for (kk in seq_along(NAMES)) {
[09:32:36.396]                   name <- added[[kk]]
[09:32:36.396]                   NAME <- NAMES[[kk]]
[09:32:36.396]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.396]                     next
[09:32:36.396]                   args[[name]] <- ""
[09:32:36.396]                 }
[09:32:36.396]                 NAMES <- toupper(removed)
[09:32:36.396]                 for (kk in seq_along(NAMES)) {
[09:32:36.396]                   name <- removed[[kk]]
[09:32:36.396]                   NAME <- NAMES[[kk]]
[09:32:36.396]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.396]                     next
[09:32:36.396]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.396]                 }
[09:32:36.396]                 if (length(args) > 0) 
[09:32:36.396]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.396]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.396]             }
[09:32:36.396]             else {
[09:32:36.396]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.396]             }
[09:32:36.396]             {
[09:32:36.396]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.396]                   0L) {
[09:32:36.396]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.396]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.396]                   base::options(opts)
[09:32:36.396]                 }
[09:32:36.396]                 {
[09:32:36.396]                   {
[09:32:36.396]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.396]                     NULL
[09:32:36.396]                   }
[09:32:36.396]                   options(future.plan = NULL)
[09:32:36.396]                   if (is.na(NA_character_)) 
[09:32:36.396]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.396]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.396]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.396]                     .init = FALSE)
[09:32:36.396]                 }
[09:32:36.396]             }
[09:32:36.396]         }
[09:32:36.396]     })
[09:32:36.396]     if (TRUE) {
[09:32:36.396]         base::sink(type = "output", split = FALSE)
[09:32:36.396]         if (TRUE) {
[09:32:36.396]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.396]         }
[09:32:36.396]         else {
[09:32:36.396]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.396]         }
[09:32:36.396]         base::close(...future.stdout)
[09:32:36.396]         ...future.stdout <- NULL
[09:32:36.396]     }
[09:32:36.396]     ...future.result$conditions <- ...future.conditions
[09:32:36.396]     ...future.result$finished <- base::Sys.time()
[09:32:36.396]     ...future.result
[09:32:36.396] }
[09:32:36.399] MultisessionFuture started
[09:32:36.399] - Launch lazy future ... done
[09:32:36.399] run() for ‘MultisessionFuture’ ... done
[09:32:36.400] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.400] - Validating connection of MultisessionFuture
[09:32:36.401] - received message: FutureResult
[09:32:36.401] - Received FutureResult
[09:32:36.401] - Erased future from FutureRegistry
[09:32:36.401] result() for ClusterFuture ...
[09:32:36.401] - result already collected: FutureResult
[09:32:36.401] result() for ClusterFuture ... done
[09:32:36.401] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.401] Future #2
[09:32:36.401]  length: 1 (resolved future 2)
[09:32:36.401]  length: 0 (resolved future 3)
[09:32:36.402] resolve() on list ... DONE
[09:32:36.402] getGlobalsAndPackages() ...
[09:32:36.402] Searching for globals...
[09:32:36.402] 
[09:32:36.402] Searching for globals ... DONE
[09:32:36.402] - globals: [0] <none>
[09:32:36.402] getGlobalsAndPackages() ... DONE
[09:32:36.403] run() for ‘Future’ ...
[09:32:36.403] - state: ‘created’
[09:32:36.403] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.417]   - Field: ‘node’
[09:32:36.417]   - Field: ‘label’
[09:32:36.417]   - Field: ‘local’
[09:32:36.417]   - Field: ‘owner’
[09:32:36.417]   - Field: ‘envir’
[09:32:36.417]   - Field: ‘workers’
[09:32:36.417]   - Field: ‘packages’
[09:32:36.417]   - Field: ‘gc’
[09:32:36.417]   - Field: ‘conditions’
[09:32:36.417]   - Field: ‘persistent’
[09:32:36.417]   - Field: ‘expr’
[09:32:36.418]   - Field: ‘uuid’
[09:32:36.418]   - Field: ‘seed’
[09:32:36.418]   - Field: ‘version’
[09:32:36.418]   - Field: ‘result’
[09:32:36.418]   - Field: ‘asynchronous’
[09:32:36.418]   - Field: ‘calls’
[09:32:36.418]   - Field: ‘globals’
[09:32:36.418]   - Field: ‘stdout’
[09:32:36.418]   - Field: ‘earlySignal’
[09:32:36.418]   - Field: ‘lazy’
[09:32:36.418]   - Field: ‘state’
[09:32:36.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.419] - Launch lazy future ...
[09:32:36.419] Packages needed by the future expression (n = 0): <none>
[09:32:36.419] Packages needed by future strategies (n = 0): <none>
[09:32:36.419] {
[09:32:36.419]     {
[09:32:36.419]         {
[09:32:36.419]             ...future.startTime <- base::Sys.time()
[09:32:36.419]             {
[09:32:36.419]                 {
[09:32:36.419]                   {
[09:32:36.419]                     {
[09:32:36.419]                       base::local({
[09:32:36.419]                         has_future <- base::requireNamespace("future", 
[09:32:36.419]                           quietly = TRUE)
[09:32:36.419]                         if (has_future) {
[09:32:36.419]                           ns <- base::getNamespace("future")
[09:32:36.419]                           version <- ns[[".package"]][["version"]]
[09:32:36.419]                           if (is.null(version)) 
[09:32:36.419]                             version <- utils::packageVersion("future")
[09:32:36.419]                         }
[09:32:36.419]                         else {
[09:32:36.419]                           version <- NULL
[09:32:36.419]                         }
[09:32:36.419]                         if (!has_future || version < "1.8.0") {
[09:32:36.419]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.419]                             "", base::R.version$version.string), 
[09:32:36.419]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.419]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.419]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.419]                               "release", "version")], collapse = " "), 
[09:32:36.419]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.419]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.419]                             info)
[09:32:36.419]                           info <- base::paste(info, collapse = "; ")
[09:32:36.419]                           if (!has_future) {
[09:32:36.419]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.419]                               info)
[09:32:36.419]                           }
[09:32:36.419]                           else {
[09:32:36.419]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.419]                               info, version)
[09:32:36.419]                           }
[09:32:36.419]                           base::stop(msg)
[09:32:36.419]                         }
[09:32:36.419]                       })
[09:32:36.419]                     }
[09:32:36.419]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.419]                     base::options(mc.cores = 1L)
[09:32:36.419]                   }
[09:32:36.419]                   ...future.strategy.old <- future::plan("list")
[09:32:36.419]                   options(future.plan = NULL)
[09:32:36.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.419]                 }
[09:32:36.419]                 ...future.workdir <- getwd()
[09:32:36.419]             }
[09:32:36.419]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.419]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.419]         }
[09:32:36.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.419]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.419]             base::names(...future.oldOptions))
[09:32:36.419]     }
[09:32:36.419]     if (FALSE) {
[09:32:36.419]     }
[09:32:36.419]     else {
[09:32:36.419]         if (TRUE) {
[09:32:36.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.419]                 open = "w")
[09:32:36.419]         }
[09:32:36.419]         else {
[09:32:36.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.419]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.419]         }
[09:32:36.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.419]             base::sink(type = "output", split = FALSE)
[09:32:36.419]             base::close(...future.stdout)
[09:32:36.419]         }, add = TRUE)
[09:32:36.419]     }
[09:32:36.419]     ...future.frame <- base::sys.nframe()
[09:32:36.419]     ...future.conditions <- base::list()
[09:32:36.419]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.419]     if (FALSE) {
[09:32:36.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.419]     }
[09:32:36.419]     ...future.result <- base::tryCatch({
[09:32:36.419]         base::withCallingHandlers({
[09:32:36.419]             ...future.value <- base::withVisible(base::local({
[09:32:36.419]                 ...future.makeSendCondition <- base::local({
[09:32:36.419]                   sendCondition <- NULL
[09:32:36.419]                   function(frame = 1L) {
[09:32:36.419]                     if (is.function(sendCondition)) 
[09:32:36.419]                       return(sendCondition)
[09:32:36.419]                     ns <- getNamespace("parallel")
[09:32:36.419]                     if (exists("sendData", mode = "function", 
[09:32:36.419]                       envir = ns)) {
[09:32:36.419]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.419]                         envir = ns)
[09:32:36.419]                       envir <- sys.frame(frame)
[09:32:36.419]                       master <- NULL
[09:32:36.419]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.419]                         !identical(envir, emptyenv())) {
[09:32:36.419]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.419]                           inherits = FALSE)) {
[09:32:36.419]                           master <- get("master", mode = "list", 
[09:32:36.419]                             envir = envir, inherits = FALSE)
[09:32:36.419]                           if (inherits(master, c("SOCKnode", 
[09:32:36.419]                             "SOCK0node"))) {
[09:32:36.419]                             sendCondition <<- function(cond) {
[09:32:36.419]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.419]                                 success = TRUE)
[09:32:36.419]                               parallel_sendData(master, data)
[09:32:36.419]                             }
[09:32:36.419]                             return(sendCondition)
[09:32:36.419]                           }
[09:32:36.419]                         }
[09:32:36.419]                         frame <- frame + 1L
[09:32:36.419]                         envir <- sys.frame(frame)
[09:32:36.419]                       }
[09:32:36.419]                     }
[09:32:36.419]                     sendCondition <<- function(cond) NULL
[09:32:36.419]                   }
[09:32:36.419]                 })
[09:32:36.419]                 withCallingHandlers({
[09:32:36.419]                   1
[09:32:36.419]                 }, immediateCondition = function(cond) {
[09:32:36.419]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.419]                   sendCondition(cond)
[09:32:36.419]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.419]                   {
[09:32:36.419]                     inherits <- base::inherits
[09:32:36.419]                     invokeRestart <- base::invokeRestart
[09:32:36.419]                     is.null <- base::is.null
[09:32:36.419]                     muffled <- FALSE
[09:32:36.419]                     if (inherits(cond, "message")) {
[09:32:36.419]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.419]                       if (muffled) 
[09:32:36.419]                         invokeRestart("muffleMessage")
[09:32:36.419]                     }
[09:32:36.419]                     else if (inherits(cond, "warning")) {
[09:32:36.419]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.419]                       if (muffled) 
[09:32:36.419]                         invokeRestart("muffleWarning")
[09:32:36.419]                     }
[09:32:36.419]                     else if (inherits(cond, "condition")) {
[09:32:36.419]                       if (!is.null(pattern)) {
[09:32:36.419]                         computeRestarts <- base::computeRestarts
[09:32:36.419]                         grepl <- base::grepl
[09:32:36.419]                         restarts <- computeRestarts(cond)
[09:32:36.419]                         for (restart in restarts) {
[09:32:36.419]                           name <- restart$name
[09:32:36.419]                           if (is.null(name)) 
[09:32:36.419]                             next
[09:32:36.419]                           if (!grepl(pattern, name)) 
[09:32:36.419]                             next
[09:32:36.419]                           invokeRestart(restart)
[09:32:36.419]                           muffled <- TRUE
[09:32:36.419]                           break
[09:32:36.419]                         }
[09:32:36.419]                       }
[09:32:36.419]                     }
[09:32:36.419]                     invisible(muffled)
[09:32:36.419]                   }
[09:32:36.419]                   muffleCondition(cond)
[09:32:36.419]                 })
[09:32:36.419]             }))
[09:32:36.419]             future::FutureResult(value = ...future.value$value, 
[09:32:36.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.419]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.419]                     ...future.globalenv.names))
[09:32:36.419]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.419]         }, condition = base::local({
[09:32:36.419]             c <- base::c
[09:32:36.419]             inherits <- base::inherits
[09:32:36.419]             invokeRestart <- base::invokeRestart
[09:32:36.419]             length <- base::length
[09:32:36.419]             list <- base::list
[09:32:36.419]             seq.int <- base::seq.int
[09:32:36.419]             signalCondition <- base::signalCondition
[09:32:36.419]             sys.calls <- base::sys.calls
[09:32:36.419]             `[[` <- base::`[[`
[09:32:36.419]             `+` <- base::`+`
[09:32:36.419]             `<<-` <- base::`<<-`
[09:32:36.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.419]                   3L)]
[09:32:36.419]             }
[09:32:36.419]             function(cond) {
[09:32:36.419]                 is_error <- inherits(cond, "error")
[09:32:36.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.419]                   NULL)
[09:32:36.419]                 if (is_error) {
[09:32:36.419]                   sessionInformation <- function() {
[09:32:36.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.419]                       search = base::search(), system = base::Sys.info())
[09:32:36.419]                   }
[09:32:36.419]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.419]                     cond$call), session = sessionInformation(), 
[09:32:36.419]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.419]                   signalCondition(cond)
[09:32:36.419]                 }
[09:32:36.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.419]                 "immediateCondition"))) {
[09:32:36.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.419]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.419]                   if (TRUE && !signal) {
[09:32:36.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.419]                     {
[09:32:36.419]                       inherits <- base::inherits
[09:32:36.419]                       invokeRestart <- base::invokeRestart
[09:32:36.419]                       is.null <- base::is.null
[09:32:36.419]                       muffled <- FALSE
[09:32:36.419]                       if (inherits(cond, "message")) {
[09:32:36.419]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.419]                         if (muffled) 
[09:32:36.419]                           invokeRestart("muffleMessage")
[09:32:36.419]                       }
[09:32:36.419]                       else if (inherits(cond, "warning")) {
[09:32:36.419]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.419]                         if (muffled) 
[09:32:36.419]                           invokeRestart("muffleWarning")
[09:32:36.419]                       }
[09:32:36.419]                       else if (inherits(cond, "condition")) {
[09:32:36.419]                         if (!is.null(pattern)) {
[09:32:36.419]                           computeRestarts <- base::computeRestarts
[09:32:36.419]                           grepl <- base::grepl
[09:32:36.419]                           restarts <- computeRestarts(cond)
[09:32:36.419]                           for (restart in restarts) {
[09:32:36.419]                             name <- restart$name
[09:32:36.419]                             if (is.null(name)) 
[09:32:36.419]                               next
[09:32:36.419]                             if (!grepl(pattern, name)) 
[09:32:36.419]                               next
[09:32:36.419]                             invokeRestart(restart)
[09:32:36.419]                             muffled <- TRUE
[09:32:36.419]                             break
[09:32:36.419]                           }
[09:32:36.419]                         }
[09:32:36.419]                       }
[09:32:36.419]                       invisible(muffled)
[09:32:36.419]                     }
[09:32:36.419]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.419]                   }
[09:32:36.419]                 }
[09:32:36.419]                 else {
[09:32:36.419]                   if (TRUE) {
[09:32:36.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.419]                     {
[09:32:36.419]                       inherits <- base::inherits
[09:32:36.419]                       invokeRestart <- base::invokeRestart
[09:32:36.419]                       is.null <- base::is.null
[09:32:36.419]                       muffled <- FALSE
[09:32:36.419]                       if (inherits(cond, "message")) {
[09:32:36.419]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.419]                         if (muffled) 
[09:32:36.419]                           invokeRestart("muffleMessage")
[09:32:36.419]                       }
[09:32:36.419]                       else if (inherits(cond, "warning")) {
[09:32:36.419]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.419]                         if (muffled) 
[09:32:36.419]                           invokeRestart("muffleWarning")
[09:32:36.419]                       }
[09:32:36.419]                       else if (inherits(cond, "condition")) {
[09:32:36.419]                         if (!is.null(pattern)) {
[09:32:36.419]                           computeRestarts <- base::computeRestarts
[09:32:36.419]                           grepl <- base::grepl
[09:32:36.419]                           restarts <- computeRestarts(cond)
[09:32:36.419]                           for (restart in restarts) {
[09:32:36.419]                             name <- restart$name
[09:32:36.419]                             if (is.null(name)) 
[09:32:36.419]                               next
[09:32:36.419]                             if (!grepl(pattern, name)) 
[09:32:36.419]                               next
[09:32:36.419]                             invokeRestart(restart)
[09:32:36.419]                             muffled <- TRUE
[09:32:36.419]                             break
[09:32:36.419]                           }
[09:32:36.419]                         }
[09:32:36.419]                       }
[09:32:36.419]                       invisible(muffled)
[09:32:36.419]                     }
[09:32:36.419]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.419]                   }
[09:32:36.419]                 }
[09:32:36.419]             }
[09:32:36.419]         }))
[09:32:36.419]     }, error = function(ex) {
[09:32:36.419]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.419]                 ...future.rng), started = ...future.startTime, 
[09:32:36.419]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.419]             version = "1.8"), class = "FutureResult")
[09:32:36.419]     }, finally = {
[09:32:36.419]         if (!identical(...future.workdir, getwd())) 
[09:32:36.419]             setwd(...future.workdir)
[09:32:36.419]         {
[09:32:36.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.419]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.419]             }
[09:32:36.419]             base::options(...future.oldOptions)
[09:32:36.419]             if (.Platform$OS.type == "windows") {
[09:32:36.419]                 old_names <- names(...future.oldEnvVars)
[09:32:36.419]                 envs <- base::Sys.getenv()
[09:32:36.419]                 names <- names(envs)
[09:32:36.419]                 common <- intersect(names, old_names)
[09:32:36.419]                 added <- setdiff(names, old_names)
[09:32:36.419]                 removed <- setdiff(old_names, names)
[09:32:36.419]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.419]                   envs[common]]
[09:32:36.419]                 NAMES <- toupper(changed)
[09:32:36.419]                 args <- list()
[09:32:36.419]                 for (kk in seq_along(NAMES)) {
[09:32:36.419]                   name <- changed[[kk]]
[09:32:36.419]                   NAME <- NAMES[[kk]]
[09:32:36.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.419]                     next
[09:32:36.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.419]                 }
[09:32:36.419]                 NAMES <- toupper(added)
[09:32:36.419]                 for (kk in seq_along(NAMES)) {
[09:32:36.419]                   name <- added[[kk]]
[09:32:36.419]                   NAME <- NAMES[[kk]]
[09:32:36.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.419]                     next
[09:32:36.419]                   args[[name]] <- ""
[09:32:36.419]                 }
[09:32:36.419]                 NAMES <- toupper(removed)
[09:32:36.419]                 for (kk in seq_along(NAMES)) {
[09:32:36.419]                   name <- removed[[kk]]
[09:32:36.419]                   NAME <- NAMES[[kk]]
[09:32:36.419]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.419]                     next
[09:32:36.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.419]                 }
[09:32:36.419]                 if (length(args) > 0) 
[09:32:36.419]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.419]             }
[09:32:36.419]             else {
[09:32:36.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.419]             }
[09:32:36.419]             {
[09:32:36.419]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.419]                   0L) {
[09:32:36.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.419]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.419]                   base::options(opts)
[09:32:36.419]                 }
[09:32:36.419]                 {
[09:32:36.419]                   {
[09:32:36.419]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.419]                     NULL
[09:32:36.419]                   }
[09:32:36.419]                   options(future.plan = NULL)
[09:32:36.419]                   if (is.na(NA_character_)) 
[09:32:36.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.419]                     .init = FALSE)
[09:32:36.419]                 }
[09:32:36.419]             }
[09:32:36.419]         }
[09:32:36.419]     })
[09:32:36.419]     if (TRUE) {
[09:32:36.419]         base::sink(type = "output", split = FALSE)
[09:32:36.419]         if (TRUE) {
[09:32:36.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.419]         }
[09:32:36.419]         else {
[09:32:36.419]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.419]         }
[09:32:36.419]         base::close(...future.stdout)
[09:32:36.419]         ...future.stdout <- NULL
[09:32:36.419]     }
[09:32:36.419]     ...future.result$conditions <- ...future.conditions
[09:32:36.419]     ...future.result$finished <- base::Sys.time()
[09:32:36.419]     ...future.result
[09:32:36.419] }
[09:32:36.422] MultisessionFuture started
[09:32:36.422] - Launch lazy future ... done
[09:32:36.423] run() for ‘MultisessionFuture’ ... done
[09:32:36.423] getGlobalsAndPackages() ...
[09:32:36.423] Searching for globals...
[09:32:36.424] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:36.424] Searching for globals ... DONE
[09:32:36.424] Resolving globals: FALSE
[09:32:36.424] 
[09:32:36.424] 
[09:32:36.424] getGlobalsAndPackages() ... DONE
[09:32:36.425] run() for ‘Future’ ...
[09:32:36.425] - state: ‘created’
[09:32:36.425] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.438] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.439]   - Field: ‘node’
[09:32:36.439]   - Field: ‘label’
[09:32:36.439]   - Field: ‘local’
[09:32:36.439]   - Field: ‘owner’
[09:32:36.439]   - Field: ‘envir’
[09:32:36.439]   - Field: ‘workers’
[09:32:36.439]   - Field: ‘packages’
[09:32:36.439]   - Field: ‘gc’
[09:32:36.439]   - Field: ‘conditions’
[09:32:36.439]   - Field: ‘persistent’
[09:32:36.439]   - Field: ‘expr’
[09:32:36.440]   - Field: ‘uuid’
[09:32:36.440]   - Field: ‘seed’
[09:32:36.440]   - Field: ‘version’
[09:32:36.440]   - Field: ‘result’
[09:32:36.440]   - Field: ‘asynchronous’
[09:32:36.440]   - Field: ‘calls’
[09:32:36.440]   - Field: ‘globals’
[09:32:36.440]   - Field: ‘stdout’
[09:32:36.440]   - Field: ‘earlySignal’
[09:32:36.440]   - Field: ‘lazy’
[09:32:36.440]   - Field: ‘state’
[09:32:36.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.441] - Launch lazy future ...
[09:32:36.443] Packages needed by the future expression (n = 0): <none>
[09:32:36.443] Packages needed by future strategies (n = 0): <none>
[09:32:36.444] {
[09:32:36.444]     {
[09:32:36.444]         {
[09:32:36.444]             ...future.startTime <- base::Sys.time()
[09:32:36.444]             {
[09:32:36.444]                 {
[09:32:36.444]                   {
[09:32:36.444]                     {
[09:32:36.444]                       base::local({
[09:32:36.444]                         has_future <- base::requireNamespace("future", 
[09:32:36.444]                           quietly = TRUE)
[09:32:36.444]                         if (has_future) {
[09:32:36.444]                           ns <- base::getNamespace("future")
[09:32:36.444]                           version <- ns[[".package"]][["version"]]
[09:32:36.444]                           if (is.null(version)) 
[09:32:36.444]                             version <- utils::packageVersion("future")
[09:32:36.444]                         }
[09:32:36.444]                         else {
[09:32:36.444]                           version <- NULL
[09:32:36.444]                         }
[09:32:36.444]                         if (!has_future || version < "1.8.0") {
[09:32:36.444]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.444]                             "", base::R.version$version.string), 
[09:32:36.444]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.444]                               "release", "version")], collapse = " "), 
[09:32:36.444]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.444]                             info)
[09:32:36.444]                           info <- base::paste(info, collapse = "; ")
[09:32:36.444]                           if (!has_future) {
[09:32:36.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.444]                               info)
[09:32:36.444]                           }
[09:32:36.444]                           else {
[09:32:36.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.444]                               info, version)
[09:32:36.444]                           }
[09:32:36.444]                           base::stop(msg)
[09:32:36.444]                         }
[09:32:36.444]                       })
[09:32:36.444]                     }
[09:32:36.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.444]                     base::options(mc.cores = 1L)
[09:32:36.444]                   }
[09:32:36.444]                   ...future.strategy.old <- future::plan("list")
[09:32:36.444]                   options(future.plan = NULL)
[09:32:36.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.444]                 }
[09:32:36.444]                 ...future.workdir <- getwd()
[09:32:36.444]             }
[09:32:36.444]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.444]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.444]         }
[09:32:36.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.444]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.444]             base::names(...future.oldOptions))
[09:32:36.444]     }
[09:32:36.444]     if (FALSE) {
[09:32:36.444]     }
[09:32:36.444]     else {
[09:32:36.444]         if (TRUE) {
[09:32:36.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.444]                 open = "w")
[09:32:36.444]         }
[09:32:36.444]         else {
[09:32:36.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.444]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.444]         }
[09:32:36.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.444]             base::sink(type = "output", split = FALSE)
[09:32:36.444]             base::close(...future.stdout)
[09:32:36.444]         }, add = TRUE)
[09:32:36.444]     }
[09:32:36.444]     ...future.frame <- base::sys.nframe()
[09:32:36.444]     ...future.conditions <- base::list()
[09:32:36.444]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.444]     if (FALSE) {
[09:32:36.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.444]     }
[09:32:36.444]     ...future.result <- base::tryCatch({
[09:32:36.444]         base::withCallingHandlers({
[09:32:36.444]             ...future.value <- base::withVisible(base::local({
[09:32:36.444]                 ...future.makeSendCondition <- base::local({
[09:32:36.444]                   sendCondition <- NULL
[09:32:36.444]                   function(frame = 1L) {
[09:32:36.444]                     if (is.function(sendCondition)) 
[09:32:36.444]                       return(sendCondition)
[09:32:36.444]                     ns <- getNamespace("parallel")
[09:32:36.444]                     if (exists("sendData", mode = "function", 
[09:32:36.444]                       envir = ns)) {
[09:32:36.444]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.444]                         envir = ns)
[09:32:36.444]                       envir <- sys.frame(frame)
[09:32:36.444]                       master <- NULL
[09:32:36.444]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.444]                         !identical(envir, emptyenv())) {
[09:32:36.444]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.444]                           inherits = FALSE)) {
[09:32:36.444]                           master <- get("master", mode = "list", 
[09:32:36.444]                             envir = envir, inherits = FALSE)
[09:32:36.444]                           if (inherits(master, c("SOCKnode", 
[09:32:36.444]                             "SOCK0node"))) {
[09:32:36.444]                             sendCondition <<- function(cond) {
[09:32:36.444]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.444]                                 success = TRUE)
[09:32:36.444]                               parallel_sendData(master, data)
[09:32:36.444]                             }
[09:32:36.444]                             return(sendCondition)
[09:32:36.444]                           }
[09:32:36.444]                         }
[09:32:36.444]                         frame <- frame + 1L
[09:32:36.444]                         envir <- sys.frame(frame)
[09:32:36.444]                       }
[09:32:36.444]                     }
[09:32:36.444]                     sendCondition <<- function(cond) NULL
[09:32:36.444]                   }
[09:32:36.444]                 })
[09:32:36.444]                 withCallingHandlers({
[09:32:36.444]                   {
[09:32:36.444]                     Sys.sleep(0.5)
[09:32:36.444]                     2
[09:32:36.444]                   }
[09:32:36.444]                 }, immediateCondition = function(cond) {
[09:32:36.444]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.444]                   sendCondition(cond)
[09:32:36.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.444]                   {
[09:32:36.444]                     inherits <- base::inherits
[09:32:36.444]                     invokeRestart <- base::invokeRestart
[09:32:36.444]                     is.null <- base::is.null
[09:32:36.444]                     muffled <- FALSE
[09:32:36.444]                     if (inherits(cond, "message")) {
[09:32:36.444]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.444]                       if (muffled) 
[09:32:36.444]                         invokeRestart("muffleMessage")
[09:32:36.444]                     }
[09:32:36.444]                     else if (inherits(cond, "warning")) {
[09:32:36.444]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.444]                       if (muffled) 
[09:32:36.444]                         invokeRestart("muffleWarning")
[09:32:36.444]                     }
[09:32:36.444]                     else if (inherits(cond, "condition")) {
[09:32:36.444]                       if (!is.null(pattern)) {
[09:32:36.444]                         computeRestarts <- base::computeRestarts
[09:32:36.444]                         grepl <- base::grepl
[09:32:36.444]                         restarts <- computeRestarts(cond)
[09:32:36.444]                         for (restart in restarts) {
[09:32:36.444]                           name <- restart$name
[09:32:36.444]                           if (is.null(name)) 
[09:32:36.444]                             next
[09:32:36.444]                           if (!grepl(pattern, name)) 
[09:32:36.444]                             next
[09:32:36.444]                           invokeRestart(restart)
[09:32:36.444]                           muffled <- TRUE
[09:32:36.444]                           break
[09:32:36.444]                         }
[09:32:36.444]                       }
[09:32:36.444]                     }
[09:32:36.444]                     invisible(muffled)
[09:32:36.444]                   }
[09:32:36.444]                   muffleCondition(cond)
[09:32:36.444]                 })
[09:32:36.444]             }))
[09:32:36.444]             future::FutureResult(value = ...future.value$value, 
[09:32:36.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.444]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.444]                     ...future.globalenv.names))
[09:32:36.444]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.444]         }, condition = base::local({
[09:32:36.444]             c <- base::c
[09:32:36.444]             inherits <- base::inherits
[09:32:36.444]             invokeRestart <- base::invokeRestart
[09:32:36.444]             length <- base::length
[09:32:36.444]             list <- base::list
[09:32:36.444]             seq.int <- base::seq.int
[09:32:36.444]             signalCondition <- base::signalCondition
[09:32:36.444]             sys.calls <- base::sys.calls
[09:32:36.444]             `[[` <- base::`[[`
[09:32:36.444]             `+` <- base::`+`
[09:32:36.444]             `<<-` <- base::`<<-`
[09:32:36.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.444]                   3L)]
[09:32:36.444]             }
[09:32:36.444]             function(cond) {
[09:32:36.444]                 is_error <- inherits(cond, "error")
[09:32:36.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.444]                   NULL)
[09:32:36.444]                 if (is_error) {
[09:32:36.444]                   sessionInformation <- function() {
[09:32:36.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.444]                       search = base::search(), system = base::Sys.info())
[09:32:36.444]                   }
[09:32:36.444]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.444]                     cond$call), session = sessionInformation(), 
[09:32:36.444]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.444]                   signalCondition(cond)
[09:32:36.444]                 }
[09:32:36.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.444]                 "immediateCondition"))) {
[09:32:36.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.444]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.444]                   if (TRUE && !signal) {
[09:32:36.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.444]                     {
[09:32:36.444]                       inherits <- base::inherits
[09:32:36.444]                       invokeRestart <- base::invokeRestart
[09:32:36.444]                       is.null <- base::is.null
[09:32:36.444]                       muffled <- FALSE
[09:32:36.444]                       if (inherits(cond, "message")) {
[09:32:36.444]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.444]                         if (muffled) 
[09:32:36.444]                           invokeRestart("muffleMessage")
[09:32:36.444]                       }
[09:32:36.444]                       else if (inherits(cond, "warning")) {
[09:32:36.444]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.444]                         if (muffled) 
[09:32:36.444]                           invokeRestart("muffleWarning")
[09:32:36.444]                       }
[09:32:36.444]                       else if (inherits(cond, "condition")) {
[09:32:36.444]                         if (!is.null(pattern)) {
[09:32:36.444]                           computeRestarts <- base::computeRestarts
[09:32:36.444]                           grepl <- base::grepl
[09:32:36.444]                           restarts <- computeRestarts(cond)
[09:32:36.444]                           for (restart in restarts) {
[09:32:36.444]                             name <- restart$name
[09:32:36.444]                             if (is.null(name)) 
[09:32:36.444]                               next
[09:32:36.444]                             if (!grepl(pattern, name)) 
[09:32:36.444]                               next
[09:32:36.444]                             invokeRestart(restart)
[09:32:36.444]                             muffled <- TRUE
[09:32:36.444]                             break
[09:32:36.444]                           }
[09:32:36.444]                         }
[09:32:36.444]                       }
[09:32:36.444]                       invisible(muffled)
[09:32:36.444]                     }
[09:32:36.444]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.444]                   }
[09:32:36.444]                 }
[09:32:36.444]                 else {
[09:32:36.444]                   if (TRUE) {
[09:32:36.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.444]                     {
[09:32:36.444]                       inherits <- base::inherits
[09:32:36.444]                       invokeRestart <- base::invokeRestart
[09:32:36.444]                       is.null <- base::is.null
[09:32:36.444]                       muffled <- FALSE
[09:32:36.444]                       if (inherits(cond, "message")) {
[09:32:36.444]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.444]                         if (muffled) 
[09:32:36.444]                           invokeRestart("muffleMessage")
[09:32:36.444]                       }
[09:32:36.444]                       else if (inherits(cond, "warning")) {
[09:32:36.444]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.444]                         if (muffled) 
[09:32:36.444]                           invokeRestart("muffleWarning")
[09:32:36.444]                       }
[09:32:36.444]                       else if (inherits(cond, "condition")) {
[09:32:36.444]                         if (!is.null(pattern)) {
[09:32:36.444]                           computeRestarts <- base::computeRestarts
[09:32:36.444]                           grepl <- base::grepl
[09:32:36.444]                           restarts <- computeRestarts(cond)
[09:32:36.444]                           for (restart in restarts) {
[09:32:36.444]                             name <- restart$name
[09:32:36.444]                             if (is.null(name)) 
[09:32:36.444]                               next
[09:32:36.444]                             if (!grepl(pattern, name)) 
[09:32:36.444]                               next
[09:32:36.444]                             invokeRestart(restart)
[09:32:36.444]                             muffled <- TRUE
[09:32:36.444]                             break
[09:32:36.444]                           }
[09:32:36.444]                         }
[09:32:36.444]                       }
[09:32:36.444]                       invisible(muffled)
[09:32:36.444]                     }
[09:32:36.444]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.444]                   }
[09:32:36.444]                 }
[09:32:36.444]             }
[09:32:36.444]         }))
[09:32:36.444]     }, error = function(ex) {
[09:32:36.444]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.444]                 ...future.rng), started = ...future.startTime, 
[09:32:36.444]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.444]             version = "1.8"), class = "FutureResult")
[09:32:36.444]     }, finally = {
[09:32:36.444]         if (!identical(...future.workdir, getwd())) 
[09:32:36.444]             setwd(...future.workdir)
[09:32:36.444]         {
[09:32:36.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.444]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.444]             }
[09:32:36.444]             base::options(...future.oldOptions)
[09:32:36.444]             if (.Platform$OS.type == "windows") {
[09:32:36.444]                 old_names <- names(...future.oldEnvVars)
[09:32:36.444]                 envs <- base::Sys.getenv()
[09:32:36.444]                 names <- names(envs)
[09:32:36.444]                 common <- intersect(names, old_names)
[09:32:36.444]                 added <- setdiff(names, old_names)
[09:32:36.444]                 removed <- setdiff(old_names, names)
[09:32:36.444]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.444]                   envs[common]]
[09:32:36.444]                 NAMES <- toupper(changed)
[09:32:36.444]                 args <- list()
[09:32:36.444]                 for (kk in seq_along(NAMES)) {
[09:32:36.444]                   name <- changed[[kk]]
[09:32:36.444]                   NAME <- NAMES[[kk]]
[09:32:36.444]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.444]                     next
[09:32:36.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.444]                 }
[09:32:36.444]                 NAMES <- toupper(added)
[09:32:36.444]                 for (kk in seq_along(NAMES)) {
[09:32:36.444]                   name <- added[[kk]]
[09:32:36.444]                   NAME <- NAMES[[kk]]
[09:32:36.444]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.444]                     next
[09:32:36.444]                   args[[name]] <- ""
[09:32:36.444]                 }
[09:32:36.444]                 NAMES <- toupper(removed)
[09:32:36.444]                 for (kk in seq_along(NAMES)) {
[09:32:36.444]                   name <- removed[[kk]]
[09:32:36.444]                   NAME <- NAMES[[kk]]
[09:32:36.444]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.444]                     next
[09:32:36.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.444]                 }
[09:32:36.444]                 if (length(args) > 0) 
[09:32:36.444]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.444]             }
[09:32:36.444]             else {
[09:32:36.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.444]             }
[09:32:36.444]             {
[09:32:36.444]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.444]                   0L) {
[09:32:36.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.444]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.444]                   base::options(opts)
[09:32:36.444]                 }
[09:32:36.444]                 {
[09:32:36.444]                   {
[09:32:36.444]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.444]                     NULL
[09:32:36.444]                   }
[09:32:36.444]                   options(future.plan = NULL)
[09:32:36.444]                   if (is.na(NA_character_)) 
[09:32:36.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.444]                     .init = FALSE)
[09:32:36.444]                 }
[09:32:36.444]             }
[09:32:36.444]         }
[09:32:36.444]     })
[09:32:36.444]     if (TRUE) {
[09:32:36.444]         base::sink(type = "output", split = FALSE)
[09:32:36.444]         if (TRUE) {
[09:32:36.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.444]         }
[09:32:36.444]         else {
[09:32:36.444]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.444]         }
[09:32:36.444]         base::close(...future.stdout)
[09:32:36.444]         ...future.stdout <- NULL
[09:32:36.444]     }
[09:32:36.444]     ...future.result$conditions <- ...future.conditions
[09:32:36.444]     ...future.result$finished <- base::Sys.time()
[09:32:36.444]     ...future.result
[09:32:36.444] }
[09:32:36.447] MultisessionFuture started
[09:32:36.447] - Launch lazy future ... done
[09:32:36.447] run() for ‘MultisessionFuture’ ... done
[09:32:36.447] resolve() on list ...
[09:32:36.447]  recursive: 0
[09:32:36.448]  length: 1
[09:32:36.448] 
[09:32:36.448] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.448] - Validating connection of MultisessionFuture
[09:32:36.448] - received message: FutureResult
[09:32:36.449] - Received FutureResult
[09:32:36.449] - Erased future from FutureRegistry
[09:32:36.449] result() for ClusterFuture ...
[09:32:36.449] - result already collected: FutureResult
[09:32:36.449] result() for ClusterFuture ... done
[09:32:36.449] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.449] Future #1
[09:32:36.449]  length: 0 (resolved future 1)
[09:32:36.449] resolve() on list ... DONE
[09:32:36.449] resolve() on list ...
[09:32:36.450]  recursive: 0
[09:32:36.450]  length: 1
[09:32:36.450] 
[09:32:36.949] receiveMessageFromWorker() for ClusterFuture ...
[09:32:36.950] - Validating connection of MultisessionFuture
[09:32:36.950] - received message: FutureResult
[09:32:36.950] - Received FutureResult
[09:32:36.950] - Erased future from FutureRegistry
[09:32:36.950] result() for ClusterFuture ...
[09:32:36.950] - result already collected: FutureResult
[09:32:36.950] result() for ClusterFuture ... done
[09:32:36.950] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:36.950] Future #1
[09:32:36.951]  length: 0 (resolved future 1)
[09:32:36.951] resolve() on list ... DONE
[09:32:36.951] resolve() on list ...
[09:32:36.951]  recursive: 0
[09:32:36.951]  length: 1
[09:32:36.951] 
[09:32:36.951]  length: 0 (resolved future 1)
[09:32:36.951] resolve() on list ... DONE
[09:32:36.952] resolve() on list ...
[09:32:36.952]  recursive: 0
[09:32:36.952]  length: 4
[09:32:36.952] 
[09:32:36.952] Future #1
[09:32:36.952]  length: 3 (resolved future 1)
[09:32:36.952] Future #2
[09:32:36.952]  length: 2 (resolved future 2)
[09:32:36.952]  length: 1 (resolved future 3)
[09:32:36.952]  length: 0 (resolved future 4)
[09:32:36.953] resolve() on list ... DONE
[09:32:36.953] resolve() on list ...
[09:32:36.953]  recursive: 0
[09:32:36.953]  length: 4
[09:32:36.953] 
[09:32:36.953] Future #1
[09:32:36.953]  length: 3 (resolved future 1)
[09:32:36.953] Future #2
[09:32:36.953]  length: 2 (resolved future 2)
[09:32:36.953]  length: 1 (resolved future 3)
[09:32:36.954]  length: 0 (resolved future 4)
[09:32:36.954] resolve() on list ... DONE
[09:32:36.954] resolve() on list ...
[09:32:36.954]  recursive: 0
[09:32:36.954]  length: 1
[09:32:36.954] 
[09:32:36.954]  length: 0 (resolved future 1)
[09:32:36.954] resolve() on list ... DONE
[09:32:36.954] getGlobalsAndPackages() ...
[09:32:36.954] Searching for globals...
[09:32:36.955] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:36.956] Searching for globals ... DONE
[09:32:36.956] Resolving globals: FALSE
[09:32:36.956] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:36.956] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:36.957] - globals: [1] ‘kk’
[09:32:36.957] 
[09:32:36.957] getGlobalsAndPackages() ... DONE
[09:32:36.957] run() for ‘Future’ ...
[09:32:36.957] - state: ‘created’
[09:32:36.957] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.972] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.972]   - Field: ‘node’
[09:32:36.972]   - Field: ‘label’
[09:32:36.972]   - Field: ‘local’
[09:32:36.972]   - Field: ‘owner’
[09:32:36.972]   - Field: ‘envir’
[09:32:36.972]   - Field: ‘workers’
[09:32:36.972]   - Field: ‘packages’
[09:32:36.972]   - Field: ‘gc’
[09:32:36.972]   - Field: ‘conditions’
[09:32:36.973]   - Field: ‘persistent’
[09:32:36.973]   - Field: ‘expr’
[09:32:36.973]   - Field: ‘uuid’
[09:32:36.973]   - Field: ‘seed’
[09:32:36.973]   - Field: ‘version’
[09:32:36.973]   - Field: ‘result’
[09:32:36.973]   - Field: ‘asynchronous’
[09:32:36.973]   - Field: ‘calls’
[09:32:36.973]   - Field: ‘globals’
[09:32:36.973]   - Field: ‘stdout’
[09:32:36.973]   - Field: ‘earlySignal’
[09:32:36.974]   - Field: ‘lazy’
[09:32:36.974]   - Field: ‘state’
[09:32:36.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.974] - Launch lazy future ...
[09:32:36.974] Packages needed by the future expression (n = 0): <none>
[09:32:36.974] Packages needed by future strategies (n = 0): <none>
[09:32:36.975] {
[09:32:36.975]     {
[09:32:36.975]         {
[09:32:36.975]             ...future.startTime <- base::Sys.time()
[09:32:36.975]             {
[09:32:36.975]                 {
[09:32:36.975]                   {
[09:32:36.975]                     {
[09:32:36.975]                       base::local({
[09:32:36.975]                         has_future <- base::requireNamespace("future", 
[09:32:36.975]                           quietly = TRUE)
[09:32:36.975]                         if (has_future) {
[09:32:36.975]                           ns <- base::getNamespace("future")
[09:32:36.975]                           version <- ns[[".package"]][["version"]]
[09:32:36.975]                           if (is.null(version)) 
[09:32:36.975]                             version <- utils::packageVersion("future")
[09:32:36.975]                         }
[09:32:36.975]                         else {
[09:32:36.975]                           version <- NULL
[09:32:36.975]                         }
[09:32:36.975]                         if (!has_future || version < "1.8.0") {
[09:32:36.975]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:36.975]                             "", base::R.version$version.string), 
[09:32:36.975]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:36.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:36.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:36.975]                               "release", "version")], collapse = " "), 
[09:32:36.975]                             hostname = base::Sys.info()[["nodename"]])
[09:32:36.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:36.975]                             info)
[09:32:36.975]                           info <- base::paste(info, collapse = "; ")
[09:32:36.975]                           if (!has_future) {
[09:32:36.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:36.975]                               info)
[09:32:36.975]                           }
[09:32:36.975]                           else {
[09:32:36.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:36.975]                               info, version)
[09:32:36.975]                           }
[09:32:36.975]                           base::stop(msg)
[09:32:36.975]                         }
[09:32:36.975]                       })
[09:32:36.975]                     }
[09:32:36.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:36.975]                     base::options(mc.cores = 1L)
[09:32:36.975]                   }
[09:32:36.975]                   ...future.strategy.old <- future::plan("list")
[09:32:36.975]                   options(future.plan = NULL)
[09:32:36.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:36.975]                 }
[09:32:36.975]                 ...future.workdir <- getwd()
[09:32:36.975]             }
[09:32:36.975]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:36.975]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:36.975]         }
[09:32:36.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:36.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:36.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:36.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:36.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:36.975]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:36.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:36.975]             base::names(...future.oldOptions))
[09:32:36.975]     }
[09:32:36.975]     if (FALSE) {
[09:32:36.975]     }
[09:32:36.975]     else {
[09:32:36.975]         if (TRUE) {
[09:32:36.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:36.975]                 open = "w")
[09:32:36.975]         }
[09:32:36.975]         else {
[09:32:36.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:36.975]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:36.975]         }
[09:32:36.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:36.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:36.975]             base::sink(type = "output", split = FALSE)
[09:32:36.975]             base::close(...future.stdout)
[09:32:36.975]         }, add = TRUE)
[09:32:36.975]     }
[09:32:36.975]     ...future.frame <- base::sys.nframe()
[09:32:36.975]     ...future.conditions <- base::list()
[09:32:36.975]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:36.975]     if (FALSE) {
[09:32:36.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:36.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:36.975]     }
[09:32:36.975]     ...future.result <- base::tryCatch({
[09:32:36.975]         base::withCallingHandlers({
[09:32:36.975]             ...future.value <- base::withVisible(base::local({
[09:32:36.975]                 ...future.makeSendCondition <- base::local({
[09:32:36.975]                   sendCondition <- NULL
[09:32:36.975]                   function(frame = 1L) {
[09:32:36.975]                     if (is.function(sendCondition)) 
[09:32:36.975]                       return(sendCondition)
[09:32:36.975]                     ns <- getNamespace("parallel")
[09:32:36.975]                     if (exists("sendData", mode = "function", 
[09:32:36.975]                       envir = ns)) {
[09:32:36.975]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:36.975]                         envir = ns)
[09:32:36.975]                       envir <- sys.frame(frame)
[09:32:36.975]                       master <- NULL
[09:32:36.975]                       while (!identical(envir, .GlobalEnv) && 
[09:32:36.975]                         !identical(envir, emptyenv())) {
[09:32:36.975]                         if (exists("master", mode = "list", envir = envir, 
[09:32:36.975]                           inherits = FALSE)) {
[09:32:36.975]                           master <- get("master", mode = "list", 
[09:32:36.975]                             envir = envir, inherits = FALSE)
[09:32:36.975]                           if (inherits(master, c("SOCKnode", 
[09:32:36.975]                             "SOCK0node"))) {
[09:32:36.975]                             sendCondition <<- function(cond) {
[09:32:36.975]                               data <- list(type = "VALUE", value = cond, 
[09:32:36.975]                                 success = TRUE)
[09:32:36.975]                               parallel_sendData(master, data)
[09:32:36.975]                             }
[09:32:36.975]                             return(sendCondition)
[09:32:36.975]                           }
[09:32:36.975]                         }
[09:32:36.975]                         frame <- frame + 1L
[09:32:36.975]                         envir <- sys.frame(frame)
[09:32:36.975]                       }
[09:32:36.975]                     }
[09:32:36.975]                     sendCondition <<- function(cond) NULL
[09:32:36.975]                   }
[09:32:36.975]                 })
[09:32:36.975]                 withCallingHandlers({
[09:32:36.975]                   {
[09:32:36.975]                     Sys.sleep(0.1)
[09:32:36.975]                     kk
[09:32:36.975]                   }
[09:32:36.975]                 }, immediateCondition = function(cond) {
[09:32:36.975]                   sendCondition <- ...future.makeSendCondition()
[09:32:36.975]                   sendCondition(cond)
[09:32:36.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.975]                   {
[09:32:36.975]                     inherits <- base::inherits
[09:32:36.975]                     invokeRestart <- base::invokeRestart
[09:32:36.975]                     is.null <- base::is.null
[09:32:36.975]                     muffled <- FALSE
[09:32:36.975]                     if (inherits(cond, "message")) {
[09:32:36.975]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:36.975]                       if (muffled) 
[09:32:36.975]                         invokeRestart("muffleMessage")
[09:32:36.975]                     }
[09:32:36.975]                     else if (inherits(cond, "warning")) {
[09:32:36.975]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:36.975]                       if (muffled) 
[09:32:36.975]                         invokeRestart("muffleWarning")
[09:32:36.975]                     }
[09:32:36.975]                     else if (inherits(cond, "condition")) {
[09:32:36.975]                       if (!is.null(pattern)) {
[09:32:36.975]                         computeRestarts <- base::computeRestarts
[09:32:36.975]                         grepl <- base::grepl
[09:32:36.975]                         restarts <- computeRestarts(cond)
[09:32:36.975]                         for (restart in restarts) {
[09:32:36.975]                           name <- restart$name
[09:32:36.975]                           if (is.null(name)) 
[09:32:36.975]                             next
[09:32:36.975]                           if (!grepl(pattern, name)) 
[09:32:36.975]                             next
[09:32:36.975]                           invokeRestart(restart)
[09:32:36.975]                           muffled <- TRUE
[09:32:36.975]                           break
[09:32:36.975]                         }
[09:32:36.975]                       }
[09:32:36.975]                     }
[09:32:36.975]                     invisible(muffled)
[09:32:36.975]                   }
[09:32:36.975]                   muffleCondition(cond)
[09:32:36.975]                 })
[09:32:36.975]             }))
[09:32:36.975]             future::FutureResult(value = ...future.value$value, 
[09:32:36.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.975]                   ...future.rng), globalenv = if (FALSE) 
[09:32:36.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:36.975]                     ...future.globalenv.names))
[09:32:36.975]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:36.975]         }, condition = base::local({
[09:32:36.975]             c <- base::c
[09:32:36.975]             inherits <- base::inherits
[09:32:36.975]             invokeRestart <- base::invokeRestart
[09:32:36.975]             length <- base::length
[09:32:36.975]             list <- base::list
[09:32:36.975]             seq.int <- base::seq.int
[09:32:36.975]             signalCondition <- base::signalCondition
[09:32:36.975]             sys.calls <- base::sys.calls
[09:32:36.975]             `[[` <- base::`[[`
[09:32:36.975]             `+` <- base::`+`
[09:32:36.975]             `<<-` <- base::`<<-`
[09:32:36.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:36.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:36.975]                   3L)]
[09:32:36.975]             }
[09:32:36.975]             function(cond) {
[09:32:36.975]                 is_error <- inherits(cond, "error")
[09:32:36.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:36.975]                   NULL)
[09:32:36.975]                 if (is_error) {
[09:32:36.975]                   sessionInformation <- function() {
[09:32:36.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:36.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:36.975]                       search = base::search(), system = base::Sys.info())
[09:32:36.975]                   }
[09:32:36.975]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:36.975]                     cond$call), session = sessionInformation(), 
[09:32:36.975]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:36.975]                   signalCondition(cond)
[09:32:36.975]                 }
[09:32:36.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:36.975]                 "immediateCondition"))) {
[09:32:36.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:36.975]                   ...future.conditions[[length(...future.conditions) + 
[09:32:36.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:36.975]                   if (TRUE && !signal) {
[09:32:36.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.975]                     {
[09:32:36.975]                       inherits <- base::inherits
[09:32:36.975]                       invokeRestart <- base::invokeRestart
[09:32:36.975]                       is.null <- base::is.null
[09:32:36.975]                       muffled <- FALSE
[09:32:36.975]                       if (inherits(cond, "message")) {
[09:32:36.975]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.975]                         if (muffled) 
[09:32:36.975]                           invokeRestart("muffleMessage")
[09:32:36.975]                       }
[09:32:36.975]                       else if (inherits(cond, "warning")) {
[09:32:36.975]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.975]                         if (muffled) 
[09:32:36.975]                           invokeRestart("muffleWarning")
[09:32:36.975]                       }
[09:32:36.975]                       else if (inherits(cond, "condition")) {
[09:32:36.975]                         if (!is.null(pattern)) {
[09:32:36.975]                           computeRestarts <- base::computeRestarts
[09:32:36.975]                           grepl <- base::grepl
[09:32:36.975]                           restarts <- computeRestarts(cond)
[09:32:36.975]                           for (restart in restarts) {
[09:32:36.975]                             name <- restart$name
[09:32:36.975]                             if (is.null(name)) 
[09:32:36.975]                               next
[09:32:36.975]                             if (!grepl(pattern, name)) 
[09:32:36.975]                               next
[09:32:36.975]                             invokeRestart(restart)
[09:32:36.975]                             muffled <- TRUE
[09:32:36.975]                             break
[09:32:36.975]                           }
[09:32:36.975]                         }
[09:32:36.975]                       }
[09:32:36.975]                       invisible(muffled)
[09:32:36.975]                     }
[09:32:36.975]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.975]                   }
[09:32:36.975]                 }
[09:32:36.975]                 else {
[09:32:36.975]                   if (TRUE) {
[09:32:36.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:36.975]                     {
[09:32:36.975]                       inherits <- base::inherits
[09:32:36.975]                       invokeRestart <- base::invokeRestart
[09:32:36.975]                       is.null <- base::is.null
[09:32:36.975]                       muffled <- FALSE
[09:32:36.975]                       if (inherits(cond, "message")) {
[09:32:36.975]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:36.975]                         if (muffled) 
[09:32:36.975]                           invokeRestart("muffleMessage")
[09:32:36.975]                       }
[09:32:36.975]                       else if (inherits(cond, "warning")) {
[09:32:36.975]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:36.975]                         if (muffled) 
[09:32:36.975]                           invokeRestart("muffleWarning")
[09:32:36.975]                       }
[09:32:36.975]                       else if (inherits(cond, "condition")) {
[09:32:36.975]                         if (!is.null(pattern)) {
[09:32:36.975]                           computeRestarts <- base::computeRestarts
[09:32:36.975]                           grepl <- base::grepl
[09:32:36.975]                           restarts <- computeRestarts(cond)
[09:32:36.975]                           for (restart in restarts) {
[09:32:36.975]                             name <- restart$name
[09:32:36.975]                             if (is.null(name)) 
[09:32:36.975]                               next
[09:32:36.975]                             if (!grepl(pattern, name)) 
[09:32:36.975]                               next
[09:32:36.975]                             invokeRestart(restart)
[09:32:36.975]                             muffled <- TRUE
[09:32:36.975]                             break
[09:32:36.975]                           }
[09:32:36.975]                         }
[09:32:36.975]                       }
[09:32:36.975]                       invisible(muffled)
[09:32:36.975]                     }
[09:32:36.975]                     muffleCondition(cond, pattern = "^muffle")
[09:32:36.975]                   }
[09:32:36.975]                 }
[09:32:36.975]             }
[09:32:36.975]         }))
[09:32:36.975]     }, error = function(ex) {
[09:32:36.975]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:36.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:36.975]                 ...future.rng), started = ...future.startTime, 
[09:32:36.975]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:36.975]             version = "1.8"), class = "FutureResult")
[09:32:36.975]     }, finally = {
[09:32:36.975]         if (!identical(...future.workdir, getwd())) 
[09:32:36.975]             setwd(...future.workdir)
[09:32:36.975]         {
[09:32:36.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:36.975]                 ...future.oldOptions$nwarnings <- NULL
[09:32:36.975]             }
[09:32:36.975]             base::options(...future.oldOptions)
[09:32:36.975]             if (.Platform$OS.type == "windows") {
[09:32:36.975]                 old_names <- names(...future.oldEnvVars)
[09:32:36.975]                 envs <- base::Sys.getenv()
[09:32:36.975]                 names <- names(envs)
[09:32:36.975]                 common <- intersect(names, old_names)
[09:32:36.975]                 added <- setdiff(names, old_names)
[09:32:36.975]                 removed <- setdiff(old_names, names)
[09:32:36.975]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:36.975]                   envs[common]]
[09:32:36.975]                 NAMES <- toupper(changed)
[09:32:36.975]                 args <- list()
[09:32:36.975]                 for (kk in seq_along(NAMES)) {
[09:32:36.975]                   name <- changed[[kk]]
[09:32:36.975]                   NAME <- NAMES[[kk]]
[09:32:36.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.975]                     next
[09:32:36.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.975]                 }
[09:32:36.975]                 NAMES <- toupper(added)
[09:32:36.975]                 for (kk in seq_along(NAMES)) {
[09:32:36.975]                   name <- added[[kk]]
[09:32:36.975]                   NAME <- NAMES[[kk]]
[09:32:36.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.975]                     next
[09:32:36.975]                   args[[name]] <- ""
[09:32:36.975]                 }
[09:32:36.975]                 NAMES <- toupper(removed)
[09:32:36.975]                 for (kk in seq_along(NAMES)) {
[09:32:36.975]                   name <- removed[[kk]]
[09:32:36.975]                   NAME <- NAMES[[kk]]
[09:32:36.975]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:36.975]                     next
[09:32:36.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:36.975]                 }
[09:32:36.975]                 if (length(args) > 0) 
[09:32:36.975]                   base::do.call(base::Sys.setenv, args = args)
[09:32:36.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:36.975]             }
[09:32:36.975]             else {
[09:32:36.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:36.975]             }
[09:32:36.975]             {
[09:32:36.975]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:36.975]                   0L) {
[09:32:36.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:36.975]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:36.975]                   base::options(opts)
[09:32:36.975]                 }
[09:32:36.975]                 {
[09:32:36.975]                   {
[09:32:36.975]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:36.975]                     NULL
[09:32:36.975]                   }
[09:32:36.975]                   options(future.plan = NULL)
[09:32:36.975]                   if (is.na(NA_character_)) 
[09:32:36.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:36.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:36.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:36.975]                     .init = FALSE)
[09:32:36.975]                 }
[09:32:36.975]             }
[09:32:36.975]         }
[09:32:36.975]     })
[09:32:36.975]     if (TRUE) {
[09:32:36.975]         base::sink(type = "output", split = FALSE)
[09:32:36.975]         if (TRUE) {
[09:32:36.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:36.975]         }
[09:32:36.975]         else {
[09:32:36.975]             ...future.result["stdout"] <- base::list(NULL)
[09:32:36.975]         }
[09:32:36.975]         base::close(...future.stdout)
[09:32:36.975]         ...future.stdout <- NULL
[09:32:36.975]     }
[09:32:36.975]     ...future.result$conditions <- ...future.conditions
[09:32:36.975]     ...future.result$finished <- base::Sys.time()
[09:32:36.975]     ...future.result
[09:32:36.975] }
[09:32:36.977] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:32:36.977] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[09:32:36.978] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[09:32:36.978] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:32:36.978] MultisessionFuture started
[09:32:36.979] - Launch lazy future ... done
[09:32:36.979] run() for ‘MultisessionFuture’ ... done
[09:32:36.979] getGlobalsAndPackages() ...
[09:32:36.979] Searching for globals...
[09:32:36.980] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:36.981] Searching for globals ... DONE
[09:32:36.981] Resolving globals: FALSE
[09:32:36.981] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:36.981] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:36.981] - globals: [1] ‘kk’
[09:32:36.982] 
[09:32:36.982] getGlobalsAndPackages() ... DONE
[09:32:36.982] run() for ‘Future’ ...
[09:32:36.982] - state: ‘created’
[09:32:36.982] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:36.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:36.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:36.997]   - Field: ‘node’
[09:32:36.997]   - Field: ‘label’
[09:32:36.997]   - Field: ‘local’
[09:32:36.997]   - Field: ‘owner’
[09:32:36.998]   - Field: ‘envir’
[09:32:36.998]   - Field: ‘workers’
[09:32:36.998]   - Field: ‘packages’
[09:32:36.998]   - Field: ‘gc’
[09:32:36.998]   - Field: ‘conditions’
[09:32:36.998]   - Field: ‘persistent’
[09:32:36.998]   - Field: ‘expr’
[09:32:36.998]   - Field: ‘uuid’
[09:32:36.998]   - Field: ‘seed’
[09:32:36.998]   - Field: ‘version’
[09:32:36.998]   - Field: ‘result’
[09:32:36.999]   - Field: ‘asynchronous’
[09:32:36.999]   - Field: ‘calls’
[09:32:36.999]   - Field: ‘globals’
[09:32:36.999]   - Field: ‘stdout’
[09:32:36.999]   - Field: ‘earlySignal’
[09:32:36.999]   - Field: ‘lazy’
[09:32:36.999]   - Field: ‘state’
[09:32:36.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:36.999] - Launch lazy future ...
[09:32:37.000] Packages needed by the future expression (n = 0): <none>
[09:32:37.000] Packages needed by future strategies (n = 0): <none>
[09:32:37.000] {
[09:32:37.000]     {
[09:32:37.000]         {
[09:32:37.000]             ...future.startTime <- base::Sys.time()
[09:32:37.000]             {
[09:32:37.000]                 {
[09:32:37.000]                   {
[09:32:37.000]                     {
[09:32:37.000]                       base::local({
[09:32:37.000]                         has_future <- base::requireNamespace("future", 
[09:32:37.000]                           quietly = TRUE)
[09:32:37.000]                         if (has_future) {
[09:32:37.000]                           ns <- base::getNamespace("future")
[09:32:37.000]                           version <- ns[[".package"]][["version"]]
[09:32:37.000]                           if (is.null(version)) 
[09:32:37.000]                             version <- utils::packageVersion("future")
[09:32:37.000]                         }
[09:32:37.000]                         else {
[09:32:37.000]                           version <- NULL
[09:32:37.000]                         }
[09:32:37.000]                         if (!has_future || version < "1.8.0") {
[09:32:37.000]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.000]                             "", base::R.version$version.string), 
[09:32:37.000]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.000]                               "release", "version")], collapse = " "), 
[09:32:37.000]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.000]                             info)
[09:32:37.000]                           info <- base::paste(info, collapse = "; ")
[09:32:37.000]                           if (!has_future) {
[09:32:37.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.000]                               info)
[09:32:37.000]                           }
[09:32:37.000]                           else {
[09:32:37.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.000]                               info, version)
[09:32:37.000]                           }
[09:32:37.000]                           base::stop(msg)
[09:32:37.000]                         }
[09:32:37.000]                       })
[09:32:37.000]                     }
[09:32:37.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.000]                     base::options(mc.cores = 1L)
[09:32:37.000]                   }
[09:32:37.000]                   ...future.strategy.old <- future::plan("list")
[09:32:37.000]                   options(future.plan = NULL)
[09:32:37.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.000]                 }
[09:32:37.000]                 ...future.workdir <- getwd()
[09:32:37.000]             }
[09:32:37.000]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.000]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.000]         }
[09:32:37.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.000]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.000]             base::names(...future.oldOptions))
[09:32:37.000]     }
[09:32:37.000]     if (FALSE) {
[09:32:37.000]     }
[09:32:37.000]     else {
[09:32:37.000]         if (TRUE) {
[09:32:37.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.000]                 open = "w")
[09:32:37.000]         }
[09:32:37.000]         else {
[09:32:37.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.000]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.000]         }
[09:32:37.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.000]             base::sink(type = "output", split = FALSE)
[09:32:37.000]             base::close(...future.stdout)
[09:32:37.000]         }, add = TRUE)
[09:32:37.000]     }
[09:32:37.000]     ...future.frame <- base::sys.nframe()
[09:32:37.000]     ...future.conditions <- base::list()
[09:32:37.000]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.000]     if (FALSE) {
[09:32:37.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.000]     }
[09:32:37.000]     ...future.result <- base::tryCatch({
[09:32:37.000]         base::withCallingHandlers({
[09:32:37.000]             ...future.value <- base::withVisible(base::local({
[09:32:37.000]                 ...future.makeSendCondition <- base::local({
[09:32:37.000]                   sendCondition <- NULL
[09:32:37.000]                   function(frame = 1L) {
[09:32:37.000]                     if (is.function(sendCondition)) 
[09:32:37.000]                       return(sendCondition)
[09:32:37.000]                     ns <- getNamespace("parallel")
[09:32:37.000]                     if (exists("sendData", mode = "function", 
[09:32:37.000]                       envir = ns)) {
[09:32:37.000]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.000]                         envir = ns)
[09:32:37.000]                       envir <- sys.frame(frame)
[09:32:37.000]                       master <- NULL
[09:32:37.000]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.000]                         !identical(envir, emptyenv())) {
[09:32:37.000]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.000]                           inherits = FALSE)) {
[09:32:37.000]                           master <- get("master", mode = "list", 
[09:32:37.000]                             envir = envir, inherits = FALSE)
[09:32:37.000]                           if (inherits(master, c("SOCKnode", 
[09:32:37.000]                             "SOCK0node"))) {
[09:32:37.000]                             sendCondition <<- function(cond) {
[09:32:37.000]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.000]                                 success = TRUE)
[09:32:37.000]                               parallel_sendData(master, data)
[09:32:37.000]                             }
[09:32:37.000]                             return(sendCondition)
[09:32:37.000]                           }
[09:32:37.000]                         }
[09:32:37.000]                         frame <- frame + 1L
[09:32:37.000]                         envir <- sys.frame(frame)
[09:32:37.000]                       }
[09:32:37.000]                     }
[09:32:37.000]                     sendCondition <<- function(cond) NULL
[09:32:37.000]                   }
[09:32:37.000]                 })
[09:32:37.000]                 withCallingHandlers({
[09:32:37.000]                   {
[09:32:37.000]                     Sys.sleep(0.1)
[09:32:37.000]                     kk
[09:32:37.000]                   }
[09:32:37.000]                 }, immediateCondition = function(cond) {
[09:32:37.000]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.000]                   sendCondition(cond)
[09:32:37.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.000]                   {
[09:32:37.000]                     inherits <- base::inherits
[09:32:37.000]                     invokeRestart <- base::invokeRestart
[09:32:37.000]                     is.null <- base::is.null
[09:32:37.000]                     muffled <- FALSE
[09:32:37.000]                     if (inherits(cond, "message")) {
[09:32:37.000]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.000]                       if (muffled) 
[09:32:37.000]                         invokeRestart("muffleMessage")
[09:32:37.000]                     }
[09:32:37.000]                     else if (inherits(cond, "warning")) {
[09:32:37.000]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.000]                       if (muffled) 
[09:32:37.000]                         invokeRestart("muffleWarning")
[09:32:37.000]                     }
[09:32:37.000]                     else if (inherits(cond, "condition")) {
[09:32:37.000]                       if (!is.null(pattern)) {
[09:32:37.000]                         computeRestarts <- base::computeRestarts
[09:32:37.000]                         grepl <- base::grepl
[09:32:37.000]                         restarts <- computeRestarts(cond)
[09:32:37.000]                         for (restart in restarts) {
[09:32:37.000]                           name <- restart$name
[09:32:37.000]                           if (is.null(name)) 
[09:32:37.000]                             next
[09:32:37.000]                           if (!grepl(pattern, name)) 
[09:32:37.000]                             next
[09:32:37.000]                           invokeRestart(restart)
[09:32:37.000]                           muffled <- TRUE
[09:32:37.000]                           break
[09:32:37.000]                         }
[09:32:37.000]                       }
[09:32:37.000]                     }
[09:32:37.000]                     invisible(muffled)
[09:32:37.000]                   }
[09:32:37.000]                   muffleCondition(cond)
[09:32:37.000]                 })
[09:32:37.000]             }))
[09:32:37.000]             future::FutureResult(value = ...future.value$value, 
[09:32:37.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.000]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.000]                     ...future.globalenv.names))
[09:32:37.000]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.000]         }, condition = base::local({
[09:32:37.000]             c <- base::c
[09:32:37.000]             inherits <- base::inherits
[09:32:37.000]             invokeRestart <- base::invokeRestart
[09:32:37.000]             length <- base::length
[09:32:37.000]             list <- base::list
[09:32:37.000]             seq.int <- base::seq.int
[09:32:37.000]             signalCondition <- base::signalCondition
[09:32:37.000]             sys.calls <- base::sys.calls
[09:32:37.000]             `[[` <- base::`[[`
[09:32:37.000]             `+` <- base::`+`
[09:32:37.000]             `<<-` <- base::`<<-`
[09:32:37.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.000]                   3L)]
[09:32:37.000]             }
[09:32:37.000]             function(cond) {
[09:32:37.000]                 is_error <- inherits(cond, "error")
[09:32:37.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.000]                   NULL)
[09:32:37.000]                 if (is_error) {
[09:32:37.000]                   sessionInformation <- function() {
[09:32:37.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.000]                       search = base::search(), system = base::Sys.info())
[09:32:37.000]                   }
[09:32:37.000]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.000]                     cond$call), session = sessionInformation(), 
[09:32:37.000]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.000]                   signalCondition(cond)
[09:32:37.000]                 }
[09:32:37.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.000]                 "immediateCondition"))) {
[09:32:37.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.000]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.000]                   if (TRUE && !signal) {
[09:32:37.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.000]                     {
[09:32:37.000]                       inherits <- base::inherits
[09:32:37.000]                       invokeRestart <- base::invokeRestart
[09:32:37.000]                       is.null <- base::is.null
[09:32:37.000]                       muffled <- FALSE
[09:32:37.000]                       if (inherits(cond, "message")) {
[09:32:37.000]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.000]                         if (muffled) 
[09:32:37.000]                           invokeRestart("muffleMessage")
[09:32:37.000]                       }
[09:32:37.000]                       else if (inherits(cond, "warning")) {
[09:32:37.000]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.000]                         if (muffled) 
[09:32:37.000]                           invokeRestart("muffleWarning")
[09:32:37.000]                       }
[09:32:37.000]                       else if (inherits(cond, "condition")) {
[09:32:37.000]                         if (!is.null(pattern)) {
[09:32:37.000]                           computeRestarts <- base::computeRestarts
[09:32:37.000]                           grepl <- base::grepl
[09:32:37.000]                           restarts <- computeRestarts(cond)
[09:32:37.000]                           for (restart in restarts) {
[09:32:37.000]                             name <- restart$name
[09:32:37.000]                             if (is.null(name)) 
[09:32:37.000]                               next
[09:32:37.000]                             if (!grepl(pattern, name)) 
[09:32:37.000]                               next
[09:32:37.000]                             invokeRestart(restart)
[09:32:37.000]                             muffled <- TRUE
[09:32:37.000]                             break
[09:32:37.000]                           }
[09:32:37.000]                         }
[09:32:37.000]                       }
[09:32:37.000]                       invisible(muffled)
[09:32:37.000]                     }
[09:32:37.000]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.000]                   }
[09:32:37.000]                 }
[09:32:37.000]                 else {
[09:32:37.000]                   if (TRUE) {
[09:32:37.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.000]                     {
[09:32:37.000]                       inherits <- base::inherits
[09:32:37.000]                       invokeRestart <- base::invokeRestart
[09:32:37.000]                       is.null <- base::is.null
[09:32:37.000]                       muffled <- FALSE
[09:32:37.000]                       if (inherits(cond, "message")) {
[09:32:37.000]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.000]                         if (muffled) 
[09:32:37.000]                           invokeRestart("muffleMessage")
[09:32:37.000]                       }
[09:32:37.000]                       else if (inherits(cond, "warning")) {
[09:32:37.000]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.000]                         if (muffled) 
[09:32:37.000]                           invokeRestart("muffleWarning")
[09:32:37.000]                       }
[09:32:37.000]                       else if (inherits(cond, "condition")) {
[09:32:37.000]                         if (!is.null(pattern)) {
[09:32:37.000]                           computeRestarts <- base::computeRestarts
[09:32:37.000]                           grepl <- base::grepl
[09:32:37.000]                           restarts <- computeRestarts(cond)
[09:32:37.000]                           for (restart in restarts) {
[09:32:37.000]                             name <- restart$name
[09:32:37.000]                             if (is.null(name)) 
[09:32:37.000]                               next
[09:32:37.000]                             if (!grepl(pattern, name)) 
[09:32:37.000]                               next
[09:32:37.000]                             invokeRestart(restart)
[09:32:37.000]                             muffled <- TRUE
[09:32:37.000]                             break
[09:32:37.000]                           }
[09:32:37.000]                         }
[09:32:37.000]                       }
[09:32:37.000]                       invisible(muffled)
[09:32:37.000]                     }
[09:32:37.000]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.000]                   }
[09:32:37.000]                 }
[09:32:37.000]             }
[09:32:37.000]         }))
[09:32:37.000]     }, error = function(ex) {
[09:32:37.000]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.000]                 ...future.rng), started = ...future.startTime, 
[09:32:37.000]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.000]             version = "1.8"), class = "FutureResult")
[09:32:37.000]     }, finally = {
[09:32:37.000]         if (!identical(...future.workdir, getwd())) 
[09:32:37.000]             setwd(...future.workdir)
[09:32:37.000]         {
[09:32:37.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.000]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.000]             }
[09:32:37.000]             base::options(...future.oldOptions)
[09:32:37.000]             if (.Platform$OS.type == "windows") {
[09:32:37.000]                 old_names <- names(...future.oldEnvVars)
[09:32:37.000]                 envs <- base::Sys.getenv()
[09:32:37.000]                 names <- names(envs)
[09:32:37.000]                 common <- intersect(names, old_names)
[09:32:37.000]                 added <- setdiff(names, old_names)
[09:32:37.000]                 removed <- setdiff(old_names, names)
[09:32:37.000]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.000]                   envs[common]]
[09:32:37.000]                 NAMES <- toupper(changed)
[09:32:37.000]                 args <- list()
[09:32:37.000]                 for (kk in seq_along(NAMES)) {
[09:32:37.000]                   name <- changed[[kk]]
[09:32:37.000]                   NAME <- NAMES[[kk]]
[09:32:37.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.000]                     next
[09:32:37.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.000]                 }
[09:32:37.000]                 NAMES <- toupper(added)
[09:32:37.000]                 for (kk in seq_along(NAMES)) {
[09:32:37.000]                   name <- added[[kk]]
[09:32:37.000]                   NAME <- NAMES[[kk]]
[09:32:37.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.000]                     next
[09:32:37.000]                   args[[name]] <- ""
[09:32:37.000]                 }
[09:32:37.000]                 NAMES <- toupper(removed)
[09:32:37.000]                 for (kk in seq_along(NAMES)) {
[09:32:37.000]                   name <- removed[[kk]]
[09:32:37.000]                   NAME <- NAMES[[kk]]
[09:32:37.000]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.000]                     next
[09:32:37.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.000]                 }
[09:32:37.000]                 if (length(args) > 0) 
[09:32:37.000]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.000]             }
[09:32:37.000]             else {
[09:32:37.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.000]             }
[09:32:37.000]             {
[09:32:37.000]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.000]                   0L) {
[09:32:37.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.000]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.000]                   base::options(opts)
[09:32:37.000]                 }
[09:32:37.000]                 {
[09:32:37.000]                   {
[09:32:37.000]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.000]                     NULL
[09:32:37.000]                   }
[09:32:37.000]                   options(future.plan = NULL)
[09:32:37.000]                   if (is.na(NA_character_)) 
[09:32:37.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.000]                     .init = FALSE)
[09:32:37.000]                 }
[09:32:37.000]             }
[09:32:37.000]         }
[09:32:37.000]     })
[09:32:37.000]     if (TRUE) {
[09:32:37.000]         base::sink(type = "output", split = FALSE)
[09:32:37.000]         if (TRUE) {
[09:32:37.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.000]         }
[09:32:37.000]         else {
[09:32:37.000]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.000]         }
[09:32:37.000]         base::close(...future.stdout)
[09:32:37.000]         ...future.stdout <- NULL
[09:32:37.000]     }
[09:32:37.000]     ...future.result$conditions <- ...future.conditions
[09:32:37.000]     ...future.result$finished <- base::Sys.time()
[09:32:37.000]     ...future.result
[09:32:37.000] }
[09:32:37.003] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:32:37.003] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[09:32:37.003] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[09:32:37.003] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:32:37.004] MultisessionFuture started
[09:32:37.004] - Launch lazy future ... done
[09:32:37.004] run() for ‘MultisessionFuture’ ... done
[09:32:37.004] getGlobalsAndPackages() ...
[09:32:37.004] Searching for globals...
[09:32:37.005] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:37.005] Searching for globals ... DONE
[09:32:37.005] Resolving globals: FALSE
[09:32:37.005] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:37.006] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:37.006] - globals: [1] ‘kk’
[09:32:37.006] 
[09:32:37.006] getGlobalsAndPackages() ... DONE
[09:32:37.006] run() for ‘Future’ ...
[09:32:37.006] - state: ‘created’
[09:32:37.007] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.020] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.020]   - Field: ‘node’
[09:32:37.020]   - Field: ‘label’
[09:32:37.020]   - Field: ‘local’
[09:32:37.020]   - Field: ‘owner’
[09:32:37.021]   - Field: ‘envir’
[09:32:37.021]   - Field: ‘workers’
[09:32:37.021]   - Field: ‘packages’
[09:32:37.021]   - Field: ‘gc’
[09:32:37.021]   - Field: ‘conditions’
[09:32:37.021]   - Field: ‘persistent’
[09:32:37.021]   - Field: ‘expr’
[09:32:37.021]   - Field: ‘uuid’
[09:32:37.021]   - Field: ‘seed’
[09:32:37.021]   - Field: ‘version’
[09:32:37.021]   - Field: ‘result’
[09:32:37.022]   - Field: ‘asynchronous’
[09:32:37.022]   - Field: ‘calls’
[09:32:37.022]   - Field: ‘globals’
[09:32:37.022]   - Field: ‘stdout’
[09:32:37.022]   - Field: ‘earlySignal’
[09:32:37.022]   - Field: ‘lazy’
[09:32:37.022]   - Field: ‘state’
[09:32:37.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.022] - Launch lazy future ...
[09:32:37.023] Packages needed by the future expression (n = 0): <none>
[09:32:37.023] Packages needed by future strategies (n = 0): <none>
[09:32:37.023] {
[09:32:37.023]     {
[09:32:37.023]         {
[09:32:37.023]             ...future.startTime <- base::Sys.time()
[09:32:37.023]             {
[09:32:37.023]                 {
[09:32:37.023]                   {
[09:32:37.023]                     {
[09:32:37.023]                       base::local({
[09:32:37.023]                         has_future <- base::requireNamespace("future", 
[09:32:37.023]                           quietly = TRUE)
[09:32:37.023]                         if (has_future) {
[09:32:37.023]                           ns <- base::getNamespace("future")
[09:32:37.023]                           version <- ns[[".package"]][["version"]]
[09:32:37.023]                           if (is.null(version)) 
[09:32:37.023]                             version <- utils::packageVersion("future")
[09:32:37.023]                         }
[09:32:37.023]                         else {
[09:32:37.023]                           version <- NULL
[09:32:37.023]                         }
[09:32:37.023]                         if (!has_future || version < "1.8.0") {
[09:32:37.023]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.023]                             "", base::R.version$version.string), 
[09:32:37.023]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.023]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.023]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.023]                               "release", "version")], collapse = " "), 
[09:32:37.023]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.023]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.023]                             info)
[09:32:37.023]                           info <- base::paste(info, collapse = "; ")
[09:32:37.023]                           if (!has_future) {
[09:32:37.023]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.023]                               info)
[09:32:37.023]                           }
[09:32:37.023]                           else {
[09:32:37.023]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.023]                               info, version)
[09:32:37.023]                           }
[09:32:37.023]                           base::stop(msg)
[09:32:37.023]                         }
[09:32:37.023]                       })
[09:32:37.023]                     }
[09:32:37.023]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.023]                     base::options(mc.cores = 1L)
[09:32:37.023]                   }
[09:32:37.023]                   ...future.strategy.old <- future::plan("list")
[09:32:37.023]                   options(future.plan = NULL)
[09:32:37.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.023]                 }
[09:32:37.023]                 ...future.workdir <- getwd()
[09:32:37.023]             }
[09:32:37.023]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.023]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.023]         }
[09:32:37.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.023]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.023]             base::names(...future.oldOptions))
[09:32:37.023]     }
[09:32:37.023]     if (FALSE) {
[09:32:37.023]     }
[09:32:37.023]     else {
[09:32:37.023]         if (TRUE) {
[09:32:37.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.023]                 open = "w")
[09:32:37.023]         }
[09:32:37.023]         else {
[09:32:37.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.023]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.023]         }
[09:32:37.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.023]             base::sink(type = "output", split = FALSE)
[09:32:37.023]             base::close(...future.stdout)
[09:32:37.023]         }, add = TRUE)
[09:32:37.023]     }
[09:32:37.023]     ...future.frame <- base::sys.nframe()
[09:32:37.023]     ...future.conditions <- base::list()
[09:32:37.023]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.023]     if (FALSE) {
[09:32:37.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.023]     }
[09:32:37.023]     ...future.result <- base::tryCatch({
[09:32:37.023]         base::withCallingHandlers({
[09:32:37.023]             ...future.value <- base::withVisible(base::local({
[09:32:37.023]                 ...future.makeSendCondition <- base::local({
[09:32:37.023]                   sendCondition <- NULL
[09:32:37.023]                   function(frame = 1L) {
[09:32:37.023]                     if (is.function(sendCondition)) 
[09:32:37.023]                       return(sendCondition)
[09:32:37.023]                     ns <- getNamespace("parallel")
[09:32:37.023]                     if (exists("sendData", mode = "function", 
[09:32:37.023]                       envir = ns)) {
[09:32:37.023]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.023]                         envir = ns)
[09:32:37.023]                       envir <- sys.frame(frame)
[09:32:37.023]                       master <- NULL
[09:32:37.023]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.023]                         !identical(envir, emptyenv())) {
[09:32:37.023]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.023]                           inherits = FALSE)) {
[09:32:37.023]                           master <- get("master", mode = "list", 
[09:32:37.023]                             envir = envir, inherits = FALSE)
[09:32:37.023]                           if (inherits(master, c("SOCKnode", 
[09:32:37.023]                             "SOCK0node"))) {
[09:32:37.023]                             sendCondition <<- function(cond) {
[09:32:37.023]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.023]                                 success = TRUE)
[09:32:37.023]                               parallel_sendData(master, data)
[09:32:37.023]                             }
[09:32:37.023]                             return(sendCondition)
[09:32:37.023]                           }
[09:32:37.023]                         }
[09:32:37.023]                         frame <- frame + 1L
[09:32:37.023]                         envir <- sys.frame(frame)
[09:32:37.023]                       }
[09:32:37.023]                     }
[09:32:37.023]                     sendCondition <<- function(cond) NULL
[09:32:37.023]                   }
[09:32:37.023]                 })
[09:32:37.023]                 withCallingHandlers({
[09:32:37.023]                   {
[09:32:37.023]                     Sys.sleep(0.1)
[09:32:37.023]                     kk
[09:32:37.023]                   }
[09:32:37.023]                 }, immediateCondition = function(cond) {
[09:32:37.023]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.023]                   sendCondition(cond)
[09:32:37.023]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.023]                   {
[09:32:37.023]                     inherits <- base::inherits
[09:32:37.023]                     invokeRestart <- base::invokeRestart
[09:32:37.023]                     is.null <- base::is.null
[09:32:37.023]                     muffled <- FALSE
[09:32:37.023]                     if (inherits(cond, "message")) {
[09:32:37.023]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.023]                       if (muffled) 
[09:32:37.023]                         invokeRestart("muffleMessage")
[09:32:37.023]                     }
[09:32:37.023]                     else if (inherits(cond, "warning")) {
[09:32:37.023]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.023]                       if (muffled) 
[09:32:37.023]                         invokeRestart("muffleWarning")
[09:32:37.023]                     }
[09:32:37.023]                     else if (inherits(cond, "condition")) {
[09:32:37.023]                       if (!is.null(pattern)) {
[09:32:37.023]                         computeRestarts <- base::computeRestarts
[09:32:37.023]                         grepl <- base::grepl
[09:32:37.023]                         restarts <- computeRestarts(cond)
[09:32:37.023]                         for (restart in restarts) {
[09:32:37.023]                           name <- restart$name
[09:32:37.023]                           if (is.null(name)) 
[09:32:37.023]                             next
[09:32:37.023]                           if (!grepl(pattern, name)) 
[09:32:37.023]                             next
[09:32:37.023]                           invokeRestart(restart)
[09:32:37.023]                           muffled <- TRUE
[09:32:37.023]                           break
[09:32:37.023]                         }
[09:32:37.023]                       }
[09:32:37.023]                     }
[09:32:37.023]                     invisible(muffled)
[09:32:37.023]                   }
[09:32:37.023]                   muffleCondition(cond)
[09:32:37.023]                 })
[09:32:37.023]             }))
[09:32:37.023]             future::FutureResult(value = ...future.value$value, 
[09:32:37.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.023]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.023]                     ...future.globalenv.names))
[09:32:37.023]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.023]         }, condition = base::local({
[09:32:37.023]             c <- base::c
[09:32:37.023]             inherits <- base::inherits
[09:32:37.023]             invokeRestart <- base::invokeRestart
[09:32:37.023]             length <- base::length
[09:32:37.023]             list <- base::list
[09:32:37.023]             seq.int <- base::seq.int
[09:32:37.023]             signalCondition <- base::signalCondition
[09:32:37.023]             sys.calls <- base::sys.calls
[09:32:37.023]             `[[` <- base::`[[`
[09:32:37.023]             `+` <- base::`+`
[09:32:37.023]             `<<-` <- base::`<<-`
[09:32:37.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.023]                   3L)]
[09:32:37.023]             }
[09:32:37.023]             function(cond) {
[09:32:37.023]                 is_error <- inherits(cond, "error")
[09:32:37.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.023]                   NULL)
[09:32:37.023]                 if (is_error) {
[09:32:37.023]                   sessionInformation <- function() {
[09:32:37.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.023]                       search = base::search(), system = base::Sys.info())
[09:32:37.023]                   }
[09:32:37.023]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.023]                     cond$call), session = sessionInformation(), 
[09:32:37.023]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.023]                   signalCondition(cond)
[09:32:37.023]                 }
[09:32:37.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.023]                 "immediateCondition"))) {
[09:32:37.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.023]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.023]                   if (TRUE && !signal) {
[09:32:37.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.023]                     {
[09:32:37.023]                       inherits <- base::inherits
[09:32:37.023]                       invokeRestart <- base::invokeRestart
[09:32:37.023]                       is.null <- base::is.null
[09:32:37.023]                       muffled <- FALSE
[09:32:37.023]                       if (inherits(cond, "message")) {
[09:32:37.023]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.023]                         if (muffled) 
[09:32:37.023]                           invokeRestart("muffleMessage")
[09:32:37.023]                       }
[09:32:37.023]                       else if (inherits(cond, "warning")) {
[09:32:37.023]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.023]                         if (muffled) 
[09:32:37.023]                           invokeRestart("muffleWarning")
[09:32:37.023]                       }
[09:32:37.023]                       else if (inherits(cond, "condition")) {
[09:32:37.023]                         if (!is.null(pattern)) {
[09:32:37.023]                           computeRestarts <- base::computeRestarts
[09:32:37.023]                           grepl <- base::grepl
[09:32:37.023]                           restarts <- computeRestarts(cond)
[09:32:37.023]                           for (restart in restarts) {
[09:32:37.023]                             name <- restart$name
[09:32:37.023]                             if (is.null(name)) 
[09:32:37.023]                               next
[09:32:37.023]                             if (!grepl(pattern, name)) 
[09:32:37.023]                               next
[09:32:37.023]                             invokeRestart(restart)
[09:32:37.023]                             muffled <- TRUE
[09:32:37.023]                             break
[09:32:37.023]                           }
[09:32:37.023]                         }
[09:32:37.023]                       }
[09:32:37.023]                       invisible(muffled)
[09:32:37.023]                     }
[09:32:37.023]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.023]                   }
[09:32:37.023]                 }
[09:32:37.023]                 else {
[09:32:37.023]                   if (TRUE) {
[09:32:37.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.023]                     {
[09:32:37.023]                       inherits <- base::inherits
[09:32:37.023]                       invokeRestart <- base::invokeRestart
[09:32:37.023]                       is.null <- base::is.null
[09:32:37.023]                       muffled <- FALSE
[09:32:37.023]                       if (inherits(cond, "message")) {
[09:32:37.023]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.023]                         if (muffled) 
[09:32:37.023]                           invokeRestart("muffleMessage")
[09:32:37.023]                       }
[09:32:37.023]                       else if (inherits(cond, "warning")) {
[09:32:37.023]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.023]                         if (muffled) 
[09:32:37.023]                           invokeRestart("muffleWarning")
[09:32:37.023]                       }
[09:32:37.023]                       else if (inherits(cond, "condition")) {
[09:32:37.023]                         if (!is.null(pattern)) {
[09:32:37.023]                           computeRestarts <- base::computeRestarts
[09:32:37.023]                           grepl <- base::grepl
[09:32:37.023]                           restarts <- computeRestarts(cond)
[09:32:37.023]                           for (restart in restarts) {
[09:32:37.023]                             name <- restart$name
[09:32:37.023]                             if (is.null(name)) 
[09:32:37.023]                               next
[09:32:37.023]                             if (!grepl(pattern, name)) 
[09:32:37.023]                               next
[09:32:37.023]                             invokeRestart(restart)
[09:32:37.023]                             muffled <- TRUE
[09:32:37.023]                             break
[09:32:37.023]                           }
[09:32:37.023]                         }
[09:32:37.023]                       }
[09:32:37.023]                       invisible(muffled)
[09:32:37.023]                     }
[09:32:37.023]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.023]                   }
[09:32:37.023]                 }
[09:32:37.023]             }
[09:32:37.023]         }))
[09:32:37.023]     }, error = function(ex) {
[09:32:37.023]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.023]                 ...future.rng), started = ...future.startTime, 
[09:32:37.023]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.023]             version = "1.8"), class = "FutureResult")
[09:32:37.023]     }, finally = {
[09:32:37.023]         if (!identical(...future.workdir, getwd())) 
[09:32:37.023]             setwd(...future.workdir)
[09:32:37.023]         {
[09:32:37.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.023]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.023]             }
[09:32:37.023]             base::options(...future.oldOptions)
[09:32:37.023]             if (.Platform$OS.type == "windows") {
[09:32:37.023]                 old_names <- names(...future.oldEnvVars)
[09:32:37.023]                 envs <- base::Sys.getenv()
[09:32:37.023]                 names <- names(envs)
[09:32:37.023]                 common <- intersect(names, old_names)
[09:32:37.023]                 added <- setdiff(names, old_names)
[09:32:37.023]                 removed <- setdiff(old_names, names)
[09:32:37.023]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.023]                   envs[common]]
[09:32:37.023]                 NAMES <- toupper(changed)
[09:32:37.023]                 args <- list()
[09:32:37.023]                 for (kk in seq_along(NAMES)) {
[09:32:37.023]                   name <- changed[[kk]]
[09:32:37.023]                   NAME <- NAMES[[kk]]
[09:32:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.023]                     next
[09:32:37.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.023]                 }
[09:32:37.023]                 NAMES <- toupper(added)
[09:32:37.023]                 for (kk in seq_along(NAMES)) {
[09:32:37.023]                   name <- added[[kk]]
[09:32:37.023]                   NAME <- NAMES[[kk]]
[09:32:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.023]                     next
[09:32:37.023]                   args[[name]] <- ""
[09:32:37.023]                 }
[09:32:37.023]                 NAMES <- toupper(removed)
[09:32:37.023]                 for (kk in seq_along(NAMES)) {
[09:32:37.023]                   name <- removed[[kk]]
[09:32:37.023]                   NAME <- NAMES[[kk]]
[09:32:37.023]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.023]                     next
[09:32:37.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.023]                 }
[09:32:37.023]                 if (length(args) > 0) 
[09:32:37.023]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.023]             }
[09:32:37.023]             else {
[09:32:37.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.023]             }
[09:32:37.023]             {
[09:32:37.023]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.023]                   0L) {
[09:32:37.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.023]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.023]                   base::options(opts)
[09:32:37.023]                 }
[09:32:37.023]                 {
[09:32:37.023]                   {
[09:32:37.023]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.023]                     NULL
[09:32:37.023]                   }
[09:32:37.023]                   options(future.plan = NULL)
[09:32:37.023]                   if (is.na(NA_character_)) 
[09:32:37.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.023]                     .init = FALSE)
[09:32:37.023]                 }
[09:32:37.023]             }
[09:32:37.023]         }
[09:32:37.023]     })
[09:32:37.023]     if (TRUE) {
[09:32:37.023]         base::sink(type = "output", split = FALSE)
[09:32:37.023]         if (TRUE) {
[09:32:37.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.023]         }
[09:32:37.023]         else {
[09:32:37.023]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.023]         }
[09:32:37.023]         base::close(...future.stdout)
[09:32:37.023]         ...future.stdout <- NULL
[09:32:37.023]     }
[09:32:37.023]     ...future.result$conditions <- ...future.conditions
[09:32:37.023]     ...future.result$finished <- base::Sys.time()
[09:32:37.023]     ...future.result
[09:32:37.023] }
[09:32:37.025] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:37.057] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[09:32:37.088] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[09:32:37.099] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.100] - Validating connection of MultisessionFuture
[09:32:37.100] - received message: FutureResult
[09:32:37.100] - Received FutureResult
[09:32:37.100] - Erased future from FutureRegistry
[09:32:37.100] result() for ClusterFuture ...
[09:32:37.100] - result already collected: FutureResult
[09:32:37.100] result() for ClusterFuture ... done
[09:32:37.100] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.101] result() for ClusterFuture ...
[09:32:37.101] - result already collected: FutureResult
[09:32:37.101] result() for ClusterFuture ... done
[09:32:37.101] result() for ClusterFuture ...
[09:32:37.101] - result already collected: FutureResult
[09:32:37.101] result() for ClusterFuture ... done
[09:32:37.102] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:32:37.102] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[09:32:37.102] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[09:32:37.102] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:32:37.103] MultisessionFuture started
[09:32:37.103] - Launch lazy future ... done
[09:32:37.103] run() for ‘MultisessionFuture’ ... done
[09:32:37.103] resolve() on list ...
[09:32:37.104]  recursive: 0
[09:32:37.104]  length: 3
[09:32:37.104] 
[09:32:37.104] Future #1
[09:32:37.104]  length: 2 (resolved future 1)
[09:32:37.105] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.106] - Validating connection of MultisessionFuture
[09:32:37.106] - received message: FutureResult
[09:32:37.106] - Received FutureResult
[09:32:37.106] - Erased future from FutureRegistry
[09:32:37.106] result() for ClusterFuture ...
[09:32:37.106] - result already collected: FutureResult
[09:32:37.106] result() for ClusterFuture ... done
[09:32:37.106] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.106] Future #2
[09:32:37.106]  length: 1 (resolved future 2)
[09:32:37.210] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.210] - Validating connection of MultisessionFuture
[09:32:37.210] - received message: FutureResult
[09:32:37.210] - Received FutureResult
[09:32:37.210] - Erased future from FutureRegistry
[09:32:37.210] result() for ClusterFuture ...
[09:32:37.211] - result already collected: FutureResult
[09:32:37.211] result() for ClusterFuture ... done
[09:32:37.211] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.211] Future #3
[09:32:37.211]  length: 0 (resolved future 3)
[09:32:37.211] resolve() on list ... DONE
[09:32:37.211] getGlobalsAndPackages() ...
[09:32:37.211] Searching for globals...
[09:32:37.212] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:37.212] Searching for globals ... DONE
[09:32:37.212] Resolving globals: FALSE
[09:32:37.213] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:37.213] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:37.213] - globals: [1] ‘kk’
[09:32:37.213] 
[09:32:37.213] getGlobalsAndPackages() ... DONE
[09:32:37.214] getGlobalsAndPackages() ...
[09:32:37.214] Searching for globals...
[09:32:37.215] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:37.215] Searching for globals ... DONE
[09:32:37.215] Resolving globals: FALSE
[09:32:37.215] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:37.216] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:37.216] - globals: [1] ‘kk’
[09:32:37.216] 
[09:32:37.216] getGlobalsAndPackages() ... DONE
[09:32:37.216] getGlobalsAndPackages() ...
[09:32:37.216] Searching for globals...
[09:32:37.217] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[09:32:37.217] Searching for globals ... DONE
[09:32:37.217] Resolving globals: FALSE
[09:32:37.218] The total size of the 1 globals is 56 bytes (56 bytes)
[09:32:37.218] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 56 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (56 bytes of class ‘numeric’)
[09:32:37.218] - globals: [1] ‘kk’
[09:32:37.218] 
[09:32:37.218] getGlobalsAndPackages() ... DONE
[09:32:37.219] resolve() on list ...
[09:32:37.219]  recursive: 0
[09:32:37.219]  length: 3
[09:32:37.219] 
[09:32:37.219] run() for ‘Future’ ...
[09:32:37.219] - state: ‘created’
[09:32:37.219] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.233]   - Field: ‘node’
[09:32:37.233]   - Field: ‘label’
[09:32:37.233]   - Field: ‘local’
[09:32:37.233]   - Field: ‘owner’
[09:32:37.234]   - Field: ‘envir’
[09:32:37.234]   - Field: ‘workers’
[09:32:37.234]   - Field: ‘packages’
[09:32:37.234]   - Field: ‘gc’
[09:32:37.234]   - Field: ‘conditions’
[09:32:37.234]   - Field: ‘persistent’
[09:32:37.234]   - Field: ‘expr’
[09:32:37.234]   - Field: ‘uuid’
[09:32:37.234]   - Field: ‘seed’
[09:32:37.234]   - Field: ‘version’
[09:32:37.234]   - Field: ‘result’
[09:32:37.235]   - Field: ‘asynchronous’
[09:32:37.235]   - Field: ‘calls’
[09:32:37.235]   - Field: ‘globals’
[09:32:37.235]   - Field: ‘stdout’
[09:32:37.235]   - Field: ‘earlySignal’
[09:32:37.235]   - Field: ‘lazy’
[09:32:37.235]   - Field: ‘state’
[09:32:37.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.235] - Launch lazy future ...
[09:32:37.238] Packages needed by the future expression (n = 0): <none>
[09:32:37.238] Packages needed by future strategies (n = 0): <none>
[09:32:37.239] {
[09:32:37.239]     {
[09:32:37.239]         {
[09:32:37.239]             ...future.startTime <- base::Sys.time()
[09:32:37.239]             {
[09:32:37.239]                 {
[09:32:37.239]                   {
[09:32:37.239]                     {
[09:32:37.239]                       base::local({
[09:32:37.239]                         has_future <- base::requireNamespace("future", 
[09:32:37.239]                           quietly = TRUE)
[09:32:37.239]                         if (has_future) {
[09:32:37.239]                           ns <- base::getNamespace("future")
[09:32:37.239]                           version <- ns[[".package"]][["version"]]
[09:32:37.239]                           if (is.null(version)) 
[09:32:37.239]                             version <- utils::packageVersion("future")
[09:32:37.239]                         }
[09:32:37.239]                         else {
[09:32:37.239]                           version <- NULL
[09:32:37.239]                         }
[09:32:37.239]                         if (!has_future || version < "1.8.0") {
[09:32:37.239]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.239]                             "", base::R.version$version.string), 
[09:32:37.239]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.239]                               "release", "version")], collapse = " "), 
[09:32:37.239]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.239]                             info)
[09:32:37.239]                           info <- base::paste(info, collapse = "; ")
[09:32:37.239]                           if (!has_future) {
[09:32:37.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.239]                               info)
[09:32:37.239]                           }
[09:32:37.239]                           else {
[09:32:37.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.239]                               info, version)
[09:32:37.239]                           }
[09:32:37.239]                           base::stop(msg)
[09:32:37.239]                         }
[09:32:37.239]                       })
[09:32:37.239]                     }
[09:32:37.239]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.239]                     base::options(mc.cores = 1L)
[09:32:37.239]                   }
[09:32:37.239]                   ...future.strategy.old <- future::plan("list")
[09:32:37.239]                   options(future.plan = NULL)
[09:32:37.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.239]                 }
[09:32:37.239]                 ...future.workdir <- getwd()
[09:32:37.239]             }
[09:32:37.239]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.239]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.239]         }
[09:32:37.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.239]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.239]             base::names(...future.oldOptions))
[09:32:37.239]     }
[09:32:37.239]     if (FALSE) {
[09:32:37.239]     }
[09:32:37.239]     else {
[09:32:37.239]         if (TRUE) {
[09:32:37.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.239]                 open = "w")
[09:32:37.239]         }
[09:32:37.239]         else {
[09:32:37.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.239]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.239]         }
[09:32:37.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.239]             base::sink(type = "output", split = FALSE)
[09:32:37.239]             base::close(...future.stdout)
[09:32:37.239]         }, add = TRUE)
[09:32:37.239]     }
[09:32:37.239]     ...future.frame <- base::sys.nframe()
[09:32:37.239]     ...future.conditions <- base::list()
[09:32:37.239]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.239]     if (FALSE) {
[09:32:37.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.239]     }
[09:32:37.239]     ...future.result <- base::tryCatch({
[09:32:37.239]         base::withCallingHandlers({
[09:32:37.239]             ...future.value <- base::withVisible(base::local({
[09:32:37.239]                 ...future.makeSendCondition <- base::local({
[09:32:37.239]                   sendCondition <- NULL
[09:32:37.239]                   function(frame = 1L) {
[09:32:37.239]                     if (is.function(sendCondition)) 
[09:32:37.239]                       return(sendCondition)
[09:32:37.239]                     ns <- getNamespace("parallel")
[09:32:37.239]                     if (exists("sendData", mode = "function", 
[09:32:37.239]                       envir = ns)) {
[09:32:37.239]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.239]                         envir = ns)
[09:32:37.239]                       envir <- sys.frame(frame)
[09:32:37.239]                       master <- NULL
[09:32:37.239]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.239]                         !identical(envir, emptyenv())) {
[09:32:37.239]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.239]                           inherits = FALSE)) {
[09:32:37.239]                           master <- get("master", mode = "list", 
[09:32:37.239]                             envir = envir, inherits = FALSE)
[09:32:37.239]                           if (inherits(master, c("SOCKnode", 
[09:32:37.239]                             "SOCK0node"))) {
[09:32:37.239]                             sendCondition <<- function(cond) {
[09:32:37.239]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.239]                                 success = TRUE)
[09:32:37.239]                               parallel_sendData(master, data)
[09:32:37.239]                             }
[09:32:37.239]                             return(sendCondition)
[09:32:37.239]                           }
[09:32:37.239]                         }
[09:32:37.239]                         frame <- frame + 1L
[09:32:37.239]                         envir <- sys.frame(frame)
[09:32:37.239]                       }
[09:32:37.239]                     }
[09:32:37.239]                     sendCondition <<- function(cond) NULL
[09:32:37.239]                   }
[09:32:37.239]                 })
[09:32:37.239]                 withCallingHandlers({
[09:32:37.239]                   {
[09:32:37.239]                     Sys.sleep(0.1)
[09:32:37.239]                     kk
[09:32:37.239]                   }
[09:32:37.239]                 }, immediateCondition = function(cond) {
[09:32:37.239]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.239]                   sendCondition(cond)
[09:32:37.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.239]                   {
[09:32:37.239]                     inherits <- base::inherits
[09:32:37.239]                     invokeRestart <- base::invokeRestart
[09:32:37.239]                     is.null <- base::is.null
[09:32:37.239]                     muffled <- FALSE
[09:32:37.239]                     if (inherits(cond, "message")) {
[09:32:37.239]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.239]                       if (muffled) 
[09:32:37.239]                         invokeRestart("muffleMessage")
[09:32:37.239]                     }
[09:32:37.239]                     else if (inherits(cond, "warning")) {
[09:32:37.239]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.239]                       if (muffled) 
[09:32:37.239]                         invokeRestart("muffleWarning")
[09:32:37.239]                     }
[09:32:37.239]                     else if (inherits(cond, "condition")) {
[09:32:37.239]                       if (!is.null(pattern)) {
[09:32:37.239]                         computeRestarts <- base::computeRestarts
[09:32:37.239]                         grepl <- base::grepl
[09:32:37.239]                         restarts <- computeRestarts(cond)
[09:32:37.239]                         for (restart in restarts) {
[09:32:37.239]                           name <- restart$name
[09:32:37.239]                           if (is.null(name)) 
[09:32:37.239]                             next
[09:32:37.239]                           if (!grepl(pattern, name)) 
[09:32:37.239]                             next
[09:32:37.239]                           invokeRestart(restart)
[09:32:37.239]                           muffled <- TRUE
[09:32:37.239]                           break
[09:32:37.239]                         }
[09:32:37.239]                       }
[09:32:37.239]                     }
[09:32:37.239]                     invisible(muffled)
[09:32:37.239]                   }
[09:32:37.239]                   muffleCondition(cond)
[09:32:37.239]                 })
[09:32:37.239]             }))
[09:32:37.239]             future::FutureResult(value = ...future.value$value, 
[09:32:37.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.239]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.239]                     ...future.globalenv.names))
[09:32:37.239]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.239]         }, condition = base::local({
[09:32:37.239]             c <- base::c
[09:32:37.239]             inherits <- base::inherits
[09:32:37.239]             invokeRestart <- base::invokeRestart
[09:32:37.239]             length <- base::length
[09:32:37.239]             list <- base::list
[09:32:37.239]             seq.int <- base::seq.int
[09:32:37.239]             signalCondition <- base::signalCondition
[09:32:37.239]             sys.calls <- base::sys.calls
[09:32:37.239]             `[[` <- base::`[[`
[09:32:37.239]             `+` <- base::`+`
[09:32:37.239]             `<<-` <- base::`<<-`
[09:32:37.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.239]                   3L)]
[09:32:37.239]             }
[09:32:37.239]             function(cond) {
[09:32:37.239]                 is_error <- inherits(cond, "error")
[09:32:37.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.239]                   NULL)
[09:32:37.239]                 if (is_error) {
[09:32:37.239]                   sessionInformation <- function() {
[09:32:37.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.239]                       search = base::search(), system = base::Sys.info())
[09:32:37.239]                   }
[09:32:37.239]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.239]                     cond$call), session = sessionInformation(), 
[09:32:37.239]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.239]                   signalCondition(cond)
[09:32:37.239]                 }
[09:32:37.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.239]                 "immediateCondition"))) {
[09:32:37.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.239]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.239]                   if (TRUE && !signal) {
[09:32:37.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.239]                     {
[09:32:37.239]                       inherits <- base::inherits
[09:32:37.239]                       invokeRestart <- base::invokeRestart
[09:32:37.239]                       is.null <- base::is.null
[09:32:37.239]                       muffled <- FALSE
[09:32:37.239]                       if (inherits(cond, "message")) {
[09:32:37.239]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.239]                         if (muffled) 
[09:32:37.239]                           invokeRestart("muffleMessage")
[09:32:37.239]                       }
[09:32:37.239]                       else if (inherits(cond, "warning")) {
[09:32:37.239]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.239]                         if (muffled) 
[09:32:37.239]                           invokeRestart("muffleWarning")
[09:32:37.239]                       }
[09:32:37.239]                       else if (inherits(cond, "condition")) {
[09:32:37.239]                         if (!is.null(pattern)) {
[09:32:37.239]                           computeRestarts <- base::computeRestarts
[09:32:37.239]                           grepl <- base::grepl
[09:32:37.239]                           restarts <- computeRestarts(cond)
[09:32:37.239]                           for (restart in restarts) {
[09:32:37.239]                             name <- restart$name
[09:32:37.239]                             if (is.null(name)) 
[09:32:37.239]                               next
[09:32:37.239]                             if (!grepl(pattern, name)) 
[09:32:37.239]                               next
[09:32:37.239]                             invokeRestart(restart)
[09:32:37.239]                             muffled <- TRUE
[09:32:37.239]                             break
[09:32:37.239]                           }
[09:32:37.239]                         }
[09:32:37.239]                       }
[09:32:37.239]                       invisible(muffled)
[09:32:37.239]                     }
[09:32:37.239]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.239]                   }
[09:32:37.239]                 }
[09:32:37.239]                 else {
[09:32:37.239]                   if (TRUE) {
[09:32:37.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.239]                     {
[09:32:37.239]                       inherits <- base::inherits
[09:32:37.239]                       invokeRestart <- base::invokeRestart
[09:32:37.239]                       is.null <- base::is.null
[09:32:37.239]                       muffled <- FALSE
[09:32:37.239]                       if (inherits(cond, "message")) {
[09:32:37.239]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.239]                         if (muffled) 
[09:32:37.239]                           invokeRestart("muffleMessage")
[09:32:37.239]                       }
[09:32:37.239]                       else if (inherits(cond, "warning")) {
[09:32:37.239]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.239]                         if (muffled) 
[09:32:37.239]                           invokeRestart("muffleWarning")
[09:32:37.239]                       }
[09:32:37.239]                       else if (inherits(cond, "condition")) {
[09:32:37.239]                         if (!is.null(pattern)) {
[09:32:37.239]                           computeRestarts <- base::computeRestarts
[09:32:37.239]                           grepl <- base::grepl
[09:32:37.239]                           restarts <- computeRestarts(cond)
[09:32:37.239]                           for (restart in restarts) {
[09:32:37.239]                             name <- restart$name
[09:32:37.239]                             if (is.null(name)) 
[09:32:37.239]                               next
[09:32:37.239]                             if (!grepl(pattern, name)) 
[09:32:37.239]                               next
[09:32:37.239]                             invokeRestart(restart)
[09:32:37.239]                             muffled <- TRUE
[09:32:37.239]                             break
[09:32:37.239]                           }
[09:32:37.239]                         }
[09:32:37.239]                       }
[09:32:37.239]                       invisible(muffled)
[09:32:37.239]                     }
[09:32:37.239]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.239]                   }
[09:32:37.239]                 }
[09:32:37.239]             }
[09:32:37.239]         }))
[09:32:37.239]     }, error = function(ex) {
[09:32:37.239]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.239]                 ...future.rng), started = ...future.startTime, 
[09:32:37.239]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.239]             version = "1.8"), class = "FutureResult")
[09:32:37.239]     }, finally = {
[09:32:37.239]         if (!identical(...future.workdir, getwd())) 
[09:32:37.239]             setwd(...future.workdir)
[09:32:37.239]         {
[09:32:37.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.239]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.239]             }
[09:32:37.239]             base::options(...future.oldOptions)
[09:32:37.239]             if (.Platform$OS.type == "windows") {
[09:32:37.239]                 old_names <- names(...future.oldEnvVars)
[09:32:37.239]                 envs <- base::Sys.getenv()
[09:32:37.239]                 names <- names(envs)
[09:32:37.239]                 common <- intersect(names, old_names)
[09:32:37.239]                 added <- setdiff(names, old_names)
[09:32:37.239]                 removed <- setdiff(old_names, names)
[09:32:37.239]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.239]                   envs[common]]
[09:32:37.239]                 NAMES <- toupper(changed)
[09:32:37.239]                 args <- list()
[09:32:37.239]                 for (kk in seq_along(NAMES)) {
[09:32:37.239]                   name <- changed[[kk]]
[09:32:37.239]                   NAME <- NAMES[[kk]]
[09:32:37.239]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.239]                     next
[09:32:37.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.239]                 }
[09:32:37.239]                 NAMES <- toupper(added)
[09:32:37.239]                 for (kk in seq_along(NAMES)) {
[09:32:37.239]                   name <- added[[kk]]
[09:32:37.239]                   NAME <- NAMES[[kk]]
[09:32:37.239]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.239]                     next
[09:32:37.239]                   args[[name]] <- ""
[09:32:37.239]                 }
[09:32:37.239]                 NAMES <- toupper(removed)
[09:32:37.239]                 for (kk in seq_along(NAMES)) {
[09:32:37.239]                   name <- removed[[kk]]
[09:32:37.239]                   NAME <- NAMES[[kk]]
[09:32:37.239]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.239]                     next
[09:32:37.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.239]                 }
[09:32:37.239]                 if (length(args) > 0) 
[09:32:37.239]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.239]             }
[09:32:37.239]             else {
[09:32:37.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.239]             }
[09:32:37.239]             {
[09:32:37.239]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.239]                   0L) {
[09:32:37.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.239]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.239]                   base::options(opts)
[09:32:37.239]                 }
[09:32:37.239]                 {
[09:32:37.239]                   {
[09:32:37.239]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.239]                     NULL
[09:32:37.239]                   }
[09:32:37.239]                   options(future.plan = NULL)
[09:32:37.239]                   if (is.na(NA_character_)) 
[09:32:37.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.239]                     .init = FALSE)
[09:32:37.239]                 }
[09:32:37.239]             }
[09:32:37.239]         }
[09:32:37.239]     })
[09:32:37.239]     if (TRUE) {
[09:32:37.239]         base::sink(type = "output", split = FALSE)
[09:32:37.239]         if (TRUE) {
[09:32:37.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.239]         }
[09:32:37.239]         else {
[09:32:37.239]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.239]         }
[09:32:37.239]         base::close(...future.stdout)
[09:32:37.239]         ...future.stdout <- NULL
[09:32:37.239]     }
[09:32:37.239]     ...future.result$conditions <- ...future.conditions
[09:32:37.239]     ...future.result$finished <- base::Sys.time()
[09:32:37.239]     ...future.result
[09:32:37.239] }
[09:32:37.242] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:32:37.242] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[09:32:37.242] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[09:32:37.242] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:32:37.243] MultisessionFuture started
[09:32:37.243] - Launch lazy future ... done
[09:32:37.243] run() for ‘MultisessionFuture’ ... done
[09:32:37.254] run() for ‘Future’ ...
[09:32:37.254] - state: ‘created’
[09:32:37.254] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.269] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.269]   - Field: ‘node’
[09:32:37.269]   - Field: ‘label’
[09:32:37.269]   - Field: ‘local’
[09:32:37.269]   - Field: ‘owner’
[09:32:37.269]   - Field: ‘envir’
[09:32:37.269]   - Field: ‘workers’
[09:32:37.270]   - Field: ‘packages’
[09:32:37.270]   - Field: ‘gc’
[09:32:37.270]   - Field: ‘conditions’
[09:32:37.270]   - Field: ‘persistent’
[09:32:37.270]   - Field: ‘expr’
[09:32:37.270]   - Field: ‘uuid’
[09:32:37.270]   - Field: ‘seed’
[09:32:37.270]   - Field: ‘version’
[09:32:37.270]   - Field: ‘result’
[09:32:37.270]   - Field: ‘asynchronous’
[09:32:37.270]   - Field: ‘calls’
[09:32:37.270]   - Field: ‘globals’
[09:32:37.271]   - Field: ‘stdout’
[09:32:37.271]   - Field: ‘earlySignal’
[09:32:37.271]   - Field: ‘lazy’
[09:32:37.271]   - Field: ‘state’
[09:32:37.271] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.271] - Launch lazy future ...
[09:32:37.271] Packages needed by the future expression (n = 0): <none>
[09:32:37.271] Packages needed by future strategies (n = 0): <none>
[09:32:37.272] {
[09:32:37.272]     {
[09:32:37.272]         {
[09:32:37.272]             ...future.startTime <- base::Sys.time()
[09:32:37.272]             {
[09:32:37.272]                 {
[09:32:37.272]                   {
[09:32:37.272]                     {
[09:32:37.272]                       base::local({
[09:32:37.272]                         has_future <- base::requireNamespace("future", 
[09:32:37.272]                           quietly = TRUE)
[09:32:37.272]                         if (has_future) {
[09:32:37.272]                           ns <- base::getNamespace("future")
[09:32:37.272]                           version <- ns[[".package"]][["version"]]
[09:32:37.272]                           if (is.null(version)) 
[09:32:37.272]                             version <- utils::packageVersion("future")
[09:32:37.272]                         }
[09:32:37.272]                         else {
[09:32:37.272]                           version <- NULL
[09:32:37.272]                         }
[09:32:37.272]                         if (!has_future || version < "1.8.0") {
[09:32:37.272]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.272]                             "", base::R.version$version.string), 
[09:32:37.272]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.272]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.272]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.272]                               "release", "version")], collapse = " "), 
[09:32:37.272]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.272]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.272]                             info)
[09:32:37.272]                           info <- base::paste(info, collapse = "; ")
[09:32:37.272]                           if (!has_future) {
[09:32:37.272]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.272]                               info)
[09:32:37.272]                           }
[09:32:37.272]                           else {
[09:32:37.272]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.272]                               info, version)
[09:32:37.272]                           }
[09:32:37.272]                           base::stop(msg)
[09:32:37.272]                         }
[09:32:37.272]                       })
[09:32:37.272]                     }
[09:32:37.272]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.272]                     base::options(mc.cores = 1L)
[09:32:37.272]                   }
[09:32:37.272]                   ...future.strategy.old <- future::plan("list")
[09:32:37.272]                   options(future.plan = NULL)
[09:32:37.272]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.272]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.272]                 }
[09:32:37.272]                 ...future.workdir <- getwd()
[09:32:37.272]             }
[09:32:37.272]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.272]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.272]         }
[09:32:37.272]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.272]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.272]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.272]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.272]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.272]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.272]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.272]             base::names(...future.oldOptions))
[09:32:37.272]     }
[09:32:37.272]     if (FALSE) {
[09:32:37.272]     }
[09:32:37.272]     else {
[09:32:37.272]         if (TRUE) {
[09:32:37.272]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.272]                 open = "w")
[09:32:37.272]         }
[09:32:37.272]         else {
[09:32:37.272]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.272]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.272]         }
[09:32:37.272]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.272]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.272]             base::sink(type = "output", split = FALSE)
[09:32:37.272]             base::close(...future.stdout)
[09:32:37.272]         }, add = TRUE)
[09:32:37.272]     }
[09:32:37.272]     ...future.frame <- base::sys.nframe()
[09:32:37.272]     ...future.conditions <- base::list()
[09:32:37.272]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.272]     if (FALSE) {
[09:32:37.272]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.272]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.272]     }
[09:32:37.272]     ...future.result <- base::tryCatch({
[09:32:37.272]         base::withCallingHandlers({
[09:32:37.272]             ...future.value <- base::withVisible(base::local({
[09:32:37.272]                 ...future.makeSendCondition <- base::local({
[09:32:37.272]                   sendCondition <- NULL
[09:32:37.272]                   function(frame = 1L) {
[09:32:37.272]                     if (is.function(sendCondition)) 
[09:32:37.272]                       return(sendCondition)
[09:32:37.272]                     ns <- getNamespace("parallel")
[09:32:37.272]                     if (exists("sendData", mode = "function", 
[09:32:37.272]                       envir = ns)) {
[09:32:37.272]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.272]                         envir = ns)
[09:32:37.272]                       envir <- sys.frame(frame)
[09:32:37.272]                       master <- NULL
[09:32:37.272]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.272]                         !identical(envir, emptyenv())) {
[09:32:37.272]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.272]                           inherits = FALSE)) {
[09:32:37.272]                           master <- get("master", mode = "list", 
[09:32:37.272]                             envir = envir, inherits = FALSE)
[09:32:37.272]                           if (inherits(master, c("SOCKnode", 
[09:32:37.272]                             "SOCK0node"))) {
[09:32:37.272]                             sendCondition <<- function(cond) {
[09:32:37.272]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.272]                                 success = TRUE)
[09:32:37.272]                               parallel_sendData(master, data)
[09:32:37.272]                             }
[09:32:37.272]                             return(sendCondition)
[09:32:37.272]                           }
[09:32:37.272]                         }
[09:32:37.272]                         frame <- frame + 1L
[09:32:37.272]                         envir <- sys.frame(frame)
[09:32:37.272]                       }
[09:32:37.272]                     }
[09:32:37.272]                     sendCondition <<- function(cond) NULL
[09:32:37.272]                   }
[09:32:37.272]                 })
[09:32:37.272]                 withCallingHandlers({
[09:32:37.272]                   {
[09:32:37.272]                     Sys.sleep(0.1)
[09:32:37.272]                     kk
[09:32:37.272]                   }
[09:32:37.272]                 }, immediateCondition = function(cond) {
[09:32:37.272]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.272]                   sendCondition(cond)
[09:32:37.272]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.272]                   {
[09:32:37.272]                     inherits <- base::inherits
[09:32:37.272]                     invokeRestart <- base::invokeRestart
[09:32:37.272]                     is.null <- base::is.null
[09:32:37.272]                     muffled <- FALSE
[09:32:37.272]                     if (inherits(cond, "message")) {
[09:32:37.272]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.272]                       if (muffled) 
[09:32:37.272]                         invokeRestart("muffleMessage")
[09:32:37.272]                     }
[09:32:37.272]                     else if (inherits(cond, "warning")) {
[09:32:37.272]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.272]                       if (muffled) 
[09:32:37.272]                         invokeRestart("muffleWarning")
[09:32:37.272]                     }
[09:32:37.272]                     else if (inherits(cond, "condition")) {
[09:32:37.272]                       if (!is.null(pattern)) {
[09:32:37.272]                         computeRestarts <- base::computeRestarts
[09:32:37.272]                         grepl <- base::grepl
[09:32:37.272]                         restarts <- computeRestarts(cond)
[09:32:37.272]                         for (restart in restarts) {
[09:32:37.272]                           name <- restart$name
[09:32:37.272]                           if (is.null(name)) 
[09:32:37.272]                             next
[09:32:37.272]                           if (!grepl(pattern, name)) 
[09:32:37.272]                             next
[09:32:37.272]                           invokeRestart(restart)
[09:32:37.272]                           muffled <- TRUE
[09:32:37.272]                           break
[09:32:37.272]                         }
[09:32:37.272]                       }
[09:32:37.272]                     }
[09:32:37.272]                     invisible(muffled)
[09:32:37.272]                   }
[09:32:37.272]                   muffleCondition(cond)
[09:32:37.272]                 })
[09:32:37.272]             }))
[09:32:37.272]             future::FutureResult(value = ...future.value$value, 
[09:32:37.272]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.272]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.272]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.272]                     ...future.globalenv.names))
[09:32:37.272]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.272]         }, condition = base::local({
[09:32:37.272]             c <- base::c
[09:32:37.272]             inherits <- base::inherits
[09:32:37.272]             invokeRestart <- base::invokeRestart
[09:32:37.272]             length <- base::length
[09:32:37.272]             list <- base::list
[09:32:37.272]             seq.int <- base::seq.int
[09:32:37.272]             signalCondition <- base::signalCondition
[09:32:37.272]             sys.calls <- base::sys.calls
[09:32:37.272]             `[[` <- base::`[[`
[09:32:37.272]             `+` <- base::`+`
[09:32:37.272]             `<<-` <- base::`<<-`
[09:32:37.272]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.272]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.272]                   3L)]
[09:32:37.272]             }
[09:32:37.272]             function(cond) {
[09:32:37.272]                 is_error <- inherits(cond, "error")
[09:32:37.272]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.272]                   NULL)
[09:32:37.272]                 if (is_error) {
[09:32:37.272]                   sessionInformation <- function() {
[09:32:37.272]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.272]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.272]                       search = base::search(), system = base::Sys.info())
[09:32:37.272]                   }
[09:32:37.272]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.272]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.272]                     cond$call), session = sessionInformation(), 
[09:32:37.272]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.272]                   signalCondition(cond)
[09:32:37.272]                 }
[09:32:37.272]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.272]                 "immediateCondition"))) {
[09:32:37.272]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.272]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.272]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.272]                   if (TRUE && !signal) {
[09:32:37.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.272]                     {
[09:32:37.272]                       inherits <- base::inherits
[09:32:37.272]                       invokeRestart <- base::invokeRestart
[09:32:37.272]                       is.null <- base::is.null
[09:32:37.272]                       muffled <- FALSE
[09:32:37.272]                       if (inherits(cond, "message")) {
[09:32:37.272]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.272]                         if (muffled) 
[09:32:37.272]                           invokeRestart("muffleMessage")
[09:32:37.272]                       }
[09:32:37.272]                       else if (inherits(cond, "warning")) {
[09:32:37.272]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.272]                         if (muffled) 
[09:32:37.272]                           invokeRestart("muffleWarning")
[09:32:37.272]                       }
[09:32:37.272]                       else if (inherits(cond, "condition")) {
[09:32:37.272]                         if (!is.null(pattern)) {
[09:32:37.272]                           computeRestarts <- base::computeRestarts
[09:32:37.272]                           grepl <- base::grepl
[09:32:37.272]                           restarts <- computeRestarts(cond)
[09:32:37.272]                           for (restart in restarts) {
[09:32:37.272]                             name <- restart$name
[09:32:37.272]                             if (is.null(name)) 
[09:32:37.272]                               next
[09:32:37.272]                             if (!grepl(pattern, name)) 
[09:32:37.272]                               next
[09:32:37.272]                             invokeRestart(restart)
[09:32:37.272]                             muffled <- TRUE
[09:32:37.272]                             break
[09:32:37.272]                           }
[09:32:37.272]                         }
[09:32:37.272]                       }
[09:32:37.272]                       invisible(muffled)
[09:32:37.272]                     }
[09:32:37.272]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.272]                   }
[09:32:37.272]                 }
[09:32:37.272]                 else {
[09:32:37.272]                   if (TRUE) {
[09:32:37.272]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.272]                     {
[09:32:37.272]                       inherits <- base::inherits
[09:32:37.272]                       invokeRestart <- base::invokeRestart
[09:32:37.272]                       is.null <- base::is.null
[09:32:37.272]                       muffled <- FALSE
[09:32:37.272]                       if (inherits(cond, "message")) {
[09:32:37.272]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.272]                         if (muffled) 
[09:32:37.272]                           invokeRestart("muffleMessage")
[09:32:37.272]                       }
[09:32:37.272]                       else if (inherits(cond, "warning")) {
[09:32:37.272]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.272]                         if (muffled) 
[09:32:37.272]                           invokeRestart("muffleWarning")
[09:32:37.272]                       }
[09:32:37.272]                       else if (inherits(cond, "condition")) {
[09:32:37.272]                         if (!is.null(pattern)) {
[09:32:37.272]                           computeRestarts <- base::computeRestarts
[09:32:37.272]                           grepl <- base::grepl
[09:32:37.272]                           restarts <- computeRestarts(cond)
[09:32:37.272]                           for (restart in restarts) {
[09:32:37.272]                             name <- restart$name
[09:32:37.272]                             if (is.null(name)) 
[09:32:37.272]                               next
[09:32:37.272]                             if (!grepl(pattern, name)) 
[09:32:37.272]                               next
[09:32:37.272]                             invokeRestart(restart)
[09:32:37.272]                             muffled <- TRUE
[09:32:37.272]                             break
[09:32:37.272]                           }
[09:32:37.272]                         }
[09:32:37.272]                       }
[09:32:37.272]                       invisible(muffled)
[09:32:37.272]                     }
[09:32:37.272]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.272]                   }
[09:32:37.272]                 }
[09:32:37.272]             }
[09:32:37.272]         }))
[09:32:37.272]     }, error = function(ex) {
[09:32:37.272]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.272]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.272]                 ...future.rng), started = ...future.startTime, 
[09:32:37.272]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.272]             version = "1.8"), class = "FutureResult")
[09:32:37.272]     }, finally = {
[09:32:37.272]         if (!identical(...future.workdir, getwd())) 
[09:32:37.272]             setwd(...future.workdir)
[09:32:37.272]         {
[09:32:37.272]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.272]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.272]             }
[09:32:37.272]             base::options(...future.oldOptions)
[09:32:37.272]             if (.Platform$OS.type == "windows") {
[09:32:37.272]                 old_names <- names(...future.oldEnvVars)
[09:32:37.272]                 envs <- base::Sys.getenv()
[09:32:37.272]                 names <- names(envs)
[09:32:37.272]                 common <- intersect(names, old_names)
[09:32:37.272]                 added <- setdiff(names, old_names)
[09:32:37.272]                 removed <- setdiff(old_names, names)
[09:32:37.272]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.272]                   envs[common]]
[09:32:37.272]                 NAMES <- toupper(changed)
[09:32:37.272]                 args <- list()
[09:32:37.272]                 for (kk in seq_along(NAMES)) {
[09:32:37.272]                   name <- changed[[kk]]
[09:32:37.272]                   NAME <- NAMES[[kk]]
[09:32:37.272]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.272]                     next
[09:32:37.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.272]                 }
[09:32:37.272]                 NAMES <- toupper(added)
[09:32:37.272]                 for (kk in seq_along(NAMES)) {
[09:32:37.272]                   name <- added[[kk]]
[09:32:37.272]                   NAME <- NAMES[[kk]]
[09:32:37.272]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.272]                     next
[09:32:37.272]                   args[[name]] <- ""
[09:32:37.272]                 }
[09:32:37.272]                 NAMES <- toupper(removed)
[09:32:37.272]                 for (kk in seq_along(NAMES)) {
[09:32:37.272]                   name <- removed[[kk]]
[09:32:37.272]                   NAME <- NAMES[[kk]]
[09:32:37.272]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.272]                     next
[09:32:37.272]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.272]                 }
[09:32:37.272]                 if (length(args) > 0) 
[09:32:37.272]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.272]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.272]             }
[09:32:37.272]             else {
[09:32:37.272]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.272]             }
[09:32:37.272]             {
[09:32:37.272]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.272]                   0L) {
[09:32:37.272]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.272]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.272]                   base::options(opts)
[09:32:37.272]                 }
[09:32:37.272]                 {
[09:32:37.272]                   {
[09:32:37.272]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.272]                     NULL
[09:32:37.272]                   }
[09:32:37.272]                   options(future.plan = NULL)
[09:32:37.272]                   if (is.na(NA_character_)) 
[09:32:37.272]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.272]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.272]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.272]                     .init = FALSE)
[09:32:37.272]                 }
[09:32:37.272]             }
[09:32:37.272]         }
[09:32:37.272]     })
[09:32:37.272]     if (TRUE) {
[09:32:37.272]         base::sink(type = "output", split = FALSE)
[09:32:37.272]         if (TRUE) {
[09:32:37.272]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.272]         }
[09:32:37.272]         else {
[09:32:37.272]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.272]         }
[09:32:37.272]         base::close(...future.stdout)
[09:32:37.272]         ...future.stdout <- NULL
[09:32:37.272]     }
[09:32:37.272]     ...future.result$conditions <- ...future.conditions
[09:32:37.272]     ...future.result$finished <- base::Sys.time()
[09:32:37.272]     ...future.result
[09:32:37.272] }
[09:32:37.274] Exporting 1 global objects (56 bytes) to cluster node #2 ...
[09:32:37.274] Exporting ‘kk’ (56 bytes) to cluster node #2 ...
[09:32:37.275] Exporting ‘kk’ (56 bytes) to cluster node #2 ... DONE
[09:32:37.275] Exporting 1 global objects (56 bytes) to cluster node #2 ... DONE
[09:32:37.275] MultisessionFuture started
[09:32:37.275] - Launch lazy future ... done
[09:32:37.276] run() for ‘MultisessionFuture’ ... done
[09:32:37.286] run() for ‘Future’ ...
[09:32:37.286] - state: ‘created’
[09:32:37.286] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.300] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.300]   - Field: ‘node’
[09:32:37.300]   - Field: ‘label’
[09:32:37.300]   - Field: ‘local’
[09:32:37.300]   - Field: ‘owner’
[09:32:37.300]   - Field: ‘envir’
[09:32:37.300]   - Field: ‘workers’
[09:32:37.301]   - Field: ‘packages’
[09:32:37.301]   - Field: ‘gc’
[09:32:37.301]   - Field: ‘conditions’
[09:32:37.301]   - Field: ‘persistent’
[09:32:37.301]   - Field: ‘expr’
[09:32:37.301]   - Field: ‘uuid’
[09:32:37.301]   - Field: ‘seed’
[09:32:37.301]   - Field: ‘version’
[09:32:37.301]   - Field: ‘result’
[09:32:37.301]   - Field: ‘asynchronous’
[09:32:37.301]   - Field: ‘calls’
[09:32:37.301]   - Field: ‘globals’
[09:32:37.302]   - Field: ‘stdout’
[09:32:37.302]   - Field: ‘earlySignal’
[09:32:37.302]   - Field: ‘lazy’
[09:32:37.302]   - Field: ‘state’
[09:32:37.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.302] - Launch lazy future ...
[09:32:37.302] Packages needed by the future expression (n = 0): <none>
[09:32:37.302] Packages needed by future strategies (n = 0): <none>
[09:32:37.303] {
[09:32:37.303]     {
[09:32:37.303]         {
[09:32:37.303]             ...future.startTime <- base::Sys.time()
[09:32:37.303]             {
[09:32:37.303]                 {
[09:32:37.303]                   {
[09:32:37.303]                     {
[09:32:37.303]                       base::local({
[09:32:37.303]                         has_future <- base::requireNamespace("future", 
[09:32:37.303]                           quietly = TRUE)
[09:32:37.303]                         if (has_future) {
[09:32:37.303]                           ns <- base::getNamespace("future")
[09:32:37.303]                           version <- ns[[".package"]][["version"]]
[09:32:37.303]                           if (is.null(version)) 
[09:32:37.303]                             version <- utils::packageVersion("future")
[09:32:37.303]                         }
[09:32:37.303]                         else {
[09:32:37.303]                           version <- NULL
[09:32:37.303]                         }
[09:32:37.303]                         if (!has_future || version < "1.8.0") {
[09:32:37.303]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.303]                             "", base::R.version$version.string), 
[09:32:37.303]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.303]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.303]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.303]                               "release", "version")], collapse = " "), 
[09:32:37.303]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.303]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.303]                             info)
[09:32:37.303]                           info <- base::paste(info, collapse = "; ")
[09:32:37.303]                           if (!has_future) {
[09:32:37.303]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.303]                               info)
[09:32:37.303]                           }
[09:32:37.303]                           else {
[09:32:37.303]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.303]                               info, version)
[09:32:37.303]                           }
[09:32:37.303]                           base::stop(msg)
[09:32:37.303]                         }
[09:32:37.303]                       })
[09:32:37.303]                     }
[09:32:37.303]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.303]                     base::options(mc.cores = 1L)
[09:32:37.303]                   }
[09:32:37.303]                   ...future.strategy.old <- future::plan("list")
[09:32:37.303]                   options(future.plan = NULL)
[09:32:37.303]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.303]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.303]                 }
[09:32:37.303]                 ...future.workdir <- getwd()
[09:32:37.303]             }
[09:32:37.303]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.303]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.303]         }
[09:32:37.303]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.303]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.303]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.303]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.303]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.303]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.303]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.303]             base::names(...future.oldOptions))
[09:32:37.303]     }
[09:32:37.303]     if (FALSE) {
[09:32:37.303]     }
[09:32:37.303]     else {
[09:32:37.303]         if (TRUE) {
[09:32:37.303]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.303]                 open = "w")
[09:32:37.303]         }
[09:32:37.303]         else {
[09:32:37.303]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.303]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.303]         }
[09:32:37.303]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.303]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.303]             base::sink(type = "output", split = FALSE)
[09:32:37.303]             base::close(...future.stdout)
[09:32:37.303]         }, add = TRUE)
[09:32:37.303]     }
[09:32:37.303]     ...future.frame <- base::sys.nframe()
[09:32:37.303]     ...future.conditions <- base::list()
[09:32:37.303]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.303]     if (FALSE) {
[09:32:37.303]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.303]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.303]     }
[09:32:37.303]     ...future.result <- base::tryCatch({
[09:32:37.303]         base::withCallingHandlers({
[09:32:37.303]             ...future.value <- base::withVisible(base::local({
[09:32:37.303]                 ...future.makeSendCondition <- base::local({
[09:32:37.303]                   sendCondition <- NULL
[09:32:37.303]                   function(frame = 1L) {
[09:32:37.303]                     if (is.function(sendCondition)) 
[09:32:37.303]                       return(sendCondition)
[09:32:37.303]                     ns <- getNamespace("parallel")
[09:32:37.303]                     if (exists("sendData", mode = "function", 
[09:32:37.303]                       envir = ns)) {
[09:32:37.303]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.303]                         envir = ns)
[09:32:37.303]                       envir <- sys.frame(frame)
[09:32:37.303]                       master <- NULL
[09:32:37.303]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.303]                         !identical(envir, emptyenv())) {
[09:32:37.303]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.303]                           inherits = FALSE)) {
[09:32:37.303]                           master <- get("master", mode = "list", 
[09:32:37.303]                             envir = envir, inherits = FALSE)
[09:32:37.303]                           if (inherits(master, c("SOCKnode", 
[09:32:37.303]                             "SOCK0node"))) {
[09:32:37.303]                             sendCondition <<- function(cond) {
[09:32:37.303]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.303]                                 success = TRUE)
[09:32:37.303]                               parallel_sendData(master, data)
[09:32:37.303]                             }
[09:32:37.303]                             return(sendCondition)
[09:32:37.303]                           }
[09:32:37.303]                         }
[09:32:37.303]                         frame <- frame + 1L
[09:32:37.303]                         envir <- sys.frame(frame)
[09:32:37.303]                       }
[09:32:37.303]                     }
[09:32:37.303]                     sendCondition <<- function(cond) NULL
[09:32:37.303]                   }
[09:32:37.303]                 })
[09:32:37.303]                 withCallingHandlers({
[09:32:37.303]                   {
[09:32:37.303]                     Sys.sleep(0.1)
[09:32:37.303]                     kk
[09:32:37.303]                   }
[09:32:37.303]                 }, immediateCondition = function(cond) {
[09:32:37.303]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.303]                   sendCondition(cond)
[09:32:37.303]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.303]                   {
[09:32:37.303]                     inherits <- base::inherits
[09:32:37.303]                     invokeRestart <- base::invokeRestart
[09:32:37.303]                     is.null <- base::is.null
[09:32:37.303]                     muffled <- FALSE
[09:32:37.303]                     if (inherits(cond, "message")) {
[09:32:37.303]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.303]                       if (muffled) 
[09:32:37.303]                         invokeRestart("muffleMessage")
[09:32:37.303]                     }
[09:32:37.303]                     else if (inherits(cond, "warning")) {
[09:32:37.303]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.303]                       if (muffled) 
[09:32:37.303]                         invokeRestart("muffleWarning")
[09:32:37.303]                     }
[09:32:37.303]                     else if (inherits(cond, "condition")) {
[09:32:37.303]                       if (!is.null(pattern)) {
[09:32:37.303]                         computeRestarts <- base::computeRestarts
[09:32:37.303]                         grepl <- base::grepl
[09:32:37.303]                         restarts <- computeRestarts(cond)
[09:32:37.303]                         for (restart in restarts) {
[09:32:37.303]                           name <- restart$name
[09:32:37.303]                           if (is.null(name)) 
[09:32:37.303]                             next
[09:32:37.303]                           if (!grepl(pattern, name)) 
[09:32:37.303]                             next
[09:32:37.303]                           invokeRestart(restart)
[09:32:37.303]                           muffled <- TRUE
[09:32:37.303]                           break
[09:32:37.303]                         }
[09:32:37.303]                       }
[09:32:37.303]                     }
[09:32:37.303]                     invisible(muffled)
[09:32:37.303]                   }
[09:32:37.303]                   muffleCondition(cond)
[09:32:37.303]                 })
[09:32:37.303]             }))
[09:32:37.303]             future::FutureResult(value = ...future.value$value, 
[09:32:37.303]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.303]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.303]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.303]                     ...future.globalenv.names))
[09:32:37.303]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.303]         }, condition = base::local({
[09:32:37.303]             c <- base::c
[09:32:37.303]             inherits <- base::inherits
[09:32:37.303]             invokeRestart <- base::invokeRestart
[09:32:37.303]             length <- base::length
[09:32:37.303]             list <- base::list
[09:32:37.303]             seq.int <- base::seq.int
[09:32:37.303]             signalCondition <- base::signalCondition
[09:32:37.303]             sys.calls <- base::sys.calls
[09:32:37.303]             `[[` <- base::`[[`
[09:32:37.303]             `+` <- base::`+`
[09:32:37.303]             `<<-` <- base::`<<-`
[09:32:37.303]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.303]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.303]                   3L)]
[09:32:37.303]             }
[09:32:37.303]             function(cond) {
[09:32:37.303]                 is_error <- inherits(cond, "error")
[09:32:37.303]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.303]                   NULL)
[09:32:37.303]                 if (is_error) {
[09:32:37.303]                   sessionInformation <- function() {
[09:32:37.303]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.303]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.303]                       search = base::search(), system = base::Sys.info())
[09:32:37.303]                   }
[09:32:37.303]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.303]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.303]                     cond$call), session = sessionInformation(), 
[09:32:37.303]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.303]                   signalCondition(cond)
[09:32:37.303]                 }
[09:32:37.303]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.303]                 "immediateCondition"))) {
[09:32:37.303]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.303]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.303]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.303]                   if (TRUE && !signal) {
[09:32:37.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.303]                     {
[09:32:37.303]                       inherits <- base::inherits
[09:32:37.303]                       invokeRestart <- base::invokeRestart
[09:32:37.303]                       is.null <- base::is.null
[09:32:37.303]                       muffled <- FALSE
[09:32:37.303]                       if (inherits(cond, "message")) {
[09:32:37.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.303]                         if (muffled) 
[09:32:37.303]                           invokeRestart("muffleMessage")
[09:32:37.303]                       }
[09:32:37.303]                       else if (inherits(cond, "warning")) {
[09:32:37.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.303]                         if (muffled) 
[09:32:37.303]                           invokeRestart("muffleWarning")
[09:32:37.303]                       }
[09:32:37.303]                       else if (inherits(cond, "condition")) {
[09:32:37.303]                         if (!is.null(pattern)) {
[09:32:37.303]                           computeRestarts <- base::computeRestarts
[09:32:37.303]                           grepl <- base::grepl
[09:32:37.303]                           restarts <- computeRestarts(cond)
[09:32:37.303]                           for (restart in restarts) {
[09:32:37.303]                             name <- restart$name
[09:32:37.303]                             if (is.null(name)) 
[09:32:37.303]                               next
[09:32:37.303]                             if (!grepl(pattern, name)) 
[09:32:37.303]                               next
[09:32:37.303]                             invokeRestart(restart)
[09:32:37.303]                             muffled <- TRUE
[09:32:37.303]                             break
[09:32:37.303]                           }
[09:32:37.303]                         }
[09:32:37.303]                       }
[09:32:37.303]                       invisible(muffled)
[09:32:37.303]                     }
[09:32:37.303]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.303]                   }
[09:32:37.303]                 }
[09:32:37.303]                 else {
[09:32:37.303]                   if (TRUE) {
[09:32:37.303]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.303]                     {
[09:32:37.303]                       inherits <- base::inherits
[09:32:37.303]                       invokeRestart <- base::invokeRestart
[09:32:37.303]                       is.null <- base::is.null
[09:32:37.303]                       muffled <- FALSE
[09:32:37.303]                       if (inherits(cond, "message")) {
[09:32:37.303]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.303]                         if (muffled) 
[09:32:37.303]                           invokeRestart("muffleMessage")
[09:32:37.303]                       }
[09:32:37.303]                       else if (inherits(cond, "warning")) {
[09:32:37.303]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.303]                         if (muffled) 
[09:32:37.303]                           invokeRestart("muffleWarning")
[09:32:37.303]                       }
[09:32:37.303]                       else if (inherits(cond, "condition")) {
[09:32:37.303]                         if (!is.null(pattern)) {
[09:32:37.303]                           computeRestarts <- base::computeRestarts
[09:32:37.303]                           grepl <- base::grepl
[09:32:37.303]                           restarts <- computeRestarts(cond)
[09:32:37.303]                           for (restart in restarts) {
[09:32:37.303]                             name <- restart$name
[09:32:37.303]                             if (is.null(name)) 
[09:32:37.303]                               next
[09:32:37.303]                             if (!grepl(pattern, name)) 
[09:32:37.303]                               next
[09:32:37.303]                             invokeRestart(restart)
[09:32:37.303]                             muffled <- TRUE
[09:32:37.303]                             break
[09:32:37.303]                           }
[09:32:37.303]                         }
[09:32:37.303]                       }
[09:32:37.303]                       invisible(muffled)
[09:32:37.303]                     }
[09:32:37.303]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.303]                   }
[09:32:37.303]                 }
[09:32:37.303]             }
[09:32:37.303]         }))
[09:32:37.303]     }, error = function(ex) {
[09:32:37.303]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.303]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.303]                 ...future.rng), started = ...future.startTime, 
[09:32:37.303]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.303]             version = "1.8"), class = "FutureResult")
[09:32:37.303]     }, finally = {
[09:32:37.303]         if (!identical(...future.workdir, getwd())) 
[09:32:37.303]             setwd(...future.workdir)
[09:32:37.303]         {
[09:32:37.303]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.303]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.303]             }
[09:32:37.303]             base::options(...future.oldOptions)
[09:32:37.303]             if (.Platform$OS.type == "windows") {
[09:32:37.303]                 old_names <- names(...future.oldEnvVars)
[09:32:37.303]                 envs <- base::Sys.getenv()
[09:32:37.303]                 names <- names(envs)
[09:32:37.303]                 common <- intersect(names, old_names)
[09:32:37.303]                 added <- setdiff(names, old_names)
[09:32:37.303]                 removed <- setdiff(old_names, names)
[09:32:37.303]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.303]                   envs[common]]
[09:32:37.303]                 NAMES <- toupper(changed)
[09:32:37.303]                 args <- list()
[09:32:37.303]                 for (kk in seq_along(NAMES)) {
[09:32:37.303]                   name <- changed[[kk]]
[09:32:37.303]                   NAME <- NAMES[[kk]]
[09:32:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.303]                     next
[09:32:37.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.303]                 }
[09:32:37.303]                 NAMES <- toupper(added)
[09:32:37.303]                 for (kk in seq_along(NAMES)) {
[09:32:37.303]                   name <- added[[kk]]
[09:32:37.303]                   NAME <- NAMES[[kk]]
[09:32:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.303]                     next
[09:32:37.303]                   args[[name]] <- ""
[09:32:37.303]                 }
[09:32:37.303]                 NAMES <- toupper(removed)
[09:32:37.303]                 for (kk in seq_along(NAMES)) {
[09:32:37.303]                   name <- removed[[kk]]
[09:32:37.303]                   NAME <- NAMES[[kk]]
[09:32:37.303]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.303]                     next
[09:32:37.303]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.303]                 }
[09:32:37.303]                 if (length(args) > 0) 
[09:32:37.303]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.303]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.303]             }
[09:32:37.303]             else {
[09:32:37.303]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.303]             }
[09:32:37.303]             {
[09:32:37.303]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.303]                   0L) {
[09:32:37.303]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.303]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.303]                   base::options(opts)
[09:32:37.303]                 }
[09:32:37.303]                 {
[09:32:37.303]                   {
[09:32:37.303]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.303]                     NULL
[09:32:37.303]                   }
[09:32:37.303]                   options(future.plan = NULL)
[09:32:37.303]                   if (is.na(NA_character_)) 
[09:32:37.303]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.303]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.303]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.303]                     .init = FALSE)
[09:32:37.303]                 }
[09:32:37.303]             }
[09:32:37.303]         }
[09:32:37.303]     })
[09:32:37.303]     if (TRUE) {
[09:32:37.303]         base::sink(type = "output", split = FALSE)
[09:32:37.303]         if (TRUE) {
[09:32:37.303]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.303]         }
[09:32:37.303]         else {
[09:32:37.303]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.303]         }
[09:32:37.303]         base::close(...future.stdout)
[09:32:37.303]         ...future.stdout <- NULL
[09:32:37.303]     }
[09:32:37.303]     ...future.result$conditions <- ...future.conditions
[09:32:37.303]     ...future.result$finished <- base::Sys.time()
[09:32:37.303]     ...future.result
[09:32:37.303] }
[09:32:37.305] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:37.336] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[09:32:37.347] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.347] - Validating connection of MultisessionFuture
[09:32:37.347] - received message: FutureResult
[09:32:37.347] - Received FutureResult
[09:32:37.348] - Erased future from FutureRegistry
[09:32:37.348] result() for ClusterFuture ...
[09:32:37.348] - result already collected: FutureResult
[09:32:37.348] result() for ClusterFuture ... done
[09:32:37.348] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.348] result() for ClusterFuture ...
[09:32:37.348] - result already collected: FutureResult
[09:32:37.348] result() for ClusterFuture ... done
[09:32:37.348] result() for ClusterFuture ...
[09:32:37.348] - result already collected: FutureResult
[09:32:37.349] result() for ClusterFuture ... done
[09:32:37.349] Exporting 1 global objects (56 bytes) to cluster node #1 ...
[09:32:37.349] Exporting ‘kk’ (56 bytes) to cluster node #1 ...
[09:32:37.350] Exporting ‘kk’ (56 bytes) to cluster node #1 ... DONE
[09:32:37.350] Exporting 1 global objects (56 bytes) to cluster node #1 ... DONE
[09:32:37.350] MultisessionFuture started
[09:32:37.350] - Launch lazy future ... done
[09:32:37.351] run() for ‘MultisessionFuture’ ... done
[09:32:37.371] Future #1
[09:32:37.372]  length: 2 (resolved future 1)
[09:32:37.377] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.377] - Validating connection of MultisessionFuture
[09:32:37.378] - received message: FutureResult
[09:32:37.378] - Received FutureResult
[09:32:37.378] - Erased future from FutureRegistry
[09:32:37.378] result() for ClusterFuture ...
[09:32:37.378] - result already collected: FutureResult
[09:32:37.378] result() for ClusterFuture ... done
[09:32:37.378] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.378] Future #2
[09:32:37.378]  length: 1 (resolved future 2)
[09:32:37.461] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.461] - Validating connection of MultisessionFuture
[09:32:37.461] - received message: FutureResult
[09:32:37.461] - Received FutureResult
[09:32:37.462] - Erased future from FutureRegistry
[09:32:37.462] result() for ClusterFuture ...
[09:32:37.462] - result already collected: FutureResult
[09:32:37.462] result() for ClusterFuture ... done
[09:32:37.462] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.462] Future #3
[09:32:37.462]  length: 0 (resolved future 3)
[09:32:37.462] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[09:32:37.463] resolve() on environment ...
[09:32:37.463]  recursive: 0
[09:32:37.463]  elements: [2] ‘a’, ‘b’
[09:32:37.463]  length: 1 (resolved future 1)
[09:32:37.464]  length: 0 (resolved future 2)
[09:32:37.464] resolve() on environment ... DONE
[09:32:37.464] getGlobalsAndPackages() ...
[09:32:37.464] Searching for globals...
[09:32:37.465] 
[09:32:37.465] Searching for globals ... DONE
[09:32:37.465] - globals: [0] <none>
[09:32:37.465] getGlobalsAndPackages() ... DONE
[09:32:37.465] run() for ‘Future’ ...
[09:32:37.465] - state: ‘created’
[09:32:37.465] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.479] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.479]   - Field: ‘node’
[09:32:37.479]   - Field: ‘label’
[09:32:37.479]   - Field: ‘local’
[09:32:37.479]   - Field: ‘owner’
[09:32:37.479]   - Field: ‘envir’
[09:32:37.479]   - Field: ‘workers’
[09:32:37.479]   - Field: ‘packages’
[09:32:37.480]   - Field: ‘gc’
[09:32:37.480]   - Field: ‘conditions’
[09:32:37.480]   - Field: ‘persistent’
[09:32:37.480]   - Field: ‘expr’
[09:32:37.480]   - Field: ‘uuid’
[09:32:37.480]   - Field: ‘seed’
[09:32:37.480]   - Field: ‘version’
[09:32:37.480]   - Field: ‘result’
[09:32:37.480]   - Field: ‘asynchronous’
[09:32:37.480]   - Field: ‘calls’
[09:32:37.480]   - Field: ‘globals’
[09:32:37.481]   - Field: ‘stdout’
[09:32:37.481]   - Field: ‘earlySignal’
[09:32:37.481]   - Field: ‘lazy’
[09:32:37.481]   - Field: ‘state’
[09:32:37.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.481] - Launch lazy future ...
[09:32:37.481] Packages needed by the future expression (n = 0): <none>
[09:32:37.481] Packages needed by future strategies (n = 0): <none>
[09:32:37.482] {
[09:32:37.482]     {
[09:32:37.482]         {
[09:32:37.482]             ...future.startTime <- base::Sys.time()
[09:32:37.482]             {
[09:32:37.482]                 {
[09:32:37.482]                   {
[09:32:37.482]                     {
[09:32:37.482]                       base::local({
[09:32:37.482]                         has_future <- base::requireNamespace("future", 
[09:32:37.482]                           quietly = TRUE)
[09:32:37.482]                         if (has_future) {
[09:32:37.482]                           ns <- base::getNamespace("future")
[09:32:37.482]                           version <- ns[[".package"]][["version"]]
[09:32:37.482]                           if (is.null(version)) 
[09:32:37.482]                             version <- utils::packageVersion("future")
[09:32:37.482]                         }
[09:32:37.482]                         else {
[09:32:37.482]                           version <- NULL
[09:32:37.482]                         }
[09:32:37.482]                         if (!has_future || version < "1.8.0") {
[09:32:37.482]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.482]                             "", base::R.version$version.string), 
[09:32:37.482]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.482]                               "release", "version")], collapse = " "), 
[09:32:37.482]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.482]                             info)
[09:32:37.482]                           info <- base::paste(info, collapse = "; ")
[09:32:37.482]                           if (!has_future) {
[09:32:37.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.482]                               info)
[09:32:37.482]                           }
[09:32:37.482]                           else {
[09:32:37.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.482]                               info, version)
[09:32:37.482]                           }
[09:32:37.482]                           base::stop(msg)
[09:32:37.482]                         }
[09:32:37.482]                       })
[09:32:37.482]                     }
[09:32:37.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.482]                     base::options(mc.cores = 1L)
[09:32:37.482]                   }
[09:32:37.482]                   ...future.strategy.old <- future::plan("list")
[09:32:37.482]                   options(future.plan = NULL)
[09:32:37.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.482]                 }
[09:32:37.482]                 ...future.workdir <- getwd()
[09:32:37.482]             }
[09:32:37.482]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.482]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.482]         }
[09:32:37.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.482]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.482]             base::names(...future.oldOptions))
[09:32:37.482]     }
[09:32:37.482]     if (FALSE) {
[09:32:37.482]     }
[09:32:37.482]     else {
[09:32:37.482]         if (TRUE) {
[09:32:37.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.482]                 open = "w")
[09:32:37.482]         }
[09:32:37.482]         else {
[09:32:37.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.482]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.482]         }
[09:32:37.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.482]             base::sink(type = "output", split = FALSE)
[09:32:37.482]             base::close(...future.stdout)
[09:32:37.482]         }, add = TRUE)
[09:32:37.482]     }
[09:32:37.482]     ...future.frame <- base::sys.nframe()
[09:32:37.482]     ...future.conditions <- base::list()
[09:32:37.482]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.482]     if (FALSE) {
[09:32:37.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.482]     }
[09:32:37.482]     ...future.result <- base::tryCatch({
[09:32:37.482]         base::withCallingHandlers({
[09:32:37.482]             ...future.value <- base::withVisible(base::local({
[09:32:37.482]                 ...future.makeSendCondition <- base::local({
[09:32:37.482]                   sendCondition <- NULL
[09:32:37.482]                   function(frame = 1L) {
[09:32:37.482]                     if (is.function(sendCondition)) 
[09:32:37.482]                       return(sendCondition)
[09:32:37.482]                     ns <- getNamespace("parallel")
[09:32:37.482]                     if (exists("sendData", mode = "function", 
[09:32:37.482]                       envir = ns)) {
[09:32:37.482]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.482]                         envir = ns)
[09:32:37.482]                       envir <- sys.frame(frame)
[09:32:37.482]                       master <- NULL
[09:32:37.482]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.482]                         !identical(envir, emptyenv())) {
[09:32:37.482]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.482]                           inherits = FALSE)) {
[09:32:37.482]                           master <- get("master", mode = "list", 
[09:32:37.482]                             envir = envir, inherits = FALSE)
[09:32:37.482]                           if (inherits(master, c("SOCKnode", 
[09:32:37.482]                             "SOCK0node"))) {
[09:32:37.482]                             sendCondition <<- function(cond) {
[09:32:37.482]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.482]                                 success = TRUE)
[09:32:37.482]                               parallel_sendData(master, data)
[09:32:37.482]                             }
[09:32:37.482]                             return(sendCondition)
[09:32:37.482]                           }
[09:32:37.482]                         }
[09:32:37.482]                         frame <- frame + 1L
[09:32:37.482]                         envir <- sys.frame(frame)
[09:32:37.482]                       }
[09:32:37.482]                     }
[09:32:37.482]                     sendCondition <<- function(cond) NULL
[09:32:37.482]                   }
[09:32:37.482]                 })
[09:32:37.482]                 withCallingHandlers({
[09:32:37.482]                   1
[09:32:37.482]                 }, immediateCondition = function(cond) {
[09:32:37.482]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.482]                   sendCondition(cond)
[09:32:37.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.482]                   {
[09:32:37.482]                     inherits <- base::inherits
[09:32:37.482]                     invokeRestart <- base::invokeRestart
[09:32:37.482]                     is.null <- base::is.null
[09:32:37.482]                     muffled <- FALSE
[09:32:37.482]                     if (inherits(cond, "message")) {
[09:32:37.482]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.482]                       if (muffled) 
[09:32:37.482]                         invokeRestart("muffleMessage")
[09:32:37.482]                     }
[09:32:37.482]                     else if (inherits(cond, "warning")) {
[09:32:37.482]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.482]                       if (muffled) 
[09:32:37.482]                         invokeRestart("muffleWarning")
[09:32:37.482]                     }
[09:32:37.482]                     else if (inherits(cond, "condition")) {
[09:32:37.482]                       if (!is.null(pattern)) {
[09:32:37.482]                         computeRestarts <- base::computeRestarts
[09:32:37.482]                         grepl <- base::grepl
[09:32:37.482]                         restarts <- computeRestarts(cond)
[09:32:37.482]                         for (restart in restarts) {
[09:32:37.482]                           name <- restart$name
[09:32:37.482]                           if (is.null(name)) 
[09:32:37.482]                             next
[09:32:37.482]                           if (!grepl(pattern, name)) 
[09:32:37.482]                             next
[09:32:37.482]                           invokeRestart(restart)
[09:32:37.482]                           muffled <- TRUE
[09:32:37.482]                           break
[09:32:37.482]                         }
[09:32:37.482]                       }
[09:32:37.482]                     }
[09:32:37.482]                     invisible(muffled)
[09:32:37.482]                   }
[09:32:37.482]                   muffleCondition(cond)
[09:32:37.482]                 })
[09:32:37.482]             }))
[09:32:37.482]             future::FutureResult(value = ...future.value$value, 
[09:32:37.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.482]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.482]                     ...future.globalenv.names))
[09:32:37.482]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.482]         }, condition = base::local({
[09:32:37.482]             c <- base::c
[09:32:37.482]             inherits <- base::inherits
[09:32:37.482]             invokeRestart <- base::invokeRestart
[09:32:37.482]             length <- base::length
[09:32:37.482]             list <- base::list
[09:32:37.482]             seq.int <- base::seq.int
[09:32:37.482]             signalCondition <- base::signalCondition
[09:32:37.482]             sys.calls <- base::sys.calls
[09:32:37.482]             `[[` <- base::`[[`
[09:32:37.482]             `+` <- base::`+`
[09:32:37.482]             `<<-` <- base::`<<-`
[09:32:37.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.482]                   3L)]
[09:32:37.482]             }
[09:32:37.482]             function(cond) {
[09:32:37.482]                 is_error <- inherits(cond, "error")
[09:32:37.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.482]                   NULL)
[09:32:37.482]                 if (is_error) {
[09:32:37.482]                   sessionInformation <- function() {
[09:32:37.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.482]                       search = base::search(), system = base::Sys.info())
[09:32:37.482]                   }
[09:32:37.482]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.482]                     cond$call), session = sessionInformation(), 
[09:32:37.482]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.482]                   signalCondition(cond)
[09:32:37.482]                 }
[09:32:37.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.482]                 "immediateCondition"))) {
[09:32:37.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.482]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.482]                   if (TRUE && !signal) {
[09:32:37.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.482]                     {
[09:32:37.482]                       inherits <- base::inherits
[09:32:37.482]                       invokeRestart <- base::invokeRestart
[09:32:37.482]                       is.null <- base::is.null
[09:32:37.482]                       muffled <- FALSE
[09:32:37.482]                       if (inherits(cond, "message")) {
[09:32:37.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.482]                         if (muffled) 
[09:32:37.482]                           invokeRestart("muffleMessage")
[09:32:37.482]                       }
[09:32:37.482]                       else if (inherits(cond, "warning")) {
[09:32:37.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.482]                         if (muffled) 
[09:32:37.482]                           invokeRestart("muffleWarning")
[09:32:37.482]                       }
[09:32:37.482]                       else if (inherits(cond, "condition")) {
[09:32:37.482]                         if (!is.null(pattern)) {
[09:32:37.482]                           computeRestarts <- base::computeRestarts
[09:32:37.482]                           grepl <- base::grepl
[09:32:37.482]                           restarts <- computeRestarts(cond)
[09:32:37.482]                           for (restart in restarts) {
[09:32:37.482]                             name <- restart$name
[09:32:37.482]                             if (is.null(name)) 
[09:32:37.482]                               next
[09:32:37.482]                             if (!grepl(pattern, name)) 
[09:32:37.482]                               next
[09:32:37.482]                             invokeRestart(restart)
[09:32:37.482]                             muffled <- TRUE
[09:32:37.482]                             break
[09:32:37.482]                           }
[09:32:37.482]                         }
[09:32:37.482]                       }
[09:32:37.482]                       invisible(muffled)
[09:32:37.482]                     }
[09:32:37.482]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.482]                   }
[09:32:37.482]                 }
[09:32:37.482]                 else {
[09:32:37.482]                   if (TRUE) {
[09:32:37.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.482]                     {
[09:32:37.482]                       inherits <- base::inherits
[09:32:37.482]                       invokeRestart <- base::invokeRestart
[09:32:37.482]                       is.null <- base::is.null
[09:32:37.482]                       muffled <- FALSE
[09:32:37.482]                       if (inherits(cond, "message")) {
[09:32:37.482]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.482]                         if (muffled) 
[09:32:37.482]                           invokeRestart("muffleMessage")
[09:32:37.482]                       }
[09:32:37.482]                       else if (inherits(cond, "warning")) {
[09:32:37.482]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.482]                         if (muffled) 
[09:32:37.482]                           invokeRestart("muffleWarning")
[09:32:37.482]                       }
[09:32:37.482]                       else if (inherits(cond, "condition")) {
[09:32:37.482]                         if (!is.null(pattern)) {
[09:32:37.482]                           computeRestarts <- base::computeRestarts
[09:32:37.482]                           grepl <- base::grepl
[09:32:37.482]                           restarts <- computeRestarts(cond)
[09:32:37.482]                           for (restart in restarts) {
[09:32:37.482]                             name <- restart$name
[09:32:37.482]                             if (is.null(name)) 
[09:32:37.482]                               next
[09:32:37.482]                             if (!grepl(pattern, name)) 
[09:32:37.482]                               next
[09:32:37.482]                             invokeRestart(restart)
[09:32:37.482]                             muffled <- TRUE
[09:32:37.482]                             break
[09:32:37.482]                           }
[09:32:37.482]                         }
[09:32:37.482]                       }
[09:32:37.482]                       invisible(muffled)
[09:32:37.482]                     }
[09:32:37.482]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.482]                   }
[09:32:37.482]                 }
[09:32:37.482]             }
[09:32:37.482]         }))
[09:32:37.482]     }, error = function(ex) {
[09:32:37.482]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.482]                 ...future.rng), started = ...future.startTime, 
[09:32:37.482]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.482]             version = "1.8"), class = "FutureResult")
[09:32:37.482]     }, finally = {
[09:32:37.482]         if (!identical(...future.workdir, getwd())) 
[09:32:37.482]             setwd(...future.workdir)
[09:32:37.482]         {
[09:32:37.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.482]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.482]             }
[09:32:37.482]             base::options(...future.oldOptions)
[09:32:37.482]             if (.Platform$OS.type == "windows") {
[09:32:37.482]                 old_names <- names(...future.oldEnvVars)
[09:32:37.482]                 envs <- base::Sys.getenv()
[09:32:37.482]                 names <- names(envs)
[09:32:37.482]                 common <- intersect(names, old_names)
[09:32:37.482]                 added <- setdiff(names, old_names)
[09:32:37.482]                 removed <- setdiff(old_names, names)
[09:32:37.482]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.482]                   envs[common]]
[09:32:37.482]                 NAMES <- toupper(changed)
[09:32:37.482]                 args <- list()
[09:32:37.482]                 for (kk in seq_along(NAMES)) {
[09:32:37.482]                   name <- changed[[kk]]
[09:32:37.482]                   NAME <- NAMES[[kk]]
[09:32:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.482]                     next
[09:32:37.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.482]                 }
[09:32:37.482]                 NAMES <- toupper(added)
[09:32:37.482]                 for (kk in seq_along(NAMES)) {
[09:32:37.482]                   name <- added[[kk]]
[09:32:37.482]                   NAME <- NAMES[[kk]]
[09:32:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.482]                     next
[09:32:37.482]                   args[[name]] <- ""
[09:32:37.482]                 }
[09:32:37.482]                 NAMES <- toupper(removed)
[09:32:37.482]                 for (kk in seq_along(NAMES)) {
[09:32:37.482]                   name <- removed[[kk]]
[09:32:37.482]                   NAME <- NAMES[[kk]]
[09:32:37.482]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.482]                     next
[09:32:37.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.482]                 }
[09:32:37.482]                 if (length(args) > 0) 
[09:32:37.482]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.482]             }
[09:32:37.482]             else {
[09:32:37.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.482]             }
[09:32:37.482]             {
[09:32:37.482]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.482]                   0L) {
[09:32:37.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.482]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.482]                   base::options(opts)
[09:32:37.482]                 }
[09:32:37.482]                 {
[09:32:37.482]                   {
[09:32:37.482]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.482]                     NULL
[09:32:37.482]                   }
[09:32:37.482]                   options(future.plan = NULL)
[09:32:37.482]                   if (is.na(NA_character_)) 
[09:32:37.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.482]                     .init = FALSE)
[09:32:37.482]                 }
[09:32:37.482]             }
[09:32:37.482]         }
[09:32:37.482]     })
[09:32:37.482]     if (TRUE) {
[09:32:37.482]         base::sink(type = "output", split = FALSE)
[09:32:37.482]         if (TRUE) {
[09:32:37.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.482]         }
[09:32:37.482]         else {
[09:32:37.482]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.482]         }
[09:32:37.482]         base::close(...future.stdout)
[09:32:37.482]         ...future.stdout <- NULL
[09:32:37.482]     }
[09:32:37.482]     ...future.result$conditions <- ...future.conditions
[09:32:37.482]     ...future.result$finished <- base::Sys.time()
[09:32:37.482]     ...future.result
[09:32:37.482] }
[09:32:37.485] MultisessionFuture started
[09:32:37.485] - Launch lazy future ... done
[09:32:37.485] run() for ‘MultisessionFuture’ ... done
[09:32:37.485] getGlobalsAndPackages() ...
[09:32:37.485] Searching for globals...
[09:32:37.485] 
[09:32:37.485] Searching for globals ... DONE
[09:32:37.486] - globals: [0] <none>
[09:32:37.486] getGlobalsAndPackages() ... DONE
[09:32:37.486] run() for ‘Future’ ...
[09:32:37.486] - state: ‘created’
[09:32:37.486] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.500]   - Field: ‘node’
[09:32:37.500]   - Field: ‘label’
[09:32:37.500]   - Field: ‘local’
[09:32:37.500]   - Field: ‘owner’
[09:32:37.500]   - Field: ‘envir’
[09:32:37.500]   - Field: ‘workers’
[09:32:37.500]   - Field: ‘packages’
[09:32:37.500]   - Field: ‘gc’
[09:32:37.500]   - Field: ‘conditions’
[09:32:37.500]   - Field: ‘persistent’
[09:32:37.501]   - Field: ‘expr’
[09:32:37.501]   - Field: ‘uuid’
[09:32:37.501]   - Field: ‘seed’
[09:32:37.501]   - Field: ‘version’
[09:32:37.501]   - Field: ‘result’
[09:32:37.501]   - Field: ‘asynchronous’
[09:32:37.501]   - Field: ‘calls’
[09:32:37.501]   - Field: ‘globals’
[09:32:37.501]   - Field: ‘stdout’
[09:32:37.501]   - Field: ‘earlySignal’
[09:32:37.501]   - Field: ‘lazy’
[09:32:37.502]   - Field: ‘state’
[09:32:37.502] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.502] - Launch lazy future ...
[09:32:37.502] Packages needed by the future expression (n = 0): <none>
[09:32:37.502] Packages needed by future strategies (n = 0): <none>
[09:32:37.502] {
[09:32:37.502]     {
[09:32:37.502]         {
[09:32:37.502]             ...future.startTime <- base::Sys.time()
[09:32:37.502]             {
[09:32:37.502]                 {
[09:32:37.502]                   {
[09:32:37.502]                     {
[09:32:37.502]                       base::local({
[09:32:37.502]                         has_future <- base::requireNamespace("future", 
[09:32:37.502]                           quietly = TRUE)
[09:32:37.502]                         if (has_future) {
[09:32:37.502]                           ns <- base::getNamespace("future")
[09:32:37.502]                           version <- ns[[".package"]][["version"]]
[09:32:37.502]                           if (is.null(version)) 
[09:32:37.502]                             version <- utils::packageVersion("future")
[09:32:37.502]                         }
[09:32:37.502]                         else {
[09:32:37.502]                           version <- NULL
[09:32:37.502]                         }
[09:32:37.502]                         if (!has_future || version < "1.8.0") {
[09:32:37.502]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.502]                             "", base::R.version$version.string), 
[09:32:37.502]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.502]                               "release", "version")], collapse = " "), 
[09:32:37.502]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.502]                             info)
[09:32:37.502]                           info <- base::paste(info, collapse = "; ")
[09:32:37.502]                           if (!has_future) {
[09:32:37.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.502]                               info)
[09:32:37.502]                           }
[09:32:37.502]                           else {
[09:32:37.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.502]                               info, version)
[09:32:37.502]                           }
[09:32:37.502]                           base::stop(msg)
[09:32:37.502]                         }
[09:32:37.502]                       })
[09:32:37.502]                     }
[09:32:37.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.502]                     base::options(mc.cores = 1L)
[09:32:37.502]                   }
[09:32:37.502]                   ...future.strategy.old <- future::plan("list")
[09:32:37.502]                   options(future.plan = NULL)
[09:32:37.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.502]                 }
[09:32:37.502]                 ...future.workdir <- getwd()
[09:32:37.502]             }
[09:32:37.502]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.502]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.502]         }
[09:32:37.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.502]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.502]             base::names(...future.oldOptions))
[09:32:37.502]     }
[09:32:37.502]     if (FALSE) {
[09:32:37.502]     }
[09:32:37.502]     else {
[09:32:37.502]         if (TRUE) {
[09:32:37.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.502]                 open = "w")
[09:32:37.502]         }
[09:32:37.502]         else {
[09:32:37.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.502]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.502]         }
[09:32:37.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.502]             base::sink(type = "output", split = FALSE)
[09:32:37.502]             base::close(...future.stdout)
[09:32:37.502]         }, add = TRUE)
[09:32:37.502]     }
[09:32:37.502]     ...future.frame <- base::sys.nframe()
[09:32:37.502]     ...future.conditions <- base::list()
[09:32:37.502]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.502]     if (FALSE) {
[09:32:37.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.502]     }
[09:32:37.502]     ...future.result <- base::tryCatch({
[09:32:37.502]         base::withCallingHandlers({
[09:32:37.502]             ...future.value <- base::withVisible(base::local({
[09:32:37.502]                 ...future.makeSendCondition <- base::local({
[09:32:37.502]                   sendCondition <- NULL
[09:32:37.502]                   function(frame = 1L) {
[09:32:37.502]                     if (is.function(sendCondition)) 
[09:32:37.502]                       return(sendCondition)
[09:32:37.502]                     ns <- getNamespace("parallel")
[09:32:37.502]                     if (exists("sendData", mode = "function", 
[09:32:37.502]                       envir = ns)) {
[09:32:37.502]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.502]                         envir = ns)
[09:32:37.502]                       envir <- sys.frame(frame)
[09:32:37.502]                       master <- NULL
[09:32:37.502]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.502]                         !identical(envir, emptyenv())) {
[09:32:37.502]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.502]                           inherits = FALSE)) {
[09:32:37.502]                           master <- get("master", mode = "list", 
[09:32:37.502]                             envir = envir, inherits = FALSE)
[09:32:37.502]                           if (inherits(master, c("SOCKnode", 
[09:32:37.502]                             "SOCK0node"))) {
[09:32:37.502]                             sendCondition <<- function(cond) {
[09:32:37.502]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.502]                                 success = TRUE)
[09:32:37.502]                               parallel_sendData(master, data)
[09:32:37.502]                             }
[09:32:37.502]                             return(sendCondition)
[09:32:37.502]                           }
[09:32:37.502]                         }
[09:32:37.502]                         frame <- frame + 1L
[09:32:37.502]                         envir <- sys.frame(frame)
[09:32:37.502]                       }
[09:32:37.502]                     }
[09:32:37.502]                     sendCondition <<- function(cond) NULL
[09:32:37.502]                   }
[09:32:37.502]                 })
[09:32:37.502]                 withCallingHandlers({
[09:32:37.502]                   2
[09:32:37.502]                 }, immediateCondition = function(cond) {
[09:32:37.502]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.502]                   sendCondition(cond)
[09:32:37.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.502]                   {
[09:32:37.502]                     inherits <- base::inherits
[09:32:37.502]                     invokeRestart <- base::invokeRestart
[09:32:37.502]                     is.null <- base::is.null
[09:32:37.502]                     muffled <- FALSE
[09:32:37.502]                     if (inherits(cond, "message")) {
[09:32:37.502]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.502]                       if (muffled) 
[09:32:37.502]                         invokeRestart("muffleMessage")
[09:32:37.502]                     }
[09:32:37.502]                     else if (inherits(cond, "warning")) {
[09:32:37.502]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.502]                       if (muffled) 
[09:32:37.502]                         invokeRestart("muffleWarning")
[09:32:37.502]                     }
[09:32:37.502]                     else if (inherits(cond, "condition")) {
[09:32:37.502]                       if (!is.null(pattern)) {
[09:32:37.502]                         computeRestarts <- base::computeRestarts
[09:32:37.502]                         grepl <- base::grepl
[09:32:37.502]                         restarts <- computeRestarts(cond)
[09:32:37.502]                         for (restart in restarts) {
[09:32:37.502]                           name <- restart$name
[09:32:37.502]                           if (is.null(name)) 
[09:32:37.502]                             next
[09:32:37.502]                           if (!grepl(pattern, name)) 
[09:32:37.502]                             next
[09:32:37.502]                           invokeRestart(restart)
[09:32:37.502]                           muffled <- TRUE
[09:32:37.502]                           break
[09:32:37.502]                         }
[09:32:37.502]                       }
[09:32:37.502]                     }
[09:32:37.502]                     invisible(muffled)
[09:32:37.502]                   }
[09:32:37.502]                   muffleCondition(cond)
[09:32:37.502]                 })
[09:32:37.502]             }))
[09:32:37.502]             future::FutureResult(value = ...future.value$value, 
[09:32:37.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.502]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.502]                     ...future.globalenv.names))
[09:32:37.502]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.502]         }, condition = base::local({
[09:32:37.502]             c <- base::c
[09:32:37.502]             inherits <- base::inherits
[09:32:37.502]             invokeRestart <- base::invokeRestart
[09:32:37.502]             length <- base::length
[09:32:37.502]             list <- base::list
[09:32:37.502]             seq.int <- base::seq.int
[09:32:37.502]             signalCondition <- base::signalCondition
[09:32:37.502]             sys.calls <- base::sys.calls
[09:32:37.502]             `[[` <- base::`[[`
[09:32:37.502]             `+` <- base::`+`
[09:32:37.502]             `<<-` <- base::`<<-`
[09:32:37.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.502]                   3L)]
[09:32:37.502]             }
[09:32:37.502]             function(cond) {
[09:32:37.502]                 is_error <- inherits(cond, "error")
[09:32:37.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.502]                   NULL)
[09:32:37.502]                 if (is_error) {
[09:32:37.502]                   sessionInformation <- function() {
[09:32:37.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.502]                       search = base::search(), system = base::Sys.info())
[09:32:37.502]                   }
[09:32:37.502]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.502]                     cond$call), session = sessionInformation(), 
[09:32:37.502]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.502]                   signalCondition(cond)
[09:32:37.502]                 }
[09:32:37.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.502]                 "immediateCondition"))) {
[09:32:37.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.502]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.502]                   if (TRUE && !signal) {
[09:32:37.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.502]                     {
[09:32:37.502]                       inherits <- base::inherits
[09:32:37.502]                       invokeRestart <- base::invokeRestart
[09:32:37.502]                       is.null <- base::is.null
[09:32:37.502]                       muffled <- FALSE
[09:32:37.502]                       if (inherits(cond, "message")) {
[09:32:37.502]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.502]                         if (muffled) 
[09:32:37.502]                           invokeRestart("muffleMessage")
[09:32:37.502]                       }
[09:32:37.502]                       else if (inherits(cond, "warning")) {
[09:32:37.502]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.502]                         if (muffled) 
[09:32:37.502]                           invokeRestart("muffleWarning")
[09:32:37.502]                       }
[09:32:37.502]                       else if (inherits(cond, "condition")) {
[09:32:37.502]                         if (!is.null(pattern)) {
[09:32:37.502]                           computeRestarts <- base::computeRestarts
[09:32:37.502]                           grepl <- base::grepl
[09:32:37.502]                           restarts <- computeRestarts(cond)
[09:32:37.502]                           for (restart in restarts) {
[09:32:37.502]                             name <- restart$name
[09:32:37.502]                             if (is.null(name)) 
[09:32:37.502]                               next
[09:32:37.502]                             if (!grepl(pattern, name)) 
[09:32:37.502]                               next
[09:32:37.502]                             invokeRestart(restart)
[09:32:37.502]                             muffled <- TRUE
[09:32:37.502]                             break
[09:32:37.502]                           }
[09:32:37.502]                         }
[09:32:37.502]                       }
[09:32:37.502]                       invisible(muffled)
[09:32:37.502]                     }
[09:32:37.502]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.502]                   }
[09:32:37.502]                 }
[09:32:37.502]                 else {
[09:32:37.502]                   if (TRUE) {
[09:32:37.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.502]                     {
[09:32:37.502]                       inherits <- base::inherits
[09:32:37.502]                       invokeRestart <- base::invokeRestart
[09:32:37.502]                       is.null <- base::is.null
[09:32:37.502]                       muffled <- FALSE
[09:32:37.502]                       if (inherits(cond, "message")) {
[09:32:37.502]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.502]                         if (muffled) 
[09:32:37.502]                           invokeRestart("muffleMessage")
[09:32:37.502]                       }
[09:32:37.502]                       else if (inherits(cond, "warning")) {
[09:32:37.502]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.502]                         if (muffled) 
[09:32:37.502]                           invokeRestart("muffleWarning")
[09:32:37.502]                       }
[09:32:37.502]                       else if (inherits(cond, "condition")) {
[09:32:37.502]                         if (!is.null(pattern)) {
[09:32:37.502]                           computeRestarts <- base::computeRestarts
[09:32:37.502]                           grepl <- base::grepl
[09:32:37.502]                           restarts <- computeRestarts(cond)
[09:32:37.502]                           for (restart in restarts) {
[09:32:37.502]                             name <- restart$name
[09:32:37.502]                             if (is.null(name)) 
[09:32:37.502]                               next
[09:32:37.502]                             if (!grepl(pattern, name)) 
[09:32:37.502]                               next
[09:32:37.502]                             invokeRestart(restart)
[09:32:37.502]                             muffled <- TRUE
[09:32:37.502]                             break
[09:32:37.502]                           }
[09:32:37.502]                         }
[09:32:37.502]                       }
[09:32:37.502]                       invisible(muffled)
[09:32:37.502]                     }
[09:32:37.502]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.502]                   }
[09:32:37.502]                 }
[09:32:37.502]             }
[09:32:37.502]         }))
[09:32:37.502]     }, error = function(ex) {
[09:32:37.502]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.502]                 ...future.rng), started = ...future.startTime, 
[09:32:37.502]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.502]             version = "1.8"), class = "FutureResult")
[09:32:37.502]     }, finally = {
[09:32:37.502]         if (!identical(...future.workdir, getwd())) 
[09:32:37.502]             setwd(...future.workdir)
[09:32:37.502]         {
[09:32:37.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.502]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.502]             }
[09:32:37.502]             base::options(...future.oldOptions)
[09:32:37.502]             if (.Platform$OS.type == "windows") {
[09:32:37.502]                 old_names <- names(...future.oldEnvVars)
[09:32:37.502]                 envs <- base::Sys.getenv()
[09:32:37.502]                 names <- names(envs)
[09:32:37.502]                 common <- intersect(names, old_names)
[09:32:37.502]                 added <- setdiff(names, old_names)
[09:32:37.502]                 removed <- setdiff(old_names, names)
[09:32:37.502]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.502]                   envs[common]]
[09:32:37.502]                 NAMES <- toupper(changed)
[09:32:37.502]                 args <- list()
[09:32:37.502]                 for (kk in seq_along(NAMES)) {
[09:32:37.502]                   name <- changed[[kk]]
[09:32:37.502]                   NAME <- NAMES[[kk]]
[09:32:37.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.502]                     next
[09:32:37.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.502]                 }
[09:32:37.502]                 NAMES <- toupper(added)
[09:32:37.502]                 for (kk in seq_along(NAMES)) {
[09:32:37.502]                   name <- added[[kk]]
[09:32:37.502]                   NAME <- NAMES[[kk]]
[09:32:37.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.502]                     next
[09:32:37.502]                   args[[name]] <- ""
[09:32:37.502]                 }
[09:32:37.502]                 NAMES <- toupper(removed)
[09:32:37.502]                 for (kk in seq_along(NAMES)) {
[09:32:37.502]                   name <- removed[[kk]]
[09:32:37.502]                   NAME <- NAMES[[kk]]
[09:32:37.502]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.502]                     next
[09:32:37.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.502]                 }
[09:32:37.502]                 if (length(args) > 0) 
[09:32:37.502]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.502]             }
[09:32:37.502]             else {
[09:32:37.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.502]             }
[09:32:37.502]             {
[09:32:37.502]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.502]                   0L) {
[09:32:37.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.502]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.502]                   base::options(opts)
[09:32:37.502]                 }
[09:32:37.502]                 {
[09:32:37.502]                   {
[09:32:37.502]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.502]                     NULL
[09:32:37.502]                   }
[09:32:37.502]                   options(future.plan = NULL)
[09:32:37.502]                   if (is.na(NA_character_)) 
[09:32:37.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.502]                     .init = FALSE)
[09:32:37.502]                 }
[09:32:37.502]             }
[09:32:37.502]         }
[09:32:37.502]     })
[09:32:37.502]     if (TRUE) {
[09:32:37.502]         base::sink(type = "output", split = FALSE)
[09:32:37.502]         if (TRUE) {
[09:32:37.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.502]         }
[09:32:37.502]         else {
[09:32:37.502]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.502]         }
[09:32:37.502]         base::close(...future.stdout)
[09:32:37.502]         ...future.stdout <- NULL
[09:32:37.502]     }
[09:32:37.502]     ...future.result$conditions <- ...future.conditions
[09:32:37.502]     ...future.result$finished <- base::Sys.time()
[09:32:37.502]     ...future.result
[09:32:37.502] }
[09:32:37.505] MultisessionFuture started
[09:32:37.505] - Launch lazy future ... done
[09:32:37.505] run() for ‘MultisessionFuture’ ... done
[09:32:37.506] resolve() on environment ...
[09:32:37.506]  recursive: 0
[09:32:37.507]  elements: [3] ‘a’, ‘b’, ‘c’
[09:32:37.507] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.507] - Validating connection of MultisessionFuture
[09:32:37.507] - received message: FutureResult
[09:32:37.507] - Received FutureResult
[09:32:37.508] - Erased future from FutureRegistry
[09:32:37.508] result() for ClusterFuture ...
[09:32:37.508] - result already collected: FutureResult
[09:32:37.508] result() for ClusterFuture ... done
[09:32:37.508] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.508] Future #1
[09:32:37.508]  length: 2 (resolved future 1)
[09:32:37.509] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.509] - Validating connection of MultisessionFuture
[09:32:37.509] - received message: FutureResult
[09:32:37.509] - Received FutureResult
[09:32:37.509] - Erased future from FutureRegistry
[09:32:37.509] result() for ClusterFuture ...
[09:32:37.509] - result already collected: FutureResult
[09:32:37.509] result() for ClusterFuture ... done
[09:32:37.509] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.509] Future #2
[09:32:37.510]  length: 1 (resolved future 2)
[09:32:37.510]  length: 0 (resolved future 3)
[09:32:37.510] resolve() on environment ... DONE
[09:32:37.510] getGlobalsAndPackages() ...
[09:32:37.510] Searching for globals...
[09:32:37.511] - globals found: [1] ‘{’
[09:32:37.511] Searching for globals ... DONE
[09:32:37.511] Resolving globals: FALSE
[09:32:37.511] 
[09:32:37.512] 
[09:32:37.512] getGlobalsAndPackages() ... DONE
[09:32:37.512] run() for ‘Future’ ...
[09:32:37.512] - state: ‘created’
[09:32:37.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.525] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.525]   - Field: ‘node’
[09:32:37.526]   - Field: ‘label’
[09:32:37.526]   - Field: ‘local’
[09:32:37.526]   - Field: ‘owner’
[09:32:37.526]   - Field: ‘envir’
[09:32:37.526]   - Field: ‘workers’
[09:32:37.526]   - Field: ‘packages’
[09:32:37.526]   - Field: ‘gc’
[09:32:37.526]   - Field: ‘conditions’
[09:32:37.526]   - Field: ‘persistent’
[09:32:37.526]   - Field: ‘expr’
[09:32:37.526]   - Field: ‘uuid’
[09:32:37.527]   - Field: ‘seed’
[09:32:37.527]   - Field: ‘version’
[09:32:37.527]   - Field: ‘result’
[09:32:37.527]   - Field: ‘asynchronous’
[09:32:37.527]   - Field: ‘calls’
[09:32:37.527]   - Field: ‘globals’
[09:32:37.527]   - Field: ‘stdout’
[09:32:37.527]   - Field: ‘earlySignal’
[09:32:37.527]   - Field: ‘lazy’
[09:32:37.527]   - Field: ‘state’
[09:32:37.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.528] - Launch lazy future ...
[09:32:37.528] Packages needed by the future expression (n = 0): <none>
[09:32:37.528] Packages needed by future strategies (n = 0): <none>
[09:32:37.528] {
[09:32:37.528]     {
[09:32:37.528]         {
[09:32:37.528]             ...future.startTime <- base::Sys.time()
[09:32:37.528]             {
[09:32:37.528]                 {
[09:32:37.528]                   {
[09:32:37.528]                     {
[09:32:37.528]                       base::local({
[09:32:37.528]                         has_future <- base::requireNamespace("future", 
[09:32:37.528]                           quietly = TRUE)
[09:32:37.528]                         if (has_future) {
[09:32:37.528]                           ns <- base::getNamespace("future")
[09:32:37.528]                           version <- ns[[".package"]][["version"]]
[09:32:37.528]                           if (is.null(version)) 
[09:32:37.528]                             version <- utils::packageVersion("future")
[09:32:37.528]                         }
[09:32:37.528]                         else {
[09:32:37.528]                           version <- NULL
[09:32:37.528]                         }
[09:32:37.528]                         if (!has_future || version < "1.8.0") {
[09:32:37.528]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.528]                             "", base::R.version$version.string), 
[09:32:37.528]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.528]                               "release", "version")], collapse = " "), 
[09:32:37.528]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.528]                             info)
[09:32:37.528]                           info <- base::paste(info, collapse = "; ")
[09:32:37.528]                           if (!has_future) {
[09:32:37.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.528]                               info)
[09:32:37.528]                           }
[09:32:37.528]                           else {
[09:32:37.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.528]                               info, version)
[09:32:37.528]                           }
[09:32:37.528]                           base::stop(msg)
[09:32:37.528]                         }
[09:32:37.528]                       })
[09:32:37.528]                     }
[09:32:37.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.528]                     base::options(mc.cores = 1L)
[09:32:37.528]                   }
[09:32:37.528]                   ...future.strategy.old <- future::plan("list")
[09:32:37.528]                   options(future.plan = NULL)
[09:32:37.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.528]                 }
[09:32:37.528]                 ...future.workdir <- getwd()
[09:32:37.528]             }
[09:32:37.528]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.528]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.528]         }
[09:32:37.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.528]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.528]             base::names(...future.oldOptions))
[09:32:37.528]     }
[09:32:37.528]     if (FALSE) {
[09:32:37.528]     }
[09:32:37.528]     else {
[09:32:37.528]         if (TRUE) {
[09:32:37.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.528]                 open = "w")
[09:32:37.528]         }
[09:32:37.528]         else {
[09:32:37.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.528]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.528]         }
[09:32:37.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.528]             base::sink(type = "output", split = FALSE)
[09:32:37.528]             base::close(...future.stdout)
[09:32:37.528]         }, add = TRUE)
[09:32:37.528]     }
[09:32:37.528]     ...future.frame <- base::sys.nframe()
[09:32:37.528]     ...future.conditions <- base::list()
[09:32:37.528]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.528]     if (FALSE) {
[09:32:37.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.528]     }
[09:32:37.528]     ...future.result <- base::tryCatch({
[09:32:37.528]         base::withCallingHandlers({
[09:32:37.528]             ...future.value <- base::withVisible(base::local({
[09:32:37.528]                 ...future.makeSendCondition <- base::local({
[09:32:37.528]                   sendCondition <- NULL
[09:32:37.528]                   function(frame = 1L) {
[09:32:37.528]                     if (is.function(sendCondition)) 
[09:32:37.528]                       return(sendCondition)
[09:32:37.528]                     ns <- getNamespace("parallel")
[09:32:37.528]                     if (exists("sendData", mode = "function", 
[09:32:37.528]                       envir = ns)) {
[09:32:37.528]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.528]                         envir = ns)
[09:32:37.528]                       envir <- sys.frame(frame)
[09:32:37.528]                       master <- NULL
[09:32:37.528]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.528]                         !identical(envir, emptyenv())) {
[09:32:37.528]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.528]                           inherits = FALSE)) {
[09:32:37.528]                           master <- get("master", mode = "list", 
[09:32:37.528]                             envir = envir, inherits = FALSE)
[09:32:37.528]                           if (inherits(master, c("SOCKnode", 
[09:32:37.528]                             "SOCK0node"))) {
[09:32:37.528]                             sendCondition <<- function(cond) {
[09:32:37.528]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.528]                                 success = TRUE)
[09:32:37.528]                               parallel_sendData(master, data)
[09:32:37.528]                             }
[09:32:37.528]                             return(sendCondition)
[09:32:37.528]                           }
[09:32:37.528]                         }
[09:32:37.528]                         frame <- frame + 1L
[09:32:37.528]                         envir <- sys.frame(frame)
[09:32:37.528]                       }
[09:32:37.528]                     }
[09:32:37.528]                     sendCondition <<- function(cond) NULL
[09:32:37.528]                   }
[09:32:37.528]                 })
[09:32:37.528]                 withCallingHandlers({
[09:32:37.528]                   {
[09:32:37.528]                     1
[09:32:37.528]                   }
[09:32:37.528]                 }, immediateCondition = function(cond) {
[09:32:37.528]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.528]                   sendCondition(cond)
[09:32:37.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.528]                   {
[09:32:37.528]                     inherits <- base::inherits
[09:32:37.528]                     invokeRestart <- base::invokeRestart
[09:32:37.528]                     is.null <- base::is.null
[09:32:37.528]                     muffled <- FALSE
[09:32:37.528]                     if (inherits(cond, "message")) {
[09:32:37.528]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.528]                       if (muffled) 
[09:32:37.528]                         invokeRestart("muffleMessage")
[09:32:37.528]                     }
[09:32:37.528]                     else if (inherits(cond, "warning")) {
[09:32:37.528]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.528]                       if (muffled) 
[09:32:37.528]                         invokeRestart("muffleWarning")
[09:32:37.528]                     }
[09:32:37.528]                     else if (inherits(cond, "condition")) {
[09:32:37.528]                       if (!is.null(pattern)) {
[09:32:37.528]                         computeRestarts <- base::computeRestarts
[09:32:37.528]                         grepl <- base::grepl
[09:32:37.528]                         restarts <- computeRestarts(cond)
[09:32:37.528]                         for (restart in restarts) {
[09:32:37.528]                           name <- restart$name
[09:32:37.528]                           if (is.null(name)) 
[09:32:37.528]                             next
[09:32:37.528]                           if (!grepl(pattern, name)) 
[09:32:37.528]                             next
[09:32:37.528]                           invokeRestart(restart)
[09:32:37.528]                           muffled <- TRUE
[09:32:37.528]                           break
[09:32:37.528]                         }
[09:32:37.528]                       }
[09:32:37.528]                     }
[09:32:37.528]                     invisible(muffled)
[09:32:37.528]                   }
[09:32:37.528]                   muffleCondition(cond)
[09:32:37.528]                 })
[09:32:37.528]             }))
[09:32:37.528]             future::FutureResult(value = ...future.value$value, 
[09:32:37.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.528]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.528]                     ...future.globalenv.names))
[09:32:37.528]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.528]         }, condition = base::local({
[09:32:37.528]             c <- base::c
[09:32:37.528]             inherits <- base::inherits
[09:32:37.528]             invokeRestart <- base::invokeRestart
[09:32:37.528]             length <- base::length
[09:32:37.528]             list <- base::list
[09:32:37.528]             seq.int <- base::seq.int
[09:32:37.528]             signalCondition <- base::signalCondition
[09:32:37.528]             sys.calls <- base::sys.calls
[09:32:37.528]             `[[` <- base::`[[`
[09:32:37.528]             `+` <- base::`+`
[09:32:37.528]             `<<-` <- base::`<<-`
[09:32:37.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.528]                   3L)]
[09:32:37.528]             }
[09:32:37.528]             function(cond) {
[09:32:37.528]                 is_error <- inherits(cond, "error")
[09:32:37.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.528]                   NULL)
[09:32:37.528]                 if (is_error) {
[09:32:37.528]                   sessionInformation <- function() {
[09:32:37.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.528]                       search = base::search(), system = base::Sys.info())
[09:32:37.528]                   }
[09:32:37.528]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.528]                     cond$call), session = sessionInformation(), 
[09:32:37.528]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.528]                   signalCondition(cond)
[09:32:37.528]                 }
[09:32:37.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.528]                 "immediateCondition"))) {
[09:32:37.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.528]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.528]                   if (TRUE && !signal) {
[09:32:37.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.528]                     {
[09:32:37.528]                       inherits <- base::inherits
[09:32:37.528]                       invokeRestart <- base::invokeRestart
[09:32:37.528]                       is.null <- base::is.null
[09:32:37.528]                       muffled <- FALSE
[09:32:37.528]                       if (inherits(cond, "message")) {
[09:32:37.528]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.528]                         if (muffled) 
[09:32:37.528]                           invokeRestart("muffleMessage")
[09:32:37.528]                       }
[09:32:37.528]                       else if (inherits(cond, "warning")) {
[09:32:37.528]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.528]                         if (muffled) 
[09:32:37.528]                           invokeRestart("muffleWarning")
[09:32:37.528]                       }
[09:32:37.528]                       else if (inherits(cond, "condition")) {
[09:32:37.528]                         if (!is.null(pattern)) {
[09:32:37.528]                           computeRestarts <- base::computeRestarts
[09:32:37.528]                           grepl <- base::grepl
[09:32:37.528]                           restarts <- computeRestarts(cond)
[09:32:37.528]                           for (restart in restarts) {
[09:32:37.528]                             name <- restart$name
[09:32:37.528]                             if (is.null(name)) 
[09:32:37.528]                               next
[09:32:37.528]                             if (!grepl(pattern, name)) 
[09:32:37.528]                               next
[09:32:37.528]                             invokeRestart(restart)
[09:32:37.528]                             muffled <- TRUE
[09:32:37.528]                             break
[09:32:37.528]                           }
[09:32:37.528]                         }
[09:32:37.528]                       }
[09:32:37.528]                       invisible(muffled)
[09:32:37.528]                     }
[09:32:37.528]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.528]                   }
[09:32:37.528]                 }
[09:32:37.528]                 else {
[09:32:37.528]                   if (TRUE) {
[09:32:37.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.528]                     {
[09:32:37.528]                       inherits <- base::inherits
[09:32:37.528]                       invokeRestart <- base::invokeRestart
[09:32:37.528]                       is.null <- base::is.null
[09:32:37.528]                       muffled <- FALSE
[09:32:37.528]                       if (inherits(cond, "message")) {
[09:32:37.528]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.528]                         if (muffled) 
[09:32:37.528]                           invokeRestart("muffleMessage")
[09:32:37.528]                       }
[09:32:37.528]                       else if (inherits(cond, "warning")) {
[09:32:37.528]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.528]                         if (muffled) 
[09:32:37.528]                           invokeRestart("muffleWarning")
[09:32:37.528]                       }
[09:32:37.528]                       else if (inherits(cond, "condition")) {
[09:32:37.528]                         if (!is.null(pattern)) {
[09:32:37.528]                           computeRestarts <- base::computeRestarts
[09:32:37.528]                           grepl <- base::grepl
[09:32:37.528]                           restarts <- computeRestarts(cond)
[09:32:37.528]                           for (restart in restarts) {
[09:32:37.528]                             name <- restart$name
[09:32:37.528]                             if (is.null(name)) 
[09:32:37.528]                               next
[09:32:37.528]                             if (!grepl(pattern, name)) 
[09:32:37.528]                               next
[09:32:37.528]                             invokeRestart(restart)
[09:32:37.528]                             muffled <- TRUE
[09:32:37.528]                             break
[09:32:37.528]                           }
[09:32:37.528]                         }
[09:32:37.528]                       }
[09:32:37.528]                       invisible(muffled)
[09:32:37.528]                     }
[09:32:37.528]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.528]                   }
[09:32:37.528]                 }
[09:32:37.528]             }
[09:32:37.528]         }))
[09:32:37.528]     }, error = function(ex) {
[09:32:37.528]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.528]                 ...future.rng), started = ...future.startTime, 
[09:32:37.528]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.528]             version = "1.8"), class = "FutureResult")
[09:32:37.528]     }, finally = {
[09:32:37.528]         if (!identical(...future.workdir, getwd())) 
[09:32:37.528]             setwd(...future.workdir)
[09:32:37.528]         {
[09:32:37.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.528]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.528]             }
[09:32:37.528]             base::options(...future.oldOptions)
[09:32:37.528]             if (.Platform$OS.type == "windows") {
[09:32:37.528]                 old_names <- names(...future.oldEnvVars)
[09:32:37.528]                 envs <- base::Sys.getenv()
[09:32:37.528]                 names <- names(envs)
[09:32:37.528]                 common <- intersect(names, old_names)
[09:32:37.528]                 added <- setdiff(names, old_names)
[09:32:37.528]                 removed <- setdiff(old_names, names)
[09:32:37.528]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.528]                   envs[common]]
[09:32:37.528]                 NAMES <- toupper(changed)
[09:32:37.528]                 args <- list()
[09:32:37.528]                 for (kk in seq_along(NAMES)) {
[09:32:37.528]                   name <- changed[[kk]]
[09:32:37.528]                   NAME <- NAMES[[kk]]
[09:32:37.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.528]                     next
[09:32:37.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.528]                 }
[09:32:37.528]                 NAMES <- toupper(added)
[09:32:37.528]                 for (kk in seq_along(NAMES)) {
[09:32:37.528]                   name <- added[[kk]]
[09:32:37.528]                   NAME <- NAMES[[kk]]
[09:32:37.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.528]                     next
[09:32:37.528]                   args[[name]] <- ""
[09:32:37.528]                 }
[09:32:37.528]                 NAMES <- toupper(removed)
[09:32:37.528]                 for (kk in seq_along(NAMES)) {
[09:32:37.528]                   name <- removed[[kk]]
[09:32:37.528]                   NAME <- NAMES[[kk]]
[09:32:37.528]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.528]                     next
[09:32:37.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.528]                 }
[09:32:37.528]                 if (length(args) > 0) 
[09:32:37.528]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.528]             }
[09:32:37.528]             else {
[09:32:37.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.528]             }
[09:32:37.528]             {
[09:32:37.528]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.528]                   0L) {
[09:32:37.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.528]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.528]                   base::options(opts)
[09:32:37.528]                 }
[09:32:37.528]                 {
[09:32:37.528]                   {
[09:32:37.528]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.528]                     NULL
[09:32:37.528]                   }
[09:32:37.528]                   options(future.plan = NULL)
[09:32:37.528]                   if (is.na(NA_character_)) 
[09:32:37.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.528]                     .init = FALSE)
[09:32:37.528]                 }
[09:32:37.528]             }
[09:32:37.528]         }
[09:32:37.528]     })
[09:32:37.528]     if (TRUE) {
[09:32:37.528]         base::sink(type = "output", split = FALSE)
[09:32:37.528]         if (TRUE) {
[09:32:37.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.528]         }
[09:32:37.528]         else {
[09:32:37.528]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.528]         }
[09:32:37.528]         base::close(...future.stdout)
[09:32:37.528]         ...future.stdout <- NULL
[09:32:37.528]     }
[09:32:37.528]     ...future.result$conditions <- ...future.conditions
[09:32:37.528]     ...future.result$finished <- base::Sys.time()
[09:32:37.528]     ...future.result
[09:32:37.528] }
[09:32:37.531] MultisessionFuture started
[09:32:37.531] - Launch lazy future ... done
[09:32:37.532] run() for ‘MultisessionFuture’ ... done
[09:32:37.532] getGlobalsAndPackages() ...
[09:32:37.532] Searching for globals...
[09:32:37.533] - globals found: [1] ‘{’
[09:32:37.533] Searching for globals ... DONE
[09:32:37.533] Resolving globals: FALSE
[09:32:37.534] 
[09:32:37.534] 
[09:32:37.534] getGlobalsAndPackages() ... DONE
[09:32:37.534] run() for ‘Future’ ...
[09:32:37.534] - state: ‘created’
[09:32:37.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.548]   - Field: ‘node’
[09:32:37.548]   - Field: ‘label’
[09:32:37.548]   - Field: ‘local’
[09:32:37.548]   - Field: ‘owner’
[09:32:37.548]   - Field: ‘envir’
[09:32:37.548]   - Field: ‘workers’
[09:32:37.549]   - Field: ‘packages’
[09:32:37.549]   - Field: ‘gc’
[09:32:37.549]   - Field: ‘conditions’
[09:32:37.549]   - Field: ‘persistent’
[09:32:37.549]   - Field: ‘expr’
[09:32:37.549]   - Field: ‘uuid’
[09:32:37.549]   - Field: ‘seed’
[09:32:37.549]   - Field: ‘version’
[09:32:37.549]   - Field: ‘result’
[09:32:37.549]   - Field: ‘asynchronous’
[09:32:37.549]   - Field: ‘calls’
[09:32:37.549]   - Field: ‘globals’
[09:32:37.550]   - Field: ‘stdout’
[09:32:37.550]   - Field: ‘earlySignal’
[09:32:37.550]   - Field: ‘lazy’
[09:32:37.550]   - Field: ‘state’
[09:32:37.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.550] - Launch lazy future ...
[09:32:37.550] Packages needed by the future expression (n = 0): <none>
[09:32:37.550] Packages needed by future strategies (n = 0): <none>
[09:32:37.551] {
[09:32:37.551]     {
[09:32:37.551]         {
[09:32:37.551]             ...future.startTime <- base::Sys.time()
[09:32:37.551]             {
[09:32:37.551]                 {
[09:32:37.551]                   {
[09:32:37.551]                     {
[09:32:37.551]                       base::local({
[09:32:37.551]                         has_future <- base::requireNamespace("future", 
[09:32:37.551]                           quietly = TRUE)
[09:32:37.551]                         if (has_future) {
[09:32:37.551]                           ns <- base::getNamespace("future")
[09:32:37.551]                           version <- ns[[".package"]][["version"]]
[09:32:37.551]                           if (is.null(version)) 
[09:32:37.551]                             version <- utils::packageVersion("future")
[09:32:37.551]                         }
[09:32:37.551]                         else {
[09:32:37.551]                           version <- NULL
[09:32:37.551]                         }
[09:32:37.551]                         if (!has_future || version < "1.8.0") {
[09:32:37.551]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.551]                             "", base::R.version$version.string), 
[09:32:37.551]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.551]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.551]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.551]                               "release", "version")], collapse = " "), 
[09:32:37.551]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.551]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.551]                             info)
[09:32:37.551]                           info <- base::paste(info, collapse = "; ")
[09:32:37.551]                           if (!has_future) {
[09:32:37.551]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.551]                               info)
[09:32:37.551]                           }
[09:32:37.551]                           else {
[09:32:37.551]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.551]                               info, version)
[09:32:37.551]                           }
[09:32:37.551]                           base::stop(msg)
[09:32:37.551]                         }
[09:32:37.551]                       })
[09:32:37.551]                     }
[09:32:37.551]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.551]                     base::options(mc.cores = 1L)
[09:32:37.551]                   }
[09:32:37.551]                   ...future.strategy.old <- future::plan("list")
[09:32:37.551]                   options(future.plan = NULL)
[09:32:37.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.551]                 }
[09:32:37.551]                 ...future.workdir <- getwd()
[09:32:37.551]             }
[09:32:37.551]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.551]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.551]         }
[09:32:37.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.551]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.551]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.551]             base::names(...future.oldOptions))
[09:32:37.551]     }
[09:32:37.551]     if (FALSE) {
[09:32:37.551]     }
[09:32:37.551]     else {
[09:32:37.551]         if (TRUE) {
[09:32:37.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.551]                 open = "w")
[09:32:37.551]         }
[09:32:37.551]         else {
[09:32:37.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.551]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.551]         }
[09:32:37.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.551]             base::sink(type = "output", split = FALSE)
[09:32:37.551]             base::close(...future.stdout)
[09:32:37.551]         }, add = TRUE)
[09:32:37.551]     }
[09:32:37.551]     ...future.frame <- base::sys.nframe()
[09:32:37.551]     ...future.conditions <- base::list()
[09:32:37.551]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.551]     if (FALSE) {
[09:32:37.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.551]     }
[09:32:37.551]     ...future.result <- base::tryCatch({
[09:32:37.551]         base::withCallingHandlers({
[09:32:37.551]             ...future.value <- base::withVisible(base::local({
[09:32:37.551]                 ...future.makeSendCondition <- base::local({
[09:32:37.551]                   sendCondition <- NULL
[09:32:37.551]                   function(frame = 1L) {
[09:32:37.551]                     if (is.function(sendCondition)) 
[09:32:37.551]                       return(sendCondition)
[09:32:37.551]                     ns <- getNamespace("parallel")
[09:32:37.551]                     if (exists("sendData", mode = "function", 
[09:32:37.551]                       envir = ns)) {
[09:32:37.551]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.551]                         envir = ns)
[09:32:37.551]                       envir <- sys.frame(frame)
[09:32:37.551]                       master <- NULL
[09:32:37.551]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.551]                         !identical(envir, emptyenv())) {
[09:32:37.551]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.551]                           inherits = FALSE)) {
[09:32:37.551]                           master <- get("master", mode = "list", 
[09:32:37.551]                             envir = envir, inherits = FALSE)
[09:32:37.551]                           if (inherits(master, c("SOCKnode", 
[09:32:37.551]                             "SOCK0node"))) {
[09:32:37.551]                             sendCondition <<- function(cond) {
[09:32:37.551]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.551]                                 success = TRUE)
[09:32:37.551]                               parallel_sendData(master, data)
[09:32:37.551]                             }
[09:32:37.551]                             return(sendCondition)
[09:32:37.551]                           }
[09:32:37.551]                         }
[09:32:37.551]                         frame <- frame + 1L
[09:32:37.551]                         envir <- sys.frame(frame)
[09:32:37.551]                       }
[09:32:37.551]                     }
[09:32:37.551]                     sendCondition <<- function(cond) NULL
[09:32:37.551]                   }
[09:32:37.551]                 })
[09:32:37.551]                 withCallingHandlers({
[09:32:37.551]                   {
[09:32:37.551]                     2
[09:32:37.551]                   }
[09:32:37.551]                 }, immediateCondition = function(cond) {
[09:32:37.551]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.551]                   sendCondition(cond)
[09:32:37.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.551]                   {
[09:32:37.551]                     inherits <- base::inherits
[09:32:37.551]                     invokeRestart <- base::invokeRestart
[09:32:37.551]                     is.null <- base::is.null
[09:32:37.551]                     muffled <- FALSE
[09:32:37.551]                     if (inherits(cond, "message")) {
[09:32:37.551]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.551]                       if (muffled) 
[09:32:37.551]                         invokeRestart("muffleMessage")
[09:32:37.551]                     }
[09:32:37.551]                     else if (inherits(cond, "warning")) {
[09:32:37.551]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.551]                       if (muffled) 
[09:32:37.551]                         invokeRestart("muffleWarning")
[09:32:37.551]                     }
[09:32:37.551]                     else if (inherits(cond, "condition")) {
[09:32:37.551]                       if (!is.null(pattern)) {
[09:32:37.551]                         computeRestarts <- base::computeRestarts
[09:32:37.551]                         grepl <- base::grepl
[09:32:37.551]                         restarts <- computeRestarts(cond)
[09:32:37.551]                         for (restart in restarts) {
[09:32:37.551]                           name <- restart$name
[09:32:37.551]                           if (is.null(name)) 
[09:32:37.551]                             next
[09:32:37.551]                           if (!grepl(pattern, name)) 
[09:32:37.551]                             next
[09:32:37.551]                           invokeRestart(restart)
[09:32:37.551]                           muffled <- TRUE
[09:32:37.551]                           break
[09:32:37.551]                         }
[09:32:37.551]                       }
[09:32:37.551]                     }
[09:32:37.551]                     invisible(muffled)
[09:32:37.551]                   }
[09:32:37.551]                   muffleCondition(cond)
[09:32:37.551]                 })
[09:32:37.551]             }))
[09:32:37.551]             future::FutureResult(value = ...future.value$value, 
[09:32:37.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.551]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.551]                     ...future.globalenv.names))
[09:32:37.551]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.551]         }, condition = base::local({
[09:32:37.551]             c <- base::c
[09:32:37.551]             inherits <- base::inherits
[09:32:37.551]             invokeRestart <- base::invokeRestart
[09:32:37.551]             length <- base::length
[09:32:37.551]             list <- base::list
[09:32:37.551]             seq.int <- base::seq.int
[09:32:37.551]             signalCondition <- base::signalCondition
[09:32:37.551]             sys.calls <- base::sys.calls
[09:32:37.551]             `[[` <- base::`[[`
[09:32:37.551]             `+` <- base::`+`
[09:32:37.551]             `<<-` <- base::`<<-`
[09:32:37.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.551]                   3L)]
[09:32:37.551]             }
[09:32:37.551]             function(cond) {
[09:32:37.551]                 is_error <- inherits(cond, "error")
[09:32:37.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.551]                   NULL)
[09:32:37.551]                 if (is_error) {
[09:32:37.551]                   sessionInformation <- function() {
[09:32:37.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.551]                       search = base::search(), system = base::Sys.info())
[09:32:37.551]                   }
[09:32:37.551]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.551]                     cond$call), session = sessionInformation(), 
[09:32:37.551]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.551]                   signalCondition(cond)
[09:32:37.551]                 }
[09:32:37.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.551]                 "immediateCondition"))) {
[09:32:37.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.551]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.551]                   if (TRUE && !signal) {
[09:32:37.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.551]                     {
[09:32:37.551]                       inherits <- base::inherits
[09:32:37.551]                       invokeRestart <- base::invokeRestart
[09:32:37.551]                       is.null <- base::is.null
[09:32:37.551]                       muffled <- FALSE
[09:32:37.551]                       if (inherits(cond, "message")) {
[09:32:37.551]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.551]                         if (muffled) 
[09:32:37.551]                           invokeRestart("muffleMessage")
[09:32:37.551]                       }
[09:32:37.551]                       else if (inherits(cond, "warning")) {
[09:32:37.551]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.551]                         if (muffled) 
[09:32:37.551]                           invokeRestart("muffleWarning")
[09:32:37.551]                       }
[09:32:37.551]                       else if (inherits(cond, "condition")) {
[09:32:37.551]                         if (!is.null(pattern)) {
[09:32:37.551]                           computeRestarts <- base::computeRestarts
[09:32:37.551]                           grepl <- base::grepl
[09:32:37.551]                           restarts <- computeRestarts(cond)
[09:32:37.551]                           for (restart in restarts) {
[09:32:37.551]                             name <- restart$name
[09:32:37.551]                             if (is.null(name)) 
[09:32:37.551]                               next
[09:32:37.551]                             if (!grepl(pattern, name)) 
[09:32:37.551]                               next
[09:32:37.551]                             invokeRestart(restart)
[09:32:37.551]                             muffled <- TRUE
[09:32:37.551]                             break
[09:32:37.551]                           }
[09:32:37.551]                         }
[09:32:37.551]                       }
[09:32:37.551]                       invisible(muffled)
[09:32:37.551]                     }
[09:32:37.551]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.551]                   }
[09:32:37.551]                 }
[09:32:37.551]                 else {
[09:32:37.551]                   if (TRUE) {
[09:32:37.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.551]                     {
[09:32:37.551]                       inherits <- base::inherits
[09:32:37.551]                       invokeRestart <- base::invokeRestart
[09:32:37.551]                       is.null <- base::is.null
[09:32:37.551]                       muffled <- FALSE
[09:32:37.551]                       if (inherits(cond, "message")) {
[09:32:37.551]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.551]                         if (muffled) 
[09:32:37.551]                           invokeRestart("muffleMessage")
[09:32:37.551]                       }
[09:32:37.551]                       else if (inherits(cond, "warning")) {
[09:32:37.551]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.551]                         if (muffled) 
[09:32:37.551]                           invokeRestart("muffleWarning")
[09:32:37.551]                       }
[09:32:37.551]                       else if (inherits(cond, "condition")) {
[09:32:37.551]                         if (!is.null(pattern)) {
[09:32:37.551]                           computeRestarts <- base::computeRestarts
[09:32:37.551]                           grepl <- base::grepl
[09:32:37.551]                           restarts <- computeRestarts(cond)
[09:32:37.551]                           for (restart in restarts) {
[09:32:37.551]                             name <- restart$name
[09:32:37.551]                             if (is.null(name)) 
[09:32:37.551]                               next
[09:32:37.551]                             if (!grepl(pattern, name)) 
[09:32:37.551]                               next
[09:32:37.551]                             invokeRestart(restart)
[09:32:37.551]                             muffled <- TRUE
[09:32:37.551]                             break
[09:32:37.551]                           }
[09:32:37.551]                         }
[09:32:37.551]                       }
[09:32:37.551]                       invisible(muffled)
[09:32:37.551]                     }
[09:32:37.551]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.551]                   }
[09:32:37.551]                 }
[09:32:37.551]             }
[09:32:37.551]         }))
[09:32:37.551]     }, error = function(ex) {
[09:32:37.551]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.551]                 ...future.rng), started = ...future.startTime, 
[09:32:37.551]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.551]             version = "1.8"), class = "FutureResult")
[09:32:37.551]     }, finally = {
[09:32:37.551]         if (!identical(...future.workdir, getwd())) 
[09:32:37.551]             setwd(...future.workdir)
[09:32:37.551]         {
[09:32:37.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.551]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.551]             }
[09:32:37.551]             base::options(...future.oldOptions)
[09:32:37.551]             if (.Platform$OS.type == "windows") {
[09:32:37.551]                 old_names <- names(...future.oldEnvVars)
[09:32:37.551]                 envs <- base::Sys.getenv()
[09:32:37.551]                 names <- names(envs)
[09:32:37.551]                 common <- intersect(names, old_names)
[09:32:37.551]                 added <- setdiff(names, old_names)
[09:32:37.551]                 removed <- setdiff(old_names, names)
[09:32:37.551]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.551]                   envs[common]]
[09:32:37.551]                 NAMES <- toupper(changed)
[09:32:37.551]                 args <- list()
[09:32:37.551]                 for (kk in seq_along(NAMES)) {
[09:32:37.551]                   name <- changed[[kk]]
[09:32:37.551]                   NAME <- NAMES[[kk]]
[09:32:37.551]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.551]                     next
[09:32:37.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.551]                 }
[09:32:37.551]                 NAMES <- toupper(added)
[09:32:37.551]                 for (kk in seq_along(NAMES)) {
[09:32:37.551]                   name <- added[[kk]]
[09:32:37.551]                   NAME <- NAMES[[kk]]
[09:32:37.551]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.551]                     next
[09:32:37.551]                   args[[name]] <- ""
[09:32:37.551]                 }
[09:32:37.551]                 NAMES <- toupper(removed)
[09:32:37.551]                 for (kk in seq_along(NAMES)) {
[09:32:37.551]                   name <- removed[[kk]]
[09:32:37.551]                   NAME <- NAMES[[kk]]
[09:32:37.551]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.551]                     next
[09:32:37.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.551]                 }
[09:32:37.551]                 if (length(args) > 0) 
[09:32:37.551]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.551]             }
[09:32:37.551]             else {
[09:32:37.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.551]             }
[09:32:37.551]             {
[09:32:37.551]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.551]                   0L) {
[09:32:37.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.551]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.551]                   base::options(opts)
[09:32:37.551]                 }
[09:32:37.551]                 {
[09:32:37.551]                   {
[09:32:37.551]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.551]                     NULL
[09:32:37.551]                   }
[09:32:37.551]                   options(future.plan = NULL)
[09:32:37.551]                   if (is.na(NA_character_)) 
[09:32:37.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.551]                     .init = FALSE)
[09:32:37.551]                 }
[09:32:37.551]             }
[09:32:37.551]         }
[09:32:37.551]     })
[09:32:37.551]     if (TRUE) {
[09:32:37.551]         base::sink(type = "output", split = FALSE)
[09:32:37.551]         if (TRUE) {
[09:32:37.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.551]         }
[09:32:37.551]         else {
[09:32:37.551]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.551]         }
[09:32:37.551]         base::close(...future.stdout)
[09:32:37.551]         ...future.stdout <- NULL
[09:32:37.551]     }
[09:32:37.551]     ...future.result$conditions <- ...future.conditions
[09:32:37.551]     ...future.result$finished <- base::Sys.time()
[09:32:37.551]     ...future.result
[09:32:37.551] }
[09:32:37.554] MultisessionFuture started
[09:32:37.554] - Launch lazy future ... done
[09:32:37.554] run() for ‘MultisessionFuture’ ... done
[09:32:37.554] resolve() on environment ...
[09:32:37.555]  recursive: 0
[09:32:37.555]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:37.555] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.556] - Validating connection of MultisessionFuture
[09:32:37.556] - received message: FutureResult
[09:32:37.556] - Received FutureResult
[09:32:37.556] - Erased future from FutureRegistry
[09:32:37.556] result() for ClusterFuture ...
[09:32:37.556] - result already collected: FutureResult
[09:32:37.556] result() for ClusterFuture ... done
[09:32:37.556] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.556] Future #1
[09:32:37.557]  length: 2 (resolved future 1)
[09:32:37.557] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.560] - Validating connection of MultisessionFuture
[09:32:37.560] - received message: FutureResult
[09:32:37.560] - Received FutureResult
[09:32:37.560] - Erased future from FutureRegistry
[09:32:37.561] result() for ClusterFuture ...
[09:32:37.561] - result already collected: FutureResult
[09:32:37.561] result() for ClusterFuture ... done
[09:32:37.561] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.561] Future #2
[09:32:37.561]  length: 1 (resolved future 2)
[09:32:37.561]  length: 0 (resolved future 3)
[09:32:37.561] resolve() on environment ... DONE
[09:32:37.562] getGlobalsAndPackages() ...
[09:32:37.562] Searching for globals...
[09:32:37.563] - globals found: [1] ‘{’
[09:32:37.563] Searching for globals ... DONE
[09:32:37.563] Resolving globals: FALSE
[09:32:37.563] 
[09:32:37.563] 
[09:32:37.563] getGlobalsAndPackages() ... DONE
[09:32:37.563] run() for ‘Future’ ...
[09:32:37.563] - state: ‘created’
[09:32:37.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.577]   - Field: ‘node’
[09:32:37.577]   - Field: ‘label’
[09:32:37.577]   - Field: ‘local’
[09:32:37.577]   - Field: ‘owner’
[09:32:37.577]   - Field: ‘envir’
[09:32:37.577]   - Field: ‘workers’
[09:32:37.578]   - Field: ‘packages’
[09:32:37.578]   - Field: ‘gc’
[09:32:37.578]   - Field: ‘conditions’
[09:32:37.578]   - Field: ‘persistent’
[09:32:37.578]   - Field: ‘expr’
[09:32:37.578]   - Field: ‘uuid’
[09:32:37.578]   - Field: ‘seed’
[09:32:37.578]   - Field: ‘version’
[09:32:37.578]   - Field: ‘result’
[09:32:37.578]   - Field: ‘asynchronous’
[09:32:37.578]   - Field: ‘calls’
[09:32:37.579]   - Field: ‘globals’
[09:32:37.579]   - Field: ‘stdout’
[09:32:37.579]   - Field: ‘earlySignal’
[09:32:37.579]   - Field: ‘lazy’
[09:32:37.579]   - Field: ‘state’
[09:32:37.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.579] - Launch lazy future ...
[09:32:37.579] Packages needed by the future expression (n = 0): <none>
[09:32:37.579] Packages needed by future strategies (n = 0): <none>
[09:32:37.580] {
[09:32:37.580]     {
[09:32:37.580]         {
[09:32:37.580]             ...future.startTime <- base::Sys.time()
[09:32:37.580]             {
[09:32:37.580]                 {
[09:32:37.580]                   {
[09:32:37.580]                     {
[09:32:37.580]                       base::local({
[09:32:37.580]                         has_future <- base::requireNamespace("future", 
[09:32:37.580]                           quietly = TRUE)
[09:32:37.580]                         if (has_future) {
[09:32:37.580]                           ns <- base::getNamespace("future")
[09:32:37.580]                           version <- ns[[".package"]][["version"]]
[09:32:37.580]                           if (is.null(version)) 
[09:32:37.580]                             version <- utils::packageVersion("future")
[09:32:37.580]                         }
[09:32:37.580]                         else {
[09:32:37.580]                           version <- NULL
[09:32:37.580]                         }
[09:32:37.580]                         if (!has_future || version < "1.8.0") {
[09:32:37.580]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.580]                             "", base::R.version$version.string), 
[09:32:37.580]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.580]                               "release", "version")], collapse = " "), 
[09:32:37.580]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.580]                             info)
[09:32:37.580]                           info <- base::paste(info, collapse = "; ")
[09:32:37.580]                           if (!has_future) {
[09:32:37.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.580]                               info)
[09:32:37.580]                           }
[09:32:37.580]                           else {
[09:32:37.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.580]                               info, version)
[09:32:37.580]                           }
[09:32:37.580]                           base::stop(msg)
[09:32:37.580]                         }
[09:32:37.580]                       })
[09:32:37.580]                     }
[09:32:37.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.580]                     base::options(mc.cores = 1L)
[09:32:37.580]                   }
[09:32:37.580]                   ...future.strategy.old <- future::plan("list")
[09:32:37.580]                   options(future.plan = NULL)
[09:32:37.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.580]                 }
[09:32:37.580]                 ...future.workdir <- getwd()
[09:32:37.580]             }
[09:32:37.580]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.580]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.580]         }
[09:32:37.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.580]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.580]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.580]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.580]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.580]             base::names(...future.oldOptions))
[09:32:37.580]     }
[09:32:37.580]     if (FALSE) {
[09:32:37.580]     }
[09:32:37.580]     else {
[09:32:37.580]         if (TRUE) {
[09:32:37.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.580]                 open = "w")
[09:32:37.580]         }
[09:32:37.580]         else {
[09:32:37.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.580]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.580]         }
[09:32:37.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.580]             base::sink(type = "output", split = FALSE)
[09:32:37.580]             base::close(...future.stdout)
[09:32:37.580]         }, add = TRUE)
[09:32:37.580]     }
[09:32:37.580]     ...future.frame <- base::sys.nframe()
[09:32:37.580]     ...future.conditions <- base::list()
[09:32:37.580]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.580]     if (FALSE) {
[09:32:37.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.580]     }
[09:32:37.580]     ...future.result <- base::tryCatch({
[09:32:37.580]         base::withCallingHandlers({
[09:32:37.580]             ...future.value <- base::withVisible(base::local({
[09:32:37.580]                 ...future.makeSendCondition <- base::local({
[09:32:37.580]                   sendCondition <- NULL
[09:32:37.580]                   function(frame = 1L) {
[09:32:37.580]                     if (is.function(sendCondition)) 
[09:32:37.580]                       return(sendCondition)
[09:32:37.580]                     ns <- getNamespace("parallel")
[09:32:37.580]                     if (exists("sendData", mode = "function", 
[09:32:37.580]                       envir = ns)) {
[09:32:37.580]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.580]                         envir = ns)
[09:32:37.580]                       envir <- sys.frame(frame)
[09:32:37.580]                       master <- NULL
[09:32:37.580]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.580]                         !identical(envir, emptyenv())) {
[09:32:37.580]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.580]                           inherits = FALSE)) {
[09:32:37.580]                           master <- get("master", mode = "list", 
[09:32:37.580]                             envir = envir, inherits = FALSE)
[09:32:37.580]                           if (inherits(master, c("SOCKnode", 
[09:32:37.580]                             "SOCK0node"))) {
[09:32:37.580]                             sendCondition <<- function(cond) {
[09:32:37.580]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.580]                                 success = TRUE)
[09:32:37.580]                               parallel_sendData(master, data)
[09:32:37.580]                             }
[09:32:37.580]                             return(sendCondition)
[09:32:37.580]                           }
[09:32:37.580]                         }
[09:32:37.580]                         frame <- frame + 1L
[09:32:37.580]                         envir <- sys.frame(frame)
[09:32:37.580]                       }
[09:32:37.580]                     }
[09:32:37.580]                     sendCondition <<- function(cond) NULL
[09:32:37.580]                   }
[09:32:37.580]                 })
[09:32:37.580]                 withCallingHandlers({
[09:32:37.580]                   {
[09:32:37.580]                     1
[09:32:37.580]                   }
[09:32:37.580]                 }, immediateCondition = function(cond) {
[09:32:37.580]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.580]                   sendCondition(cond)
[09:32:37.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.580]                   {
[09:32:37.580]                     inherits <- base::inherits
[09:32:37.580]                     invokeRestart <- base::invokeRestart
[09:32:37.580]                     is.null <- base::is.null
[09:32:37.580]                     muffled <- FALSE
[09:32:37.580]                     if (inherits(cond, "message")) {
[09:32:37.580]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.580]                       if (muffled) 
[09:32:37.580]                         invokeRestart("muffleMessage")
[09:32:37.580]                     }
[09:32:37.580]                     else if (inherits(cond, "warning")) {
[09:32:37.580]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.580]                       if (muffled) 
[09:32:37.580]                         invokeRestart("muffleWarning")
[09:32:37.580]                     }
[09:32:37.580]                     else if (inherits(cond, "condition")) {
[09:32:37.580]                       if (!is.null(pattern)) {
[09:32:37.580]                         computeRestarts <- base::computeRestarts
[09:32:37.580]                         grepl <- base::grepl
[09:32:37.580]                         restarts <- computeRestarts(cond)
[09:32:37.580]                         for (restart in restarts) {
[09:32:37.580]                           name <- restart$name
[09:32:37.580]                           if (is.null(name)) 
[09:32:37.580]                             next
[09:32:37.580]                           if (!grepl(pattern, name)) 
[09:32:37.580]                             next
[09:32:37.580]                           invokeRestart(restart)
[09:32:37.580]                           muffled <- TRUE
[09:32:37.580]                           break
[09:32:37.580]                         }
[09:32:37.580]                       }
[09:32:37.580]                     }
[09:32:37.580]                     invisible(muffled)
[09:32:37.580]                   }
[09:32:37.580]                   muffleCondition(cond)
[09:32:37.580]                 })
[09:32:37.580]             }))
[09:32:37.580]             future::FutureResult(value = ...future.value$value, 
[09:32:37.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.580]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.580]                     ...future.globalenv.names))
[09:32:37.580]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.580]         }, condition = base::local({
[09:32:37.580]             c <- base::c
[09:32:37.580]             inherits <- base::inherits
[09:32:37.580]             invokeRestart <- base::invokeRestart
[09:32:37.580]             length <- base::length
[09:32:37.580]             list <- base::list
[09:32:37.580]             seq.int <- base::seq.int
[09:32:37.580]             signalCondition <- base::signalCondition
[09:32:37.580]             sys.calls <- base::sys.calls
[09:32:37.580]             `[[` <- base::`[[`
[09:32:37.580]             `+` <- base::`+`
[09:32:37.580]             `<<-` <- base::`<<-`
[09:32:37.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.580]                   3L)]
[09:32:37.580]             }
[09:32:37.580]             function(cond) {
[09:32:37.580]                 is_error <- inherits(cond, "error")
[09:32:37.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.580]                   NULL)
[09:32:37.580]                 if (is_error) {
[09:32:37.580]                   sessionInformation <- function() {
[09:32:37.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.580]                       search = base::search(), system = base::Sys.info())
[09:32:37.580]                   }
[09:32:37.580]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.580]                     cond$call), session = sessionInformation(), 
[09:32:37.580]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.580]                   signalCondition(cond)
[09:32:37.580]                 }
[09:32:37.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.580]                 "immediateCondition"))) {
[09:32:37.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.580]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.580]                   if (TRUE && !signal) {
[09:32:37.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.580]                     {
[09:32:37.580]                       inherits <- base::inherits
[09:32:37.580]                       invokeRestart <- base::invokeRestart
[09:32:37.580]                       is.null <- base::is.null
[09:32:37.580]                       muffled <- FALSE
[09:32:37.580]                       if (inherits(cond, "message")) {
[09:32:37.580]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.580]                         if (muffled) 
[09:32:37.580]                           invokeRestart("muffleMessage")
[09:32:37.580]                       }
[09:32:37.580]                       else if (inherits(cond, "warning")) {
[09:32:37.580]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.580]                         if (muffled) 
[09:32:37.580]                           invokeRestart("muffleWarning")
[09:32:37.580]                       }
[09:32:37.580]                       else if (inherits(cond, "condition")) {
[09:32:37.580]                         if (!is.null(pattern)) {
[09:32:37.580]                           computeRestarts <- base::computeRestarts
[09:32:37.580]                           grepl <- base::grepl
[09:32:37.580]                           restarts <- computeRestarts(cond)
[09:32:37.580]                           for (restart in restarts) {
[09:32:37.580]                             name <- restart$name
[09:32:37.580]                             if (is.null(name)) 
[09:32:37.580]                               next
[09:32:37.580]                             if (!grepl(pattern, name)) 
[09:32:37.580]                               next
[09:32:37.580]                             invokeRestart(restart)
[09:32:37.580]                             muffled <- TRUE
[09:32:37.580]                             break
[09:32:37.580]                           }
[09:32:37.580]                         }
[09:32:37.580]                       }
[09:32:37.580]                       invisible(muffled)
[09:32:37.580]                     }
[09:32:37.580]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.580]                   }
[09:32:37.580]                 }
[09:32:37.580]                 else {
[09:32:37.580]                   if (TRUE) {
[09:32:37.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.580]                     {
[09:32:37.580]                       inherits <- base::inherits
[09:32:37.580]                       invokeRestart <- base::invokeRestart
[09:32:37.580]                       is.null <- base::is.null
[09:32:37.580]                       muffled <- FALSE
[09:32:37.580]                       if (inherits(cond, "message")) {
[09:32:37.580]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.580]                         if (muffled) 
[09:32:37.580]                           invokeRestart("muffleMessage")
[09:32:37.580]                       }
[09:32:37.580]                       else if (inherits(cond, "warning")) {
[09:32:37.580]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.580]                         if (muffled) 
[09:32:37.580]                           invokeRestart("muffleWarning")
[09:32:37.580]                       }
[09:32:37.580]                       else if (inherits(cond, "condition")) {
[09:32:37.580]                         if (!is.null(pattern)) {
[09:32:37.580]                           computeRestarts <- base::computeRestarts
[09:32:37.580]                           grepl <- base::grepl
[09:32:37.580]                           restarts <- computeRestarts(cond)
[09:32:37.580]                           for (restart in restarts) {
[09:32:37.580]                             name <- restart$name
[09:32:37.580]                             if (is.null(name)) 
[09:32:37.580]                               next
[09:32:37.580]                             if (!grepl(pattern, name)) 
[09:32:37.580]                               next
[09:32:37.580]                             invokeRestart(restart)
[09:32:37.580]                             muffled <- TRUE
[09:32:37.580]                             break
[09:32:37.580]                           }
[09:32:37.580]                         }
[09:32:37.580]                       }
[09:32:37.580]                       invisible(muffled)
[09:32:37.580]                     }
[09:32:37.580]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.580]                   }
[09:32:37.580]                 }
[09:32:37.580]             }
[09:32:37.580]         }))
[09:32:37.580]     }, error = function(ex) {
[09:32:37.580]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.580]                 ...future.rng), started = ...future.startTime, 
[09:32:37.580]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.580]             version = "1.8"), class = "FutureResult")
[09:32:37.580]     }, finally = {
[09:32:37.580]         if (!identical(...future.workdir, getwd())) 
[09:32:37.580]             setwd(...future.workdir)
[09:32:37.580]         {
[09:32:37.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.580]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.580]             }
[09:32:37.580]             base::options(...future.oldOptions)
[09:32:37.580]             if (.Platform$OS.type == "windows") {
[09:32:37.580]                 old_names <- names(...future.oldEnvVars)
[09:32:37.580]                 envs <- base::Sys.getenv()
[09:32:37.580]                 names <- names(envs)
[09:32:37.580]                 common <- intersect(names, old_names)
[09:32:37.580]                 added <- setdiff(names, old_names)
[09:32:37.580]                 removed <- setdiff(old_names, names)
[09:32:37.580]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.580]                   envs[common]]
[09:32:37.580]                 NAMES <- toupper(changed)
[09:32:37.580]                 args <- list()
[09:32:37.580]                 for (kk in seq_along(NAMES)) {
[09:32:37.580]                   name <- changed[[kk]]
[09:32:37.580]                   NAME <- NAMES[[kk]]
[09:32:37.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.580]                     next
[09:32:37.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.580]                 }
[09:32:37.580]                 NAMES <- toupper(added)
[09:32:37.580]                 for (kk in seq_along(NAMES)) {
[09:32:37.580]                   name <- added[[kk]]
[09:32:37.580]                   NAME <- NAMES[[kk]]
[09:32:37.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.580]                     next
[09:32:37.580]                   args[[name]] <- ""
[09:32:37.580]                 }
[09:32:37.580]                 NAMES <- toupper(removed)
[09:32:37.580]                 for (kk in seq_along(NAMES)) {
[09:32:37.580]                   name <- removed[[kk]]
[09:32:37.580]                   NAME <- NAMES[[kk]]
[09:32:37.580]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.580]                     next
[09:32:37.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.580]                 }
[09:32:37.580]                 if (length(args) > 0) 
[09:32:37.580]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.580]             }
[09:32:37.580]             else {
[09:32:37.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.580]             }
[09:32:37.580]             {
[09:32:37.580]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.580]                   0L) {
[09:32:37.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.580]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.580]                   base::options(opts)
[09:32:37.580]                 }
[09:32:37.580]                 {
[09:32:37.580]                   {
[09:32:37.580]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.580]                     NULL
[09:32:37.580]                   }
[09:32:37.580]                   options(future.plan = NULL)
[09:32:37.580]                   if (is.na(NA_character_)) 
[09:32:37.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.580]                     .init = FALSE)
[09:32:37.580]                 }
[09:32:37.580]             }
[09:32:37.580]         }
[09:32:37.580]     })
[09:32:37.580]     if (TRUE) {
[09:32:37.580]         base::sink(type = "output", split = FALSE)
[09:32:37.580]         if (TRUE) {
[09:32:37.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.580]         }
[09:32:37.580]         else {
[09:32:37.580]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.580]         }
[09:32:37.580]         base::close(...future.stdout)
[09:32:37.580]         ...future.stdout <- NULL
[09:32:37.580]     }
[09:32:37.580]     ...future.result$conditions <- ...future.conditions
[09:32:37.580]     ...future.result$finished <- base::Sys.time()
[09:32:37.580]     ...future.result
[09:32:37.580] }
[09:32:37.583] MultisessionFuture started
[09:32:37.583] - Launch lazy future ... done
[09:32:37.583] run() for ‘MultisessionFuture’ ... done
[09:32:37.583] getGlobalsAndPackages() ...
[09:32:37.584] Searching for globals...
[09:32:37.584] - globals found: [1] ‘{’
[09:32:37.585] Searching for globals ... DONE
[09:32:37.585] Resolving globals: FALSE
[09:32:37.585] 
[09:32:37.585] 
[09:32:37.585] getGlobalsAndPackages() ... DONE
[09:32:37.586] run() for ‘Future’ ...
[09:32:37.586] - state: ‘created’
[09:32:37.586] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.599]   - Field: ‘node’
[09:32:37.599]   - Field: ‘label’
[09:32:37.599]   - Field: ‘local’
[09:32:37.599]   - Field: ‘owner’
[09:32:37.599]   - Field: ‘envir’
[09:32:37.599]   - Field: ‘workers’
[09:32:37.600]   - Field: ‘packages’
[09:32:37.600]   - Field: ‘gc’
[09:32:37.600]   - Field: ‘conditions’
[09:32:37.600]   - Field: ‘persistent’
[09:32:37.600]   - Field: ‘expr’
[09:32:37.600]   - Field: ‘uuid’
[09:32:37.600]   - Field: ‘seed’
[09:32:37.600]   - Field: ‘version’
[09:32:37.600]   - Field: ‘result’
[09:32:37.600]   - Field: ‘asynchronous’
[09:32:37.600]   - Field: ‘calls’
[09:32:37.601]   - Field: ‘globals’
[09:32:37.601]   - Field: ‘stdout’
[09:32:37.601]   - Field: ‘earlySignal’
[09:32:37.601]   - Field: ‘lazy’
[09:32:37.601]   - Field: ‘state’
[09:32:37.601] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.601] - Launch lazy future ...
[09:32:37.601] Packages needed by the future expression (n = 0): <none>
[09:32:37.601] Packages needed by future strategies (n = 0): <none>
[09:32:37.602] {
[09:32:37.602]     {
[09:32:37.602]         {
[09:32:37.602]             ...future.startTime <- base::Sys.time()
[09:32:37.602]             {
[09:32:37.602]                 {
[09:32:37.602]                   {
[09:32:37.602]                     {
[09:32:37.602]                       base::local({
[09:32:37.602]                         has_future <- base::requireNamespace("future", 
[09:32:37.602]                           quietly = TRUE)
[09:32:37.602]                         if (has_future) {
[09:32:37.602]                           ns <- base::getNamespace("future")
[09:32:37.602]                           version <- ns[[".package"]][["version"]]
[09:32:37.602]                           if (is.null(version)) 
[09:32:37.602]                             version <- utils::packageVersion("future")
[09:32:37.602]                         }
[09:32:37.602]                         else {
[09:32:37.602]                           version <- NULL
[09:32:37.602]                         }
[09:32:37.602]                         if (!has_future || version < "1.8.0") {
[09:32:37.602]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.602]                             "", base::R.version$version.string), 
[09:32:37.602]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.602]                               "release", "version")], collapse = " "), 
[09:32:37.602]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.602]                             info)
[09:32:37.602]                           info <- base::paste(info, collapse = "; ")
[09:32:37.602]                           if (!has_future) {
[09:32:37.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.602]                               info)
[09:32:37.602]                           }
[09:32:37.602]                           else {
[09:32:37.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.602]                               info, version)
[09:32:37.602]                           }
[09:32:37.602]                           base::stop(msg)
[09:32:37.602]                         }
[09:32:37.602]                       })
[09:32:37.602]                     }
[09:32:37.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.602]                     base::options(mc.cores = 1L)
[09:32:37.602]                   }
[09:32:37.602]                   ...future.strategy.old <- future::plan("list")
[09:32:37.602]                   options(future.plan = NULL)
[09:32:37.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.602]                 }
[09:32:37.602]                 ...future.workdir <- getwd()
[09:32:37.602]             }
[09:32:37.602]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.602]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.602]         }
[09:32:37.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.602]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.602]             base::names(...future.oldOptions))
[09:32:37.602]     }
[09:32:37.602]     if (FALSE) {
[09:32:37.602]     }
[09:32:37.602]     else {
[09:32:37.602]         if (TRUE) {
[09:32:37.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.602]                 open = "w")
[09:32:37.602]         }
[09:32:37.602]         else {
[09:32:37.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.602]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.602]         }
[09:32:37.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.602]             base::sink(type = "output", split = FALSE)
[09:32:37.602]             base::close(...future.stdout)
[09:32:37.602]         }, add = TRUE)
[09:32:37.602]     }
[09:32:37.602]     ...future.frame <- base::sys.nframe()
[09:32:37.602]     ...future.conditions <- base::list()
[09:32:37.602]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.602]     if (FALSE) {
[09:32:37.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.602]     }
[09:32:37.602]     ...future.result <- base::tryCatch({
[09:32:37.602]         base::withCallingHandlers({
[09:32:37.602]             ...future.value <- base::withVisible(base::local({
[09:32:37.602]                 ...future.makeSendCondition <- base::local({
[09:32:37.602]                   sendCondition <- NULL
[09:32:37.602]                   function(frame = 1L) {
[09:32:37.602]                     if (is.function(sendCondition)) 
[09:32:37.602]                       return(sendCondition)
[09:32:37.602]                     ns <- getNamespace("parallel")
[09:32:37.602]                     if (exists("sendData", mode = "function", 
[09:32:37.602]                       envir = ns)) {
[09:32:37.602]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.602]                         envir = ns)
[09:32:37.602]                       envir <- sys.frame(frame)
[09:32:37.602]                       master <- NULL
[09:32:37.602]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.602]                         !identical(envir, emptyenv())) {
[09:32:37.602]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.602]                           inherits = FALSE)) {
[09:32:37.602]                           master <- get("master", mode = "list", 
[09:32:37.602]                             envir = envir, inherits = FALSE)
[09:32:37.602]                           if (inherits(master, c("SOCKnode", 
[09:32:37.602]                             "SOCK0node"))) {
[09:32:37.602]                             sendCondition <<- function(cond) {
[09:32:37.602]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.602]                                 success = TRUE)
[09:32:37.602]                               parallel_sendData(master, data)
[09:32:37.602]                             }
[09:32:37.602]                             return(sendCondition)
[09:32:37.602]                           }
[09:32:37.602]                         }
[09:32:37.602]                         frame <- frame + 1L
[09:32:37.602]                         envir <- sys.frame(frame)
[09:32:37.602]                       }
[09:32:37.602]                     }
[09:32:37.602]                     sendCondition <<- function(cond) NULL
[09:32:37.602]                   }
[09:32:37.602]                 })
[09:32:37.602]                 withCallingHandlers({
[09:32:37.602]                   {
[09:32:37.602]                     2
[09:32:37.602]                   }
[09:32:37.602]                 }, immediateCondition = function(cond) {
[09:32:37.602]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.602]                   sendCondition(cond)
[09:32:37.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.602]                   {
[09:32:37.602]                     inherits <- base::inherits
[09:32:37.602]                     invokeRestart <- base::invokeRestart
[09:32:37.602]                     is.null <- base::is.null
[09:32:37.602]                     muffled <- FALSE
[09:32:37.602]                     if (inherits(cond, "message")) {
[09:32:37.602]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.602]                       if (muffled) 
[09:32:37.602]                         invokeRestart("muffleMessage")
[09:32:37.602]                     }
[09:32:37.602]                     else if (inherits(cond, "warning")) {
[09:32:37.602]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.602]                       if (muffled) 
[09:32:37.602]                         invokeRestart("muffleWarning")
[09:32:37.602]                     }
[09:32:37.602]                     else if (inherits(cond, "condition")) {
[09:32:37.602]                       if (!is.null(pattern)) {
[09:32:37.602]                         computeRestarts <- base::computeRestarts
[09:32:37.602]                         grepl <- base::grepl
[09:32:37.602]                         restarts <- computeRestarts(cond)
[09:32:37.602]                         for (restart in restarts) {
[09:32:37.602]                           name <- restart$name
[09:32:37.602]                           if (is.null(name)) 
[09:32:37.602]                             next
[09:32:37.602]                           if (!grepl(pattern, name)) 
[09:32:37.602]                             next
[09:32:37.602]                           invokeRestart(restart)
[09:32:37.602]                           muffled <- TRUE
[09:32:37.602]                           break
[09:32:37.602]                         }
[09:32:37.602]                       }
[09:32:37.602]                     }
[09:32:37.602]                     invisible(muffled)
[09:32:37.602]                   }
[09:32:37.602]                   muffleCondition(cond)
[09:32:37.602]                 })
[09:32:37.602]             }))
[09:32:37.602]             future::FutureResult(value = ...future.value$value, 
[09:32:37.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.602]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.602]                     ...future.globalenv.names))
[09:32:37.602]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.602]         }, condition = base::local({
[09:32:37.602]             c <- base::c
[09:32:37.602]             inherits <- base::inherits
[09:32:37.602]             invokeRestart <- base::invokeRestart
[09:32:37.602]             length <- base::length
[09:32:37.602]             list <- base::list
[09:32:37.602]             seq.int <- base::seq.int
[09:32:37.602]             signalCondition <- base::signalCondition
[09:32:37.602]             sys.calls <- base::sys.calls
[09:32:37.602]             `[[` <- base::`[[`
[09:32:37.602]             `+` <- base::`+`
[09:32:37.602]             `<<-` <- base::`<<-`
[09:32:37.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.602]                   3L)]
[09:32:37.602]             }
[09:32:37.602]             function(cond) {
[09:32:37.602]                 is_error <- inherits(cond, "error")
[09:32:37.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.602]                   NULL)
[09:32:37.602]                 if (is_error) {
[09:32:37.602]                   sessionInformation <- function() {
[09:32:37.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.602]                       search = base::search(), system = base::Sys.info())
[09:32:37.602]                   }
[09:32:37.602]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.602]                     cond$call), session = sessionInformation(), 
[09:32:37.602]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.602]                   signalCondition(cond)
[09:32:37.602]                 }
[09:32:37.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.602]                 "immediateCondition"))) {
[09:32:37.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.602]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.602]                   if (TRUE && !signal) {
[09:32:37.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.602]                     {
[09:32:37.602]                       inherits <- base::inherits
[09:32:37.602]                       invokeRestart <- base::invokeRestart
[09:32:37.602]                       is.null <- base::is.null
[09:32:37.602]                       muffled <- FALSE
[09:32:37.602]                       if (inherits(cond, "message")) {
[09:32:37.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.602]                         if (muffled) 
[09:32:37.602]                           invokeRestart("muffleMessage")
[09:32:37.602]                       }
[09:32:37.602]                       else if (inherits(cond, "warning")) {
[09:32:37.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.602]                         if (muffled) 
[09:32:37.602]                           invokeRestart("muffleWarning")
[09:32:37.602]                       }
[09:32:37.602]                       else if (inherits(cond, "condition")) {
[09:32:37.602]                         if (!is.null(pattern)) {
[09:32:37.602]                           computeRestarts <- base::computeRestarts
[09:32:37.602]                           grepl <- base::grepl
[09:32:37.602]                           restarts <- computeRestarts(cond)
[09:32:37.602]                           for (restart in restarts) {
[09:32:37.602]                             name <- restart$name
[09:32:37.602]                             if (is.null(name)) 
[09:32:37.602]                               next
[09:32:37.602]                             if (!grepl(pattern, name)) 
[09:32:37.602]                               next
[09:32:37.602]                             invokeRestart(restart)
[09:32:37.602]                             muffled <- TRUE
[09:32:37.602]                             break
[09:32:37.602]                           }
[09:32:37.602]                         }
[09:32:37.602]                       }
[09:32:37.602]                       invisible(muffled)
[09:32:37.602]                     }
[09:32:37.602]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.602]                   }
[09:32:37.602]                 }
[09:32:37.602]                 else {
[09:32:37.602]                   if (TRUE) {
[09:32:37.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.602]                     {
[09:32:37.602]                       inherits <- base::inherits
[09:32:37.602]                       invokeRestart <- base::invokeRestart
[09:32:37.602]                       is.null <- base::is.null
[09:32:37.602]                       muffled <- FALSE
[09:32:37.602]                       if (inherits(cond, "message")) {
[09:32:37.602]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.602]                         if (muffled) 
[09:32:37.602]                           invokeRestart("muffleMessage")
[09:32:37.602]                       }
[09:32:37.602]                       else if (inherits(cond, "warning")) {
[09:32:37.602]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.602]                         if (muffled) 
[09:32:37.602]                           invokeRestart("muffleWarning")
[09:32:37.602]                       }
[09:32:37.602]                       else if (inherits(cond, "condition")) {
[09:32:37.602]                         if (!is.null(pattern)) {
[09:32:37.602]                           computeRestarts <- base::computeRestarts
[09:32:37.602]                           grepl <- base::grepl
[09:32:37.602]                           restarts <- computeRestarts(cond)
[09:32:37.602]                           for (restart in restarts) {
[09:32:37.602]                             name <- restart$name
[09:32:37.602]                             if (is.null(name)) 
[09:32:37.602]                               next
[09:32:37.602]                             if (!grepl(pattern, name)) 
[09:32:37.602]                               next
[09:32:37.602]                             invokeRestart(restart)
[09:32:37.602]                             muffled <- TRUE
[09:32:37.602]                             break
[09:32:37.602]                           }
[09:32:37.602]                         }
[09:32:37.602]                       }
[09:32:37.602]                       invisible(muffled)
[09:32:37.602]                     }
[09:32:37.602]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.602]                   }
[09:32:37.602]                 }
[09:32:37.602]             }
[09:32:37.602]         }))
[09:32:37.602]     }, error = function(ex) {
[09:32:37.602]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.602]                 ...future.rng), started = ...future.startTime, 
[09:32:37.602]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.602]             version = "1.8"), class = "FutureResult")
[09:32:37.602]     }, finally = {
[09:32:37.602]         if (!identical(...future.workdir, getwd())) 
[09:32:37.602]             setwd(...future.workdir)
[09:32:37.602]         {
[09:32:37.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.602]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.602]             }
[09:32:37.602]             base::options(...future.oldOptions)
[09:32:37.602]             if (.Platform$OS.type == "windows") {
[09:32:37.602]                 old_names <- names(...future.oldEnvVars)
[09:32:37.602]                 envs <- base::Sys.getenv()
[09:32:37.602]                 names <- names(envs)
[09:32:37.602]                 common <- intersect(names, old_names)
[09:32:37.602]                 added <- setdiff(names, old_names)
[09:32:37.602]                 removed <- setdiff(old_names, names)
[09:32:37.602]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.602]                   envs[common]]
[09:32:37.602]                 NAMES <- toupper(changed)
[09:32:37.602]                 args <- list()
[09:32:37.602]                 for (kk in seq_along(NAMES)) {
[09:32:37.602]                   name <- changed[[kk]]
[09:32:37.602]                   NAME <- NAMES[[kk]]
[09:32:37.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.602]                     next
[09:32:37.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.602]                 }
[09:32:37.602]                 NAMES <- toupper(added)
[09:32:37.602]                 for (kk in seq_along(NAMES)) {
[09:32:37.602]                   name <- added[[kk]]
[09:32:37.602]                   NAME <- NAMES[[kk]]
[09:32:37.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.602]                     next
[09:32:37.602]                   args[[name]] <- ""
[09:32:37.602]                 }
[09:32:37.602]                 NAMES <- toupper(removed)
[09:32:37.602]                 for (kk in seq_along(NAMES)) {
[09:32:37.602]                   name <- removed[[kk]]
[09:32:37.602]                   NAME <- NAMES[[kk]]
[09:32:37.602]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.602]                     next
[09:32:37.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.602]                 }
[09:32:37.602]                 if (length(args) > 0) 
[09:32:37.602]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.602]             }
[09:32:37.602]             else {
[09:32:37.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.602]             }
[09:32:37.602]             {
[09:32:37.602]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.602]                   0L) {
[09:32:37.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.602]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.602]                   base::options(opts)
[09:32:37.602]                 }
[09:32:37.602]                 {
[09:32:37.602]                   {
[09:32:37.602]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.602]                     NULL
[09:32:37.602]                   }
[09:32:37.602]                   options(future.plan = NULL)
[09:32:37.602]                   if (is.na(NA_character_)) 
[09:32:37.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.602]                     .init = FALSE)
[09:32:37.602]                 }
[09:32:37.602]             }
[09:32:37.602]         }
[09:32:37.602]     })
[09:32:37.602]     if (TRUE) {
[09:32:37.602]         base::sink(type = "output", split = FALSE)
[09:32:37.602]         if (TRUE) {
[09:32:37.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.602]         }
[09:32:37.602]         else {
[09:32:37.602]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.602]         }
[09:32:37.602]         base::close(...future.stdout)
[09:32:37.602]         ...future.stdout <- NULL
[09:32:37.602]     }
[09:32:37.602]     ...future.result$conditions <- ...future.conditions
[09:32:37.602]     ...future.result$finished <- base::Sys.time()
[09:32:37.602]     ...future.result
[09:32:37.602] }
[09:32:37.605] MultisessionFuture started
[09:32:37.605] - Launch lazy future ... done
[09:32:37.605] run() for ‘MultisessionFuture’ ... done
[09:32:37.605] resolve() on environment ...
[09:32:37.605]  recursive: 0
[09:32:37.606]  elements: [3] ‘a’
[09:32:37.606] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.606] - Validating connection of MultisessionFuture
[09:32:37.607] - received message: FutureResult
[09:32:37.607] - Received FutureResult
[09:32:37.607] - Erased future from FutureRegistry
[09:32:37.607] result() for ClusterFuture ...
[09:32:37.607] - result already collected: FutureResult
[09:32:37.607] result() for ClusterFuture ... done
[09:32:37.607] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.607] Future #1
[09:32:37.607]  length: 2 (resolved future 1)
[09:32:37.608] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.608] - Validating connection of MultisessionFuture
[09:32:37.608] - received message: FutureResult
[09:32:37.608] - Received FutureResult
[09:32:37.608] - Erased future from FutureRegistry
[09:32:37.608] result() for ClusterFuture ...
[09:32:37.608] - result already collected: FutureResult
[09:32:37.608] result() for ClusterFuture ... done
[09:32:37.609] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.609] Future #2
[09:32:37.609]  length: 1 (resolved future 2)
[09:32:37.609]  length: 0 (resolved future 3)
[09:32:37.609] resolve() on environment ... DONE
[09:32:37.609] resolve() on environment ...
[09:32:37.609]  recursive: 0
[09:32:37.610]  elements: [3] ‘b’
[09:32:37.610] Future #1
[09:32:37.610]  length: 2 (resolved future 1)
[09:32:37.610] Future #2
[09:32:37.610]  length: 1 (resolved future 2)
[09:32:37.610]  length: 0 (resolved future 3)
[09:32:37.611] resolve() on environment ... DONE
[09:32:37.611] resolve() on environment ...
[09:32:37.611]  recursive: 0
[09:32:37.611]  elements: [3] ‘c’
[09:32:37.612] Future #1
[09:32:37.612]  length: 2 (resolved future 1)
[09:32:37.612] Future #2
[09:32:37.612]  length: 1 (resolved future 2)
[09:32:37.612]  length: 0 (resolved future 3)
[09:32:37.612] resolve() on environment ... DONE
[09:32:37.613] resolve() on environment ...
[09:32:37.613]  recursive: 0
[09:32:37.613]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[09:32:37.613] Future #1
[09:32:37.613] result() for ClusterFuture ...
[09:32:37.613] - result already collected: FutureResult
[09:32:37.613] result() for ClusterFuture ... done
[09:32:37.614] result() for ClusterFuture ...
[09:32:37.614] - result already collected: FutureResult
[09:32:37.614] result() for ClusterFuture ... done
[09:32:37.614]  length: 2 (resolved future 1)
[09:32:37.614] Future #2
[09:32:37.614] result() for ClusterFuture ...
[09:32:37.614] - result already collected: FutureResult
[09:32:37.614] result() for ClusterFuture ... done
[09:32:37.614] result() for ClusterFuture ...
[09:32:37.614] - result already collected: FutureResult
[09:32:37.614] result() for ClusterFuture ... done
[09:32:37.615]  length: 1 (resolved future 2)
[09:32:37.615]  length: 0 (resolved future 3)
[09:32:37.615] resolve() on environment ... DONE
[09:32:37.615] resolve() on environment ...
[09:32:37.615]  recursive: 99
[09:32:37.616]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[09:32:37.616] Future #1
[09:32:37.616] result() for ClusterFuture ...
[09:32:37.616] - result already collected: FutureResult
[09:32:37.616] result() for ClusterFuture ... done
[09:32:37.616] result() for ClusterFuture ...
[09:32:37.616] - result already collected: FutureResult
[09:32:37.616] result() for ClusterFuture ... done
[09:32:37.616] A MultisessionFuture was resolved
[09:32:37.617]  length: 2 (resolved future 1)
[09:32:37.617] Future #2
[09:32:37.617] result() for ClusterFuture ...
[09:32:37.617] - result already collected: FutureResult
[09:32:37.617] result() for ClusterFuture ... done
[09:32:37.617] result() for ClusterFuture ...
[09:32:37.617] - result already collected: FutureResult
[09:32:37.617] result() for ClusterFuture ... done
[09:32:37.617] A MultisessionFuture was resolved
[09:32:37.617]  length: 1 (resolved future 2)
[09:32:37.617]  length: 0 (resolved future 3)
[09:32:37.618] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[09:32:37.618] resolve() on list environment ...
[09:32:37.618]  recursive: 0
[09:32:37.619]  length: 2
[09:32:37.619]  elements: ‘a’, ‘b’
[09:32:37.619]  length: 1 (resolved future 1)
[09:32:37.619]  length: 0 (resolved future 2)
[09:32:37.619] resolve() on list environment ... DONE
[09:32:37.619] getGlobalsAndPackages() ...
[09:32:37.619] Searching for globals...
[09:32:37.620] 
[09:32:37.620] Searching for globals ... DONE
[09:32:37.620] - globals: [0] <none>
[09:32:37.620] getGlobalsAndPackages() ... DONE
[09:32:37.620] run() for ‘Future’ ...
[09:32:37.620] - state: ‘created’
[09:32:37.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.634] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.634]   - Field: ‘node’
[09:32:37.634]   - Field: ‘label’
[09:32:37.634]   - Field: ‘local’
[09:32:37.634]   - Field: ‘owner’
[09:32:37.634]   - Field: ‘envir’
[09:32:37.634]   - Field: ‘workers’
[09:32:37.634]   - Field: ‘packages’
[09:32:37.635]   - Field: ‘gc’
[09:32:37.635]   - Field: ‘conditions’
[09:32:37.635]   - Field: ‘persistent’
[09:32:37.635]   - Field: ‘expr’
[09:32:37.635]   - Field: ‘uuid’
[09:32:37.635]   - Field: ‘seed’
[09:32:37.635]   - Field: ‘version’
[09:32:37.635]   - Field: ‘result’
[09:32:37.635]   - Field: ‘asynchronous’
[09:32:37.635]   - Field: ‘calls’
[09:32:37.635]   - Field: ‘globals’
[09:32:37.636]   - Field: ‘stdout’
[09:32:37.636]   - Field: ‘earlySignal’
[09:32:37.636]   - Field: ‘lazy’
[09:32:37.636]   - Field: ‘state’
[09:32:37.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.636] - Launch lazy future ...
[09:32:37.636] Packages needed by the future expression (n = 0): <none>
[09:32:37.636] Packages needed by future strategies (n = 0): <none>
[09:32:37.637] {
[09:32:37.637]     {
[09:32:37.637]         {
[09:32:37.637]             ...future.startTime <- base::Sys.time()
[09:32:37.637]             {
[09:32:37.637]                 {
[09:32:37.637]                   {
[09:32:37.637]                     {
[09:32:37.637]                       base::local({
[09:32:37.637]                         has_future <- base::requireNamespace("future", 
[09:32:37.637]                           quietly = TRUE)
[09:32:37.637]                         if (has_future) {
[09:32:37.637]                           ns <- base::getNamespace("future")
[09:32:37.637]                           version <- ns[[".package"]][["version"]]
[09:32:37.637]                           if (is.null(version)) 
[09:32:37.637]                             version <- utils::packageVersion("future")
[09:32:37.637]                         }
[09:32:37.637]                         else {
[09:32:37.637]                           version <- NULL
[09:32:37.637]                         }
[09:32:37.637]                         if (!has_future || version < "1.8.0") {
[09:32:37.637]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.637]                             "", base::R.version$version.string), 
[09:32:37.637]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.637]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.637]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.637]                               "release", "version")], collapse = " "), 
[09:32:37.637]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.637]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.637]                             info)
[09:32:37.637]                           info <- base::paste(info, collapse = "; ")
[09:32:37.637]                           if (!has_future) {
[09:32:37.637]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.637]                               info)
[09:32:37.637]                           }
[09:32:37.637]                           else {
[09:32:37.637]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.637]                               info, version)
[09:32:37.637]                           }
[09:32:37.637]                           base::stop(msg)
[09:32:37.637]                         }
[09:32:37.637]                       })
[09:32:37.637]                     }
[09:32:37.637]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.637]                     base::options(mc.cores = 1L)
[09:32:37.637]                   }
[09:32:37.637]                   ...future.strategy.old <- future::plan("list")
[09:32:37.637]                   options(future.plan = NULL)
[09:32:37.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.637]                 }
[09:32:37.637]                 ...future.workdir <- getwd()
[09:32:37.637]             }
[09:32:37.637]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.637]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.637]         }
[09:32:37.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.637]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.637]             base::names(...future.oldOptions))
[09:32:37.637]     }
[09:32:37.637]     if (FALSE) {
[09:32:37.637]     }
[09:32:37.637]     else {
[09:32:37.637]         if (TRUE) {
[09:32:37.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.637]                 open = "w")
[09:32:37.637]         }
[09:32:37.637]         else {
[09:32:37.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.637]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.637]         }
[09:32:37.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.637]             base::sink(type = "output", split = FALSE)
[09:32:37.637]             base::close(...future.stdout)
[09:32:37.637]         }, add = TRUE)
[09:32:37.637]     }
[09:32:37.637]     ...future.frame <- base::sys.nframe()
[09:32:37.637]     ...future.conditions <- base::list()
[09:32:37.637]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.637]     if (FALSE) {
[09:32:37.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.637]     }
[09:32:37.637]     ...future.result <- base::tryCatch({
[09:32:37.637]         base::withCallingHandlers({
[09:32:37.637]             ...future.value <- base::withVisible(base::local({
[09:32:37.637]                 ...future.makeSendCondition <- base::local({
[09:32:37.637]                   sendCondition <- NULL
[09:32:37.637]                   function(frame = 1L) {
[09:32:37.637]                     if (is.function(sendCondition)) 
[09:32:37.637]                       return(sendCondition)
[09:32:37.637]                     ns <- getNamespace("parallel")
[09:32:37.637]                     if (exists("sendData", mode = "function", 
[09:32:37.637]                       envir = ns)) {
[09:32:37.637]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.637]                         envir = ns)
[09:32:37.637]                       envir <- sys.frame(frame)
[09:32:37.637]                       master <- NULL
[09:32:37.637]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.637]                         !identical(envir, emptyenv())) {
[09:32:37.637]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.637]                           inherits = FALSE)) {
[09:32:37.637]                           master <- get("master", mode = "list", 
[09:32:37.637]                             envir = envir, inherits = FALSE)
[09:32:37.637]                           if (inherits(master, c("SOCKnode", 
[09:32:37.637]                             "SOCK0node"))) {
[09:32:37.637]                             sendCondition <<- function(cond) {
[09:32:37.637]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.637]                                 success = TRUE)
[09:32:37.637]                               parallel_sendData(master, data)
[09:32:37.637]                             }
[09:32:37.637]                             return(sendCondition)
[09:32:37.637]                           }
[09:32:37.637]                         }
[09:32:37.637]                         frame <- frame + 1L
[09:32:37.637]                         envir <- sys.frame(frame)
[09:32:37.637]                       }
[09:32:37.637]                     }
[09:32:37.637]                     sendCondition <<- function(cond) NULL
[09:32:37.637]                   }
[09:32:37.637]                 })
[09:32:37.637]                 withCallingHandlers({
[09:32:37.637]                   1
[09:32:37.637]                 }, immediateCondition = function(cond) {
[09:32:37.637]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.637]                   sendCondition(cond)
[09:32:37.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.637]                   {
[09:32:37.637]                     inherits <- base::inherits
[09:32:37.637]                     invokeRestart <- base::invokeRestart
[09:32:37.637]                     is.null <- base::is.null
[09:32:37.637]                     muffled <- FALSE
[09:32:37.637]                     if (inherits(cond, "message")) {
[09:32:37.637]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.637]                       if (muffled) 
[09:32:37.637]                         invokeRestart("muffleMessage")
[09:32:37.637]                     }
[09:32:37.637]                     else if (inherits(cond, "warning")) {
[09:32:37.637]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.637]                       if (muffled) 
[09:32:37.637]                         invokeRestart("muffleWarning")
[09:32:37.637]                     }
[09:32:37.637]                     else if (inherits(cond, "condition")) {
[09:32:37.637]                       if (!is.null(pattern)) {
[09:32:37.637]                         computeRestarts <- base::computeRestarts
[09:32:37.637]                         grepl <- base::grepl
[09:32:37.637]                         restarts <- computeRestarts(cond)
[09:32:37.637]                         for (restart in restarts) {
[09:32:37.637]                           name <- restart$name
[09:32:37.637]                           if (is.null(name)) 
[09:32:37.637]                             next
[09:32:37.637]                           if (!grepl(pattern, name)) 
[09:32:37.637]                             next
[09:32:37.637]                           invokeRestart(restart)
[09:32:37.637]                           muffled <- TRUE
[09:32:37.637]                           break
[09:32:37.637]                         }
[09:32:37.637]                       }
[09:32:37.637]                     }
[09:32:37.637]                     invisible(muffled)
[09:32:37.637]                   }
[09:32:37.637]                   muffleCondition(cond)
[09:32:37.637]                 })
[09:32:37.637]             }))
[09:32:37.637]             future::FutureResult(value = ...future.value$value, 
[09:32:37.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.637]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.637]                     ...future.globalenv.names))
[09:32:37.637]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.637]         }, condition = base::local({
[09:32:37.637]             c <- base::c
[09:32:37.637]             inherits <- base::inherits
[09:32:37.637]             invokeRestart <- base::invokeRestart
[09:32:37.637]             length <- base::length
[09:32:37.637]             list <- base::list
[09:32:37.637]             seq.int <- base::seq.int
[09:32:37.637]             signalCondition <- base::signalCondition
[09:32:37.637]             sys.calls <- base::sys.calls
[09:32:37.637]             `[[` <- base::`[[`
[09:32:37.637]             `+` <- base::`+`
[09:32:37.637]             `<<-` <- base::`<<-`
[09:32:37.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.637]                   3L)]
[09:32:37.637]             }
[09:32:37.637]             function(cond) {
[09:32:37.637]                 is_error <- inherits(cond, "error")
[09:32:37.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.637]                   NULL)
[09:32:37.637]                 if (is_error) {
[09:32:37.637]                   sessionInformation <- function() {
[09:32:37.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.637]                       search = base::search(), system = base::Sys.info())
[09:32:37.637]                   }
[09:32:37.637]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.637]                     cond$call), session = sessionInformation(), 
[09:32:37.637]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.637]                   signalCondition(cond)
[09:32:37.637]                 }
[09:32:37.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.637]                 "immediateCondition"))) {
[09:32:37.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.637]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.637]                   if (TRUE && !signal) {
[09:32:37.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.637]                     {
[09:32:37.637]                       inherits <- base::inherits
[09:32:37.637]                       invokeRestart <- base::invokeRestart
[09:32:37.637]                       is.null <- base::is.null
[09:32:37.637]                       muffled <- FALSE
[09:32:37.637]                       if (inherits(cond, "message")) {
[09:32:37.637]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.637]                         if (muffled) 
[09:32:37.637]                           invokeRestart("muffleMessage")
[09:32:37.637]                       }
[09:32:37.637]                       else if (inherits(cond, "warning")) {
[09:32:37.637]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.637]                         if (muffled) 
[09:32:37.637]                           invokeRestart("muffleWarning")
[09:32:37.637]                       }
[09:32:37.637]                       else if (inherits(cond, "condition")) {
[09:32:37.637]                         if (!is.null(pattern)) {
[09:32:37.637]                           computeRestarts <- base::computeRestarts
[09:32:37.637]                           grepl <- base::grepl
[09:32:37.637]                           restarts <- computeRestarts(cond)
[09:32:37.637]                           for (restart in restarts) {
[09:32:37.637]                             name <- restart$name
[09:32:37.637]                             if (is.null(name)) 
[09:32:37.637]                               next
[09:32:37.637]                             if (!grepl(pattern, name)) 
[09:32:37.637]                               next
[09:32:37.637]                             invokeRestart(restart)
[09:32:37.637]                             muffled <- TRUE
[09:32:37.637]                             break
[09:32:37.637]                           }
[09:32:37.637]                         }
[09:32:37.637]                       }
[09:32:37.637]                       invisible(muffled)
[09:32:37.637]                     }
[09:32:37.637]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.637]                   }
[09:32:37.637]                 }
[09:32:37.637]                 else {
[09:32:37.637]                   if (TRUE) {
[09:32:37.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.637]                     {
[09:32:37.637]                       inherits <- base::inherits
[09:32:37.637]                       invokeRestart <- base::invokeRestart
[09:32:37.637]                       is.null <- base::is.null
[09:32:37.637]                       muffled <- FALSE
[09:32:37.637]                       if (inherits(cond, "message")) {
[09:32:37.637]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.637]                         if (muffled) 
[09:32:37.637]                           invokeRestart("muffleMessage")
[09:32:37.637]                       }
[09:32:37.637]                       else if (inherits(cond, "warning")) {
[09:32:37.637]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.637]                         if (muffled) 
[09:32:37.637]                           invokeRestart("muffleWarning")
[09:32:37.637]                       }
[09:32:37.637]                       else if (inherits(cond, "condition")) {
[09:32:37.637]                         if (!is.null(pattern)) {
[09:32:37.637]                           computeRestarts <- base::computeRestarts
[09:32:37.637]                           grepl <- base::grepl
[09:32:37.637]                           restarts <- computeRestarts(cond)
[09:32:37.637]                           for (restart in restarts) {
[09:32:37.637]                             name <- restart$name
[09:32:37.637]                             if (is.null(name)) 
[09:32:37.637]                               next
[09:32:37.637]                             if (!grepl(pattern, name)) 
[09:32:37.637]                               next
[09:32:37.637]                             invokeRestart(restart)
[09:32:37.637]                             muffled <- TRUE
[09:32:37.637]                             break
[09:32:37.637]                           }
[09:32:37.637]                         }
[09:32:37.637]                       }
[09:32:37.637]                       invisible(muffled)
[09:32:37.637]                     }
[09:32:37.637]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.637]                   }
[09:32:37.637]                 }
[09:32:37.637]             }
[09:32:37.637]         }))
[09:32:37.637]     }, error = function(ex) {
[09:32:37.637]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.637]                 ...future.rng), started = ...future.startTime, 
[09:32:37.637]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.637]             version = "1.8"), class = "FutureResult")
[09:32:37.637]     }, finally = {
[09:32:37.637]         if (!identical(...future.workdir, getwd())) 
[09:32:37.637]             setwd(...future.workdir)
[09:32:37.637]         {
[09:32:37.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.637]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.637]             }
[09:32:37.637]             base::options(...future.oldOptions)
[09:32:37.637]             if (.Platform$OS.type == "windows") {
[09:32:37.637]                 old_names <- names(...future.oldEnvVars)
[09:32:37.637]                 envs <- base::Sys.getenv()
[09:32:37.637]                 names <- names(envs)
[09:32:37.637]                 common <- intersect(names, old_names)
[09:32:37.637]                 added <- setdiff(names, old_names)
[09:32:37.637]                 removed <- setdiff(old_names, names)
[09:32:37.637]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.637]                   envs[common]]
[09:32:37.637]                 NAMES <- toupper(changed)
[09:32:37.637]                 args <- list()
[09:32:37.637]                 for (kk in seq_along(NAMES)) {
[09:32:37.637]                   name <- changed[[kk]]
[09:32:37.637]                   NAME <- NAMES[[kk]]
[09:32:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.637]                     next
[09:32:37.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.637]                 }
[09:32:37.637]                 NAMES <- toupper(added)
[09:32:37.637]                 for (kk in seq_along(NAMES)) {
[09:32:37.637]                   name <- added[[kk]]
[09:32:37.637]                   NAME <- NAMES[[kk]]
[09:32:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.637]                     next
[09:32:37.637]                   args[[name]] <- ""
[09:32:37.637]                 }
[09:32:37.637]                 NAMES <- toupper(removed)
[09:32:37.637]                 for (kk in seq_along(NAMES)) {
[09:32:37.637]                   name <- removed[[kk]]
[09:32:37.637]                   NAME <- NAMES[[kk]]
[09:32:37.637]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.637]                     next
[09:32:37.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.637]                 }
[09:32:37.637]                 if (length(args) > 0) 
[09:32:37.637]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.637]             }
[09:32:37.637]             else {
[09:32:37.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.637]             }
[09:32:37.637]             {
[09:32:37.637]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.637]                   0L) {
[09:32:37.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.637]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.637]                   base::options(opts)
[09:32:37.637]                 }
[09:32:37.637]                 {
[09:32:37.637]                   {
[09:32:37.637]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.637]                     NULL
[09:32:37.637]                   }
[09:32:37.637]                   options(future.plan = NULL)
[09:32:37.637]                   if (is.na(NA_character_)) 
[09:32:37.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.637]                     .init = FALSE)
[09:32:37.637]                 }
[09:32:37.637]             }
[09:32:37.637]         }
[09:32:37.637]     })
[09:32:37.637]     if (TRUE) {
[09:32:37.637]         base::sink(type = "output", split = FALSE)
[09:32:37.637]         if (TRUE) {
[09:32:37.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.637]         }
[09:32:37.637]         else {
[09:32:37.637]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.637]         }
[09:32:37.637]         base::close(...future.stdout)
[09:32:37.637]         ...future.stdout <- NULL
[09:32:37.637]     }
[09:32:37.637]     ...future.result$conditions <- ...future.conditions
[09:32:37.637]     ...future.result$finished <- base::Sys.time()
[09:32:37.637]     ...future.result
[09:32:37.637] }
[09:32:37.639] MultisessionFuture started
[09:32:37.640] - Launch lazy future ... done
[09:32:37.640] run() for ‘MultisessionFuture’ ... done
[09:32:37.640] getGlobalsAndPackages() ...
[09:32:37.640] Searching for globals...
[09:32:37.640] 
[09:32:37.640] Searching for globals ... DONE
[09:32:37.640] - globals: [0] <none>
[09:32:37.641] getGlobalsAndPackages() ... DONE
[09:32:37.641] run() for ‘Future’ ...
[09:32:37.641] - state: ‘created’
[09:32:37.641] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.654] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.654] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.654]   - Field: ‘node’
[09:32:37.654]   - Field: ‘label’
[09:32:37.654]   - Field: ‘local’
[09:32:37.655]   - Field: ‘owner’
[09:32:37.655]   - Field: ‘envir’
[09:32:37.655]   - Field: ‘workers’
[09:32:37.655]   - Field: ‘packages’
[09:32:37.655]   - Field: ‘gc’
[09:32:37.655]   - Field: ‘conditions’
[09:32:37.655]   - Field: ‘persistent’
[09:32:37.655]   - Field: ‘expr’
[09:32:37.655]   - Field: ‘uuid’
[09:32:37.655]   - Field: ‘seed’
[09:32:37.656]   - Field: ‘version’
[09:32:37.656]   - Field: ‘result’
[09:32:37.656]   - Field: ‘asynchronous’
[09:32:37.656]   - Field: ‘calls’
[09:32:37.656]   - Field: ‘globals’
[09:32:37.656]   - Field: ‘stdout’
[09:32:37.656]   - Field: ‘earlySignal’
[09:32:37.656]   - Field: ‘lazy’
[09:32:37.656]   - Field: ‘state’
[09:32:37.656] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.656] - Launch lazy future ...
[09:32:37.657] Packages needed by the future expression (n = 0): <none>
[09:32:37.657] Packages needed by future strategies (n = 0): <none>
[09:32:37.657] {
[09:32:37.657]     {
[09:32:37.657]         {
[09:32:37.657]             ...future.startTime <- base::Sys.time()
[09:32:37.657]             {
[09:32:37.657]                 {
[09:32:37.657]                   {
[09:32:37.657]                     {
[09:32:37.657]                       base::local({
[09:32:37.657]                         has_future <- base::requireNamespace("future", 
[09:32:37.657]                           quietly = TRUE)
[09:32:37.657]                         if (has_future) {
[09:32:37.657]                           ns <- base::getNamespace("future")
[09:32:37.657]                           version <- ns[[".package"]][["version"]]
[09:32:37.657]                           if (is.null(version)) 
[09:32:37.657]                             version <- utils::packageVersion("future")
[09:32:37.657]                         }
[09:32:37.657]                         else {
[09:32:37.657]                           version <- NULL
[09:32:37.657]                         }
[09:32:37.657]                         if (!has_future || version < "1.8.0") {
[09:32:37.657]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.657]                             "", base::R.version$version.string), 
[09:32:37.657]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.657]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.657]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.657]                               "release", "version")], collapse = " "), 
[09:32:37.657]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.657]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.657]                             info)
[09:32:37.657]                           info <- base::paste(info, collapse = "; ")
[09:32:37.657]                           if (!has_future) {
[09:32:37.657]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.657]                               info)
[09:32:37.657]                           }
[09:32:37.657]                           else {
[09:32:37.657]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.657]                               info, version)
[09:32:37.657]                           }
[09:32:37.657]                           base::stop(msg)
[09:32:37.657]                         }
[09:32:37.657]                       })
[09:32:37.657]                     }
[09:32:37.657]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.657]                     base::options(mc.cores = 1L)
[09:32:37.657]                   }
[09:32:37.657]                   ...future.strategy.old <- future::plan("list")
[09:32:37.657]                   options(future.plan = NULL)
[09:32:37.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.657]                 }
[09:32:37.657]                 ...future.workdir <- getwd()
[09:32:37.657]             }
[09:32:37.657]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.657]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.657]         }
[09:32:37.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.657]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.657]             base::names(...future.oldOptions))
[09:32:37.657]     }
[09:32:37.657]     if (FALSE) {
[09:32:37.657]     }
[09:32:37.657]     else {
[09:32:37.657]         if (TRUE) {
[09:32:37.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.657]                 open = "w")
[09:32:37.657]         }
[09:32:37.657]         else {
[09:32:37.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.657]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.657]         }
[09:32:37.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.657]             base::sink(type = "output", split = FALSE)
[09:32:37.657]             base::close(...future.stdout)
[09:32:37.657]         }, add = TRUE)
[09:32:37.657]     }
[09:32:37.657]     ...future.frame <- base::sys.nframe()
[09:32:37.657]     ...future.conditions <- base::list()
[09:32:37.657]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.657]     if (FALSE) {
[09:32:37.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.657]     }
[09:32:37.657]     ...future.result <- base::tryCatch({
[09:32:37.657]         base::withCallingHandlers({
[09:32:37.657]             ...future.value <- base::withVisible(base::local({
[09:32:37.657]                 ...future.makeSendCondition <- base::local({
[09:32:37.657]                   sendCondition <- NULL
[09:32:37.657]                   function(frame = 1L) {
[09:32:37.657]                     if (is.function(sendCondition)) 
[09:32:37.657]                       return(sendCondition)
[09:32:37.657]                     ns <- getNamespace("parallel")
[09:32:37.657]                     if (exists("sendData", mode = "function", 
[09:32:37.657]                       envir = ns)) {
[09:32:37.657]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.657]                         envir = ns)
[09:32:37.657]                       envir <- sys.frame(frame)
[09:32:37.657]                       master <- NULL
[09:32:37.657]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.657]                         !identical(envir, emptyenv())) {
[09:32:37.657]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.657]                           inherits = FALSE)) {
[09:32:37.657]                           master <- get("master", mode = "list", 
[09:32:37.657]                             envir = envir, inherits = FALSE)
[09:32:37.657]                           if (inherits(master, c("SOCKnode", 
[09:32:37.657]                             "SOCK0node"))) {
[09:32:37.657]                             sendCondition <<- function(cond) {
[09:32:37.657]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.657]                                 success = TRUE)
[09:32:37.657]                               parallel_sendData(master, data)
[09:32:37.657]                             }
[09:32:37.657]                             return(sendCondition)
[09:32:37.657]                           }
[09:32:37.657]                         }
[09:32:37.657]                         frame <- frame + 1L
[09:32:37.657]                         envir <- sys.frame(frame)
[09:32:37.657]                       }
[09:32:37.657]                     }
[09:32:37.657]                     sendCondition <<- function(cond) NULL
[09:32:37.657]                   }
[09:32:37.657]                 })
[09:32:37.657]                 withCallingHandlers({
[09:32:37.657]                   2
[09:32:37.657]                 }, immediateCondition = function(cond) {
[09:32:37.657]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.657]                   sendCondition(cond)
[09:32:37.657]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.657]                   {
[09:32:37.657]                     inherits <- base::inherits
[09:32:37.657]                     invokeRestart <- base::invokeRestart
[09:32:37.657]                     is.null <- base::is.null
[09:32:37.657]                     muffled <- FALSE
[09:32:37.657]                     if (inherits(cond, "message")) {
[09:32:37.657]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.657]                       if (muffled) 
[09:32:37.657]                         invokeRestart("muffleMessage")
[09:32:37.657]                     }
[09:32:37.657]                     else if (inherits(cond, "warning")) {
[09:32:37.657]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.657]                       if (muffled) 
[09:32:37.657]                         invokeRestart("muffleWarning")
[09:32:37.657]                     }
[09:32:37.657]                     else if (inherits(cond, "condition")) {
[09:32:37.657]                       if (!is.null(pattern)) {
[09:32:37.657]                         computeRestarts <- base::computeRestarts
[09:32:37.657]                         grepl <- base::grepl
[09:32:37.657]                         restarts <- computeRestarts(cond)
[09:32:37.657]                         for (restart in restarts) {
[09:32:37.657]                           name <- restart$name
[09:32:37.657]                           if (is.null(name)) 
[09:32:37.657]                             next
[09:32:37.657]                           if (!grepl(pattern, name)) 
[09:32:37.657]                             next
[09:32:37.657]                           invokeRestart(restart)
[09:32:37.657]                           muffled <- TRUE
[09:32:37.657]                           break
[09:32:37.657]                         }
[09:32:37.657]                       }
[09:32:37.657]                     }
[09:32:37.657]                     invisible(muffled)
[09:32:37.657]                   }
[09:32:37.657]                   muffleCondition(cond)
[09:32:37.657]                 })
[09:32:37.657]             }))
[09:32:37.657]             future::FutureResult(value = ...future.value$value, 
[09:32:37.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.657]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.657]                     ...future.globalenv.names))
[09:32:37.657]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.657]         }, condition = base::local({
[09:32:37.657]             c <- base::c
[09:32:37.657]             inherits <- base::inherits
[09:32:37.657]             invokeRestart <- base::invokeRestart
[09:32:37.657]             length <- base::length
[09:32:37.657]             list <- base::list
[09:32:37.657]             seq.int <- base::seq.int
[09:32:37.657]             signalCondition <- base::signalCondition
[09:32:37.657]             sys.calls <- base::sys.calls
[09:32:37.657]             `[[` <- base::`[[`
[09:32:37.657]             `+` <- base::`+`
[09:32:37.657]             `<<-` <- base::`<<-`
[09:32:37.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.657]                   3L)]
[09:32:37.657]             }
[09:32:37.657]             function(cond) {
[09:32:37.657]                 is_error <- inherits(cond, "error")
[09:32:37.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.657]                   NULL)
[09:32:37.657]                 if (is_error) {
[09:32:37.657]                   sessionInformation <- function() {
[09:32:37.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.657]                       search = base::search(), system = base::Sys.info())
[09:32:37.657]                   }
[09:32:37.657]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.657]                     cond$call), session = sessionInformation(), 
[09:32:37.657]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.657]                   signalCondition(cond)
[09:32:37.657]                 }
[09:32:37.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.657]                 "immediateCondition"))) {
[09:32:37.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.657]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.657]                   if (TRUE && !signal) {
[09:32:37.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.657]                     {
[09:32:37.657]                       inherits <- base::inherits
[09:32:37.657]                       invokeRestart <- base::invokeRestart
[09:32:37.657]                       is.null <- base::is.null
[09:32:37.657]                       muffled <- FALSE
[09:32:37.657]                       if (inherits(cond, "message")) {
[09:32:37.657]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.657]                         if (muffled) 
[09:32:37.657]                           invokeRestart("muffleMessage")
[09:32:37.657]                       }
[09:32:37.657]                       else if (inherits(cond, "warning")) {
[09:32:37.657]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.657]                         if (muffled) 
[09:32:37.657]                           invokeRestart("muffleWarning")
[09:32:37.657]                       }
[09:32:37.657]                       else if (inherits(cond, "condition")) {
[09:32:37.657]                         if (!is.null(pattern)) {
[09:32:37.657]                           computeRestarts <- base::computeRestarts
[09:32:37.657]                           grepl <- base::grepl
[09:32:37.657]                           restarts <- computeRestarts(cond)
[09:32:37.657]                           for (restart in restarts) {
[09:32:37.657]                             name <- restart$name
[09:32:37.657]                             if (is.null(name)) 
[09:32:37.657]                               next
[09:32:37.657]                             if (!grepl(pattern, name)) 
[09:32:37.657]                               next
[09:32:37.657]                             invokeRestart(restart)
[09:32:37.657]                             muffled <- TRUE
[09:32:37.657]                             break
[09:32:37.657]                           }
[09:32:37.657]                         }
[09:32:37.657]                       }
[09:32:37.657]                       invisible(muffled)
[09:32:37.657]                     }
[09:32:37.657]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.657]                   }
[09:32:37.657]                 }
[09:32:37.657]                 else {
[09:32:37.657]                   if (TRUE) {
[09:32:37.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.657]                     {
[09:32:37.657]                       inherits <- base::inherits
[09:32:37.657]                       invokeRestart <- base::invokeRestart
[09:32:37.657]                       is.null <- base::is.null
[09:32:37.657]                       muffled <- FALSE
[09:32:37.657]                       if (inherits(cond, "message")) {
[09:32:37.657]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.657]                         if (muffled) 
[09:32:37.657]                           invokeRestart("muffleMessage")
[09:32:37.657]                       }
[09:32:37.657]                       else if (inherits(cond, "warning")) {
[09:32:37.657]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.657]                         if (muffled) 
[09:32:37.657]                           invokeRestart("muffleWarning")
[09:32:37.657]                       }
[09:32:37.657]                       else if (inherits(cond, "condition")) {
[09:32:37.657]                         if (!is.null(pattern)) {
[09:32:37.657]                           computeRestarts <- base::computeRestarts
[09:32:37.657]                           grepl <- base::grepl
[09:32:37.657]                           restarts <- computeRestarts(cond)
[09:32:37.657]                           for (restart in restarts) {
[09:32:37.657]                             name <- restart$name
[09:32:37.657]                             if (is.null(name)) 
[09:32:37.657]                               next
[09:32:37.657]                             if (!grepl(pattern, name)) 
[09:32:37.657]                               next
[09:32:37.657]                             invokeRestart(restart)
[09:32:37.657]                             muffled <- TRUE
[09:32:37.657]                             break
[09:32:37.657]                           }
[09:32:37.657]                         }
[09:32:37.657]                       }
[09:32:37.657]                       invisible(muffled)
[09:32:37.657]                     }
[09:32:37.657]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.657]                   }
[09:32:37.657]                 }
[09:32:37.657]             }
[09:32:37.657]         }))
[09:32:37.657]     }, error = function(ex) {
[09:32:37.657]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.657]                 ...future.rng), started = ...future.startTime, 
[09:32:37.657]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.657]             version = "1.8"), class = "FutureResult")
[09:32:37.657]     }, finally = {
[09:32:37.657]         if (!identical(...future.workdir, getwd())) 
[09:32:37.657]             setwd(...future.workdir)
[09:32:37.657]         {
[09:32:37.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.657]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.657]             }
[09:32:37.657]             base::options(...future.oldOptions)
[09:32:37.657]             if (.Platform$OS.type == "windows") {
[09:32:37.657]                 old_names <- names(...future.oldEnvVars)
[09:32:37.657]                 envs <- base::Sys.getenv()
[09:32:37.657]                 names <- names(envs)
[09:32:37.657]                 common <- intersect(names, old_names)
[09:32:37.657]                 added <- setdiff(names, old_names)
[09:32:37.657]                 removed <- setdiff(old_names, names)
[09:32:37.657]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.657]                   envs[common]]
[09:32:37.657]                 NAMES <- toupper(changed)
[09:32:37.657]                 args <- list()
[09:32:37.657]                 for (kk in seq_along(NAMES)) {
[09:32:37.657]                   name <- changed[[kk]]
[09:32:37.657]                   NAME <- NAMES[[kk]]
[09:32:37.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.657]                     next
[09:32:37.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.657]                 }
[09:32:37.657]                 NAMES <- toupper(added)
[09:32:37.657]                 for (kk in seq_along(NAMES)) {
[09:32:37.657]                   name <- added[[kk]]
[09:32:37.657]                   NAME <- NAMES[[kk]]
[09:32:37.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.657]                     next
[09:32:37.657]                   args[[name]] <- ""
[09:32:37.657]                 }
[09:32:37.657]                 NAMES <- toupper(removed)
[09:32:37.657]                 for (kk in seq_along(NAMES)) {
[09:32:37.657]                   name <- removed[[kk]]
[09:32:37.657]                   NAME <- NAMES[[kk]]
[09:32:37.657]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.657]                     next
[09:32:37.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.657]                 }
[09:32:37.657]                 if (length(args) > 0) 
[09:32:37.657]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.657]             }
[09:32:37.657]             else {
[09:32:37.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.657]             }
[09:32:37.657]             {
[09:32:37.657]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.657]                   0L) {
[09:32:37.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.657]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.657]                   base::options(opts)
[09:32:37.657]                 }
[09:32:37.657]                 {
[09:32:37.657]                   {
[09:32:37.657]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.657]                     NULL
[09:32:37.657]                   }
[09:32:37.657]                   options(future.plan = NULL)
[09:32:37.657]                   if (is.na(NA_character_)) 
[09:32:37.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.657]                     .init = FALSE)
[09:32:37.657]                 }
[09:32:37.657]             }
[09:32:37.657]         }
[09:32:37.657]     })
[09:32:37.657]     if (TRUE) {
[09:32:37.657]         base::sink(type = "output", split = FALSE)
[09:32:37.657]         if (TRUE) {
[09:32:37.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.657]         }
[09:32:37.657]         else {
[09:32:37.657]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.657]         }
[09:32:37.657]         base::close(...future.stdout)
[09:32:37.657]         ...future.stdout <- NULL
[09:32:37.657]     }
[09:32:37.657]     ...future.result$conditions <- ...future.conditions
[09:32:37.657]     ...future.result$finished <- base::Sys.time()
[09:32:37.657]     ...future.result
[09:32:37.657] }
[09:32:37.660] MultisessionFuture started
[09:32:37.660] - Launch lazy future ... done
[09:32:37.660] run() for ‘MultisessionFuture’ ... done
[09:32:37.661] resolve() on list environment ...
[09:32:37.661]  recursive: 0
[09:32:37.661]  length: 3
[09:32:37.662]  elements: ‘a’, ‘b’, ‘c’
[09:32:37.662] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.662] - Validating connection of MultisessionFuture
[09:32:37.662] - received message: FutureResult
[09:32:37.662] - Received FutureResult
[09:32:37.663] - Erased future from FutureRegistry
[09:32:37.663] result() for ClusterFuture ...
[09:32:37.663] - result already collected: FutureResult
[09:32:37.663] result() for ClusterFuture ... done
[09:32:37.663] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.663] Future #1
[09:32:37.663]  length: 2 (resolved future 1)
[09:32:37.663] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.664] - Validating connection of MultisessionFuture
[09:32:37.664] - received message: FutureResult
[09:32:37.664] - Received FutureResult
[09:32:37.664] - Erased future from FutureRegistry
[09:32:37.664] result() for ClusterFuture ...
[09:32:37.664] - result already collected: FutureResult
[09:32:37.664] result() for ClusterFuture ... done
[09:32:37.664] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.664] Future #2
[09:32:37.665]  length: 1 (resolved future 2)
[09:32:37.665]  length: 0 (resolved future 3)
[09:32:37.665] resolve() on list environment ... DONE
[09:32:37.665] getGlobalsAndPackages() ...
[09:32:37.665] Searching for globals...
[09:32:37.666] - globals found: [1] ‘{’
[09:32:37.666] Searching for globals ... DONE
[09:32:37.666] Resolving globals: FALSE
[09:32:37.666] 
[09:32:37.667] 
[09:32:37.667] getGlobalsAndPackages() ... DONE
[09:32:37.667] run() for ‘Future’ ...
[09:32:37.667] - state: ‘created’
[09:32:37.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.680] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.680] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.680]   - Field: ‘node’
[09:32:37.681]   - Field: ‘label’
[09:32:37.681]   - Field: ‘local’
[09:32:37.681]   - Field: ‘owner’
[09:32:37.681]   - Field: ‘envir’
[09:32:37.681]   - Field: ‘workers’
[09:32:37.681]   - Field: ‘packages’
[09:32:37.681]   - Field: ‘gc’
[09:32:37.681]   - Field: ‘conditions’
[09:32:37.681]   - Field: ‘persistent’
[09:32:37.681]   - Field: ‘expr’
[09:32:37.681]   - Field: ‘uuid’
[09:32:37.682]   - Field: ‘seed’
[09:32:37.682]   - Field: ‘version’
[09:32:37.682]   - Field: ‘result’
[09:32:37.682]   - Field: ‘asynchronous’
[09:32:37.682]   - Field: ‘calls’
[09:32:37.682]   - Field: ‘globals’
[09:32:37.682]   - Field: ‘stdout’
[09:32:37.682]   - Field: ‘earlySignal’
[09:32:37.682]   - Field: ‘lazy’
[09:32:37.682]   - Field: ‘state’
[09:32:37.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.683] - Launch lazy future ...
[09:32:37.683] Packages needed by the future expression (n = 0): <none>
[09:32:37.683] Packages needed by future strategies (n = 0): <none>
[09:32:37.683] {
[09:32:37.683]     {
[09:32:37.683]         {
[09:32:37.683]             ...future.startTime <- base::Sys.time()
[09:32:37.683]             {
[09:32:37.683]                 {
[09:32:37.683]                   {
[09:32:37.683]                     {
[09:32:37.683]                       base::local({
[09:32:37.683]                         has_future <- base::requireNamespace("future", 
[09:32:37.683]                           quietly = TRUE)
[09:32:37.683]                         if (has_future) {
[09:32:37.683]                           ns <- base::getNamespace("future")
[09:32:37.683]                           version <- ns[[".package"]][["version"]]
[09:32:37.683]                           if (is.null(version)) 
[09:32:37.683]                             version <- utils::packageVersion("future")
[09:32:37.683]                         }
[09:32:37.683]                         else {
[09:32:37.683]                           version <- NULL
[09:32:37.683]                         }
[09:32:37.683]                         if (!has_future || version < "1.8.0") {
[09:32:37.683]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.683]                             "", base::R.version$version.string), 
[09:32:37.683]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.683]                               "release", "version")], collapse = " "), 
[09:32:37.683]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.683]                             info)
[09:32:37.683]                           info <- base::paste(info, collapse = "; ")
[09:32:37.683]                           if (!has_future) {
[09:32:37.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.683]                               info)
[09:32:37.683]                           }
[09:32:37.683]                           else {
[09:32:37.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.683]                               info, version)
[09:32:37.683]                           }
[09:32:37.683]                           base::stop(msg)
[09:32:37.683]                         }
[09:32:37.683]                       })
[09:32:37.683]                     }
[09:32:37.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.683]                     base::options(mc.cores = 1L)
[09:32:37.683]                   }
[09:32:37.683]                   ...future.strategy.old <- future::plan("list")
[09:32:37.683]                   options(future.plan = NULL)
[09:32:37.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.683]                 }
[09:32:37.683]                 ...future.workdir <- getwd()
[09:32:37.683]             }
[09:32:37.683]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.683]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.683]         }
[09:32:37.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.683]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.683]             base::names(...future.oldOptions))
[09:32:37.683]     }
[09:32:37.683]     if (FALSE) {
[09:32:37.683]     }
[09:32:37.683]     else {
[09:32:37.683]         if (TRUE) {
[09:32:37.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.683]                 open = "w")
[09:32:37.683]         }
[09:32:37.683]         else {
[09:32:37.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.683]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.683]         }
[09:32:37.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.683]             base::sink(type = "output", split = FALSE)
[09:32:37.683]             base::close(...future.stdout)
[09:32:37.683]         }, add = TRUE)
[09:32:37.683]     }
[09:32:37.683]     ...future.frame <- base::sys.nframe()
[09:32:37.683]     ...future.conditions <- base::list()
[09:32:37.683]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.683]     if (FALSE) {
[09:32:37.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.683]     }
[09:32:37.683]     ...future.result <- base::tryCatch({
[09:32:37.683]         base::withCallingHandlers({
[09:32:37.683]             ...future.value <- base::withVisible(base::local({
[09:32:37.683]                 ...future.makeSendCondition <- base::local({
[09:32:37.683]                   sendCondition <- NULL
[09:32:37.683]                   function(frame = 1L) {
[09:32:37.683]                     if (is.function(sendCondition)) 
[09:32:37.683]                       return(sendCondition)
[09:32:37.683]                     ns <- getNamespace("parallel")
[09:32:37.683]                     if (exists("sendData", mode = "function", 
[09:32:37.683]                       envir = ns)) {
[09:32:37.683]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.683]                         envir = ns)
[09:32:37.683]                       envir <- sys.frame(frame)
[09:32:37.683]                       master <- NULL
[09:32:37.683]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.683]                         !identical(envir, emptyenv())) {
[09:32:37.683]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.683]                           inherits = FALSE)) {
[09:32:37.683]                           master <- get("master", mode = "list", 
[09:32:37.683]                             envir = envir, inherits = FALSE)
[09:32:37.683]                           if (inherits(master, c("SOCKnode", 
[09:32:37.683]                             "SOCK0node"))) {
[09:32:37.683]                             sendCondition <<- function(cond) {
[09:32:37.683]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.683]                                 success = TRUE)
[09:32:37.683]                               parallel_sendData(master, data)
[09:32:37.683]                             }
[09:32:37.683]                             return(sendCondition)
[09:32:37.683]                           }
[09:32:37.683]                         }
[09:32:37.683]                         frame <- frame + 1L
[09:32:37.683]                         envir <- sys.frame(frame)
[09:32:37.683]                       }
[09:32:37.683]                     }
[09:32:37.683]                     sendCondition <<- function(cond) NULL
[09:32:37.683]                   }
[09:32:37.683]                 })
[09:32:37.683]                 withCallingHandlers({
[09:32:37.683]                   {
[09:32:37.683]                     1
[09:32:37.683]                   }
[09:32:37.683]                 }, immediateCondition = function(cond) {
[09:32:37.683]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.683]                   sendCondition(cond)
[09:32:37.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.683]                   {
[09:32:37.683]                     inherits <- base::inherits
[09:32:37.683]                     invokeRestart <- base::invokeRestart
[09:32:37.683]                     is.null <- base::is.null
[09:32:37.683]                     muffled <- FALSE
[09:32:37.683]                     if (inherits(cond, "message")) {
[09:32:37.683]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.683]                       if (muffled) 
[09:32:37.683]                         invokeRestart("muffleMessage")
[09:32:37.683]                     }
[09:32:37.683]                     else if (inherits(cond, "warning")) {
[09:32:37.683]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.683]                       if (muffled) 
[09:32:37.683]                         invokeRestart("muffleWarning")
[09:32:37.683]                     }
[09:32:37.683]                     else if (inherits(cond, "condition")) {
[09:32:37.683]                       if (!is.null(pattern)) {
[09:32:37.683]                         computeRestarts <- base::computeRestarts
[09:32:37.683]                         grepl <- base::grepl
[09:32:37.683]                         restarts <- computeRestarts(cond)
[09:32:37.683]                         for (restart in restarts) {
[09:32:37.683]                           name <- restart$name
[09:32:37.683]                           if (is.null(name)) 
[09:32:37.683]                             next
[09:32:37.683]                           if (!grepl(pattern, name)) 
[09:32:37.683]                             next
[09:32:37.683]                           invokeRestart(restart)
[09:32:37.683]                           muffled <- TRUE
[09:32:37.683]                           break
[09:32:37.683]                         }
[09:32:37.683]                       }
[09:32:37.683]                     }
[09:32:37.683]                     invisible(muffled)
[09:32:37.683]                   }
[09:32:37.683]                   muffleCondition(cond)
[09:32:37.683]                 })
[09:32:37.683]             }))
[09:32:37.683]             future::FutureResult(value = ...future.value$value, 
[09:32:37.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.683]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.683]                     ...future.globalenv.names))
[09:32:37.683]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.683]         }, condition = base::local({
[09:32:37.683]             c <- base::c
[09:32:37.683]             inherits <- base::inherits
[09:32:37.683]             invokeRestart <- base::invokeRestart
[09:32:37.683]             length <- base::length
[09:32:37.683]             list <- base::list
[09:32:37.683]             seq.int <- base::seq.int
[09:32:37.683]             signalCondition <- base::signalCondition
[09:32:37.683]             sys.calls <- base::sys.calls
[09:32:37.683]             `[[` <- base::`[[`
[09:32:37.683]             `+` <- base::`+`
[09:32:37.683]             `<<-` <- base::`<<-`
[09:32:37.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.683]                   3L)]
[09:32:37.683]             }
[09:32:37.683]             function(cond) {
[09:32:37.683]                 is_error <- inherits(cond, "error")
[09:32:37.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.683]                   NULL)
[09:32:37.683]                 if (is_error) {
[09:32:37.683]                   sessionInformation <- function() {
[09:32:37.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.683]                       search = base::search(), system = base::Sys.info())
[09:32:37.683]                   }
[09:32:37.683]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.683]                     cond$call), session = sessionInformation(), 
[09:32:37.683]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.683]                   signalCondition(cond)
[09:32:37.683]                 }
[09:32:37.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.683]                 "immediateCondition"))) {
[09:32:37.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.683]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.683]                   if (TRUE && !signal) {
[09:32:37.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.683]                     {
[09:32:37.683]                       inherits <- base::inherits
[09:32:37.683]                       invokeRestart <- base::invokeRestart
[09:32:37.683]                       is.null <- base::is.null
[09:32:37.683]                       muffled <- FALSE
[09:32:37.683]                       if (inherits(cond, "message")) {
[09:32:37.683]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.683]                         if (muffled) 
[09:32:37.683]                           invokeRestart("muffleMessage")
[09:32:37.683]                       }
[09:32:37.683]                       else if (inherits(cond, "warning")) {
[09:32:37.683]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.683]                         if (muffled) 
[09:32:37.683]                           invokeRestart("muffleWarning")
[09:32:37.683]                       }
[09:32:37.683]                       else if (inherits(cond, "condition")) {
[09:32:37.683]                         if (!is.null(pattern)) {
[09:32:37.683]                           computeRestarts <- base::computeRestarts
[09:32:37.683]                           grepl <- base::grepl
[09:32:37.683]                           restarts <- computeRestarts(cond)
[09:32:37.683]                           for (restart in restarts) {
[09:32:37.683]                             name <- restart$name
[09:32:37.683]                             if (is.null(name)) 
[09:32:37.683]                               next
[09:32:37.683]                             if (!grepl(pattern, name)) 
[09:32:37.683]                               next
[09:32:37.683]                             invokeRestart(restart)
[09:32:37.683]                             muffled <- TRUE
[09:32:37.683]                             break
[09:32:37.683]                           }
[09:32:37.683]                         }
[09:32:37.683]                       }
[09:32:37.683]                       invisible(muffled)
[09:32:37.683]                     }
[09:32:37.683]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.683]                   }
[09:32:37.683]                 }
[09:32:37.683]                 else {
[09:32:37.683]                   if (TRUE) {
[09:32:37.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.683]                     {
[09:32:37.683]                       inherits <- base::inherits
[09:32:37.683]                       invokeRestart <- base::invokeRestart
[09:32:37.683]                       is.null <- base::is.null
[09:32:37.683]                       muffled <- FALSE
[09:32:37.683]                       if (inherits(cond, "message")) {
[09:32:37.683]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.683]                         if (muffled) 
[09:32:37.683]                           invokeRestart("muffleMessage")
[09:32:37.683]                       }
[09:32:37.683]                       else if (inherits(cond, "warning")) {
[09:32:37.683]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.683]                         if (muffled) 
[09:32:37.683]                           invokeRestart("muffleWarning")
[09:32:37.683]                       }
[09:32:37.683]                       else if (inherits(cond, "condition")) {
[09:32:37.683]                         if (!is.null(pattern)) {
[09:32:37.683]                           computeRestarts <- base::computeRestarts
[09:32:37.683]                           grepl <- base::grepl
[09:32:37.683]                           restarts <- computeRestarts(cond)
[09:32:37.683]                           for (restart in restarts) {
[09:32:37.683]                             name <- restart$name
[09:32:37.683]                             if (is.null(name)) 
[09:32:37.683]                               next
[09:32:37.683]                             if (!grepl(pattern, name)) 
[09:32:37.683]                               next
[09:32:37.683]                             invokeRestart(restart)
[09:32:37.683]                             muffled <- TRUE
[09:32:37.683]                             break
[09:32:37.683]                           }
[09:32:37.683]                         }
[09:32:37.683]                       }
[09:32:37.683]                       invisible(muffled)
[09:32:37.683]                     }
[09:32:37.683]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.683]                   }
[09:32:37.683]                 }
[09:32:37.683]             }
[09:32:37.683]         }))
[09:32:37.683]     }, error = function(ex) {
[09:32:37.683]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.683]                 ...future.rng), started = ...future.startTime, 
[09:32:37.683]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.683]             version = "1.8"), class = "FutureResult")
[09:32:37.683]     }, finally = {
[09:32:37.683]         if (!identical(...future.workdir, getwd())) 
[09:32:37.683]             setwd(...future.workdir)
[09:32:37.683]         {
[09:32:37.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.683]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.683]             }
[09:32:37.683]             base::options(...future.oldOptions)
[09:32:37.683]             if (.Platform$OS.type == "windows") {
[09:32:37.683]                 old_names <- names(...future.oldEnvVars)
[09:32:37.683]                 envs <- base::Sys.getenv()
[09:32:37.683]                 names <- names(envs)
[09:32:37.683]                 common <- intersect(names, old_names)
[09:32:37.683]                 added <- setdiff(names, old_names)
[09:32:37.683]                 removed <- setdiff(old_names, names)
[09:32:37.683]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.683]                   envs[common]]
[09:32:37.683]                 NAMES <- toupper(changed)
[09:32:37.683]                 args <- list()
[09:32:37.683]                 for (kk in seq_along(NAMES)) {
[09:32:37.683]                   name <- changed[[kk]]
[09:32:37.683]                   NAME <- NAMES[[kk]]
[09:32:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.683]                     next
[09:32:37.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.683]                 }
[09:32:37.683]                 NAMES <- toupper(added)
[09:32:37.683]                 for (kk in seq_along(NAMES)) {
[09:32:37.683]                   name <- added[[kk]]
[09:32:37.683]                   NAME <- NAMES[[kk]]
[09:32:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.683]                     next
[09:32:37.683]                   args[[name]] <- ""
[09:32:37.683]                 }
[09:32:37.683]                 NAMES <- toupper(removed)
[09:32:37.683]                 for (kk in seq_along(NAMES)) {
[09:32:37.683]                   name <- removed[[kk]]
[09:32:37.683]                   NAME <- NAMES[[kk]]
[09:32:37.683]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.683]                     next
[09:32:37.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.683]                 }
[09:32:37.683]                 if (length(args) > 0) 
[09:32:37.683]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.683]             }
[09:32:37.683]             else {
[09:32:37.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.683]             }
[09:32:37.683]             {
[09:32:37.683]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.683]                   0L) {
[09:32:37.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.683]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.683]                   base::options(opts)
[09:32:37.683]                 }
[09:32:37.683]                 {
[09:32:37.683]                   {
[09:32:37.683]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.683]                     NULL
[09:32:37.683]                   }
[09:32:37.683]                   options(future.plan = NULL)
[09:32:37.683]                   if (is.na(NA_character_)) 
[09:32:37.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.683]                     .init = FALSE)
[09:32:37.683]                 }
[09:32:37.683]             }
[09:32:37.683]         }
[09:32:37.683]     })
[09:32:37.683]     if (TRUE) {
[09:32:37.683]         base::sink(type = "output", split = FALSE)
[09:32:37.683]         if (TRUE) {
[09:32:37.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.683]         }
[09:32:37.683]         else {
[09:32:37.683]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.683]         }
[09:32:37.683]         base::close(...future.stdout)
[09:32:37.683]         ...future.stdout <- NULL
[09:32:37.683]     }
[09:32:37.683]     ...future.result$conditions <- ...future.conditions
[09:32:37.683]     ...future.result$finished <- base::Sys.time()
[09:32:37.683]     ...future.result
[09:32:37.683] }
[09:32:37.686] MultisessionFuture started
[09:32:37.686] - Launch lazy future ... done
[09:32:37.686] run() for ‘MultisessionFuture’ ... done
[09:32:37.687] getGlobalsAndPackages() ...
[09:32:37.687] Searching for globals...
[09:32:37.688] - globals found: [1] ‘{’
[09:32:37.688] Searching for globals ... DONE
[09:32:37.688] Resolving globals: FALSE
[09:32:37.689] 
[09:32:37.689] 
[09:32:37.689] getGlobalsAndPackages() ... DONE
[09:32:37.689] run() for ‘Future’ ...
[09:32:37.689] - state: ‘created’
[09:32:37.689] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.709]   - Field: ‘node’
[09:32:37.709]   - Field: ‘label’
[09:32:37.709]   - Field: ‘local’
[09:32:37.709]   - Field: ‘owner’
[09:32:37.709]   - Field: ‘envir’
[09:32:37.709]   - Field: ‘workers’
[09:32:37.709]   - Field: ‘packages’
[09:32:37.709]   - Field: ‘gc’
[09:32:37.709]   - Field: ‘conditions’
[09:32:37.709]   - Field: ‘persistent’
[09:32:37.710]   - Field: ‘expr’
[09:32:37.710]   - Field: ‘uuid’
[09:32:37.710]   - Field: ‘seed’
[09:32:37.710]   - Field: ‘version’
[09:32:37.710]   - Field: ‘result’
[09:32:37.710]   - Field: ‘asynchronous’
[09:32:37.710]   - Field: ‘calls’
[09:32:37.710]   - Field: ‘globals’
[09:32:37.710]   - Field: ‘stdout’
[09:32:37.710]   - Field: ‘earlySignal’
[09:32:37.710]   - Field: ‘lazy’
[09:32:37.710]   - Field: ‘state’
[09:32:37.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.711] - Launch lazy future ...
[09:32:37.711] Packages needed by the future expression (n = 0): <none>
[09:32:37.711] Packages needed by future strategies (n = 0): <none>
[09:32:37.711] {
[09:32:37.711]     {
[09:32:37.711]         {
[09:32:37.711]             ...future.startTime <- base::Sys.time()
[09:32:37.711]             {
[09:32:37.711]                 {
[09:32:37.711]                   {
[09:32:37.711]                     {
[09:32:37.711]                       base::local({
[09:32:37.711]                         has_future <- base::requireNamespace("future", 
[09:32:37.711]                           quietly = TRUE)
[09:32:37.711]                         if (has_future) {
[09:32:37.711]                           ns <- base::getNamespace("future")
[09:32:37.711]                           version <- ns[[".package"]][["version"]]
[09:32:37.711]                           if (is.null(version)) 
[09:32:37.711]                             version <- utils::packageVersion("future")
[09:32:37.711]                         }
[09:32:37.711]                         else {
[09:32:37.711]                           version <- NULL
[09:32:37.711]                         }
[09:32:37.711]                         if (!has_future || version < "1.8.0") {
[09:32:37.711]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.711]                             "", base::R.version$version.string), 
[09:32:37.711]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.711]                               "release", "version")], collapse = " "), 
[09:32:37.711]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.711]                             info)
[09:32:37.711]                           info <- base::paste(info, collapse = "; ")
[09:32:37.711]                           if (!has_future) {
[09:32:37.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.711]                               info)
[09:32:37.711]                           }
[09:32:37.711]                           else {
[09:32:37.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.711]                               info, version)
[09:32:37.711]                           }
[09:32:37.711]                           base::stop(msg)
[09:32:37.711]                         }
[09:32:37.711]                       })
[09:32:37.711]                     }
[09:32:37.711]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.711]                     base::options(mc.cores = 1L)
[09:32:37.711]                   }
[09:32:37.711]                   ...future.strategy.old <- future::plan("list")
[09:32:37.711]                   options(future.plan = NULL)
[09:32:37.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.711]                 }
[09:32:37.711]                 ...future.workdir <- getwd()
[09:32:37.711]             }
[09:32:37.711]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.711]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.711]         }
[09:32:37.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.711]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.711]             base::names(...future.oldOptions))
[09:32:37.711]     }
[09:32:37.711]     if (FALSE) {
[09:32:37.711]     }
[09:32:37.711]     else {
[09:32:37.711]         if (TRUE) {
[09:32:37.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.711]                 open = "w")
[09:32:37.711]         }
[09:32:37.711]         else {
[09:32:37.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.711]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.711]         }
[09:32:37.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.711]             base::sink(type = "output", split = FALSE)
[09:32:37.711]             base::close(...future.stdout)
[09:32:37.711]         }, add = TRUE)
[09:32:37.711]     }
[09:32:37.711]     ...future.frame <- base::sys.nframe()
[09:32:37.711]     ...future.conditions <- base::list()
[09:32:37.711]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.711]     if (FALSE) {
[09:32:37.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.711]     }
[09:32:37.711]     ...future.result <- base::tryCatch({
[09:32:37.711]         base::withCallingHandlers({
[09:32:37.711]             ...future.value <- base::withVisible(base::local({
[09:32:37.711]                 ...future.makeSendCondition <- base::local({
[09:32:37.711]                   sendCondition <- NULL
[09:32:37.711]                   function(frame = 1L) {
[09:32:37.711]                     if (is.function(sendCondition)) 
[09:32:37.711]                       return(sendCondition)
[09:32:37.711]                     ns <- getNamespace("parallel")
[09:32:37.711]                     if (exists("sendData", mode = "function", 
[09:32:37.711]                       envir = ns)) {
[09:32:37.711]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.711]                         envir = ns)
[09:32:37.711]                       envir <- sys.frame(frame)
[09:32:37.711]                       master <- NULL
[09:32:37.711]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.711]                         !identical(envir, emptyenv())) {
[09:32:37.711]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.711]                           inherits = FALSE)) {
[09:32:37.711]                           master <- get("master", mode = "list", 
[09:32:37.711]                             envir = envir, inherits = FALSE)
[09:32:37.711]                           if (inherits(master, c("SOCKnode", 
[09:32:37.711]                             "SOCK0node"))) {
[09:32:37.711]                             sendCondition <<- function(cond) {
[09:32:37.711]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.711]                                 success = TRUE)
[09:32:37.711]                               parallel_sendData(master, data)
[09:32:37.711]                             }
[09:32:37.711]                             return(sendCondition)
[09:32:37.711]                           }
[09:32:37.711]                         }
[09:32:37.711]                         frame <- frame + 1L
[09:32:37.711]                         envir <- sys.frame(frame)
[09:32:37.711]                       }
[09:32:37.711]                     }
[09:32:37.711]                     sendCondition <<- function(cond) NULL
[09:32:37.711]                   }
[09:32:37.711]                 })
[09:32:37.711]                 withCallingHandlers({
[09:32:37.711]                   {
[09:32:37.711]                     2
[09:32:37.711]                   }
[09:32:37.711]                 }, immediateCondition = function(cond) {
[09:32:37.711]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.711]                   sendCondition(cond)
[09:32:37.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.711]                   {
[09:32:37.711]                     inherits <- base::inherits
[09:32:37.711]                     invokeRestart <- base::invokeRestart
[09:32:37.711]                     is.null <- base::is.null
[09:32:37.711]                     muffled <- FALSE
[09:32:37.711]                     if (inherits(cond, "message")) {
[09:32:37.711]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.711]                       if (muffled) 
[09:32:37.711]                         invokeRestart("muffleMessage")
[09:32:37.711]                     }
[09:32:37.711]                     else if (inherits(cond, "warning")) {
[09:32:37.711]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.711]                       if (muffled) 
[09:32:37.711]                         invokeRestart("muffleWarning")
[09:32:37.711]                     }
[09:32:37.711]                     else if (inherits(cond, "condition")) {
[09:32:37.711]                       if (!is.null(pattern)) {
[09:32:37.711]                         computeRestarts <- base::computeRestarts
[09:32:37.711]                         grepl <- base::grepl
[09:32:37.711]                         restarts <- computeRestarts(cond)
[09:32:37.711]                         for (restart in restarts) {
[09:32:37.711]                           name <- restart$name
[09:32:37.711]                           if (is.null(name)) 
[09:32:37.711]                             next
[09:32:37.711]                           if (!grepl(pattern, name)) 
[09:32:37.711]                             next
[09:32:37.711]                           invokeRestart(restart)
[09:32:37.711]                           muffled <- TRUE
[09:32:37.711]                           break
[09:32:37.711]                         }
[09:32:37.711]                       }
[09:32:37.711]                     }
[09:32:37.711]                     invisible(muffled)
[09:32:37.711]                   }
[09:32:37.711]                   muffleCondition(cond)
[09:32:37.711]                 })
[09:32:37.711]             }))
[09:32:37.711]             future::FutureResult(value = ...future.value$value, 
[09:32:37.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.711]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.711]                     ...future.globalenv.names))
[09:32:37.711]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.711]         }, condition = base::local({
[09:32:37.711]             c <- base::c
[09:32:37.711]             inherits <- base::inherits
[09:32:37.711]             invokeRestart <- base::invokeRestart
[09:32:37.711]             length <- base::length
[09:32:37.711]             list <- base::list
[09:32:37.711]             seq.int <- base::seq.int
[09:32:37.711]             signalCondition <- base::signalCondition
[09:32:37.711]             sys.calls <- base::sys.calls
[09:32:37.711]             `[[` <- base::`[[`
[09:32:37.711]             `+` <- base::`+`
[09:32:37.711]             `<<-` <- base::`<<-`
[09:32:37.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.711]                   3L)]
[09:32:37.711]             }
[09:32:37.711]             function(cond) {
[09:32:37.711]                 is_error <- inherits(cond, "error")
[09:32:37.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.711]                   NULL)
[09:32:37.711]                 if (is_error) {
[09:32:37.711]                   sessionInformation <- function() {
[09:32:37.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.711]                       search = base::search(), system = base::Sys.info())
[09:32:37.711]                   }
[09:32:37.711]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.711]                     cond$call), session = sessionInformation(), 
[09:32:37.711]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.711]                   signalCondition(cond)
[09:32:37.711]                 }
[09:32:37.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.711]                 "immediateCondition"))) {
[09:32:37.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.711]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.711]                   if (TRUE && !signal) {
[09:32:37.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.711]                     {
[09:32:37.711]                       inherits <- base::inherits
[09:32:37.711]                       invokeRestart <- base::invokeRestart
[09:32:37.711]                       is.null <- base::is.null
[09:32:37.711]                       muffled <- FALSE
[09:32:37.711]                       if (inherits(cond, "message")) {
[09:32:37.711]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.711]                         if (muffled) 
[09:32:37.711]                           invokeRestart("muffleMessage")
[09:32:37.711]                       }
[09:32:37.711]                       else if (inherits(cond, "warning")) {
[09:32:37.711]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.711]                         if (muffled) 
[09:32:37.711]                           invokeRestart("muffleWarning")
[09:32:37.711]                       }
[09:32:37.711]                       else if (inherits(cond, "condition")) {
[09:32:37.711]                         if (!is.null(pattern)) {
[09:32:37.711]                           computeRestarts <- base::computeRestarts
[09:32:37.711]                           grepl <- base::grepl
[09:32:37.711]                           restarts <- computeRestarts(cond)
[09:32:37.711]                           for (restart in restarts) {
[09:32:37.711]                             name <- restart$name
[09:32:37.711]                             if (is.null(name)) 
[09:32:37.711]                               next
[09:32:37.711]                             if (!grepl(pattern, name)) 
[09:32:37.711]                               next
[09:32:37.711]                             invokeRestart(restart)
[09:32:37.711]                             muffled <- TRUE
[09:32:37.711]                             break
[09:32:37.711]                           }
[09:32:37.711]                         }
[09:32:37.711]                       }
[09:32:37.711]                       invisible(muffled)
[09:32:37.711]                     }
[09:32:37.711]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.711]                   }
[09:32:37.711]                 }
[09:32:37.711]                 else {
[09:32:37.711]                   if (TRUE) {
[09:32:37.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.711]                     {
[09:32:37.711]                       inherits <- base::inherits
[09:32:37.711]                       invokeRestart <- base::invokeRestart
[09:32:37.711]                       is.null <- base::is.null
[09:32:37.711]                       muffled <- FALSE
[09:32:37.711]                       if (inherits(cond, "message")) {
[09:32:37.711]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.711]                         if (muffled) 
[09:32:37.711]                           invokeRestart("muffleMessage")
[09:32:37.711]                       }
[09:32:37.711]                       else if (inherits(cond, "warning")) {
[09:32:37.711]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.711]                         if (muffled) 
[09:32:37.711]                           invokeRestart("muffleWarning")
[09:32:37.711]                       }
[09:32:37.711]                       else if (inherits(cond, "condition")) {
[09:32:37.711]                         if (!is.null(pattern)) {
[09:32:37.711]                           computeRestarts <- base::computeRestarts
[09:32:37.711]                           grepl <- base::grepl
[09:32:37.711]                           restarts <- computeRestarts(cond)
[09:32:37.711]                           for (restart in restarts) {
[09:32:37.711]                             name <- restart$name
[09:32:37.711]                             if (is.null(name)) 
[09:32:37.711]                               next
[09:32:37.711]                             if (!grepl(pattern, name)) 
[09:32:37.711]                               next
[09:32:37.711]                             invokeRestart(restart)
[09:32:37.711]                             muffled <- TRUE
[09:32:37.711]                             break
[09:32:37.711]                           }
[09:32:37.711]                         }
[09:32:37.711]                       }
[09:32:37.711]                       invisible(muffled)
[09:32:37.711]                     }
[09:32:37.711]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.711]                   }
[09:32:37.711]                 }
[09:32:37.711]             }
[09:32:37.711]         }))
[09:32:37.711]     }, error = function(ex) {
[09:32:37.711]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.711]                 ...future.rng), started = ...future.startTime, 
[09:32:37.711]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.711]             version = "1.8"), class = "FutureResult")
[09:32:37.711]     }, finally = {
[09:32:37.711]         if (!identical(...future.workdir, getwd())) 
[09:32:37.711]             setwd(...future.workdir)
[09:32:37.711]         {
[09:32:37.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.711]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.711]             }
[09:32:37.711]             base::options(...future.oldOptions)
[09:32:37.711]             if (.Platform$OS.type == "windows") {
[09:32:37.711]                 old_names <- names(...future.oldEnvVars)
[09:32:37.711]                 envs <- base::Sys.getenv()
[09:32:37.711]                 names <- names(envs)
[09:32:37.711]                 common <- intersect(names, old_names)
[09:32:37.711]                 added <- setdiff(names, old_names)
[09:32:37.711]                 removed <- setdiff(old_names, names)
[09:32:37.711]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.711]                   envs[common]]
[09:32:37.711]                 NAMES <- toupper(changed)
[09:32:37.711]                 args <- list()
[09:32:37.711]                 for (kk in seq_along(NAMES)) {
[09:32:37.711]                   name <- changed[[kk]]
[09:32:37.711]                   NAME <- NAMES[[kk]]
[09:32:37.711]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.711]                     next
[09:32:37.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.711]                 }
[09:32:37.711]                 NAMES <- toupper(added)
[09:32:37.711]                 for (kk in seq_along(NAMES)) {
[09:32:37.711]                   name <- added[[kk]]
[09:32:37.711]                   NAME <- NAMES[[kk]]
[09:32:37.711]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.711]                     next
[09:32:37.711]                   args[[name]] <- ""
[09:32:37.711]                 }
[09:32:37.711]                 NAMES <- toupper(removed)
[09:32:37.711]                 for (kk in seq_along(NAMES)) {
[09:32:37.711]                   name <- removed[[kk]]
[09:32:37.711]                   NAME <- NAMES[[kk]]
[09:32:37.711]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.711]                     next
[09:32:37.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.711]                 }
[09:32:37.711]                 if (length(args) > 0) 
[09:32:37.711]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.711]             }
[09:32:37.711]             else {
[09:32:37.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.711]             }
[09:32:37.711]             {
[09:32:37.711]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.711]                   0L) {
[09:32:37.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.711]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.711]                   base::options(opts)
[09:32:37.711]                 }
[09:32:37.711]                 {
[09:32:37.711]                   {
[09:32:37.711]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.711]                     NULL
[09:32:37.711]                   }
[09:32:37.711]                   options(future.plan = NULL)
[09:32:37.711]                   if (is.na(NA_character_)) 
[09:32:37.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.711]                     .init = FALSE)
[09:32:37.711]                 }
[09:32:37.711]             }
[09:32:37.711]         }
[09:32:37.711]     })
[09:32:37.711]     if (TRUE) {
[09:32:37.711]         base::sink(type = "output", split = FALSE)
[09:32:37.711]         if (TRUE) {
[09:32:37.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.711]         }
[09:32:37.711]         else {
[09:32:37.711]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.711]         }
[09:32:37.711]         base::close(...future.stdout)
[09:32:37.711]         ...future.stdout <- NULL
[09:32:37.711]     }
[09:32:37.711]     ...future.result$conditions <- ...future.conditions
[09:32:37.711]     ...future.result$finished <- base::Sys.time()
[09:32:37.711]     ...future.result
[09:32:37.711] }
[09:32:37.714] MultisessionFuture started
[09:32:37.714] - Launch lazy future ... done
[09:32:37.714] run() for ‘MultisessionFuture’ ... done
[09:32:37.715] resolve() on list environment ...
[09:32:37.715]  recursive: 0
[09:32:37.715]  length: 3
[09:32:37.716]  elements: ‘a’, ‘b’, ‘c’
[09:32:37.716] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.716] - Validating connection of MultisessionFuture
[09:32:37.716] - received message: FutureResult
[09:32:37.716] - Received FutureResult
[09:32:37.717] - Erased future from FutureRegistry
[09:32:37.717] result() for ClusterFuture ...
[09:32:37.717] - result already collected: FutureResult
[09:32:37.717] result() for ClusterFuture ... done
[09:32:37.717] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.717] Future #1
[09:32:37.717]  length: 2 (resolved future 1)
[09:32:37.717] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.718] - Validating connection of MultisessionFuture
[09:32:37.718] - received message: FutureResult
[09:32:37.718] - Received FutureResult
[09:32:37.718] - Erased future from FutureRegistry
[09:32:37.718] result() for ClusterFuture ...
[09:32:37.718] - result already collected: FutureResult
[09:32:37.718] result() for ClusterFuture ... done
[09:32:37.718] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.718] Future #2
[09:32:37.718]  length: 1 (resolved future 2)
[09:32:37.719]  length: 0 (resolved future 3)
[09:32:37.719] resolve() on list environment ... DONE
[09:32:37.719] getGlobalsAndPackages() ...
[09:32:37.719] Searching for globals...
[09:32:37.720] - globals found: [1] ‘{’
[09:32:37.720] Searching for globals ... DONE
[09:32:37.720] Resolving globals: FALSE
[09:32:37.720] 
[09:32:37.720] 
[09:32:37.720] getGlobalsAndPackages() ... DONE
[09:32:37.721] run() for ‘Future’ ...
[09:32:37.721] - state: ‘created’
[09:32:37.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.735]   - Field: ‘node’
[09:32:37.735]   - Field: ‘label’
[09:32:37.735]   - Field: ‘local’
[09:32:37.735]   - Field: ‘owner’
[09:32:37.735]   - Field: ‘envir’
[09:32:37.735]   - Field: ‘workers’
[09:32:37.735]   - Field: ‘packages’
[09:32:37.735]   - Field: ‘gc’
[09:32:37.735]   - Field: ‘conditions’
[09:32:37.736]   - Field: ‘persistent’
[09:32:37.736]   - Field: ‘expr’
[09:32:37.736]   - Field: ‘uuid’
[09:32:37.736]   - Field: ‘seed’
[09:32:37.736]   - Field: ‘version’
[09:32:37.736]   - Field: ‘result’
[09:32:37.736]   - Field: ‘asynchronous’
[09:32:37.736]   - Field: ‘calls’
[09:32:37.736]   - Field: ‘globals’
[09:32:37.736]   - Field: ‘stdout’
[09:32:37.736]   - Field: ‘earlySignal’
[09:32:37.737]   - Field: ‘lazy’
[09:32:37.737]   - Field: ‘state’
[09:32:37.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.737] - Launch lazy future ...
[09:32:37.737] Packages needed by the future expression (n = 0): <none>
[09:32:37.737] Packages needed by future strategies (n = 0): <none>
[09:32:37.738] {
[09:32:37.738]     {
[09:32:37.738]         {
[09:32:37.738]             ...future.startTime <- base::Sys.time()
[09:32:37.738]             {
[09:32:37.738]                 {
[09:32:37.738]                   {
[09:32:37.738]                     {
[09:32:37.738]                       base::local({
[09:32:37.738]                         has_future <- base::requireNamespace("future", 
[09:32:37.738]                           quietly = TRUE)
[09:32:37.738]                         if (has_future) {
[09:32:37.738]                           ns <- base::getNamespace("future")
[09:32:37.738]                           version <- ns[[".package"]][["version"]]
[09:32:37.738]                           if (is.null(version)) 
[09:32:37.738]                             version <- utils::packageVersion("future")
[09:32:37.738]                         }
[09:32:37.738]                         else {
[09:32:37.738]                           version <- NULL
[09:32:37.738]                         }
[09:32:37.738]                         if (!has_future || version < "1.8.0") {
[09:32:37.738]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.738]                             "", base::R.version$version.string), 
[09:32:37.738]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.738]                               "release", "version")], collapse = " "), 
[09:32:37.738]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.738]                             info)
[09:32:37.738]                           info <- base::paste(info, collapse = "; ")
[09:32:37.738]                           if (!has_future) {
[09:32:37.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.738]                               info)
[09:32:37.738]                           }
[09:32:37.738]                           else {
[09:32:37.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.738]                               info, version)
[09:32:37.738]                           }
[09:32:37.738]                           base::stop(msg)
[09:32:37.738]                         }
[09:32:37.738]                       })
[09:32:37.738]                     }
[09:32:37.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.738]                     base::options(mc.cores = 1L)
[09:32:37.738]                   }
[09:32:37.738]                   ...future.strategy.old <- future::plan("list")
[09:32:37.738]                   options(future.plan = NULL)
[09:32:37.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.738]                 }
[09:32:37.738]                 ...future.workdir <- getwd()
[09:32:37.738]             }
[09:32:37.738]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.738]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.738]         }
[09:32:37.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.738]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.738]             base::names(...future.oldOptions))
[09:32:37.738]     }
[09:32:37.738]     if (FALSE) {
[09:32:37.738]     }
[09:32:37.738]     else {
[09:32:37.738]         if (TRUE) {
[09:32:37.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.738]                 open = "w")
[09:32:37.738]         }
[09:32:37.738]         else {
[09:32:37.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.738]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.738]         }
[09:32:37.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.738]             base::sink(type = "output", split = FALSE)
[09:32:37.738]             base::close(...future.stdout)
[09:32:37.738]         }, add = TRUE)
[09:32:37.738]     }
[09:32:37.738]     ...future.frame <- base::sys.nframe()
[09:32:37.738]     ...future.conditions <- base::list()
[09:32:37.738]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.738]     if (FALSE) {
[09:32:37.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.738]     }
[09:32:37.738]     ...future.result <- base::tryCatch({
[09:32:37.738]         base::withCallingHandlers({
[09:32:37.738]             ...future.value <- base::withVisible(base::local({
[09:32:37.738]                 ...future.makeSendCondition <- base::local({
[09:32:37.738]                   sendCondition <- NULL
[09:32:37.738]                   function(frame = 1L) {
[09:32:37.738]                     if (is.function(sendCondition)) 
[09:32:37.738]                       return(sendCondition)
[09:32:37.738]                     ns <- getNamespace("parallel")
[09:32:37.738]                     if (exists("sendData", mode = "function", 
[09:32:37.738]                       envir = ns)) {
[09:32:37.738]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.738]                         envir = ns)
[09:32:37.738]                       envir <- sys.frame(frame)
[09:32:37.738]                       master <- NULL
[09:32:37.738]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.738]                         !identical(envir, emptyenv())) {
[09:32:37.738]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.738]                           inherits = FALSE)) {
[09:32:37.738]                           master <- get("master", mode = "list", 
[09:32:37.738]                             envir = envir, inherits = FALSE)
[09:32:37.738]                           if (inherits(master, c("SOCKnode", 
[09:32:37.738]                             "SOCK0node"))) {
[09:32:37.738]                             sendCondition <<- function(cond) {
[09:32:37.738]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.738]                                 success = TRUE)
[09:32:37.738]                               parallel_sendData(master, data)
[09:32:37.738]                             }
[09:32:37.738]                             return(sendCondition)
[09:32:37.738]                           }
[09:32:37.738]                         }
[09:32:37.738]                         frame <- frame + 1L
[09:32:37.738]                         envir <- sys.frame(frame)
[09:32:37.738]                       }
[09:32:37.738]                     }
[09:32:37.738]                     sendCondition <<- function(cond) NULL
[09:32:37.738]                   }
[09:32:37.738]                 })
[09:32:37.738]                 withCallingHandlers({
[09:32:37.738]                   {
[09:32:37.738]                     1
[09:32:37.738]                   }
[09:32:37.738]                 }, immediateCondition = function(cond) {
[09:32:37.738]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.738]                   sendCondition(cond)
[09:32:37.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.738]                   {
[09:32:37.738]                     inherits <- base::inherits
[09:32:37.738]                     invokeRestart <- base::invokeRestart
[09:32:37.738]                     is.null <- base::is.null
[09:32:37.738]                     muffled <- FALSE
[09:32:37.738]                     if (inherits(cond, "message")) {
[09:32:37.738]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.738]                       if (muffled) 
[09:32:37.738]                         invokeRestart("muffleMessage")
[09:32:37.738]                     }
[09:32:37.738]                     else if (inherits(cond, "warning")) {
[09:32:37.738]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.738]                       if (muffled) 
[09:32:37.738]                         invokeRestart("muffleWarning")
[09:32:37.738]                     }
[09:32:37.738]                     else if (inherits(cond, "condition")) {
[09:32:37.738]                       if (!is.null(pattern)) {
[09:32:37.738]                         computeRestarts <- base::computeRestarts
[09:32:37.738]                         grepl <- base::grepl
[09:32:37.738]                         restarts <- computeRestarts(cond)
[09:32:37.738]                         for (restart in restarts) {
[09:32:37.738]                           name <- restart$name
[09:32:37.738]                           if (is.null(name)) 
[09:32:37.738]                             next
[09:32:37.738]                           if (!grepl(pattern, name)) 
[09:32:37.738]                             next
[09:32:37.738]                           invokeRestart(restart)
[09:32:37.738]                           muffled <- TRUE
[09:32:37.738]                           break
[09:32:37.738]                         }
[09:32:37.738]                       }
[09:32:37.738]                     }
[09:32:37.738]                     invisible(muffled)
[09:32:37.738]                   }
[09:32:37.738]                   muffleCondition(cond)
[09:32:37.738]                 })
[09:32:37.738]             }))
[09:32:37.738]             future::FutureResult(value = ...future.value$value, 
[09:32:37.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.738]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.738]                     ...future.globalenv.names))
[09:32:37.738]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.738]         }, condition = base::local({
[09:32:37.738]             c <- base::c
[09:32:37.738]             inherits <- base::inherits
[09:32:37.738]             invokeRestart <- base::invokeRestart
[09:32:37.738]             length <- base::length
[09:32:37.738]             list <- base::list
[09:32:37.738]             seq.int <- base::seq.int
[09:32:37.738]             signalCondition <- base::signalCondition
[09:32:37.738]             sys.calls <- base::sys.calls
[09:32:37.738]             `[[` <- base::`[[`
[09:32:37.738]             `+` <- base::`+`
[09:32:37.738]             `<<-` <- base::`<<-`
[09:32:37.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.738]                   3L)]
[09:32:37.738]             }
[09:32:37.738]             function(cond) {
[09:32:37.738]                 is_error <- inherits(cond, "error")
[09:32:37.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.738]                   NULL)
[09:32:37.738]                 if (is_error) {
[09:32:37.738]                   sessionInformation <- function() {
[09:32:37.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.738]                       search = base::search(), system = base::Sys.info())
[09:32:37.738]                   }
[09:32:37.738]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.738]                     cond$call), session = sessionInformation(), 
[09:32:37.738]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.738]                   signalCondition(cond)
[09:32:37.738]                 }
[09:32:37.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.738]                 "immediateCondition"))) {
[09:32:37.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.738]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.738]                   if (TRUE && !signal) {
[09:32:37.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.738]                     {
[09:32:37.738]                       inherits <- base::inherits
[09:32:37.738]                       invokeRestart <- base::invokeRestart
[09:32:37.738]                       is.null <- base::is.null
[09:32:37.738]                       muffled <- FALSE
[09:32:37.738]                       if (inherits(cond, "message")) {
[09:32:37.738]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.738]                         if (muffled) 
[09:32:37.738]                           invokeRestart("muffleMessage")
[09:32:37.738]                       }
[09:32:37.738]                       else if (inherits(cond, "warning")) {
[09:32:37.738]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.738]                         if (muffled) 
[09:32:37.738]                           invokeRestart("muffleWarning")
[09:32:37.738]                       }
[09:32:37.738]                       else if (inherits(cond, "condition")) {
[09:32:37.738]                         if (!is.null(pattern)) {
[09:32:37.738]                           computeRestarts <- base::computeRestarts
[09:32:37.738]                           grepl <- base::grepl
[09:32:37.738]                           restarts <- computeRestarts(cond)
[09:32:37.738]                           for (restart in restarts) {
[09:32:37.738]                             name <- restart$name
[09:32:37.738]                             if (is.null(name)) 
[09:32:37.738]                               next
[09:32:37.738]                             if (!grepl(pattern, name)) 
[09:32:37.738]                               next
[09:32:37.738]                             invokeRestart(restart)
[09:32:37.738]                             muffled <- TRUE
[09:32:37.738]                             break
[09:32:37.738]                           }
[09:32:37.738]                         }
[09:32:37.738]                       }
[09:32:37.738]                       invisible(muffled)
[09:32:37.738]                     }
[09:32:37.738]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.738]                   }
[09:32:37.738]                 }
[09:32:37.738]                 else {
[09:32:37.738]                   if (TRUE) {
[09:32:37.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.738]                     {
[09:32:37.738]                       inherits <- base::inherits
[09:32:37.738]                       invokeRestart <- base::invokeRestart
[09:32:37.738]                       is.null <- base::is.null
[09:32:37.738]                       muffled <- FALSE
[09:32:37.738]                       if (inherits(cond, "message")) {
[09:32:37.738]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.738]                         if (muffled) 
[09:32:37.738]                           invokeRestart("muffleMessage")
[09:32:37.738]                       }
[09:32:37.738]                       else if (inherits(cond, "warning")) {
[09:32:37.738]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.738]                         if (muffled) 
[09:32:37.738]                           invokeRestart("muffleWarning")
[09:32:37.738]                       }
[09:32:37.738]                       else if (inherits(cond, "condition")) {
[09:32:37.738]                         if (!is.null(pattern)) {
[09:32:37.738]                           computeRestarts <- base::computeRestarts
[09:32:37.738]                           grepl <- base::grepl
[09:32:37.738]                           restarts <- computeRestarts(cond)
[09:32:37.738]                           for (restart in restarts) {
[09:32:37.738]                             name <- restart$name
[09:32:37.738]                             if (is.null(name)) 
[09:32:37.738]                               next
[09:32:37.738]                             if (!grepl(pattern, name)) 
[09:32:37.738]                               next
[09:32:37.738]                             invokeRestart(restart)
[09:32:37.738]                             muffled <- TRUE
[09:32:37.738]                             break
[09:32:37.738]                           }
[09:32:37.738]                         }
[09:32:37.738]                       }
[09:32:37.738]                       invisible(muffled)
[09:32:37.738]                     }
[09:32:37.738]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.738]                   }
[09:32:37.738]                 }
[09:32:37.738]             }
[09:32:37.738]         }))
[09:32:37.738]     }, error = function(ex) {
[09:32:37.738]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.738]                 ...future.rng), started = ...future.startTime, 
[09:32:37.738]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.738]             version = "1.8"), class = "FutureResult")
[09:32:37.738]     }, finally = {
[09:32:37.738]         if (!identical(...future.workdir, getwd())) 
[09:32:37.738]             setwd(...future.workdir)
[09:32:37.738]         {
[09:32:37.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.738]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.738]             }
[09:32:37.738]             base::options(...future.oldOptions)
[09:32:37.738]             if (.Platform$OS.type == "windows") {
[09:32:37.738]                 old_names <- names(...future.oldEnvVars)
[09:32:37.738]                 envs <- base::Sys.getenv()
[09:32:37.738]                 names <- names(envs)
[09:32:37.738]                 common <- intersect(names, old_names)
[09:32:37.738]                 added <- setdiff(names, old_names)
[09:32:37.738]                 removed <- setdiff(old_names, names)
[09:32:37.738]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.738]                   envs[common]]
[09:32:37.738]                 NAMES <- toupper(changed)
[09:32:37.738]                 args <- list()
[09:32:37.738]                 for (kk in seq_along(NAMES)) {
[09:32:37.738]                   name <- changed[[kk]]
[09:32:37.738]                   NAME <- NAMES[[kk]]
[09:32:37.738]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.738]                     next
[09:32:37.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.738]                 }
[09:32:37.738]                 NAMES <- toupper(added)
[09:32:37.738]                 for (kk in seq_along(NAMES)) {
[09:32:37.738]                   name <- added[[kk]]
[09:32:37.738]                   NAME <- NAMES[[kk]]
[09:32:37.738]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.738]                     next
[09:32:37.738]                   args[[name]] <- ""
[09:32:37.738]                 }
[09:32:37.738]                 NAMES <- toupper(removed)
[09:32:37.738]                 for (kk in seq_along(NAMES)) {
[09:32:37.738]                   name <- removed[[kk]]
[09:32:37.738]                   NAME <- NAMES[[kk]]
[09:32:37.738]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.738]                     next
[09:32:37.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.738]                 }
[09:32:37.738]                 if (length(args) > 0) 
[09:32:37.738]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.738]             }
[09:32:37.738]             else {
[09:32:37.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.738]             }
[09:32:37.738]             {
[09:32:37.738]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.738]                   0L) {
[09:32:37.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.738]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.738]                   base::options(opts)
[09:32:37.738]                 }
[09:32:37.738]                 {
[09:32:37.738]                   {
[09:32:37.738]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.738]                     NULL
[09:32:37.738]                   }
[09:32:37.738]                   options(future.plan = NULL)
[09:32:37.738]                   if (is.na(NA_character_)) 
[09:32:37.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.738]                     .init = FALSE)
[09:32:37.738]                 }
[09:32:37.738]             }
[09:32:37.738]         }
[09:32:37.738]     })
[09:32:37.738]     if (TRUE) {
[09:32:37.738]         base::sink(type = "output", split = FALSE)
[09:32:37.738]         if (TRUE) {
[09:32:37.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.738]         }
[09:32:37.738]         else {
[09:32:37.738]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.738]         }
[09:32:37.738]         base::close(...future.stdout)
[09:32:37.738]         ...future.stdout <- NULL
[09:32:37.738]     }
[09:32:37.738]     ...future.result$conditions <- ...future.conditions
[09:32:37.738]     ...future.result$finished <- base::Sys.time()
[09:32:37.738]     ...future.result
[09:32:37.738] }
[09:32:37.740] MultisessionFuture started
[09:32:37.740] - Launch lazy future ... done
[09:32:37.741] run() for ‘MultisessionFuture’ ... done
[09:32:37.741] getGlobalsAndPackages() ...
[09:32:37.741] Searching for globals...
[09:32:37.742] - globals found: [2] ‘{’, ‘Sys.sleep’
[09:32:37.742] Searching for globals ... DONE
[09:32:37.742] Resolving globals: FALSE
[09:32:37.742] 
[09:32:37.742] 
[09:32:37.742] getGlobalsAndPackages() ... DONE
[09:32:37.743] run() for ‘Future’ ...
[09:32:37.743] - state: ‘created’
[09:32:37.743] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.758] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.758]   - Field: ‘node’
[09:32:37.758]   - Field: ‘label’
[09:32:37.759]   - Field: ‘local’
[09:32:37.759]   - Field: ‘owner’
[09:32:37.759]   - Field: ‘envir’
[09:32:37.759]   - Field: ‘workers’
[09:32:37.759]   - Field: ‘packages’
[09:32:37.759]   - Field: ‘gc’
[09:32:37.759]   - Field: ‘conditions’
[09:32:37.759]   - Field: ‘persistent’
[09:32:37.759]   - Field: ‘expr’
[09:32:37.759]   - Field: ‘uuid’
[09:32:37.759]   - Field: ‘seed’
[09:32:37.760]   - Field: ‘version’
[09:32:37.760]   - Field: ‘result’
[09:32:37.760]   - Field: ‘asynchronous’
[09:32:37.760]   - Field: ‘calls’
[09:32:37.760]   - Field: ‘globals’
[09:32:37.760]   - Field: ‘stdout’
[09:32:37.760]   - Field: ‘earlySignal’
[09:32:37.760]   - Field: ‘lazy’
[09:32:37.760]   - Field: ‘state’
[09:32:37.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.761] - Launch lazy future ...
[09:32:37.761] Packages needed by the future expression (n = 0): <none>
[09:32:37.761] Packages needed by future strategies (n = 0): <none>
[09:32:37.761] {
[09:32:37.761]     {
[09:32:37.761]         {
[09:32:37.761]             ...future.startTime <- base::Sys.time()
[09:32:37.761]             {
[09:32:37.761]                 {
[09:32:37.761]                   {
[09:32:37.761]                     {
[09:32:37.761]                       base::local({
[09:32:37.761]                         has_future <- base::requireNamespace("future", 
[09:32:37.761]                           quietly = TRUE)
[09:32:37.761]                         if (has_future) {
[09:32:37.761]                           ns <- base::getNamespace("future")
[09:32:37.761]                           version <- ns[[".package"]][["version"]]
[09:32:37.761]                           if (is.null(version)) 
[09:32:37.761]                             version <- utils::packageVersion("future")
[09:32:37.761]                         }
[09:32:37.761]                         else {
[09:32:37.761]                           version <- NULL
[09:32:37.761]                         }
[09:32:37.761]                         if (!has_future || version < "1.8.0") {
[09:32:37.761]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.761]                             "", base::R.version$version.string), 
[09:32:37.761]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.761]                               "release", "version")], collapse = " "), 
[09:32:37.761]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.761]                             info)
[09:32:37.761]                           info <- base::paste(info, collapse = "; ")
[09:32:37.761]                           if (!has_future) {
[09:32:37.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.761]                               info)
[09:32:37.761]                           }
[09:32:37.761]                           else {
[09:32:37.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.761]                               info, version)
[09:32:37.761]                           }
[09:32:37.761]                           base::stop(msg)
[09:32:37.761]                         }
[09:32:37.761]                       })
[09:32:37.761]                     }
[09:32:37.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.761]                     base::options(mc.cores = 1L)
[09:32:37.761]                   }
[09:32:37.761]                   ...future.strategy.old <- future::plan("list")
[09:32:37.761]                   options(future.plan = NULL)
[09:32:37.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.761]                 }
[09:32:37.761]                 ...future.workdir <- getwd()
[09:32:37.761]             }
[09:32:37.761]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.761]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.761]         }
[09:32:37.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.761]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.761]             base::names(...future.oldOptions))
[09:32:37.761]     }
[09:32:37.761]     if (FALSE) {
[09:32:37.761]     }
[09:32:37.761]     else {
[09:32:37.761]         if (TRUE) {
[09:32:37.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.761]                 open = "w")
[09:32:37.761]         }
[09:32:37.761]         else {
[09:32:37.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.761]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.761]         }
[09:32:37.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.761]             base::sink(type = "output", split = FALSE)
[09:32:37.761]             base::close(...future.stdout)
[09:32:37.761]         }, add = TRUE)
[09:32:37.761]     }
[09:32:37.761]     ...future.frame <- base::sys.nframe()
[09:32:37.761]     ...future.conditions <- base::list()
[09:32:37.761]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.761]     if (FALSE) {
[09:32:37.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.761]     }
[09:32:37.761]     ...future.result <- base::tryCatch({
[09:32:37.761]         base::withCallingHandlers({
[09:32:37.761]             ...future.value <- base::withVisible(base::local({
[09:32:37.761]                 ...future.makeSendCondition <- base::local({
[09:32:37.761]                   sendCondition <- NULL
[09:32:37.761]                   function(frame = 1L) {
[09:32:37.761]                     if (is.function(sendCondition)) 
[09:32:37.761]                       return(sendCondition)
[09:32:37.761]                     ns <- getNamespace("parallel")
[09:32:37.761]                     if (exists("sendData", mode = "function", 
[09:32:37.761]                       envir = ns)) {
[09:32:37.761]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.761]                         envir = ns)
[09:32:37.761]                       envir <- sys.frame(frame)
[09:32:37.761]                       master <- NULL
[09:32:37.761]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.761]                         !identical(envir, emptyenv())) {
[09:32:37.761]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.761]                           inherits = FALSE)) {
[09:32:37.761]                           master <- get("master", mode = "list", 
[09:32:37.761]                             envir = envir, inherits = FALSE)
[09:32:37.761]                           if (inherits(master, c("SOCKnode", 
[09:32:37.761]                             "SOCK0node"))) {
[09:32:37.761]                             sendCondition <<- function(cond) {
[09:32:37.761]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.761]                                 success = TRUE)
[09:32:37.761]                               parallel_sendData(master, data)
[09:32:37.761]                             }
[09:32:37.761]                             return(sendCondition)
[09:32:37.761]                           }
[09:32:37.761]                         }
[09:32:37.761]                         frame <- frame + 1L
[09:32:37.761]                         envir <- sys.frame(frame)
[09:32:37.761]                       }
[09:32:37.761]                     }
[09:32:37.761]                     sendCondition <<- function(cond) NULL
[09:32:37.761]                   }
[09:32:37.761]                 })
[09:32:37.761]                 withCallingHandlers({
[09:32:37.761]                   {
[09:32:37.761]                     Sys.sleep(0.5)
[09:32:37.761]                     2
[09:32:37.761]                   }
[09:32:37.761]                 }, immediateCondition = function(cond) {
[09:32:37.761]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.761]                   sendCondition(cond)
[09:32:37.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.761]                   {
[09:32:37.761]                     inherits <- base::inherits
[09:32:37.761]                     invokeRestart <- base::invokeRestart
[09:32:37.761]                     is.null <- base::is.null
[09:32:37.761]                     muffled <- FALSE
[09:32:37.761]                     if (inherits(cond, "message")) {
[09:32:37.761]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.761]                       if (muffled) 
[09:32:37.761]                         invokeRestart("muffleMessage")
[09:32:37.761]                     }
[09:32:37.761]                     else if (inherits(cond, "warning")) {
[09:32:37.761]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.761]                       if (muffled) 
[09:32:37.761]                         invokeRestart("muffleWarning")
[09:32:37.761]                     }
[09:32:37.761]                     else if (inherits(cond, "condition")) {
[09:32:37.761]                       if (!is.null(pattern)) {
[09:32:37.761]                         computeRestarts <- base::computeRestarts
[09:32:37.761]                         grepl <- base::grepl
[09:32:37.761]                         restarts <- computeRestarts(cond)
[09:32:37.761]                         for (restart in restarts) {
[09:32:37.761]                           name <- restart$name
[09:32:37.761]                           if (is.null(name)) 
[09:32:37.761]                             next
[09:32:37.761]                           if (!grepl(pattern, name)) 
[09:32:37.761]                             next
[09:32:37.761]                           invokeRestart(restart)
[09:32:37.761]                           muffled <- TRUE
[09:32:37.761]                           break
[09:32:37.761]                         }
[09:32:37.761]                       }
[09:32:37.761]                     }
[09:32:37.761]                     invisible(muffled)
[09:32:37.761]                   }
[09:32:37.761]                   muffleCondition(cond)
[09:32:37.761]                 })
[09:32:37.761]             }))
[09:32:37.761]             future::FutureResult(value = ...future.value$value, 
[09:32:37.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.761]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.761]                     ...future.globalenv.names))
[09:32:37.761]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.761]         }, condition = base::local({
[09:32:37.761]             c <- base::c
[09:32:37.761]             inherits <- base::inherits
[09:32:37.761]             invokeRestart <- base::invokeRestart
[09:32:37.761]             length <- base::length
[09:32:37.761]             list <- base::list
[09:32:37.761]             seq.int <- base::seq.int
[09:32:37.761]             signalCondition <- base::signalCondition
[09:32:37.761]             sys.calls <- base::sys.calls
[09:32:37.761]             `[[` <- base::`[[`
[09:32:37.761]             `+` <- base::`+`
[09:32:37.761]             `<<-` <- base::`<<-`
[09:32:37.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.761]                   3L)]
[09:32:37.761]             }
[09:32:37.761]             function(cond) {
[09:32:37.761]                 is_error <- inherits(cond, "error")
[09:32:37.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.761]                   NULL)
[09:32:37.761]                 if (is_error) {
[09:32:37.761]                   sessionInformation <- function() {
[09:32:37.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.761]                       search = base::search(), system = base::Sys.info())
[09:32:37.761]                   }
[09:32:37.761]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.761]                     cond$call), session = sessionInformation(), 
[09:32:37.761]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.761]                   signalCondition(cond)
[09:32:37.761]                 }
[09:32:37.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.761]                 "immediateCondition"))) {
[09:32:37.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.761]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.761]                   if (TRUE && !signal) {
[09:32:37.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.761]                     {
[09:32:37.761]                       inherits <- base::inherits
[09:32:37.761]                       invokeRestart <- base::invokeRestart
[09:32:37.761]                       is.null <- base::is.null
[09:32:37.761]                       muffled <- FALSE
[09:32:37.761]                       if (inherits(cond, "message")) {
[09:32:37.761]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.761]                         if (muffled) 
[09:32:37.761]                           invokeRestart("muffleMessage")
[09:32:37.761]                       }
[09:32:37.761]                       else if (inherits(cond, "warning")) {
[09:32:37.761]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.761]                         if (muffled) 
[09:32:37.761]                           invokeRestart("muffleWarning")
[09:32:37.761]                       }
[09:32:37.761]                       else if (inherits(cond, "condition")) {
[09:32:37.761]                         if (!is.null(pattern)) {
[09:32:37.761]                           computeRestarts <- base::computeRestarts
[09:32:37.761]                           grepl <- base::grepl
[09:32:37.761]                           restarts <- computeRestarts(cond)
[09:32:37.761]                           for (restart in restarts) {
[09:32:37.761]                             name <- restart$name
[09:32:37.761]                             if (is.null(name)) 
[09:32:37.761]                               next
[09:32:37.761]                             if (!grepl(pattern, name)) 
[09:32:37.761]                               next
[09:32:37.761]                             invokeRestart(restart)
[09:32:37.761]                             muffled <- TRUE
[09:32:37.761]                             break
[09:32:37.761]                           }
[09:32:37.761]                         }
[09:32:37.761]                       }
[09:32:37.761]                       invisible(muffled)
[09:32:37.761]                     }
[09:32:37.761]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.761]                   }
[09:32:37.761]                 }
[09:32:37.761]                 else {
[09:32:37.761]                   if (TRUE) {
[09:32:37.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.761]                     {
[09:32:37.761]                       inherits <- base::inherits
[09:32:37.761]                       invokeRestart <- base::invokeRestart
[09:32:37.761]                       is.null <- base::is.null
[09:32:37.761]                       muffled <- FALSE
[09:32:37.761]                       if (inherits(cond, "message")) {
[09:32:37.761]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.761]                         if (muffled) 
[09:32:37.761]                           invokeRestart("muffleMessage")
[09:32:37.761]                       }
[09:32:37.761]                       else if (inherits(cond, "warning")) {
[09:32:37.761]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.761]                         if (muffled) 
[09:32:37.761]                           invokeRestart("muffleWarning")
[09:32:37.761]                       }
[09:32:37.761]                       else if (inherits(cond, "condition")) {
[09:32:37.761]                         if (!is.null(pattern)) {
[09:32:37.761]                           computeRestarts <- base::computeRestarts
[09:32:37.761]                           grepl <- base::grepl
[09:32:37.761]                           restarts <- computeRestarts(cond)
[09:32:37.761]                           for (restart in restarts) {
[09:32:37.761]                             name <- restart$name
[09:32:37.761]                             if (is.null(name)) 
[09:32:37.761]                               next
[09:32:37.761]                             if (!grepl(pattern, name)) 
[09:32:37.761]                               next
[09:32:37.761]                             invokeRestart(restart)
[09:32:37.761]                             muffled <- TRUE
[09:32:37.761]                             break
[09:32:37.761]                           }
[09:32:37.761]                         }
[09:32:37.761]                       }
[09:32:37.761]                       invisible(muffled)
[09:32:37.761]                     }
[09:32:37.761]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.761]                   }
[09:32:37.761]                 }
[09:32:37.761]             }
[09:32:37.761]         }))
[09:32:37.761]     }, error = function(ex) {
[09:32:37.761]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.761]                 ...future.rng), started = ...future.startTime, 
[09:32:37.761]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.761]             version = "1.8"), class = "FutureResult")
[09:32:37.761]     }, finally = {
[09:32:37.761]         if (!identical(...future.workdir, getwd())) 
[09:32:37.761]             setwd(...future.workdir)
[09:32:37.761]         {
[09:32:37.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.761]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.761]             }
[09:32:37.761]             base::options(...future.oldOptions)
[09:32:37.761]             if (.Platform$OS.type == "windows") {
[09:32:37.761]                 old_names <- names(...future.oldEnvVars)
[09:32:37.761]                 envs <- base::Sys.getenv()
[09:32:37.761]                 names <- names(envs)
[09:32:37.761]                 common <- intersect(names, old_names)
[09:32:37.761]                 added <- setdiff(names, old_names)
[09:32:37.761]                 removed <- setdiff(old_names, names)
[09:32:37.761]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.761]                   envs[common]]
[09:32:37.761]                 NAMES <- toupper(changed)
[09:32:37.761]                 args <- list()
[09:32:37.761]                 for (kk in seq_along(NAMES)) {
[09:32:37.761]                   name <- changed[[kk]]
[09:32:37.761]                   NAME <- NAMES[[kk]]
[09:32:37.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.761]                     next
[09:32:37.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.761]                 }
[09:32:37.761]                 NAMES <- toupper(added)
[09:32:37.761]                 for (kk in seq_along(NAMES)) {
[09:32:37.761]                   name <- added[[kk]]
[09:32:37.761]                   NAME <- NAMES[[kk]]
[09:32:37.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.761]                     next
[09:32:37.761]                   args[[name]] <- ""
[09:32:37.761]                 }
[09:32:37.761]                 NAMES <- toupper(removed)
[09:32:37.761]                 for (kk in seq_along(NAMES)) {
[09:32:37.761]                   name <- removed[[kk]]
[09:32:37.761]                   NAME <- NAMES[[kk]]
[09:32:37.761]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.761]                     next
[09:32:37.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.761]                 }
[09:32:37.761]                 if (length(args) > 0) 
[09:32:37.761]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.761]             }
[09:32:37.761]             else {
[09:32:37.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.761]             }
[09:32:37.761]             {
[09:32:37.761]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.761]                   0L) {
[09:32:37.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.761]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.761]                   base::options(opts)
[09:32:37.761]                 }
[09:32:37.761]                 {
[09:32:37.761]                   {
[09:32:37.761]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.761]                     NULL
[09:32:37.761]                   }
[09:32:37.761]                   options(future.plan = NULL)
[09:32:37.761]                   if (is.na(NA_character_)) 
[09:32:37.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.761]                     .init = FALSE)
[09:32:37.761]                 }
[09:32:37.761]             }
[09:32:37.761]         }
[09:32:37.761]     })
[09:32:37.761]     if (TRUE) {
[09:32:37.761]         base::sink(type = "output", split = FALSE)
[09:32:37.761]         if (TRUE) {
[09:32:37.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.761]         }
[09:32:37.761]         else {
[09:32:37.761]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.761]         }
[09:32:37.761]         base::close(...future.stdout)
[09:32:37.761]         ...future.stdout <- NULL
[09:32:37.761]     }
[09:32:37.761]     ...future.result$conditions <- ...future.conditions
[09:32:37.761]     ...future.result$finished <- base::Sys.time()
[09:32:37.761]     ...future.result
[09:32:37.761] }
[09:32:37.764] MultisessionFuture started
[09:32:37.764] - Launch lazy future ... done
[09:32:37.764] run() for ‘MultisessionFuture’ ... done
[09:32:37.765] getGlobalsAndPackages() ...
[09:32:37.765] Searching for globals...
[09:32:37.765] - globals found: [1] ‘{’
[09:32:37.765] Searching for globals ... DONE
[09:32:37.766] Resolving globals: FALSE
[09:32:37.766] 
[09:32:37.766] 
[09:32:37.766] getGlobalsAndPackages() ... DONE
[09:32:37.766] run() for ‘Future’ ...
[09:32:37.766] - state: ‘created’
[09:32:37.766] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[09:32:37.779] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[09:32:37.780] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[09:32:37.780]   - Field: ‘node’
[09:32:37.780]   - Field: ‘label’
[09:32:37.780]   - Field: ‘local’
[09:32:37.780]   - Field: ‘owner’
[09:32:37.780]   - Field: ‘envir’
[09:32:37.780]   - Field: ‘workers’
[09:32:37.780]   - Field: ‘packages’
[09:32:37.780]   - Field: ‘gc’
[09:32:37.780]   - Field: ‘conditions’
[09:32:37.781]   - Field: ‘persistent’
[09:32:37.781]   - Field: ‘expr’
[09:32:37.781]   - Field: ‘uuid’
[09:32:37.781]   - Field: ‘seed’
[09:32:37.781]   - Field: ‘version’
[09:32:37.781]   - Field: ‘result’
[09:32:37.781]   - Field: ‘asynchronous’
[09:32:37.781]   - Field: ‘calls’
[09:32:37.781]   - Field: ‘globals’
[09:32:37.781]   - Field: ‘stdout’
[09:32:37.781]   - Field: ‘earlySignal’
[09:32:37.782]   - Field: ‘lazy’
[09:32:37.782]   - Field: ‘state’
[09:32:37.782] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[09:32:37.782] - Launch lazy future ...
[09:32:37.782] Packages needed by the future expression (n = 0): <none>
[09:32:37.782] Packages needed by future strategies (n = 0): <none>
[09:32:37.783] {
[09:32:37.783]     {
[09:32:37.783]         {
[09:32:37.783]             ...future.startTime <- base::Sys.time()
[09:32:37.783]             {
[09:32:37.783]                 {
[09:32:37.783]                   {
[09:32:37.783]                     {
[09:32:37.783]                       base::local({
[09:32:37.783]                         has_future <- base::requireNamespace("future", 
[09:32:37.783]                           quietly = TRUE)
[09:32:37.783]                         if (has_future) {
[09:32:37.783]                           ns <- base::getNamespace("future")
[09:32:37.783]                           version <- ns[[".package"]][["version"]]
[09:32:37.783]                           if (is.null(version)) 
[09:32:37.783]                             version <- utils::packageVersion("future")
[09:32:37.783]                         }
[09:32:37.783]                         else {
[09:32:37.783]                           version <- NULL
[09:32:37.783]                         }
[09:32:37.783]                         if (!has_future || version < "1.8.0") {
[09:32:37.783]                           info <- base::c(r_version = base::gsub("R version ", 
[09:32:37.783]                             "", base::R.version$version.string), 
[09:32:37.783]                             platform = base::sprintf("%s (%s-bit)", 
[09:32:37.783]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[09:32:37.783]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[09:32:37.783]                               "release", "version")], collapse = " "), 
[09:32:37.783]                             hostname = base::Sys.info()[["nodename"]])
[09:32:37.783]                           info <- base::sprintf("%s: %s", base::names(info), 
[09:32:37.783]                             info)
[09:32:37.783]                           info <- base::paste(info, collapse = "; ")
[09:32:37.783]                           if (!has_future) {
[09:32:37.783]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[09:32:37.783]                               info)
[09:32:37.783]                           }
[09:32:37.783]                           else {
[09:32:37.783]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[09:32:37.783]                               info, version)
[09:32:37.783]                           }
[09:32:37.783]                           base::stop(msg)
[09:32:37.783]                         }
[09:32:37.783]                       })
[09:32:37.783]                     }
[09:32:37.783]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[09:32:37.783]                     base::options(mc.cores = 1L)
[09:32:37.783]                   }
[09:32:37.783]                   ...future.strategy.old <- future::plan("list")
[09:32:37.783]                   options(future.plan = NULL)
[09:32:37.783]                   Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.783]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[09:32:37.783]                 }
[09:32:37.783]                 ...future.workdir <- getwd()
[09:32:37.783]             }
[09:32:37.783]             ...future.oldOptions <- base::as.list(base::.Options)
[09:32:37.783]             ...future.oldEnvVars <- base::Sys.getenv()
[09:32:37.783]         }
[09:32:37.783]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[09:32:37.783]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[09:32:37.783]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[09:32:37.783]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[09:32:37.783]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[09:32:37.783]             future.stdout.windows.reencode = NULL, width = 80L)
[09:32:37.783]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[09:32:37.783]             base::names(...future.oldOptions))
[09:32:37.783]     }
[09:32:37.783]     if (FALSE) {
[09:32:37.783]     }
[09:32:37.783]     else {
[09:32:37.783]         if (TRUE) {
[09:32:37.783]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[09:32:37.783]                 open = "w")
[09:32:37.783]         }
[09:32:37.783]         else {
[09:32:37.783]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[09:32:37.783]                 windows = "NUL", "/dev/null"), open = "w")
[09:32:37.783]         }
[09:32:37.783]         base::sink(...future.stdout, type = "output", split = FALSE)
[09:32:37.783]         base::on.exit(if (!base::is.null(...future.stdout)) {
[09:32:37.783]             base::sink(type = "output", split = FALSE)
[09:32:37.783]             base::close(...future.stdout)
[09:32:37.783]         }, add = TRUE)
[09:32:37.783]     }
[09:32:37.783]     ...future.frame <- base::sys.nframe()
[09:32:37.783]     ...future.conditions <- base::list()
[09:32:37.783]     ...future.rng <- base::globalenv()$.Random.seed
[09:32:37.783]     if (FALSE) {
[09:32:37.783]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[09:32:37.783]             "...future.value", "...future.globalenv.names", ".Random.seed")
[09:32:37.783]     }
[09:32:37.783]     ...future.result <- base::tryCatch({
[09:32:37.783]         base::withCallingHandlers({
[09:32:37.783]             ...future.value <- base::withVisible(base::local({
[09:32:37.783]                 ...future.makeSendCondition <- base::local({
[09:32:37.783]                   sendCondition <- NULL
[09:32:37.783]                   function(frame = 1L) {
[09:32:37.783]                     if (is.function(sendCondition)) 
[09:32:37.783]                       return(sendCondition)
[09:32:37.783]                     ns <- getNamespace("parallel")
[09:32:37.783]                     if (exists("sendData", mode = "function", 
[09:32:37.783]                       envir = ns)) {
[09:32:37.783]                       parallel_sendData <- get("sendData", mode = "function", 
[09:32:37.783]                         envir = ns)
[09:32:37.783]                       envir <- sys.frame(frame)
[09:32:37.783]                       master <- NULL
[09:32:37.783]                       while (!identical(envir, .GlobalEnv) && 
[09:32:37.783]                         !identical(envir, emptyenv())) {
[09:32:37.783]                         if (exists("master", mode = "list", envir = envir, 
[09:32:37.783]                           inherits = FALSE)) {
[09:32:37.783]                           master <- get("master", mode = "list", 
[09:32:37.783]                             envir = envir, inherits = FALSE)
[09:32:37.783]                           if (inherits(master, c("SOCKnode", 
[09:32:37.783]                             "SOCK0node"))) {
[09:32:37.783]                             sendCondition <<- function(cond) {
[09:32:37.783]                               data <- list(type = "VALUE", value = cond, 
[09:32:37.783]                                 success = TRUE)
[09:32:37.783]                               parallel_sendData(master, data)
[09:32:37.783]                             }
[09:32:37.783]                             return(sendCondition)
[09:32:37.783]                           }
[09:32:37.783]                         }
[09:32:37.783]                         frame <- frame + 1L
[09:32:37.783]                         envir <- sys.frame(frame)
[09:32:37.783]                       }
[09:32:37.783]                     }
[09:32:37.783]                     sendCondition <<- function(cond) NULL
[09:32:37.783]                   }
[09:32:37.783]                 })
[09:32:37.783]                 withCallingHandlers({
[09:32:37.783]                   {
[09:32:37.783]                     3
[09:32:37.783]                   }
[09:32:37.783]                 }, immediateCondition = function(cond) {
[09:32:37.783]                   sendCondition <- ...future.makeSendCondition()
[09:32:37.783]                   sendCondition(cond)
[09:32:37.783]                   muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.783]                   {
[09:32:37.783]                     inherits <- base::inherits
[09:32:37.783]                     invokeRestart <- base::invokeRestart
[09:32:37.783]                     is.null <- base::is.null
[09:32:37.783]                     muffled <- FALSE
[09:32:37.783]                     if (inherits(cond, "message")) {
[09:32:37.783]                       muffled <- grepl(pattern, "muffleMessage")
[09:32:37.783]                       if (muffled) 
[09:32:37.783]                         invokeRestart("muffleMessage")
[09:32:37.783]                     }
[09:32:37.783]                     else if (inherits(cond, "warning")) {
[09:32:37.783]                       muffled <- grepl(pattern, "muffleWarning")
[09:32:37.783]                       if (muffled) 
[09:32:37.783]                         invokeRestart("muffleWarning")
[09:32:37.783]                     }
[09:32:37.783]                     else if (inherits(cond, "condition")) {
[09:32:37.783]                       if (!is.null(pattern)) {
[09:32:37.783]                         computeRestarts <- base::computeRestarts
[09:32:37.783]                         grepl <- base::grepl
[09:32:37.783]                         restarts <- computeRestarts(cond)
[09:32:37.783]                         for (restart in restarts) {
[09:32:37.783]                           name <- restart$name
[09:32:37.783]                           if (is.null(name)) 
[09:32:37.783]                             next
[09:32:37.783]                           if (!grepl(pattern, name)) 
[09:32:37.783]                             next
[09:32:37.783]                           invokeRestart(restart)
[09:32:37.783]                           muffled <- TRUE
[09:32:37.783]                           break
[09:32:37.783]                         }
[09:32:37.783]                       }
[09:32:37.783]                     }
[09:32:37.783]                     invisible(muffled)
[09:32:37.783]                   }
[09:32:37.783]                   muffleCondition(cond)
[09:32:37.783]                 })
[09:32:37.783]             }))
[09:32:37.783]             future::FutureResult(value = ...future.value$value, 
[09:32:37.783]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.783]                   ...future.rng), globalenv = if (FALSE) 
[09:32:37.783]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[09:32:37.783]                     ...future.globalenv.names))
[09:32:37.783]                 else NULL, started = ...future.startTime, version = "1.8")
[09:32:37.783]         }, condition = base::local({
[09:32:37.783]             c <- base::c
[09:32:37.783]             inherits <- base::inherits
[09:32:37.783]             invokeRestart <- base::invokeRestart
[09:32:37.783]             length <- base::length
[09:32:37.783]             list <- base::list
[09:32:37.783]             seq.int <- base::seq.int
[09:32:37.783]             signalCondition <- base::signalCondition
[09:32:37.783]             sys.calls <- base::sys.calls
[09:32:37.783]             `[[` <- base::`[[`
[09:32:37.783]             `+` <- base::`+`
[09:32:37.783]             `<<-` <- base::`<<-`
[09:32:37.783]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[09:32:37.783]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[09:32:37.783]                   3L)]
[09:32:37.783]             }
[09:32:37.783]             function(cond) {
[09:32:37.783]                 is_error <- inherits(cond, "error")
[09:32:37.783]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[09:32:37.783]                   NULL)
[09:32:37.783]                 if (is_error) {
[09:32:37.783]                   sessionInformation <- function() {
[09:32:37.783]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[09:32:37.783]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[09:32:37.783]                       search = base::search(), system = base::Sys.info())
[09:32:37.783]                   }
[09:32:37.783]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.783]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[09:32:37.783]                     cond$call), session = sessionInformation(), 
[09:32:37.783]                     timestamp = base::Sys.time(), signaled = 0L)
[09:32:37.783]                   signalCondition(cond)
[09:32:37.783]                 }
[09:32:37.783]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[09:32:37.783]                 "immediateCondition"))) {
[09:32:37.783]                   signal <- TRUE && inherits(cond, "immediateCondition")
[09:32:37.783]                   ...future.conditions[[length(...future.conditions) + 
[09:32:37.783]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[09:32:37.783]                   if (TRUE && !signal) {
[09:32:37.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.783]                     {
[09:32:37.783]                       inherits <- base::inherits
[09:32:37.783]                       invokeRestart <- base::invokeRestart
[09:32:37.783]                       is.null <- base::is.null
[09:32:37.783]                       muffled <- FALSE
[09:32:37.783]                       if (inherits(cond, "message")) {
[09:32:37.783]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.783]                         if (muffled) 
[09:32:37.783]                           invokeRestart("muffleMessage")
[09:32:37.783]                       }
[09:32:37.783]                       else if (inherits(cond, "warning")) {
[09:32:37.783]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.783]                         if (muffled) 
[09:32:37.783]                           invokeRestart("muffleWarning")
[09:32:37.783]                       }
[09:32:37.783]                       else if (inherits(cond, "condition")) {
[09:32:37.783]                         if (!is.null(pattern)) {
[09:32:37.783]                           computeRestarts <- base::computeRestarts
[09:32:37.783]                           grepl <- base::grepl
[09:32:37.783]                           restarts <- computeRestarts(cond)
[09:32:37.783]                           for (restart in restarts) {
[09:32:37.783]                             name <- restart$name
[09:32:37.783]                             if (is.null(name)) 
[09:32:37.783]                               next
[09:32:37.783]                             if (!grepl(pattern, name)) 
[09:32:37.783]                               next
[09:32:37.783]                             invokeRestart(restart)
[09:32:37.783]                             muffled <- TRUE
[09:32:37.783]                             break
[09:32:37.783]                           }
[09:32:37.783]                         }
[09:32:37.783]                       }
[09:32:37.783]                       invisible(muffled)
[09:32:37.783]                     }
[09:32:37.783]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.783]                   }
[09:32:37.783]                 }
[09:32:37.783]                 else {
[09:32:37.783]                   if (TRUE) {
[09:32:37.783]                     muffleCondition <- function (cond, pattern = "^muffle") 
[09:32:37.783]                     {
[09:32:37.783]                       inherits <- base::inherits
[09:32:37.783]                       invokeRestart <- base::invokeRestart
[09:32:37.783]                       is.null <- base::is.null
[09:32:37.783]                       muffled <- FALSE
[09:32:37.783]                       if (inherits(cond, "message")) {
[09:32:37.783]                         muffled <- grepl(pattern, "muffleMessage")
[09:32:37.783]                         if (muffled) 
[09:32:37.783]                           invokeRestart("muffleMessage")
[09:32:37.783]                       }
[09:32:37.783]                       else if (inherits(cond, "warning")) {
[09:32:37.783]                         muffled <- grepl(pattern, "muffleWarning")
[09:32:37.783]                         if (muffled) 
[09:32:37.783]                           invokeRestart("muffleWarning")
[09:32:37.783]                       }
[09:32:37.783]                       else if (inherits(cond, "condition")) {
[09:32:37.783]                         if (!is.null(pattern)) {
[09:32:37.783]                           computeRestarts <- base::computeRestarts
[09:32:37.783]                           grepl <- base::grepl
[09:32:37.783]                           restarts <- computeRestarts(cond)
[09:32:37.783]                           for (restart in restarts) {
[09:32:37.783]                             name <- restart$name
[09:32:37.783]                             if (is.null(name)) 
[09:32:37.783]                               next
[09:32:37.783]                             if (!grepl(pattern, name)) 
[09:32:37.783]                               next
[09:32:37.783]                             invokeRestart(restart)
[09:32:37.783]                             muffled <- TRUE
[09:32:37.783]                             break
[09:32:37.783]                           }
[09:32:37.783]                         }
[09:32:37.783]                       }
[09:32:37.783]                       invisible(muffled)
[09:32:37.783]                     }
[09:32:37.783]                     muffleCondition(cond, pattern = "^muffle")
[09:32:37.783]                   }
[09:32:37.783]                 }
[09:32:37.783]             }
[09:32:37.783]         }))
[09:32:37.783]     }, error = function(ex) {
[09:32:37.783]         base::structure(base::list(value = NULL, visible = NULL, 
[09:32:37.783]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[09:32:37.783]                 ...future.rng), started = ...future.startTime, 
[09:32:37.783]             finished = Sys.time(), session_uuid = NA_character_, 
[09:32:37.783]             version = "1.8"), class = "FutureResult")
[09:32:37.783]     }, finally = {
[09:32:37.783]         if (!identical(...future.workdir, getwd())) 
[09:32:37.783]             setwd(...future.workdir)
[09:32:37.783]         {
[09:32:37.783]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[09:32:37.783]                 ...future.oldOptions$nwarnings <- NULL
[09:32:37.783]             }
[09:32:37.783]             base::options(...future.oldOptions)
[09:32:37.783]             if (.Platform$OS.type == "windows") {
[09:32:37.783]                 old_names <- names(...future.oldEnvVars)
[09:32:37.783]                 envs <- base::Sys.getenv()
[09:32:37.783]                 names <- names(envs)
[09:32:37.783]                 common <- intersect(names, old_names)
[09:32:37.783]                 added <- setdiff(names, old_names)
[09:32:37.783]                 removed <- setdiff(old_names, names)
[09:32:37.783]                 changed <- common[...future.oldEnvVars[common] != 
[09:32:37.783]                   envs[common]]
[09:32:37.783]                 NAMES <- toupper(changed)
[09:32:37.783]                 args <- list()
[09:32:37.783]                 for (kk in seq_along(NAMES)) {
[09:32:37.783]                   name <- changed[[kk]]
[09:32:37.783]                   NAME <- NAMES[[kk]]
[09:32:37.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.783]                     next
[09:32:37.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.783]                 }
[09:32:37.783]                 NAMES <- toupper(added)
[09:32:37.783]                 for (kk in seq_along(NAMES)) {
[09:32:37.783]                   name <- added[[kk]]
[09:32:37.783]                   NAME <- NAMES[[kk]]
[09:32:37.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.783]                     next
[09:32:37.783]                   args[[name]] <- ""
[09:32:37.783]                 }
[09:32:37.783]                 NAMES <- toupper(removed)
[09:32:37.783]                 for (kk in seq_along(NAMES)) {
[09:32:37.783]                   name <- removed[[kk]]
[09:32:37.783]                   NAME <- NAMES[[kk]]
[09:32:37.783]                   if (name != NAME && is.element(NAME, old_names)) 
[09:32:37.783]                     next
[09:32:37.783]                   args[[name]] <- ...future.oldEnvVars[[name]]
[09:32:37.783]                 }
[09:32:37.783]                 if (length(args) > 0) 
[09:32:37.783]                   base::do.call(base::Sys.setenv, args = args)
[09:32:37.783]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[09:32:37.783]             }
[09:32:37.783]             else {
[09:32:37.783]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[09:32:37.783]             }
[09:32:37.783]             {
[09:32:37.783]                 if (base::length(...future.futureOptionsAdded) > 
[09:32:37.783]                   0L) {
[09:32:37.783]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[09:32:37.783]                   base::names(opts) <- ...future.futureOptionsAdded
[09:32:37.783]                   base::options(opts)
[09:32:37.783]                 }
[09:32:37.783]                 {
[09:32:37.783]                   {
[09:32:37.783]                     base::options(mc.cores = ...future.mc.cores.old)
[09:32:37.783]                     NULL
[09:32:37.783]                   }
[09:32:37.783]                   options(future.plan = NULL)
[09:32:37.783]                   if (is.na(NA_character_)) 
[09:32:37.783]                     Sys.unsetenv("R_FUTURE_PLAN")
[09:32:37.783]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[09:32:37.783]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[09:32:37.783]                     .init = FALSE)
[09:32:37.783]                 }
[09:32:37.783]             }
[09:32:37.783]         }
[09:32:37.783]     })
[09:32:37.783]     if (TRUE) {
[09:32:37.783]         base::sink(type = "output", split = FALSE)
[09:32:37.783]         if (TRUE) {
[09:32:37.783]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[09:32:37.783]         }
[09:32:37.783]         else {
[09:32:37.783]             ...future.result["stdout"] <- base::list(NULL)
[09:32:37.783]         }
[09:32:37.783]         base::close(...future.stdout)
[09:32:37.783]         ...future.stdout <- NULL
[09:32:37.783]     }
[09:32:37.783]     ...future.result$conditions <- ...future.conditions
[09:32:37.783]     ...future.result$finished <- base::Sys.time()
[09:32:37.783]     ...future.result
[09:32:37.783] }
[09:32:37.785] Poll #1 (0): usedNodes() = 2, workers = 2
[09:32:37.795] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.796] - Validating connection of MultisessionFuture
[09:32:37.796] - received message: FutureResult
[09:32:37.796] - Received FutureResult
[09:32:37.796] - Erased future from FutureRegistry
[09:32:37.796] result() for ClusterFuture ...
[09:32:37.796] - result already collected: FutureResult
[09:32:37.796] result() for ClusterFuture ... done
[09:32:37.796] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.796] result() for ClusterFuture ...
[09:32:37.797] - result already collected: FutureResult
[09:32:37.797] result() for ClusterFuture ... done
[09:32:37.797] result() for ClusterFuture ...
[09:32:37.797] - result already collected: FutureResult
[09:32:37.797] result() for ClusterFuture ... done
[09:32:37.798] MultisessionFuture started
[09:32:37.798] - Launch lazy future ... done
[09:32:37.798] run() for ‘MultisessionFuture’ ... done
[09:32:37.799] resolve() on list environment ...
[09:32:37.799]  recursive: 0
[09:32:37.800]  length: 4
[09:32:37.800]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:37.801] Future #1
[09:32:37.801]  length: 3 (resolved future 1)
[09:32:37.812] receiveMessageFromWorker() for ClusterFuture ...
[09:32:37.812] - Validating connection of MultisessionFuture
[09:32:37.812] - received message: FutureResult
[09:32:37.812] - Received FutureResult
[09:32:37.812] - Erased future from FutureRegistry
[09:32:37.812] result() for ClusterFuture ...
[09:32:37.812] - result already collected: FutureResult
[09:32:37.812] result() for ClusterFuture ... done
[09:32:37.813] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:37.813] Future #3
[09:32:37.813]  length: 2 (resolved future 3)
[09:32:37.813]  length: 1 (resolved future 4)
[09:32:38.267] receiveMessageFromWorker() for ClusterFuture ...
[09:32:38.267] - Validating connection of MultisessionFuture
[09:32:38.267] - received message: FutureResult
[09:32:38.267] - Received FutureResult
[09:32:38.267] - Erased future from FutureRegistry
[09:32:38.267] result() for ClusterFuture ...
[09:32:38.268] - result already collected: FutureResult
[09:32:38.268] result() for ClusterFuture ... done
[09:32:38.268] receiveMessageFromWorker() for ClusterFuture ... done
[09:32:38.268] Future #2
[09:32:38.268]  length: 0 (resolved future 2)
[09:32:38.268] resolve() on list environment ... DONE
[09:32:38.268] resolve() on list environment ...
[09:32:38.268]  recursive: 0
[09:32:38.269]  length: 4
[09:32:38.269]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:38.269] Future #1
[09:32:38.269]  length: 3 (resolved future 1)
[09:32:38.270] Future #2
[09:32:38.270]  length: 2 (resolved future 2)
[09:32:38.270] Future #3
[09:32:38.270]  length: 1 (resolved future 3)
[09:32:38.270]  length: 0 (resolved future 4)
[09:32:38.270] resolve() on list environment ... DONE
[09:32:38.271] resolve() on list environment ...
[09:32:38.271]  recursive: 0
[09:32:38.271]  length: 4
[09:32:38.271]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:38.272] Future #1
[09:32:38.272]  length: 3 (resolved future 1)
[09:32:38.272] Future #2
[09:32:38.272]  length: 2 (resolved future 2)
[09:32:38.272] Future #3
[09:32:38.272]  length: 1 (resolved future 3)
[09:32:38.272]  length: 0 (resolved future 4)
[09:32:38.272] resolve() on list environment ... DONE
[09:32:38.273] resolve() on list environment ...
[09:32:38.273]  recursive: 0
[09:32:38.273]  length: 4
[09:32:38.273]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:38.274] Future #1
[09:32:38.274]  length: 3 (resolved future 1)
[09:32:38.274] Future #2
[09:32:38.274]  length: 2 (resolved future 2)
[09:32:38.274] Future #3
[09:32:38.274]  length: 1 (resolved future 3)
[09:32:38.274]  length: 0 (resolved future 4)
[09:32:38.274] resolve() on list environment ... DONE
[09:32:38.275] resolve() on list environment ...
[09:32:38.275]  recursive: 0
[09:32:38.275]  length: 4
[09:32:38.275]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:38.276] Future #1
[09:32:38.276] result() for ClusterFuture ...
[09:32:38.276] - result already collected: FutureResult
[09:32:38.276] result() for ClusterFuture ... done
[09:32:38.276] result() for ClusterFuture ...
[09:32:38.276] - result already collected: FutureResult
[09:32:38.276] result() for ClusterFuture ... done
[09:32:38.276]  length: 3 (resolved future 1)
[09:32:38.276] Future #2
[09:32:38.277] result() for ClusterFuture ...
[09:32:38.277] - result already collected: FutureResult
[09:32:38.277] result() for ClusterFuture ... done
[09:32:38.277] result() for ClusterFuture ...
[09:32:38.277] - result already collected: FutureResult
[09:32:38.277] result() for ClusterFuture ... done
[09:32:38.277]  length: 2 (resolved future 2)
[09:32:38.277] Future #3
[09:32:38.277] result() for ClusterFuture ...
[09:32:38.277] - result already collected: FutureResult
[09:32:38.277] result() for ClusterFuture ... done
[09:32:38.278] result() for ClusterFuture ...
[09:32:38.278] - result already collected: FutureResult
[09:32:38.278] result() for ClusterFuture ... done
[09:32:38.278]  length: 1 (resolved future 3)
[09:32:38.278]  length: 0 (resolved future 4)
[09:32:38.278] resolve() on list environment ... DONE
[09:32:38.278] resolve() on list environment ...
[09:32:38.279]  recursive: 99
[09:32:38.279]  length: 4
[09:32:38.279]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[09:32:38.279] Future #1
[09:32:38.279] result() for ClusterFuture ...
[09:32:38.280] - result already collected: FutureResult
[09:32:38.280] result() for ClusterFuture ... done
[09:32:38.280] result() for ClusterFuture ...
[09:32:38.280] - result already collected: FutureResult
[09:32:38.280] result() for ClusterFuture ... done
[09:32:38.280] A MultisessionFuture was resolved
[09:32:38.280]  length: 3 (resolved future 1)
[09:32:38.280] Future #2
[09:32:38.280] result() for ClusterFuture ...
[09:32:38.280] - result already collected: FutureResult
[09:32:38.280] result() for ClusterFuture ... done
[09:32:38.281] result() for ClusterFuture ...
[09:32:38.281] - result already collected: FutureResult
[09:32:38.281] result() for ClusterFuture ... done
[09:32:38.281] A MultisessionFuture was resolved
[09:32:38.281]  length: 2 (resolved future 2)
[09:32:38.281] Future #3
[09:32:38.281] result() for ClusterFuture ...
[09:32:38.281] - result already collected: FutureResult
[09:32:38.281] result() for ClusterFuture ... done
[09:32:38.281] result() for ClusterFuture ...
[09:32:38.282] - result already collected: FutureResult
[09:32:38.282] result() for ClusterFuture ... done
[09:32:38.282] A MultisessionFuture was resolved
[09:32:38.282]  length: 1 (resolved future 3)
[09:32:38.285]  length: 0 (resolved future 4)
[09:32:38.285] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[09:32:38.289] resolve() on list ...
[09:32:38.289]  recursive: 0
[09:32:38.289]  length: 3
[09:32:38.289] 
[09:32:38.289]  length: 2 (resolved future 1)
[09:32:38.289]  length: 1 (resolved future 2)
[09:32:38.289]  length: 0 (resolved future 3)
[09:32:38.289] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[09:32:38.290] plan(): Setting new future strategy stack:
[09:32:38.290] List of future strategies:
[09:32:38.290] 1. FutureStrategy:
[09:32:38.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[09:32:38.290]    - tweaked: FALSE
[09:32:38.290]    - call: future::plan(oplan)
[09:32:38.291] plan(): nbrOfWorkers() = 1
> 
