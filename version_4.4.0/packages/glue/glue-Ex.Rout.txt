
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "glue"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('glue')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as_glue")
> ### * as_glue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_glue
> ### Title: Coerce object to glue
> ### Aliases: as_glue
> 
> ### ** Examples
> 
> x <- as_glue(c("abc", "\"\\\\", "\n"))
> x
abc
"\\


> 
> x <- 1
> y <- 3
> glue("x + y") + " = {x + y}"
x + y = {x + y}
> 
> 
> 
> cleanEx()
> nameEx("glue")
> ### * glue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glue
> ### Title: Format and interpolate a string
> ### Aliases: glue glue_data
> 
> ### ** Examples
> 
> name <- "Fred"
> age <- 50
> anniversary <- as.Date("1991-10-12")
> glue('My name is {name},',
+   'my age next year is {age + 1},',
+   'my anniversary is {format(anniversary, "%A, %B %d, %Y")}.')
My name is Fred,my age next year is 51,my anniversary is Saturday, October 12, 1991.
> 
> # single braces can be inserted by doubling them
> glue("My name is {name}, not {{name}}.")
My name is Fred, not {name}.
> 
> # Named arguments can be used to assign temporary variables.
> glue('My name is {name},',
+   ' my age next year is {age + 1},',
+   ' my anniversary is {format(anniversary, "%A, %B %d, %Y")}.',
+   name = "Joe",
+   age = 40,
+   anniversary = as.Date("2001-10-12"))
My name is Joe, my age next year is 41, my anniversary is Friday, October 12, 2001.
> 
> # `glue()` can also be used in user defined functions
> intro <- function(name, profession, country){
+   glue("My name is {name}, a {profession}, from {country}")
+ }
> intro("Shelmith", "Senior Data Analyst", "Kenya")
My name is Shelmith, a Senior Data Analyst, from Kenya
> intro("Cate", "Data Scientist", "Kenya")
My name is Cate, a Data Scientist, from Kenya
> 
> # `glue_data()` is useful in magrittr pipes
> if (require(magrittr)) {
+ 
+ mtcars %>% glue_data("{rownames(.)} has {hp} hp")
+ 
+ # Or within dplyr pipelines
+ if (require(dplyr)) {
+ 
+ head(iris) %>%
+   mutate(description = glue("This {Species} has a petal length of {Petal.Length}"))
+ 
+ }}
Loading required package: magrittr
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa
                            description
1 This setosa has a petal length of 1.4
2 This setosa has a petal length of 1.4
3 This setosa has a petal length of 1.3
4 This setosa has a petal length of 1.5
5 This setosa has a petal length of 1.4
6 This setosa has a petal length of 1.7
> 
> # Alternative delimiters can also be used if needed
> one <- "1"
> glue("The value of $e^{2\\pi i}$ is $<<one>>$.", .open = "<<", .close = ">>")
The value of $e^{2\pi i}$ is $1$.
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:magrittr’

> nameEx("glue_col")
> ### * glue_col
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glue_col
> ### Title: Construct strings with color
> ### Aliases: glue_col glue_data_col
> 
> ### ** Examples
> 
> ## Don't show: 
> if (require(crayon)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ library(crayon)
+ 
+ glue_col("{blue foo bar}")
+ 
+ glue_col("{blue 1 + 1 = {1 + 1}}")
+ 
+ glue_col("{blue 2 + 2 = {green {2 + 2}}}")
+ 
+ white_on_black <- bgBlack $ white
+ glue_col("{white_on_black
+   Roses are {red {colors()[[552]]}},
+   Violets are {blue {colors()[[26]]}},
+   `glue_col()` can show \\
+   {red c}{yellow o}{green l}{cyan o}{blue r}{magenta s}
+   and {bold bold} and {underline underline} too!
+ }")
+ 
+ # this would error due to an unterminated quote, if we did not specify
+ # `.literal = TRUE`
+ glue_col("{yellow It's} happening!", .literal = TRUE)
+ 
+ # `.literal = TRUE` also prevents an error here due to the `#` comment
+ glue_col(
+   "A URL: {magenta https://github.com/tidyverse/glue#readme}",
+   .literal = TRUE
+ )
+ 
+ # `.literal = TRUE` does NOT prevent evaluation
+ x <- "world"
+ y <- "day"
+ glue_col("hello {x}! {green it's a new {y}!}", .literal = TRUE)
+ ## Don't show: 
+ }) # examplesIf
Loading required package: crayon
> library(crayon)
> glue_col("{blue foo bar}")
foo bar
> glue_col("{blue 1 + 1 = {1 + 1}}")
1 + 1 = 2
> glue_col("{blue 2 + 2 = {green {2 + 2}}}")
2 + 2 = 4
> white_on_black <- bgBlack$white
> glue_col("{white_on_black\n  Roses are {red {colors()[[552]]}},\n  Violets are {blue {colors()[[26]]}},\n  `glue_col()` can show \\\n  {red c}{yellow o}{green l}{cyan o}{blue r}{magenta s}\n  and {bold bold} and {underline underline} too!\n}")
Roses are red,
Violets are blue,
`glue_col()` can show   colors
and bold and underline too!
> glue_col("{yellow It's} happening!", .literal = TRUE)
It's happening!
> glue_col("A URL: {magenta https://github.com/tidyverse/glue#readme}", 
+     .literal = TRUE)
A URL: https://github.com/tidyverse/glue#readme
> x <- "world"
> y <- "day"
> glue_col("hello {x}! {green it's a new {y}!}", .literal = TRUE)
hello world! it's a new day!
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:crayon’

> nameEx("glue_collapse")
> ### * glue_collapse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glue_collapse
> ### Title: Collapse a character vector
> ### Aliases: glue_collapse glue_sql_collapse
> 
> ### ** Examples
> 
> glue_collapse(glue("{1:10}"))
12345678910
> 
> # Wide values can be truncated
> glue_collapse(glue("{1:10}"), width = 5)
12...
> 
> glue_collapse(1:4, ", ", last = " and ")
1, 2, 3 and 4
> 
> 
> 
> cleanEx()
> nameEx("glue_safe")
> ### * glue_safe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glue_safe
> ### Title: Safely interpolate strings
> ### Aliases: glue_safe glue_data_safe
> 
> ### ** Examples
> 
> "1 + 1" <- 5
> # glue actually executes the code
> glue("{1 + 1}")
2
> 
> # glue_safe just looks up the value
> glue_safe("{1 + 1}")
5
> 
> rm("1 + 1")
> 
> 
> 
> cleanEx()
> nameEx("glue_sql")
> ### * glue_sql
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glue_sql
> ### Title: Interpolate strings with SQL escaping
> ### Aliases: glue_sql glue_data_sql
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("DBI", quietly = TRUE) && requireNamespace("RSQLite", quietly = TRUE)) (if (getRversion() >= "3.4") withAutoprint else force)({ # examplesIf
+ ## End(Don't show)
+ con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
+ iris2 <- iris
+ colnames(iris2) <- gsub("[.]", "_", tolower(colnames(iris)))
+ DBI::dbWriteTable(con, "iris", iris2)
+ var <- "sepal_width"
+ tbl <- "iris"
+ num <- 2
+ val <- "setosa"
+ glue_sql("
+   SELECT {`var`}
+   FROM {`tbl`}
+   WHERE {`tbl`}.sepal_length > {num}
+     AND {`tbl`}.species = {val}
+   ", .con = con)
+ 
+ # If sepal_length is store on the database as a character explicitly convert
+ # the data to character to quote appropriately.
+ glue_sql("
+   SELECT {`var`}
+   FROM {`tbl`}
+   WHERE {`tbl`}.sepal_length > {as.character(num)}
+     AND {`tbl`}.species = {val}
+   ", .con = con)
+ 
+ 
+ # `glue_sql()` can be used in conjuction with parameterized queries using
+ # `DBI::dbBind()` to provide protection for SQL Injection attacks
+  sql <- glue_sql("
+     SELECT {`var`}
+     FROM {`tbl`}
+     WHERE {`tbl`}.sepal_length > ?
+   ", .con = con)
+ query <- DBI::dbSendQuery(con, sql)
+ DBI::dbBind(query, list(num))
+ DBI::dbFetch(query, n = 4)
+ DBI::dbClearResult(query)
+ 
+ # `glue_sql()` can be used to build up more complex queries with
+ # interchangeable sub queries. It returns `DBI::SQL()` objects which are
+ # properly protected from quoting.
+ sub_query <- glue_sql("
+   SELECT *
+   FROM {`tbl`}
+   ", .con = con)
+ 
+ glue_sql("
+   SELECT s.{`var`}
+   FROM ({sub_query}) AS s
+   ", .con = con)
+ 
+ # If you want to input multiple values for use in SQL IN statements put `*`
+ # at the end of the value and the values will be collapsed and quoted appropriately.
+ glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})",
+   vals = 1, .con = con)
+ 
+ glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})",
+   vals = 1:5, .con = con)
+ 
+ glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})",
+   vals = "setosa", .con = con)
+ 
+ glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})",
+   vals = c("setosa", "versicolor"), .con = con)
+ 
+ # If you need to reference variables from multiple tables use `DBI::Id()`.
+ # Here we create a new table of nicknames, join the two tables together and
+ # select columns from both tables. Using `DBI::Id()` and the special
+ # `glue_sql()` syntax ensures all the table and column identifiers are quoted
+ # appropriately.
+ 
+ iris_db <- "iris"
+ nicknames_db <- "nicknames"
+ 
+ nicknames <- data.frame(
+   species = c("setosa", "versicolor", "virginica"),
+   nickname = c("Beachhead Iris", "Harlequin Blueflag", "Virginia Iris"),
+   stringsAsFactors = FALSE
+ )
+ 
+ DBI::dbWriteTable(con, nicknames_db, nicknames)
+ 
+ cols <- list(
+   DBI::Id(iris_db, "sepal_length"),
+   DBI::Id(iris_db, "sepal_width"),
+   DBI::Id(nicknames_db, "nickname")
+ )
+ 
+ iris_species <- DBI::Id(iris_db, "species")
+ nicknames_species <- DBI::Id(nicknames_db, "species")
+ 
+ query <- glue_sql("
+   SELECT {`cols`*}
+   FROM {`iris_db`}
+   JOIN {`nicknames_db`}
+   ON {`iris_species`}={`nicknames_species`}",
+   .con = con
+ )
+ query
+ 
+ DBI::dbGetQuery(con, query, n = 5)
+ 
+ DBI::dbDisconnect(con)
+ ## Don't show: 
+ }) # examplesIf
> con <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
> iris2 <- iris
> colnames(iris2) <- gsub("[.]", "_", tolower(colnames(iris)))
> DBI::dbWriteTable(con, "iris", iris2)
> var <- "sepal_width"
> tbl <- "iris"
> num <- 2
> val <- "setosa"
> glue_sql("\n  SELECT {`var`}\n  FROM {`tbl`}\n  WHERE {`tbl`}.sepal_length > {num}\n    AND {`tbl`}.species = {val}\n  ", 
+     .con = con)
<SQL> SELECT `sepal_width`
FROM `iris`
WHERE `iris`.sepal_length > 2
  AND `iris`.species = 'setosa'
> glue_sql("\n  SELECT {`var`}\n  FROM {`tbl`}\n  WHERE {`tbl`}.sepal_length > {as.character(num)}\n    AND {`tbl`}.species = {val}\n  ", 
+     .con = con)
<SQL> SELECT `sepal_width`
FROM `iris`
WHERE `iris`.sepal_length > '2'
  AND `iris`.species = 'setosa'
> sql <- glue_sql("\n    SELECT {`var`}\n    FROM {`tbl`}\n    WHERE {`tbl`}.sepal_length > ?\n  ", 
+     .con = con)
> query <- DBI::dbSendQuery(con, sql)
> DBI::dbBind(query, list(num))
> DBI::dbFetch(query, n = 4)
  sepal_width
1         3.5
2         3.0
3         3.2
4         3.1
> DBI::dbClearResult(query)
> sub_query <- glue_sql("\n  SELECT *\n  FROM {`tbl`}\n  ", .con = con)
> glue_sql("\n  SELECT s.{`var`}\n  FROM ({sub_query}) AS s\n  ", .con = con)
<SQL> SELECT s.`sepal_width`
FROM (SELECT *
FROM `iris`) AS s
> glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})", vals = 1, 
+     .con = con)
<SQL> SELECT * FROM `iris` WHERE sepal_length IN (1)
> glue_sql("SELECT * FROM {`tbl`} WHERE sepal_length IN ({vals*})", vals = 1:5, 
+     .con = con)
<SQL> SELECT * FROM `iris` WHERE sepal_length IN (1, 2, 3, 4, 5)
> glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})", vals = "setosa", 
+     .con = con)
<SQL> SELECT * FROM `iris` WHERE species IN ('setosa')
> glue_sql("SELECT * FROM {`tbl`} WHERE species IN ({vals*})", vals = c("setosa", 
+     "versicolor"), .con = con)
<SQL> SELECT * FROM `iris` WHERE species IN ('setosa', 'versicolor')
> iris_db <- "iris"
> nicknames_db <- "nicknames"
> nicknames <- data.frame(species = c("setosa", "versicolor", "virginica"), 
+     nickname = c("Beachhead Iris", "Harlequin Blueflag", "Virginia Iris"), stringsAsFactors = FALSE)
> DBI::dbWriteTable(con, nicknames_db, nicknames)
> cols <- list(DBI::Id(iris_db, "sepal_length"), DBI::Id(iris_db, "sepal_width"), 
+     DBI::Id(nicknames_db, "nickname"))
> iris_species <- DBI::Id(iris_db, "species")
> nicknames_species <- DBI::Id(nicknames_db, "species")
> query <- glue_sql("\n  SELECT {`cols`*}\n  FROM {`iris_db`}\n  JOIN {`nicknames_db`}\n  ON {`iris_species`}={`nicknames_species`}", 
+     .con = con)
> query
<SQL> SELECT `iris`.`sepal_length`, `iris`.`sepal_width`, `nicknames`.`nickname`
FROM `iris`
JOIN `nicknames`
ON `iris`.`species`=`nicknames`.`species`
> DBI::dbGetQuery(con, query, n = 5)
  sepal_length sepal_width       nickname
1          5.1         3.5 Beachhead Iris
2          4.9         3.0 Beachhead Iris
3          4.7         3.2 Beachhead Iris
4          4.6         3.1 Beachhead Iris
5          5.0         3.6 Beachhead Iris
> DBI::dbDisconnect(con)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("quoting")
> ### * quoting
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: quoting
> ### Title: Quoting operators
> ### Aliases: quoting single_quote double_quote backtick
> 
> ### ** Examples
> 
> x <- 1:5
> glue('Values of x: {glue_collapse(backtick(x), sep = ", ", last = " and ")}')
Values of x: `1`, `2`, `3`, `4` and `5`
> 
> 
> 
> cleanEx()
> nameEx("trim")
> ### * trim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trim
> ### Title: Trim a character vector
> ### Aliases: trim
> 
> ### ** Examples
> 
> glue("
+     A formatted string
+     Can have multiple lines
+       with additional indention preserved
+     ")
A formatted string
Can have multiple lines
  with additional indention preserved
> 
> glue("
+   \ntrailing or leading newlines can be added explicitly\n
+   ")
  
trailing or leading newlines can be added explicitly

> 
> glue("
+     A formatted string \\
+     can also be on a \\
+     single line
+     ")
A formatted string can also be on a single line
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.659 0.028 0.686 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
