
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "broom.mixed"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('broom.mixed')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("augment.ranef.mer")
> ### * augment.ranef.mer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: augment.ranef.mer
> ### Title: Augmentation for random effects (for caterpillar plots etc.)
> ### Aliases: augment.ranef.mer
> 
> ### ** Examples
> 
> if (require("lme4")) {
+    load(system.file("extdata","lme4_example.rda",package="broom.mixed"))
+    rr <- ranef(lmm1,condVar=TRUE)
+    aa <- broom::augment(rr)
+    ## Q-Q plot:
+    if (require(ggplot2) && require(dplyr)) {
+       g0 <- ggplot(aa,aes(estimate,qq,xmin=lb,xmax=ub))+
+           geom_errorbarh(height=0)+
+           geom_point()+facet_wrap(~variable,scale="free_x")
+       ## regular caterpillar plot:
+       g1 <- ggplot(aa,aes(estimate,level,xmin=lb,xmax=ub))+
+          geom_errorbarh(height=0)+
+          geom_vline(xintercept=0,lty=2)+
+          geom_point()+facet_wrap(~variable,scale="free_x")
+       ## emphasize extreme values
+       aa2 <- group_by(aa,grp,level)
+       aa3 <- mutate(aa2, keep=any(estimate/std.error>2))
+       ## Update caterpillar plot with extreme levels highlighted
+       ##  (highlight all groups with *either* extreme intercept *or*
+       ##   extreme slope)
+       ggplot(aa3, aes(estimate,level,xmin=lb,xmax=ub,colour=factor(keep)))+
+          geom_errorbarh(height=0)+
+          geom_vline(xintercept=0,lty=2)+
+          geom_point()+facet_wrap(~variable,scale="free_x")+
+          scale_colour_manual(values=c("black","red"), guide=FALSE)
+    }
+ }
Loading required package: lme4
Loading required package: Matrix
Loading required package: ggplot2
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in
ggplot2 3.3.4.
ℹ Please use "none" instead.
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:ggplot2’, ‘package:lme4’,
  ‘package:Matrix’

> nameEx("brms_tidiers")
> ### * brms_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: brms_tidiers
> ### Title: Tidying methods for a brms model
> ### Aliases: brms_tidiers tidy.brmsfit glance.brmsfit augment.brmsfit
> 
> ### ** Examples
> 
>  ## original model
>  ## Not run: 
> ##D     brms_crossedRE <- brm(mpg ~ wt + (1|cyl) + (1+wt|gear), data = mtcars,
> ##D            iter = 500, chains = 2)
> ##D  
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("fixef.MCMCglmm")
> ### * fixef.MCMCglmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixef.MCMCglmm
> ### Title: Extract fixed effects from an 'MCMCglmm' object
> ### Aliases: fixef.MCMCglmm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   # a simple MCMCglmm model
> ##D   data(PlodiaPO)
> ##D   m <- MCMCglmm(PO ~ 1, random= ~ FSfamily, data=PlodiaPO, verbose=FALSE)
> ##D 
> ##D   # only extract average fixed effects
> ##D   fixef(m, use = "mean")
> ##D 
> ##D   # histogram of posterior samples of fixed effects
> ##D   hist(fixef(m))
> ##D   # matches the mean
> ##D   rowMeans(fixef(m))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("gamlss_tidiers")
> ### * gamlss_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gamlss_tidiers
> ### Title: Tidying methods for gamlss objects
> ### Aliases: gamlss_tidiers tidy.gamlss
> 
> ### ** Examples
> 
> if (requireNamespace("gamlss", quietly = TRUE) &&
+     requireNamespace("gamlss.data", quietly = TRUE)) {
+     data(abdom, package="gamlss.data")
+     ## Not run: 
+ ##D          mod <- gamlss(y~pb(x), sigma.fo=~pb(x), family=BCT,
+ ##D                        data=abdom, method=mixed(1,20))
+ ##D     
+ ## End(Not run)
+     ## load stored object
+     mod <- readRDS(system.file("extdata", "gamlss_example.rds",
+                    package="broom.mixed"))
+     tidy(mod)
+ }
> 
> 
> 
> 
> cleanEx()
> nameEx("get_methods")
> ### * get_methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get_methods
> ### Title: Retrieve all method/class combinations currently provided by the
> ###   broom.mixed package
> ### Aliases: get_methods
> 
> ### ** Examples
> 
> print(get_methods(), n = Inf)
# A tibble: 24 × 4
   class       tidy  glance augment
   <chr>       <lgl> <lgl>  <lgl>  
 1 allFit      TRUE  TRUE   FALSE  
 2 brmsfit     TRUE  TRUE   TRUE   
 3 gamlss      TRUE  TRUE   FALSE  
 4 gamm4       TRUE  TRUE   TRUE   
 5 glmmadmb    TRUE  TRUE   TRUE   
 6 glmmTMB     TRUE  TRUE   TRUE   
 7 gls         TRUE  TRUE   TRUE   
 8 lme         TRUE  TRUE   TRUE   
 9 lmList4     TRUE  FALSE  FALSE  
10 lqmm        TRUE  TRUE   FALSE  
11 mcmc        TRUE  FALSE  FALSE  
12 mcmc.list   TRUE  FALSE  FALSE  
13 MCMCglmm    TRUE  FALSE  FALSE  
14 mediate.mer TRUE  FALSE  FALSE  
15 merMod      TRUE  TRUE   TRUE   
16 MixMod      TRUE  FALSE  FALSE  
17 ranef.mer   FALSE FALSE  TRUE   
18 rjags       TRUE  FALSE  FALSE  
19 rlmerMod    TRUE  FALSE  FALSE  
20 stanfit     TRUE  FALSE  FALSE  
21 stanreg     TRUE  TRUE   FALSE  
22 TMB         TRUE  FALSE  FALSE  
23 varComb     TRUE  FALSE  FALSE  
24 varFunc     TRUE  FALSE  FALSE  
> 
> 
> 
> cleanEx()
> nameEx("glmmTMB_tidiers")
> ### * glmmTMB_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glmmTMB_tidiers
> ### Title: Tidying methods for glmmTMB models
> ### Aliases: glmmTMB_tidiers tidy.glmmTMB augment.glmmTMB glance.glmmTMB
> 
> ### ** Examples
> 
> if (require("glmmTMB") && require("lme4")
+     ## &&
+     ## make sure package versions are OK
+     ## checkDepPackageVersion(dep_pkg = "TMB",
+     ##                       this_pkg = "glmmTMB",
+     ##                        warn = FALSE) &&
+     ## checkDepPackageVersion(dep_pkg = "Matrix",
+     ##                       this_pkg = "TMB",
+     ##                      warn = FALSE)
+ )
+ {
+     data("sleepstudy",package="lme4")
+     ## original model:
+     ## Not run: 
+ ##D         lmm1 <- glmmTMB(Reaction ~ Days + (Days | Subject), sleepstudy)
+ ##D     
+ ## End(Not run)
+     ## load stored object
+     L <- load(system.file("extdata","glmmTMB_example.rda",package="broom.mixed"))
+     for (obj in L) {
+        assign(obj, glmmTMB::up2date(get(obj)))
+     }
+     tidy(lmm1)
+     tidy(lmm1, effects = "fixed")
+     tidy(lmm1, effects = "fixed", conf.int=TRUE)
+     tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="uniroot")
+     ## FIX: tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
+     head(augment(lmm1, sleepstudy))
+     glance(lmm1)
+ 
+     ## original model:
+     ##  glmm1 <- glmmTMB(incidence/size ~ period + (1 | herd),
+     ##                  data = cbpp, family = binomial, weights=size)
+     tidy(glmm1)
+     tidy(glmm1, effects = "fixed")
+     tidy(glmm1, effects = "fixed", exponentiate=TRUE)
+     tidy(glmm1, effects = "fixed", conf.int=TRUE, exponentiate=TRUE)
+     head(augment(glmm1, cbpp))
+     head(augment(glmm1, cbpp, type.residuals="pearson"))
+     glance(glmm1)
+ ## Not run: 
+ ##D     ## profile CIs - a little bit slower but more accurate
+ ##D     tidy(glmm1, effects = "fixed", conf.int=TRUE, exponentiate=TRUE, conf.method="profile")
+ ## End(Not run)
+ }
Loading required package: glmmTMB
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘glmmTMB’
> 
> 
> 
> cleanEx()
> nameEx("glmmadmb_tidiers")
> ### * glmmadmb_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glmmadmb_tidiers
> ### Title: Tidying methods for glmmADMB models
> ### Aliases: glmmadmb_tidiers glmmADMB_tidiers tidy.glmmadmb
> ###   augment.glmmadmb glance.glmmadmb
> 
> ### ** Examples
> 
> 
> if (require("glmmADMB") && require("lme4")) {
+     ## original model
+     ## Not run: 
+ ##D         data("sleepstudy", package="lme4")
+ ##D         lmm1 <- glmmadmb(Reaction ~ Days + (Days | Subject), sleepstudy,
+ ##D                          family="gaussian")
+ ##D     
+ ## End(Not run)
+     ## load stored object
+     load(system.file("extdata","glmmADMB_example.rda",package="broom.mixed"))
+     tidy(lmm1, effects = "fixed")
+     tidy(lmm1, effects = "fixed", conf.int=TRUE)
+     ## tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="profile")
+     ## tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
+     head(augment(lmm1, sleepstudy))
+     glance(lmm1)
+ 
+     glmm1 <- glmmadmb(cbind(incidence, size - incidence) ~ period + (1 | herd),
+                   data = cbpp, family = "binomial")
+     tidy(glmm1)
+     tidy(glmm1, effects = "fixed")
+     head(augment(glmm1, cbpp))
+     glance(glmm1)
+ 
+ }
Loading required package: glmmADMB
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘glmmADMB’
> 
> 
> 
> cleanEx()
> nameEx("lme4_tidiers")
> ### * lme4_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lme4_tidiers
> ### Title: Tidying methods for mixed effects models
> ### Aliases: lme4_tidiers glance.allFit tidy.allFit tidy.merMod
> ###   tidy.rlmerMod augment.merMod glance.merMod
> 
> ### ** Examples
> 
> 
> if (require("lme4")) {
+     ## original model
+     ## Not run: 
+ ##D         lmm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+ ##D     
+ ## End(Not run)
+     ## load stored object
+     load(system.file("extdata", "lme4_example.rda", package="broom.mixed"))
+     (tt <- tidy(lmm1))
+     tidy(lmm1, effects = "fixed")
+     tidy(lmm1, effects = "fixed", conf.int=TRUE)
+     tidy(lmm1, effects = "fixed", conf.int=TRUE, conf.method="profile")
+     ## lmm1_prof <- profile(lmm1) # generated by extdata/runexamples
+     tidy(lmm1, conf.int=TRUE, conf.method="profile", profile=lmm1_prof)
+     ## conditional modes (group-level deviations from population-level estimate)
+     tidy(lmm1, effects = "ran_vals", conf.int=TRUE)
+     ## coefficients (group-level estimates)
+     (rcoef1 <- tidy(lmm1, effects = "ran_coefs"))
+     if (require(tidyr) && require(dplyr)) {
+        ## reconstitute standard coefficient-by-level table
+        spread(rcoef1,key=term,value=estimate)
+        ## split ran_pars into type + term; sort fixed/sd/cor
+        (tt %>% separate(term,c("type","term"),sep="__",fill="left")
+            %>% arrange(!is.na(type),desc(type)))
+     }
+     head(augment(lmm1, sleepstudy))
+     glance(lmm1)
+ 
+     glmm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
+                   data = cbpp, family = binomial)
+     tidy(glmm1)
+     tidy(glmm1,exponentiate=TRUE)
+     tidy(glmm1, effects = "fixed")
+     ## suppress warning about influence.merMod
+     head(suppressWarnings(augment(glmm1, cbpp)))
+     glance(glmm1)
+ 
+     startvec <- c(Asym = 200, xmid = 725, scal = 350)
+     nm1 <- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,
+                   Orange, start = startvec)
+     ## suppress warnings about var-cov matrix ...
+     op <- options(warn=-1)
+     tidy(nm1)
+     tidy(nm1, effects = "fixed")
+     options(op)
+     head(augment(nm1, Orange))
+     glance(nm1)
+     detach("package:lme4")
+ }
Loading required package: lme4
Loading required package: Matrix
Computing profile confidence intervals ...
Loading required package: tidyr

Attaching package: ‘tidyr’

The following objects are masked from ‘package:Matrix’:

    expand, pack, unpack

Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> if (require("lmerTest")) {
+    lmm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
+    tidy(lmm1)
+    glance(lmm1)
+    detach("package:lmerTest")  # clean up
+ }
Loading required package: lmerTest
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘lmerTest’
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:tidyr’, ‘package:Matrix’

> nameEx("mcmc_tidiers")
> ### * mcmc_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy.MCMCglmm
> ### Title: Tidying methods for MCMC (Stan, JAGS, etc.) fits
> ### Aliases: tidy.MCMCglmm mcmc_tidiers tidyMCMC tidy.rjags tidy.stanfit
> ###   tidy.mcmc tidy.mcmc.list
> 
> ### ** Examples
> 
> if (require("MCMCglmm")) {
+   ## original model
+   ## Not run: 
+ ##D       mm0 <- MCMCglmm(Reaction ~ Days,
+ ##D                  random = ~Subject, data = sleepstudy,
+ ##D                  nitt=4000,
+ ##D                  pr = TRUE
+ ##D              )
+ ##D    
+ ## End(Not run)
+    ## load stored object
+    load(system.file("extdata","MCMCglmm_example.rda",
+                                      package="broom.mixed"))
+    tidy(mm0)
+    tidy(mm1)
+    tidy(mm2)
+    tail(tidy(mm0,effects="ran_vals"))
+ }
Loading required package: MCMCglmm
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘MCMCglmm’
> 
> # Using example from "RStan Getting Started"
> # https://github.com/stan-dev/rstan/wiki/RStan-Getting-Started
> 
> model_file <- system.file("extdata", "8schools.stan", package = "broom.mixed")
> schools_dat <- list(J = 8,
+                     y = c(28,  8, -3,  7, -1,  1, 18, 12),
+                     sigma = c(15, 10, 16, 11,  9, 11, 10, 18))
> ## original model
> ## Not run: 
> ##D     set.seed(2015)
> ##D     rstan_example <- rstan::stan(file = model_file, data = schools_dat,
> ##D                          iter = 1000, chains = 2, save_dso = FALSE)
> ## End(Not run)
> if (require(rstan)) {
+    ## load stored object
+    rstan_example <- readRDS(system.file("extdata", "rstan_example.rds", package = "broom.mixed"))
+    tidy(rstan_example)
+    tidy(rstan_example, conf.int = TRUE, pars = "theta")
+    td_mean <- tidy(rstan_example, conf.int = TRUE)
+    td_median <- tidy(rstan_example, conf.int = TRUE, robust = TRUE)
+    
+    if (require(dplyr) && require(ggplot2)) {
+        tds <- (dplyr::bind_rows(list(mean=td_mean, median=td_median), .id="method")
+           %>% mutate(type=ifelse(grepl("^theta",term),"theta",
+             ifelse(grepl("^eta",term),"eta",
+                   "other")))
+       )
+ 
+      ggplot(tds, aes(estimate, term)) +
+       geom_errorbarh(aes(xmin = conf.low, xmax = conf.high),height=0) +
+       geom_point(aes(color = method))+
+       facet_wrap(~type,scale="free",ncol=1)
+  } ## require(dplyr,ggplot2)
+ } ## require(rstan)
Loading required package: rstan
Loading required package: StanHeaders

rstan version 2.32.6 (Stan version 2.32.2)

For execution on a local, multicore CPU with excess RAM we recommend calling
options(mc.cores = parallel::detectCores()).
To avoid recompilation of unchanged Stan programs, we recommend calling
rstan_options(auto_write = TRUE)
For within-chain threading using `reduce_sum()` or `map_rect()` Stan functions,
change `threads_per_chain` option:
rstan_options(threads_per_chain = 1)

Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: ggplot2
> if (require(R2jags)) {
+    ## see help("jags",package="R2jags")
+    ## and  example("jags",package="R2jags")
+    ## for details
+    ## load stored object
+    R2jags_example <- readRDS(system.file("extdata", "R2jags_example.rds", package = "broom.mixed"))
+    tidy(R2jags_example)
+    tidy(R2jags_example, conf.int=TRUE, conf.method="quantile")
+ }
Loading required package: R2jags
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘R2jags’
> 
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:dplyr’, ‘package:rstan’,
  ‘package:StanHeaders’

> nameEx("mediation_tidiers")
> ### * mediation_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mediation_tidiers
> ### Title: Tidying methods for mediation analyses involving mixed effects
> ###   models
> ### Aliases: mediation_tidiers tidy.mediate.mer
> 
> ### ** Examples
> 
> if (require("lme4") && require("mediation")) {
+     ## Borrowed from \code{help(mediation::mediate)}:
+     ## Not run: 
+ ##D         ## Varying intercept for mediator 
+ ##D         mod_m <- glmer(job_dich ~ treat + econ_hard + (1 | educ), 
+ ##D                        family = binomial(link = "probit"), data = jobs)
+ ##D         ## Varying intercept and slope for outcome
+ ##D         mod_y <- glmer(work1 ~ treat + job_dich + econ_hard + (1 + treat | occp),
+ ##D                        family = binomial(link = "probit"), data = jobs)
+ ##D         ## Output based on mediator group ("educ")
+ ##D         mod_med <- mediate(mod_m, mod_y, treat = "treat", 
+ ##D                            mediator = "job_dich", sims=50, group.out="educ")
+ ##D     
+ ## End(Not run)
+     ## Load stored objects
+     load(system.file("extdata", "mediation_example.rda", package="broom.mixed"))
+     ## Tidy outputs
+     tidy(mod_m)
+     tidy(mod_y)
+     tidy(mod_med)
+ }
Loading required package: lme4
Loading required package: Matrix
Loading required package: mediation
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘mediation’
> 
> 
> 
> cleanEx()

detaching ‘package:lme4’, ‘package:Matrix’

> nameEx("nlme_tidiers")
> ### * nlme_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nlme_tidiers
> ### Title: Tidying methods for mixed effects models
> ### Aliases: nlme_tidiers tidy.lme augment.lme glance.lme tidy.gls
> ###   augment.gls
> 
> ### ** Examples
> 
> 
> if (require("nlme") && require("lme4")) {
+     data("sleepstudy", package="lme4")
+     ## original model
+     ## Not run: 
+ ##D          lmm1 <- lme(Reaction ~ Days, random=~ Days|Subject, sleepstudy)
+ ##D     
+ ## End(Not run)
+     ## load stored object
+     load(system.file("extdata","nlme_example.rda", package="broom.mixed"))
+     tidy(lmm1)
+     tidy(lmm1, effects = "fixed")
+     tidy(lmm1, conf.int = TRUE)
+     tidy(lmm1, conf.int = TRUE, conf.level = 0.8)
+     tidy(lmm1, effects = "ran_pars")
+     tidy(lmm1, effects = "ran_vals")
+     tidy(lmm1, effects = "ran_coefs")
+     head(augment(lmm1, sleepstudy))
+     glance(lmm1)
+ 
+     startvec <- c(Asym = 200, xmid = 725, scal = 350)
+     nm1 <- nlme(circumference ~ SSlogis(age, Asym, xmid, scal),
+                   data = Orange,
+                   fixed = Asym + xmid + scal ~1,
+                   random = Asym ~1,
+                   start = startvec)
+     tidy(nm1)
+     tidy(nm1, effects = "fixed")
+     head(augment(nm1, Orange))
+     glance(nm1)
+ 
+     gls1 <- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
+                          correlation = corAR1(form = ~ 1 | Mare))
+     tidy(gls1)
+     glance(gls1)
+     head(augment(gls1))
+ }
Loading required package: nlme
Loading required package: lme4
Loading required package: Matrix

Attaching package: ‘lme4’

The following object is masked from ‘package:nlme’:

    lmList

Warning in tidy.lme(nm1) :
  ran_pars not yet implemented for nonlinear models
# A tibble: 6 × 5
  Mare     Time follicles .fitted .resid
  <ord>   <dbl>     <dbl>   <dbl>  <dbl>
1 1     -0.136         20   13.7  6.28  
2 1     -0.0909        15   13.0  2.04  
3 1     -0.0455        19   12.1  6.87  
4 1      0             16   11.3  4.68  
5 1      0.0455        13   10.6  2.43  
6 1      0.0909        10    9.96 0.0405
> 
> 
> 
> 
> cleanEx()

detaching ‘package:lme4’, ‘package:Matrix’, ‘package:nlme’

> nameEx("paramNamesMCMCglmm")
> ### * paramNamesMCMCglmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paramNamesMCMCglmm
> ### Title: Extract the parameter names from an 'MCMCglmm' object
> ### Aliases: paramNamesMCMCglmm
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   # a simple MCMCglmm model
> ##D   if (require(MCMCglmm)) {
> ##D      data(PlodiaPO)
> ##D      m <- MCMCglmm(PO ~ 1, random = ~ FSfamily, data = PlodiaPO, verbose=FALSE, pr=TRUE)
> ##D   }
> ##D   # extract the parameter names
> ##D   paramNamesMCMCglmm(m)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ranef.MCMCglmm")
> ### * ranef.MCMCglmm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranef.MCMCglmm
> ### Title: Extract random effects from an 'MCMCglmm' object
> ### Aliases: ranef.MCMCglmm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   # a simple MCMCglmm model
> ##D   data(PlodiaPO)
> ##D   m <- MCMCglmm(PO ~ 1, random= ~ FSfamily, data=PlodiaPO, pr=TRUE, verbose=FALSE)
> ##D 
> ##D   # only extract average fixed effects
> ##D   head(ranef(m, use = "mean"))
> ##D 
> ##D   # histogram of posterior samples of fixed effects
> ##D   hist(ranef(m)[1, ])
> ##D   # matches the mean
> ##D   rowMeans(ranef(m)[1:6, ])
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ranefLevels")
> ### * ranefLevels
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ranefLevels
> ### Title: Extract the levels of factors used for random effects in
> ###   'MCMCglmm' objects
> ### Aliases: ranefLevels
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   # a simple MCMCglmm model
> ##D   data(PlodiaPO)
> ##D   m <- MCMCglmm(PO ~ 1, random = ~ FSfamily, data = PlodiaPO, verbose=FALSE)
> ##D 
> ##D   # extract the random effects levels
> ##D   ranefLevels(m, PlodiaPO)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rstanarm_tidiers")
> ### * rstanarm_tidiers
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rstanarm_tidiers
> ### Title: Tidying methods for an rstanarm model
> ### Aliases: rstanarm_tidiers tidy.stanreg glance.stanreg
> 
> ### ** Examples
> 
> 
> if (require("rstanarm")) {
+ ## Not run: 
+ ##D #'     ## original models
+ ##D   fit <- stan_glmer(mpg ~ wt + (1|cyl) + (1+wt|gear), data = mtcars,
+ ##D                       iter = 500, chains = 2)
+ ##D   fit2 <- stan_glmer((mpg>20) ~ wt + (1 | cyl) + (1 + wt | gear),
+ ##D                     data = mtcars,
+ ##D                     family = binomial,
+ ##D                     iter = 500, chains = 2
+ ##D   
+ ## End(Not run)
+ ## load example data
+   load(system.file("extdata", "rstanarm_example.rda", package="broom.mixed"))
+ 
+   # non-varying ("population") parameters
+   tidy(fit, conf.int = TRUE, conf.level = 0.5)
+   tidy(fit, conf.int = TRUE, conf.method = "HPDinterval", conf.level = 0.5)
+ 
+   #  exponentiating (in this case, from log-odds to odds ratios)
+   (tidy(fit2, conf.int = TRUE, conf.level = 0.5)
+           |> dplyr::filter(term != "(Intercept)")
+   )
+   (tidy(fit2, conf.int = TRUE, conf.level = 0.5, exponentiate = TRUE)
+           |> dplyr::filter(term != "(Intercept)")
+   )
+ 
+   # hierarchical sd & correlation parameters
+   tidy(fit, effects = "ran_pars")
+ 
+   # group-specific deviations from "population" parameters
+   tidy(fit, effects = "ran_vals")
+ 
+   # glance method
+    glance(fit)
+   ## Not run: 
+ ##D      glance(fit, looic = TRUE, cores = 1)
+ ##D   
+ ## End(Not run)
+ } ## if require("rstanarm")
Loading required package: rstanarm
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘rstanarm’
> 
> 
> 
> cleanEx()
> nameEx("stdranef")
> ### * stdranef
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stdranef
> ### Title: Extract standard deviation of "random" effects from an
> ###   'MCMCglmm' object
> ### Aliases: stdranef
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   # a simple MCMCglmm model
> ##D   data(PlodiaPO)
> ##D   PlodiaPO <- within(PlodiaPO, {
> ##D     PO2 <- cut(PO, quantile(PO, c(0, .33, .66, 1)))
> ##D     plate <- factor(plate)
> ##D   })
> ##D 
> ##D   m <- MCMCglmm(PO2 ~ 1, random = ~ FSfamily + plate,
> ##D     family = "ordinal", data = PlodiaPO,
> ##D     prior = list(
> ##D       R = list(V = 1, fix = 1),
> ##D       G = list(
> ##D         G1 = list(V = 1, nu = .002),
> ##D         G2 = list(V = 1, nu = .002)
> ##D       )
> ##D     ), verbose=FALSE, thin=1, pr=TRUE)
> ##D 
> ##D   # summary of the model
> ##D   summary(m)
> ##D 
> ##D   # examples of extracting standard deviations of
> ##D   # different random effects on the linear predictor metric
> ##D   # or after transformation to probabilities (only for ordinal)
> ##D   stdranef(m, which = list(1), type = "lp")
> ##D   stdranef(m, which = list(2), type = "lp")
> ##D   stdranef(m, which = list(1, 2, c(1, 2)), type = "lp")
> ##D   stdranef(m, type = "lp")
> ##D 
> ##D   ## error because no 3rd random effect
> ##D   #stdranef(m, which = list(1, 2, 3), type = "lp")
> ##D 
> ##D   stdranef(m, which = list("FSfamily", "plate"), type = "lp")
> ##D 
> ##D   # mean standard deviations on the probability metric
> ##D   # also the full distributions, if desired in the Data slot.
> ##D   res <- stdranef(m, type = "response")
> ##D   res$M # means
> ##D   hist(res$Data$FSfamily[, 1]) # histogram
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("tidy.TMB")
> ### * tidy.TMB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy.TMB
> ### Title: Tidying methods for TMB models
> ### Aliases: tidy.TMB
> 
> ### ** Examples
> 
> if (require("TMB")) {
+ 
+     ## Not run: 
+ ##D        runExample("simple",thisR=TRUE)
+ ##D        class(obj) <- "TMB"
+ ##D        tidy(obj,conf.int=TRUE,conf.method="wald")
+ ##D     
+ ## End(Not run)
+     ## Not run: tidy(obj,conf.int=TRUE,conf.method="uniroot")
+     ## Not run: tidy(obj,conf.int=TRUE,conf.method="profile")
+ }
Loading required package: TMB
Warning in library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘TMB’
> 
> 
> 
> cleanEx()
> nameEx("tidy.varFunc")
> ### * tidy.varFunc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy.varFunc
> ### Title: Tidy variance structure for the 'nlme' package.
> ### Aliases: tidy.varFunc tidy.varComb
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (require("nlme")) {
> ##D ChickWeight_arbitrary_group <- datasets::ChickWeight
> ##D ChickWeight_arbitrary_group$group_arb_n <-
> ##D   1 + (
> ##D     as.integer(ChickWeight_arbitrary_group$Chick) >
> ##D     median(as.integer(ChickWeight_arbitrary_group$Chick))
> ##D   )
> ##D ChickWeight_arbitrary_group$group_arb <- c("low", "high")[ChickWeight_arbitrary_group$group_arb_n]
> ##D 
> ##D fit_with_fixed <-
> ##D   lme(
> ##D     weight ~ Diet * Time,
> ##D     random = ~Time | Chick,
> ##D     data =ChickWeight_arbitrary_group,
> ##D     weights=varIdent(fixed=c("low"=5), form=~1|group_arb)
> ##D   )
> ##D # Show all parameters
> ##D tidy(fit_with_fixed)
> ##D # Exclude fixed parameters
> ##D tidy(fit_with_fixed) %>%
> ##D   filter(across(any_of("estimated"), ~.x))
> ##D }
> ## End(Not run)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.235 1.736 6.095 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
